[{:lociüÕ:projects[I"activemodel_proj:ETI"activerecord_proj;TI"backup_proj;TI"bundler_proj;TI"cancan_proj;TI"capistrano_proj;TI"compass_proj;TI"cucumber_prok;TI"devise_proj;TI"diaspora_proj;TI"haml_proj;TI"homebrew_proj;TI"jekyll_proj;TI"mongoid_proj;TI"nokogiri_proj;TI"omni_proj;TI"paperclip_proj;TI"redmine_proj;TI"rescue_proj;TI"rspec_proj;TI"sinatra_proj;TI"SiriProxy_proj;TI"state_machine_proj;TI"twitter_proj;TI"whenever_proj;T:options[I"
--var;TI"
--fun;TI"--fargs;T[W[I"end;FI"end;FI"end;FI"end;FI"end;FiI[I[	I";data//activemodel_proj/active_model/secure_password.rb;TiiI"¨            BCrypt::Engine::DEFAULT_COST
          end
          self.password_digest = BCrypt::Password.create(var, :cost => (var))
        end
      end
    end
  end
end;Fi[	I"9data//activemodel_proj/active_model/serialization.rb;Ti^I"Ç      var.each do |arglist|
        if var = send(var) then
          yield(var, var, var)
        end
      end
    end
  end
end;Fi[	I"Adata//activemodel_proj/active_model/validations/validates.rb;Ti£I"q          { :in => (var) }
        else
          { :with => (var) }
        end
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/aggregations.rb;TicI"Ø          else
            var.each { |arglist| self[var.first] = var.send(var.last) }
            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	@7idI"†            var.each { |arglist| self[var.first] = var.send(var.last) }
            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//activerecord_proj/active_record/associations/association.rb;Ti‘I"»          var = [reflection.foreign_key, reflection.type].compact
          var = create_scope.except(*(var.changed - var))
          var.assign_attributes(var)
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/associations/collection_association.rb;TiÁI"Ê        var = fetch_first_or_last_using_find?(var) ? (scope) : (load_target)
        var.send(var, *var).tap do |arglist|
          set_inverse_instance(var) if var.is_a?(ActiveRecord::Base)
        end
      end
    end
  end
end;Fi[	I"Vdata//activerecord_proj/active_record/associations/has_one_through_association.rb;TiI"ª              var.update(var)
            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	@BiI"ù            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	@Bi I"å              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	I"[data//activerecord_proj/active_record/associations/join_dependency/join_association.rb;TivI"Ä        
        def function(arglist)
          @var ||= reflection.scope_chain.reverse
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/associations/join_dependency/join_base.rb;TiI"v        
        def function(arglist)
          active_record.table_name
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/associations/join_dependency/join_part.rb;TiDI"ß        
        def function(arglist)
          @var[record_id(var)] ||= active_record.send(:instantiate, extract_record(var))
        end
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/associations/preloader/association.rb;TinI"§            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/associations/preloader/belongs_to.rb;TiI"t        
        def function(arglist)
          reflection.foreign_key
        end
      end
    end
  end
end;Fi[	I"[data//activerecord_proj/active_record/associations/preloader/collection_association.rb;TiI"±            var.loaded!
            var.target.concat(var)
            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	@XiI"ô            var.target.concat(var)
            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	I"\data//activerecord_proj/active_record/associations/preloader/has_and_belongs_to_many.rb;Ti:I"        def function(arglist)
          var = table[reflection.association_primary_key].eq(join_table[reflection.association_foreign_key])
          table.create_join(join_table, table.create_on(var))
        end
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/associations/preloader/has_many.rb;TiI"}        
        def function(arglist)
          reflection.active_record_primary_key
        end
      end
    end
  end
end;Fi[	I"Udata//activerecord_proj/active_record/associations/preloader/has_many_through.rb;TiI"ö        
        def function(arglist)
          super.each { |arglist| var.uniq! if reflection_scope.uniq_value }
        end
      end
    end
  end
end;Fi[	I"Ldata//activerecord_proj/active_record/associations/preloader/has_one.rb;TiI"ß        
        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]))
        end
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/associations/preloader/singular_association.rb;TiI"Ø            var = var.association(reflection.name)
            var.target = var
            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	@iiI"|            var.target = var
            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	I"Xdata//activerecord_proj/active_record/associations/preloader/through_association.rb;Ti4I"Ö            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/associations/preloader.rb;TiäI"d          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Ndata//activerecord_proj/active_record/associations/through_association.rb;TiFI"∫      def function(arglist)
        if reflection.nested? then
          raise(HasManyThroughNestedAssociationsAreReadonly.new(owner, reflection))
        end
      end
    end
  end
end;Fi[	I"Kdata//activerecord_proj/active_record/attribute_methods/primary_key.rb;TisI"~        def function(arglist)
          @var = (var and var.to_s)
          @var = nil
        end
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/attribute_methods/serialization.rb;TiÉI"}            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	@ziÑI"[          else
            super
          end
        end
      end
    end
  end
end;Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract/schema_dumper.rb;Ti4I"p          "'#{value.to_s(:db)}'"
        else
          var.inspect
        end
      end
    end
  end
end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/connection_specification.rb;TiLI"d            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/mysql2_adapter.rb;Ti„I"±      def function(arglist)
        @var ||= @var.info[:version].scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/connection_adapters/mysql_adapter.rb;TiÿI"Æ      def function(arglist)
        @var ||= @var.server_info.scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/connection_adapters/postgresql/array_parser.rb;Ti]I"≈        def function(arglist)
          unless (var.length == 0) then
            var.! and (var == "NULL") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	@Üi^I"ß          unless (var.length == 0) then
            var.! and (var == "NULL") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/postgresql/cast.rb;TièI"Å            var
          else
            "\"#{value.gsub(/"/, "\\\"")}\""
          end
        end
      end
    end
  end
end;Fi[	@ãiêI"v          else
            "\"#{value.gsub(/"/, "\\\"")}\""
          end
        end
      end
    end
  end
end;Fi[	I"`data//activerecord_proj/active_record/connection_adapters/postgresql/database_statements.rb;TiøI"è        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/connection_adapters/postgresql/quoting.rb;TiôI"Å          end
          var = (var.sub(/^-/, "") + " BC") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	I"bdata//activerecord_proj/active_record/connection_adapters/postgresql/referential_integrity.rb;TiI"˙              end.join(";")) rescue execute(tables.collect do |arglist|
                  "ALTER TABLE #{quote_table_name(name)} ENABLE TRIGGER USER"
                end.join(";"))
            end
          end
        end
      end
    end
  end
end;Fi[	@ñi I"≤                  "ALTER TABLE #{quote_table_name(name)} ENABLE TRIGGER USER"
                end.join(";"))
            end
          end
        end
      end
    end
  end
end;Fi[	@ñi!I"i                end.join(";"))
            end
          end
        end
      end
    end
  end
end;Fi[	I"^data//activerecord_proj/active_record/connection_adapters/postgresql/schema_statements.rb;TibI"Ñ            "#{column} AS alias_#{i}"
          end
          [super].concat(var).join(", ")
        end
      end
    end
  end
end;Fi[	I"Ndata//activerecord_proj/active_record/connection_adapters/schema_cache.rb;TiXI"µ        end
        @var.default_proc = Proc.new do |arglist|
          var[var] = table_exists?(var) ? (connection.primary_key(var)) : (nil)
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/sqlite3_adapter.rb;TiI"q          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	I"@data//activerecord_proj/active_record/locking/optimistic.rb;TioI"o            var[locking_column] ||= 0
          end
          var)
        end
      end
    end
  end
end;Fi[	I"Adata//activerecord_proj/active_record/locking/pessimistic.rb;TiI"r        transaction do |arglist|
          lock!(var)
          yield
        end
      end
    end
  end
end;Fi[	I"Hdata//activerecord_proj/active_record/migration/command_recorder.rb;TiÜI"√          @var.send(var, *var, &var)
        rescue NoMethodError => var
          raise(var, var.message.sub(/ for #<.*$/, " via proxy for #{@delegate}"))
        end
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/model_schema.rb;Ti8I"≤          "#{full_table_name_prefix}#{contained}#{undecorated_table_name(name)}#{table_name_suffix}"
        else
          var.table_name
        end
      end
    end
  end
end;Fi[	I"?data//activerecord_proj/active_record/nested_attributes.rb;TiÅI"_              send(var, var.except(*UNASSIGNABLE_KEYS))
            else
              raise(ArgumentError, "Cannot build association `#{association_name}'. Are you trying to build a polymorphic one-to-one association?")
            end
          end
        end
      end
    end
    
    # Assigns the given attributes to the collection association.;Fi[	I"5data//activerecord_proj/active_record/railtie.rb;TiEI"]                self.connection.schema_cache = var
              else
                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end
    ;Fi[	@µiFI"d              else
                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end
    
    initializer("active_record.set_configs") do |arglist|;Fi[	I"Idata//activerecord_proj/active_record/railties/controller_runtime.rb;Ti-I"†          var, var = super, var[:db_runtime]
          (var << ("ActiveRecord: %.1fms" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	I"Adata//activerecord_proj/active_record/relation/delegation.rb;Ti<I"¶              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods;Fi[	@ΩioI"¢          to_a.send(var, *var, &var)
        else
          arel.respond_to?(var) ? (arel.send(var, *var, &var)) : (super)
        end
      end
    end
  end
end;Fi[	I"=data//activerecord_proj/active_record/relation/merger.rb;TiqI"g          var
        else
          relation.where_values
        end
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/relation/query_methods.rb;Ti6I"‚      var.select { |arglist| Hash.===(var) }.each do |arglist|
        unless (var.values - [:asc, :desc]).empty? then
          raise(ArgumentError, "Direction should be :asc or :desc")
        end
      end
    end
  end
end;Fi[	I"=data//activerecord_proj/active_record/scoping/default.rb;TiqI"Á                    var.merge(unscoped { |arglist| var.call })
                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        ;Fi[	@»irI"∆                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist);Fi[	@»iÜI"á            yield)
          ensure
            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	@»iáI"y          ensure
            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	I";data//activerecord_proj/active_record/scoping/named.rb;TiòI"‡            var = var.respond_to?(:call) ? (unscoped { |arglist| var.call(*var) }) : (var)
            var = all.merge(var)
            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	@—iôI"Ö            var = all.merge(var)
            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	I"3data//activerecord_proj/active_record/store.rb;TiSI"ë          var.with_indifferent_access
        else
          ActiveSupport::HashWithIndifferentAccess.new
        end
      end
    end
  end
end;Fi[	I"\data//activerecord_proj/rails/generators/active_record/migration/migration_generator.rb;Ti4I"≠      def function(arglist)
        unless file_name =~ /^[_a-z0-9]+$/ then
          raise(IllegalMigrationNameError.new(file_name))
        end
      end
    end
  end
end;Fi[	I"6data//backup_proj/backup/configuration/helpers.rb;TilI"~          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/notifier/campfire.rb;TiI"≥        # Returns the url for the specified room (in JSON format)
        def function(arglist)
          "/room/#{room_id}/#{action}.json"
        end
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/notifier/hipchat.rb;TiZI"“        var = HipChat::Client.new(token)
        [rooms_notified].flatten.each do |arglist|
          var[var].send(from, var, :color => (var), :notify => (notify_users))
        end
      end
    end
  end
end;Fi[	I"3data//backup_proj/backup/storage/cloudfiles.rb;TiBI"        transferred_files_for(var) do |arglist|
          Logger.message(("#{storage_name} started removing '#{local_file}' " + "from container '#{container}'."))
          connection.delete_object(container, File.join(var, var))
        end
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/storage/dropbox.rb;TiàI"«          var)
        rescue => var
          raise(Errors::Storage::Dropbox::AuthenticationError.wrap(var, "Could not create or authenticate a new session"))
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/storage/ftp.rb;TidI"ñ            var.mkdir(var.join("/"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ÎieI"v          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/storage/local.rb;Ti=I"Ï        else
          Logger.warn(Errors::Storage::Local::TransferError.new("            Local File Copy Warning!\n            The final backup file(s) for '#{@model.label}' (#{@model.trigger})\n            will be *copied* to '#{remote_path_for(@package)}'\n            To avoid this, when using more than one Storage, the 'Local' Storage\n            should be added *last* so the files may be *moved* to their destination.\n"))
          @var = :cp
        end
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/storage/ninefold.rb;TiWI"ß          end
        else
          raise(Errors::Storage::Ninefold::NotFoundError, "Directory at '#{remote_path}' not found")
        end
      end
    end
  end
end;Fi[	I"+data//backup_proj/backup/storage/s3.rb;TiFI"        transferred_files_for(var) do |arglist|
          Logger.message(("#{storage_name} started removing " + "'#{local_file}' from bucket '#{bucket}'."))
          connection.delete_object(bucket, File.join(var, var))
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/storage/scp.rb;TiLI"¬        end
        unless var.empty? then
          raise(Errors::Storage::SCP::SSHError, ("Net::SSH reported the following errors:\n" + var.join("\n")))
        end
      end
    end
  end
end;Fi[	I"-data//backup_proj/backup/storage/sftp.rb;TiVI"†            var.mkdir!(var.join("/"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@¸iWI"          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/cloud/base.rb;TiúI"˜                else
                  MUTEX.synchronize do |arglist|
                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end
        ;Fi[	@iùI"˙                  MUTEX.synchronize do |arglist|
                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end
        
        class LocalFile;Fi[	@i»I"•              var if var.unpack("U").!.! rescue @var = true
                "\xEF\xBF\xBD"
            end.join
          end
        end
      end
    end
  end
end;Fi[	@i…I"n                "\xEF\xBF\xBD"
            end.join
          end
        end
      end
    end
  end
end;Fi[	I"9data//backup_proj/backup/syncer/cloud/cloud_files.rb;TiBI"ú        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "Rackspace"
        end
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/syncer/cloud/s3.rb;Ti9I"ñ        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "AWS"
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/base.rb;Ti+I"ñ        # Returns Rsync syntax for invoking "archive" mode
        def function(arglist)
          "--archive"
        end
      end
    end
  end
end;Fi[	I"3data//backup_proj/backup/syncer/rsync/local.rb;Ti-I"¬        # concatenated, ready for the CLI
        def function(arglist)
          ([archive_option, mirror_option] + additional_options).compact.join(" ")
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/pull.rb;TiI"©        # Return expanded @path, since this path is local
        def function(arglist)
          @var ||= File.expand_path(@var)
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/push.rb;TijI"}        def function(arglist)
          @var.delete if @var
          @var = nil
        end
      end
    end
  end
end;Fi[	I"-data//bundler_proj/bundler/deployment.rb;Ti$I"€          (var << var.to_s)
          (var << "--without #{bundle_without.join(" ")}") unless var.empty?
          run("cd #{app_path} && #{bundle_cmd} install #{args.join(" ")}")
        end
      end
    end
  end
end;Fi[	I"(data//bundler_proj/bundler/graph.rb;TiéI"’          rescue ArgumentError => var
            $stderr.puts("Unsupported output format. See Ruby-Graphviz/lib/graphviz/constants.rb")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	@ièI"Ø            $stderr.puts("Unsupported output format. See Ruby-Graphviz/lib/graphviz/constants.rb")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	I",data//bundler_proj/bundler/installer.rb;Ti¿I"»        var.puts("path = File.expand_path('..', __FILE__)")
        var.each do |arglist|
          var.puts("$:.unshift File.expand_path(\"#{path}/#{path}\")")
        end
      end
    end
  end
end;Fi[	I"+data//bundler_proj/bundler/resolver.rb;TiÎI"›            if var.include?(var) then
              debug { |arglist| "    -> Jumping to: #{savepoint}" }
              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"/data//bundler_proj/bundler/ruby_version.rb;Ti+I"Ω            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion;Fi[	I"7data//bundler_proj/bundler/rubygems_integration.rb;Ti°I"∫            @var = RubygemsIntegration::Legacy.new
          else
            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  
  class << self;Fi[	I"*data//bundler_proj/bundler/runtime.rb;Ti>I"Ï              var = $1
              raise(var) if (var.autorequire or (var and var.gsub("-", "/").!=(var)))
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"7data//bundler_proj/bundler/source/git/git_proxy.rb;Ti}I"˝            in_path { |arglist| yield }
          else
            raise(GitError, "The git source #{uri} is not yet checked out. Please run `bundle install` before trying to start your application")
          end
        end
      end
    end
  end
end;Fi[	@3i~I"’          else
            raise(GitError, "The git source #{uri} is not yet checked out. Please run `bundle install` before trying to start your application")
          end
        end
      end
    end
  end
end;Fi[	I"-data//bundler_proj/bundler/source/git.rb;Ti⁄I"Æ      def function(arglist)
        @var ||= GitProxy.new(cache_path, uri, ref, cached_revision) do |arglist|
          allow_git_ops?
        end
      end
    end
  end
end;Fi[	I"8data//bundler_proj/bundler/source/path/installer.rb;Ti#I"            Bundler.mkdir_p("#{Bundler.rubygems.gem_dir}/bin")
            spec.executables.each do |arglist|
              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end
end;Fi[	@;i$I"”            spec.executables.each do |arglist|
              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end
end;Fi[	@;i%I"§              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end
end;Fi[	I".data//bundler_proj/bundler/source/path.rb;TiªI"Ì            var = " at #{$1}" if var.inspect =~ /@(.*:\d+)/
            var = "#{type} hook#{location} failed for #{installer.spec.full_name}"
            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	@BiºI"±            var = "#{type} hook#{location} failed for #{installer.spec.full_name}"
            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	I"2data//bundler_proj/bundler/source/rubygems.rb;Ti“I"s          var)
        ensure
          Bundler.rubygems.sources = var
        end
      end
    end
  end
end;Fi[	I"%data//bundler_proj/bundler/ui.rb;TimI"}          @var.info("with native extensions ")
        else
          @var.debug(var)
        end
      end
    end
  end
end;Fi[	I"@data//bundler_proj/bundler/vendor/thor/actions/directory.rb;Ti^I"¿            var = base.template(var, var[(0..-4)], config, &@var)
          else
            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	@Mi_I"~          else
            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//bundler_proj/bundler/vendor/thor/actions/inject_into_file.rb;TiYI"“          if (var or var.include?(replacement).!) then
            var.gsub!(var, var)
            File.open(destination, "wb") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	@RiZI"õ            var.gsub!(var, var)
            File.open(destination, "wb") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	I"Tdata//bundler_proj/bundler/vendor/thor/core_ext/hash_with_indifferent_access.rb;Ti=I"ä          var.empty? ? (self[$1].!.!) : ((self[$1] == var.first))
        else
          self[var]
        end
      end
    end
  end
end;Fi[	I"Ddata//bundler_proj/bundler/vendor/thor/core_ext/ordered_hash.rb;TiRI"i        
        def function(arglist)
          @var.empty?
        end
      end
    end
  end
end;Fi[	I"=data//bundler_proj/bundler/vendor/thor/parser/options.rb;Ti“I"                return var.lazy_default
              else
                raise(MalformattedArgumentError, "No value provided for option '#{switch}'")
              end
            end
          end
        end
      end
      @var.delete(var)
      send(:"parse_#{var.type}", var);Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/color.rb;TiçI"e          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	I"9data//bundler_proj/bundler/vendor/thor/shell/html.rb;Ti{I"e          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	I"3data//bundler_proj/bundler/vendor/thor/util.rb;TiZI"ﬂ              ENV["APPDATA"]
            else
              File.expand_path("~") rescue File::ALT_SEPARATOR ? ("C:/") : ("/")
            end
          end
        end
      end
    end
    
    def self.thor_root(arglist);Fi[	I"?data//cancan_proj/cancan/model_adapters/mongoid_adapter.rb;Ti&I"⁄                var.or(var.conditions)
              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end;Fi[	@ii'I"∑              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ii(I"À                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods;Fi[	@ii)I"Æ              end
            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods
  include(CanCan::ModelAdditions::ClassMethods);Fi[	I"%data//cancan_proj/cancan/rule.rb;Ti0I"√              matches_conditions_hash?(var)
            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	@riÄI"…                end
              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    ;Fi[	@riÅI"œ              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"4data//capistrano_proj/capistrano/cli/execute.rb;TiQI"k          abort(var.message)
        else
          raise(var)
        end
      end
    end
  end
end;Fi[	I"4data//capistrano_proj/capistrano/cli/options.rb;Ti«I"U          nil
        else
          var
        end
      end
    end
  end
end;Fi[	I"/data//capistrano_proj/capistrano/cli/ui.rb;Ti#I"∫            var.default = "y"
            var.validate = /(y(es)?)|(no?)|(a(bort)?|\n)/i
            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	@i$I"ú            var.validate = /(y(es)?)|(no?)|(a(bort)?|\n)/i
            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	I"0data//capistrano_proj/capistrano/command.rb;TiI"ª        options[:env].inject("env") do |arglist|
          var = var.to_s.gsub(/[ "]/) { |arglist| "\#{m}" }
          (var << " #{name}=#{value}")
        end
      end
    end
  end
end;Fi[	I"Ldata//capistrano_proj/capistrano/configuration/actions/file_transfer.rb;Ti.I"Ò          execute_on_servers(var) do |arglist|
            var = var.map { |arglist| sessions[var] }
            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	@ái/I"¬            var = var.map { |arglist| sessions[var] }
            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//capistrano_proj/capistrano/configuration/actions/inspect.rb;Ti/I"X            end
          end
          var
        end
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/configuration/actions/invocation.rb;TiI"w            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@èiI"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/configuration/callbacks.rb;TiãI"≠          (var << " for `#{task.fully_qualified_name}'") if var
          logger.trace(var)
          var.each { |arglist| var.call }
        end
      end
    end
  end
end;Fi[	I"Bdata//capistrano_proj/capistrano/configuration/connections.rb;TiÿI"õ        rescue Exception => var
          raise unless var
          (var << { :server => (var), :error => (var) })
        end
      end
    end
  end
end;Fi[	I">data//capistrano_proj/capistrano/configuration/loading.rb;TijI"ˆ                  instance_eval(&var[:proc])
                else
                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end
      ;Fi[	@öikI"                else
                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,;Fi[	@öiºI"ª        if self.class.current_feature then
          var = self.class.recipes_per_feature[self.class.current_feature] ||= []
          (var << var)
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/configuration/variables.rb;TiyI"Ñ          self[var]
        else
          method_missing_without_variables(var, *var, &var)
        end
      end
    end
  end
end;Fi[	I"7data//capistrano_proj/capistrano/ext/multistage.rb;Ti3I"P          File.open(var, "w") do |arglist|
            var.puts("# #{name.upcase}-specific deployment configuration")
            var.puts("# please put general deployment config in config/deploy.rb")
          end
        end
      end
    end
  end
  on(:start, "multistage:ensure", :except => ((stages + ["multistage:prepare"])))
end;Fi[	I"Idata//capistrano_proj/capistrano/recipes/deploy/remote_dependency.rb;TimI"ì        rescue Capistrano::CommandError => var
          @var = false
          @var = var.hosts.join(", ")
        end
      end
    end
  end
end;Fi[	I"Cdata//capistrano_proj/capistrano/recipes/deploy/scm/accurev.rb;Ti~I"Æ          
          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	@™iI"£          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/scm/base.rb;Ti≤I"ä          var = variable(:scm_arguments)
          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/bzr.rb;TiKI"ò        
        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("-r #{revision}".chomp)
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/cvs.rb;TiâI"à          var = var.pop
          var = var.join("/")
          "mkdir -p #{dest} && cd #{dest}"
        end
      end
    end
  end
end;Fi[	I"Adata//capistrano_proj/capistrano/recipes/deploy/scm/darcs.rb;Ti[I"j            nil
          else
            "-v"
          end
        end
      end
    end
  end
end;Fi[	@∏i\I"Z          else
            "-v"
          end
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/git.rb;TiòI"©        # command-line switch for "quiet" ("-q").
        def function(arglist)
          variable(:scm_verbose) ? (nil) : ("-q")
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/scm/mercurial.rb;TinI"«          @var ||= (variable(:scm_password) or if variable(:scm_prefer_prompt) then
            Capistrano::CLI.password_prompt("hg password: ")
          end)
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/scm/none.rb;Ti$I"¶        # log: There's no log, so it just echos from and to.
        def function(arglist)
          "No SCM: #{from} - #{to}"
        end
      end
    end
  end
end;Fi[	I"Ddata//capistrano_proj/capistrano/recipes/deploy/scm/perforce.rb;TiÜI"t            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	@∆iáI"Y          else
            var
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//capistrano_proj/capistrano/recipes/deploy/scm/subversion.rb;TitI"–        
        def function(arglist)
          @var ||= (variable(:scm_password) or (variable(:password) or Capistrano::CLI.password_prompt("Subversion password: ")))
        end
      end
    end
  end
end;Fi[	I";data//capistrano_proj/capistrano/recipes/deploy/scm.rb;TiI"õ          end)
        rescue LoadError
          raise(Capistrano::Error, "could not find any SCM named `#{scm}'")
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/strategy/base.rb;TiOI"å        # and not a pseudo-id.
        def function(arglist)
          configuration[:real_revision]
        end
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/recipes/deploy/strategy/checkout.rb;TiI"Ÿ        # Returns the SCM's checkout command for the revision to deploy.
        def function(arglist)
          @var ||= source.checkout(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/strategy/copy.rb;Ti"I"í        def function(arglist)
          upload(filename, remote_filename)
          decompress_remote_file
        end
      end
    end
  end
end;Fi[	I"Gdata//capistrano_proj/capistrano/recipes/deploy/strategy/export.rb;TiI"’        # Returns the SCM's export command for the revision to deploy.
        def function(arglist)
          @var ||= source.export(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	I"Gdata//capistrano_proj/capistrano/recipes/deploy/strategy/remote.rb;Ti+I"‘        # revision being deployed to the REVISION file on each host.
        def function(arglist)
          "(echo #{revision} > #{configuration[:release_path]}/REVISION)"
        end
      end
    end
  end
end;Fi[	I"Mdata//capistrano_proj/capistrano/recipes/deploy/strategy/remote_cache.rb;Ti0I"è        
        def function(arglist)
          @var ||= Array(configuration.fetch(:copy_exclude, []))
        end
      end
    end
  end
end;Fi[	I"Vdata//capistrano_proj/capistrano/recipes/deploy/strategy/unshared_remote_cache.rb;TiI"~        
        def function(arglist)
          configuration[:repository_cache]
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/strategy.rb;TiI"•          end)
        rescue LoadError
          raise(Capistrano::Error, "could not find any strategy named `#{strategy}'")
        end
      end
    end
  end
end;Fi[	I"7data//capistrano_proj/capistrano/recipes/deploy.rb;TiyI"æ                :perforce
              else
                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end;Fi[	@ÈizI"®              else
                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@Èi{I"·                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your;Fi[	@Èi|I"∑              end
            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your
# own dependencies.;Fi[	I"Udata//compass_proj/compass/app_integration/stand_alone/configuration_defaults.rb;TiI"k        
        def function(arglist)
          ".sass-cache"
        end
      end
    end
  end
end;Fi[	I"Hdata//compass_proj/compass/app_integration/stand_alone/installer.rb;Ti?I"k        
        def function(arglist)
          @var.compile?
        end
      end
    end
  end
end;Fi[	I"9data//compass_proj/compass/configuration/comments.rb;Ti-I"k          "\n# If you prefer the indented syntax, you might want to regenerate this\n# project again passing --syntax sass, or you can uncomment this:\n# preferred_syntax = :sass\n# and then run:\n# sass-convert -R --from scss --to sass #{top_level.sass_dir} scss && rm -rf sass && mv scss sass\n"
        else
          ""
        end
      end
    end
  end
end;Fi[	I"5data//compass_proj/compass/configuration/data.rb;TiI"Ò            else
              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	@˚i∞I"”        else
          if (var.size > 0) then
            raise(Error, "Illegal configuration attributes: #{illegal_attrs.map { |a| a.inspect }.join(", ")}")
          end
        end
      end
    end
  end
end;Fi[	@˚i±I"∆          if (var.size > 0) then
            raise(Error, "Illegal configuration attributes: #{illegal_attrs.map { |a| a.inspect }.join(", ")}")
          end
        end
      end
    end
  end
end;Fi[	I"8data//compass_proj/compass/configuration/helpers.rb;Ti1I"                    Compass::AppIntegration.lookup(var).configuration
                  else
                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end;Fi[	@i2I"⁄                  else
                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end
      ;Fi[	@i3I"‡                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end
      
      # Support for testing.;Fi[	I"<data//compass_proj/compass/configuration/inheritance.rb;Ti–I"c            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	I">data//compass_proj/compass/configuration/serialization.rb;TiOI"ﬁ      def function(arglist)
        if (http_images_path == :relative) then
          $stderr.puts("DEPRECATION WARNING: Please set relative_assets = true to enable relative paths.")
        end
      end
    end
  end
end;Fi[	I"Kdata//compass_proj/compass/sass_extensions/monkey_patches/traversal.rb;TiI"Ñ            var.visit_depth_first(var)
          end
          var.up(self) if children.any?
        end
      end
    end
  end
end;Fi[	I"Tdata//compass_proj/compass/sass_extensions/sprites/engines/chunky_png_engine.rb;TiI"¥        def function(arglist)
          construct_sprite if canvas.nil?
          canvas.save(var, Compass.configuration.chunky_png_options)
        end
      end
    end
  end
end;Fi[	I"Bdata//compass_proj/compass/sass_extensions/sprites/engines.rb;TiI"⁄        
        def function(arglist)
          raise(::Compass::Error, "You must impliment save(filename)")
        end
      end
    end
  end
end
require("compass/sass_extensions/sprites/engines/chunky_png_engine");Fi[	I"@data//compass_proj/compass/sass_extensions/sprites/image.rb;TiïI"Ø        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end
      end
    end
  end
end;Fi[	I"Hdata//compass_proj/compass/sass_extensions/sprites/image_methods.rb;Ti I"À        # Return and array of image names that make up this sprite
        def function(arglist)
          image_names.map { |arglist| File.basename(var, ".png") }
        end
      end
    end
  end
end;Fi[	I"Ddata//compass_proj/compass/sass_extensions/sprites/image_row.rb;Ti/I"Å        
        def function(arglist)
          ((total_width + var.width) <= max_width)
        end
      end
    end
  end
end;Fi[	I"Idata//compass_proj/compass/sass_extensions/sprites/layout_methods.rb;Ti†I"å        
        def function(arglist)
          @var.map { |arglist| (var.width + var.offset) }.max
        end
      end
    end
  end
end;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/row_fitter.rb;TiPI"                        var = true
                        (var << var)
                        throw(:done)
                      end
                    end
                  end
                end
              end
            end
          end while var;Fi[	@$iQI"Î                        (var << var)
                        throw(:done)
                      end
                    end
                  end
                end
              end
            end
          end while var
        end;Fi[	@$iWI"f              end
            end
          end while var
        end
      end
    end
  end
end;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/sprite_map.rb;TiLI"÷          @var ||= Compass.configuration.sprite_engine.to_s.scan(/([^_.]+)/).flatten.map do |arglist|
            "#{chunk[0].chr.upcase}#{chunk[(1..-1)]}"
          end.join
        end
      end
    end
  end
end;Fi[	I"Idata//compass_proj/compass/sass_extensions/sprites/sprite_methods.rb;TiÄI"¯        def function(arglist)
          if options[:compass] and (options[:compass][:logger] and options[:quiet].!) then
            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	@.iÅI"⁄          if options[:compass] and (options[:compass][:logger] and options[:quiet].!) then
            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/ast/outline_table.rb;Ti∞I"j        
        def function(arglist)
          (index == 0)
        end
      end
    end
  end
end;Fi[	I".data//cucumber_prok/cucumber/ast/table.rb;TiÉI"b        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	I"-data//cucumber_prok/cucumber/cli/main.rb;TiNI"«          exit!(1) if Cucumber.wants_to_quit
          Cucumber.wants_to_quit = true
          STDERR.puts("\nExiting... Interrupt again to exit immediately.")
        end
      end
    end
  end
end;Fi[	I"3data//cucumber_prok/cucumber/formatter/html.rb;Ti7I"l            (var << var)
          end
          var.join("\n")
        end
      end
    end
  end
end;Fi[	I":data//cucumber_prok/cucumber/formatter/interceptor.rb;Ti@I"}            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@?iAI"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"Adata//cucumber_prok/cucumber/formatter/ordered_xml_markup.rb;TiI"¨        var.each do |arglist|
          var = (var[var.to_sym] or var[var])
          (@var << " #{k}=\"#{_attr_value(v)}\"") if var
        end
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/formatter/unicode.rb;TiDI"˚              rescue Iconv::IllegalSequence => var
                STDERR.cucumber_puts("WARNING: #{e.message}")
                cucumber_puts(*var)
              end
            end
          end
        end
      end
      
      Kernel.extend(self);Fi[	I"4data//cucumber_prok/cucumber/formatter/usage.rb;TixI"¡        @var.unmatched_step_definitions.each do |arglist|
          var = StepDefKey.new(var.regexp_source, var.file_colon_line)
          @var[var] = []
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/js_support/js_language.rb;TißI"å        else
          var = var[0][/(^.*\/?features)/, 0]
          var ? ("#{path}/../") : ("../")
        end
      end
    end
  end
end;Fi[	I"Fdata//cucumber_prok/cucumber/language_support/language_methods.rb;TirI"ó          var.invoke(var, var, &var)
        rescue Exception => var
          var ? (var.fail!(var)) : (raise)
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/parser/gherkin_builder.rb;TiOI"f          end
          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/rb_support/rb_language.rb;TißI"U          end
        else
          var
        end
      end
    end
  end
end;Fi[	I"Gdata//cucumber_prok/cucumber/rb_support/regexp_argument_matcher.rb;TiI"U          end
        else
          nil
        end
      end
    end
  end
end;Fi[	I"@data//cucumber_prok/cucumber/rspec/disable_option_parser.rb;TiI"é          @var = true
          define_method(var) { |arglist| NEUTERED_RSPEC }
          @var = false
        end
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/runtime/results.rb;Ti1I"⁄          scenarios(:passed).any?
        else
          (scenarios(:failed).any? or (steps(:failed).any? or (@var.strict? and (steps(:undefined).any? or steps(:pending).any?))))
        end
      end
    end
  end
end;Fi[	I"9data//cucumber_prok/cucumber/runtime/support_code.rb;Ti≥I"U          end
        else
          nil
        end
      end
    end
  end
end;Fi[	I"<data//cucumber_prok/cucumber/wire_support/connection.rb;Ti8I"¸          @var ||= TCPSocket.new(@var.host, @var.port)
        rescue Errno::ECONNREFUSED => var
          raise(ConnectionError, "Unable to contact the wire server at #{@config.host}:#{@config.port}. Is it up?")
        end
      end
    end
  end
end;Fi[	I"Hdata//cucumber_prok/cucumber/wire_support/wire_protocol/requests.rb;TipI"á          
          def function(arglist)
            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	@hiqI"|          def function(arglist)
            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	I"4data//devise_proj/devise/controllers/helpers.rb;TiËI"®      def function(arglist)
        Devise.mappings.each do |arglist|
          instance_variable_set("@current_#{m.name}", nil)
        end
      end
    end
  end
end;Fi[	I"9data//devise_proj/devise/controllers/scoped_views.rb;TiI"h        
        def function(arglist)
          @var = var
        end
      end
    end
  end
end;Fi[	I"(data//devise_proj/devise/mapping.rb;TiÇI"á          @var = (self.routes - Array(var).map(&var))
        else
          @var = self.routes
        end
      end
    end
  end
end;Fi[	I"7data//devise_proj/devise/models/authenticatable.rb;Ti«I"∫          loop do |arglist|
            var = Devise.friendly_token
            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	@vi»I"û            var = Devise.friendly_token
            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	I"@data//devise_proj/devise/models/database_authenticatable.rb;TijI"â        # the proper fields.
        def function(arglist)
          find_for_authentication(var)
        end
      end
    end
  end
end;Fi[	I"4data//devise_proj/devise/models/registerable.rb;TiI"x        # new with params.
        def function(arglist)
          new(var)
        end
      end
    end
  end
end;Fi[	I"0data//devise_proj/devise/omniauth/config.rb;Ti,I"ã          ::OmniAuth::Strategies.const_get(var)
        else
          raise(StrategyNotFound, var)
        end
      end
    end
  end
end;Fi[	I"&data//devise_proj/devise/rails.rb;Ti.I"¿        # We can get rid of this once we support only Rails > 3.2
        def function(arglist)
          (super or routes.url_helpers.respond_to?(var))
        end
      end
    end
  end
end;Fi[	I"Ddata//devise_proj/devise/strategies/database_authenticatable.rb;TiI"        if validate(var) { |arglist| var.valid_password?(password) } then
          var.after_database_authentication
          success!(var)
        end
      end
    end
  end
end
Warden::Strategies.add(:database_authenticatable, Devise::Strategies::DatabaseAuthenticatable);Fi[	I">data//diaspora_proj/controllers/application_controller.rb;TiiI"î          unless var.nil? then
            @var = var
            break
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"8data//diaspora_proj/controllers/likes_controller.rb;Ti7I"Í      Comment.find(params[:comment_id]).tap do |arglist|
        unless current_user.find_visible_shareable_by_id(Post, var.commentable_id) then
          raise(ActiveRecord::RecordNotFound.new)
        end
      end
    end
  end
end;Fi[	I"8data//diaspora_proj/controllers/users_controller.rb;TiMI"1                    flash[:notice] = I18n.t("users.update.follow_settings_changed")
                  else
                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end
      end;Fi[	@êiNI"Ê                  else
                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end
      end
    else;Fi[	@êiOI"¸                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end
      end
    else
      if var = params[:reorder_aspects] then;Fi[	I"0data//diaspora_proj/helpers/posts_helper.rb;TiI"        else
          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"1data//diaspora_proj/helpers/stream_helper.rb;TiI"	            stream_path(:max_time => (time_for_scroll(@var)))
          else
            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"2data//diaspora_proj/models/jobs/http_multi.rb;TiI"          Resque.enqueue(Jobs::HttpMulti, var, var, var.failed_people, var, (var + 1))
        else
          Rails.logger.info("event=http_multi_abandon sender_id=#{user_id} failed_recipient_ids='[#{person_ids.join(", ")}] '")
        end
      end
    end
  end
end;Fi[	I";data//diaspora_proj/models/jobs/mail/also_commented.rb;TiI"ö      def self.perform(arglist)
        if var = Notifier.also_commented(var, var, var) then
          var.deliver
        end
      end
    end
  end
end;Fi[	I"%data//haml_proj/haml/compiler.rb;TiI"Ö              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">"
            else
              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
            end
          end
        end
      end
    end
    
    # Evaluates `text` in the context of the scope object, but;Fi[	I"$data//haml_proj/haml/filters.rb;TiI"´      class << self
        def function(arglist)
          super.sub(/^#coding:.*?\n/, "")
        end
      end
    end
  end
end
begin
  (require("haml/filters/maruku");Fi[	I"#data//homebrew_proj/cleaner.rb;Ti:I"»              var.unlink unless @var.skip_clean?(var)
            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end;Fi[	@©i;I"°            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end
class Pathname;Fi[	@©i<I"∂              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end
class Pathname
  alias_method(:orig_unlink, :unlink);Fi[	I"'data//homebrew_proj/cmd/cleanup.rb;TiLI"ñ          else
            puts("Removing: #{pn}...")
            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"&data//homebrew_proj/cmd/search.rb;Ti3I"          if ($found == 0) and blacklisted?(var).! then
            puts("No formula found for \"#{query}\". Searching open pull requests...")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@≥iWI"≈        if var.include?(var) then
          var = ((HOMEBREW_REPOSITORY + "Library/Aliases") + var).readlink.basename(".rb").to_s
          var.include?(var)
        end
      end
    end
  end
end;Fi[	I"(data//homebrew_proj/cmd/versions.rb;TiI"⁄          print("#{version.to_s.ljust(8)} ")
          print(Tty.reset.to_s)
          puts("git checkout #{sha} #{f.pretty_relative_path}")
        end
      end
    end
  end
end
class Formula
  def function(arglist);Fi[	I",data//homebrew_proj/extend/fileutils.rb;TiCI"            end
          else
            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	@ªiDI"o          else
            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	I"+data//homebrew_proj/extend/pathname.rb;TiI"¶            raise("            Could not symlink file: #{src.expand_path}\n            #{dirname} is not writable. You should change its permissions.\n".undent)
          else
            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"data//homebrew_proj/keg.rb;Ti˘I"ƒ            unless resolve_any_conflicts(var) then
              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end
end;Fi[	@√i˙I"≤              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	@√i˚I"              Find.prune
            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	I"1data//homebrew_proj/keg_fix_install_names.rb;TiI"                  system(MacOS.locate("install_name_tool"), "-change", var, var, var)
                else
                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end;Fi[	@ iI"æ                else
                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@ iI"¨                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end
  end
  ;Fi[	@ iI"y                end
              end
            end
          end
        end
      end
    end
  end
  
  private;Fi[	I"Jdata//homebrew_proj/vendor/multi_json/adapters/nsjsonserialization.rb;Ti I"•          NSMutableString.alloc.initWithData(var, :encoding => (NSUTF8StringEncoding))
        else
          super(var, var)
        end
      end
    end
  end
end;Fi[	I">data//homebrew_proj/vendor/multi_json/adapters/ok_json.rb;Ti)I"U          end
        else
          var
        end
      end
    end
  end
end;Fi[	I",data//jekyll_proj/jekyll/convertible.rb;TiYI"ú        end
        if var = var[var.data["layout"]] then
          var.include?(var) ? (var = nil) : ((var << var))
        end
      end
    end
  end
end;Fi[	I"1data//jekyll_proj/jekyll/migrators/drupal.rb;Ti4I"„              var.puts("layout: refresh")
              var.puts("refresh_to_post_id: /#{(time.strftime("%Y/%m/%d/") + slug)}")
              var.puts("---")
            end
          end
        end
      end
    end
  end
end;Fi[	@‹i5I"π              var.puts("refresh_to_post_id: /#{(time.strftime("%Y/%m/%d/") + slug)}")
              var.puts("---")
            end
          end
        end
      end
    end
  end
end;Fi[	@‹i6I"h              var.puts("---")
            end
          end
        end
      end
    end
  end
end;Fi[	I"/data//jekyll_proj/jekyll/migrators/enki.rb;TiI"Ñ          end.to_yaml)
          var.puts("---")
          var.puts(var[:body].delete("\r"))
        end
      end
    end
  end
end;Fi[	I"1data//jekyll_proj/jekyll/migrators/joomla.rb;TiI"v          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"3data//jekyll_proj/jekyll/migrators/mephisto.rb;Ti&I"v          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"-data//jekyll_proj/jekyll/migrators/mt.rb;Ti,I"ê          "textile"
        else
          ((var == "0") or var.include?("richtext")) ? ("html") : (var)
        end
      end
    end
  end
end;Fi[	I".data//jekyll_proj/jekyll/migrators/rss.rb;TiI"á          var.puts(var.to_yaml)
          var.puts("---\n")
          var.puts(var.description)
        end
      end
    end
  end
end;Fi[	I"6data//jekyll_proj/jekyll/migrators/textpattern.rb;TiI"v          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"/data//jekyll_proj/jekyll/migrators/typo.rb;TiI"Ñ          end.to_yaml)
          var.puts("---")
          var.puts(var[:body].delete("\r"))
        end
      end
    end
  end
end;Fi[	I"4data//jekyll_proj/jekyll/migrators/wordpress.rb;TiJI"ˇ                (var << clean_entities(var[:name]))
              else
                (var << var[:name])
              end
            end
          end
        end
      end
      var = []
      if var[:comments] and (var[:comment_count].to_i > 0) then;Fi[	I"%data//jekyll_proj/jekyll/site.rb;Ti|I"$              (pages << Page.new(self, self.source, var, var))
            else
              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    
    # Read all the files in <source>/<dir>/_posts and create a new Post;Fi[	I"-data//jekyll_proj/jekyll/tags/include.rb;TiI"È          var.stack { |arglist| var.render(var) }
        else
          "Included file '#{@file}' not found in _includes directory"
        end
      end
    end
  end
end
Liquid::Template.register_tag("include", Jekyll::IncludeTag);Fi[	I"Adata//mongoid_proj/lib/mongoid/atomic/paths/embedded/many.rb;Ti'I"˙            var = parent.atomic_position
            var = document.new_record? ? ("") : (".#{document._index}")
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}#{locator}"
          end
        end
      end
    end
  end
end;Fi[	@i(I"—            var = document.new_record? ? ("") : (".#{document._index}")
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}#{locator}"
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/atomic/paths/embedded/one.rb;Ti&I"»          def function(arglist)
            var = parent.atomic_position
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}"
          end
        end
      end
    end
  end
end;Fi[	@i'I"®            var = parent.atomic_position
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}"
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/atomic/paths/embedded.rb;TiBI"ñ        
        def function(arglist)
          document._root.updates_requested?.! and only_root_selector?.!
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/atomic/paths/root.rb;Ti/I"¶        # @since 2.1.0
        def function(arglist)
          { "_id" => (document._id) }.merge!(document.shard_key_selector)
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/attributes/processing.rb;TiºI"y          yield)
        ensure
          self.mass_assignment_options = nil
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/attributes/readonly.rb;Ti2I"ü        # @since 3.0.0
        def function(arglist)
          var.each { |arglist| (readonly_attributes << var.to_s) }
        end
      end
    end
  end
end;Fi[	I"1data//mongoid_proj/lib/mongoid/components.rb;Ti\I"Æ      def function(arglist)
        @var ||= MODULES.flat_map do |arglist|
          var.instance_methods.map { |arglist| var.to_sym }
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/config/validators/option.rb;TiI"À        def function(arglist)
          unless Config.settings.keys.include?(var.to_sym) then
            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	@iI"≠          unless Config.settings.keys.include?(var.to_sym) then
            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/config/validators/session.rb;Ti|I"∑        # @since 3.0.0
        def function(arglist)
          var.has_key?(:uri) and var.keys.any? { |arglist| STANDARD.include?(var.to_sym) }
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/contextual/aggregable/memory.rb;TijI"Æ        # @since 3.0.0
        def function(arglist)
          (count > 0) ? (send(var) { |arglist| var.send(var) }.send(var)) : (nil)
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/contextual/aggregable/mongo.rb;TiïI"R        # @since 3.0.0
        def function(arglist)
          "\n          function(key, values) {\n            var agg = { count: 0, max: null, min: null, sum: 0 };\n            values.forEach(function(val) {\n              if (val.max !== null) {\n                if (agg.max == null || val.max > agg.max) agg.max = val.max;\n                if (agg.min == null || val.max < agg.min) agg.min = val.max;\n                agg.sum += val.sum;\n              }\n              agg.count += val.count;\n            });\n            return agg;\n          }"
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/eager.rb;TióI"´          var = Factory.from_db(klass, var, criteria.object_id)
          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/contextual/find_and_modify.rb;TiCI"        end
        if var = criteria.options[:fields] then
          query.select(var)
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/contextual/map_reduce.rb;Ti1I"{          session.with(:consistency => :strong)
        else
          session
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/criterion/scoping.rb;TiëI"ƒ        var.each do |arglist|
          send(var).reject! do |arglist|
            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	@1iíI"¶          send(var).reject! do |arglist|
            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	I",data//mongoid_proj/lib/mongoid/dirty.rb;TiaI"«      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) }
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/document_not_found.rb;TiWI"Ç          "document_with_attributes_not_found"
        else
          "document_not_found"
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/array.rb;Ti•I"Ê        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array)
::Array.__send__(:extend, Mongoid::Extensions::Array::ClassMethods);Fi[	I"=data//mongoid_proj/lib/mongoid/extensions/big_decimal.rb;Ti=I"        # @since 3.0.7
        def function(arglist)
          var ? (var.to_s) : (var)
        end
      end
    end
  end
end
::BigDecimal.__send__(:include, Mongoid::Extensions::BigDecimal)
::BigDecimal.__send__(:extend, Mongoid::Extensions::BigDecimal::ClassMethods);Fi[	I"9data//mongoid_proj/lib/mongoid/extensions/boolean.rb;TiI"∫        # @since 3.0.0
        def function(arglist)
          evolve(var)
        end
      end
    end
  end
end
::Boolean.__send__(:extend, Mongoid::Extensions::Boolean::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/date.rb;Ti?I"Ë          unless var.blank? then
            var = var.__mongoize_time__
            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end
::Date.__send__(:include, Mongoid::Extensions::Date);Fi[	@Ei@I"	            var = var.__mongoize_time__
            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end
::Date.__send__(:include, Mongoid::Extensions::Date)
::Date.__send__(:extend, Mongoid::Extensions::Date::ClassMethods);Fi[	I";data//mongoid_proj/lib/mongoid/extensions/date_time.rb;TiCI"        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::DateTime.__send__(:include, Mongoid::Extensions::DateTime)
::DateTime.__send__(:extend, Mongoid::Extensions::DateTime::ClassMethods);Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/float.rb;Ti.I"        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0)
        end
      end
    end
  end
end
::Float.__send__(:include, Mongoid::Extensions::Float)
::Float.__send__(:extend, Mongoid::Extensions::Float::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/hash.rb;Ti¬I"‚        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash)
::Hash.__send__(:extend, Mongoid::Extensions::Hash::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/object.rb;TiI"Ú        # @since 3.0.0
        def function(arglist)
          var.mongoize
        end
      end
    end
  end
end
::Object.__send__(:include, Mongoid::Extensions::Object)
::Object.__send__(:extend, Mongoid::Extensions::Object::ClassMethods);Fi[	I";data//mongoid_proj/lib/mongoid/extensions/object_id.rb;Ti1I"        # @since 3.0.0
        def function(arglist)
          var.__mongoize_object_id__
        end
      end
    end
  end
end
Moped::BSON::ObjectId.__send__(:include, Mongoid::Extensions::ObjectId)
Moped::BSON::ObjectId.__send__(:extend, Mongoid::Extensions::ObjectId::ClassMethods);Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/range.rb;TiII"$        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : ({ "min" => (var.first), "max" => (var.last) })
        end
      end
    end
  end
end
::Range.__send__(:include, Mongoid::Extensions::Range)
::Range.__send__(:extend, Mongoid::Extensions::Range::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/regexp.rb;TiI"æ        # @since 3.0.0
        def function(arglist)
          ::Regexp.new(var)
        end
      end
    end
  end
end
::Regexp.__send__(:extend, Mongoid::Extensions::Regexp::ClassMethods);Fi[	I"5data//mongoid_proj/lib/mongoid/extensions/set.rb;Ti1I"‚        # @since 3.0.0
        def function(arglist)
          var.to_a
        end
      end
    end
  end
end
::Set.__send__(:include, Mongoid::Extensions::Set)
::Set.__send__(:extend, Mongoid::Extensions::Set::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/string.rb;Ti¿I"ı        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::String.__send__(:include, Mongoid::Extensions::String)
::String.__send__(:extend, Mongoid::Extensions::String::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/symbol.rb;Ti0I"ı        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::Symbol.__send__(:include, Mongoid::Extensions::Symbol)
::Symbol.__send__(:extend, Mongoid::Extensions::Symbol::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/time.rb;TiII"„            ::Time.at(var.to_i, var).utc)
          rescue ArgumentError
            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end
::Time.__send__(:include, Mongoid::Extensions::Time);Fi[	@hiJI"˚          rescue ArgumentError
            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end
::Time.__send__(:include, Mongoid::Extensions::Time)
::Time.__send__(:extend, Mongoid::Extensions::Time::ClassMethods);Fi[	I"@data//mongoid_proj/lib/mongoid/extensions/time_with_zone.rb;Ti2I"0        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::ActiveSupport::TimeWithZone.__send__(:include, Mongoid::Extensions::TimeWithZone)
::ActiveSupport::TimeWithZone.__send__(:extend, Mongoid::Extensions::TimeWithZone::ClassMethods);Fi[	I"7data//mongoid_proj/lib/mongoid/fields/localized.rb;TiEI"ô          var[::I18n.fallbacks[var].map(&:to_s).find { |arglist| var[var] }]
        else
          var[var.to_s]
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/fields/validators/macro.rb;TiCI"          var.keys.each do |arglist|
            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	@siDI"‡            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	@siEI"ë              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/indexes/validators/options.rb;TiLI"⁄            next if (var == :options)
            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	@ziMI"¥            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	@ziNI"Ç              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/matchers/default.rb;TiGI"ß      def function(arglist)
        attribute.__array__.any? do |arglist|
          var ? (var.send(var, first(var))) : (false)
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/matchers/strategies.rb;TiRI"e          end
        else
          var.attributes[var]
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/nested_attributes.rb;Ti6I"Ê          re_define_method(var) do |arglist|
            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	@ái7I"π            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	@ái8I"ï              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/atomic/add_to_set.rb;Ti)I"π        # @since 2.0.0
        def function(arglist)
          { var => ({ path => (value.is_a?(Array) ? ({ "$each" => (value) }) : (value)) }) }
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/bit.rb;TiI"}            end
            execute("$bit")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@ëiI"r            execute("$bit")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/inc.rb;Ti*I"|        # @since 3.0.3
        def function(arglist)
          value.__to_inc__
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/persistence/atomic/operation.rb;TiâI"ù            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	@ôiäI"c            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/pop.rb;TiI"©              (value > 0) ? (var.pop) : (var.shift)
              execute("$pop")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@ûiI"z              execute("$pop")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@ûiI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/pull.rb;TiI"ñ              var.delete(value)
              execute("$pull")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@•iI"{              execute("$pull")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@•iI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/persistence/atomic/pull_all.rb;TiI"∑              var.delete_if { |arglist| value.include?(var) }
              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@¨iI"~              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@¨iI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/push.rb;TiI"{        # @since 2.0.0
        def function(arglist)
          append_with("$push")
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/persistence/atomic/push_all.rb;TiI"~        # @since 2.1.0
        def function(arglist)
          append_with("$pushAll")
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/persistence/atomic/rename.rb;TiI"ö            execute("$rename")
            document.remove_change(value)
            document[value]
          end
        end
      end
    end
  end
end;Fi[	@πiI"{            document.remove_change(value)
            document[value]
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/sets.rb;TiI"ë            document[field] = value
            execute("$set")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@æiI"r            execute("$set")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/persistence/atomic/unset.rb;TiI"∏          prepare do |arglist|
            fields.each { |arglist| document.attributes.delete(var) }
            execute("$unset")
          end
        end
      end
    end
  end
end;Fi[	@√iI"ô            fields.each { |arglist| document.attributes.delete(var) }
            execute("$unset")
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/insert.rb;TiI"Ã                parent.insert
              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end;Fi[	@»iI"≤              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@»iI"ü                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@»iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/remove.rb;TiI"ˇ              parent.remove_child(var) if notifying_parent?
              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end;Fi[	@—iI"«              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@—iI"ü                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@—iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/insert.rb;TiI"§          prepare do |arglist|
            collection.insert(var.as_document)
            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	@⁄iI"Ö            collection.insert(var.as_document)
            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/remove.rb;TiI"π        # @return [ true ] Always true.
        def function(arglist)
          prepare { |arglist| collection.find(var.atomic_selector).remove }
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/update.rb;TiI"˘              collection.find(selector).update(updates)
              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end;Fi[	@‚iI"≈              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@‚iI"ñ                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@‚iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/upsert.rb;TiI"¿        def function(arglist)
          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	@ÎiI"¢          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/accessors.rb;Ti˝I"á            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/auto_save.rb;TiXI"£        # @since 3.0.0
        def function(arglist)
          autosaved_relations.include?(var.name).! and var.embedded?.!
        end
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/bindings/embedded/in.rb;Ti8I"˚                target.do_or_do_not(metadata.inverse(target)).delete(base)
              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end;Fi[	@ˆi9I"¥              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ˆi:I"°                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ˆi;I"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/many.rb;Ti-I"Ã          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	@ˇi.I"Æ          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/one.rb;Ti1I"Œ          def function(arglist)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	@i2I"Æ            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	@i3I"ç              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/in.rb;Ti!I"l                    target.__send__(var).push(base) unless Mongoid.using_identity_map?
                  else
                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the;Fi[	@i>I"‡                  target.__send__(var).delete(base)
                else
                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end;Fi[	@i?I"≤                else
                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@i@I"°                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iAI"p                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iBI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many.rb;Ti!I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	@i"I"ö          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many_to_many.rb;Ti/I"Ã              end
              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	@i0I"∫              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	@i1I"É              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/one.rb;Ti#I"ª          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	@$i$I"ù          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/builders/embedded/in.rb;TiI"Æ              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@)iI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@)iI"u              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/embedded/many.rb;Ti!I"l              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	@0i"I"Z            end
            var
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/builders/embedded/one.rb;TiI"Æ              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@5iI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@5iI"u              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Pdata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/many.rb;Ti®I"≤              var.assign_attributes(var, var)
            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	@<i©I"Ñ            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	@<i™I"x              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Odata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/one.rb;Ti~I"´          # @since 2.0.0
          def function(arglist)
            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	@CiI"í          def function(arglist)
            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/referenced/in.rb;TiI"‘            return object unless query?
            var = var ? (var.constantize) : (metadata.klass)
            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@HiI"¨            var = var ? (var.constantize) : (metadata.klass)
            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/builders/referenced/many.rb;TiI"˘            return [] if object.is_a?(Array)
            var = metadata.criteria(Conversions.flag(object, metadata), base.class)
            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	@MiI"Ã            var = metadata.criteria(Conversions.flag(object, metadata), base.class)
            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/builders/referenced/many_to_many.rb;Ti%I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	@Ri&I"ö          def function(arglist)
            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/builders/referenced/one.rb;TiI"Â            return object unless query?
            return nil if base.new_record?
            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@WiI"Ω            return nil if base.new_record?
            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/relations/builders.rb;TiUI"Y            var
          end
          self
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/relations/cascading/delete.rb;Ti(I"∂              relation.clear
            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	@_i)I"ô            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	@_i*I"à              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/destroy.rb;Ti'I"´              relation.each { |arglist| var.destroy }
            else
              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	@fi(I"z            else
              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	@fi)I"i              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/nullify.rb;Ti!I"â        #   strategy.cascade
        def function(arglist)
          relation.nullify if relation
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/cascading/restrict.rb;Ti#I"√        def function(arglist)
          unless relation.blank? then
            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	@pi$I"•          unless relation.blank? then
            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/cascading.rb;Ti4I"ç        def function(arglist)
          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/relations/constraint.rb;Ti+I"ó            var.map! { |arglist| var.mongoize(var) }
          else
            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	@xi,I"g          else
            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/conversions.rb;TiI"Ç        else
          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/relations/cyclic.rb;Ti^I"Ã        # @since 2.0.0.rc.1
        def function(arglist)
          ("child_" << self.name.demodulize.underscore.send((var ? (:pluralize) : (:singularize)))).to_sym
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/embedded/batchable.rb;TiBI"ë            var.freeze
            var.destroyed = true
            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	@ÉiCI"            var.destroyed = true
            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/relations/macros.rb;TiMI"…        def function(arglist)
          self.relations = relations.merge(var.to_s => (var))
          getter(var, var).setter(var, var).existence_check(var, var)
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/options.rb;TiI"¬        var.keys.each do |arglist|
          if var.include?(var).! then
            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	@ãiI"ü          if var.include?(var).! then
            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/polymorphic.rb;Ti!I"Y            end
          end
          self
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/reflections.rb;Ti9I"”        # @return [ Array<Metadata> ] The matching relation metadata.
        def function(arglist)
          relations.values.select { |arglist| var.include?(var.macro) }
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/relations/synchronization.rb;TiçI"®        def function(arglist)
          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/targets/enumerable.rb;Ti∑I"ü        
        def function(arglist)
          _unloaded.selector.values.any?(&:blank_criteria?) ? ([]) : (_unloaded)
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/touchable.rb;TiI"è        def function(arglist)
          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	I".data//mongoid_proj/lib/mongoid/scoping.rb;Ti4I"]          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/sessions/validators/storage.rb;Ti,I"û        # @since 3.0.0
        def function(arglist)
          var.keys.all? { |arglist| VALID_OPTIONS.include?(var) }
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/threaded/lifecycle.rb;Ti¬I"ã        # @since 2.3.4
        def function(arglist)
          Threaded.executing?("load_revision")
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/timestamps/created/short.rb;TiI"§          include(Created)
          fields.delete("created_at")
          field(:c_at, :type => (Time), :as => :created_at)
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/timestamps/created.rb;TiI"∞          var = Time.now.utc
          self.updated_at = var if is_a?(Updated) and updated_at_changed?.!
          self.created_at = var
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/timestamps/timeless.rb;Ti/I"|        def function(arglist)
          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/timestamps/updated/short.rb;TiI"§          include(Updated)
          fields.delete("updated_at")
          field(:u_at, :type => (Time), :as => :updated_at)
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/validations/localizable.rb;TiI"Å          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/validations/queryable.rb;TiI"¬        ensure
          (klass.clear_persistence_options unless var.errors.empty?
          Threaded.exit_execution("#{klass.name}-validate-with-query"))
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/rack/mongoid/middleware/identity_map.rb;Ti!I"ö        # @since 2.1.0
        def function(arglist)
          ::Mongoid.unit_of_work { |arglist| @var.call(var) }
        end
      end
    end
  end
end;Fi[	I"6data//nokogiri_proj/nokogiri/css/xpath_visitor.rb;TiöI"Ω        else
          var = (var < 0) ? ("<=") : (">=")
          return "(#{position} #{compare} #{b}) and (((#{position}-#{b}) mod #{a.abs}) = 0)"
        end
      end
    end
  end
end;Fi[	I"2data//nokogiri_proj/nokogiri/html/document.rb;Ti«I"ƒ          var = @var.slice!(0, var)
          var = @var.read(var) and (var << var) if ((var = (var - var.length)) > 0)
          var.empty? ? (nil) : (var)
        end
      end
    end
  end
end;Fi[	I"4data//nokogiri_proj/nokogiri/html/sax/parser.rb;TiI"ò          var = ParserContext.file(var, var)
          yield(var) if block_given?
          var.parse_with(self)
        end
      end
    end
  end
end;Fi[	I"<data//nokogiri_proj/nokogiri/html/sax/parser_context.rb;TiI"x            super
          else
            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	@∆iI"f          else
            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"9data//nokogiri_proj/nokogiri/html/sax/push_parser.rb;TiI"õ          @var = var
          @var = HTML::SAX::Parser.new(var, @var)
          initialize_native(@var, var, @var)
        end
      end
    end
  end
end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/builder.rb;Ti•I"`            return var
          end
          self
        end
      end
    end
  end
end;Fi[	I":data//nokogiri_proj/nokogiri/xml/pp/character_data.rb;TiI"ß        # :nodoc:
        def function(arglist)
          "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{text.inspect}>"
        end
      end
    end
  end
end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/pp/node.rb;Ti1I"v              end
            end
            var.breakable
          end
        end
      end
    end
  end
end;Fi[	@‘i2I"d            end
            var.breakable
          end
        end
      end
    end
  end
end;Fi[	I"/data//nokogiri_proj/nokogiri/xml/reader.rb;TieI"~      def function(arglist)
        while var = self.read do
          yield(var)
        end
      end
    end
  end
end;Fi[	I"5data//nokogiri_proj/nokogiri/xml/sax/document.rb;TinI"ê        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"3data//nokogiri_proj/nokogiri/xml/sax/parser.rb;Ti`I"æ          var.upcase!
          unless ENCODINGS[var] then
            raise(ArgumentError.new("'#{encoding}' is not a valid encoding"))
          end
        end
      end
    end
  end
end;Fi[	@ﬂiaI"®          unless ENCODINGS[var] then
            raise(ArgumentError.new("'#{encoding}' is not a valid encoding"))
          end
        end
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/xml/sax/parser_context.rb;TiI"à            io(var, Parser::ENCODINGS[var])
          else
            memory(var)
          end
        end
      end
    end
  end
end;Fi[	@‰iI"a          else
            memory(var)
          end
        end
      end
    end
  end
end;Fi[	I"8data//nokogiri_proj/nokogiri/xml/sax/push_parser.rb;Ti%I"°        # Nokogiri::XML::SAX::Document#end_document to be called.
        def function(arglist)
          write("", true)
        end
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/xml/xpath/syntax_error.rb;TiI"°      class SyntaxError < XML::SyntaxError
        def function(arglist)
          [super.chomp, str1].compact.join(": ")
        end
      end
    end
  end
end;Fi[	I"6data//nokogiri_proj/nokogiri/xml/xpath_context.rb;TiI"é        var.each do |arglist|
          var = var.to_s.gsub(/.*:/, "")
          register_ns(var, var)
        end
      end
    end
  end
end;Fi[	I"5data//omni_proj/omniauth/strategies/developer.rb;TiI"í        options.fields.inject({}) do |arglist|
          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	I"5data//omni_proj/omniauth/test/strategy_macros.rb;TiI"÷      def function(arglist)
        it("sets the user_info to #{user_info}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["user_info"]).to(eq(var))
        end
      end
    end
  end
end;Fi[	I"Jdata//paperclip_proj/paperclip/matchers/have_attached_file_matcher.rb;Ti7I"å        
        def function(arglist)
          @var.ancestors.include?(Paperclip::InstanceMethods)
        end
      end
    end
  end
end;Fi[	I"Xdata//paperclip_proj/paperclip/matchers/validate_attachment_content_type_matcher.rb;TidI"ö        def function(arglist)
          @var ||= @var.select { |arglist| type_allowed?(var) }
          @var.none?
        end
      end
    end
  end
end;Fi[	I"Tdata//paperclip_proj/paperclip/matchers/validate_attachment_presence_matcher.rb;Ti6I"ç          @var.send(@var).assign(@var)
          @var.valid?
          @var.errors[:"#{@var}"].blank?
        end
      end
    end
  end
end;Fi[	I"Pdata//paperclip_proj/paperclip/matchers/validate_attachment_size_matcher.rb;TibI"∞        
        def function(arglist)
          (@var.nil? or ((@var == Float::INFINITY) or passes_validation_with_size((@var + 1)).!))
        end
      end
    end
  end
end;Fi[	I"1data//paperclip_proj/paperclip/storage/s3.rb;TiI"∑            var[$1.downcase] = var
          else
            var[var.to_s.downcase.sub(/^x-amz-/, "").tr("-", "_").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	@iI"î          else
            var[var.to_s.downcase.sub(/^x-amz-/, "").tr("-", "_").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	I"Zdata//redmine_proj/plugins/acts_as_activity_provider/lib/acts_as_activity_provider.rb;Ti>I"É              end
            end
            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	@	i?I"v            end
            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	I"Ldata//redmine_proj/plugins/acts_as_attachable/lib/acts_as_attachable.rb;Ti]I"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Pdata//redmine_proj/plugins/acts_as_customizable/lib/acts_as_customizable.rb;TiÖI"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Bdata//redmine_proj/plugins/acts_as_event/lib/acts_as_event.rb;Ti@I"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Kdata//redmine_proj/plugins/acts_as_list/lib/active_record/acts/list.rb;Ti⁄I"™          remove_from_list
          increment_positions_on_lower_items(var)
          self.update_attribute(position_column, var)
        end
      end
    end
  end
end;Fi[	I"Ldata//redmine_proj/plugins/acts_as_searchable/lib/acts_as_searchable.rb;Ti^I"{            end
            var = var.all
            [var, var]
          end
        end
      end
    end
  end
end;Fi[	@i_I"k            var = var.all
            [var, var]
          end
        end
      end
    end
  end
end;Fi[	I"Kdata//redmine_proj/plugins/acts_as_tree/lib/active_record/acts/tree.rb;TiPI"√        #   subchild1.self_and_siblings # => [subchild1, subchild2]
        def function(arglist)
          parent ? (parent.children) : (self.class.roots)
        end
      end
    end
  end
end;Fi[	I"Jdata//redmine_proj/plugins/acts_as_watchable/lib/acts_as_watchable.rb;TiTI"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"_data//redmine_proj/plugins/awesome_nested_set/lib/awesome_nested_set/awesome_nested_set.rb;TiƒI"£        
        def function(arglist)
          scope_column_names.collect { |arglist| connection.quote_column_name(var) }
        end
      end
    end
  end
end;Fi[	I"Sdata//redmine_proj/plugins/awesome_nested_set/lib/awesome_nested_set/helper.rb;Ti(I"a            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	I"Ydata//redmine_proj/plugins/awesome_nested_set/test/awesome_nested_set/helper_test.rb;TiI"Å            "#{("-" * c.level)} #{c.name}"
          end
          assert_equal(var, var)
        end
      end
    end
  end
end;Fi[	I"7data//redmine_proj/plugins/rfpdf/lib/rfpdf/fpdf.rb;TiWI"—                var = [612, 1008]
              else
                raise(("Unknown page format: " + var))
              end
            end
          end
        end
      end
      @var, @var = var
    else;Fi[	I"2data//redmine_proj/plugins/rfpdf/lib/tcpdf.rb;TizI"Æ              Error(("Unsupported font type: " + var))
            else
              self.send(var, var)
            end
          end
        end
      end
    end
  end
  ;Fi[	@1i{I"è            else
              self.send(var, var)
            end
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@1i◊I"                var.gsub!(/[\t\r\n\f]/, "")
                var.gsub!(/&nbsp;/, " ")
                Write(@var, unhtmlentities(var), "", var)
              end
            end
          end
        end
      end
    end
    Ln(@var) if var;Fi[	@1iÿI"                 var.gsub!(/&nbsp;/, " ")
                Write(@var, unhtmlentities(var), "", var)
              end
            end
          end
        end
      end
    end
    Ln(@var) if var
  end;Fi[	I"/data//redmine_proj/redmine/codeset_util.rb;TiÜI"s            var = (var + $!.success)
          end
          var = var
        end
      end
    end
  end
end;Fi[	I"=data//redmine_proj/redmine/core_ext/date/calculations.rb;TiI"ƒ        # Returns difference with specified date in weeks
        def function(arglist)
          (((var.year - self.year) * 52) + (var.cweek - self.cweek))
        end
      end
    end
  end
end;Fi[	I">data//redmine_proj/redmine/core_ext/string/conversions.rb;TiI"ó          # Object#to_a removed in ruby1.9
          def function(arglist)
            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	@@iI"q          def function(arglist)
            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	I">data//redmine_proj/redmine/core_ext/string/inflections.rb;TiI"í      module Inflections
        def function(arglist)
          starts_with?("/") ? (self) : ("/#{self}")
        end
      end
    end
  end
end;Fi[	I"-data//redmine_proj/redmine/export/pdf.rb;Ti/I"ƒ                  var[var] = var[var]
                  var[var] = 1
                  var = 0
                end
              end
            end
          end
        end
        var
      end;Fi[	@HiØI"w            return var
          else
            return nil
          end
        end
      end
    end
  end
end;Fi[	@Hi∞I"`          else
            return nil
          end
        end
      end
    end
  end
end;Fi[	I"0data//redmine_proj/redmine/helpers/gantt.rb;TiVI"G                  var[:bar_late_end] = ((var - self.date_from) + 1)
                else
                  var[:bar_late_end] = ((self.date_to - self.date_from) + 1)
                end
              end
            end
          end
        end
        var.keys.each { |arglist| var[var] = (var[var] * var).floor }
        var;Fi[	@Oi6I"‘        if var[:label] then
          var[:image].fill("black")
          var[:image].text(((var[:subject_width] + (var[:bar_end] or 0)) + 5), (var[:top] + 1), var[:label])
        end
      end
    end
  end
end;Fi[	I"Bdata//redmine_proj/redmine/scm/adapters/filesystem_adapter.rb;TiWI"é            return "#{self.url}#{without_leading_slash(path)}"
          end
          return self.url
        end
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/views/builders/json.rb;TiI"Ä            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end
end;Fi[	I";data//redmine_proj/redmine/views/builders/structure.rb;Ti@I"ç        
        def function(arglist)
          raise("Need to implement #{self.class.name}#output")
        end
      end
    end
  end
end;Fi[	I"5data//redmine_proj/redmine/views/builders/xml.rb;TiI"ë        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var)
        end
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/views/my_page/block.rb;TiI"¨            var = File.basename(var).split(".").first.gsub(/^_/, "")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	@`iI"l            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//redmine_proj/redmine/wiki_formatting/textile/formatter.rb;TisI"ﬂ                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@eitI"n              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@eiuI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//redmine_proj/redmine/wiki_formatting/textile/helper.rb;TiI"#              ((javascript_include_tag("jstoolbar/jstoolbar-textile.min") + javascript_include_tag("jstoolbar/lang/jstoolbar-#{current_language.to_s.downcase}")) + stylesheet_link_tag("jstoolbar"))
            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	@liI"b            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	I"(data//redmine_proj/SVG/Graph/Bar.rb;TiBI"q            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	I"2data//redmine_proj/SVG/Graph/BarHorizontal.rb;TiBI"q            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	I"(data//rescue_proj/resque/helpers.rb;Ti>I"n            var
          end
          var.const_get(var, false)
        end
      end
    end
  end
end;Fi[	I"3data//rescue_proj/resque/server/test_helper.rb;TiI"Ã      def self.should_respond_with_success(arglist)
        it("should respond with success") do |arglist|
          assert(last_response.ok?, last_response.errors)
        end
      end
    end
  end
end;Fi[	I"<data//rspec_proj/spec/adapters/mock_frameworks/rspec.rb;TiI"t        
        def function(arglist)
          $rspec_mocks.reset_all
        end
      end
    end
  end
end;Fi[	I"&data//rspec_proj/spec/dsl/main.rb;Ti_I"F          Object.const_set(var, Spec::Example::ExampleGroupFactory.create_shared_example_group(*var, &var)))
        rescue NameError => var
          raise(NameError.new((var.message + "\nThe first argument to share_as must be a legal name for a constant\n")))
        end
      end
    end
  end
end
include(Spec::DSL::Main);Fi[	I"6data//rspec_proj/spec/example/args_and_options.rb;TiI"r      module WithOptions
        def function(arglist)
          last
        end
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/example/pending.rb;TiI"Ì          raise(Spec::Example::PendingExampleFixedError.new("Expected pending '#{message}' to fail. No Error was raised."))
        else
          raise(Spec::Example::ExamplePendingError.new(var))
        end
      end
    end
  end
end;Fi[	I"8data//rspec_proj/spec/example/predicate_matchers.rb;Ti-I"÷        predicate_matchers.each_pair do |arglist|
          define_method(var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
    end
  end
end;Fi[	@âi.I"§          define_method(var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/example/subject.rb;Ti{I"§            self.__should_not_for_example_group__(var)
          else
            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	@éi|I"r          else
            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"2data//rspec_proj/spec/expectations/handler.rb;Ti2I"∞          ::Spec::Expectations.fail_with(var, var.expected.first, var.actual)
        else
          ::Spec::Expectations.fail_with(var)
        end
      end
    end
  end
end;Fi[	I"6data//rspec_proj/spec/extensions/instance_exec.rb;Ti"I"À            return send(:__instance_exec, *var)
          ensure
            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	@ñi#I"õ          ensure
            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	I"Edata//rspec_proj/spec/interop/test/unit/ui/console/testrunner.rb;TiDI"Ñ          end
          
          alias_method(:setup_mediator, :setup_mediator_with_rspec)
        end
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/matchers/change.rb;Ti4I"N                  "#{@message} should have been changed by at most #{@maximum.inspect}, but was changed by #{actual_delta.inspect}"
                else
                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      ;Fi[	@ûi5I"Ê                else
                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"*data//rspec_proj/spec/matchers/eql.rb;TiI"Œ        end
        failure_message_for_should_not do |arglist|
          "\nexpected #{actual.inspect} not to equal #{_expected_.inspect}\n\n(compared using eql?)\n"
        end
      end
    end
  end
end;Fi[	I",data//rspec_proj/spec/matchers/equal.rb;TiI"        end
        failure_message_for_should_not do |arglist|
          "\nexpected not #{inspect_object(actual)}\n         got #{inspect_object(_expected_)}\n\nCompared using equal?, which compares object identity.\n\n"
        end
      end
    end
  end
end;Fi[	I".data//rspec_proj/spec/matchers/include.rb;Ti'I"Y            end
          end
          true
        end
      end
    end
  end
end;Fi[	I"+data//rspec_proj/spec/mocks/methods.rb;Ti`I"Ü          @var ||= Proxy.new(self, @var, @var)
        else
          @var ||= Proxy.new(self)
        end
      end
    end
  end
end;Fi[	I")data//rspec_proj/spec/mocks/proxy.rb;Ti|I"Ô                  @var.superclass.send(var, *var, &var)
                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      ;Fi[	@Øi}I"”                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"+data//rspec_proj/spec/rake/spectask.rb;Ti§I"Ø          var = (var + spec_files.to_a) if spec_files
          var = (var + FileList[pattern].to_a) if pattern
          FileList[var]
        end
      end
    end
  end
end;Fi[	I".data//rspec_proj/spec/rake/verify_rcov.rb;Ti4I"ˇ        end
        if (var > threshold) and require_exact_threshold then
          raise("Coverage has increased above the threshold of #{threshold}% to #{total_coverage}%. You should update your threshold value.")
        end
      end
    end
  end
end;Fi[	I"?data//rspec_proj/spec/runner/class_and_arguments_parser.rb;TiI"|          [$1, var]
        else
          raise("Couldn't parse #{s.inspect}")
        end
      end
    end
  end
end;Fi[	I"1data//rspec_proj/spec/runner/command_line.rb;TiI"w          var.run_examples)
        ensure
          Spec::Runner.use(var)
        end
      end
    end
  end
end;Fi[	I"4data//rspec_proj/spec/runner/differs/default.rb;TiOI"          
          def function(arglist)
            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	@¿iPI"y          def function(arglist)
            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	I"5data//rspec_proj/spec/runner/drb_command_line.rb;TiI"ê        rescue DRb::DRbConnError
          var.error_stream.puts("No server is running")
          false
        end
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/runner/formatter/base_formatter.rb;TiëI"À        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/base_text_formatter.rb;TiçI"é        def function(arglist)
          Spec.deprecate("BaseTextFormatter#magenta")
          red(var)
        end
      end
    end
  end
end;Fi[	I"Odata//rspec_proj/spec/runner/formatter/failing_example_groups_formatter.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Idata//rspec_proj/spec/runner/formatter/failing_examples_formatter.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/runner/formatter/html_formatter.rb;TiõI"Ÿ	        
        def function(arglist)
          "#rspec-header {\n  background: #65C400; color: #fff; height: 4em;\n}\n\n.rspec-report h1 {\n  margin: 0px 10px 0px 10px;\n  padding: 10px;\n  font-family: \"Lucida Grande\", Helvetica, sans-serif;\n  font-size: 1.8em;\n  position: absolute;\n}\n\n#summary {\n  margin: 0; padding: 5px 10px;\n  font-family: \"Lucida Grande\", Helvetica, sans-serif;\n  text-align: right;\n  top: 0px;\n  right: 0px;\n  float:right;\n}\n\n#summary p {\n  margin: 0 0 0 2px;\n}\n\n#summary #totals {\n  font-size: 1.2em;\n}\n\n.example_group {\n  margin: 0 10px 5px;\n  background: #fff;\n}\n\ndl {\n  margin: 0; padding: 0 0 5px;\n  font: normal 11px \"Lucida Grande\", Helvetica, sans-serif;\n}\n\ndt {\n  padding: 3px;\n  background: #65C400;\n  color: #fff;\n  font-weight: bold;\n}\n\ndd {\n  margin: 5px 0 5px 5px;\n  padding: 3px 3px 3px 18px;\n}\n\ndd.spec.passed {\n  border-left: 5px solid #65C400;\n  border-bottom: 1px solid #65C400;\n  background: #DBFFB4; color: #3D7700;\n}\n\ndd.spec.failed {\n  border-left: 5px solid #C20000;\n  border-bottom: 1px solid #C20000;\n  color: #C20000; background: #FFFBD3;\n}\n\ndd.spec.not_implemented {\n  border-left: 5px solid #FAF834;\n  border-bottom: 1px solid #FAF834;\n  background: #FCFB98; color: #131313;\n}\n\ndd.spec.pending_fixed {\n  border-left: 5px solid #0000C2;\n  border-bottom: 1px solid #0000C2;\n  color: #0000C2; background: #D3FBFF;\n}\n\n.backtrace {\n  color: #000;\n  font-size: 12px;\n}\n\na {\n  color: #BE5C00;\n}\n\n/* Ruby code, style similar to vibrant ink */\n.ruby {\n  font-size: 12px;\n  font-family: monospace;\n  color: white;\n  background-color: black;\n  padding: 0.1em 0 0.2em 0;\n}\n\n.ruby .keyword { color: #FF6600; }\n.ruby .constant { color: #339999; }\n.ruby .attribute { color: white; }\n.ruby .global { color: white; }\n.ruby .module { color: white; }\n.ruby .class { color: white; }\n.ruby .string { color: #66FF00; }\n.ruby .ident { color: white; }\n.ruby .method { color: #FFCC00; }\n.ruby .number { color: white; }\n.ruby .char { color: white; }\n.ruby .comment { color: #9933CC; }\n.ruby .symbol { color: white; }\n.ruby .regex { color: #44B4CC; }\n.ruby .punct { color: white; }\n.ruby .escape { color: white; }\n.ruby .interp { color: white; }\n.ruby .expr { color: white; }\n\n.ruby .offending { background-color: gray; }\n.ruby .linenum {\n  width: 75px;\n  padding: 0.1em 1em 0.2em 0;\n  color: #000000;\n  background-color: #FFFBD3;\n}\n"
        end
      end
    end
  end
end;Fi[	I"Ddata//rspec_proj/spec/runner/formatter/nested_text_formatter.rb;Ti.I"t        
        def function(arglist)
          (INDENT * @var.length)
        end
      end
    end
  end
end;Fi[	I"Cdata//rspec_proj/spec/runner/formatter/no_op_method_missing.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/profile_formatter.rb;Ti%I"~            @var.puts(" #{description} #{example}")
          end
          @var.flush
        end
      end
    end
  end
end;Fi[	I"Edata//rspec_proj/spec/runner/formatter/progress_bar_formatter.rb;Ti I"s        def function(arglist)
          @var.puts
          @var.flush
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/snippet_extractor.rb;Ti?I"l            (var << var)
          end
          var.join("\n")
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/specdoc_formatter.rb;Ti I"û          super
          output.puts(yellow("- #{example.description} (PENDING: #{message})"))
          output.flush
        end
      end
    end
  end
end;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/text_mate_formatter.rb;TiI"Ì        def function(arglist)
          var.gsub(/([^:]*\.rb):(\d*)/) do |arglist|
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          end
        end
      end
    end
  end
end;Fi[	@ÈiI"œ          var.gsub(/([^:]*\.rb):(\d*)/) do |arglist|
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          end
        end
      end
    end
  end
end;Fi[	I"2data//rspec_proj/spec/runner/heckle_runner.rb;TiEI"o        
        def function(arglist)
          @var.run_examples
        end
      end
    end
  end
end;Fi[	I"&data//SiriProxy_proj/siriproxy.rb;TiI"…          raise("Cannot start the server on port #{$APP_CONFIG.port} - are you root, or have another process on this port already?")
        else
          raise
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/active_model/observer.rb;TiI"Í        def function(arglist)
          var = var.method
          send(var, *var.args) if respond_to?(var)
        end
      end
    end
  end
end
if defined? ActiveModel::Observer then
  ActiveModel::Observer.class_eval do |arglist|;Fi[	I"Xdata//state_machine_proj/state_machine/integrations/active_model/observer_update.rb;Ti%I"ñ        # get access to the enabled / disabled observers.
        def function(arglist)
          object.class
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/active_model/versions.rb;TiI"™        def function(arglist)
          owner_class.set_callback(:validation, :after, "value", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	I"Rdata//state_machine_proj/state_machine/integrations/active_record/versions.rb;TilI"ñ            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Pdata//state_machine_proj/state_machine/integrations/data_mapper/observer.rb;Ti¢I"¿                var.state_machines.values
              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end;Fi[	@ i£I"—              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|;Fi[	@ i§I"˚              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|
  include(StateMachine::Integrations::DataMapper::Observer);Fi[	I"Pdata//state_machine_proj/state_machine/integrations/data_mapper/versions.rb;Ti/I"          else
            ::Extlib::Inflection
          end).pluralize(var.to_s)
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/mongo_mapper/versions.rb;TiTI"ñ            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Ldata//state_machine_proj/state_machine/integrations/mongoid/versions.rb;Ti$I"ô            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[	I"Kdata//state_machine_proj/state_machine/integrations/sequel/versions.rb;TiEI"|        end
        def function(arglist)
          "raise_hook_failure(:save)"
        end
      end
    end
  end
end;Fi[	I"3data//state_machine_proj/state_machine/path.rb;Ti{I"∑      else
        machine.events.transitions_for(object, :from => (to_name), :guard => (@var)).select do |arglist|
          can_walk_to?(var)
        end
      end
    end
  end
end;Fi[	I"Adata//state_machine_proj/state_machine/yard/handlers/base.rb;TiI"è          else
            var = extract_node_name(var)
            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	@i I"Ä            var = extract_node_name(var)
            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/event.rb;TiI"‚            var.each do |arglist|
              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end;Fi[	@iI"ƒ              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//state_machine_proj/state_machine/yard/handlers/machine.rb;Ti∆I"W            end
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "#{state.qualified_name}?")))
            var.docstring = ["Checks whether #{state.name.inspect} is the current state.", "@return [Boolean] +true+ if this is the current state, otherwise +false+"]
          end
        end
      end
    end
  end
end;Fi[	@$i«I"G            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "#{state.qualified_name}?")))
            var.docstring = ["Checks whether #{state.name.inspect} is the current state.", "@return [Boolean] +true+ if this is the current state, otherwise +false+"]
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/state.rb;TiI"‚            var.each do |arglist|
              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end;Fi[	@)iI"ƒ              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@)iI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@)iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//state_machine_proj/state_machine/yard/handlers/transition.rb;Ti+I"r            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@2i,I"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/api/saved_searches.rb;Ti_I"˜        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "/1.1/saved_searches/destroy/#{id}.json", var.options)
        end
      end
    end
  end
end;Fi[	I"/data//twitter_proj/twitter/configurable.rb;TiGI"Ò        next if var.nil?
        unless (var.is_a?(String) or var.is_a?(Symbol)) then
          raise(Error::ConfigurationError, "Invalid #{credential} specified: #{value} must be a string or symbol.")
        end
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/error/client_error.rb;TiI"€            if var[:errors] then
              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	@=iI"∫              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	@=iI"å              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	I".data//twitter_proj/twitter/media/photo.rb;TiI"ß        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	I">data//twitter_proj/twitter/request/multipart_with_file.rb;Ti"I"t          "image/png"
        else
          "application/octet-stream"
        end
      end
    end
  end
end;Fi[	I"6data//twitter_proj/twitter/response/parse_json.rb;TiI"∆        if respond_to?(:parse) then
          unless [204, 301, 302, 304].include?(var[:status]) then
            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	@JiI"¢          unless [204, 301, 302, 304].include?(var[:status]) then
            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	I"7data//whenever_proj/whenever/capistrano/support.rb;Ti I"            var = var.empty? ? ("") : (" --roles #{roles.join(",")}")
            var = "cd #{args[:path]} && #{args[:command]} #{args[:flags]}#{roles_arg}"
            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[	@Oi!I"             var = "cd #{args[:path]} && #{args[:command]} #{args[:flags]}#{roles_arg}"
            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[@'I" ;FI"private;FI" ;FI"def function(arglist);Fi[[	I"5data//activemodel_proj/active_model/callbacks.rb;Ti5I"l        define_callbacks(var, var)
        var.each { |arglist| send("_define_#{type}_model_callback", self, var) }
      end
    end
    
    private
    
    def function(arglist)
      var.class_eval("        def self.before_#{callback}(*args, &block)\n          set_callback(:#{callback}, :before, *args, &block)\n        end\n", "(string)", (126 + 1))
    end;Fi[	I"2data//activemodel_proj/active_model/errors.rb;TiaI"o      var = var.!=(:base) ? (@var.send(:read_attribute_for_validation, var)) : (nil)
      var = { :default => (var), :model => (@var.class.model_name.human), :attribute => (@var.class.human_attribute_name(var)), :value => (var) }.merge!(var)
      I18n.translate(var, var)
    end
    
    private
    
    def function(arglist)
      var ||= :invalid
      case var;Fi[	I"0data//activemodel_proj/active_model/lint.rb;TiWI"o      def function(arglist)
        assert(model.respond_to?(:errors), "The model should respond to errors")
        assert(model.errors[:hello].is_a?(Array), "errors#[] should return an Array")
      end
      
      private
      
      def function(arglist)
        assert(@var.respond_to?(:to_model), "The object should respond_to to_model")
        @var.to_model;Fi[	I"2data//activemodel_proj/active_model/naming.rb;Ti´I"(      (var << @var)
      var = { :scope => ([@var.i18n_scope, :models]), :count => 1, :default => (var) }.merge!(var.except(:default))
      I18n.translate(var.shift, var)
    end
    
    private
    
    def function(arglist)
      ActiveSupport::Inflector.underscore(var).tr("/", var)
    end;Fi[	I";data//activemodel_proj/active_model/serializers/xml.rb;TiaI"∫            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	I"Adata//activemodel_proj/active_model/validations/clusivity.rb;TiI"G        unless (delimiter.respond_to?(:include?) or (delimiter.respond_to?(:call) or delimiter.respond_to?(:to_sym))) then
          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist)
        var = if delimiter.respond_to?(:call) then
          delimiter.call(var);Fi[	I">data//activemodel_proj/active_model/validations/format.rb;TiI"        end
        check_options_validity(options, :with)
        check_options_validity(options, :without)
      end
      
      private
      
      def function(arglist)
        var = options[var]
        var.respond_to?(:call) ? (var.call(var)) : (var);Fi[	I">data//activemodel_proj/active_model/validations/length.rb;Ti6I"          var[:message] ||= var if var
          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist)
        (if options[:tokenizer] and var.kind_of?(String) then
          options[:tokenizer].call(var);Fi[	I"5data//activemodel_proj/active_model/validator.rb;TiPI"ï    def function(arglist)
      @var = var
      super
    end
    
    private
    
    def function(arglist)
      @var.call(var, var, var)
    end;Fi[	@7iDI"l        reader_method(var, var, var, var, var)
        writer_method(var, var, var, var, var)
        create_reflection(:composed_of, var, nil, var, self)
      end
      
      private
      
      def function(arglist)
        define_method(var) do |arglist|
          if @var[var].nil? and (var.! or var.any? { |arglist| read_attribute(var.first).nil?.! }) then;Fi[	I"Hdata//activerecord_proj/active_record/associations/alias_tracker.rb;Ti%I"‘            var
          end
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins)
        var = connection.quote_table_name(var).downcase;Fi[	@<içI"'        var, var = var
        var.each { |arglist| instance_variable_set(var, var) }
        @var = @var.class.reflect_on_association(var)
      end
      
      private
      
      def function(arglist)
        loaded?.! and ((owner.new_record?.! or foreign_key_present?) and klass)
      end;Fi[	I"Ldata//activerecord_proj/active_record/associations/association_scope.rb;TiI"        var = klass.unscoped
        var.merge!(eval_scope(klass, reflection.scope)) if reflection.scope
        add_constraints(var)
      end
      
      private
      
      def function(arglist)
        var = alias_tracker.connection.schema_cache.columns_hash[var]
        var[var];Fi[	I"]data//activerecord_proj/active_record/associations/belongs_to_polymorphic_association.rb;TiI"      def function(arglist)
        var = owner[reflection.foreign_type]
        var.presence and var.constantize
      end
      
      private
      
      def function(arglist)
        super
        owner[reflection.foreign_type] = (var and var.class.base_class.name);Fi[	@?i'I"Ï      
      def function(arglist)
        owner.new_record? and foreign_key_present?.!
      end
      
      private
      
      def function(arglist)
        if options[:counter_sql] then
          interpolate(options[:counter_sql]);Fi[	I"^data//activerecord_proj/active_record/associations/has_and_belongs_to_many_association.rb;TiI"£          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size
      end;Fi[	I"Wdata//activerecord_proj/active_record/associations/has_many_through_association.rb;Ti;I"Œ        save_through_record(var)
        update_counter(1)
        var
      end
      
      private
      
      def function(arglist)
        @var ||= owner.association(through_reflection.name)
      end;Fi[	@BiI"Ì      def function(arglist)
        create_through_record(var)
        self.target = var
      end
      
      private
      
      def function(arglist)
        ensure_not_nested
        var = owner.association(through_reflection.name);Fi[	I"Fdata//activerecord_proj/active_record/associations/join_helper.rb;Ti
I"º    module JoinHelper
      def function(arglist)
        Arel::InnerJoin
      end
      
      private
      
      def function(arglist)
        var = []
        chain.each do |arglist|;Fi[	@RiDI"Œ        
        def function(arglist)
          reflection.options
        end
        
        private
        
        def function(arglist)
          var = owners_by_key
          var = var.keys.compact;Fi[	@fiI"        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        private
        
        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]))
        end;Fi[	@niI"2            var.map! { |arglist| var.send(source_reflection.name) }.flatten!
            var.compact!
          end
        end
        
        private
        
        def function(arglist)
          Preloader.new(owners, through_reflection.name, through_scope).run
          Hash[owners.map do |arglist|;Fi[	@qiCI"◊      
      def function(arglist)
        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var
        when Hash then;Fi[	I"Odata//activerecord_proj/active_record/associations/singular_association.rb;Ti#I"ﬁ        yield(var) if block_given?
        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist)
        scope.scope_for_create.stringify_keys.except(klass.primary_key)
      end;Fi[	I"Bdata//activerecord_proj/active_record/attribute_assignment.rb;TiwI"        else
          (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist)
        if object.class.send(:create_time_zone_conversion_attribute?, name, column) then
          Time.zone.local(*var);Fi[	I"Ddata//activerecord_proj/active_record/attribute_methods/read.rb;Ti;I"w        def function(arglist)
          var = var.unpack("h*").first
          generated_attribute_methods.module_eval("            def __temp__#{safe_name}\n              read_attribute(AttrNames::ATTR_#{safe_name}) { |n| missing_attribute(n, caller) }\n            end\n            alias_method #{name.inspect}, :__temp__#{safe_name}\n            undef_method :__temp__#{safe_name}\n", "(string)", (59 + 1))
        end
        
        private
        
        def function(arglist)
          if (attribute_types_cached_by_default == ATTRIBUTE_TYPES_CACHED_BY_DEFAULT) then
            serialized_attributes.include?(var.name).!;Fi[	@ùi\I"°            var.type_cast(var)
          end
        end)
      end
      
      private
      
      def function(arglist)
        read_attribute(var)
      end;Fi[	I"Tdata//activerecord_proj/active_record/attribute_methods/time_zone_conversion.rb;Ti,I"%          else
            super
          end
        end
        
        private
        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end;Fi[	@¢i3I":        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist)
        var.change(:usec => 0) if var
      end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/abstract/connection_pool.rb;TiFI"Ô          synchronize do |arglist|
            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist)
          @var.synchronize(&var)
        end;Fi[	@ßi¡I"®          end
          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist)
        @var[Process.pid]
      end;Fi[	I"]data//activerecord_proj/active_record/connection_adapters/abstract/schema_definitions.rb;TiI"        var[:default] = default unless default.nil?
        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist)
        base.add_column_options!(var, var.merge(:column => (self)))
      end;Fi[	@¨iI"      # to generate the final SQL to create the table.
      def function(arglist)
        (@var.map { |arglist| var.to_sql } * ", ")
      end
      
      private
      
      def function(arglist)
        var = ColumnDefinition.new(var, var, var)
        (@var << var);Fi[	@i(I"Ú      # Lists the valid migration options
      def function(arglist)
        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var
        when BigDecimal then;Fi[	I"\data//activerecord_proj/active_record/connection_adapters/abstract/schema_statements.rb;Ti¶I"-          raise(ArgumentError.new("You must specify at least one column name. Example: remove_columns(:people, :first_name)"))
        end
        var.map { |arglist| quote_column_name(var) }
      end
      
      private
      
      def function(arglist)
        TableDefinition.new(self)
      end;Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract_mysql_adapter.rb;Ti.I"        
        def function(arglist)
          collation and collation.match(/_ci$/).!
        end
        
        private
        
        def function(arglist)
          if adapter.emulate_booleans and var.downcase.index("tinyint(1)") then
            return :boolean;Fi[	@∂i°I"€      
      def function(arglist)
        [remove_column_sql(var, :updated_at), remove_column_sql(var, :created_at)]
      end
      
      private
      
      def function(arglist)
        (version[0] >= 5)
      end;Fi[	@}i'I"+          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) }
          raise(AdapterNotSpecified, "#{spec} database is not configured") unless var;Fi[	@ÄimI"          (var << var)
          (var << build_footer(var.rows.length, var))
          (var.join("\n") + "\n")
        end
        
        private
        
        def function(arglist)
          [].tap do |arglist|
            var.columns.each_with_index do |arglist|;Fi[	@Äi“I"æ      
      def function(arglist)
        @var.last_id
      end
      
      private
      
      def function(arglist)
        @var = Mysql2::Client.new(@var)
        configure_connection;Fi[	@ÉirI"‚        def function(arglist)
          cache.values.each { |arglist| var[:stmt].close }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[Process.pid]
        end;Fi[	@ÉiíI"π        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {}
        log(var, var, var) do |arglist|;Fi[	@†iMI"-      def function(arglist)
        @var, @var, @var, @var, @var = var
        prepare_default_proc
      end
      
      private
      
      def function(arglist)
        @var.default_proc = Proc.new { |arglist| var[var] = connection.columns(var) }
        @var.default_proc = Proc.new do |arglist|;Fi[	@£iSI"‹        def function(arglist)
          cache.values.each { |arglist| dealloc(var[:stmt]) }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[$$]
        end;Fi[	I"6data//activerecord_proj/active_record/fixtures.rb;Ti≈I"ò        var
      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key)
    end;Fi[	@…i≠I"H    
    def function(arglist)
      ActiveRecord::Base.connection_handler.connection_pool_list.map(&:connection)
    end
    
    private
    
    def function(arglist)
      var = ActiveRecord::FixtureSet.create_fixtures(fixture_path, fixture_table_names, fixture_class_names)
      Hash[var.map { |arglist| [var.name, var] }];Fi[	@¶iI"Õ      
      def function(arglist)
        self.class.locking_enabled?
      end
      
      private
      
      def function(arglist)
        var = self.class.locking_column
        var = send(var).to_i;Fi[	I"9data//activerecord_proj/active_record/query_cache.rb;Ti'I"Ê        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    
    def function(arglist)
      ActiveRecord::Base.connection_id = var
      ActiveRecord::Base.connection.clear_query_cache;Fi[	I"8data//activerecord_proj/active_record/reflection.rb;Ti|I"H      # and +other_aggregation+ has an options hash assigned to it.
      def function(arglist)
        (super or (var.kind_of?(self.class) and ((name == var.name) and (var.options and (active_record == var.active_record)))))
      end
      
      private
      
      def function(arglist)
        name.to_s.camelize
      end;Fi[	@”iII"’      
      def function(arglist)
        options.key?(:polymorphic)
      end
      
      private
      
      def function(arglist)
        var = name.to_s.camelize
        var = var.singularize if collection?;Fi[	@”iËI")          raise(HasOneThroughCantAssociateThroughCollection.new(active_record.name, self, through_reflection))
        end
        check_validity_of_inverse!
      end
      
      private
      
      def function(arglist)
        (options[:source_type] or source_reflection.class_name)
      end;Fi[	I">data//activerecord_proj/active_record/relation/batches.rb;TiNI"‘          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    
    def function(arglist)
      "#{quoted_table_name}.#{quoted_primary_key} ASC"
    end;Fi[	I"Cdata//activerecord_proj/active_record/relation/calculations.rb;Ti¥I"P    #   Person.joins(:companies).ids # SELECT people.id FROM people INNER JOIN companies ON companies.person_id = people.id
    def function(arglist)
      pluck(primary_key)
    end
    
    private
    
    def function(arglist)
      (eager_loading? or (includes_values.present? and (var or references_eager_loaded_tables?)))
    end;Fi[	@¬i@I"„        merge_multi_values
        merge_single_values
        relation
      end
      
      private
      
      def function(arglist)
        relation.where_values = merged_wheres
        relation.bind_values = merged_binds;Fi[	@≈i≠I"·      var.from(build_from) if from_value
      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist)
      var = var.reject { |arglist| var.blank? }
      return [] if var.empty?;Fi[	I"Ddata//activerecord_proj/active_record/relation/spawn_methods.rb;Ti;I"    #   Post.order('id asc').only(:where, :order) # uses the specified order
    def function(arglist)
      relation_with(values.slice(*var))
    end
    
    private
    
    def function(arglist)
      var = Relation.new(klass, table, var)
      var.default_scoped = default_scoped;Fi[	I"6data//activerecord_proj/active_record/relation.rb;Ti I"      var = to_a.take([limit_value, 11].compact.min).map!(&:inspect)
      var[10] = "..." if (var.size == 11)
      "#<#{self.class.name} [#{entries.join(", ")}]>"
    end
    
    private
    
    def function(arglist)
      var = with_default_scope
      if var.equal?(self) then;Ti[	I"4data//activerecord_proj/active_record/result.rb;Ti3I"‰      @var = columns.dup
      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist)
      @var ||= (var = @var.map { |arglist| var.dup.freeze }
      @var.map { |arglist| Hash[var.zip(var)] });Fi[	I";data//activerecord_proj/active_record/schema_dumper.rb;TiI"ü      tables(var)
      trailer(var)
      var
    end
    
    private
    
    def function(arglist)
      @var = var
      @var = @var.native_database_types;Fi[	@÷i-I"Ÿ        send(:"#{var}_will_change!")
        var[var] = var
      end
    end
    
    private
    
    def function(arglist)
      var = send(var)
      unless var.is_a?(ActiveSupport::HashWithIndifferentAccess) then;Fi[	I"Bdata//activerecord_proj/active_record/tasks/database_tasks.rb;TixI"I        var = var.first
        var = var.delete_at(1)
        class_for_adapter(var["adapter"]).new(*var).structure_load(var)
      end
      
      private
      
      def function(arglist)
        @var ||= ConnectionAdapters::ConnectionSpecification::Resolver.new(ENV["DATABASE_URL"], {}).spec.config.stringify_keys
      end;Fi[	I"7data//activerecord_proj/active_record/timestamp.rb;TiI"”    def function(arglist)
      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist)
      if self.record_timestamps then
        var = current_time_from_proper_timezone;Fi[	I":data//activerecord_proj/active_record/transactions.rb;Ti3I"˝      def function(arglist)
        set_options_for_callbacks!(var)
        set_callback(:rollback, :after, *var, &var)
      end
      
      private
      
      def function(arglist)
        var = var.last
        if var.is_a?(Hash) and var[:on] then;Fi[	@Ÿi-I""      
      def function(arglist)
        (var.foreign_key? ? (var.name) : (var.name.singularize.foreign_key)).to_sym
      end
      
      private
      
      def function(arglist)
        unless file_name =~ /^[_a-z0-9]+$/ then
          raise(IllegalMigrationNameError.new(file_name));Fi[	I"1data//backup_proj/backup/compressor/bzip2.rb;TiI"Ÿ        instance_eval(&var) if block_given?
        @var = "#{utility(:bzip2)}#{options}"
        @var = ".bz2"
      end
      
      private
      
      def function(arglist)
        " -#{@level}" if @var
      end;Fi[	I"0data//backup_proj/backup/compressor/gzip.rb;TiI"◊        instance_eval(&var) if block_given?
        @var = "#{utility(:gzip)}#{options}"
        @var = ".gz"
      end
      
      private
      
      def function(arglist)
        " -#{@level}" if @var
      end;Fi[	I"0data//backup_proj/backup/compressor/lzma.rb;Ti"I"≠      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Lzma is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        (" --best" if @var or " --fast" if @var)
      end;Fi[	I"2data//backup_proj/backup/compressor/pbzip2.rb;Ti(I"’      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Pbzip2 is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        var = (" --best" if @var or " --fast" if @var)
        var = " -p#{@processors}" if @var;Fi[	I".data//backup_proj/backup/configuration.rb;TiI"Æ      var = eval(self.to_s.sub("Configuration::", ""))
      Logger.warn(Errors::ConfigurationError.new("        [DEPRECATION WARNING]\n        #{self}.defaults is being deprecated.\n        To set pre-configured defaults for #{klass}, use:\n        #{klass}.defaults\n"))
      var.defaults(&var)
    end
    
    private
    
    def function(arglist)
      const_set(var, Module.new { |arglist| extend(Configuration) })
    end;Fi[	I"'data//backup_proj/backup/errors.rb;Ti*I"√          end
        end
        @var = var ? ((msg_prefix + var)) : (class_name)
      end
      
      private
      
      def function(arglist)
        @var ||= (class_name + ": ")
      end;Fi[	I",data//backup_proj/backup/syncer/base.rb;Ti&I"◊      # Adds a path to the @directories array
      def function(arglist)
        (@var << var)
      end
      
      private
      
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end;Fi[	I"&data//bundler_proj/bundler/cli.rb;TiµI":    
    def function(arglist)
      Env.new.write($stdout)
    end
    
    private
    
    def function(arglist)
      Bundler.settings[:cache_all] = options[:all] if options.key?("all")
      if Bundler.definition.sources.any? { |arglist| var.is_a?(Source::Rubygems).! } and Bundler.settings[:cache_all].! then;Fi[	I"-data//bundler_proj/bundler/definition.rb;TiI"º        end
        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist)
      @var.! and (@var.! and (@var.! and (@var.! and @var.!)))
    end;Fi[	I",data//bundler_proj/bundler/dep_proxy.rb;Ti%I"£    
    def function(arglist)
      "#{name} (#{requirement}) #{__platform}"
    end
    
    private
    
    def function(arglist)
      @var.send(*var)
    end;Fi[	I"-data//bundler_proj/bundler/dependency.rb;Ti@I"†      var = super
      (var << "!") if source
      (var << "\n")
    end
    
    private
    
    def function(arglist)
      RUBY_VERSION =~ /^1\.8/
    end;Fi[	I"&data//bundler_proj/bundler/dsl.rb;Ti®I"5    def function(arglist)
      var = caller[0].split(":")[(0..1)].join(":")
      raise(GemfileError, "Undefined local variable or method `#{name}' for Gemfile\n        from #{location}")
    end
    
    private
    
    def function(arglist)
      var.keys.each do |arglist|
        next if String.===(var);Fi[	I"9data//bundler_proj/bundler/endpoint_specification.rb;TiDI"ß    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "#{base_dir}/specifications/#{full_name}.gemspec"
    end;Fi[	I"&data//bundler_proj/bundler/env.rb;Ti&I"…      ((var << "\n\n") << "Gemfile.lock\n")
      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip;Fi[	@iI"∑    
    def function(arglist)
      GraphVizClient.new(self).run
    end
    
    private
    
    def function(arglist)
      var = _groups.values.to_set.flatten
      while true do;Fi[	I"(data//bundler_proj/bundler/index.rb;TiI"∞      else
        raise(ArgumentError, "Source must be an index, not #{index.class}")
      end
    end
    
    private
    
    def function(arglist)
      @var[var]
    end;Fi[	I"+data//bundler_proj/bundler/injector.rb;Ti"I"”      ensure
        Bundler.settings[:frozen] = "1" if var
      end
    end
    
    private
    
    def function(arglist)
      @var.map { |arglist| "gem '#{d.name}', '#{d.requirement}'" }.join("\n")
    end;Fi[	@$iïI"        end
        Bundler.ui.warn("If you want to overwrite skipped stubs, use --force.")
      end
    end
    
    private
    
    def function(arglist)
      var = Bundler.bin_path
      var = File.read(File.expand_path("../templates/Executable.standalone", "(string)"));Fi[	I"5data//bundler_proj/bundler/lazy_specification.rb;TiCI"µ    
    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end;Fi[	I"7data//bundler_proj/bundler/remote_specification.rb;Ti)I"≥    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      @var ||= @var.fetch_spec([@var, @var, @var])
    end;Fi[	@'iUI"º      
      def function(arglist)
        "#{name} (#{version})"
      end
      
      private
      
      def function(arglist)
        @var ||= (var = {}
        ALL.each do |arglist|;Fi[	I"/data//bundler_proj/bundler/rubygems_ext.rb;TiHI"¨    
    def function(arglist)
      (dependencies - development_dependencies)
    end
    
    private
    
    def function(arglist)
      var = ""
      if var.any? then;Fi[	@0i∫I"¬        end
        ENV["RUBYOPT"] = var.join(" ")
      end
    end
    
    private
    
    def function(arglist)
      var = Dir["#{cache_path}/*.gem"]
      var = var.delete_if do |arglist|;Fi[	I"+data//bundler_proj/bundler/settings.rb;TifI"π    
    def function(arglist)
      ENV["BUNDLE_IGNORE_CONFIG"]
    end
    
    private
    
    def function(arglist)
      var = var.to_s.sub(".", "__").upcase
      "BUNDLE_#{key}";Fi[	I"1data//bundler_proj/bundler/shared_helpers.rb;Ti!I"¥    
    def function(arglist)
      find_gemfile
    end
    
    private
    
    def function(arglist)
      var = ENV["BUNDLE_GEMFILE"]
      return var if var and var.empty?.!;Fi[	@8iûI"›      
      def function(arglist)
        "#{base_name}-#{shortref_for_path((cached_revision or revision))}"
      end
      
      private
      
      def function(arglist)
        @var = true
        @var = @var = nil;Fi[	@Bi_I"∂      
      def function(arglist)
        name
      end
      
      private
      
      def function(arglist)
        @var ||= Bundler.app_cache.join(app_cache_dirname)
      end;Fi[	@Gi|I"        @var = []
        var.remotes.each { |arglist| add_remote(var.to_s) }
        true
      end
      
      private
      
      def function(arglist)
        var = @var.map { |arglist| "#{p}/#{spec.file_name}" }
        var = var.find { |arglist| File.exist?(var) };Fi[	I"+data//bundler_proj/bundler/spec_set.rb;TipI"“        (var << var)
      end
      SpecSet.new(var)
    end
    
    private
    
    def function(arglist)
      var = @var.find { |arglist| (var.name == "rake") }
      @var ||= ([var] + tsort).compact.uniq;Fi[	I"(data//cancan_proj/cancan/ability.rb;Ti·I"    def function(arglist)
      var.send(:rules).each { |arglist| (rules << var.dup) }
      self
    end
    
    private
    
    def function(arglist)
      unless var.kind_of?(Symbol) then
        var = ((var.class == Class) ? (var) : (var.class)).name.underscore;Fi[	I"4data//cancan_proj/cancan/controller_resource.rb;TiI"∂    
    def function(arglist)
      ([:new, :create] + [@var[:new]].flatten)
    end
    
    private
    
    def function(arglist)
      var.to_s.underscore.gsub("/", "_")
    end;Fi[	I"Edata//cancan_proj/cancan/model_adapters/active_record_adapter.rb;TiyI"@            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact
        if defined? ActiveRecord::Relation and var.any? { |arglist| var.kind_of?(ActiveRecord::Relation) } then;Fi[	@riVI"≈        end
      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class
      ((var == Class) or (var == Module));Fi[	@ÑiπI"–    # associated with this command.
    def function(arglist)
      @var.each { |arglist| var.close unless var[:closed] }
    end
    
    private
    
    def function(arglist)
      options[:logger]
    end;Fi[	@ßi_I"∏        var = @var.dup
        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var;Fi[	@™iMI"h          var = "#{from.stream}-capistrano-diff-from"
          var = "#{to.stream}-capistrano-diff-to"
          [change_or_create_stream(var, var), change_or_create_stream(var, var), scm(:diff, "-v", var, "-V", var, "-a")].join(" && ")
        end
        
        private
        
        def function(arglist)
          repository.split("/")[0]
        end;Fi[	@≤iEI"        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        
        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("-r #{revision}".chomp)
        end;Fi[	@∏iOI"Ω          else
            return var
          end
        end
        
        private
        
        def function(arglist)
          case variable(:scm_verbose)
          when nil then;Fi[	@—iCI"          end
          logger.trace("command finished in #{(elapsed * 1000).round}ms")
          var
        end
        
        private
        
        def function(arglist)
          @var ||= (configuration.logger or Capistrano::Logger.new(:output => (STDOUT)))
        end;Fi[	@◊i5I"˙          else
            File.expand_path(configuration[:copy_cache], Dir.pwd)
          end rescue nil
        end
        
        private
        
        def function(arglist)
          copy_repository_to_local_cache
          build(copy_cache);Fi[	@‡iI"+            var.remote.command("rsync") unless copy_exclude.empty?
            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist)
          File.join(shared_path, (configuration[:repository_cache] or "cached-copy"))
        end;Fi[	@„iI"      class UnsharedRemoteCache < RemoteCache
        def function(arglist)
          super.check { |arglist| var.remote.writable(repository_cache) }
        end
        
        private
        
        def function(arglist)
          configuration[:repository_cache]
        end;Fi[	I"8data//compass_proj/compass/commands/project_base.rb;TiII"            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then
          File.basename(strip_trailing_separator(var[:project_name]));Fi[	@˚i•I"¸      
      def function(arglist)
        (relative_assets or (http_images_path == :relative))
      end
      
      private
      
      def function(arglist)
        var = ((var.keys - ATTRIBUTES) - ARRAY_ATTRIBUTES)
        if (var.size == 1) then;Fi[	I"Cdata//compass_proj/compass/sass_extensions/functions/colors.rb;Ti;I"    var = (var.alpha * 255).round
    var = var.to_s(16).rjust(2, "0")
    Sass::Script::String.new("##{alphastr}#{color.send(:hex_str)[(1..-1)]}".upcase)
  end
  
  private
  
  def function(arglist)
    if (var > 0) then
      var = (var + ((100 - var) * (var / 100.0)));Fi[	I"Mdata//compass_proj/compass/sass_extensions/functions/gradient_support.rb;TiyI"X      var = color_stops_in_percentages(var)
      var = radial_svg(var, var, var, var)
      inline_image_string(var.gsub(/\s+/, " "), "image/svg+xml")
    end
    
    private
    
    def function(arglist)
      (var.is_a?(ColorStop) or ((var.is_a?(Sass::Script::List) and ColorStop.new(*var.value)) or ColorStop.new(var))) rescue nil
    end;Fi[	I"Idata//compass_proj/compass/sass_extensions/functions/inline_image.rb;Ti I"◊    var = [var].flatten.pack("m").gsub("\n", "")
    var = "url('data:#{mime_type};base64,#{data}')"
    Sass::Script::String.new(var)
  end
  
  private
  
  def function(arglist)
    return var if var
    case var;Fi[	@ièI"            PARENT.match(name)
            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end;Fi[	@$i*I"+        
        def function(arglist)
          (@var.inject(0) { |arglist| var = (var + var.efficiency) } ** @var.length)
        end
        
        private
        
        def function(arglist)
          var = Compass::SassExtensions::Sprites::ImageRow.new(width)
          var.add(var) if var;Fi[	@+iDI"W        
        def function(arglist)
          @var.respond_to?(var) ? (@var.send(var, *var, &var)) : (super)
        end
        
        private
        
        def function(arglist)
          @var ||= Compass.configuration.sprite_engine.to_s.scan(/([^_.]+)/).flatten.map do |arglist|
            "#{chunk[0].chr.upcase}#{chunk[(1..-1)]}";Fi[	@3i™I"≠        
        def function(arglist)
          @var.language
        end
        
        private
        
        def function(arglist)
          (index == 0)
        end;Fi[	I"1data//cucumber_prok/cucumber/ast/scenario.rb;TinI"û        @var = var
        yield
        @var = nil
      end
      
      private
      
      def function(arglist)
        (@var.failed? or @var)
      end;Fi[	I"-data//cucumber_prok/cucumber/ast/step.rb;Ti^I"‰      
      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "_").gsub(/\./, "_").gsub(/:/, "_")
      end
      
      private
      
      def function(arglist)
        var = 0
        var.select do |arglist|;Fi[	@6iLI"±        
        def function(arglist)
          "row_#{line}"
        end
        
        private
        
        def function(arglist)
          @var.index(self)
        end;Fi[	I"4data//cucumber_prok/cucumber/ast/tree_walker.rb;TiI"˙      # For most formatters this is a no-op.
      def function(arglist)
        broadcast(var, var, var)
      end
      
      private
      
      def function(arglist)
        var = extract_method_name_from(caller)
        var.gsub!("visit_", "");Fi[	I"6data//cucumber_prok/cucumber/cli/configuration.rb;TiûI"Û      
      def function(arglist)
        @var[:paths].empty? ? (["features"]) : (@var[:paths])
      end
      
      private
      
      def function(arglist)
        if @var[:autoformat] then
          require("cucumber/formatter/pretty");Fi[	@9i;I"À        @var.parse!(@var)
        Cucumber.logger = @var.log
        @var
      end
      
      private
      
      def function(arglist)
        begin
          (return false unless configuration.drb?;Fi[	I"2data//cucumber_prok/cucumber/configuration.rb;Ti*I"’    
    def function(arglist)
      @var[:autoload_code_paths]
    end
    
    private
    
    def function(arglist)
      { :autoload_code_paths => (["features/support", "features/step_definitions"]) }
    end;Fi[	I";data//cucumber_prok/cucumber/core_ext/instance_exec.rb;Ti2I"≤        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity
    Cucumber::RUBY_1_9 ? (var) : ((var == -1) ? (0) : (var));Fi[	I"1data//cucumber_prok/cucumber/feature_file.rb;TiMI"†          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING
      var.each_line do |arglist|;Fi[	I"6data//cucumber_prok/cucumber/formatter/console.rb;Ti≠I"¥      
      def function(arglist)
        @var = []
      end
      
      private
      
      def function(arglist)
        var = var.join("_").to_sym
        var = FORMATS[var];Fi[	I"4data//cucumber_prok/cucumber/formatter/debug.rb;TiI"È        @var = (@var - 2) if var.to_s =~ /^after/
        print(var)
        @var = (@var + 2) if var.to_s =~ /^before/
      end
      
      private
      
      def function(arglist)
        @var.puts("#{indent}#{text}")
      end;Fi[	I"4data//cucumber_prok/cucumber/formatter/junit.rb;TioI"◊          build_testcase(var, var.status, var.exception, var)
        end
        @var = false if @var
      end
      
      private
      
      def function(arglist)
        @var = (@var + var)
        var = @var;Fi[	I"5data//cucumber_prok/cucumber/formatter/pretty.rb;TiÃI"<        var = cell_prefix(var)
        @var.print(((" " + format_string("#{prefix}#{padded}", var)) + ::Cucumber::Term::ANSIColor.reset(" |")))
        @var.flush
      end
      
      private
      
      def function(arglist)
        @var.puts if (@var == 6)
        var = var.empty? ? ([var]) : (var.split("\n"));Fi[	I"7data//cucumber_prok/cucumber/formatter/progress.rb;TiAI"≥      
      def function(arglist)
        @var = true
      end
      
      private
      
      def function(arglist)
        print_steps(:pending)
        print_steps(:failed);Fi[	I"4data//cucumber_prok/cucumber/formatter/rerun.rb;TiGI"–      
      def function(arglist)
        @var = true if [:failed, :pending, :undefined].index(var)
      end
      
      private
      
      def function(arglist)
        yield if @var
        @var = true;Fi[	I"4data//cucumber_prok/cucumber/formatter/steps.rb;TiI"≥      
      def function(arglist)
        print_summary
      end
      
      private
      
      def function(arglist)
        var = 0
        @var.keys.sort.each do |arglist|;Fi[	I"6data//cucumber_prok/cucumber/formatter/summary.rb;TiI"N      def function(arglist)
        var = lambda { |arglist| var.steps(var) }
        (dump_count(var.steps.length, "step") + dump_status_counts(var, &var))
      end
      
      private
      
      def function(arglist)
        var = [:failed, :skipped, :undefined, :pending, :passed].map do |arglist|
          var = var.call(var);Fi[	@MiúI"À      
      def function(arglist)
        @var.invoke_steps(var, @var, var)
      end
      
      private
      
      def function(arglist)
        var = @var.features_paths
        if var.empty? then;Fi[	@PiGI"–      
      def function(arglist)
        invoked_step_definition_hash[StepDefinitionLight.new(var, var)] = nil
      end
      
      private
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@SiCI"∞      
      def function(arglist)
        # do nothing
      end
      
      private
      
      def function(arglist)
        var.map do |arglist|
          var = var.cells;Fi[	I";data//cucumber_prok/cucumber/py_support/py_language.rb;Ti*I"ÿ      
      def function(arglist)
        @var.step_matches(var, var)
      end
      
      private
      
      def function(arglist)
        var = File.basename(var)[(0...-File.extname(var).length)]
        begin;Fi[	@ViÑI"ß      
      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist)
        if @var then
          @var = @var.call;Fi[	I"<data//cucumber_prok/cucumber/rb_support/rb_transform.rb;Ti I"       
      def function(arglist)
        convert_captures(strip_anchors(@var.source))
      end
      
      private
      
      def function(arglist)
        var.gsub(/(\()(?!\?:)/, "(?:")
      end;Fi[	I"<data//cucumber_prok/cucumber/runtime/features_loader.rb;TiI"¥      def function(arglist)
        load unless @var
        @var
      end
      
      private
      
      def function(arglist)
        var = Ast::Features.new
        var = {};Fi[	@bi~I"        var = best_matches(var, var) if (var.size > 1) and guess_step_matches?
        raise(Ambiguous.new(var, var, guess_step_matches?)) if (var.size > 1)
        var[0]
      end
      
      private
      
      def function(arglist)
        @var.guess?
      end;Fi[	I";data//cucumber_prok/cucumber/runtime/user_interface.rb;Ti3I"Õ      #
      def function(arglist)
        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin
          Timeout.timeout(var) { |arglist| STDIN.gets };Fi[	@ei"I"Û      
      def function(arglist)
        WireException.new(var, @var.host, @var.port)
      end
      
      private
      
      def function(arglist)
        Timeout.timeout(@var.timeout("connect")) { |arglist| socket.puts(var) }
      end;Fi[	I"Fdata//cucumber_prok/cucumber/wire_support/wire_step_definition.rb;TiI"˜      def function(arglist)
        var = var.map { |arglist| prepare(var) }
        @var.invoke(@var, var)
      end
      
      private
      
      def function(arglist)
        return var unless var.is_a?(Cucumber::Ast::Table)
        var.raw;Fi[	@mi·I"      
      def function(arglist)
        Devise.navigational_formats.include?(request_format)
      end
      
      private
      
      def function(arglist)
        Devise.mappings.each do |arglist|
          instance_variable_set("@current_#{m.name}", nil);Fi[	@siNI")    
    def self.add_module(arglist)
      class_eval("        def #{m}?\n          self.modules.include?(:#{m})\n        end\n", "(string)", (113 + 1))
    end
    
    private
    
    def function(arglist)
      @var = (var[:failure_app] or Devise::FailureApp)
      if @var.is_a?(String) then;Fi[	I"3data//devise_proj/devise/models/timeoutable.rb;TiI"Ù      
      def function(arglist)
        self.class.timeout_in
      end
      
      private
      
      def function(arglist)
        return false unless respond_to?(:remember_created_at)
        remember_created_at and remember_expired?.!;Fi[	I"8data//devise_proj/devise/strategies/rememberable.rb;TiI"“          return pass
        end
        success!(var) if validate(var)
      end
      
      private
      
      def function(arglist)
        super
        if var.respond_to?(:extend_remember_period=) then;Fi[	I"9data//diaspora_proj/controllers/admins_controller.rb;TiLI"ª  
  def function(arglist)
    @var = Statistics.new.generate_correlations
  end
  
  private
  
  def function(arglist)
    sprintf("%0.02f", (((var - var) / var.to_f) * 100)).to_f
  end;Fi[	I":data//diaspora_proj/controllers/aspects_controller.rb;TinI"¥      @var.contacts_visible = true
    end
    @var.save
  end
  
  private
  
  def function(arglist)
    @var = Person.find(var)
    if @var = current_user.contact_for(@var) then;Fi[	I"9data//diaspora_proj/controllers/blocks_controller.rb;Ti"I"      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist)
    if var = current_user.contact_for(var) then
      current_user.disconnect(var, :force => (true));Fi[	I";data//diaspora_proj/controllers/comments_controller.rb;TiAI"‰      end
      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist)
    if user_signed_in? then
      @var = current_user.find_visible_shareable_by_id(Post, params[:post_id]);Fi[	I";data//diaspora_proj/controllers/contacts_controller.rb;TiI"µ  def function(arglist)
    @var = true
    @var = Person.community_spotlight
  end
  
  private
  
  def function(arglist)
    @var = case params[:set]
    when "only_sharing" then;Fi[	I"Cdata//diaspora_proj/controllers/invitation_codes_controller.rb;TiI"˛  def function(arglist)
    sign_out(current_user) if user_signed_in?
    redirect_to(new_user_registration_path(:invite => ({ :token => (params[:id]) })))
  end
  
  private
  
  def function(arglist)
    InvitationCode.find_by_token!(params[:id])
  end;Fi[	I">data//diaspora_proj/controllers/invitations_controller.rb;TiII"π      flash[:error] = I18n.t("invitations.create.no_more")
      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist)
    User.email_regexp.match(var).present?
  end;Fi[	@çi,I"W      var.all { |arglist| render(:layout => (false)) }
      var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist)
    @var ||= if params[:post_id] then
      (current_user.find_visible_shareable_by_id(Post, params[:post_id]) or raise(ActiveRecord::RecordNotFound.new));Fi[	I"9data//diaspora_proj/controllers/people_controller.rb;Ti®I"é        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id }
    var = {};Fi[	I"9data//diaspora_proj/controllers/photos_controller.rb;Ti|I"¿    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist)
    if request.params[:qqfile].is_a?(String).! then
      var[:qqfile];Fi[	I";data//diaspora_proj/controllers/profiles_controller.rb;Ti:I"Ò        end
      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("profiles.edit.your_tags_placeholder"))) then
      @var[:tag_string].split(" ").each do |arglist|;Fi[	I":data//diaspora_proj/controllers/publics_controller.rb;TiKI"O    FEDERATION_LOGGER.info("recieved a private message for user:#{@user.id}")
    Resque.enqueue(Jobs::ReceiveEncryptedSalmon, @var.id, CGI.unescape(params[:xml]))
    render(:nothing => (true), :status => 202)
  end
  
  private
  
  def function(arglist)
    if params[:xml].nil? then
      render(:nothing => (true), :status => 422);Fi[	I"@data//diaspora_proj/controllers/registrations_controller.rb;TiI"¿  
  def function(arglist)
    super
  end
  
  private
  
  def function(arglist)
    return true if AppConfig.settings.enable_registrations?
    return true if invite and invite.can_be_used?;Fi[	I"Edata//diaspora_proj/controllers/share_visibilities_controller.rb;TiI"K    params[:shareable_type] ||= "Post"
    var = current_user.toggle_hidden_shareable(accessible_post)
    render(:nothing => (true), :status => 200)
  end
  
  private
  
  def function(arglist)
    @var ||= params[:shareable_type].constantize.where(:id => (params[:post_id])).select("id, guid, author_id, created_at").first
  end;Fi[	I"Bdata//diaspora_proj/controllers/status_messages_controller.rb;TiCI"        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "all_aspects")) then
      current_user.aspect_ids;Fi[	I":data//diaspora_proj/controllers/streams_controller.rb;Ti6I"ˆ  def function(arglist)
    gon.tagFollowings = tags
    stream_responder(Stream::FollowedTag)
  end
  
  private
  
  def function(arglist)
    @var ||= var.new(current_user, :max_time => (max_time)) if var.present?
    respond_with do |arglist|;Fi[	I"7data//diaspora_proj/controllers/tags_controller.rb;Ti-I"î        end))
      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name])
  end;Fi[	I"4data//diaspora_proj/helpers/analytics_helper.rb;Ti"I";        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var)
    yield(var);Fi[	@öiI"§  
  def function(arglist)
    var.instance_of?(Reshare)
  end
  
  private
  
  def function(arglist)
    if var.stream_posts.empty? then
      (Time.now + 1).to_i;Fi[	I"=data//diaspora_proj/mailers/notification_mailers/base.rb;TiI";      var = Mail::Address.new(var)
      var.display_name = var
      var.format
    end
    
    private
    
    def function(arglist)
      var = { :from => (AppConfig.mail.sender_address.get), :host => ("#{AppConfig.pod_uri.host}"), :to => (name_and_address(@var.name, @var.email)) }
      if @var.present? then;Fi[	I",data//diaspora_proj/mailers/notifier.rb;TiQI"‡  
  def function(arglist)
    send_notification(:confirm_email, var)
  end
  
  private
  
  def function(arglist)
    @var = NotificationMailers.const_get(var.to_s.camelize).new(*var)
    with_recipient_locale do |arglist|;Fi[	I"*data//diaspora_proj/models/contact.rb;TiSI"	        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist)
    if person_id and person.closed_account? then
      (errors[:base] << "Cannot be in contact with a closed account");Fi[	I"*data//diaspora_proj/models/message.rb;TiZI"  
  def function(arglist)
    var[:plain_text] ? (self.text) : (ERB::Util.h(self.text))
  end
  
  private
  
  def function(arglist)
    if self.parent and self.parent.participants.include?(self.author).! then
      (errors[:base] << "Author is not participating in the conversation");Fi[	I")data//diaspora_proj/models/person.rb;Ti>I"˝      self.url = ("http://" + self.url) unless self.url.match(/https?:\/\//)
      self.url = (self.url + "/") if self.url[-1, 1].!=("/")
    end
  end
  
  private
  
  def function(arglist)
    Webfinger.new(self.diaspora_handle).fetch
    self.reload;Fi[	I"*data//diaspora_proj/models/profile.rb;TiæI"’      errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["created_at", "updated_at", "person_id"])
  end;Fi[	I"*data//diaspora_proj/models/reshare.rb;TiPI"ö      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch
    var.save! unless var.persisted?;Fi[	I"3data//diaspora_proj/models/services/twitter.rb;TiI"ˇ  
  def function(arglist)
    client.user(nickname).profile_image_url_https("original")
  end
  
  private
  
  def function(arglist)
    @var ||= Twitter::Client.new(:oauth_token => (self.access_token), :oauth_token_secret => (self.access_secret))
  end;Fi[	I"3data//diaspora_proj/models/share_visibility.rb;Ti I"7      var = var.map { |arglist| [var, var.id, var.class.base_class.to_s] }
      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist)
    if shareable.public? then
      (errors[:base] << "Cannot create visibility for a public object");Fi[	I"'data//diaspora_proj/models/user.rb;Ti¡I"o    self.password = var
    self.password_confirmation = var
    self.save(:validate => (false))
  end
  
  private
  
  def function(arglist)
    (self.attributes.keys - ["id", "username", "encrypted_password", "created_at", "updated_at", "locked_at", "serialized_private_key", "getting_started", "disable_mail", "show_community_spotlight_in_stream", "email"])
  end;Fi[	I"!data//haml_proj/haml/exec.rb;TiåI"_        raise("[BUG] Unrecognized color #{color}") unless COLORS[var]
        return var if (ENV["TERM"].nil? or (ENV["TERM"].empty? or STDOUT.tty?.!))
        return "[#{COLORS[color]}m#{str}[0m"
      end
      
      private
      
      def function(arglist)
        return if var.nil?
        var = "wb" if @var[:unix_newlines] and (var == "w");Fi[	I"$data//haml_proj/haml/options.rb;TiÊI"å        var[var] = send(var)
        var
      end
    end
    
    private
    
    def function(arglist)
      self.class.defaults
    end;Fi[	I"#data//homebrew_proj/caveats.rb;TiI"«  
  def function(arglist)
    caveats.empty?
  end
  
  private
  
  def function(arglist)
    @var ||= [f.prefix, f.opt_prefix, f.linked_keg].map do |arglist|
      Keg.new(var.realpath) rescue nil;Fi[	I"%data//homebrew_proj/cmd/audit.rb;Ti.I"    audit_conflicts
    audit_patches
    audit_text
  end
  
  private
  
  def function(arglist)
    (@var << var)
  end;Fi[	I"$data//homebrew_proj/cmd/info.rb;TizI"Ã        raise("No such formula or keg")
      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "http://") or ((var[(0..7)] == "https://") or (var[(0..5)] == "ftp://")))
  end;Fi[	I"$data//homebrew_proj/cmd/list.rb;TiI"ª        end
      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|
      var.basename.to_s;Fi[	I"#data//homebrew_proj/cmd/tap.rb;TiUI"ﬁ      var = (var + link_tap_formula(var))
    end
    puts("Tapped #{count} formula")
  end
  
  private
  
  def function(arglist)
    ARGV.first =~ /^(\S+)\/(homebrew-)?(\w+)$/
    raise("Invalid usage") unless $1 and $3;Fi[	I"&data//homebrew_proj/cmd/update.rb;Ti,I"Î      puts("Updated Homebrew from #{master_updater.initial_revision[0, 8]} to #{master_updater.current_revision[0, 8]}.")
      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir[".git/*"].empty? then;Fi[	@@ibI"}      end
    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp
  end;Fi[	@∏i0I"Ó    else
      "#{HOMEBREW_REPOSITORY}/Library/Formula/#{name}.rb"
    end
  end
  
  private
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-list --abbrev-commit HEAD -- Library/Formula/#{name}.rb`.split;Fi[	I"-data//homebrew_proj/download_strategy.rb;TisI"ì    else
      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist)
    var = Dir["*"]
    case var.length;Fi[	@GiÄI"¨        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "").split(/:/)
    var = var.pop;Fi[	I"'data//homebrew_proj/extend/ARGV.rb;Ti≠I"Æ    ensure
      replace(var)
    end
  end
  
  private
  
  def function(arglist)
    @var ||= named.map { |arglist| var.include?("/") ? (var) : (var.downcase) }.uniq
  end;Fi[	I")data//homebrew_proj/macos/xquartz.rb;Ti`I"¢  
  def function(arglist)
    (prefix / "share")
  end
  
  private
  
  def function(arglist)
    ((prefix.to_s == "/opt/X11") or MacOS::CLT.installed?).!
  end;Fi[	I"%data//homebrew_proj/metafiles.rb;TiI"À  def function(arglist)
    return false if [".DS_Store", "INSTALL_RECEIPT.json"].include?(var)
    include?(var).!
  end
  
  private
  
  def function(arglist)
    var = var.to_s
    var = var.downcase;Fi[	I"#data//homebrew_proj/patches.rb;Ti'I"‘    return unless external_patches?
    curl(*external_curl_args)
    external_patches.each { |arglist| var.stage! }
  end
  
  private
  
  def function(arglist)
    @var.select { |arglist| var.external? }
  end;Fi[	I"#data//homebrew_proj/version.rb;Ti®I"≈        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  
  def function(arglist)
    raise("Unknown version scheme #{@scheme} was requested.")
  end;Fi[	I"6data//jekyll_proj/jekyll/generators/pagination.rb;Ti1I"Ø          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["paginate_path"]
      var.sub(":num", var.to_s);Fi[	@i8I"        # @since 3.1.0
        def function(arglist)
          positionally_operable? ? (position.sub(/\.\d/, ".$")) : (position)
        end
        
        private
        
        def function(arglist)
          document.persisted? and document._id_changed?
        end;Fi[	I"<data//mongoid_proj/lib/mongoid/criterion/marshalable.rb;Ti I"        @var, @var, @var, @var, @var, @var = var
        @var = load_hash(Origin::Selector, var)
        @var = load_hash(Origin::Options, var)
      end
      
      private
      
      def function(arglist)
        send(var).inject({}) do |arglist|
          var[var] = var;Fi[	@1iâI"¬          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|
          send(var).reject! do |arglist|;Fi[	@ôi©I"À        # @since 2.1.0
        def function(arglist)
          entries.uniq
        end
        
        private
        
        def function(arglist)
          entries.send(var, *var, &var)
        end;Fi[	@ΩiäI"      
      def function(arglist)
        var.accept(self)
      end
      
      private
      
      def function(arglist)
        unless (var.value.size == 4) then
          raise(ArgumentError, "expected an+b node to contain 4 tokens, but is #{node.value.inspect}");Fi[	I"1data//nokogiri_proj/nokogiri/xml/document.rb;Ti€I"À      def function(arglist)
        raise("JRuby only method") unless Nokogiri.jruby?
        return toJavaDocument
      end
      
      private
      
      def function(arglist)
        "/"
      end;Fi[	I"-data//nokogiri_proj/nokogiri/xml/node.rb;Ti2I"J          var = var.is_a?(XML::Node) ? (var) : (var)
          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist)
        var = (var == :next) ? (:add_next_sibling_node) : (:add_previous_sibling_node)
        var = (var == :next) ? (:reverse_each) : (:each);Fi[	@ﬂiXI"Ù          var = ParserContext.memory(var)
          yield(var) if block_given?
          var.parse_with(self)
        end
        
        private
        
        def function(arglist)
          var.upcase!
          unless ENCODINGS[var] then;Fi[	I"1data//paperclip_proj/paperclip/attachment.rb;Ti1I"˝    def function(arglist)
      var = :"#{name}_#{var}"
      instance.send(var) if instance.respond_to?(var)
    end
    
    private
    
    def function(arglist)
      @var[:path].respond_to?(:call) ? (@var[:path].call(self)) : (@var[:path])
    end;Fi[	I"<data//paperclip_proj/paperclip/content_type_detector.rb;TiI"ù          end
        end
      end).to_s
    end
    
    private
    
    def function(arglist)
      File.exists?(@var) and (File.size(@var) == 0)
    end;Fi[	I"Idata//paperclip_proj/paperclip/file_command_content_type_detector.rb;TiI"«    
    def function(arglist)
      type_from_file_command
    end
    
    private
    
    def function(arglist)
      var = begin
        Paperclip.run("file", "-b --mime :file", :file => (@var));Fi[	I"/data//paperclip_proj/paperclip/geometry.rb;Ti|I"∫      else
        scale_to(var)
      end
    end
    
    private
    
    def function(arglist)
      if (var.horizontal? or var.square?) then
        [("%dx" % var.width), var.width];Fi[	I"@data//paperclip_proj/paperclip/geometry_detector_factory.rb;TiI"    def function(arglist)
      var = GeometryParser.new(geometry_string.strip).make
      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin
        silence_stream(STDERR) do |arglist|;Fi[	I">data//paperclip_proj/paperclip/geometry_parser_factory.rb;TiI"      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist)
      if var = (@var and @var.match(FORMAT)) then
        @var = var[1];Fi[	I"Cdata//paperclip_proj/paperclip/io_adapters/abstract_adapter.rb;TiI"“    
    def function(arglist)
      @var = var.gsub(OS_RESTRICTED_CHARACTERS, "_")
    end
    
    private
    
    def function(arglist)
      @var ||= TempfileFactory.new.generate(original_filename)
    end;Fi[	I"Edata//paperclip_proj/paperclip/io_adapters/attachment_adapter.rb;TiI"¥        # do nothing
      end
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename
      @var = @var.content_type;Fi[	I"?data//paperclip_proj/paperclip/io_adapters/file_adapter.rb;Ti
I"Ò    def function(arglist)
      @var = var
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename if @var.respond_to?(:original_filename)
      @var ||= File.basename(@var.path);Fi[	I"Hdata//paperclip_proj/paperclip/io_adapters/uploaded_file_adapter.rb;TiI"¬    
    class << self
      attr_accessor(:content_type_detector)
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename
      @var = determine_content_type;Fi[	I"-data//paperclip_proj/paperclip/schema.rb;TiBI"…    module CommandRecorder
      def function(arglist)
        record(:add_attachment, var)
      end
      
      private
      
      def function(arglist)
        [:remove_attachment, var]
      end;Fi[	I"2data//paperclip_proj/paperclip/storage/fog.rb;Ti}I"
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        if @var[:fog_host].respond_to?(:call) then
          @var[:fog_host].call(self);Fi[	@i˙I"⁄          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then;Fi[	I"Kdata//paperclip_proj/paperclip/validators/attachment_size_validator.rb;Ti#I"^        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator")
        end
      end
      
      private
      
      def function(arglist)
        if var = var[:in] then
          if var[:in].respond_to?(:call).! then;Fi[	@iíI"Ú        # Test if this record is in a list
        def function(arglist)
          send(position_column).nil?.!
        end
        
        private
        
        def function(arglist)
          increment_positions_on_all_items
        end;Fi[	I"ddata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication/mem_cache_store.rb;Ti2I"+      return false if ((var - Time.now.to_i).abs > OpenID::Nonce.skew)
      @var.write(nonce_key(var, var), var, :expires_in => (OpenID::Nonce.skew))
      return true
    end
    
    private
    
    def function(arglist)
      "openid_association_#{digest(server_url)}_#{digest(handle)}"
    end;Fi[	I"Tdata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication.rb;TimI"Ø    else
      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist)
    (params[:openid_identifier] or params[:openid_url])
  end;Fi[	I"Sdata//redmine_proj/plugins/open_id_authentication/test/mem_cache_store_test.rb;TiMI"      var = OpenID::Nonce.mk_nonce(3600)
      assert_nonce(var, false, var, "Old nonce #{old_nonce.inspect} passed")
    end
  end
  
  private
  
  def function(arglist)
    var = OpenID::CryptUtil.random_string(20, nil)
    var = OpenID::CryptUtil.random_string(128, ALLOWED_HANDLE);Fi[	I"9data//redmine_proj/plugins/rfpdf/lib/fpdf/chinese.rb;TiÎI"À    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I":data//redmine_proj/plugins/rfpdf/lib/fpdf/japanese.rb;TiÙI"À    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I"8data//redmine_proj/plugins/rfpdf/lib/fpdf/korean.rb;Ti⁄I"À    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I"Ddata//redmine_proj/plugins/rfpdf/lib/rfpdf/action_controller.rb;TiI"÷      def function(arglist)
        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var)
      end
      
      private
      
      def function(arglist)
        var = var.dup
        var;Fi[	@ÆiI"    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!(var)
    end
    
    private
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!((self.class.read_inheritable_attribute(:rfpdf) or {})) do |arglist|;Fi[	@.iI"≠    else
      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "")) then;Fi[	I"3data//redmine_proj/redmine/activity/fetcher.rb;TiII"Ì        var.sort! { |arglist| (var.event_datetime <=> var.event_datetime) }
        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist)
        @@var[var]
      end;Fi[	I"9data//redmine_proj/redmine/core_ext/active_record.rb;Ti	I"”  module FinderMethods
    def function(arglist)
      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@Oi2I"E        var = { :top => (var), :zoom => (var), :subject_width => (var), :g_width => (var), :indent => 0, :indent_increment => 5, :top_increment => 5, :format => :pdf, :pdf => (var) }
        render(var)
        var.Output
      end
      
      private
      
      def function(arglist)
        var ||= @var
        var = {};Fi[	I"6data//redmine_proj/redmine/helpers/time_report.rb;TiI"Á      
      def function(arglist)
        (@var or load_available_criteria)
      end
      
      private
      
      def function(arglist)
        unless @var.empty? then
          var = ["tyear", "tmonth", "tweek", "spent_on"];Fi[	I")data//redmine_proj/redmine/themes.rb;TiGI"Í      
      def function(arglist)
        "/themes/#{dir}/javascripts/#{source}"
      end
      
      private
      
      def function(arglist)
        if var then
          Dir.glob("#{path}/#{dir}/*.#{ext}").collect do |arglist|;Fi[	I"*data//redmine_proj/SVG/Graph/Graph.rb;Ti'I"Ì          end
          var.attributes["transform"] = "translate(#{x_offset} #{y_offset})"
        end
      end
      
      private
      
      def function(arglist)
        if (var < var) then
          var = partition(var, var, var);Fi[	I"-data//redmine_proj/SVG/Graph/Schedule.rb;TiÜI"Ê      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end
      
      private
      
      def function(arglist)
        var = [@var[0][-1], @var[1].max].max
        var = [@var[0][0], @var[1].min].min;Fi[	I"/data//redmine_proj/SVG/Graph/TimeSeries.rb;TiYI"Ê      
      def function(arglist)
        get_x_values.collect { |arglist| Time.at(var).strftime(x_label_format) }
      end
      
      private
      
      def function(arglist)
        var = []
        var, var, var = x_range;Fi[	I":data//rspec_proj/spec/example/shared_example_group.rb;TiI"ª        
        def function(arglist)
          shared_example_groups.length
        end
        
        private
        
        def function(arglist)
          @var ||= []
        end;Fi[	I")data//rspec_proj/spec/matchers/be.rb;Ti+I"      
      [:==, :<, :<=, :>=, :>, :===].each do |arglist|
        define_method(var) { |arglist| BeComparedTo.new(var, var) }
      end
      
      private
      
      def function(arglist)
        @var.empty? ? ("") : (parenthesize(inspected_args.join(", ")))
      end;Fi[	@œi{I"◊      
      def function(arglist)
        "#{prefix_to_sentence}#{expected_to_sentence}#{args_to_sentence}"
      end
      
      private
      
      def function(arglist)
        "#{@expected}?".to_sym
      end;Fi[	I"*data//rspec_proj/spec/matchers/has.rb;TiI"»      
      def function(arglist)
        "have key #{@args[0].inspect}"
      end
      
      private
      
      def function(arglist)
        "#{sym.to_s.sub("have_", "has_")}?".to_sym
      end;Fi[	I"+data//rspec_proj/spec/matchers/have.rb;TiEI"‹      
      def function(arglist)
        (@var.respond_to?(var) or super)
      end
      
      private
      
      def function(arglist)
        @var = var
        if (var = if defined? ActiveSupport::Inflector then;Fi[	I"2data//rspec_proj/spec/matchers/match_array.rb;Ti'I"Ó      
      def function(arglist)
        "contain exactly #{_pretty_print(@expected)}"
      end
      
      private
      
      def function(arglist)
        var.all? { |arglist| var.respond_to?(:<=>) } ? (var.sort) : (var)
      end;Fi[	I"6data//rspec_proj/spec/matchers/raise_exception.rb;TiGI"≤      
      def function(arglist)
        "raise #{expected_exception}"
      end
      
      private
      
      def function(arglist)
        case @var
        when nil then;Fi[	I"3data//rspec_proj/spec/matchers/throw_symbol.rb;Ti8I"‘      
      def function(arglist)
        "throw #{expected}"
      end
      
      private
      
      def function(arglist)
        @var.nil? ? ("a Symbol") : ("#{@expected_symbol.inspect}#{args}")
      end;Fi[	I"3data//rspec_proj/spec/mocks/error_generator.rb;Ti0I"      
      def function(arglist)
        __raise("#{intro} yielded |#{arg_list(*args_to_yield)}| to block with arity of #{arity}")
      end
      
      private
      
      def function(arglist)
        if @var then
          "#{@declared_as} #{@name.inspect}";Fi[	@¨iWI"’      #:nodoc:
      def function(arglist)
        __mock_proxy.reset
      end
      
      private
      
      def function(arglist)
        if Mock.===(self) then
          @var ||= Proxy.new(self, @var, @var);Fi[	I"(data//rspec_proj/spec/mocks/mock.rb;Ti'I"‹      
      def function(arglist)
        inspect.gsub("<", "[").gsub(">", "]")
      end
      
      private
      
      def function(arglist)
        __mock_proxy.record_message_received(var, var, var)
        begin;Fi[	@ØiçI"ˆ      
      def function(arglist)
        @var.find { |arglist| var.matches(var, var) }
      end
      
      private
      
      def function(arglist)
        $rspec_mocks.add(@var) unless $rspec_mocks.nil?
        define_expected_method(var);Fi[	I")data//rspec_proj/spec/mocks/space.rb;TiI"¿      def function(arglist)
        mocks.each { |arglist| var.rspec_reset }
        mocks.clear
      end
      
      private
      
      def function(arglist)
        @var ||= []
      end;Fi[	I"2data//rspec_proj/spec/runner/configuration.rb;TißI"‰      
      def function(arglist)
        @var ||= false
      end
      
      private
      
      def function(arglist)
        var, var = args_and_options(*var)
        [get_type_from_options(var)].flatten.each do |arglist|;Fi[	@⁄iI"·          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	I"-data//rspec_proj/spec/runner/reporter.rb;TimI"Œ        def function(arglist)
          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist)
        @var.formatters
      end;Fi[	I"1data//sinatra_proj/sinatra/showexceptions.rb;Ti&I"i        var["rack.errors"] = var
        [500, { "Content-Type" => (var), "Content-Length" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist)
      (Request.new(var).preferred_type("text/plain", "text/html") == "text/html").! and [/curl/].index { |arglist| var.=~(var["HTTP_USER_AGENT"]) }
    end;Fi[	I"3data//SiriProxy_proj/siriproxy/command_line.rb;Ti{I"◊  
  def function(arglist)
    puts("\n#{@option_parser}\n")
  end
  
  private
  
  def function(arglist)
    $APP_CONFIG = OpenStruct.new(YAML.load_file(File.expand_path("~/.siriproxy/config.yml")))
    @var = nil;Fi[	I"?data//state_machine_proj/state_machine/event_collection.rb;TiÄI"ù        end
      end)
      var
    end
    
    private
    
    def function(arglist)
      var and var[:on] ? ([fetch(var.delete(:on))]) : (self)
    end;Fi[	I")data//twitter_proj/twitter/client.rb;TiZI"ÿ    # Perform an HTTP PUT request
    def function(arglist)
      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin
        connection.send(var.to_sym, var, var) do |arglist|;Fi[	I",data//twitter_proj/twitter/creatable.rb;TiI"∆    # @return [Time]
    def function(arglist)
      @var ||= Time.parse(@var[:created_at]) if created?
    end
    
    private
    
    def function(arglist)
      @var[:created_at].nil?.!
    end;Fi[	@GiI"†          end
        end
        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var
        when /\.jpe?g/i then;Fi[	I"'data//twitter_proj/twitter/user.rb;TieI"ö    
    def function(arglist)
      @var[:status].nil?.!
    end
    
    private
    
    def function(arglist)
      var.sub(/^https/i, "http")
    end;Fi[@'@(@)I" ;FI"def function(arglist);Fi„[„[	@fiII"/              self.class::MethodAttribute.new(var, @var, var)
            else
              self.class::Attribute.new(var, @var, var)
            end
          end
        end
        
        def function(arglist)
          require("builder") unless defined? ::Builder
          options[:indent] ||= 2;Fi[	@liI"Ç          if options[:without] then
            var = option_call(var, :without)
            record_error(var, var, :without, var) if var.to_s.=~(var)
          end
        end
      end
      
      def function(arglist)
        unless options.include?(:with).^(options.include?(:without)) then
          raise(ArgumentError, "Either :with or :without must be supplied (but not both)");Fi[	@oi$I"w          var = options[var]
          unless ((var.is_a?(Integer) and (var >= 0)) or (var == Float::INFINITY)) then
            raise(ArgumentError, ":#{key} must be a nonnegative Integer or Infinity")
          end
        end
      end
      
      def function(arglist)
        var = tokenize(var)
        var = var.respond_to?(:length) ? (var.length) : (var.to_s.length);Fi[	I"Ddata//activemodel_proj/active_model/validations/numericality.rb;Ti>I"◊            Kernel.Float(var)
          rescue ArgumentError, TypeError
            nil
          end
        end
      end
      
      def function(arglist)
        var.to_i if var.to_s =~ /\A[+-]?\d+\Z/
      end;Fi[	I"Ydata//activerecord_proj/active_record/associations/builder/collection_association.rb;Ti%I"u      [:finder_sql, :counter_sql].each do |arglist|
        if options.include?(var) then
          ActiveSupport::Deprecation.warn("The :#{name} association option is deprecated. Please find an alternative (such as using scopes).")
        end
      end
    end
    
    def function(arglist)
      if block_extension then
        @var = var = Module.new(&block_extension);Fi[	@	i4I"#          @var = proc { |arglist| instance_exec(var, &var).extending(var) }
        else
          @var = proc { |arglist| extending(var) }
        end
      end
    end
    
    def function(arglist)
      @var ||= "#{model.name.demodulize}#{name.to_s.camelize}AssociationExtension"
    end;Fi[	I"Zdata//activerecord_proj/active_record/associations/builder/has_and_belongs_to_many.rb;TiI"x      [:delete_sql, :insert_sql].each do |arglist|
        if options.include?(var) then
          ActiveSupport::Deprecation.warn("The :#{name} association option is deprecated. Please find an alternative (such as using has_many :through).")
        end
      end
    end
    
    def function(arglist)
      var = self.name
      model.send(:include, Module.new do |arglist|;Fi[	@?i3I"            var = $2.to_s
            var = "*" if (var.blank? or (var =~ /,/ or var =~ /\.\*/))
            "SELECT #{$1}COUNT(#{count_with}) FROM"
          end
        end
      end
      
      def function(arglist)
        interpolate(options[:finder_sql])
      end;Fi[	@?i≠I"            var.call(owner, var)
          else
            var.send(var, owner, var)
          end
        end
      end
      
      def function(arglist)
        var = "#{callback_name}_for_#{reflection.name}"
        (owner.class.send(var.to_sym) or []);Fi[	I"Odata//activerecord_proj/active_record/associations/has_many_association.rb;TipI"            update_counter(-var.delete_all)
          else
            update_counter(-var.update_all(reflection.foreign_key => (nil)))
          end
        end
      end
      
      def function(arglist)
        owner.attribute_present?(reflection.association_primary_key)
      end;Fi[	@qifI"[        grouped_records(var).each do |arglist|
          var.each do |arglist|
            preloader_for(var).new(var, var, var, preload_scope).run
          end
        end
      end
      
      def function(arglist)
        Hash[records_by_reflection(var).map do |arglist|
          [var, var.group_by { |arglist| association_klass(var, var) }];Fi[	@ziI"f          super.dup.tap do |arglist|
            self.class.serialized_attributes.each_key do |arglist|
              var[var] = var[var].unserialized_value if var.key?(var)
            end
          end
        end
        
        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value;Fi[	@ßi”I"            establish_connection(var, var.spec)
          else
            owner_to_pool[var.name] = nil
          end
        end
      end
      
      def function(arglist)
        var = @var.values.find { |arglist| var[var.name] }
        var and var[var.name];Fi[	@≥i&I"1              execute("INSERT INTO #{sm_table} (version) VALUES ('#{v}')")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist)
        if var = native_database_types[var.to_sym] then
          var = (var.is_a?(Hash) ? (var[:name]) : (var)).dup;Fi[	I"Vdata//activerecord_proj/active_record/connection_adapters/abstract/transaction.rb;Ti_I"            var.rolledback!(parent.closed?)
          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        records.uniq.each do |arglist|
          begin;Fi[	@0	iiI"ﬁ            var.committed!
          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false
      end;Fi[	I"Rdata//activerecord_proj/active_record/connection_adapters/abstract_adapter.rb;TiWI"»          unless in_use then
            @var = true
            @var = Time.now
          end
        end
      end
      
      def function(arglist)
        var.connection = self
        @var = var;Fi[	@∂i¶I"Y        execute_and_free(var, "SCHEMA") do |arglist|
          each_hash(var).map do |arglist|
            new_column(var[:Field], var[:Default], var[:Type], (var[:Null] == "YES"), var[:Collation])
          end
        end
      end
      
      def function(arglist)
        super(var, var.reverse_merge(:options => "ENGINE=InnoDB"))
      end;Fi[	@ÄivI"|            var.columns.each_with_index do |arglist|
              var = ([var] + var.rows.map { |arglist| var[var].nil? ? ("NULL") : (var[var].to_s) })
              (var << var.map(&:length).max)
            end
          end
        end
        
        def function(arglist)
          var = 1
          (("+" + var.map { |arglist| ("-" * (var + (var * 2))) }.join("+")) + "+");Fi[	@ãi/I"÷              end]
            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var)
        end;Fi[	@ãihI"¥              else
                var
              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil;Fi[	@êi2I"Â              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist)
          super.insert
        end;Fi[	@£i¨I"≥            self.null = var[:null] if var.include?(:null)
            self.precision = var[:precision] if var.include?(:precision)
            self.scale = var[:scale] if var.include?(:scale)
          end
        end
      end
      
      def function(arglist)
        unless columns(var).detect { |arglist| (var.name == var.to_s) } then
          raise(ActiveRecord::ActiveRecordError, "Missing column #{table_name}.#{column_name}");Fi[	@£i¯I"O            var = { :name => (var.gsub(/(^|_)(#{var})_/, "\1#{to}_")) }
            var[:unique] = true if var.unique
            add_index(var, var, var)
          end
        end
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, var] }]
        var.each { |arglist| var[var.last] = var.first };Fi[	@…i‰I"œ          var.each do |arglist|
            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "#{@path}.yml"
    end;Fi[	@…iRI"ã        rescue LoadError => var
          if ActiveRecord::Base.logger then
            ActiveRecord::Base.logger.warn("Unable to load #{file_name}, underlying cause #{e.message} \n\n #{e.backtrace.join("\n")}")
          end
        end
      end
      
      def function(arglist)
        var ? (var = var.map { |arglist| var.to_s }) : (var = fixture_table_names)
        var.each do |arglist|;Fi[	@…i…I"˚        end
        @var.each_value do |arglist|
          ActiveRecord::FixtureSet.instantiate_fixtures(self, var, load_instances?)
        end
      end
    end
    
    def function(arglist)
      use_instantiated_fixtures.!=(:no_instances)
    end;Fi[	I"9data//activerecord_proj/active_record/inheritance.rb;Ti%I"5            superclass.descends_from_active_record?
          else
            ((superclass == Base) or columns_hash.include?(inheritance_column).!)
          end
        end
      end
      
      def function(arglist)
        (:true == (@var ||= descends_from_active_record? ? (:false) : (:true)))
      end;Fi[	@”i‡I"        unless options[:polymorphic] then
          if has_inverse? and inverse_of.nil? then
            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@Ωi I".              module_eval("                def #{method}(*args, &block)\n                  scoping { @klass.#{method}(*args, &block) }\n                end\n", "(string)", (39 + 1))
            else
              module_eval("                def #{method}(*args, &block)\n                  scoping { @klass.send(#{method.inspect}, *args, &block) }\n                end\n", "(string)", (46 + 1))
            end
          end
        end
        
        def function(arglist)
          @var.synchronize do |arglist|
            return if method_defined?(var);Fi[	@Ωi]I"Ï          end
        else
          ActiveRecord::Relation
        end
      end
    end
    
    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))))
    end;Fi[	I"Edata//activerecord_proj/active_record/relation/finder_methods.rb;TiI"–          order(arel_table[primary_key].asc).limit(1).to_a.first
        else
          limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      if loaded? then
        @var.last;Fi[	@U	i*I"ø          to_a.last
        else
          reverse_order.limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      var.none? { |arglist| var.collection? }
    end;Fi[	@≈iI"±          end
        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) }
    end;Fi[	@Ái-I"Î          true
        else
          false
        end
      end
    end
    
    def function(arglist)
      return [] if var.blank?
      (var.scan(/([a-zA-Z_][.\w]+).?\./).flatten.map { |arglist| var.downcase }.uniq - ["raw_sql_"]);Ti[	I":data//activerecord_proj/active_record/sanitization.rb;TióI"B            else
              raise(PreparedStatementInvalid, "missing value for :#{match} in #{statement}")
            end
          end
        end
      end
      
      def function(arglist)
        if var.respond_to?(:map) and var.acts_like?(:string).! then
          if var.respond_to?(:empty?) and var.empty? then;Fi[	@»itI"—                  end
                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["#{self}_ignore_default_scope"]
        end;Fi[	@Úi%I"◊            database_url_config
          else
            ActiveRecord::Base.configurations[var[:env]]
          end
        end
      end
      
      def function(arglist)
        begin
          (var = var.first;Fi[	@ÚiéI"/            yield(var)
          else
            $stderr.puts("This task only modifies local databases. #{configuration["database"]} is on a remote host.")
          end
        end
      end
      
      def function(arglist)
        (var["host"].blank? or LOCAL_HOSTS.include?(var["host"]))
      end;Fi[	I"Hdata//activerecord_proj/active_record/tasks/mysql_database_tasks.rb;Ti+I"U            if configuration["encoding"] then
              $stderr.puts("(If you set the charset manually, make sure you have a matching collation)")
            end
          end
        end
      end
      
      def function(arglist)
        establish_connection(configuration)
        connection.drop_database(configuration["database"]);Fi[	@g	inI"l            Mysql2::Error
          else
            defined? Mysql ? (Mysql::Error) : (StandardError)
          end
        end
      end
      
      def function(arglist)
        "GRANT ALL PRIVILEGES ON #{configuration["database"]}.*\n  TO '#{configuration["username"]}'@'localhost'\nIDENTIFIED BY '#{configuration["password"]}' WITH GRANT OPTION;\n"
      end;Fi[	I"Mdata//activerecord_proj/active_record/tasks/postgresql_database_tasks.rb;TiI"            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist)
        establish_master_connection
        connection.drop_database(configuration["database"]);Fi[	@iMI"*      @var.each do |arglist|
        if var = @var.find { |arglist| (var.name == var.name) } then
          var.instance_variable_set(:@type, var.type)
        end
      end
    end
    
    def function(arglist)
      raise("Specs already loaded") if @var
      @var.each { |arglist| var.cached! };Fi[	@iPI"&        next unless var.instance_of?(Source::Path)
        specs_changed?(var) do |arglist|
          (var.class == var.class) and (var.path == var.path)
        end
      end
    end
    
    def function(arglist)
      var = false
      var = @var.find { |arglist| Source::Rubygems.===(var) };Fi[	@i1I"÷            end
          end
          var = var
        end
      end
    end
    
    def function(arglist)
      var = Hash.new { |arglist| var[var] = Set.new }
      @var.current_dependencies.each do |arglist|;Fi[	@$i£I"e        var = var = Pathname(var.full_gem_path).join(var.bindir, var).relative_path_from(var)
        File.open("#{bin_path}/#{executable}", "w", 493) do |arglist|
          var.puts(ERB.new(var, nil, "-").result(binding))
        end
      end
    end
    
    def function(arglist)
      var = Bundler.settings[:path]
      var = File.join(var, "bundler");Fi[	I"2data//bundler_proj/bundler/lockfile_parser.rb;TimI"          var = var.split(",").map { |arglist| var.strip } if var
          var = Gem::Dependency.new(var, var)
          (@var.dependencies << var)
        end
      end
    end
    
    def function(arglist)
      (@var << Gem::Platform.new($1)) if var =~ /^  (.*)$/
    end;Fi[	@'iÌI"¡              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by)
      (var.required_by << var);Fi[	@0i@I"≠              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then
        dependencies;Fi[	@0iÀI"        var.each do |arglist|
          Bundler.ui.info("  * #{File.basename(path)}")
          File.delete(var)
        end
      end
    end
    
    def function(arglist)
      var = Dir["#{cache_path}/*/.bundlecache"]
      var = var.delete_if do |arglist|;Fi[	@0iﬁI"›          var = File.dirname(var)
          Bundler.ui.info("  * #{File.basename(path)}")
          FileUtils.rm_rf(var)
        end
      end
    end
    
    def function(arglist)
      root.join("vendor/cache")
    end;Fi[	@BiÆI"        ensure
          if var and var then
            Dir.chdir(var) { |arglist| FileUtils.rm_rf(var) if File.exist?(var) }
          end
        end
      end
      
      def function(arglist)
        var = "#{type}_hooks"
        return unless Gem.respond_to?(var);Fi[	I">data//bundler_proj/bundler/vendor/thor/parser/argument.rb;Ti7I"      else
        if @var and @var.is_a?(Array).! then
          raise(ArgumentError, "An argument cannot have an enum other than an array.")
        end
      end
    end
    
    def function(arglist)
      self.class::VALID_TYPES.include?(var.to_sym)
    end;Fi[	I"?data//bundler_proj/bundler/vendor/thor/parser/arguments.rb;Ti!I"—          @var[var.human_name] = var.default
        else
          (@var << var) if var.required?
        end
      end
    end
    
    def function(arglist)
      @var = var.dup
      @var.each do |arglist|;Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/basic.rb;Ti<I"‹            yield)
          ensure
            $KCODE = var
          end
        end
      end
      
      def function(arglist)
        say("#{statement} ", var)
        stdin.gets.tap { |arglist| var.strip! if var };Fi[	@MiI"î      relevant_rules(var, var).each do |arglist|
        if var.only_raw_sql? then
          raise(Error, "The can? and cannot? call cannot be used with a raw sql 'can' definition. The checking code cannot be determined for #{action.inspect} #{subject.inspect}")
        end
      end
    end
    
    def function(arglist)
      relevant_rules(var, var).each do |arglist|
        if var.only_block? then;Fi[	@MiI"ä      relevant_rules(var, var).each do |arglist|
        if var.only_block? then
          raise(Error, "The accessible_by call cannot be used with a block 'can' definition. The SQL cannot be determined for #{action.inspect} #{subject.inspect}")
        end
      end
    end
    
    def function(arglist)
      { :read => ([:index, :show]), :create => ([:new]), :update => ([:edit]) }
    end;Fi[	@Pi+I"U          self.resource_instance ||= load_resource_instance
        else
          self.collection_instance ||= load_collection if load_collection?
        end
      end
    end
    
    def function(arglist)
      unless skip?(:authorize) then
        @var.authorize!(authorization_action, (resource_instance or resource_class_with_parent));Fi[	@Pi~I"“          end
        else
          adapter.find(resource_base, id_param)
        end
      end
    end
    
    def function(arglist)
      ModelAdapters::AbstractAdapter.adapter_class(resource_class)
    end;Fi[	I"3data//cancan_proj/cancan/inherited_resource.rb;TiI"º          assign_attributes(var)
        else
          @var.send(:resource)
        end
      end
    end
    
    def function(arglist)
      @var.send(:end_of_association_chain)
    end;Fi[	@SiQI"9        else
          @var.reverse.inject(false_sql) do |arglist|
            merge_conditions(var, tableized_conditions(var.conditions).dup, var.base_behavior)
          end
        end
      end
      
      def function(arglist)
        return var unless var.kind_of?(Hash)
        var.inject({}) do |arglist|;Fi[	@SiÄI"£          else
            var = @var.detect { |arglist| var.conditions.kind_of?(ActiveRecord::Relation) }
            raise(Error, "Unable to merge an Active Record scope with other conditions. Instead use a hash or SQL for #{rule.actions.first} #{rule.subjects.first} ability.")
          end
        end
      end
      
      def function(arglist)
        if var.blank? then
          var ? (true_sql) : (false_sql);Fi[	@SiîI"Õ            else
              "not (#{conditions}) AND (#{sql})"
            end
          end
        end
      end
      
      def function(arglist)
        sanitize_sql(["?=?", true, false])
      end;Fi[	@ri2I"∂              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!
    end;Fi[	@riÉI"Ÿ              end
            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first
      matches_conditions_hash?(var, (@var[var.class.name.downcase.to_sym] or {}));Fi[	I"1data//capistrano_proj/capistrano/cli/help.rb;TiI"˝            explain_task(var, options[:explain])
          else
            execute_requested_actions_without_help(var)
          end
        end
      end
      
      def function(arglist)
        var = options[:tool]
        if var.is_a?(String) then;Fi[	@¢	iJI"            puts
            puts("Extended help may be available for these tasks.")
            puts("Type `#{File.basename($0)} -e taskname' to view it.")
          end
        end
      end
      
      def function(arglist)
        var = var.find_task(var)
        if var.nil? then;Fi[	@|i±I"        [:pre_vars, :vars].each do |arglist|
          options[var].keys.each do |arglist|
            options[var][var] = coerce_variable(options[var][var])
          end
        end
      end
      
      def function(arglist)
        case var
        when /^"(.*)"$/ then;Fi[	@ÑiSI"µ              else
                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var;Fi[	@ói=I"Ø            var = ServerDefinition.new("127.0.0.1", :user => (var.user), :port => (var.open(var.host, (var.port or 22))))
            SSH.connection_strategy(var, @var) do |arglist|
              Net::SSH::Gateway.new(var, var, var)
            end
          end
        end
        
        def function(arglist)
          if @var[:logger] then
            @var[:logger].debug("establishing connection to `#{server}' via gateway");Fi[	I"@data//capistrano_proj/capistrano/configuration/execution.rb;Ti|I"0            logger.info("exception while rolling back: #{e.class}, #{e.message}", var.task.fully_qualified_name)
          ensure
            pop_task_call_frame
          end
        end
      end
      
      def function(arglist)
        var = TaskCallFrame.new(var)
        task_call_frames.push(var);Fi[	I">data//capistrano_proj/capistrano/configuration/servers.rb;TiPI"6              var.is_a?(Array) ? (roles[var.to_sym]) : (roles[var.to_sym].servers)
            end.flatten
            var.select { |arglist| var.include?(var) }
          end
        end
      end
      
      def function(arglist)
        var = var.split(/,/) if String.===(var)
        var = build_list(var);Fi[	@◊iI"g          if build_script then
            execute("running build script on #{directory}") do |arglist|
              Dir.chdir(var) { |arglist| system(build_script) }
            end
          end
        end
        
        def function(arglist)
          super.check do |arglist|
            var.local.command(source.local.command) if source.local.command;Fi[	@◊iØI"Ö          execute("Compressing #{destination} to #{filename}") do |arglist|
            Dir.chdir(copy_dir) do |arglist|
              system(compress(File.basename(destination), File.basename(filename)).join(" "))
            end
          end
        end
        
        def function(arglist)
          FileUtils.rm(filename) rescue nil
          FileUtils.rm_rf(destination) rescue nil;Fi[	I"1data//capistrano_proj/capistrano/transfer.rb;TidI"F          prepare_scp_transfer(var, var, var)
        else
          raise(ArgumentError, "unsupported transport type: #{transport.inspect}")
        end
      end
    end
    
    def function(arglist)
      var = (callback or Proc.new do |arglist|
        logger.trace("[#{channel[:host]}] #{name}") if logger and (var == 0);Fi[	@∑	i¢I"&          var.download(var, var, var, &var)
        else
          raise(ArgumentError, "unsupported transfer direction: #{direction.inspect}")
        end
      end
    end
    
    def function(arglist)
      if var.is_a?(String) then
        var.gsub(/\$CAPISTRANO:HOST\$/, var.xserver.host);Fi[	@∑	i±I"–          var
        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("expected a file to upload")
      var = session_map[var.session];Fi[	I"*data//compass_proj/compass/actions.rb;TiOI"Ó        if File.exists?(var) then
          File.unlink(var)
          log_action(:remove, basename(var), options)
        end
      end
    end
    
    def function(arglist)
      relativize(var) { |arglist| File.basename(var) }
    end;Fi[	I"4data//compass_proj/compass/commands/registry.rb;Ti I"Ù          else
            raise(Compass::Error, "Command not found: #{name}")
          end
        end
      end
    end
    
    def function(arglist)
      var = /^#{Regexp.escape(var)}/
      @var.keys.detect { |arglist| var.to_s.=~(var) };Fi[	I"9data//compass_proj/compass/configuration/adapters.rb;Ti,I"›            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end;Fi[	@˚iÅI"À                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= []
        (@var << [var, var]);Fi[	I"-data//compass_proj/compass/frameworks.rb;TinI"÷          var
        else
          "          No Usage!\n".gsub(/^ {8}/, "")
        end
      end
    end
    
    def function(arglist)
      var = ""
      var = Compass::Frameworks::ALL.inject(0) do |arglist|;Fi[	I"6data//compass_proj/compass/installers/manifest.rb;TiÄI"Ú            open(var) { |arglist| eval(var.read, instance_binding, var) }
          else
            eval("discover :all", instance_binding, var)
          end
        end
      end
      
      def function(arglist)
        binding
      end;Fi[	I">data//compass_proj/compass/installers/template_context.rb;TiI"
        unless instance_methods.include?(var.to_s) then
          define_method(var) do |arglist|
            (config.send(var) or config.default_for(var))
          end
        end
      end
      
      def function(arglist)
        Compass.configuration
      end;Fi[	I"Rdata//compass_proj/compass/sass_extensions/functions/cross_browser_support.rb;TiBI"É        else
          var
        end
      end
    end
  end
  
  def function(arglist)
    CSS2FallbackValue.new(var, var)
  end;Fi[	@!iMI",              var.left = var.to_i
              (@var << var)
              var = (var + var.width)
            end
          end
        end
        
        def function(arglist)
          require("rational")
          var = @var.inject(1) { |arglist| var.repeat_x? ? (var.lcm(var.width)) : (var) };Fi[	@.i(I"C          for var in sprite_names do
            unless var =~ /\A#{Sass::SCSS::RX::IDENT}\Z/ then
              raise(Sass::SyntaxError, "#{sprite_name} must be a legal css identifier")
            end
          end
        end
        
        def function(arglist)
          "#{path}-s#{uniqueness_hash}.png"
        end;Fi[	I"8data//cucumber_prok/cucumber/ast/feature_element.rb;Ti0I"Ò            else
              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("U*").length)
            end
          end
        end
      end
      
      def function(arglist)
        var.detect { |arglist| var.=~(name) }
      end;Fi[	@3iwI"3              end
              @var.each { |arglist| var.visit_table_cell(var) }
              var.visit_exception(@var, :failed) if @var
            end
          end
        end
        
        def function(arglist)
          unless header? then
            var.step_mother.with_hooks(self) do |arglist|;Fi[	@3iI"Í                @var ||= var.reported_exception
                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end;Fi[	@6iÆI"          if var.value.!=(var.value) and (var.value.to_s == var.value.to_s) then
            var.inspect!
            var.inspect!
          end
        end
      end
      
      def function(arglist)
        @var = var.map do |arglist|
          var = var.line rescue -1;Fi[	@ôiñI"            @var.puts
            var.each { |arglist| @var.puts(format_string(var, :tag)) }
            @var.flush
          end
        end
      end
      
      def function(arglist)
        @var.each { |arglist| print_message(var) }
        empty_messages;Fi[	@<iHI"˘              @var.p("Expand All", :id => "expander")
              @var.p("Collapse All", :id => "collapser")
            end
          end
        end
      end
      
      def function(arglist)
        print_stats(var)
        (@var << "</div>");Fi[	@<i{I"Ë          var[(1..-1)].each do |arglist|
            @var.text!(var.strip)
            @var.br
          end
        end
      end
      
      def function(arglist)
        @var = true
        (@var << "<div class=\"background\">");Fi[	@<i‹I"            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      
      def function(arglist)
        (@var << "<script type=\"text/javascript\">document.getElementById('duration').innerHTML = \"Finished in <strong>#{format_duration(features.duration)} seconds</strong>\";</script>")
        (@var << "<script type=\"text/javascript\">document.getElementById('totals').innerHTML = \"#{print_stat_string(features)}\";</script>");Fi[	@JipI"ù            var.status = Ast::StepInvocation.worst_status(var.map { |arglist| var[:status] })
            var = var.inject(0) { |arglist| (var[:duration] + var) }
            var.mean_duration = (var / var.length)
          end
        end
      end
      
      def function(arglist)
        @var.unmatched_step_definitions.each do |arglist|
          var = StepDefKey.new(var.regexp_source, var.file_colon_line);Fi[	@Vi?I"            @var = ::Spec::Matchers)
          rescue LoadError => var
            @var = Module.new { |arglist| }
          end
        end
      end
      
      def function(arglist)
        @var.map do |arglist|
          if var = var.arguments_from(var) then;Fi[	@biñI"Œ            end
          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then
          log.debug("  * #{file}\n");Fi[	I"@data//cucumber_prok/cucumber/wire_support/wire_exception.rb;TiI"Ω            var["backtrace"].split("\n")
          else
            var["backtrace"]
          end
        end
      end
      
      def function(arglist)
        (@var or super)
      end;Fi[	I",data//devise_proj/devise/failure_app.rb;TiÑI"‰          { :error => (i18n_message) }.send(var)
        else
          i18n_message
        end
      end
    end
    
    def function(arglist)
      var, var = var.split("#")
      var = ActiveSupport::Inflector.camelize(var);Fi[	I"0data//devise_proj/devise/mailers/helpers.rb;Ti:I"ˆ            Devise.mailer_sender.call(var.name)
          else
            Devise.mailer_sender
          end
        end
      end
      
      def function(arglist)
        var = [self.class.mailer_name]
        if self.class.scoped_views? then;Fi[	@sizI"          @var = []
        else
          @var = (self.routes - Array(var[:skip]).map(&var))
        end
      end
    end
    
    def function(arglist)
      var = lambda { |arglist| var.to_s.singularize.to_sym }
      if (var[:skip_helpers] == true) then;Fi[	I"4data//devise_proj/devise/models/rememberable.rb;Ti8I"¨            var
          else
            raise("authenticable_salt returned nil for the #{self.class.name} model. In order to use rememberable, you must ensure a password is always set or have a remember_token column in your model or implement your own rememberable_value in the model with custom logic.")
          end
        end
      end
      
      def function(arglist)
        self.class.rememberable_options
      end;Fi[	@äiGI"Î      end
      if AppConfig.git_revision.present? then
        headers["X-Git-Revision"] = AppConfig.git_revision
      end
    end
  end
  
  def function(arglist)
    if user_signed_in? then
      I18n.locale = current_user.language;Fi[	@äikI"{            break
          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil)
  end;Fi[	I"Edata//diaspora_proj/controllers/aspect_memberships_controller.rb;Ti"I":      respond_to do |arglist|
        var.js { |arglist| render(:text => (var), :status => 403) }
        var.html { |arglist| redirect_to(:back) }
      end
    end
  end
  
  def function(arglist)
    @var = Person.find(params[:person_id])
    @var = current_user.aspects.where(:id => (params[:aspect_id])).first;Fi[	@Ÿi!I"           flash[:error] = I18n.t("aspects.create.failure")
          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist)
    @var = Aspect.new
    @var = params[:person_id];Fi[	@ﬂi/I"˛      respond_to do |arglist|
        var.mobile { |arglist| redirect_to(:back) }
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    render(:layout => (false))
  end;Fi[	@‚iI"I        var = (params[:aspect_ids] or current_user.aspects.map(&:id))
        @var = Person.all_from_aspects(var, current_user).for_json
        render(:json => (@var.to_json))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.contacts.sharing.includes(:aspect_memberships)
    render(:layout => (false));Fi[	I"7data//diaspora_proj/controllers/home_controller.rb;TiI"º        end
      else
        render(:show, :layout => "post")
      end
    end
  end
  
  def function(arglist)
    if session[:mobile_view].nil? then
      session[:mobile_view] = true;Fi[	@Ìi4I"        end
        @var = @var.paginate(:page => (params[:page]), :per_page => 15)
        @var = hashes_for_people(@var, @var)
      end
    end
  end
  
  def function(arglist)
    @var = :search
    @var = Person.where(:diaspora_handle => (search_query.downcase));Fi[	@i7I"Œ        end
      else
        legacy_create
      end
    end
  end
  
  def function(arglist)
    var = current_user.person_id
    @var = Photo.where(:id => (params[:photo_id]), :author_id => (var)).first;Fi[	I"8data//diaspora_proj/controllers/posts_controller.rb;TiI"    respond_to do |arglist|
      var.all do |arglist|
        render(:template => "errors/not_public", :status => 404)
      end
    end
  end
  
  def function(arglist)
    mark_corresponding_notifications_read if user_signed_in?
    respond_to do |arglist|;Fi[	@
i&I"+      var.mobile { |arglist| render("posts/show", :layout => "application") }
      var.json do |arglist|
        render(:json => (PostPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    render(:text => (post_iframe_url(params[:id])), :layout => (false))
  end;Fi[	@
i?I"-      var.html { |arglist| redirect_to(post_path(var)) }
      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).older(@var)
    respond_to do |arglist|;Fi[	@
iII"      var.html { |arglist| redirect_to(post_path(var)) }
      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    respond_with(PostInteractionPresenter.new(@var, current_user))
  end;Fi[	@ÛiI"‰    respond_to do |arglist|
      var.json do |arglist|
        render(:json => (PersonPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.person
    @var = :person_edit;Fi[	@iCI"        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist)
    session[:a_ids] = params[:a_ids] if params[:a_ids].present?
  end;Fi[	I"Adata//diaspora_proj/controllers/tag_followings_controller.rb;Ti&I"    else
      respond_to do |arglist|
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    respond_to do |arglist|
      var.json { |arglist| render(:json => (tags.to_json), :status => 200) };Fi[	@iI"Ä      respond_to do |arglist|
        var.json { |arglist| render(:nothing => (true), :status => 422) }
        var.html { |arglist| redirect_to(tag_path("partytimeexcellent")) }
      end
    end
  end
  
  def function(arglist)
    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]));Fi[	@êi]I"Å      var.js { |arglist| render(:nothing => (true), :status => 204) }
      var.all do |arglist|
        redirect_to((var ? (new_user_session_path) : (edit_user_path)))
      end
    end
  end
  
  def function(arglist)
    if params[:user] and (params[:user][:current_password] and current_user.valid_password?(params[:user][:current_password])) then
      current_user.close_account!;Fi[	@i
I"“    include_analytics("mixpanel") do |arglist|
      javascript_tag do |arglist|
        "          (function(d,c){var a,b,g,e;a=d.createElement('script');a.type='text/javascript';a.async=!0;a.src=('https:'===d.location.protocol?'https:':'http:')+'//api.mixpanel.com/site_media/js/api/mixpanel.2.js';b=d.getElementsByTagName('script')[0];b.parentNode.insertBefore(a,b);c._i=[];c.init=function(a,d,f){var b=c;'undefined'!==typeof f?b=c[f]=[]:f='mixpanel';g='disable track track_pageview track_links track_forms register register_once unregister identify name_tag set_config'.split(' ');\n          for(e=0;e<g.length;e++)(function(a){b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,0)))}})(g[e]);c._i.push([a,d,f])};window.mixpanel=c})(document,[]);\n          mixpanel.init(\"#{AppConfig.privacy.mixpanel_uid}\");\n".html_safe
      end
    end
  end
  
  def function(arglist)
    return unless current_user
    include_analytics("mixpanel") do |arglist|;Fi[	@iI"8    include_analytics("mixpanel") do |arglist|
      javascript_tag do |arglist|
        "          mixpanel.name_tag(\"#{current_user.guid}\");\n".html_safe
      end
    end
  end
  
  def function(arglist)
    return unless configured?("chartbeat")
    javascript_tag("var _sf_startpt=(new Date()).getTime()");Fi[	I"1data//diaspora_proj/helpers/mobile_helper.rb;TiI"<        var = Reshare.where(:author_id => (current_user.person_id), :root_guid => (var.guid)).first
        var = var.present? ? ("active") : ("inactive")
        link_to("", reshares_path(:root_guid => (var.guid)), :title => (t("reshares.reshare.reshare_confirmation", :author => (var.author_name))), :class => ("image_link reshare_action #{klass}"))
      end
    end
  end
  
  def function(arglist)
    if current_user and current_user.liked?(var) then
      link_to("", post_like_path(var.id, current_user.like_for(var).id), :class => "image_link like_action active");Fi[	I"8data//diaspora_proj/helpers/notifications_helper.rb;TiI"÷        end
      else
        translation(var, :actors => (var), :count => (var))
      end
    end
  end
  
  def function(arglist)
    { :post_author => (nil) }.merge!(var)
    t("#{target_type}", var).html_safe;Fi[	I"1data//diaspora_proj/helpers/people_helper.rb;TiI"C    else
      content_tag(:h2, :id => "search_title") do |arglist|
        ((t("people.index.results_for").html_safe + " ") + content_tag(:span, search_query, :class => "term"))
      end
    end
  end
  
  def function(arglist)
    if search_query then
      I18n.t("people.helper.results_for", :params => (search_query));Fi[	@óiI"„            I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516
    var[:height] ||= 315;Fi[	@öiI"‡            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare)
  end;Fi[	I"/data//diaspora_proj/helpers/tags_helper.rb;TiI"˛    content_tag("h4") do |arglist|
      content_tag("small") do |arglist|
        t("people.index.looking_for", :tag_link => (tag_link)).html_safe
      end
    end
  end
  
  def function(arglist)
    ActsAsTaggableOn::Tag.normalize(search_query)
  end;Fi[	@i/I"˜      mail(var) do |arglist|
        var.text { |arglist| render(:layout => (nil)) }
        var.html { |arglist| render(:layout => (nil)) }
      end
    end
  end
  
  def function(arglist)
    send_notification(:started_sharing, var, var)
  end;Fi[	@i[I"¥      mail(@var.headers) do |arglist|
        var.text
        var.html
      end
    end
  end
  
  def function(arglist)
    I18n.with_locale(@var.recipient.language, &var)
  end;Fi[	I"*data//diaspora_proj/models/comment.rb;TiGI"ç        return Notifications::AlsoCommented
      else
        return false
      end
    end
  end
  
  def function(arglist)
    Post
  end;Fi[	I"/data//diaspora_proj/models/notification.rb;Ti&I"å        else
          nil
        end
      end
    end
  end
  
  def function(arglist)
    super(var.merge(:methods => :note_html))
  end;Fi[	@içI"Ë    else
      if ["year", "month", "day"].all? { |arglist| var[var].blank? } then
        self.birthday = nil
      end
    end
  end
  
  def function(arglist)
    birthday.to_s(:long).gsub(", 1000", "") if birthday.present?
  end;Fi[	@(i∂I"“      else
        var = self.user_preferences.where(:email_type => (var)).first
        var.destroy if var
      end
    end
  end
  
  def function(arglist)
    if username.present? then
      username.strip!;Fi[	@£ixI"ﬂ            @var = @var.parent.value[:dont_indent_next_line]
            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	I"(data//homebrew_proj/cmd/--config.rb;Ti+I"ª          @var = (@var + " => #{MacOS::Xcode.prefix}")
        end
        @var
      end
    end
  end
  
  def function(arglist)
    if instance_variable_defined?(:@clt) then
      @var;Fi[	@J
i5I"    else
      if MacOS::CLT.installed? and (MacOS::Xcode.version.to_f >= 4.3) then
        @var = MacOS::CLT.version
      end
    end
  end
  
  def function(arglist)
    var = HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-parse --verify -q HEAD 2>/dev/null`.chomp;Fi[	@4iqI"ı        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|
      var = Formula.factory(var.formula) rescue problem("Can't find conflicting formula \"#{req.formula}\".");Fi[	@4iøI"(        unless (var.hexdigest == var.hexdigest.downcase) then
          problem("#{cksum.hash_type} should be lowercase")
        end
      end
    end
  end
  
  def function(arglist)
    ENV.setup_build_environment
    Patches.new(f.patches).select { |arglist| var.external? }.each do |arglist|;Fi[	@4iœI"O        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then
      problem("Use a space in class inheritance: class Foo < #{$1}");Fi[	@∞i9I"    else
      if (var.rack.children.length > 1) then
        opoo("Skipping #{f.name}: most recent version #{f.version} not installed")
      end
    end
  end
  
  def function(arglist)
    return unless HOMEBREW_CACHE.directory?
    HOMEBREW_CACHE.children.each do |arglist|;Fi[	@∞iNI"§            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist)
    system("find #{HOMEBREW_PREFIX} -name .DS_Store -delete")
  end;Fi[	@7iI"
        info_formula(Formula.factory(ARGV.shift))
      else
        ARGV.formulae.each { |arglist| info_formula(var) }
      end
    end
  end
  
  def function(arglist)
    require("vendor/multi_json")
    var = ARGV.include?("--all") ? (Formula) : (ARGV.formulae);Fi[	@7i2I"Y    if which("git") and (HOMEBREW_REPOSITORY / ".git").directory? then
      if `git remote -v` =~ /origin\s+(https?:\/\/|git(?:@|:\/\/))github.com[:\/](.+)\/homebrew/ then
        $2
      end
    end
  end
  
  def function(arglist)
    var = var.path.realpath
    if var.to_s =~ /#{HOMEBREW_REPOSITORY}\/Library\/Taps\/(\w+)-(\w+)\/(.*)/ then;Fi[	@:iKI"Ø        else
          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = []
    var = [];Fi[	I"'data//homebrew_proj/cmd/options.rb;Ti I"‘        puts(var.name) if (ff.length > 1)
        dump_options_for_formula(var)
        puts
      end
    end
  end
  
  def function(arglist)
    var.build.sort_by(&:flag).each do |arglist|
      puts(var.flag);Fi[	I"(data//homebrew_proj/cmd/outdated.rb;TiI"˜        puts("#{f.name} (#{(versions * ", ")} < #{f.version})")
      else
        puts(var.name)
      end
    end
  end
  
  def function(arglist)
    Formula.installed.map do |arglist|
      var = var.rack.subdirs.map { |arglist| Keg.new(var) };Fi[	@≥i5I"ı            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist)
    (if (HOMEBREW_LIBRARY / "Taps/#{user.downcase}-#{repo.downcase}").directory? then
      return [];Fi[	@GiŒI"ˆ        get_externals { |arglist| fetch_repo((@var + var), var, @var[var], true) }
      else
        fetch_repo(@var, @var)
      end
    end
  end
  
  def function(arglist)
    quiet_safe_system(@@var, "export", "--force", @var, Dir.pwd)
  end;Fi[	@GisI"(      Dir.chdir(HOMEBREW_CACHE) do |arglist|
        safe_system("/usr/bin/cvs", "-d", var, "login")
        safe_system("/usr/bin/cvs", "-d", var, "checkout", "-d", @var, var)
      end
    end
  end
  
  def function(arglist)
    FileUtils.cp_r(Dir[(@var + "{.}")], Dir.pwd)
    require("find");Fi[	@¿iæI"£        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("r") { |arglist| var.read(1024) })
  end;Fi[	@¿i
I"            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s)
  end;Fi[	I"-data//homebrew_proj/formula_installer.rb;TiI"˙          puts("You can amend this by altering your ~/.bashrc file")
          @var = true
        end
      end
    end
  end
  
  def function(arglist)
    if (f.prefix + "man").directory? then
      opoo("A top-level \"man\" directory was found.");Fi[	@√i¡I"A    rescue NotAKegError
      if ARGV.verbose? then
        puts("Won't resolve conflicts for symlink #{dst} as it doesn't resolve into the Cellar")
      end
    end
  end
  
  def function(arglist)
    if var.exist? and (var.realpath == var.realpath) then
      puts("Skipping; already exists: #{dst}") if ARGV.verbose?;Fi[	I"'data//homebrew_proj/macos/xcode.rb;Ti'I"Ô        "4.5.2"
      else
        raise("Mac OS X `#{MacOS.version}' is invalid")
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new(folder)
    if var.absolute? and (var / "usr/bin/make").executable? then;Fi[	@t
ixI"Ç          "4.5"
        else
          "4.5"
        end
      end
  end
  
  def function(arglist)
    (version.to_f < 4.3)
  end;Fi[	@Oi:I"∆    else
      if Pathname.new("/usr/X11/lib/libpng.dylib").exist? then
        Pathname.new("/usr/X11")
      end
    end
  end
  
  def function(arglist)
    version.nil?.! and prefix.nil?.!
  end;Fi[	I"!data//homebrew_proj/macos.rb;TiI"Û        else
          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist)
    (@var ||= {}).fetch(var.to_s) do |arglist|
      @var[var.to_s] = if File.executable?("/usr/bin/#{tool}") then;Fi[	@{
i)I"e        end
        var = ["#{xcrun_path}", "#{dev_tools_path}/#{tool}", "#{xctoolchain_path}/usr/bin/#{tool}"]
        var.map { |arglist| Pathname.new(var) }.find { |arglist| var.executable? }
      end
    end
  end
  
  def function(arglist)
    @var ||= if File.exist?("/usr/bin/cc") and File.exist?("/usr/bin/make") then
      Pathname.new("/usr/bin");Fi[	@{
i7I"        if File.exist?("#{Xcode.prefix}/usr/bin/make") then
          Pathname.new("#{Xcode.prefix}/usr/bin")
        end
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new("#{Xcode.prefix}/Toolchains/XcodeDefault.xctoolchain")
    var if var.exist?);Fi[	@{
i^I"‚        :clang
      else
        (Xcode.version >= "4.2") ? (:llvm) : (:gcc)
      end
    end
  end
  
  def function(arglist)
    @var ||= if locate("gcc-4.0") then
      `#{locate("gcc-4.0")} --version` =~ /build (\d{4,})/;Fi[	@UiI"–      var.each do |arglist|
        (@var << Patch.new(var, ("%03d-homebrew.diff" % var), var))
        var = (var + 1)
      end
    end
  end
  
  def function(arglist)
    external_curl_args.empty?.!
  end;Fi[	I",data//homebrew_proj/test/test_bucket.rb;TiKI"≈        var = TestBallWithRealPath.new
        Homebrew.info_formula(var)
        Homebrew.prune
      end
    end
  end
  
  def function(arglist)
    require("cmd/cleanup")
    var = TestBall.new;Fi[	@Ü
iÜI"€        assert(var.exist?)
        HOMEBREW_CACHE.chmod_R(511)
        var.unlink
      end
    end
  end
  
  def function(arglist)
    var = (HOMEBREW_CACHE / "foo-0.1.tar.gz")
    assert_equal(".tar.gz", var.extname);Fi[	I"-data//homebrew_proj/test/test_formula.rb;TiI"Q      TestBall.new.brew do |arglist|
        assert_equal(File.expand_path(var.prefix), ((HOMEBREW_CELLAR + var.name) + "0.1").to_s)
        assert_kind_of(Pathname, var.prefix)
      end
    end
  end
  
  def function(arglist)
    assert_equal("ShellFm", Formula.class_s("shell.fm"))
    assert_equal("Fooxx", Formula.class_s("foo++"));Fi[	I".data//homebrew_proj/test/test_patching.rb;Ti&I"7        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|;Fi[	@é
i0I"3        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|;Fi[	@é
i:I"3        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|;Fi[	I";data//homebrew_proj/vendor/multi_json/vendor/okjson.rb;TioI"          var.to_json
        else
          raise(Error, "cannot encode #{x.class}: #{x.inspect}")
        end
      end
    end
    
    def function(arglist)
      (("{" + var.map { |arglist| ((keyenc(var) + ":") + valenc(var)) }.join(",")) + "}")
    end;Fi[	@ΩiyI"Ë            "not(parent::*)"
          else
            (var.value.first + "(.)")
          end
        end
      end
      
      def function(arglist)
        "contains(concat(' ', @class, ' '), ' #{node.value.first} ')"
      end;Fi[	@qi=I"^      ["file_name"].each do |arglist|
        unless @var.respond_to?("#{name}_#{field}") and @var.respond_to?("#{name}_#{field}=") then
          raise(Paperclip::Error.new("#{@instance.class} model missing required attr_accessor for '#{name}_#{field}'"))
        end
      end
    end
    
    def function(arglist)
      Paperclip.log(var)
    end;Fi[	@qimI"w      instance.run_paperclip_callbacks(:post_process) do |arglist|
        instance.run_paperclip_callbacks(:"#{name}_post_process") do |arglist|
          post_process_styles(*var)
        end
      end
    end
    
    def function(arglist)
      if styles.include?(:original) and process_style?(:original, var) then
        post_process_style(:original, styles[:original]);Fi[	@qiÆI"0        var.close unless var.closed?
        if var.respond_to?(:unlink) and (var.path.present? and File.exist?(var.path)) then
          var.unlink
        end
      end
    end
    
    def function(arglist)
      if @var[:restricted_characters] then
        var.gsub(@var[:restricted_characters], "_");Fi[	I".data//paperclip_proj/paperclip/helpers.rb;Ti4I"◊          var.const_get(var, false)
        else
          var.const_missing(var)
        end
      end
    end
    
    def function(arglist)
      @var ||= {}
      var = (var or Attachment.default_options[:path]);Fi[	@˚iBI"'              else
                (var << "  All were accepted successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          if @var.present? then
            "Reject content types: #{@rejected_types.join(", ")}\n".tap do |arglist|;Fi[	@˚iNI"Í              else
                (var << "  All were rejected successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          "Expected #{@attachment_name}:\n"
        end;Fi[	@èiI"a        var.each do |arglist|
          COLUMNS.each_pair do |arglist|
            add_column(var, "#{attachment_name}_#{column_name}", var)
          end
        end
      end
      
      def function(arglist)
        if var.empty? then
          raise(ArgumentError, "Please specify attachment name in your remove_attachment call in your migration.");Fi[	@èi&I"ä        var.each do |arglist|
          COLUMNS.each_pair do |arglist|
            remove_column(var, "#{attachment_name}_#{column_name}")
          end
        end
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("Method `drop_attached_file` in the migration has been deprecated and will be replaced by `remove_attachment`.")
        remove_attachment(*var);Fi[	@èi5I"x        var.each do |arglist|
          COLUMNS.each_pair do |arglist|
            column("#{attachment_name}_#{column_name}", var)
          end
        end
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("Method `t.has_attached_file` in the migration has been deprecated and will be replaced by `t.attachment`.")
        attachment(*var);Fi[	@íi\I"M            "https://#{host_name_for_directory}/#{path(style)}"
          else
            directory.files.new(:key => (path(var))).public_url
          end
        end
      end
      
      def function(arglist)
        if directory.files.respond_to?(:get_http_url) then
          var = directory.files.get_http_url(path(var), var);Fi[	@íiÑI"8            (@var[:fog_host] % (path(var).hash % 4))
          else
            @var[:fog_host]
          end
        end
      end
      
      def function(arglist)
        if @var[:fog_directory].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "#{@options[:fog_directory]}.s3.amazonaws.com";Fi[	@íiùI"            var.call(self)
          else
            raise(ArgumentError, "Credentials are not a path, file, hash or proc.")
          end
        end
      end
      
      def function(arglist)
        @var ||= ::Fog::Storage.new(fog_credentials)
      end;Fi[	@iMI"c        unless Paperclip::Interpolations.respond_to?(:asset_host) then
          Paperclip.interpolates(:asset_host) do |arglist|
            "#{attachment.path(style).gsub(/^\//, "")}"
          end
        end
      end
      
      def function(arglist)
        if path then
          var = { :expires => (var), :secure => (use_secure_protocol?(var)) };Fi[	I"4data//paperclip_proj/paperclip/url_generator.rb;TiI"‡          @var.instance.send(@var[:default_url])
        else
          @var[:default_url]
        end
      end
    end
    
    def function(arglist)
      @var.original_filename.nil? ? (default_url) : (@var[:url])
    end;Fi[	@óiI"              var = options[:in] ? (:in_between) : (var)
              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator");Fi[	@ói/I"*          else
            var[:less_than_or_equal_to] = var
            var[:greater_than_or_equal_to] = var
          end
        end
      end
      
      def function(arglist)
        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min);Fi[	@•i†I"¡        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var);Fi[	@•i9I"Ã          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@®iõI"√        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var);Fi[	@®iBI"Ã          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@´ièI"¡        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var);Fi[	@´i(I"Ã          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@.iëI"˛          self.Error(("Unsupported font type: " + var)) unless self.respond_to?(var)
          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist)
    var = @var ? ("/Filter /FlateDecode ") : ("")
    @var.each do |arglist|;Fi[	@.i∏I"        out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
        putstream(var)
        out("endobj")
      end
    end
  end
  
  def function(arglist)
    @var.each_value do |arglist|
      out((((("/I" + var["i"].to_s) + " ") + var["n"].to_s) + " 0 R"));Fi[	@.i¸I"¿        out("/PageLayout /OneColumn")
      else
        out("/PageLayout /TwoColumnLeft") if (@var == "two")
      end
    end
  end
  
  def function(arglist)
    out(("%PDF-" + @var))
  end;Fi[	@.iI"Ã          (var = freadshort(var)
          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist)
    while true do
      while (var = freadbyte(var)).!=(255) do;Fi[	@1i}I"Ä            end
          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj
    out("<</Type /Font");Fi[	@HiáI"]            var.Bookmark(var.title, var)
            write_wiki_page(var, var)
            write_page_hierarchy(var, var, var.id, (var + 1)) if var[var.id]
          end
        end
      end
      
      def function(arglist)
        var.RDMwriteHTMLCell(190, 5, 0, 0, var.content.text.to_s, var.attachments, 0)
        if var.attachments.any? then;Fi[	@ΩiKI"s            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist)
        @var = { "project" => ({ :sql => ("#{TimeEntry.table_name}.project_id"), :klass => (Project), :label => :label_project }), "status" => ({ :sql => ("#{Issue.table_name}.status_id"), :klass => (IssueStatus), :label => :field_status }), "version" => ({ :sql => ("#{Issue.table_name}.fixed_version_id"), :klass => (Version), :label => :label_version }), "category" => ({ :sql => ("#{Issue.table_name}.category_id"), :klass => (IssueCategory), :label => :field_category }), "user" => ({ :sql => ("#{TimeEntry.table_name}.user_id"), :klass => (User), :label => :label_user }), "tracker" => ({ :sql => ("#{Issue.table_name}.tracker_id"), :klass => (Tracker), :label => :label_tracker }), "activity" => ({ :sql => ("#{TimeEntry.table_name}.activity_id"), :klass => (TimeEntryActivity), :label => :label_activity }), "issue" => ({ :sql => ("#{TimeEntry.table_name}.issue_id"), :klass => (Issue), :label => :label_issue }) }
        var = @var.nil? ? (IssueCustomField.for_all) : (@var.all_issue_custom_fields);Fi[	I"'data//redmine_proj/redmine/i18n.rb;TiYI"          [ll(var.to_s, :general_lang_name), var.to_s]
        end.sort do |arglist|
          (var.first <=> var.first)
        end
      end
    end
    
    def function(arglist)
      @@languages_lookup = valid_languages.inject({}) do |arglist|
        var[var.to_s.downcase] = var;Fi[	@Zi:I"Â              else
                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist)
          raise("Need to implement #{self.class.name}#output")
        end;Fi[	@√i˝I"             var.attributes["transform"] = "rotate( -90, #{x}, #{y} )"
          else
            var.attributes["transform"] = "rotate( 90, #{x}, #{y} )"
          end
        end
      end
      
      def function(arglist)
        return @var.collect { |arglist| var[:title] }
      end;Fi[	@√iOI"            var = var[var]
            var = (var + var.attributes["style"]) if var.attributes["style"]
            var.attributes["style"] = var
          end
        end
      end
      
      def function(arglist)
        var = get_style
        var = {};Fi[	@ûi7I"ú                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        (@var - @var)
      end;Fi[	@◊i;I"’            if (@var == :at_least) then
              return "Isn't life confusing enough?\nInstead of having to figure out the meaning of this:\n  should_not have_at_least(#{@expected}).#{@collection_name}\nWe recommend that you use this instead:\n  should have_at_most(#{(@expected - 1)}).#{@collection_name}\n"
            end
          end
        end
      end
      
      def function(arglist)
        "have #{relative_expectation} #{@collection_name}"
      end;Fi[	I"8data//rspec_proj/spec/mocks/argument_expectation.rb;TiI"C            @var = []
          else
            @var = var.collect { |arglist| matcher_for(var) }
          end
        end
      end
      
      def function(arglist)
        return ArgumentMatchers::MatcherMatcher.new(var) if is_matcher?(var)
        return ArgumentMatchers::RegexpMatcher.new(var) if var.is_a?(Regexp);Fi[	@„i@I"            else
              @var ? (@var) : ("nil")
            end
          end
        end
      end
      
      def function(arglist)
        var = opts[:message] unless opts[:message].nil?
        Kernel.raise(Spec::Mocks::MockExpectationError, var);Fi[	@ØiI"¬                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var)
      end;Fi[	@ØiºI"´            else
              "public"
            end
          end
        end
      end
      
      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end;Fi[	@ØiÂI"À          if method_defined?(var) then
            alias_method(var, var)
            remove_method(var)
          end
        end
      end
      
      def function(arglist)
        @var.nil?
      end;Fi[	@i±I"G          var = var.to_sym if var
          var.each do |arglist|
            Spec::Example::ExampleGroupFactory[var].__send__(var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = scope_and_options(*var)
        var = Spec::Example::ExampleGroupFactory[get_type_from_options(var)];Fi[	@Ói4I"W            var.instance_methods(false).each do |arglist|
              var = @var.new(var.name, var, Spec::Runner.options)
              var.validate
            end
          end
        end
        
        def function(arglist)
          var.to_class rescue raise("Heckling failed - \"#{name}\" is not a known class or module")
        end;Fi[	I"6data//rspec_proj/spec/runner/line_number_query.rb;Ti-I"Q          consider_example_group_for_best_match(var, var, var)
          var.examples.each do |arglist|
            consider_example_for_best_match(var, var, var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = parse_location(var.location)
        if is_best_match?(var, var, var, var) then;Fi[	I",data//rspec_proj/spec/runner/options.rb;TiwI"        ensure
          after_suite_parts.each do |arglist|
            (var.arity < 1) ? (var.call) : (var.call(var))
          end
        end
      end
      
      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.before_suite_parts
      end;Fi[	@ı
iìI"          rescue LoadError
            warn("You must 'gem install win32console' to use colour on Windows")
            @var = false
          end
        end
      end
      
      def function(arglist)
        case var
        when :context, "context", "c" then;Fi[	@ı
iI"`        Spec::Runner.configuration.predicate_matchers.each_pair do |arglist|
          Spec::Example::ExampleMethods.__send__(:define_method, var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
      
      def function(arglist)
        case mock_framework
        when Module then;Fi[	@ıi&I"'            example_pending(var, var.location, var.message)
          else
            example_failed(var, var)
          end
        end
      end
      
      def function(arglist)
        backtrace_tweaker.tweak_backtrace(var)
        var = Failure.new(@var.description, var.description, var);Fi[	@ıibI"              "'#{@example_name}' FIXED"
            else
              "#{@exception.class.name} in '#{@example_name}'"
            end
          end
        end
        
        def function(arglist)
          @var.is_a?(Spec::Example::PendingExampleFixedError)
        end;Fi[	@ıiìI"Û            var.example_pending(var, var, var.location)
          else
            var.example_pending(var, var)
          end
        end
      end
      
      def function(arglist)
        (var.method(:example_pending).arity == 3)
      end;Fi[	I"1data//SiriProxy_proj/siriproxy/connection.rb;TiKI"-    else
      if ($LOG_LEVEL > 5) then
        puts("[Debug - #{self.name}] Buffering some data for later (#{self.output_buffer.length} bytes buffered)")
      end
    end
  end
  
  def function(arglist)
    (self.unzipped_input << unzip_stream.inflate(self.input_buffer))
    self.input_buffer = "";Fi[	@i^I"      if var.!=(nil) then
        var = prep_received_object(var)
        inject_object_to_output_stream(var) if var.!=(nil)
      end
    end
  end
  
  def function(arglist)
    return false if unzipped_input.empty?
    var = unzipped_input[(0...5)].unpack("H*").first;Fi[	I")data//whenever_proj/whenever/cron.rb;Ti$I"        enumerate(var).each do |arglist|
          enumerate(var.at, false).each do |arglist|
            yield(new(var, var.output, var).output)
          end
        end
      end
      
      def function(arglist)
        [time_in_cron_syntax, task].compact.join(" ").strip
      end;Fi[	@i]I"≥            end
          else
            parse_as_string
          end
        end
      end
      
      def function(arglist)
        var = Array.new(5, "*")
        case @var;Fi[	I"(data//whenever_proj/whenever/job.rb;Ti.I"Ù          escape_single_quotes(var)
        else
          var.all? { |arglist| (var == "\"") } ? (escape_double_quotes(var)) : (var)
        end
      end
    end
    
    def function(arglist)
      var.gsub(/'/) { |arglist| "'\\''" }
    end;Fi[	I"-data//whenever_proj/whenever/job_list.rb;Ti2I"*          var[:output] = @var if defined? @var and var.has_key?(:output).!
          @var[@var] ||= []
          (@var[@var] << Whenever::Job.new(@var.merge(@var).merge(var)))
        end
      end
    end
    
    def function(arglist)
      [environment_variables, cron_jobs].compact.join
    end;Fi[	@iKI"¿          var = var.strip.to_sym
          set(var, var.strip)
          @var[var] = var
        end
      end
    end
    
    def function(arglist)
      return if @var.empty?
      var = [];Fi[@'@(I" ;FI"private;FI" ;Fi[[	@Zi4I"Ä      var.each do |arglist|
        define_callbacks(var, var)
        var.each { |arglist| send("_define_#{type}_model_callback", self, var) }
      end
    end
    
    private
    
    def function(arglist)
      var.class_eval("        def self.before_#{callback}(*args, &block)\n          set_callback(:#{callback}, :before, *args, &block)\n        end\n", "(string)", (126 + 1));Fi[	@fi`I"Õ            add_extra_behavior
            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing;Fi[	@iiI"E      def function(arglist)
        unless (delimiter.respond_to?(:include?) or (delimiter.respond_to?(:call) or delimiter.respond_to?(:to_sym))) then
          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist)
        var = if delimiter.respond_to?(:call) then;Fi[	@oi5I"          var = options[MESSAGES[var]]
          var[:message] ||= var if var
          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist)
        (if options[:tokenizer] and var.kind_of?(String) then;Fi[	@wi$I"´          else
            var
          end
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins);Fi[	I"Ndata//activerecord_proj/active_record/associations/has_one_association.rb;Ti9I"          else
            # do nothing
          end
        end
      end
      
      private
      
      # The reason that the save param for replace is false, if for create (not just build),
      # is because the setting of the foreign keys is actually handled by the scoping when;Fi[	@niI"+          var.each do |arglist|
            var.map! { |arglist| var.send(source_reflection.name) }.flatten!
            var.compact!
          end
        end
        
        private
        
        def function(arglist)
          Preloader.new(owners, through_reflection.name, through_scope).run;Fi[	@öivI"          read_time
        else
          (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist)
        if object.class.send(:create_time_zone_conversion_attribute?, name, column) then;Fi[	I"Edata//activerecord_proj/active_record/attribute_methods/dirty.rb;Ti5I"Ÿ        super.tap do |arglist|
          @var.clear
          @var.clear
        end
      end
      
      private
      
      # Wrap write_attribute to remember original attribute value.
      def function(arglist);Fi[	I"Edata//activerecord_proj/active_record/attribute_methods/query.rb;Ti!I"           else
            var.number? ? (var.zero?.!) : (var.blank?.!)
          end)
        end
      end
      
      private
      
      # Handle *? for method_missing.
      def function(arglist);Fi[	@¢i+I"c            generated_attribute_methods.module_eval(var, "(string)", var)
          else
            super
          end
        end
        
        private
        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type));Fi[	@¢i2I"9        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist)
        var.change(:usec => 0) if var;Fi[	@ßiEI"        def function(arglist)
          synchronize do |arglist|
            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist)
          @var.synchronize(&var);Fi[	@ßi1I"E          connections.dup.each do |arglist|
            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      
      # Acquire a connection by one of 1) immediately removing one
      # from the queue of available connections, 2) creating a new;Fi[	@ßi¿I"∆            break unless (var <= Base))
          end
          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist)
        @var[Process.pid];Fi[	@}i&I"            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) };Fi[	@ÉiëI"Ø          exec_query("BEGIN")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {};Fi[	@ãi}I"Á            else
              var
            end
          end
        end
        
        private
        
        HstorePair = (var = /"[^"\\]*(?:\\.[^"\\]*)*"/
        var = /(?:\\.|[^\s,])[^\s=,\\]*(?:\\.[^\s=,\\]*|=[^,>])*/;Fi[	I"2data//activerecord_proj/active_record/core.rb;TiVI"ô          self
        else
          superclass.arel_engine
        end
      end
      
      private
      
      #:nodoc:
      def function(arglist);Fi[	@L	ivI"*            end
          end
          raise(NameError, "uninitialized constant #{candidates.first}")
        end
      end
      
      private
      
      # Called by +instantiate+ to decide which class to use for a new
      # record instance. For single-table inheritance, we check the record;Fi[	@L	i¢I"Q          raise(ActiveRecord::SubclassNotFound.new("Invalid single-table inheritance type: #{subclass_name} is not a subclass of #{name}"))
        end
        var
      end
    end
    
    private
    
    # Sets the attribute used for single table inheritance to this class name if this is not the
    # ActiveRecord::Base descendant.;Fi[	I"9data//activerecord_proj/active_record/persistence.rb;TilI"	        @var.except!(*var.keys)
        var = self.class.primary_key
        (self.class.unscoped.where(var => (self[var])).update_all(var) == 1)
      end
    end
    
    private
    
    # A hook to be overridden by association modules.
    def function(arglist);Fi[	@–i&I"Œ      rescue Exception => var
        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    
    def function(arglist)
      ActiveRecord::Base.connection_id = var;Fi[	@⁄iMI"Ÿ        else
          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    
    def function(arglist)
      "#{quoted_table_name}.#{quoted_primary_key} ASC";Fi[	@÷i,I"≤      if var.!=(var[var]) then
        send(:"#{var}_will_change!")
        var[var] = var
      end
    end
    
    private
    
    def function(arglist)
      var = send(var);Fi[	I"(data//backup_proj/backup/archive.rb;TiUI"        Logger.message("#{self.class} Complete!")
      else
        raise(Errors::Archive::PipelineError, ("Failed to Create Backup Archive\n" + var.error_messages))
      end
    end
    
    private
    
    ##
    # Returns a "tar-ready" string of all the specified paths combined;Fi[	@‹i>I"€        #
        def function(arglist)
          deprecations[var] = { :version => (nil), :message => (nil), :action => (nil) }.merge(var)
        end
      end
      
      private
      
      # ClassMethods
      ##;Fi[	I"1data//backup_proj/backup/database/mongodb.rb;TiKI"π        ensure
          (unlock_database if @var
          package! unless var)
        end
      end
      
      private
      
      ##
      # Builds and runs the mongodump command;Fi[	I"/data//backup_proj/backup/database/mysql.rb;TiGI"*          Logger.message("#{database_name} Complete!")
        else
          raise(Errors::Database::PipelineError, ("#{database_name} Dump Failed!\n" + var.error_messages))
        end
      end
      
      private
      
      ##
      # Builds the full mysqldump string based on all attributes;Fi[	I".data//backup_proj/backup/database/riak.rb;Ti/I"Û            run("#{command} -c #{backup_file} > #{(backup_file + ext)}")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes;Fi[	I".data//backup_proj/backup/encryptor/gpg.rb;TidI"Û          yield("#{utility(:gpg)} #{base_options} #{mode_options}", ".gpg"))
        ensure
          cleanup
        end
      end
      
      private
      
      ##
      # Remove any temporary directories and reset all instance variables.;Fi[	I".data//backup_proj/backup/notifier/base.rb;Ti?I"¥        if var then
          log!
          notify!(var)
        end
      end
      
      private
      
      ##
      # Return the notifier name, with Backup namespace removed;Fi[	@iRI"o              Parallel.each(all_file_names, { :in_processes => (var) }, &var)
            else
              raise(Errors::Syncer::Cloud::ConfigurationError, "Unknown concurrency_type setting: #{concurrency_type.inspect}")
            end
          end
          
          private
          
          ##
          # Gathers all the relative paths to the local files;Fi[	@iI"ƒ            end)
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return expanded @path, since this path is local;Fi[	@i5I"!            run(("#{utility(:rsync)} #{options} #{directories_option} " + "'#{username}@#{ip}:#{dest_path}'")))
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return @path with any preceeding "~/" removed;Fi[	@iI"À          # do nothing
        end
        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist)
      @var.! and (@var.! and (@var.! and (@var.! and @var.!)));Fi[	@)i~I"ª        @var.uniq!
      else
        raise(ArgumentError, "Source must be an index, not #{index.class}")
      end
    end
    
    private
    
    def function(arglist)
      @var[var];Fi[	@,i!I"‡        return @var)
      ensure
        Bundler.settings[:frozen] = "1" if var
      end
    end
    
    private
    
    def function(arglist)
      @var.map { |arglist| "gem '#{d.name}', '#{d.requirement}'" }.join("\n");Fi[	@$iîI"          Bundler.ui.warn("Skipped #{skipped} since they already exist."))
        end
        Bundler.ui.warn("If you want to overwrite skipped stubs, use --force.")
      end
    end
    
    private
    
    def function(arglist)
      var = Bundler.bin_path;Fi[	@0iπI"ﬂ          var.unshift("-I#{File.expand_path("../..", "(string)")}")
        end
        ENV["RUBYOPT"] = var.join(" ")
      end
    end
    
    private
    
    def function(arglist)
      var = Dir["#{cache_path}/*.gem"];Fi[	@3i?I"O            git("fetch --force --quiet --tags \"#{path}\"")
            git("reset --hard #{@revision}")
            git("submodule update --init --recursive") if var
          end
        end
        
        private
        
        # TODO: Do not rely on /dev/null.
        # Given that open3 is not cross platform until Ruby 1.9.3,;Fi[	@JiWI"æ          tell_me(var, nil, var)
        else
          STDERR.puts("#{msg}#{newline}") if @var
        end
      end
      
      private
      
      # valimism
      def function(arglist);Fi[	@SixI"ﬂ          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact;Fi[	@óiƒI">            var.hosts.each { |arglist| failed!(var) }
          end
          teardown_connections_to(var) if var
        end
      end
      
      private
      
      # We establish the connection by creating a thread in a new method--this
      # prevents problems with the thread's scope seeing the wrong 'server';Fi[	@öiüI"        ensure
          (self.class.instance = var
          self.class.current_feature = var)
        end
      end
      
      private
      
      # Load a recipe from the named file. If +name+ is given, the file will
      # be reported using that name.;Fi[	@µiUI"             "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option
        def function(arglist);Fi[	@∏iNI"œ            return var[/hash='(.*?)'/, 1]
          else
            return var
          end
        end
        
        private
        
        def function(arglist)
          case variable(:scm_verbose);Fi[	@ΩièI"Ú            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the
        # command-line switch for "quiet" ("-q").;Fi[	@¿iKI"ø            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands
        def function(arglist);Fi[	@∆iMI"            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.
        def function(arglist);Fi[	@ÀiXI"            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line
        # switches for that. Note that we don't need to return the password;Fi[	@‡iI"B          super.check do |arglist|
            var.remote.command("rsync") unless copy_exclude.empty?
            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist)
          File.join(shared_path, (configuration[:repository_cache] or "cached-copy"));Fi[	@jiHI"          if File.directory?(project_directory).! then
            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then;Fi[	I"Adata//compass_proj/compass/sass_extensions/functions/urls.rb;Ti†I"œ      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      clean_url(var)
    end
  end
  
  private
  
  # Emits a path, taking off any leading "./"
  def function(arglist);Fi[	@iéI"*          if [hover?, target?, active?].any? then
            PARENT.match(name)
            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size;Fi[	@ìi1I"Ä      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity;Fi[	@ñiLI"ç          end
          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING;Fi[	I",data//cucumber_prok/cucumber/runtime.rb;TiéI"⁄        File.open(File.join(@var.dotcucumber, "stepdefs.json"), "w") do |arglist|
          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    
    #:nodoc
    def function(arglist);Fi[	I"-data//devise_proj/devise/param_filter.rb;Ti I"8      return var unless var.is_a?(Hash)
      var.each do |arglist|
        var[var] = var.to_s if param_requires_string_conversion?(var)
      end
    end
    
    private
    
    # Determine which values should be transformed to string or passed as-is to the query builder underneath
    def function(arglist);Fi[	I"Adata//devise_proj/devise/strategies/token_authenticatable.rb;TiI"        if validate(var) then
          var.after_token_authentication
          success!(var)
        end
      end
      
      private
      
      # Token Authenticatable can be authenticated with params in any controller and any verb.
      def function(arglist);Fi[	@‹i!I"     respond_with do |arglist|
      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist)
    if var = current_user.contact_for(var) then;Fi[	@ﬂi@I"Â        render(:json => (CommentPresenter.as_collection(@var)), :status => 200)
      end
      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist)
    if user_signed_in? then;Fi[	@ËiHI"Ë    unless AppConfig.settings.invitations.open? then
      flash[:error] = I18n.t("invitations.create.no_more")
      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist)
    User.email_regexp.match(var).present?;Fi[	@çi+I"˛    respond_to do |arglist|
      var.all { |arglist| render(:layout => (false)) }
      var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist)
    @var ||= if params[:post_id] then;Fi[	@ÌißI"À        flash[:error] = I18n.t("tags.show.none", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id };Fi[	@i{I"∑      end
    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist)
    if request.params[:qqfile].is_a?(String).! then;Fi[	@Ûi9I"Â          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("profiles.edit.your_tags_placeholder"))) then;Fi[	@ˇiBI"3        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "all_aspects")) then;Fi[	@i,I"›          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name]);Fi[	@i!I"N      javascript_tag do |arglist|
        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var);Fi[	@iRI"Œ      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist)
    if person_id and person.closed_account? then;Fi[	@A
i?I"¨      self.target.post
    else
      self.target
    end
  end
  
  private
  
  def self.concatenate_or_create(arglist)
    return nil if suppress_notification?(var, var);Fi[	@i=I"    if self.url then
      self.url = ("http://" + self.url) unless self.url.match(/https?:\/\//)
      self.url = (self.url + "/") if self.url[-1, 1].!=("/")
    end
  end
  
  private
  
  def function(arglist)
    Webfinger.new(self.diaspora_handle).fetch;Fi[	@iΩI"‡    if @var then
      errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["created_at", "updated_at", "person_id"]);Fi[	@%iI"¯    else
      var = var.map { |arglist| [var, var.id, var.class.base_class.to_s] }
      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist)
    if shareable.public? then;Fi[	I"1data//diaspora_proj/models/status_message.rb;Ti¶I"  def function(arglist)
    unless text_and_photos_blank? then
      (errors[:base] << "Cannot destory a StatusMessage with text and/or photos present")
    end
  end
  
  private
  
  def self.tag_stream(arglist)
    joins(:taggings).where("taggings.tag_id IN (?)", var);Fi[	@.iÂI"¿      self.class.buffer_option_keys.inject({}) do |arglist|
        var[var] = send(var)
        var
      end
    end
    
    private
    
    def function(arglist)
      self.class.defaults;Fi[	I"#data//haml_proj/haml/parser.rb;Ti{I"?      rescue Haml::Error => var
        var.backtrace.unshift("#{@options[:filename]}:#{(((e.line ? ((e.line + 1)) : (@index)) + @options[:line]) - 1)}")
        raise
      end
    end
    
    private
    
    class Line < Struct.new(:text, :unstripped, :full, :index, :compiler, :eod)
      alias_method(:eod?, :eod);Fi[	@©iI"æ        puts("rmdir: #{d} (empty)") if ARGV.verbose?
        var.rmdir
      end
    end
  end
  
  private
  
  # Set permissions for executables and non-executables
  def function(arglist);Fi[	@7iyI"—      else
        raise("No such formula or keg")
      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "http://") or ((var[(0..7)] == "https://") or (var[(0..5)] == "ftp://")));Fi[	I"$data//homebrew_proj/cmd/link.rb;Ti#I"      print("Linking #{keg}... ") do |arglist|
        puts("#{keg.link(mode)} symlinks created")
      end
    end
  end
  
  private
  
  # Allows us to ensure a puts happens before the block exits so that if say,
  # an exception is thrown, its output starts on a new line.;Fi[	@:iI"·          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|;Fi[	@@i+I"—    else
      puts("Updated Homebrew from #{master_updater.initial_revision[0, 8]} to #{master_updater.current_revision[0, 8]}.")
      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin;Fi[	@∏i/I"√      "Library/Formula/#{name}.rb"
    else
      "#{HOMEBREW_REPOSITORY}/Library/Formula/#{name}.rb"
    end
  end
  
  private
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|;Fi[	@GirI"£      safe_system("7zr", "x", @var)
    else
      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist)
    var = Dir["*"];Fi[	@GiI"≠        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "").split(/:/);Fi[	@Gi˛I"Æ      var
    else
      var.is_a?(Symbol) ? (detect_from_symbol(var)) : (detect_from_url(var))
    end
  end
  
  private
  
  def self.detect_from_url(arglist)
    case var;Fi[	@Li¨I"µ      yield)
    ensure
      replace(var)
    end
  end
  
  private
  
  def function(arglist)
    @var ||= named.map { |arglist| var.include?("/") ? (var) : (var.downcase) }.uniq;Fi[	@ iI"ù          end
        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/
  ;Fi[	@XißI"       else
        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  
  def function(arglist)
    raise("Unknown version scheme #{@scheme} was requested.");Fi[	@[i0I"ú        else
          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["paginate_path"];Fi[	I"1data//jekyll_proj/jekyll/migrators/tumblr.rb;Ti'I"        File.open("_posts/tumblr/#{post[:name]}", "w") do |arglist|
          var.puts(((var[:header].to_yaml + "---\n") + var[:content]))
        end
      end
    end
    
    private
    
    def self.truncate_post_name(arglist)
      var = var.match(/^(.+)\.(.+)$/).captures;Fi[	I"-data//mongoid_proj/lib/mongoid/atomic.rb;TimI"º        yield(self) if block_given?)
      ensure
        self.updates_requested = false
      end
    end
    
    private
    
    # Get the atomic paths utility for this document.
    #;Fi[	@i!I"«          end
          yield(self) if block_given?
          process_pending
        end
      end
      
      private
      
      # Get the current mass assignment options for this model.
      #;Fi[	@iI"            validate_session_database(var, var)
            validate_session_hosts(var, var)
            validate_session_uri(var, var)
          end
        end
        
        private
        
        # Validate that the session config has database.
        #;Fi[	@"iVI"Â            super()
          else
            (count > 0) ? (super(0) { |arglist| var.send(var) }) : (0)
          end
        end
        
        private
        
        # Aggregate by the provided field and method.
        #;Fi[	@Ñi7I"Ÿ          else
            Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      
      # Extract the attribute from the key, being smarter about dot notation.
      #;Fi[	@ñiI"‚            document[field] = (var + value)
            execute("$inc")
            document[field]
          end
        end
        
        private
        
        # In case we need to cast going to the database.
        #;Fi[	@ÉiSI"˝            (target.clear and _unscoped.clear)
            var = execute_batch_insert(var, "$set")
            add_atomic_sets(var)
          end
        end
        
        private
        
        # Add the atomic sets to the base document.
        #;Fi[	@ñikI"˙          unless var.forced_nil_inverse? then
            synced_save(var)
            synced_destroy(var)
          end
        end
        
        private
        
        # Set up the sync of inverse keys that needs to happen on a save.
        #;Fi[	@üi I"›          yield)
        ensure
          Threaded.exit_execution("without_default_scope")
        end
      end
      
      private
      
      # Warns or raises exception if overriding another scope or method.
      #;Fi[	@¢iI"        def function(arglist)
          if (var.is_a?(::Hash).! or valid_keys?(var).!) then
            raise(Errors::InvalidStorageOptions.new(var, var))
          end
        end
        
        private
        
        # Determine if all keys in the options hash are valid.
        #;Fi[	I";data//mongoid_proj/lib/mongoid/validations/presence.rb;Ti"I"Á          else
            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      
      # Returns true if the relation is blank or the foreign key is blank.
      #;Fi[	I"=data//mongoid_proj/lib/mongoid/validations/uniqueness.rb;Ti-I"¶          else
            validate_root(var, var, var)
          end
        end
      end
      
      private
      
      # Add the error to the document.
      #;Fi[	@ŒirI"™            end
          end
          insert(var, &var)
        end
      end
      
      private
      
      ###
      # Insert +node+ as a child of the current Node;Fi[	I":data//nokogiri_proj/nokogiri/xml/document_fragment.rb;TiXI"Ô        # Create a Nokogiri::XML::DocumentFragment from +tags+
        def function(arglist)
          self.new(XML::Document.new, var)
        end
      end
      
      private
      
      # fix for issue 770
      def function(arglist);Fi[	@li1I"K        document.canonicalize(var, var, var) do |arglist|
          var = var.is_a?(XML::Node) ? (var) : (var)
          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist)
        var = (var == :next) ? (:add_next_sibling_node) : (:add_previous_sibling_node);Fi[	@zi{I"ù        end
      else
        scale_to(var)
      end
    end
    
    private
    
    def function(arglist)
      if (var.horizontal? or var.square?) then;Fi[	@ÄiI"    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist)
      if var = (@var and @var.match(FORMAT)) then;Fi[	@íi|I"        rescue ::Fog::Errors::Error => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        if @var[:fog_host].respond_to?(:call) then;Fi[	@i˘I"Î        rescue AWS::Errors::Base => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        case var;Fi[	@ói"I"J      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator")
        end
      end
      
      private
      
      def function(arglist)
        if var = var[:in] then;Fi[	@üilI"’      complete_open_id_authentication(&var)
    else
      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist)
    (params[:openid_identifier] or params[:openid_url]);Fi[	@¢iLI"*      assert_nonce(var, false, var, "#{url}: nonce not allowed third time")
      var = OpenID::Nonce.mk_nonce(3600)
      assert_nonce(var, false, var, "Old nonce #{old_nonce.inspect} passed")
    end
  end
  
  private
  
  def function(arglist)
    var = OpenID::CryptUtil.random_string(20, nil);Fi[	@•iÍI"∏    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@®iÛI"∏    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@´iŸI"∏    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@.iI"ì      return @var
    else
      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@TiKI"K          rescue => var
            logger.error("scm: filesystem: error: #{err.message}")
            raise(CommandFailed.new(var.message))
          end
        end
        
        private
        
        # AbstractAdapter::target is implicitly made to quote paths.
        # Here we do not shell-out, so we do not want quotes.;Fi[	@¿iSI"¸        else
          Dir.glob("#{path}/#{dir}/*").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    
    def self.scan_themes(arglist)
      var = Dir.glob("#{Rails.public_path}/themes/*").select do |arglist|;Fi[	@√i&I"›            # do nothing
          end
          var.attributes["transform"] = "translate(#{x_offset} #{y_offset})"
        end
      end
      
      private
      
      def function(arglist)
        if (var < var) then;Fi[	I".data//rspec_proj/spec/matchers/matcher.rb;TiYI"≈            var.call(*var)
            self
          end
        end
      end
      
      private
      
      # :nodoc:
      # Our home-grown instance_exec in ruby 1.8.6 results in any methods;Fi[	@⁄iI"Ê            true
          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing;Fi[	@ıilI"Õ        
        def function(arglist)
          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist)
        @var.formatters;Fi[	@¯i%I"m        end
        var["rack.errors"] = var
        [500, { "Content-Type" => (var), "Content-Length" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist)
      (Request.new(var).preferred_type("text/plain", "text/html") == "text/html").! and [/curl/].index { |arglist| var.=~(var["HTTP_USER_AGENT"]) };Fi[	@2iI"              var[extract_requirement(var[0])] = extract_requirement(var[1])
            end
            owner.transition(var)
          end
        end
        
        private
        
        # Extracts the statement requirement from the given node
        def function(arglist);Fi[	I"-data//twitter_proj/twitter/api/tweets.rb;Ti˙I";        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String];Fi[@'@(@)@*I" ;Fij[j[	@.i@I"A        if respond_to?(:attributes_protected_by_default) then
          def self.attributes_protected_by_default(arglist)
            (super + ["password_digest"])
          end
        end
      end
    end
    
    module InstanceMethodsOnActivation
      # Returns +self+ if the password is correct, otherwise +false+.;Fi[	@fiòI"F          if var = options.delete(:procs) then
            Array(var).each do |arglist|
              (var.arity == 1) ? (var.call(options)) : (var.call(options, @var))
            end
          end
        end
      end
      
      # Returns XML representing the model. Configuration can be
      # passed through +options+.;Fi[	@li2I"˙        else
          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var[:multiline].!=(true))) then
            raise(ArgumentError, "The provided regular expression is using multiline anchors (^ or $), which may present a security risk. Did you mean to use \\A and \\z, or forgot to add the :multiline => true option?")
          end
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is of the correct;Fi[	@?i»I"·              (var.size + count_records)
            else
              count_records
            end
          end
        end
      end
      
      # Returns the size of the collection calling +size+ on the target.
      #;Fi[	@?ijI"?            add_to_target(build_record(var)) do |arglist|
              yield(var) if block_given?
              insert_record(var, true, var)
            end
          end
        end
      end
      
      # Do the relevant stuff to insert the given record into the association collection.
      def function(arglist);Fi[	@ßiÜI"ß            while true do
              sleep(var)
              var.reap
            end
          end
        end
      end
      
      include(MonitorMixin)
      ;Fi[	@≥i%I"            if (var < var) then
              execute("INSERT INTO #{sm_table} (version) VALUES ('#{v}')")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist)
        if var = native_database_types[var.to_sym] then;Fi[	@ãigI"ø                (var..var)
              else
                var
              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then;Fi[	@êiQI"                var.gsub!(/[^-\d,]/, "").sub!(/,/, ".")
              else
                # do nothing
              end
            end
          end
        end
        
        # Queries the database and returns the results in an Array-like object
        def function(arglist);Fi[	@@i=I"              "#{super}(#{attr_list})"
            else
              "#{super}(Table doesn't exist)"
            end
          end
        end
      end
      
      # Overwrite the default class equality method to provide support for association proxies.
      def function(arglist);Fi[	@…iDI"            var.instance_variable_set("@#{fixture_name}", var.find)
          rescue FixtureClassNotFound
            nil
          end
        end
      end
    end
    
    def self.instantiate_all_loaded_fixtures(arglist)
      all_loaded_fixtures.each_value do |arglist|;Fi[	@…i„I"˜        FixtureSet::File.open(var) do |arglist|
          var.each do |arglist|
            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "#{@path}.yml";Fi[	@≤iTI"‰            generated_feature_methods.module_eval("              if method_defined?(:#{association_name}_attributes=)\n                remove_method(:#{association_name}_attributes=)\n              end\n              def #{association_name}_attributes=(attributes)\n                assign_nested_attributes_for_#{type}_association(:#{association_name}, attributes)\n              end\n", "(string)", (284 + 1))
          else
            raise(ArgumentError, "No association found for name `#{association_name}'. Has it been defined yet?")
          end
        end
      end
    end
    
    # Returns ActiveRecord::AutosaveAssociation::marked_for_destruction? It's
    # used in conjunction with fields_for to build a form element for the;Fi[	@≤iÇI"-            else
              raise(ArgumentError, "Cannot build association `#{association_name}'. Are you trying to build a polymorphic one-to-one association?")
            end
          end
        end
      end
    end
    
    # Assigns the given attributes to the collection association.
    #;Fi[	@≤i–I"&            end
          else
            raise_nested_attributes_record_not_found(var, var["id"])
          end
        end
      end
    end
    
    # Updates a record with the +attributes+ or marks it for destruction if
    # +allow_destroy+ is +true+ and has_destroy_flag? returns +true+.;Fi[	@µiGI"ä                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end
    
    initializer("active_record.set_configs") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|;Fi[	@µi{I"-          if ActiveRecord::Base.connected? then
            ActiveRecord::Base.clear_reloadable_connections!
            ActiveRecord::Base.clear_cache!
          end
        end
      end
    end
    
    initializer("active_record.add_watchable_files") do |arglist|
      var = var.paths["db"].first;Fi[	@Ωi=I"¿            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2);Fi[	@^	iI"Ó              var
            else
              (var % var.collect { |arglist| connection.quote_string(var.to_s) })
            end
          end
        end
      end
      
      alias_method(:sanitize_conditions, :sanitize_sql)
      ;Fi[	@^	iñI"2              quote_bound_value(var[var])
            else
              raise(PreparedStatementInvalid, "missing value for :#{match} in #{statement}")
            end
          end
        end
      end
      
      def function(arglist)
        if var.respond_to?(:map) and var.acts_like?(:string).! then;Fi[	@»isI"Ë                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["#{self}_ignore_default_scope"];Fi[	@g	i*I"à            $stderr.puts("Couldn't create database for #{configuration.inspect}, #{creation_options.inspect}")
            if configuration["encoding"] then
              $stderr.puts("(If you set the charset manually, make sure you have a matching collation)")
            end
          end
        end
      end
      
      def function(arglist)
        establish_connection(configuration);Fi[	I"Bdata//activerecord_proj/active_record/validations/presence.rb;TiI"A          var = Array(var.send(var))
          if var.present? and var.all? { |arglist| var.marked_for_destruction? } then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods
      # Validates that the specified attributes are not blank (as defined by;Fi[	@iûI"¸                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end
        
        class LocalFile
          attr_reader(:path, :relative_path, :md5);Fi[	@iI"%          Bundler.ui.info("Gems included by the bundle:")
          Bundler.load.specs.sort_by { |arglist| var.name }.each do |arglist|
            Bundler.ui.info("  * #{s.name} (#{s.version}#{s.git_version})")
          end
        end
      end
    end
    
    map(["list"] => "show")
    ;Fi[	@iùI"            var = var.specs
            var = (var + var.unmet_dependency_names)
            var.add_source(var)
          end
        end
      end
    end
    
    # used when frozen is enabled so we can find the bundler
    # spec, even if (say) a git gem is not checked out.;Fi[	@'iÏI"Ê              debug { |arglist| "    -> Jumping to: #{savepoint}" }
              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by);Fi[	@*i,I"ï          else
            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion
    def function(arglist);Fi[	@-i¢I"¢          else
            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  
  class << self
    attr_reader(:rubygems);Fi[	@0i?I"Ó              raise(var) if (var.autorequire or (var and var.gsub("-", "/").!=(var)))
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then;Fi[	I"=data//bundler_proj/bundler/vendor/net/http/persistent.rb;Ti$I"º        var.each_value do |arglist|
          finish(var, var)
          var.delete(var.object_id) if var
        end
      end
    end
  end
  
  ##
  # Creates a new connection for +uri+;Fi[	@fi[I"ˆ            else
              File.expand_path("~") rescue File::ALT_SEPARATOR ? ("C:/") : ("/")
            end
          end
        end
      end
    end
    
    def self.thor_root(arglist)
      File.join(user_home, ".thor").gsub(/\\/, "/");Fi[	@PiII"´            true
          else
            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    ;Fi[	@SiìI"Ô              "(#{conditions}) OR (#{sql})"
            else
              "not (#{conditions}) AND (#{sql})"
            end
          end
        end
      end
      
      def function(arglist)
        sanitize_sql(["?=?", true, false]);Fi[	@ri1I"ø            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!;Fi[	@riÇI"◊                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first;Fi[	I"1data//capistrano_proj/capistrano/callback.rb;TiI"¿          return except.include?(var.fully_qualified_name).!
        else
          return true
        end
      end
    end
  end
  
  class ProcCallback < Callback
    def function(arglist);Fi[	@ÑiRI"‘                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var;Fi[	@îiqI"¢              var[:only] = filter_deprecated_tasks(var[:only])
              var[:except] = filter_deprecated_tasks(var[:except])
              callbacks[var].concat(var.map { |arglist| TaskCallback.new(self, var, var) })
            end
          end
        end
      end
      
      # Filters the given task name or names and attempts to replace deprecated tasks with their equivalents.
      def function(arglist);Fi[	@öilI"X                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,
      # with the exception that it sets the receiver as the "current" configuration;Fi[	@¡	iI"1            raise(Compass::Error, "Ambiguous abbreviation '#{name}'. Did you mean one of: #{matching.join(", ")}")
          else
            raise(Compass::Error, "Command not found: #{name}")
          end
        end
      end
    end
    
    def function(arglist)
      var = /^#{Regexp.escape(var)}/;Fi[	@˚iÄI"Ù              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= [];Fi[	@i4I"Ø                  end
                end
              end
            end
          end
        end
      end
      
      # Support for testing.
      def function(arglist);Fi[	@	iôI"a                inherited_data.send("#{attribute}_without_default")
              else
                inherited_data.send(var) if inherited_data.respond_to?(var)
              end
            end
          end
        end
        
        # Reads the raw value that was set on this object.
        # you generally should call raw_<attribute>() instead.;Fi[	@“	iAI"û          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  
  def function(arglist)
    CSS2FallbackValue.new(var, var);Fi[	@Ÿ	i/I"P              (((Ast::Step::INDENT + @var.unpack("U*").length) + ": ".length) + var.unpack("U*").length)
            else
              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("U*").length)
            end
          end
        end
      end
      
      def function(arglist)
        var.detect { |arglist| var.=~(name) };Fi[	@3i~I"                var.invoke(var.step_mother, var.configuration)
                @var ||= var.reported_exception
                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var);Fi[	@<iGI"            @var.div(:id => "expand-collapse") do |arglist|
              @var.p("Expand All", :id => "expander")
              @var.p("Collapse All", :id => "collapser")
            end
          end
        end
      end
      
      def function(arglist)
        print_stats(var);Fi[	@GiEI"œ                STDERR.cucumber_puts("WARNING: #{e.message}")
                cucumber_puts(*var)
              end
            end
          end
        end
      end
      
      Kernel.extend(self)
      ;Fi[	I"8data//devise_proj/devise/controllers/url_helpers.rb;TiI"              var = var ? ("#{action}_") : ("")
              var = "#{action}#{module_name}_#{path_or_url}"
              class_eval("                def #{method}(resource_or_scope, *args)\n                  scope = Devise::Mapping.find_scope!(resource_or_scope)\n                  _devise_route_context.send(\"#{action}#{scope}_#{module_name}_#{path_or_url}\", *args)\n                end\n", "(string)", (53 + 1))
            end
          end
        end
      end
      
      generate_helpers!(Devise::URL_HELPERS)
      ;Fi[	I"-data//devise_proj/devise/rails/routes.rb;Ti÷I"[          end
          with_devise_exclusive_scope(var.fullpath, var.name, var) do |arglist|
            var.each { |arglist| send("devise_#{mod}", var, var.controllers) }
          end
        end
      end
    end
    
    # Allow you to add authentication request from the router.
    # Takes an optional scope and block to provide constraints;Fi[	@äijI"á            @var = var
            break
          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil);Fi[	@Ÿi I"         var.html do |arglist|
          flash[:error] = I18n.t("aspects.create.failure")
          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist)
    @var = Aspect.new;Fi[	@Ûi7I"ï          redirect_to(getting_started_path)
        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  ;Fi[	@óiI"          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516;Fi[	@öiI"È          else
            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare);Fi[	@A
i%I"î          var
        else
          nil
        end
      end
    end
  end
  
  def function(arglist)
    super(var.merge(:methods => :note_html));Fi[	@£iwI"          if Parser::MID_BLOCK_KEYWORDS.include?(var) then
            @var = @var.parent.value[:dont_indent_next_line]
            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing;Fi[	@£iI"-            else
              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
            end
          end
        end
      end
    end
    
    # Evaluates `text` in the context of the scope object, but
    # does not output the result.;Fi[	@¶iàI"—            push_text(var.rstrip)
          else
            push_text(var.rstrip.gsub("\n", "\n#{("  " * @output_tabs)}"))
          end
        end
      end
    end
    
    module Plain
      include(Base);Fi[	@4iæI"‰        end
        unless (var.hexdigest == var.hexdigest.downcase) then
          problem("#{cksum.hash_type} should be lowercase")
        end
      end
    end
  end
  
  def function(arglist)
    ENV.setup_build_environment;Fi[	@∞iMI"≈            puts("Removing: #{pn}...")
            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist)
    system("find #{HOMEBREW_PREFIX} -name .DS_Store -delete");Fi[	@:iI"∆          exec("find", *(ARGV.kegs + ["-not", "-type", "d", "-print"]))
        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  ;Fi[	@:iJI"          var.symlink? ? (puts("#{pn} -> #{pn.readlink}")) : (print_dir(var))
        else
          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = [];Fi[	@≥i4I"<            puts("No formula found for \"#{query}\". Searching open pull requests...")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist)
    (if (HOMEBREW_LIBRARY / "Taps/#{user.downcase}-#{repo.downcase}").directory? then;Fi[	@¿i	I"          else
            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s);Fi[	@o
iI"          opoo("#{bin} is not in your PATH")
          puts("You can amend this by altering your ~/.bashrc file")
          @var = true
        end
      end
    end
  end
  
  def function(arglist)
    if (f.prefix + "man").directory? then;Fi[	@√i”I"Ô        else
          var.delete if var.overwrite and var.exist?
          var.make_relative_symlink(var)
        end
      end
    end
  end
  
  # symlinks the contents of self+foo recursively into /usr/local/foo
  def function(arglist);Fi[	@ iI"h              end
            end
          end
        end
      end
    end
  end
  
  private
  ;Fi[	@{
iI"∆          :snowleopard
        else
          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist)
    (@var ||= {}).fetch(var.to_s) do |arglist|;Fi[	@{
i6I"      else
        if File.exist?("#{Xcode.prefix}/usr/bin/make") then
          Pathname.new("#{Xcode.prefix}/usr/bin")
        end
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new("#{Xcode.prefix}/Toolchains/XcodeDefault.xctoolchain");Fi[	@˚i}I"            else
              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    
    # Read all the files in <source>/<dir>/_posts and create a new Post
    # object with each one.;Fi[	I".data//mongoid_proj/lib/mongoid/railtie.rb;Ti`I"M          if ::Mongoid.running_with_passenger? then
            PhusionPassenger.on_event(:starting_worker_process) do |arglist|
              ::Mongoid.default_session.disconnect if var
            end
          end
        end
      end
      
      # Exposes Mongoid's configuration to the Rails application configuration.
      #;Fi[	@ÛiGI"                  (var.do_or_do_not(:in_memory) or Array.wrap(var)).each { |arglist| var.save }
                end
                exit_autosave
              end
            end
          end
        end
        
        # Can the autosave be added?
        #;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/binding.rb;TiöI"          if var = metadata.inverse_metadata(var) then
            if var = var.inverse_of_field_setter then
              var.you_must(var, var)
            end
          end
        end
      end
      
      # Bind the provided document with the base from the parent relation.
      #;Fi[	@i"I"3                  else
                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.;Fi[	@ui I"&            if var = relations[var] then
              var = var.cascade_strategy
              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods
        # Attempt to add the cascading information for the document to know how;Fi[	@ài'I"+                index({ var => 1, var.type => 1 }, :background => (true))
              else
                index({ var => 1 }, :background => (true))
              end
            end
          end
        end
        
        # Handle common behaviour for referenced 1-1 relation setup.
        #;Fi[	I"0data//mongoid_proj/lib/mongoid/relations.rb;TièI"A        if instance_variable_defined?("@#{name}") then
          if (_parent.nil? or instance_variable_get("@#{name}").!=(_parent)) then
            remove_instance_variable("@#{name}")
          end
        end
      end
    end
    
    module ClassMethods
      # This is convenience for librarys still on the old API.;Fi[	@üi„I"N          else
            if Mongoid.logger then
              Mongoid.logger.warn(("Creating scope :#{name}. " + "Overwriting existing method #{self.name}.#{name}."))
            end
          end
        end
      end
      
      # Checks if the intended scope is a valid object, either a criteria or
      # proc with a criteria.;Fi[	@˚iAI"#                (var << "  #{@missing_allowed_types.join(", ")} were rejected.")
              else
                (var << "  All were accepted successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          if @var.present? then;Fi[	@˚iMI"0                (var << "  #{@missing_rejected_types.join(", ")} were accepted.")
              else
                (var << "  All were rejected successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          "Expected #{@attachment_name}:\n";Fi[	I"Odata//paperclip_proj/paperclip/validators/attachment_presence_validator.rb;TiI"M        [attributes].flatten.map do |arglist|
          if var.send(:read_attribute_for_validation, "#{attribute}_file_name").blank? then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the presence of a file.;Fi[	@óiI"À            unless var.send(CHECKS[var], var) then
              var = options[:in] ? (:in_between) : (var)
              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then;Fi[	@•i8I"õ          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@®iAI"õ          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@´i'I"õ          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@.iêI"
          var = ("put" + var.downcase)
          self.Error(("Unsupported font type: " + var)) unless self.respond_to?(var)
          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist)
    var = @var ? ("/Filter /FlateDecode ") : ("");Fi[	@.i
I"´        else
          (var = freadshort(var)
          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist)
    while true do;Fi[	@1i|I"â              self.send(var, var)
            end
          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj;Fi[	@1i6I"ü        if (var == 2) then
          @var = var
          @var = var
        end
      end
    end
  end
  
  alias_method(:write_html_cell, :writeHTMLCell)
  ;Fi[	@ΩiJI"?              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist)
        @var = { "project" => ({ :sql => ("#{TimeEntry.table_name}.project_id"), :klass => (Project), :label => :label_project }), "status" => ({ :sql => ("#{Issue.table_name}.status_id"), :klass => (IssueStatus), :label => :field_status }), "version" => ({ :sql => ("#{Issue.table_name}.fixed_version_id"), :klass => (Version), :label => :label_version }), "category" => ({ :sql => ("#{Issue.table_name}.category_id"), :klass => (IssueCategory), :label => :field_category }), "user" => ({ :sql => ("#{TimeEntry.table_name}.user_id"), :klass => (User), :label => :label_user }), "tracker" => ({ :sql => ("#{Issue.table_name}.tracker_id"), :klass => (Tracker), :label => :label_tracker }), "activity" => ({ :sql => ("#{TimeEntry.table_name}.activity_id"), :klass => (TimeEntryActivity), :label => :label_activity }), "issue" => ({ :sql => ("#{TimeEntry.table_name}.issue_id"), :klass => (Issue), :label => :label_issue }) };Fi[	@Zi9I"                @var.last[var].merge!(var)
              else
                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist)
          raise("Need to implement #{self.class.name}#output");Fi[	I"&data//rescue_proj/resque/queue.rb;Ti9I"        synchronize do |arglist|
          Array(@var.lrange(@var, var, ((var + var) - 1))).map do |arglist|
            decode(var)
          end
        end
      end
    end
    
    # Pop an item off the queue.  This method will block until an item is
    # available.;Fi[	I";data//rspec_proj/spec/example/example_group_factory.rb;TiPI"º              self[(($2 == "") ? (nil) : ($2.to_sym))]
            else
              self[nil]
            end
          end
        end
      end
      
      extend(ClassMethods)
      ;Fi[	@ûi6I"Á                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        (@var - @var);Fi[	@◊i:I"⁄          else
            if (@var == :at_least) then
              return "Isn't life confusing enough?\nInstead of having to figure out the meaning of this:\n  should_not have_at_least(#{@expected}).#{@collection_name}\nWe recommend that you use this instead:\n  should have_at_most(#{(@expected - 1)}).#{@collection_name}\n"
            end
          end
        end
      end
      
      def function(arglist)
        "have #{relative_expectation} #{@collection_name}";Fi[	@„i?I"Ú              "<#{@target.inspect} (class)>"
            else
              @var ? (@var) : ("nil")
            end
          end
        end
      end
      
      def function(arglist)
        var = opts[:message] unless opts[:message].nil?;Fi[	@Øi~I"˙                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var);Fi[	@ØiªI"ª              "protected"
            else
              "public"
            end
          end
        end
      end
      
      def function(arglist)
        "proxied_by_rspec__#{sym}";Fi[	@˝iCI"q          unless (::ActiveRecord::Observer < StateMachine::Integrations::ActiveModel::Observer) then
            ::ActiveRecord::Observer.class_eval do |arglist|
              include(StateMachine::Integrations::ActiveModel::Observer)
            end
          end
        end
      end
      
      version("2.0 - 2.2.x") do |arglist|
        def self.active?(arglist);Fi[@'@TI"protected;FI" ;FI"def function(arglist);FiV[V[	I"=data//activemodel_proj/active_model/attribute_methods.rb;TiI"Ï      #:nodoc:
      def function(arglist)
        @var ||= Module.new.tap { |arglist| include(var) }
      end
      
      protected
      
      def function(arglist)
        generated_attribute_methods.method_defined?(var)
      end;Fi[	@iáI"Ÿ          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var)
    end;Fi[	@fi&I"6            var[:type] = (type == :string) ? (nil) : (type)
            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist)
            return if value.nil?
            var = ActiveSupport::XmlMini::TYPE_NAMES[value.class.name];Fi[	@	i1I"õ            end)
          end
        end
      end
      
      protected
      
      def function(arglist)
        case var
        when /\A0[xX]/ then;Fi[	I"Jdata//activerecord_proj/active_record/associations/join_dependency.rb;TiTI"ù        else
          # do nothing
        end
      end
      
      protected
      
      def function(arglist)
        var = []
        var = var.parent;Fi[	@wi$I"      # Returns the primary key value before type cast.
      def function(arglist)
        read_attribute_before_type_cast(self.class.primary_key)
      end
      
      protected
      
      def function(arglist)
        ((var == "id") or super)
      end;Fi[	I"?data//activerecord_proj/active_record/attribute_methods.rb;Ti I"Ú    #   person[:age] # => Fixnum
    def function(arglist)
      write_attribute(var, var)
    end
    
    protected
    
    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) }
      var;Fi[	@≥i^I"¯      def function(arglist)
        remove_column(var, :updated_at)
        remove_column(var, :created_at)
      end
      
      protected
      
      def function(arglist)
        if var.is_a?(Hash) and var = var[:order] then
          case var;Fi[	@5	iI"O      # Check the connection back in to the connection pool
      def function(arglist)
        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin
          @var.instrument("sql.active_record", :sql => (var), :name => (var), :connection_id => (object_id), :binds => (var)) do |arglist|;Fi[	@£iµI"          raise(ActiveRecord::ActiveRecordError, "Missing column #{table_name}.#{column_name}")
        end
        alter_table(var, :rename => ({ var.to_s => (var.to_s) }))
      end
      
      protected
      
      def function(arglist)
        exec_query(var, var, var)
      end;Fi[	@Ωi*I"»            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then
          self.class.delegate_to_scoped_klass(var);Fi[	@ΩicI"!    
    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))))
    end
    
    protected
    
    def function(arglist)
      if @var.respond_to?(var) then
        scoping { |arglist| @var.send(var, *var, &var) };Fi[	@U	iØI"¥      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@÷iI"‘        self.stored_attributes[var] ||= []
        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist)
      var = initialize_store_attribute(var)
      var[var];Fi[	I"9data//activerecord_proj/active_record/validations.rb;Ti>I"      var ||= new_record? ? (:create) : (:update)
      var = super(var)
      errors.empty? and var
    end
    
    protected
    
    def function(arglist)
      var = var[:validate].!=(false)
      var ? (valid?(var[:context])) : (true);Fi[	@MiII"·      
      def function(arglist)
        execute!
      end
      
      protected
      
      def function(arglist)
        var = Util.escape_globs(source)
        var = config[:recursive] ? (File.join(var, "**")) : (var);Fi[	@RiDI""          /(#{Regexp.escape(replacement)})(.*)(#{flag})/m
        end
        replace!(var, var, true)
      end
      
      protected
      
      def function(arglist)
        var = if (var == :invoke) then
          (flag == /\A/) ? (:prepend) : ((flag == /\z/) ? (:append) : (:insert));Fi[	@Wi)I"Î      # Convert to a Hash with String keys.
      def function(arglist)
        Hash.new(default).merge!(self)
      end
      
      protected
      
      def function(arglist)
        var.is_a?(Symbol) ? (var.to_s) : (var)
      end;Fi[	@Ñ	i-I"‡      else
        default
      end
    end
    
    protected
    
    def function(arglist)
      if required? and default.nil?.! then
        raise(ArgumentError, "An argument cannot be required and have default value.");Fi[	I"<data//bundler_proj/bundler/vendor/thor/parser/option.rb;TiFI"F    
    VALID_TYPES.each do |arglist|
      class_eval("        def #{type}?\n          self.type == #{type.inspect}\n        end\n", "(string)", (101 + 1))
    end
    
    protected
    
    def function(arglist)
      if boolean? and required? then
        raise(ArgumentError, "An option cannot be boolean and required.");Fi[	@ä	iÌI"Õ      #
      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist)
        return var unless var.is_a?(Symbol)
        self.class.const_get(var.to_s.upcase);Fi[	I"3data//bundler_proj/bundler/vendor/thor/task.rb;TiJI"«      end))
      (var << " #{required_options}")
      var.strip
    end
    
    protected
    
    def function(arglist)
      (var.class.respond_to?(:debugging) and var.class.debugging).!
    end;Fi[	@PiLI"ª          end
        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then
        build_resource;Fi[	@≠	imI"        var = execute_task(var)
        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist)
        return if Thread.current[:rollback_requests].nil?
        rollback_requests.reverse.each do |arglist|;Fi[	@∞	i@I"`          var = var.reject { |arglist| var.any? { |arglist| (var.options[var] == var) } }
          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist)
        return var unless (ENV["HOSTFILTER"] or ENV["HOSTROLEFILTER"])
        if ENV["HOSTFILTER"] then;Fi[	I"0data//compass_proj/compass/commands/base.rb;Ti#I"      
      def function(arglist)
        @var = true
      end
      
      protected
      
      def function(arglist)
        unless Compass::Frameworks[options[:framework]] then
          raise(Compass::Error.new("No such framework: #{options[:framework].inspect}"));Fi[	@jiI"—      
      def function(arglist)
        super
      end
      
      protected
      
      def function(arglist)
        add_project_configuration
        Compass.add_configuration(options, "command_line");Fi[	I"6data//compass_proj/compass/exec/sub_command_ui.rb;TiI"ã        end
        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift;Fi[	I"1data//compass_proj/compass/exec/switch_ui.rb;Ti"I"π        return 1
      end
      return 0
    end
    
    protected
    
    def function(arglist)
      options[:command] ? (do_command(options[:command])) : (puts(self.opts))
    end;Fi[	@uiI"˘      (var << "#{url} format('#{args.shift}')")
    end
    Sass::Script::String.new(var.join(", "))
  end
  
  protected
  
  def function(arglist)
    var = [var].flatten.pack("m").gsub("\n", "")
    var = "url('data:#{mime_type};base64,#{data}')";Fi[	I"Bdata//compass_proj/compass/sass_extensions/functions/lists.rb;Ti^I"º        var
      end
    end
  end
  
  protected
  
  def function(arglist)
    unless var.is_a?(Sass::Script::List) then
      raise(ArgumentError.new("#{value.inspect} is not a list"));Fi[	I"Ddata//compass_proj/compass/sass_extensions/functions/sprites.rb;Ti∏I"g  
  def function(arglist)
    raise(Sass::SyntaxError, "The sprite-image() function has been replaced by sprite(). See http://compass-style.org/help/tutorials/spriting/ for more information.")
  end
  
  protected
  
  def function(arglist)
    if Sass::Script::Color.const_defined?(:HTML4_COLORS_REVERSE) then
      Sass::Script::Color::HTML4_COLORS_REVERSE;Fi[	I"*data//compass_proj/compass/version.rb;TiI"     # This method swiped from Haml and then modified, some credit goes to Nathan Weizenbaum
    def function(arglist)
      defined? @var ? (@var) : (read_version)
    end
    
    protected
    
    def function(arglist)
      File.join(File.dirname("(string)"), "..", "..", var)
    end;Fi[	@<iGI"√      
      def function(arglist)
        @var = []
      end
      
      protected
      
      def function(arglist)
        var = Array.new
        @var.div(:class => "message") do |arglist|;Fi[	@ViI"≥      
      def function(arglist)
        load(File.expand_path(var))
      end
      
      protected
      
      def function(arglist)
        begin_rb_scenario(var)
      end;Fi[	I"?data//cucumber_prok/cucumber/wire_support/wire_language.rb;Ti%I"Û      
      def function(arglist)
        @var.map { |arglist| var.step_matches(var, var) }.flatten
      end
      
      protected
      
      def function(arglist)
        @var.each { |arglist| var.begin_scenario(var) }
        @var = var;Fi[	I"9data//devise_proj/devise/controllers/rememberable.rb;Ti"I"6        var = Devise::Mapping.find_scope!(var)
        var.forget_me!
        cookies.delete(remember_key(var, var), forget_cookie_values(var))
      end
      
      protected
      
      def function(arglist)
        Devise::Controllers::Rememberable.cookie_values.merge!(var.rememberable_options)
      end;Fi[	@Û	iAI"‚        flash[:alert] = i18n_message
      end
      redirect_to(redirect_url)
    end
    
    protected
    
    def function(arglist)
      var = (warden_message or (var or :unauthenticated))
      if var.is_a?(Symbol) then;Fi[	@vi∫I"ﬁ            end
          end
          var
        end
        
        protected
        
        def function(arglist)
          @var ||= Devise::ParamFilter.new(case_insensitive_keys, strip_whitespace_keys)
        end;Fi[	I"0data//devise_proj/devise/models/lockable.rb;TiaI"∂            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts)
      end;Fi[	I"3data//devise_proj/devise/models/recoverable.rb;Ti6I"      #
      def function(arglist)
        reset_password_sent_at and (reset_password_sent_at.utc >= self.class.reset_password_within.ago)
      end
      
      protected
      
      def function(arglist)
        (reset_password_token.nil? or reset_password_period_valid?.!)
      end;Fi[	@˚	i>I"”      
      def function(arglist)
        self.class.rememberable_options
      end
      
      protected
      
      def function(arglist)
        respond_to?(:remember_token) and remember_expired?
      end;Fi[	I";data//devise_proj/generators/devise/views_generator.rb;TiI"ˆ        view_directory(:registrations)
        view_directory(:sessions)
        view_directory(:unlocks)
      end
      
      protected
      
      def function(arglist)
        directory(var.to_s, (var or "#{target_path}/#{name}"))
      end;Fi[	@i5I"Œ  def function(arglist)
    self.profile.tombstone!
    self
  end
  
  protected
  
  def function(arglist)
    if self.url then
      self.url = ("http://" + self.url) unless self.url.match(/https?:\/\//);Fi[	@i™I"Ì    clearable_fields.each { |arglist| self[var] = nil }
    self[:searchable] = false
    self.save
  end
  
  protected
  
  def function(arglist)
    self.first_name.strip! if self.first_name
    self.last_name.strip! if self.last_name;Fi[	@æiüI"U    require("uri")
    var = URI.extract(self.raw_message, ["http", "https"])
    self.oembed_url = var.find { |arglist| TRUSTED_OEMBED_PROVIDERS.find(var).nil?.! }
  end
  
  protected
  
  def function(arglist)
    unless text_and_photos_blank? then
      (errors[:base] << "Cannot destory a StatusMessage with text and/or photos present");Fi[	I"7data//diaspora_proj/presenters/person_presenter.rb;TiI"ã  
  def function(arglist)
    (@var.try(:person) == @var)
  end
  
  protected
  
  def function(arglist)
    @var.shares_with(@var)
  end;Fi[	I"5data//diaspora_proj/presenters/post_presenter.rb;Ti7I"{  
  def function(arglist)
    @var.reshare_for(@var)
  end
  
  protected
  
  def function(arglist)
    @var.person
  end;Fi[	@√i±I"”      var.directory? ? (var.rmdir) : (var.delete if var.exist?)
    end
    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin
      if var.symlink? and var.directory? then;Fi[	I"Bdata//homebrew_proj/vendor/multi_json/adapters/json_common.rb;TiI"¬      
      def function(arglist)
        var.to_json(process_options(var))
      end
      
      protected
      
      def function(arglist)
        return var if var.empty?
        var = {};Fi[	@Xi^I"‚  def self.parse(arglist)
    var = _parse(var)
    Version.new(var, true) unless var.nil?
  end
  
  protected
  
  def function(arglist)
    @var ||= @var.scan(/\d+|[a-zA-Z]+/).map { |arglist| VersionElement.new(var) }
  end;Fi[	I"Adata//mongoid_proj/lib/mongoid/multi_parameter_attributes.rb;TiFI"Õ      else
        super
      end
    end
    
    protected
    
    def function(arglist)
      return nil if var.all? { |arglist| var.nil? }
      var = var.collect { |arglist| var.nil? ? (1) : (var) };Fi[	I"%data//omni_proj/omniauth/form.rb;TiVI"”    def function(arglist)
      footer
      Rack::Response.new(@var).finish
    end
    
    protected
    
    def function(arglist)
      "\n<style type='text/css'>#{OmniAuth.config.form_css}</style>"
    end;Fi[	I")data//omni_proj/omniauth/strategy.rb;Ti»I"°    end
    
    class Options < Hashie::Mash
    end
    
    protected
    
    def function(arglist)
      var.inject({}) do |arglist|
        var.merge!(var);Fi[	I"Edata//paperclip_proj/generators/paperclip/paperclip_generator.rb;TiI"˝  
  def function(arglist)
    migration_template("paperclip_migration.rb.erb", "db/migrate/#{migration_file_name}")
  end
  
  protected
  
  def function(arglist)
    "add_attachment_#{attachment_names.join("_")}_to_#{name.underscore.pluralize}"
  end;Fi[	@¯i(I"a        
        def function(arglist)
          "have an attachment named #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          var = @var.instance_methods.map(&:to_s)
          var.include?("#{@attachment_name}") and (var.include?("#{@attachment_name}=") and var.include?("#{@attachment_name}?"));Fi[	@˚i6I"9        
        def function(arglist)
          "validate the content types allowed on attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          if @var.present? then
            "Accept content types: #{@allowed_types.join(", ")}\n".tap do |arglist|;Fi[	@˛i'I"Ô        
        def function(arglist)
          "require presence of attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          @var.send(@var).assign(nil)
          @var.valid?;Fi[	@i:I"‹        
        def function(arglist)
          "validate the size of attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          class << var
            self;Fi[	@%iI"s          self_and_descendants.map do |arglist|
            "#{("*" * (node.level + 1))} #{node.id} #{node.to_s} (#{node.parent_id}, #{node.left}, #{node.right})"
          end.join("\n")
        end
        
        protected
        
        def function(arglist)
          var.where(["#{self.class.quoted_table_name}.#{self.class.primary_key} != ?", self])
        end;Fi[	@÷
iâI"¯          @var = nil
          @var = nil
          super
        end
        
        protected
        
        def function(arglist)
          var = var.to_s
          var = ::I18n.load_path.select { |arglist| (File.basename(var, ".*") == var) };Fi[	@qiI"∏      def function(arglist)
        super
        self.top_align = self.top_font = 1
      end
      
      protected
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@tiI"        super
        init_with(:rotate_y_labels => (true), :show_x_guidelines => (true), :show_y_guidelines => (false))
        self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value;Fi[	I")data//redmine_proj/SVG/Graph/Line.rb;Ti'I"Y      def function(arglist)
        init_with(:show_data_points => (true), :show_data_values => (true), :stacked => (false), :area_fill => (false))
        self.top_align = self.top_font = self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = 0
        if (stacked == true) then;Fi[	I")data//redmine_proj/SVG/Graph/Plot.rb;TiJI"…        sort(var, var)
        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var.collect { |arglist| var[:title] }
      end;Fi[	@∆i\I"‰        end
        sort(var, var, var)
        @var = [var, var, var]
      end
      
      protected
      
      def function(arglist)
        var = ParseDate.parsedate(var)
        @var = Time.local(*var[0, 6].compact).to_i;Fi[	@…iKI"≈        sort(var, var)
        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var = DateTime.parse(var).to_time
      end;Fi[	@˘iDI"¡        
        def function(arglist)
          @var[var]
        end
        
        protected
        
        def function(arglist)
          if var = var[:type] then
            self[var];Fi[	I"5data//rspec_proj/spec/example/example_matcher.rb;TiI"g        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist)
        var =~ /(^#{example_group_regex} #{example_regexp}$|^#{example_group_regex}$|^#{example_group_with_before_all_regexp}$|^#{example_regexp}$)/
      end;Fi[	I"7data//rspec_proj/spec/mocks/message_expectation.rb;TiçI"Ë      def function(arglist)
        (var << var) unless var.nil?
        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin
          @var.call(*var);Fi[	@≤i'I"æ      
      def function(arglist)
        return false
      end
      
      protected
      
      def function(arglist)
        @var = (var == :at_least)
        @var = (var == :at_most);Fi[	@¿iEI"Û            end
            (var << "\n")
            (var or var) ? ((var << diff_as_object(var, var))) : (var)
          end
          
          protected
          
          def function(arglist)
            @var.diff_format
          end;Fi[	I"9data//rspec_proj/spec/runner/example_group_runner.rb;TiI"˘        example_groups.each { |arglist| var = var.&(var.run(@var)) }
        finish
        var
      end
      
      protected
      
      def function(arglist)
        reporter.start(number_of_examples)
        example_groups.reverse! if reverse;Fi[	@ÀiWI"        def function(arglist)
          return "" if var.nil?
          var.map { |arglist| backtrace_line(var) }.join("\n")
        end
        
        protected
        
        def function(arglist)
          @var.colour.!.!
        end;Fi[	@Ú
i!I"›      def function(arglist)
        determine_best_match(var, var)
        best_match[:line]
      end
      
      protected
      
      def function(arglist)
        best_match.clear
        var = File.expand_path(var);Fi[	@ı
i˙I")      
      def function(arglist)
        @var.to_i if defined? @var
      end
      
      protected
      
      def function(arglist)
        Spec::Runner.configuration.predicate_matchers.each_pair do |arglist|
          Spec::Example::ExampleMethods.__send__(:define_method, var) do |arglist|;Fi[	I"9data//state_machine_proj/state_machine/extensions.rb;TiäI"E    def function(arglist)
      var = [true, false].include?(var.last) ? (var.pop) : (true)
      (fire_events(*(var + [var])) or raise(StateMachine::InvalidParallelTransition.new(self, var)))
    end
    
    protected
    
    def function(arglist)
      self.class.state_machines.initialize_states(self, var, &var)
    end;Fi[	I"1data//whenever_proj/whenever/command_line.rb;Ti.I"ç          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file])
    end;Fi[	@i7I"#        else
          parse_time
        end
      end
      
      protected
      
      def function(arglist)
        var = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
        @var.is_a?(String) and var.any? { |arglist| @var.downcase.index(var) };Fi[	@i"I"—    
    def function(arglist)
      (roles.empty? or roles.include?(var))
    end
    
    protected
    
    def function(arglist)
      var.gsub(/:\w+/) do |arglist|
        var = [$`[(-1..-1)], $'[(0..0)]];Fi[	I"7data//whenever_proj/whenever/output_redirection.rb;TiI"Ÿ        else
          ""
        end
      end
      
      protected
      
      def function(arglist)
        return unless @var.has_key?(:standard)
        @var[:standard].nil? ? ("/dev/null") : (@var[:standard]);Fi[@'I"var;FI"end;FI" ;FI"def function(arglist);FiQ[Q[	@|iVI"‘            var.includes!(var.includes_values)
            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist)
        reflection.name
      end;Fi[	@ái+I"ˇ        var = super
        if owner.new_record? and var then
          var.flatten.each { |arglist| build_through_record(var) }
        end
        var
      end
      
      def function(arglist)
        ensure_not_nested
        if var.new_record? then;Fi[	@áigI"              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!
      end;Fi[	@Ii[I"            end
            var.from(join(var, var))
            var, var = var, var.klass
          end
          var
        end
        
        def function(arglist)
          var = var[var].eq(var[var])
          if var.klass.finder_needs_type_condition? then;Fi[	@IicI"@          var = var[var].eq(var[var])
          if var.klass.finder_needs_type_condition? then
            var = var.create_and([var, var.klass.send(:type_condition, var)])
          end
          var
        end
        
        def function(arglist)
          self.join_type = Arel::OuterJoin
          var.joins(self);Fi[	@iµI"          else
            raise(ConfigurationError, "unknown macro: #{join_part.reflection.macro}")
          end
        end
        var
      end
      
      def function(arglist)
        var = var.association(var.reflection.name)
        var.target = var;Fi[	@åiI"0          if (var.source_macro == :has_and_belongs_to_many) then
            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist)
        var.table_name
      end;Fi[	@RiUI"F          var.each do |arglist|
            var = var[association_key_name].to_s
            var[var].each { |arglist| (var[var] << var) }
          end
          var
        end
        
        def function(arglist)
          @var ||= if reflection.scope then
            klass.unscoped.instance_exec(nil, &reflection.scope);Fi[	@öiYI"        var[var] ||= {}
        var = var.empty? ? (nil) : (type_cast_attribute_value(var, var))
        var[var][find_parameter_position(var)] ||= var
      end
      var
    end
    
    def function(arglist)
      var =~ /\([0-9]*([if])\)/ ? (var.send(("to_" + $1))) : (var)
    end;Fi[	@≥iúI"å        var = index_name(var, var)
        unless index_name_exists?(var, var, true) then
          raise(ArgumentError, "Index name '#{index_name}' on table '#{table_name}' does not exist")
        end
        var
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("columns_for_remove is deprecated and will be removed in the future")
        if var.blank? then;Fi[	@∂i¨I";      def function(arglist)
        unless var = columns(var).find { |arglist| (var.name == var.to_s) } then
          raise("No such column: #{table_name}.#{column_name}")
        end
        var
      end
      
      def function(arglist)
        var = (@var[:variables] or {})
        var[:sql_auto_is_null] = 0;Fi[	@Üi%I"¡              # do nothing
            end
            var = (var + 1)
          end
          var
        end
        
        def function(arglist)
          var = false
          var = false;Fi[	@£i¡I"|        var = exec_query("PRAGMA table_info(#{quote_table_name(table_name)})", "SCHEMA").to_hash
        if var.empty? then
          raise(ActiveRecord::StatementInvalid, "Could not find table '#{table_name}'")
        end
        var
      end
      
      def function(arglist)
        var = "altered_#{table_name}"
        var = lambda { |arglist| yield(var) if block_given? };Fi[	@¶i3I"        var = super
        if locking_enabled? and var.!=(1) then
          raise(ActiveRecord::StaleObjectError.new(self, "destroy"))
        end
        var
      end
      
      def function(arglist)
        var = super
        if locking_enabled? then;Fi[	@U	i˝I"i        var = arel.where_sql
        var = " [#{conditions}]" if var
        raise(RecordNotFound, "Couldn't find #{@klass.name} with #{primary_key}=#{id}#{conditions}")
      end
      var
    end
    
    def function(arglist)
      var = where(table[primary_key].in(var)).to_a
      var = limit_value and (var.size > limit_value) ? (limit_value) : (var.size);Fi[	@ÌirI"        var.puts("# Could not dump table #{table.inspect} because of following #{e.class}")
        var.puts("#   #{e.message}")
        var.puts
      end
      var
    end
    
    def function(arglist)
      if (var = @var.indexes(var)).any? then
        var = var.map do |arglist|;Fi[	I"Ddata//activerecord_proj/active_record/validations/uniqueness.rb;TiII"	            var = var.read_attribute(var)
          end
          var = var.and(var[var].eq(var))
        end
        var
      end
      
      def function(arglist)
        var = var.class.serialized_attributes[var.to_s]
        var = var.dump(var) if var and var;Fi[	@iœI"L      var = Bundler.load.dependencies.find { |arglist| (var.name == var) }
      unless var then
        raise(GemNotFound, not_found_message(var, Bundler.load.dependencies))
      end
      var
    end
    
    def function(arglist)
      var = "Could not find gem '#{missing_gem_name}'."
      var = var.map { |arglist| var.name };Fi[	@iŸI"X        next if var.include?(var.name)
        (var << var.to_lock)
        (var << var.name)
      end
      var
    end
    
    def function(arglist)
      var = false
      var = "You are trying to install in deployment mode after changing\nyour Gemfile. Run `bundle install` elsewhere and add the\nupdated Gemfile.lock to version control.";Fi[	@i`I"Ê          var.unlock!
          var = true
        end
      end
      var
    end
    
    def function(arglist)
      (@var + @var).each do |arglist|
        var.source = @var.find { |arglist| (var.source == var) } if var.source;Fi[	@iíI"        unless var.any? { |arglist| (var.source == var) } then
          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist)
      var and (var.source == var.source)
    end;Fi[	@i≠I"‹            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|
        [var.is_a?(Source::Rubygems) ? (1) : (0), var.to_s];Fi[	@i$I"Ã        var = PLATFORM_MAP[var]
        next unless var.include?(var)
        var = var.|([var])
      end
      var
    end
    
    def function(arglist)
      current_env? and current_platform?
    end;Fi[	@i≤I";        var = var[var]
        var.delete(var)
        var[var.to_s] = var
      end
      var
    end
    
    def function(arglist)
      _normalize_hash(var)
      var = ["group", "groups", "git", "gist", "github", "path", "name", "branch", "ref", "tag", "require", "submodules", "platform", "platforms", "type"];Fi[	@)i5I"B          (var << var) unless var.include?([var.name, var.version, var.platform])
          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist)
      case var
      when Gem::Specification, RemoteSpecification, LazySpecification, EndpointSpecification then;Fi[	@1i1I"#      dependencies.sort_by { |arglist| var.to_s }.each do |arglist|
        next if (var.type == :development)
        (var << "    #{dep.to_lock}\n")
      end
      var
    end
    
    def function(arglist)
      @var = source.specs.search(Gem::Dependency.new(name, version)).last
    end;Fi[	@9iBI"      unless development_dependencies.empty? then
        (var << "\n")
        (var << dependencies_to_gemfile(development_dependencies, :development))
      end
      var
    end
    
    def function(arglist)
      (dependencies - development_dependencies)
    end;Fi[	@0i¢I"t        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm_rf(var) if File.exists?(var) }
      end
      var
    end
    
    def function(arglist)
      begin
        ENV["BUNDLE_BIN_PATH"] = Bundler.rubygems.bin_path("bundler", "bundle", VERSION);Fi[	@>iDI"      end
      if var.empty? then
        return ["You have not configured a value for `#{exposed_key}`"]
      end
      var
    end
    
    def function(arglist)
      self[:without] = var.empty? ? (nil) : (var.join(":")) if var
    end;Fi[	@>iwI"?        FileUtils.mkdir_p(var.dirname)
        require("bundler/psyched_yaml")
        File.open(var, "w") { |arglist| var.puts(var.to_yaml) }
      end
      var
    end
    
    def function(arglist)
      var = (ENV["BUNDLE_CONFIG"] or File.join(Bundler.rubygems.user_home, ".bundle/config"))
      Pathname.new(var);Fi[	@BiàI",          else
            raise(PathError, "The path `#{expanded_path}` does not exist.")
          end
        end
        var
      end
      
      def function(arglist)
        if path.to_s.match(/^#{Regexp.escape(Bundler.root.to_s)}/) then
          return path.relative_path_from(Bundler.root);Fi[	@GiÄI"0        var = var.find { |arglist| File.exist?(var) }
        unless var then
          raise(Bundler::GemNotFound, "Could not find #{spec.file_name} for installation")
        end
        var
      end
      
      def function(arglist)
        var = var.to_s
        var = "#{uri}/" unless var =~ /\/$/;Fi[	@GiäI"?        var = URI(var)
        unless var.absolute? then
          raise(ArgumentError, "The source must be an absolute URI")
        end
        var
      end
      
      def function(arglist)
        @var ? (var = remote_specs.dup) : (var = Index.new)
        var.use(cached_specs, :override_dupes) if (@var or @var);Fi[	@Mi¬I"      if cannot?(var, var, *var) then
        var ||= unauthorized_message(var, var)
        raise(AccessDenied.new(var, var, var))
      end
      var
    end
    
    def function(arglist)
      var = unauthorized_message_keys(var, var)
      var = { :action => (var.to_s) };Fi[	@Mi“I"¸      var = {}
      relevant_rules(var, var).map do |arglist|
        var.merge!(var.attributes_from_conditions) if var.base_behavior
      end
      var
    end
    
    def function(arglist)
      relevant_rules(var, var).any?(&:only_block?)
    end;Fi[	@MiI"—      var = [var]
      aliased_actions.each do |arglist|
        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end;Fi[	@riJI"Ò      var = {}
      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {}
      if @var.kind_of?(Hash) then;Fi[	@	i¬I"˜          var = [self]
          while var.last.inherited_data do
            (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {}
          ATTRIBUTES.each do |arglist|;Fi[	@i@I"	          else
            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist)
        if var.respond_to?(:serialize_to_config) then
          (var.serialize_to_config(var) + "\n");Fi[	@ri‹I"∂        else
          var
        end
      end
      var
    end
    
    def function(arglist)
      Sass::Script::List.new(var.map do |arglist|
        if ColorStop.===(var) then;Fi[	I"7data//cucumber_prok/cucumber/cli/profile_loader.rb;Ti$I"          end
        else
          raise(YmlLoadError, "The '#{profile}' profile in cucumber.yml was a #{args_from_yml.class}. It must be a String or Array")
        end
        var
      end
      
      def function(arglist)
        cucumber_yml.has_key?(var)
      end;Fi[	@ñiYI"µ          var = $1
          break
        end
      end
      var
    end
    
    def function(arglist)
      if var.respond_to?(:encode) then
        var.encode(DEFAULT_ENCODING);Fi[	I"1data//cucumber_prok/cucumber/formatter/io.rb;TiI"Ì            var.flush
            var.close
          end
        end
        var
      end
      
      def function(arglist)
        unless String.===(var) then
          raise("You *must* specify --out FILE for the #{name} formatter");Fi[	@i'I"{      var = { :from => (AppConfig.mail.sender_address.get), :host => ("#{AppConfig.pod_uri.host}"), :to => (name_and_address(@var.name, @var.email)) }
      if @var.present? then
        var[:from] = "\"#{@sender.name} (Diaspora*)\" <#{AppConfig.mail.sender_address}>"
      end
      var
    end
    
    def function(arglist)
      I18n.with_locale(@var.language, &var)
    end;Fi[	@iI"±    var.each do |arglist|
      var = single_admin(var, var, var.dup)
      (var << var)
    end
    var
  end
  
  def function(arglist)
    @var = var
    @var = var.html_safe;Fi[	@iƒI"°      var = (var + "/"))
    rescue => var
      var = @var["url"]
    end
    var
  end
  
  def function(arglist)
    "#{url}receive/users/#{self.guid}/"
  end;Fi[	I"7data//diaspora_proj/models/relayable_retraction.rb;TiI"    var = super
    if defined? var.parent and (var.person == var.parent.author) then
      var.parent_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    return nil unless self.target.present?
    self.target.parent;Fi[	I"4data//diaspora_proj/models/signed_retraction.rb;Ti6I"
    var.target = var
    if (var.person == var.author) then
      var.target_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    @var ||= self.target_type.constantize.where(:guid => (target_guid)).first
  end;Fi[	@æi[I"≠          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then
      create_mentions if self.mentions.empty?;Fi[	I"0data//diaspora_proj/models/user/querying.rb;TilI"÷      var = var.where(:owner_id => (nil))
    else
      var = var.where("people.owner_id IS NOT NULL") if (var[:type] == "local")
    end
    var
  end
  
  def function(arglist)
    contact_for(var).aspects
  end;Fi[	@(iyI"    if AppConfig.settings.follow_diasporahq? then
      var = Webfinger.new("diasporahq@joindiaspora.com").fetch
      self.share_with(var, var) if var
    end
    var
  end
  
  def function(arglist)
    OpenSSL::PKey::RSA.new(serialized_private_key)
  end;Fi[	@ziI"W    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile))
    if (is_own_profile or person_is_following_current_user) then
      var.merge!(:location => (@var.location), :birthday => (@var.formatted_birthday), :bio => (@var.bio))
    end
    var
  end
  
  def function(arglist)
    (@var.try(:person) == @var)
  end;Fi[	@√iÃI"ú        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var);Fi[	I"'data//homebrew_proj/cmd/missing.rb;TiI"    HOMEBREW_CELLAR.subdirs.each do |arglist|
      var = Formula.factory(var.basename.to_s) rescue nil
      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {}
    var.each do |arglist|;Fi[	@EiI"Ó        yield(var.name, var) if block_given?
        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist)
    return unless HOMEBREW_CELLAR.exist?
    var = ARGV.named.empty? ? (installed_brews) : (ARGV.formulae);Fi[	I"/data//nokogiri_proj/nokogiri/css/parser.rb;TiaI"          var.first
        else
          Node.new(:CONDITIONAL_SELECTOR, [var.first, var[1]])
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [var.first, Node.new(:COMBINATOR, [var[1], var.last])])
        var;Fi[	@JiÙI"¡          else
            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then
          var = Node.new(:AN_PLUS_B, var);Fi[	@Ji˝I"¸          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end
      
      def function(arglist)
        if (var[0] == "n") then
          var.unshift("1");Fi[	@JiI"‡          else
            raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then
          (var << "+");Fi[	@JiI"˝          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [var[1]])
        var;Fi[	I"2data//nokogiri_proj/nokogiri/css/tokenizer.rb;Ti1I"Ù      def function(arglist)
        return if @var.eos?
        until (var = _next_token or @var.eos?) do
        end
        var
      end
      
      def function(arglist)
        var = @var.peek(1)
        @var = (@var + 1) if (var == "\n");Fi[	I",data//nokogiri_proj/nokogiri/version.rb;Ti=I"—          var["xerces"] = Nokogiri::XERCES_VERSION
          var["nekohtml"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin
        require("psych");Fi[	@liEI"ˇ          var.unlink if text?
        else
          send(var, var)
        end
        var
      end
      
      def function(arglist)
        if Nokogiri.uses_libxml? and ["2", "6"].===(LIBXML_VERSION.split(".")[(0..1)]) then
          return dump_html;Fi[	@limI"ÿ        return fragment(var).children if var.is_a?(String)
        if (var.is_a?(Document) or (var.is_a?(XML::Attr) or var.is_a?(XML::Node).!)) then
          raise(ArgumentError, "Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.\n(You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)\n")
        end
        var
      end
      
      def function(arglist)
        "./"
      end;Fi[	I" data//omni_proj/omniauth.rb;TiqI"ﬁ          next
        end
        var[var] = var[var]
      end
      var
    end
    
    def function(arglist)
      if OmniAuth.config.camelizations[var.to_s] then
        return OmniAuth.config.camelizations[var.to_s];Fi[	I"$data//redmine_proj/redcloth3.rb;Ti*I"ß        end
        var
      end
    end
    var
  end
  
  def function(arglist)
    var.gsub!(/<redpre#(\d+)>/) { |arglist| @var[$1.to_i] } unless @var.empty?
  end;Fi[	@Hi3I"Ω              end
            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("B", 8)
        var.SetFillColor(230, 230, 230);Fi[	@OiaI"7        unless var.leaf? then
          (@var << var)
          var[:indent] += var[:indent_increment]
        end
        var
      end
      
      def function(arglist)
        if var.is_a?(Issue) and var.due_before then
          var = coordinates(var.start_date, var.due_before, var.done_ratio, var[:zoom]);Fi[	@Oi£I"          relations[var.id].each do |arglist|
            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = ""
        if var[:bar_start] and var[:bar_end] then;Fi[	@√i0I"Û          var = partition(var, var, var)
          sort_multiple(var, var, (var - 1))
          sort_multiple(var, (var + 1), var)
        end
        var
      end
      
      def function(arglist)
        var = var[0][var]
        var = var;Fi[	@√iCI"Ï        end
        var.each do |arglist|
          var[var], var[var], *s(:call, s(:lvar, :var), :[], s(:lvar, :var))
        end
        var
      end
      
      def function(arglist)
        if no_css then
          var = parse_css;Fi[	@⁄iI"        end
        unless @var.empty? then
          var = (var + "the extra elements were:        #{safe_sort(@extra_items).inspect}\n")
        end
        var
      end
      
      def function(arglist)
        "Matcher does not support should_not"
      end;Fi[	@≤i°I"ˇ            @var.raise_wrong_arity_error(var, var.arity)
          end
          var = eval_block(*var, &var)
        end
        var
      end
      
      def function(arglist)
        @var ? (@var.instance_exec(*var, &var)) : (var.call(*var))
      end;Fi[	@‘izI"Ô          var = 100.0
          if @var.!=(0) then
            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@ı
iI"ø              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true)
      end;Fi[	I")data//SiriProxy_proj/siri_objects.rb;Ti*I"ﬁ      else
        var["properties"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist)
    self.extend(SiriRootObject)
    self.ref_id = (var or random_ref_id);Fi[I"var;FI"end;FI"end;FI"end;FI"end;FiG[G[	I"Kdata//activemodel_proj/active_model/forbidden_attributes_protection.rb;TiI"ß      if var.respond_to?(:permitted?) and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	@RimI"√          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@ni3I"Ω            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@ói>I"ë        var = var.save
        set_new_record(var)
        raise(RecordInvalid.new(var)) if var.! and var
        var
      end
    end
  end
end;Fi[	@}iKI"º            var = Hash[var.query.split("&").map { |arglist| var.split("=") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	@ãifI"                var = (")" == var[5]) ? ((var[4].to_i - 1)) : (var[4].to_i)
                (var..var)
              else
                var
              end
            end
          end
        end
        
        def function(arglist);Fi[	@ìiòI"æ            var = "#{result}.#{sprintf("%06d", value.usec)}"
          end
          var = (var.sub(/^-/, "") + " BC") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	@∫i,I"æ        def function(arglist)
          var, var = super, var[:db_runtime]
          (var << ("ActiveRecord: %.1fms" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	@g	iàI"®        configuration.slice("host", "port", "socket").each do |arglist|
          var.concat(["--#{k}", var]) if var
        end
        var
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/notifier/mail.rb;Ti∏I"s        var = ::Mail.new
        var.to = @var
        var.from = @var
        var
      end
    end
  end
end;Fi[	@'ioI"V            end
          end
        end
        var
      end
    end
  end
end;Fi[	@ä	iOI"ì            say("Your response must be one of: [#{answers}]. Please try again.")
          end)
        end
        var
      end
    end
  end
end;Fi[	@SiµI"Á        var.each do |arglist|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end
ActiveRecord::Base.class_eval { |arglist| include(CanCan::ModelAdditions) };Fi[	I"Cdata//cancan_proj/cancan/model_adapters/data_mapper_adapter.rb;Ti#I"›        var.each do |arglist|
          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end
DataMapper::Model.append_extensions(CanCan::ModelAdditions::ClassMethods);Fi[	@|i∆I"m        when "nil" then
          nil
        else
          var
        end
      end
    end
  end
end;Fi[	@åi.I"s              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	@Øi±I"®        def function(arglist)
          var = variable(:scm_arguments)
          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	@∆iÖI"ä          when /^\d+/ then
            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	@ƒ	iLI"î          Sass::Importers::Filesystem.new(var.to_s)
        end
        (var << Compass::SpriteImporter.new)
        var
      end
    end
  end
end;Fi[	I":data//compass_proj/compass/configuration/file_data.rb;TiI"Æ      def self.new_from_string(arglist)
        var = new(var)
        var.with_defaults(var) { |arglist| var.parse_string(var, var) }
        var
      end
    end
  end
end;Fi[	@	iœI"s            end
            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	@“	i@I"ö          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"1data//cucumber_prok/cucumber/ast/examples.rb;Ti/I"ä        var = @var.to_sexp
        var = (var + [var]) if var
        var = (var + [@var.to_sexp])
        var
      end
    end
  end
end;Fi[	I"0data//cucumber_prok/cucumber/ast/feature.rb;TikI"≥        var = (var + var) if var.any?
        var = (var + [@var.to_sexp]) if @var
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	I".data//cucumber_prok/cucumber/ast/names.rb;TiI"è      def function(arglist)
        var = @var
        var = (var + "\n#{@description}") if @var.!=("")
        var
      end
    end
  end
end;Fi[	I"9data//cucumber_prok/cucumber/ast/scenario_outline.rb;TigI"°        var = @var.to_sexp
        var = (var + var) if var.any?
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	@Éi}I"p          var ||= ""
          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	@ôiµI"≥        var = var.join("_").to_sym
        var = FORMATS[var]
        raise("No format for #{key.inspect}: #{FORMATS.inspect}") if var.nil?
        var
      end
    end
  end
end;Fi[	@+i'I"ƒ          raise("I can't write #{name} reports to a file - it has to be a directory")
        end
        FileUtils.mkdir_p(var) unless File.directory?(var)
        var
      end
    end
  end
end;Fi[	@SiNI"Ç            attr_accessor(:line)
          end
          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	@Vi¶I"l            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@ƒiDI"ö        var = java.lang.Thread.new { |arglist| var = STDIN.gets }
        var.start
        var.join((var * 1000))
        var
      end
    end
  end
end;Fi[	@÷i(I"z            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@(iñI"À          return nil unless var
          var = Factory.from_db(klass, var, criteria.object_id)
          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	@`i.I"ï      def function(arglist)
        var = var.new(klass.aliased_fields, klass.fields)
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/criterion/modifiable.rb;Ti∂I"ô      def function(arglist)
        var = (first or create_document(var, var))
        yield(var) if block_given?
        var
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/fields/foreign_key.rb;Ti™I"e      #
      # @since 3.0.0
      def function(arglist)
        var
      end
    end
  end
end;Fi[	@ôiàI"’            document[field] = [] unless document[field]
            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	@ûiI"Œ              var = document.send(field)
              (value > 0) ? (var.pop) : (var.shift)
              execute("$pop")
              var
            end
          end
        end
      end
    end
  end;Fi[	@•iI"ª              var = document.send(field)
              var.delete(value)
              execute("$pull")
              var
            end
          end
        end
      end
    end
  end;Fi[	@¨iI"‹              var = document.send(field)
              var.delete_if { |arglist| value.include?(var) }
              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end;Fi[	I"?data//mongoid_proj/lib/mongoid/persistence/modification.rb;Ti I"ò        end
        document.post_persist unless (var == false)
        document.errors.clear unless validating?
        var
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/persistence/upsertion.rb;TiI"{          true
        end
        document.post_persist unless (var == false)
        var
      end
    end
  end
end;Fi[	@0i I"õ                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	@}iI"ê          var
        else
          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	I"0data//mongoid_proj/lib/mongoid/reloading.rb;TiVI"±    def function(arglist)
      atomic_position.split(".").inject(var) do |arglist|
        var = var[(var =~ /\d/ ? (var.to_i) : (var))]
        var
      end
    end
  end
end;Fi[	@üi3I"          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/sessions/factory.rb;Ti{I"µ      # @since 3.1.0
      def function(arglist)
        var["hosts"] = var["hosts"].map { |arglist| var =~ /:/ ? (var) : ("#{host}:27017") }
        var
      end
    end
  end
end;Fi[	@UivI"à        else
          raise(ScanError, (("undefined state: '" + state.to_s) + "'"))
        end
        var
      end
    end
  end
end;Fi[	I"*data//omni_proj/omniauth/auth_hash.rb;Ti2I"y      def function(arglist)
        var = super
        var["name"] ||= name
        var
      end
    end
  end
end;Fi[	@ÚiI"™      info do |arglist|
        options.fields.inject({}) do |arglist|
          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	@çiœI"{    def function(arglist)
      var.inject({}) do |arglist|
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	@(i'I"s              end
            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	@WiI"¶            var = "#{jsonp}(#{json})"
            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end
end;Fi[	@`iI"4          @@additional_blocks ||= Dir.glob("#{Redmine::Plugin.directory}/*/app/views/my/blocks/_*.{rhtml,erb}").inject({}) do |arglist|
            var = File.basename(var).split(".").first.gsub(/^_/, "")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	@eirI"              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end;Fi[	I"3data//rescue_proj/resque/failure/thoughtbot.rb;Ti I"§      def function(arglist)
        var = payload["class"].to_s
        var = var.underscore if var.respond_to?(:underscore)
        var
      end
    end
  end
end;Fi[	I"$data//rescue_proj/resque/job.rb;TiVI"                var.send(var, *var) do |arglist|
                  var = var.perform(*var)
                  var = true
                  var
                end
              end
            end
          end
          var.call
        end;Fi[	I"-data//rspec_proj/spec/matchers/pretty.rb;Ti'I"V            end
          end
        end
        var
      end
    end
  end
end;Fi[	I"5data//rspec_proj/spec/mocks/argument_matchers.rb;TiÊI"∫      def function(arglist)
        var = (var.last.class == Hash) ? (var.delete_at(-1)) : ({})
        var.each { |arglist| var[var] = anything }
        var
      end
    end
  end
end;Fi[	@i#I"Ω            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[	I",data//twitter_proj/twitter/api/lists.rb;TiXI"æ      def function(arglist)
        merge_user!(var, var, "owner")
        var[:owner_id] = var.delete(:owner_user_id) unless var[:owner_user_id].nil?
        var
      end
    end
  end
end;Fi[	I",data//twitter_proj/twitter/api/utils.rb;TiµI"ß        end
        var[:user_id] = var.join(",") unless var.empty?
        var[:screen_name] = var.join(",") unless var.empty?
        var
      end
    end
  end
end;Fi[	I"0data//twitter_proj/twitter/configuration.rb;TiI"µ    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	@DiI"√      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/profile_banner.rb;TiI"Ø    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[I"def function(arglist);FI"# do nothing;FI"end;FI" ;FI"def function(arglist);FiB[B[	@fieI"        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          serializable_collection.each do |arglist|
            var = ActiveSupport::XmlMini.rename_key(var.name, options);Fi[	@<iÀI"Z      # the target is stale.
      #
      # This is only relevant to certain associations, which is why it returns nil by default.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        reflection.build_association(var) do |arglist|
          var = [reflection.foreign_key, reflection.type].compact;Fi[	@iI"˜        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super
        var and [var.to_s, owner[reflection.foreign_type].to_s];Fi[	I"^data//activerecord_proj/active_record/connection_adapters/abstract/database_statements.rb;TiI"Y      end
      
      # Begins the transaction (and turns off auto-committing).
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        { :read_uncommitted => "READ UNCOMMITTED", :read_committed => "READ COMMITTED", :repeatable_read => "REPEATABLE READ", :serializable => "SERIALIZABLE" }
      end;Fi[	@)iI"      
      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@5	i¸I"©        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@5	i I"¢        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@5	iI"ô        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end;Fi[	@ÉiËI"Ω      
      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/postgresql/oid.rb;TiI"·    class PostgreSQLAdapter < AbstractAdapter
      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end;Fi[	@@iI"    #
    # See also http://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
    # :nodoc:
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = self.class.primary_key
      @var[var] = nil unless @var.key?(var);Fi[	I"@data//activerecord_proj/active_record/explain_subscriber.rb;TiI"5require("active_support/notifications")
module ActiveRecord
  class ExplainSubscriber
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      if var = Thread.current[:available_queries_for_explain] then
        (var << var.values_at(:sql, :binds)) unless ignore_payload?(var);Fi[	I";data//activerecord_proj/active_record/null_relation.rb;Ti;I"|      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@GirI"»    private
    
    # A hook to be overridden by association modules.
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      relation_for_destroy.delete_all
    end;Fi[	@”i‰I"ô        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@1iGI"Ê    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      unless @var then
        raise("LazySpecification has not been materialized yet (calling :#{method} #{args.inspect})");Fi[	@*i2I"ü  end
  
  class SystemRubyVersion < RubyVersion
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      RUBY_VERSION
    end;Fi[	@JiI"≠require("rubygems/user_interaction")
module Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@JiI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@JiI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@JiI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@JiI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@JiI"á      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@ıi.I"â          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then
            puts("\n*********************************************************************\nCongratulations! Your compass project has been created.\n\nYou may now add and edit sass stylesheets in the #{Compass.configuration.sass_dir} subdirectory of your project.\n\nSass files beginning with an underscore are called partials and won't be\ncompiled to CSS, but they can be imported into other sass stylesheets.\n\nYou can configure your project by editing the config.rb configuration file.\n\nYou must compile your sass stylesheets into CSS when they change.\nThis can be done in one of the following ways:\n  1. To compile on demand:\n     compass compile [path/to/project]\n  2. To monitor your project for changes and automatically recompile:\n     compass watch [path/to/project]\n\nMore Resources:\n  * Website: http://compass-style.org/\n  * Sass: http://sass-lang.com\n  * Community: http://groups.google.com/group/compass-users/\n\n");Fi[	I"=data//compass_proj/compass/exec/command_option_parser.rb;TiI"≥      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s
    end;Fi[	I"<data//compass_proj/compass/installers/bare_installer.rb;TiI"˝module Compass
  module Installers
    class BareInstaller < Base
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir));Fi[	@ZiI"˚        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("config.rb")
        write_file(var, config_contents);Fi[	I"2data//compass_proj/compass/installers/base.rb;Ti5I"Á      
      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end;Fi[	I")data//compass_proj/compass/logger.rb;TiRI"ä  end
  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@biVI"á      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end;Fi[	I"2data//compass_proj/compass/sprite_importer.rb;Ti"I"à      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name
    end;Fi[	I"(data//compass_proj/compass/stats.rb;TiI"œ        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ji"I"∏        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false
        var = var.send(:import);Fi[	@∫iCI"         var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
        @var.next_feature_element(self) { |arglist| var.skip_invoke! };Fi[	@üiGI"›        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var)
        var = (Time.now - @var);Fi[	I"7data//cucumber_prok/cucumber/formatter/stepdefs.rb;Ti	I"Ømodule Cucumber
  module Formatter
    class Stepdefs < Usage
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0
      end;Fi[	@MivI"Á        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language
      end;Fi[	@Mi~I"ÿ        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|
          if var = var.arguments_from(var) then;Fi[	@Si=I"®        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@∑iI"∆        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "python snippet: #{code_keyword}, #{step_name}"
      end;Fi[	@∑i$I"»        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var)
      end;Fi[	@biI"¯          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end;Fi[	@_iI"À        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var)
        (@var << Connection.new(var));Fi[	I"=data//devise_proj/devise/models/token_authenticatable.rb;Ti%I"ÿ      end
      
      # Hook called after token authentication.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        self.class.expire_auth_token_on_timeout
      end;Fi[	I"'data//diaspora_proj/models/post.rb;Ti:I"x    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end;Fi[	@£i|I"µ      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value
      rstrip_buffer! if var[:nuke_outer_whitespace];Fi[	I"9data//haml_proj/haml/helpers/safe_erubis_template.rb;TiI"Ímodule Haml
  class SafeErubisTemplate < Tilt::ErubisTemplate
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      @var.merge!(:engine_class => (ActionView::Template::Handlers::Erubis))
      super;Fi[	I"8data//omni_proj/omniauth/test/strategy_test_case.rb;TiI"¥        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["rack.session"]
      end;Fi[	I">data//paperclip_proj/paperclip/io_adapters/nil_adapter.rb;TiI"ömodule Paperclip
  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end;Fi[	@íiI"~      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end;Fi[	@.iI"ä  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end;Fi[	@bi I"°  end
  
  # XXX TODO XXX
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    QTAGS.each do |arglist|
      var.gsub!(var) do |arglist|;Fi[	@√ilI"Ÿ      end
      
      # Override and place code to add defs here
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = Document.new
        (@var << XMLDecl.new);Fi[	I"(data//redmine_proj/SVG/Graph/Pie.rb;Ti_I"•      end
      
      # We don't need the graph
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        [""]
      end;Fi[	I"?data//rspec_proj/spec/adapters/mock_frameworks/flexmock.rb;TiI"∆    module MockFramework
      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        flexmock_verify
      end;Fi[	@	iI"≠      end
      
      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end;Fi[	@	i.I"’      end
      
      class BooleanMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          (TrueClass.===(var) or FalseClass.===(var))
        end;Fi[	I"6data//rspec_proj/spec/runner/backtrace_tweaker.rb;TiI"†        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end;Fi[	@ŒiI"≠          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@—iI"¥          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@‘i~I"Ã          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then
            var = "This was a dry-run";Fi[@I"@var = var;FI"end;FI" ;FI"def function(arglist);FiA[A[	@zi4I"¥      end
      
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.unserialized_value
        end;Fi[	@¢i	I"  module AttributeMethods
    module TimeZoneConversion
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var = @var.type_cast(var)
          var.acts_like?(:time) ? (var.in_time_zone) : (var);Fi[	@ßiﬁI"…    end
    
    class ConnectionManagement
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (var = var.key?("rack.test")
        var = @var.call(var);Fi[	@6iEI"'        class Array < Type
          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var);Fi[	@–iI"µ      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled;Fi[	@g	iI"      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database);Fi[	@l	iI"      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var;Fi[	@ıiI"˙      end
      
      # Unfortunately, we have to tie Uniqueness validators to a class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = find_finder_class_for(var)
        var = var.arel_table;Fi[	@,iI"Ÿ      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then;Fi[	@óiI"»      end
      
      class DefaultConnectionFactory
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          SSH.connect(var, @var)
        end;Fi[	@ØiI"Ú        end
        
        class LocalProxy
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            @var.local { |arglist| return @var.send(var, *var, &var) }
          end;Fi[	I"0data//cucumber_prok/cucumber/ast/comment.rb;TiI"∏module Cucumber
  module Ast
    class Comment
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (@var.nil? or (@var == ""))
      end;Fi[	I"0data//cucumber_prok/cucumber/broadcaster.rb;TiI"≤module Cucumber
  class Broadcaster
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      @var.map { |arglist| var.__send__(var, *var) }
    end;Fi[	@¢isI"°        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
        @var = 4;Fi[	@•i1I"ú        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end;Fi[	@biI"       class StepInvoker
        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@eiI"∫      
      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = WirePacket.new(var, var)
        begin;Fi[	I"'data//devise_proj/devise/models.rb;TiI"module Devise
  module Models
    class MissingAttribute < StandardError
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        "The following attribute(s) is (are) missing on your model: #{@attributes.join(", ")}"
      end;Fi[	I" data//devise_proj/devise.rb;Ti˛I"•  end
  
  class Getter
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      ActiveSupport::Dependencies.constantize(@var)
    end;Fi[	I"7data//diaspora_proj/presenters/aspect_presenter.rb;TiI"¢class AspectPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :name => (@var.name) }
  end;Fi[	I"8data//diaspora_proj/presenters/comment_presenter.rb;TiI"class CommentPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :guid => (@var.guid), :text => (@var.text), :author => (@var.author.as_api_response(:backbone)), :created_at => (@var.created_at) }
  end;Fi[	I"Ddata//diaspora_proj/presenters/last_three_comments_decorator.rb;TiI"¯class LastThreeCommentsDecorator
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var.as_json.tap do |arglist|
      var[:interactions].merge!(:comments => (CommentPresenter.as_collection(@var.post.last_three_comments)));Fi[	I"8data//diaspora_proj/presenters/service_presenter.rb;TiI"ôclass ServicePresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :provider => (@var.provider) }
  end;Fi[	@1iI"éclass Caveats
  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = []
    (var << f.caveats);Fi[	@XiöI"ª  end
end
class VersionSchemeDetector
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    if @var.is_a?(Class) and @var.ancestors.include?(Version) then
      @var;Fi[	I"1data//omni_proj/omniauth/failure_endpoint.rb;TiI"»      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["RACK_ENV"].to_s == "development")
      redirect_to_failure;Fi[	I"3data//omni_proj/omniauth/test/phony_session.rb;TiI"≤class OmniAuth::Test::PhonySession
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var ||= (var["rack.session"] or {})
    var["rack.session"] = @var;Fi[	@tiI"º    
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      (if blank? then
        SENSIBLE_DEFAULT;Fi[	@wi	I"‘  class FileCommandContentTypeDetector
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      type_from_file_command
    end;Fi[	@Äi	I"%  class GeometryParser
    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var));Fi[	I"-data//paperclip_proj/paperclip/logger.rb;TiI"¥      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log]
    end;Fi[	@¯iI"‚      end
      
      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = @var.class unless Class.===(@var);Fi[	@˛iI"Í      end
      
      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = var.new if (var.class == Class);Fi[	@iI"ƒ      end
      
      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self;Fi[	@.iâI"ì    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@.içI"}    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var;Fi[	@.i®I"r    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@.i¨I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@.i∞I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@.i¥I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@.i∏I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@.iºI"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@.i¿I"á    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("FPDF error: " + var))
  end;Fi[	I">data//redmine_proj/redmine/views/other_formats_builder.rb;TiI"#module Redmine
  module Views
    class OtherFormatsBuilder
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = { :format => (var.to_s.downcase) }.merge((var.delete(:url) or {})).except("page")
        var = (var.delete(:caption) or var);Fi[	@œiI"π    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!;Fi[	@⁄i
I"Â    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var);Fi[	I".data//rspec_proj/spec/matchers/satisfy.rb;TiI"∏module Spec
  module Matchers
    class Satisfy
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var if var
        @var = var;Fi[	@	i#I"ﬂ      end
      
      class RegexpMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          return var.=~(@var) unless var.is_a?(Regexp)
          (var == @var);Fi[	@	i8I"À      end
      
      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|;Fi[	@	iMI"Œ      end
      
      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|;Fi[	@	ibI"’      end
      
      class DuckTypeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.all? { |arglist| var.respond_to?(var) }
        end;Fi[	@	ilI"∫      end
      
      class MatcherMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.matches?(var)
        end;Fi[	@	ivI"¥      end
      
      class EqualityProxy
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var == var)
        end;Fi[	@	i{I"∫      end
      
      class InstanceOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.instance_of?(@var)
        end;Fi[	@	iÖI"≤      end
      
      class KindOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.kind_of?(@var)
        end;Fi[	@≤iSI"-      # raise an instance of it, creating it with +new+. If the exception
      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end;Fi[	@≤iWI"©        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then
          @var.clear;Fi[	@πiI"Ômodule Spec
  module Runner
    class ExampleGroupRunner
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        $KCODE = "u" if (RUBY_VERSION.to_f < 1.9)
        var.each { |arglist| load(var) };Fi[	@ÀiI"˙          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["#{@example_group.description} #{example.description}", var, var.location])
        end;Fi[	@ÃiI" module Whenever
  module Output
    class Redirection
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        return "" unless defined? @var
        case @var;Fi[@'@TI"def function(arglist);FI"# do nothing;FI"end;Fi9[9[	@iI"∆      
      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@)iI"      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.;Fi[	@5	i˙I"-        var = "#transaction_joinable= is deprecated. Please pass the :joinable option to #begin_transaction instead."
        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@5	i˛I"¶      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@5	iI"¶      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@>i9I"á    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@”i‚I"«            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@”iÊI"Í      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in;Fi[	I".data//bundler_proj/bundler/environment.rb;Ti&I"î    
    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@Ji
I"ò  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@JiI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@JiI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@JiI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@JiI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@ıi,I"˜          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@WiI"∫    
    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@ZiI"Ë      def function(arglist)
        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@biTI"†  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@gi I"«        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@jiI"        end
        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ji I"¶      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ÄiI"Ø        
        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	@∫iAI"Ù        var.visit_steps(@var)
        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@6iI"•        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	@ôiÜI"+        else
          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to;Fi[	@üiEI"      def function(arglist)
        @var = (var.nil? or (var == "")) ? ("Unnamed scenario") : (var.split("\n")[0])
        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@MitI"‰      
      def function(arglist)
        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@Mi|I"≠      
      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@Si;I"$        var = Ast::Step.new(var.line, var.keyword, var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@Si?I"ò      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private;Fi[	@∑iI"ß      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@∑i"I"˘        RubyPython.start
        @var = import((File.dirname("(string)") + "/py_language.py"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@biI"∏        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@biI"Ë        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	I"Adata//cucumber_prok/cucumber/wire_support/request_handler.rb;TiI"¶      
      def function(arglist)
        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      
      private;Fi[	@_iI"£      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@vi,I"©      
      def function(arglist)
        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      
      var = ["serializable_hash"];Fi[	@{iOI"        var = update_attributes(var, *var)
        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A reliable way to expose the salt regardless of the implementation.;Fi[	@liOI"⁄      def function(arglist)
        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods;Fi[	@ái8I"Å  
  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist);Fi[	I"*data//diaspora_proj/models/service.rb;Ti%I"›    var = truncate(var, :length => ((var - var)))
    var = "#{truncated}#{url}"
    return var
  end
  
  def function(arglist)
    # do nothing
  end
end
require(Rails.root.join("app", "models", "services", "facebook"));Fi[	@£izI"Ñ          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@èiI"Ò            [404, { "Content-Type" => "text/plain" }, [(var or var.key?("omniauth.auth").to_s)]]
          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@íiI"ä    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	I"0data//paperclip_proj/paperclip/processor.rb;TiI"î      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    
    def self.make(arglist);Fi[	@.iI"~  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function;Fi[	@ßiI"Æ      
      def function(arglist)
        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ŒiI"∏            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@ŒiI"•        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[	@—iI"˙        def function(arglist)
          @var.puts("#{example_group.description} #{example.description}")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@—iI"•        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[	@‘i|I"„            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[I" ;F@
I"# do nothing;FI"end;FI" ;Fi6[6[	@fidI"…        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          serializable_collection.each do |arglist|;Fi[	@iI"”      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super;Fi[	@)iI"‡      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.
      def function(arglist);Fi[	@5	i˚I"Ã        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@5	iˇI"¥      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@5	iI"´      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var;Fi[	@>i:I"é    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	@”i„I"ù          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@”iÁI"˛      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in
      # ThroughReflection.;Fi[	@1iFI"à    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      unless @var then;Fi[	@JiI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@JiI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@JiI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@JiI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@JiI"ô    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	@ıi-I"             write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then;Fi[	@WiI"≈    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s;Fi[	@ZiI"Û        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("config.rb");Fi[	@biUI"ô    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield;Fi[	@gi!I"ä      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name;Fi[	@jiI"        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@ji!I"¥      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false;Fi[	@∫iBI"        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! };Fi[	@ôiáI";          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to
      #activate this feature;Fi[	@üiFI"        @var = (var.nil? or (var == "")) ? ("Unnamed scenario") : (var.split("\n")[0])
        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var);Fi[	@MiuI"˘      def function(arglist)
        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language;Fi[	@Mi}I"ƒ      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|;Fi[	@Si<I"¡        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@Si@I"ò      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	@∑iI"ÿ      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "python snippet: #{code_keyword}, #{step_name}";Fi[	@∑i#I"        @var = import((File.dirname("(string)") + "/py_language.py"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var);Fi[	@biI"
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)));Fi[	@ÖiI"¶      def function(arglist)
        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	@_iI"¡      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var);Fi[	@vi-I"©      def function(arglist)
        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      
      var = ["serializable_hash"]
      ;Fi[	@{iPI"·        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A reliable way to expose the salt regardless of the implementation.
      def function(arglist);Fi[	@liPI"        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new;Fi[	@ái9I"Ö  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "";Fi[	@£i{I"ç        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value;Fi[	@èiI"π          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["rack.session"];Fi[	@íiI"ê    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true;Fi[	@õiI"°      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    
    def self.make(arglist)
      new(var, var, var).make;Fi[	@.iI"ä  end
  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing;Fi[	@.iI"~  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  ;Fi[	@†iI"Œ  module Adapters
    module MockFramework
      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        flexmock_verify;Fi[	@ßiI"≤      def function(arglist)
        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        [];Fi[	@ŒiI"∏            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	@—iI"Û          @var.puts("#{example_group.description} #{example.description}")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	@‘i}I"≥          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then;Fi[@'@(I"var;FI"end;FI" ;Fi3[3[	@1i5I"±          var.to_ary.map { |arglist| var.serializable_hash(var) }
        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    ;Fi[	@<iõI"E          var[reflection.foreign_key] = owner[reflection.active_record_primary_key]
          if reflection.options[:as] then
            var[reflection.type] = owner.class.base_class.name
          end
        end
        var
      end
      
      # Sets the owner attributes on the given record
      def function(arglist);Fi[	@|iUI"˜            var = eval_scope(var.klass, var)
            var.includes!(var.includes_values)
            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist)
        reflection.name;Fi[	@áifI";            if (var.macro == :has_one) then
              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!;Fi[	@i¥I"            set_target_and_inverse(var, var, var)
          else
            raise(ConfigurationError, "unknown macro: #{join_part.reflection.macro}")
          end
        end
        var
      end
      
      def function(arglist)
        var = var.association(var.reflection.name);Fi[	@åiI"ù          (var << alias_tracker.aliased_table_for(table_name_for(var), table_alias_for(var, var.!=(self.reflection))))
          if (var.source_macro == :has_and_belongs_to_many) then
            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist)
        var.table_name;Fi[	@∂iõI"            end
            (var.last.columns << var[:Column_name])
            (var.last.lengths << var[:Sub_part])
          end
        end
        var
      end
      
      # Returns an array of +Column+ objects for the table specified by +table_name+.
      def function(arglist);Fi[	@ØiÕI"d          end
          if create_time_zone_conversion_attribute?(var, var) then
            var[var] = AttributeMethods::TimeZoneConversion::Type.new(var)
          end
        end
        var
      end
      
      # Returns a hash where the keys are column names and the values are
      # default values when instantiating the AR object for this table.;Fi[	I"Hdata//activerecord_proj/active_record/relation/predicate_builder.rb;TiI"             var = Arel::Table.new(var, var.engine)
          end
          var.concat(expand(var, var, var, var))
        end
      end
      var
    end
    
    def self.expand(arglist)
      var = [];Fi[	@^	iOI"ı            end
          else
            var[var] = var
          end
        end
        var
      end
      
      # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.
      #   { name: "foo'bar", group_id: 4 };Fi[	@ËiJI"â            Logger.message("Session data loaded from cache!"))
          rescue => var
            Logger.warn(Errors::Storage::Dropbox::CacheError.wrap(var, "              Could not read session data from cache.\n              Cache data might be corrupt.\n"))
          end
        end
        var
      end
      
      ##
      # Transfers the archived file to the specified Dropbox folder;Fi[	@i_I"Á        if var.respond_to?(:unlock!) and @var[:sources].include?(var.name) then
          var.unlock!
          var = true
        end
      end
      var
    end
    
    def function(arglist)
      (@var + @var).each do |arglist|;Fi[	@iëI"1        next unless var.respond_to?(:unlock!)
        unless var.any? { |arglist| (var.source == var) } then
          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist)
      var and (var.source == var.source);Fi[	@i¨I"·          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|;Fi[	@)i4I"        var.search(var, var).each do |arglist|
          (var << var) unless var.include?([var.name, var.version, var.platform])
          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist)
      case var;Fi[	@BiáI"E            raise(PathError, "The path `#{expanded_path}` is not a directory.")
          else
            raise(PathError, "The path `#{expanded_path}` does not exist.")
          end
        end
        var
      end
      
      def function(arglist)
        if path.to_s.match(/^#{Regexp.escape(Bundler.root.to_s)}/) then;Fi[	@riSI"«      if @var.kind_of?(Hash) then
        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    ;Fi[	@¢	irI"—            (var << "\n")
          else
            (var << var.map { |arglist| "#{indentation}#{l}\n" }.join)
          end
        end
        var
      end
      
      #:nodoc:
      def function(arglist);Fi[	@îi}I"=            var = var.map do |arglist|
              (var == "deploy:symlink") ? ("deploy:create_symlink") : (var)
            end
          end
        end
        var
      end
      
      # Trigger the named event for the named task. All associated callbacks
      # will be fired, in the order they were defined.;Fi[	@i?I"Ú            (var << var)
          else
            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist)
        if var.respond_to?(:serialize_to_config) then;Fi[	@ri€I"¡          Sass::Script::Number.new(50, ["%"])
        else
          var
        end
      end
      var
    end
    
    def function(arglist)
      Sass::Script::List.new(var.map do |arglist|;Fi[	@riGI",          if (var.value.last == var.value.last) and (var.value.first.value == 0) then
            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    
    # returns the end position of the gradient from the color stop
    def function(arglist);Fi[	@ñiXI"π        if ENCODING_PATTERN.=~(var) then
          var = $1
          break
        end
      end
      var
    end
    
    def function(arglist)
      if var.respond_to?(:encode) then;Fi[	@+iI"ƒ          unless var.closed? then
            var.flush
            var.close
          end
        end
        var
      end
      
      def function(arglist)
        unless String.===(var) then;Fi[	@vi∑I"‰              var = var[var]
              var.send("#{key}=", var)
              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected
        ;Fi[	@liqI":              var.reset_password!(var[:password], var[:password_confirmation])
            else
              var.errors.add(:reset_password_token, :expired)
            end
          end
          var
        end
        
        Devise::Models.config(self, :reset_password_keys, :reset_password_within)
      end;Fi[	@æiZI"å        else
          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then;Fi[	@√iÀI"ì          var["id"] = var
        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {};Fi[	@EiI"…      unless var.empty? then
        yield(var.name, var) if block_given?
        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist)
    return unless HOMEBREW_CELLAR.exist?;Fi[	@@i_I"ß        end
        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  ;Fi[	@6iëI"ò          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    ;Fi[	@Pi0I"            (var[var] ||= {}).merge!(var)
          else
            (var["$set"] ||= {}).merge!(var => (mongoize_for(var, var, var)))
          end
        end
        var
      end
      
      # Check if the hash is part of a blank relation criteria.
      #;Fi[	I"0data//mongoid_proj/lib/mongoid/hierarchy.rb;Ti-I"ª              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end
    
    # Marks all children as being persisted.
    #;Fi[	@JiÛI"√            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then;Fi[	@JiI"ı            var = Node.new(:AN_PLUS_B, var)
          else
            raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then;Fi[	@Xi<I"œ        if jruby? then
          var["xerces"] = Nokogiri::XERCES_VERSION
          var["nekohtml"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin;Fi[	@ii=I"∏            end
          else
            var.content = var
          end
        end
        var
      end
      
      # Create a Text Node with +string+
      def function(arglist);Fi[	@bi)I"Ø          end
        end
        var
      end
    end
    var
  end
  
  def function(arglist)
    var.gsub!(/<redpre#(\d+)>/) { |arglist| @var[$1.to_i] } unless @var.empty?;Fi[	@:i I"Æ            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8(arglist)
      return var if var.nil?;Fi[	@:iHI"π            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8_by_setting(arglist)
      return var if var.nil?;Fi[	@Hi2I"©                end
              end
            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("B", 8);Fi[	@Oi¢I"Ù        if relations[var.id] then
          relations[var.id].each do |arglist|
            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = "";Fi[	I",data//redmine_proj/redmine/thumbnail.rb;TiI"˚        unless system(var) then
          logger.error("Creating thumbnail failed (#{$?}):\nCommand: #{cmd}")
          return nil
        end
      end
      var
    end
    
    def self.convert_available?(arglist)
      return @var if defined? @var;Fi[	@ı
iÔI"∆            else
              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true);Fi[	@wi)I"¡        end
      else
        var["properties"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist)
    self.extend(SiriRootObject);Fi[	I"Adata//state_machine_proj/state_machine/machine_collection.rb;Ti,I"Q          if var.dynamic_initial_state? then
            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    
    # Runs one or more events in parallel on the given object.  See
    # StateMachine::InstanceMethods#fire_events for more information.;Fi[@'@T@U@VI"##;Fi-[-[	@PiVI"      else
        raise(Errors::Archive::PipelineError, ("Failed to Create Backup Archive\n" + var.error_messages))
      end
    end
    
    private
    
    ##
    # Returns a "tar-ready" string of all the specified paths combined
    def function(arglist);Fi[	I",data//backup_proj/backup/cli/utility.rb;Ti◊I"      # Returns the current version of the Backup gem
      def function(arglist)
        puts("Backup #{Backup::Version.current}")
      end
      
      private
      
      ##
      # Helper method for asking the user if he/she wants to overwrite the file
      def function(arglist);Fi[	I"0data//backup_proj/backup/compressor/base.rb;TiI"œ      def function(arglist)
        log!
        yield(@var, @var)
      end
      
      private
      
      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist);Fi[	I"2data//backup_proj/backup/compressor/custom.rb;TiI"Û        instance_eval(&var) if block_given?
        @var = set_cmd
        @var = set_ext
      end
      
      private
      
      ##
      # Return the command line using the full path.
      # Ensures the command exists and is executable.;Fi[	I".data//backup_proj/backup/database/base.rb;TiI"»      def function(arglist)
        prepare!
        log!
      end
      
      private
      
      ##
      # Defines the @dump_path and ensures it exists by creating it
      def function(arglist);Fi[	@UiLI"∆          (unlock_database if @var
          package! unless var)
        end
      end
      
      private
      
      ##
      # Builds and runs the mongodump command
      def function(arglist);Fi[	@XiHI"        else
          raise(Errors::Database::PipelineError, ("#{database_name} Dump Failed!\n" + var.error_messages))
        end
      end
      
      private
      
      ##
      # Builds the full mysqldump string based on all attributes
      def function(arglist);Fi[	I"/data//backup_proj/backup/database/redis.rb;Ti8I"‹        super
        invoke_save! if invoke_save
        copy!
      end
      
      private
      
      ##
      # Tells Redis to persist the current state of the
      # in-memory database to the persisted dump file;Fi[	@[i0I"∆            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes
      def function(arglist);Fi[	I"/data//backup_proj/backup/encryptor/base.rb;TiI"≈      
      def function(arglist)
        load_defaults!
      end
      
      private
      
      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist);Fi[	@^ieI"Æ        ensure
          cleanup
        end
      end
      
      private
      
      ##
      # Remove any temporary directories and reset all instance variables.
      #;Fi[	I"3data//backup_proj/backup/encryptor/open_ssl.rb;Ti-I"      def function(arglist)
        log!
        yield("#{utility(:openssl)} #{options}", ".enc")
      end
      
      private
      
      ##
      # Uses the 256bit AES encryption cipher, which is what the
      # US Government uses to encrypt information at the "Top Secret" level.;Fi[	@ai@I"º          log!
          notify!(var)
        end
      end
      
      private
      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist);Fi[	@ﬂiI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@ﬂikI"f        # Wrapper method for the #send_message (private) method
        def function(arglist)
          send_message(var)
        end
        
        private
        
        ##
        # Takes a "message" as argument, the "type" defaults to "Textmessage".
        # This method builds up a POST request with the necessary params (serialized to JSON format);Fi[	@‚i0I"¯        @var ||= "yellow"
        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@îioI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"/data//backup_proj/backup/notifier/prowl.rb;TiI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"2data//backup_proj/backup/notifier/pushover.rb;Ti I"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"1data//backup_proj/backup/notifier/twitter.rb;TiI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I")data//backup_proj/backup/pipeline.rb;TiFI"¬    # Each error is wrapped by Backup::Errors to provide formatting.
    def function(arglist)
      @var ||= (((stderr_messages or "") + "The following system errors were returned:\n") + @var.map { |arglist| Errors::Error.wrap(var).message }.join("\n"))
    end
    
    private
    
    ##
    # Each command is added as part of the pipeline, grouped with an `echo`
    # command to pass along the command's index in @commands and it's exit status.;Fi[	I")data//backup_proj/backup/splitter.rb;TiI"Ô      before_packaging
      yield(@var)
      after_packaging
    end
    
    private
    
    ##
    # The `split` command reads from $stdin and will store it's output in
    # multiple files, based on the @chunk_size. The files will be;Fi[	I"-data//backup_proj/backup/storage/base.rb;Ti%I"˘        @var = @var.package
        transfer!
        cycle!
      end
      
      private
      
      ##
      # Provider defaults to false. Overridden when using a service-based
      # storage such as Amazon S3, Rackspace Cloud Files or Dropbox;Fi[	@ÂiI"Ô        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage
      def function(arglist);Fi[	@Ëi%I"&        @var ||= "backups"
        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # The initial connection to Dropbox will provide the user with an
      # authorization url. The user must open this URL and confirm that the;Fi[	@Îi"I"‘        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #;Fi[	@iI"#        @var ||= File.join(File.expand_path((ENV["HOME"] or "")), "backups")
        instance_eval(&var) if block_given?
        @var = File.expand_path(@var)
      end
      
      private
      
      ##
      # Transfers the archived file to the specified path
      def function(arglist);Fi[	@ÛiI"Ì        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage
      def function(arglist);Fi[	I".data//backup_proj/backup/storage/rsync.rb;Ti$I"Á        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored
      #;Fi[	@ˆiI"Á        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage
      def function(arglist);Fi[	@˘iI"¸        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.;Fi[	@¸iI"Ï        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist);Fi[	@iSI"Q            else
              raise(Errors::Syncer::Cloud::ConfigurationError, "Unknown concurrency_type setting: #{concurrency_type.inspect}")
            end
          end
          
          private
          
          ##
          # Gathers all the relative paths to the local files
          # and merges them with the , removing;Fi[	@
i,I"          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for CloudFiles.
        def function(arglist);Fi[	@i#I"¸          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for S3.
        def function(arglist);Fi[	@iI"	        def function(arglist)
          super
          @var ||= Array.new
        end
        
        private
        
        ##
        # Returns the @directories as a space-delimited string of
        # single-quoted values for use in the `rsync` command line.;Fi[	@iI"_        def function(arglist)
          Logger.message(("#{syncer_name} started syncing the following directories:\n  " + @var.join("\n  ")))
          run(("#{utility(:rsync)} #{options} " + "#{directories_option} '#{dest_path}'"))
        end
        
        private
        
        ##
        # Return expanded @path
        def function(arglist);Fi[	@iI"—          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return expanded @path, since this path is local
        def function(arglist);Fi[	@i6I"œ          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return @path with any preceeding "~/" removed
        def function(arglist);Fi[	I")data//backup_proj/backup/template.rb;Ti$I"R    # Returns a String object containing the contents of the file (in the context of the binding if any)
    def function(arglist)
      ERB.new(file_contents(var), nil, "<>").result(binding)
    end
    
    private
    
    ##
    # Reads and returns the contents of the provided file path,
    # relative from the Backup::TEMPLATE_PATH;Fi[@'@TI"attr_reader :function;FI" ;FI"def function(arglist);Fi%[%[	@)i‡I"ò            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?
      end;Fi[	@0	i5I"»        @var = []
        @var = false
        @var = var.fetch(:joinable, true)
      end
      
      attr_reader :function
      
      def function(arglist)
        @var and finishing?.!
      end;Fi[	@5	iÊI"˘      # is no longer active, then this method will reconnect to the database.
      def function(arglist)
        reconnect! unless active?
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.number
      end;Fi[	@inI"ø    
    def function(arglist)
      (@var - specs)
    end
    
    attr_reader :function
    
    def function(arglist)
      var = []
      resolve.materialize(requested_dependencies, var);Fi[	@8i™I"¬      
      def function(arglist)
        cached_revision and super
      end
      
      attr_reader :function
      
      def function(arglist)
        allow_git_ops? and local?.!
      end;Fi[	@JiAI"¨      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.!.! and @var.!
      end;Fi[	@]i5I"Ó        @var[var.switch_name] = var
        var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist)
      return super unless @var
      var = super;Fi[	@Ñi#I"ª        
        def function(arglist)
          options[:last]
        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end;Fi[	@ßiWI"       def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      
      def function(arglist)
        var = @var.dup
        (var << " (#{@hosts})") if @var;Fi[	I"2data//compass_proj/compass/app_integration.rb;TiI"ˆ      #attr_accessor :project_types
      def function(arglist)
        @var ||= DEAFULT_PROJECT_TYPES.dup
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.keys.===(DEAFULT_PROJECT_TYPES.keys)
      end;Fi[	I"3data//cucumber_prok/cucumber/ast/background.rb;TiII"       
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
      end
      
      attr_reader :function
      
      def function(arglist)
        (@var.first or self)
      end;Fi[	@6iÅI"Ω      
      def function(arglist)
        cells_rows[0][var]
      end
      
      attr_reader :function
      
      def function(arglist)
        columns[var].__send__(:width)
      end;Fi[	I"0data//cucumber_prok/cucumber/cli/options.rb;TiÍI"º            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then
          @var.puts("Disabling profiles...");Fi[	@Mi<I"ÿ    class JsHook
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.current_world.execute(@var)
      end;Fi[	@MiXI"≠    class JsArg
      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end;Fi[	@MiñI"›      
      def function(arglist)
        add_transform(JsTransform.new(self, var, var))
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.invoke_steps(var, @var, var)
      end;Fi[	I"%data//homebrew_proj/checksums.rb;TiI"§  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == var.hash_type) and (@var == var.hexdigest)
  end;Fi[	@GiæI"<    @var = "#{name}--svn" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (@var + "-HEAD") if ARGV.include?("--HEAD")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.sub!(/^svn\+/, "") if @var =~ /^svn\+http:\/\//
    ohai("Checking out #{@url}");Fi[	@GiI"ı    @@git ||= "git"
    @var = "#{name}--git" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.!=(:revision) and host_supports_depth?
  end;Fi[	@GieI"ı    super
    @var = "#{name}--cvs" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    ohai("Checking out #{@url}")
    var, var = split_url(@var);Fi[	@GiêI"E    super
    @var = "#{name}--hg" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|
      File.executable?(var);Fi[	@Gi∫I""    super
    @var = "#{name}--bzr" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|
      File.executable?(var);Fi[	@Gi⁄I"+    super
    @var = "#{name}--fossil" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|
      File.executable?(var);Fi[	I"+data//homebrew_proj/formula_support.rb;TiuI"Ñ    else
      true
    end
  end
  
  attr_reader :function
  
  def function(arglist)
    case @var
    when :provided_by_osx then;Fi[	@Xi3I"ë  def function(arglist)
    @var = var.to_s
    @var = var
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == "HEAD")
  end;Fi[	@.iI"ﬂ  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f G", (var / 255.0));Fi[	@.i‡I"     var = ((var + " ") + dounderline(var, var, var)) if @var and var.!=("")
    var = (((("q " + @var) + " ") + var) + " Q") if @var
    out(var)
  end
  
  attr_reader :function
  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true;Fi[	@.iÏI"È  def function(arglist)
    @var = @var
    var.kind_of?(String) ? (@var = (@var + @var)) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var))
  end;Fi[	@.iÚI"“  
  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    @var = @var
    (var >= 0) ? (@var = var) : (@var = (@var + var));Fi[	@TiI"n        def function(arglist)
          @var = with_trailling_slash(var)
          @var = var.blank? ? ("UTF-8") : (var)
        end
        
        attr_reader :function
        
        def function(arglist)
          var = var ? (with_leading_slash(var)) : (without_leading_slash(var))
          var ? (with_trailling_slash(var)) : (without_trailling_slash(var));Fi[	@ˆijI"®      @var.del(@var)
      @var.srem(:queues, @var)
      @var = true
    end
    
    attr_reader :function
    
    def function(arglist)
      @var.dump(var)
    end;Fi[	@ı
i|I"Œ      
      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.after_suite_parts
      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end;Fi[@'@(@)@	I"private;Fi$[$[	@wi#I"ª            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      
      private
      
      def function(arglist);Fi[	@#i8I"            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private
      
      # The reason that the save param for replace is false, if for create (not just build),;Fi[	@ßi0I"$          var = (Time.now - @var)
          connections.dup.each do |arglist|
            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      
      # Acquire a connection by one of 1) immediately removing one;Fi[	@ãi|I"∑              end
            else
              var
            end
          end
        end
        
        private
        
        HstorePair = (var = /"[^"\\]*(?:\\.[^"\\]*)*"/;Fi[	@⁄iLI"›          var = var.where(table[primary_key].gt(var)).to_a
        else
          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@[i.I"Ê          @var.compressor.compress_with do |arglist|
            run("#{command} -c #{backup_file} > #{(backup_file + ext)}")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##;Fi[	@SiwI"¬            end
          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist);Fi[	@jiGI"Ì        else
          if File.directory?(project_directory).! then
            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      
      def function(arglist);Fi[	@ìi0I"}        end
      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ñiKI"Ñ            exit(1)
          end
          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@óiçI"        FileUtils.mkdir_p(@var.dotcucumber) if File.directory?(@var.dotcucumber).!
        File.open(File.join(@var.dotcucumber, "stepdefs.json"), "w") do |arglist|
          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    
    #:nodoc;Fi[	@Ìi¶I"Ø      else
        flash[:error] = I18n.t("tags.show.none", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@Ûi8I"Å        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ˇiAI"ı        var.html { |arglist| redirect_to(:back) }
        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@i+I"ÿ        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@i I"[    include_analytics("chartbeat") do |arglist|
      javascript_tag do |arglist|
        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@iQI"’        aspects.detect { |arglist| (var.id == var.id) }
      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@©iI"„      if var.children.empty? and var.skip_clean?(var).! then
        puts("rmdir: #{d} (empty)") if ARGV.verbose?
        var.rmdir
      end
    end
  end
  
  private
  
  # Set permissions for executables and non-executables;Fi[	@7ixI"∂        var.children.each { |arglist| puts("#{keg} (#{keg.abv})") }
      else
        raise("No such formula or keg")
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ i"I"·      end
      print("Linking #{keg}... ") do |arglist|
        puts("#{keg.link(mode)} symlinks created")
      end
    end
  end
  
  private
  
  # Allows us to ensure a puts happens before the block exits so that if say,;Fi[	@:iI"ñ        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@Gi~I"»      if FileTest.directory?(var) and (File.basename(var) == "CVS") then
        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ iI"™            end
          end
        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/;Fi[	@Xi¶I"ß        detect_from_symbol
      else
        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@[i/I"ë          (var.pages << var)
        else
          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@·i&I"6        var[:name] = truncate_post_name(var[:name]) if (var[:name].size > 255)
        File.open("_posts/tumblr/#{post[:name]}", "w") do |arglist|
          var.puts(((var[:header].to_yaml + "---\n") + var[:content]))
        end
      end
    end
    
    private
    
    def self.truncate_post_name(arglist);Fi[	@Ñi6I"˘            Matchers::And.new(var, var)
          else
            Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      
      # Extract the attribute from the key, being smarter about dot notation.;Fi[	@˘i!I"Ô            end
          else
            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      
      # Returns true if the relation is blank or the foreign key is blank.;Fi[	@¸i,I"À            validate_embedded(var, var, var)
          else
            validate_root(var, var, var)
          end
        end
      end
      
      private
      
      # Add the error to the document.;Fi[	@¿iRI"¿          end
        else
          Dir.glob("#{path}/#{dir}/*").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    
    def self.scan_themes(arglist);Fi[	@"iXI"•          define_method(var) do |arglist|
            var.call(*var)
            self
          end
        end
      end
      
      private
      
      # :nodoc:;Fi[@¨@
I"@var = var;FI"end;FI" ;Fi$[$[	@6iDI"‚        
        class Array < Type
          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            if String.===(var) then;Fi[	@–iI"¬        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	@g	iI"Ë      ACCESS_DENIED_ERROR = 1045
      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin;Fi[	@l	iI"      DEFAULT_ENCODING = (ENV["CHARSET"] or "utf8")
      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin;Fi[	@!iAI"ë        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@,iI"√      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	@3iäI"‰        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        
        # Returns true if one or more steps failed
        def function(arglist);Fi[	@¢irI"°        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@•i0I"®        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@biI"≈      
      class StepInvoker
        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing;Fi[	@eiI"∂      end
      
      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = WirePacket.new(var, var);Fi[	@1iI"|class Caveats
  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = [];Fi[	@iI"…    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["RACK_ENV"].to_s == "development");Fi[	@ti
I"ƒ    EMPTY_TYPE = "inode/x-empty"
    
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      (if blank? then;Fi[	@wiI"›module Paperclip
  class FileCommandContentTypeDetector
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      type_from_file_command;Fi[	@ÄiI"œmodule Paperclip
  class GeometryParser
    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      if match then;Fi[	@¸iI"∆    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log];Fi[	@üi2I"ã    def self.[](arglist)
      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@.iàI"ú    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.iåI"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.ißI"∞      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.i´I"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.iØI"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.i≥I"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.i∑I"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.iªI"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@.iøI"ô  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("FPDF error: " + var));Fi[	@œiI"∫  module Matchers
    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@⁄i	I"¬  module Matchers
    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@≤iVI"∞      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then;Fi[	@ÀiI"¸          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["#{@example_group.description} #{example.description}", var, var.location]);Fi[I"	else;FI"# do nothing;FI"end;FI"end;FI" ;Fi#[#[	@iQI"«            end
            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      
      protected
      ;Fi[	@}i$I"€            resolve_string_connection(config.to_s)
          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@≤iÔI"f        (method(var).arity == 0) ? (send(var)) : (send(var, var))
      when Proc then
        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      raise(RecordNotFound, "Couldn't find #{self.class.reflect_on_association(association_name).klass.name} with ID=#{record_id} for #{self.class.name} with ID=#{id}");Fi[	@”iBI"»          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic);Fi[	@ÁiﬂI"≥        (var.to_sql == to_sql)
      when Array then
        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      var.pp(self.to_a);Ti[	@Ÿi I"Á            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|;Fi[	@pi°I"    case var
    when Net::HTTP::Delete, Net::HTTP::Get, Net::HTTP::Head, Net::HTTP::Options, Net::HTTP::Put, Net::HTTP::Trace then
      true
    else
      # do nothing
    end
  end
  
  ##
  # Is the request idempotent or is retry_change_requests allowed;Fi[	@µiSI"›            "#{(variable(:scm_password) or variable(:password))}\n"
          when /\(yes\/no\)/ then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@ΩiçI"∫            "#{pass}\n"
          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@¿iII"Æ            "#{pass}\n"
          when /yes\/no/i then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@∆iKI"'            raise(Capistrano::Error, "p4port is incorrect or unset")
          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@ÀiVI"'            raise(Capistrano::Error, "subversion can't update because directory '#{$1}' was replaced. Please add it to svn:ignore.")
          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@◊i€I"'            source.checkout(revision, destination)
          when :export then
            source.export(revision, destination)
          else
            # do nothing
          end
        end
        
        # Returns the name of the file that the source code will be
        # compressed to.;Fi[	@<i%I"€        case var
        when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "img_#{@img_id}";Fi[	I"-data//diaspora_proj/models/invitation.rb;Ti_I"¥      self.identifier
    when "facebook" then
      I18n.t("invitations.a_facebook_user")
    else
      # do nothing
    end
  end
  
  # @return [String]
  def function(arglist);Fi[	@ÃikI"ï      self.identifier
    when "facebook" then
      false
    else
      # do nothing
    end
  end
  
  # @note before_save
  def function(arglist);Fi[	I"'data//homebrew_proj/cmd/install.rb;Ti"I"l    case Hardware.cpu_type
    when :ppc, :dunno then
      abort("        Sorry, Homebrew does not support your computer's CPU architecture.\n        For PPC support, see: https://github.com/mistydemeo/tigerbrew\n".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    if HOMEBREW_CELLAR.exist? and HOMEBREW_CELLAR.writable_real?.! then;Fi[	I"%data//homebrew_proj/compilers.rb;Ti;I"¡      MacOS.llvm_build_version.to_i
    when :gcc then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist)
    (@var.to_sym == var.to_sym);Fi[	@GiI"∏    when Hash then
      @var = @var.keys.first
      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var.each_with_index do |arglist|;Fi[	@Gi~I"◊      raise("Empty archive")
    when 1 then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var = /https?:\/\/(www\.)?github\.com\/.*\/(zip|tar)ball\//;Fi[	@UiYI"•    when :bzip2 then
      @var = (@var + ".bz2")
      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    @var.nil?.!;Fi[	I"(data//homebrew_proj/requirements.rb;Ti(I"      ["/usr/bin/env", "ruby", "-rubygems", "-e", "require '#{@import_name}'"]
    when :rbx then
      ["/usr/bin/env", "rbx", "-rubygems", "-e", "require '#{@import_name}'"]
    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var;Fi[	@1i¶I"ã        var = (var + var)
      end
      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #
  	# Calculate closing tags.;Fi[	@1i∂I"∞      @var[@var] = @var if (@var[@var] < @var)
      @var = (@var + 1)
      @var.push([])
    else
      # do nothing
    end
  end
  
  #
  	# Convert to accessible file path;Fi[	@1iëI"°      SetFontSize((@var + var))
      SetStyle("b", true)
      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #
  	# Process closing tags.;Fi[	@1i>I"ë        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.;Fi[	@Oi‹I"Î        case var[:format]
        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format];Fi[	@OiÔI"˛        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Project) and (var.start_date and var.due_date) then;Fi[	@OiI"        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Version) and (var.due_date and var.start_date) then;Fi[	@≤i5I"û          1
        when :twice then
          2
        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0;Fi[@z@{I" ;FI"private;FI" ;Fi![![	@1i7I"õ          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send)
    ;Fi[	@ÑiI"1          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size;Fi[	@ái:I"–        end
        save_through_record(var)
        update_counter(1)
        var
      end
      
      private
      
      def function(arglist)
        @var ||= owner.association(through_reflection.name);Fi[	@ói"I"Ù        var = build_record(var)
        yield(var) if block_given?
        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist)
        scope.scope_for_create.stringify_keys.except(klass.primary_key);Fi[	@tiI"ç        chain[(1..-1)].each do |arglist|
          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      
      # Construct attributes for :through pointing to owner and associate. This is used by the
      # methods which create and delete records on the association.;Fi[	I":data//activerecord_proj/active_record/associations.rb;Ti™I"        var = var.association_class.new(self, var)
        association_instance_set(var, var)
      end
      var
    end
    
    private
    
    # Returns the specified association instance if it responds to :loaded?, nil otherwise.
    def function(arglist);Fi[	@¨iI";        var[:null] = null unless null.nil?
        var[:default] = default unless default.nil?
        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist)
        base.add_column_options!(var, var.merge(:column => (self)));Fi[	@…iƒI"ú        end
        var
      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key);Fi[	@Øi!I"      # attributes when they are initialized. (e.g. attribute
      # serialization)
      def function(arglist)
        var
      end
      
      private
      
      # Guesses the table name, but does not decorate it with prefix and suffix information.
      def function(arglist);Fi[	@≈i¨I"‚      var.distinct(uniq_value)
      var.from(build_from) if from_value
      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist)
      var = var.reject { |arglist| var.blank? };Fi[	@ÌiI"â      header(var)
      tables(var)
      trailer(var)
      var
    end
    
    private
    
    def function(arglist)
      @var = var;Fi[	@$i%I"⁄      ((var << read_file("Gemfile")) << "\n")
      ((var << "\n\n") << "Gemfile.lock\n")
      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist)
      begin;Fi[	@riUI"‰          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class;Fi[	@ßi^I"∂      def function(arglist)
        var = @var.dup
        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin;Fi[	@—iBI"I            var = Benchmark.realtime { |arglist| var = super }
          end
          logger.trace("command finished in #{(elapsed * 1000).round}ms")
          var
        end
        
        private
        
        def function(arglist)
          @var ||= (configuration.logger or Capistrano::Logger.new(:output => (STDOUT)));Fi[	@6iïI"‚        Cucumber::Term::ANSIColor.coloring = var
        var.rewind
        var = (("\n" + var.read) + (" " * (var[:indent] - 2)))
        var
      end
      
      private
      
      TO_S_PREFIXES = Hash.new("    ")
      ;Fi[	@iOI"ñ    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch;Fi[	@@iaI"ë        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp;Fi[	@1iàI"·        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|;Fi[	@6iìI"ç          end
        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.
    #;Fi[	@PièI"      def function(arglist)
        var = Criteria.new((delete(:klass) or delete("klass")))
        each_pair { |arglist| var = var.__send__(var, var) }
        var
      end
      
      private
      
      # Mongoize for the klass, key and value.
      #;Fi[	@ôiUI"ﬁ        def function(arglist)
          var = yield(document)
          Threaded.clear_options!
          var
        end
        
        private
        
        # In case we need to cast going to the database.
        #;Fi[	I"4data//mongoid_proj/lib/mongoid/serialization.rb;Ti%I"˜        without_autobuild { |arglist| serialize_attribute(var, var, var, var) }
      end
      serialize_relations(var, var) if var[:include]
      var
    end
    
    private
    
    # Get the names of all fields that will be serialized.
    #;Fi[	@biáI"I    var.gsub!(/x%x%/, "&#38;")
    clean_html(var) if filter_html
    var.strip!
    var
  end
  
  private
  
  TEXTILE_TAGS = [[128, 8364], [129, 0], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [141, 0], [142, 0], [143, 0], [144, 0], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [157, 0], [158, 0], [159, 376]].collect! do |arglist|
    [var.chr, ((var.zero? and "") or "&#{b};")];Fi[	@µiHI"Ô        end
        var.sort! { |arglist| (var.event_datetime <=> var.event_datetime) }
        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist)
        @@var[var];Fi[	@ei[I"©          end
          var = [var.strip, var.strip, var.strip]
          var.each { |arglist| smooth_offtags_without_code_highlighting(var) }
          var
        end
        
        private
        
        # Patch for RedCloth.  Fixed in RedCloth r128 but _why hasn't released it yet.
        # <a href="http://code.whytheluckystiff.net/redcloth/changeset/128">http://code.whytheluckystiff.net/redcloth/changeset/128</a>;Fi[	@˛iI"•          false
        end
      end)
      var
    end
    
    private
    
    def function(arglist)
      var and var[:on] ? ([fetch(var.delete(:on))]) : (self);Fi[	I"?data//state_machine_proj/state_machine/state_collection.rb;TigI"—      var = (var + keys(:name))
      var.uniq!
      var.map! { |arglist| self[var] }
      var
    end
    
    private
    
    # Gets the value for the given attribute on the node
    def function(arglist);Fi[@'@(@I"protected;FI" ;Fi![![	@iÜI"ﬁ        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var);Fi[	I"Adata//activemodel_proj/active_model/validations/callbacks.rb;TiVI"'            var[:if].unshift("#{options[:on]}.include? self.validation_context")
          end
          set_callback(:validation, :after, *(var << var), &var)
        end
      end
      
      protected
      
      # Overwrite run validations to include callbacks.
      def function(arglist);Fi[	@	i0I"‘              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      
      def function(arglist)
        case var;Fi[	@iSI"í          end
        else
          # do nothing
        end
      end
      
      protected
      
      def function(arglist)
        var = [];Fi[	@Ωi)I"¿            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then;Fi[	@U	iÆI"ø        connection.select_value(var, "#{name} Exists", var.bind_values))
      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist)
      begin;Fi[	@÷iI"—        end
        self.stored_attributes[var] ||= []
        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist)
      var = initialize_store_attribute(var);Fi[	@ıiI"N          var = options.except(:case_sensitive, :scope, :conditions)
          var[:value] = var
          var.errors.add(var, :taken, var)
        end
      end
      
      protected
      
      # The check for an existing value should be run from a class that
      # isn't abstract. This means working down from the current class;Fi[	I"6data//bundler_proj/bundler/similarity_detector.rb;TiI"        var[0]
      else
        [var[(0..-2)].join(", "), var[-1]].join(" or ") if (var.length > 1)
      end
    end
    
    protected
    
    # http://www.informit.com/articles/article.aspx?p=683059&seqNum=36
    def function(arglist);Fi[	@Ñ	i,I"¢        default.empty?.!
      else
        default
      end
    end
    
    protected
    
    def function(arglist)
      if required? and default.nil?.! then;Fi[	@]i|I"      var = @var.select { |arglist| var =~ /^--?(?:(?!--).)*$/ }
      unless var.empty? then
        raise(UnknownArgumentError, "Unknown switches '#{unknown.join(", ")}'")
      end
    end
    
    protected
    
    # Check if the current value in peek is a registered switch.
    #;Fi[	@`igI",          var = self.class.const_get(var.to_s.upcase) if var.is_a?(Symbol)
          var = var ? (BOLD) : ("")
          "#{bold}#{foreground}#{string}#{CLEAR}"
        end
      end
      
      protected
      
      # Overwrite show_diff to show diff with colors if Diff::LCS is
      # available.;Fi[	I"4data//bundler_proj/bundler/vendor/thor/shell.rb;TiLI"ö        yield)
      ensure
        shell.padding -= 1
      end
    end
    
    protected
    
    # Allow shell to be shared between invocations.
    #;Fi[	@PiKI"Ï            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then;Fi[	@∞	i?I"ò          var = var.select { |arglist| var.all? { |arglist| (var.options[var] == var) } }
          var = var.reject { |arglist| var.any? { |arglist| (var.options[var] == var) } }
          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist)
        return var unless (ENV["HOSTFILTER"] or ENV["HOSTROLEFILTER"]);Fi[	@—i"I"r            var.remote.directory(configuration[:releases_path]).or("`#{configuration[:releases_path]}' does not exist. Please run `cap deploy:setup'.")
            var.remote.writable(configuration[:deploy_to]).or("You do not have permissions to write to `#{configuration[:deploy_to]}'.")
            var.remote.writable(configuration[:releases_path]).or("You do not have permissions to write to `#{configuration[:releases_path]}'.")
          end
        end
        
        protected
        
        # This is to allow helper methods like "run" and "put" to be more
        # easily accessible to strategy implementations.;Fi[	@JiI"Ø          ::Compass::Exec::Helpers.report_error(var, (@var or {}))
        end
        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin;Fi[	@Ri]I"Ü      else
        var
      end
    end
  end
  
  protected
  
  def function(arglist)
    unless var.is_a?(Sass::Script::List) then;Fi[	@ii`I"ª          else
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts);Fi[	I"3data//devise_proj/devise/models/validatable.rb;TiI"œ        var = VALIDATIONS.select { |arglist| var.respond_to?(var).! }
        unless var.empty? then
          raise(("Could not use :validatable module since #{base} does not respond " << "to the following methods: #{unavailable_validations.to_sentence}."))
        end
      end
      
      protected
      
      # Checks whether a password is needed or not. For validations only.
      # Passwords are always required if it's a new record, or if the password;Fi[	@Åi&I"€          attribute.any? { |arglist| var.===(var) }
        else
          var.===(attribute)
        end
      end
      
      protected
      
      # Convenience method for getting the first value in a hash.
      #;Fi[	@áiEI"≠        super(var, var, var)
      else
        super
      end
    end
    
    protected
    
    def function(arglist)
      return nil if var.all? { |arglist| var.nil? };Fi[	@ØiI"y      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist)
        var =~ /(^#{example_group_regex} #{example_regexp}$|^#{example_group_regex}$|^#{example_group_with_before_all_regexp}$|^#{example_regexp}$)/;Fi[	I"5data//state_machine_proj/state_machine/branch.rb;TiçI"*          (var << var.add_edge(var, (var ? (var) : (var)), :label => (var.to_s)))
        end
        var
      end
    end
    
    protected
    
    # Builds a matcher strategy to use for the given options.  If neither a
    # whitelist nor a blacklist option is specified, then an AllMatcher is;Fi[	I"Ddata//state_machine_proj/state_machine/transition_collection.rb;TiGI"É        results[actions.first]
      else
        success?
      end
    end
    
    protected
    
    attr_reader(:results)
    ;Fi[	@≈i-I"Ã          puts("## [message] Run `whenever --help' for more options.")
          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file]);Fi[	@i6I"Ó          parse_as_string
        else
          parse_time
        end
      end
      
      protected
      
      def function(arglist)
        var = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];Fi[	@ÃiI"∂          ">> /dev/null 2>&1"
        else
          ""
        end
      end
      
      protected
      
      def function(arglist)
        return unless @var.has_key?(:standard);Fi[@©I"
super;FI"end;FI"end;FI" ;Fi![![	@zijI"P        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist)
          self.class.serialized_attributes.include?(var) ? (var.!=(var)) : (super);Fi[	@zivI"
        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist)
          super.dup.tap do |arglist|;Fi[	@¢i)I"R          if create_time_zone_conversion_attribute?(var, columns_hash[var]) then
            var, var = "              def #{attr_name}=(original_time)\n                original_time = nil if original_time.blank?\n                time = original_time\n                unless time.acts_like?(:time)\n                  time = time.is_a?(String) ? Time.zone.parse(time) : time.to_time rescue time\n                end\n                zoned_time   = time && time.in_time_zone rescue nil\n                rounded_time = round_usec(zoned_time)\n                rounded_value = round_usec(read_attribute(\"#{attr_name}\"))\n                if (rounded_value != rounded_time) || (!rounded_value && original_time)\n                  write_attribute(\"#{attr_name}\", original_time)\n                  #{attr_name}_will_change!\n                  @attributes_cache[\"#{attr_name}\"] = zoned_time\n                end\n              end\n", (52 + 1)
            generated_attribute_methods.module_eval(var, "(string)", var)
          else
            super
          end
        end
        
        private
        ;Fi[	@∂i=I"∏            :integer
          when /bit/i then
            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var;Fi[	@∂i[I"N            1
          when /^enum\((.+)\)/i then
            $1.split(",").map { |arglist| (var.strip.length - 2) }.max
          else
            super
          end
        end
        
        # MySQL misreports NOT NULL column default when none is given.
        # We can't detect this for columns which may have a legitimate '';Fi[	@∂iI"·          else
            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      
      def function(arglist)
        if var[:first] then;Fi[	@∂ieI"@          RecordNotUnique.new(var, var)
        when 1452 then
          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}";Fi[	@ãiI"‰            (-1.0 / 0.0)
          when / BC$/ then
            super(("-" + var.sub(/ BC$/, "")))
          else
            super
          end
        end
        
        def function(arglist)
          if Hash.===(var) then;Fi[	@ìiQI"¬            else
              super
            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var;Fi[	@ùiNI"I            else
              raise(ActiveRecordError, "No range type has byte size #{limit}. Use a numeric with precision 0 instead.")
            end
          else
            super
          end
        end
        
        # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.
        #;Fi[	@£i∆I"?        if var.kind_of?(String) and (var and ((var.type == :binary) and var.class.respond_to?(:string_to_binary))) then
          var = var.class.string_to_binary(var).unpack("H*")[0]
          "x'#{s}'"
        else
          super
        end
      end
      
      def function(arglist)
        @var.class.quote(var);Fi[	@£iÿI"˚      def function(arglist)
        if var.respond_to?(:usec) then
          "#{super}.#{sprintf("%06d", value.usec)}"
        else
          super
        end
      end
      
      def function(arglist)
        return var.to_f if BigDecimal.===(var);Fi[	@L	i|I"/      def function(arglist)
        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column);Fi[	@∫iI"€          var = ActiveRecord::LogSubscriber.reset_runtime
          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super;Fi[	@i6I"Ã        else
          puts(File.read("#{root}/#{command}.txt"))
        end
      else
        super
      end
    end
    
    desc("init", "Generates a Gemfile into the current working directory")
    ;Fi[	I"5data//bundler_proj/bundler/vendor/thor/runner.rb;TiI"v      var, var = Thor::Util.find_class_and_task_by_namespace(var)
      self.class.handle_no_task_error(var, false) if var.nil?
      var.start(["-h", var].compact, :shell => (self.shell))
    else
      super
    end
  end
  
  # If a task is not found on Thor::Runner, method missing is invoked and
  # Thor::Runner is then responsible for finding the task in all classes.;Fi[	@`itI"          var = File.binread(var).to_s.split("\n")
          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action;Fi[	@cibI"          var = File.binread(var).to_s.split("\n")
          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action;Fi[	@—i,I",        def function(arglist)
          if configuration.respond_to?(var) then
            configuration.send(var, *var, &var)
          else
            super
          end
        end
        
        # A wrapper for Kernel#system that logs the command being executed.
        def function(arglist);Fi[	@riûI"7    def function(arglist)
      if ["owg", "svg"].include?(var) and (position_or_angle.is_a?(Sass::Script::Number) and position_or_angle.numerator_units.include?("deg")) then
        false
      else
        super
      end
    end
    
    # Output the original webkit gradient syntax
    def function(arglist);Fi[	@áiCI"Ú          raise(Errors::MultiparameterAssignmentErrors.new(var), "#{errors.size} error(s) on assignment of multiparameter attributes")
        end
        super(var, var, var)
      else
        super
      end
    end
    
    protected
    ;Fi[	@ii…I"Ï        if var.is_a?(XML::NodeSet) then
          raise("Document cannot have multiple root nodes") if (var.size > 1)
          super(var.first)
        else
          super
        end
      end
      
      alias :<< :add_child
      ;Fi[	@]iI"5        def function(arglist)
          if (var.size == 1) and var.first.is_a?(::Time) then
            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var);Fi[	I"Hdata//state_machine_proj/state_machine/integrations/active_model.rb;Ti≥I"2          @var[((var == :around) ? (:before) : (var))].insert(-2, (var = Callback.new(var, var, &var)))
          add_states(var.known_states)
          var
        else
          super
        end
      end
      
      # Configures new states with the built-in humanize scheme
      def function(arglist);Fi[	I"Idata//state_machine_proj/state_machine/integrations/active_record.rb;Ti>I"!      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	I"Hdata//state_machine_proj/state_machine/integrations/mongo_mapper.rb;Ti7I"!      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	I"Cdata//state_machine_proj/state_machine/integrations/mongoid.rb;Ti;I"!      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	@iiÀI"        if skip_after and success? then
          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    
    # Tracks that before callbacks have now completed
    def function(arglist);Fi[@'@T@;I"	true;FI"end;Fi[[	@	iI"¨      var = super
      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	I"Wdata//activerecord_proj/active_record/associations/builder/singular_association.rb;Ti	I"Ì  class SingularAssociation < Association
    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@0	iI"º      
      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@0	ioI"Å      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end
    end
    ;Fi[	@∂iâI"      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.;Fi[	@∂iíI"
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax;Fi[	@Äi$I"‚        super
        @var = BindSubstitution.new(self)
        configure_connection
      end
      
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================;Fi[	@£iàI"û      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@£i¨I"ó      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:;Fi[	@>iI"    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@Ñi)I"±        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist);Fi[	I"9data//compass_proj/compass/configuration/defaults.rb;Ti&I"π      
      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@–iãI"ƒ      
      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@“	iI"ç    
    def function(arglist)
      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@ri@I"ú    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@6iI"Ø      class SurplusCell < Cell
        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end;Fi[	@úiI"¶      def function(arglist)
        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@vi$I"ö      
      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@]i)I"˝      # or confirmation are being set somewhere.
      def function(arglist)
        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@”i"I"ı        if var.respond_to?(:extend_remember_period=) then
          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	I"3data//diaspora_proj/models/account_deletion.rb;Ti+I"Ü  
  def function(arglist)
    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	I"(data//diaspora_proj/models/photo.rb;Ti~I"Œ  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  
  scope(:on_statuses, lambda { |arglist| where(:status_message_guid => (var)) });Fi[	@4iI"|  
  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist);Fi[	@íiI"    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@íiI"z    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end;Fi[	@	iI"√      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist);Fi[@z@{@|I" ;FI"def function(arglist);Fi[[	@qivI"f          unless var then
            raise(ActiveRecord::ConfigurationError, "Association named '#{association}' was not found; perhaps you misspelled it?")
          end
          var
        end
      end
      
      def function(arglist)
        if (var.macro == :belongs_to) and var.options[:polymorphic] then
          var = var.send(var.foreign_type);Fi[	@zicI"^            serialized_attributes.each do |arglist|
              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized);Fi[	@i.I"ı        (var = send(var, var)
        var.duplicable? ? (var.clone) : (var))
      rescue TypeError, NoMethodError
        var
      end
    end
    
    def function(arglist)
      arel_attributes_with_values(attributes_for_create(var))
    end;Fi[	@≥i=I"È          end
          var
        else
          var
        end
      end
      
      def function(arglist)
        if options_include_default?(var) then
          (var << " DEFAULT #{quote(options[:default], options[:column])}");Fi[	@ãiI"          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",")
          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil;Fi[	@ãiRI"-          if IPAddr.===(var) then
            "#{object.to_s}/#{object.instance_variable_get(:@mask_addr).to_s(2).count("1")}"
          else
            var
          end
        end
        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end;Fi[	@≈iﬁI"∑        var ||= "subquery"
        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist)
      var = var.group_by do |arglist|
        case var;Fi[	@-i¿I"'        var = Gem::SourceIndex.new
        var.spec_dirs = *var
        var.add_specs(*var)
        var
      end
    end
    
    def function(arglist)
      Gem::SourceIndex.send(:alias_method, :old_initialize, :initialize)
      Gem::SourceIndex.send(:define_method, :initialize) do |arglist|;Fi[	@]iAI"ë        @var = false
        super
      else
        var
      end
    end
    
    def function(arglist)
      @var = var.dup
      @var = true;Fi[	@∞	iaI"!        var = build_list(var)
        var.map do |arglist|
          var = String.===(var) ? (var.strip.to_sym) : (var)
          var
        end
      end
      
      def function(arglist)
        Array(var).map { |arglist| var.respond_to?(:call) ? (var.call) : (var) }.flatten
      end;Fi[	@ji]I"ﬂ            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end;Fi[	@UiÀI"Á    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then
      missing_sprite!(var);Fi[	@ÉioI"≈      def function(arglist)
        var.inject({}) do |arglist|
          var[delimited(var)] = var
          var
        end
      end
      
      def function(arglist)
        "<#{s}>"
      end;Fi[	@ãi∂I"ﬁ      
      class LogFormatter < ::Logger::Formatter
        def function(arglist)
          var
        end
      end
      
      def function(arglist)
        @var[:env_vars].each { |arglist| ENV[var] = var }
      end;Fi[	@´i)I"        var.step_definitions.inject({}) do |arglist|
          var[var.file] ||= []
          (var[var.file] << [var.file_colon_line, var.regexp_source])
          var
        end
      end
      
      def function(arglist)
        (var.map { |arglist| var.size }.max + 1)
      end;Fi[	I"-data//devise_proj/devise/test_helpers.rb;TiOI"…      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist)
      var[:action] ||= :unauthenticated
      var = var["warden"];Fi[	@iêI"d      end
      Tempfile.send(:define_method, "content_type") { |arglist| return var }
      Tempfile.send(:define_method, "original_filename") { |arglist| return var }
      var
    end
  end
  
  def function(arglist)
    if (params[:photo][:aspect_ids] == "all") then
      params[:photo][:aspect_ids] = current_user.aspects.collect { |arglist| var.id };Fi[	@i¥I"Ã      var = profile.first_name.to_s.split(/\s/)
      var = var[(0...-1)].join(" ")
      var = var[0] if var.blank?
      var
    end
  end
  
  def function(arglist)
    (self.id == var.author_id)
  end;Fi[	@XiI"¥    when /\d+/ then
      var.to_i
    else
      var
    end
  end
  
  def function(arglist)
    return unless var.is_a?(VersionElement)
    return -1 if string? and var.numeric?;Fi[	@`i'I"˜      def function(arglist)
        send(var).inject({}) do |arglist|
          var[var] = var
          var
        end
      end
      
      def function(arglist)
        var = var.new(klass.aliased_fields, klass.fields)
        var.merge!(var);Fi[	@µ
i)I"        var = var.match(/\?.+=/) ? ("&") : ("?")
        "#{url}#{delimiter_char}#{@attachment.updated_at.to_s}"
      else
        var
      end
    end
    
    def function(arglist)
      @var.respond_to?(:updated_at) and @var.updated_at.present?
    end;Fi[	@ói7I"À        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist)
        var = I18n.translate(:"number.human.storage_units.format", :locale => (options[:locale]), :raise => (true))
        var = I18n.translate(:"number.human.storage_units.units.byte", :locale => (options[:locale]), :count => (var.to_i), :raise => (true));Fi[	@iPI"+              var ||= custom_values.build(:customized => (self), :custom_field => (var), :value => (nil))
              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist)
          custom_field_values.select(&:visible?)
        end;Fi[	@ÆiI"µ      
      def function(arglist)
        var = var.dup
        var
      end
    end
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!(var);Fi[	@bi≤I"ì      else
        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist)
    (@var << var)
    " :redsh##{@shelf.length}:";Fi[	I"5data//rspec_proj/spec/example/example_methods.rb;TiaI"<      def function(arglist)
        instance_variables.inject({}) do |arglist|
          var[var] = instance_variable_get(var)
          var
        end
      end
      
      def function(arglist)
        var.each do |arglist|
          unless ["@_proxy", "@_implementation", "@method_name"].include?(var.to_s) then;Fi[I"@var = var;FI"@var = var;FI"end;FI" ;FI"def function(arglist);Fi[[	@wiI"î      # table_joins is an array of arel joins which might conflict with the aliases we assign here
      def function(arglist)
        @var = Hash.new { |arglist| var[var] = initial_count_for(var) }
        @var = var
        @var = var
      end
      
      def function(arglist)
        var = aliased_name_for(var, var)
        (var == var) ? (Arel::Table.new(var)) : (Arel::Table.new(var).alias(var));Fi[	@öijI"      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?
        @var = (object.class.reflect_on_aggregation(name.to_sym) or object.column_for_attribute(name));Fi[	@ßi|I"ˇ        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency
          Thread.new(frequency, pool) do |arglist|;Fi[	@}iI"Á        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config
          when nil then;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/statement_pool.rb;TiI"º      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@…i˚I"Ω    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class
    end;Fi[	@¬iI"·      
      def function(arglist)
        var.assert_valid_keys(*Relation::VALUE_METHODS)
        @var = var
        @var = var
      end
      
      def function(arglist)
        Merger.new(relation, other).merge
      end;Fi[	I"@data//cancan_proj/cancan/model_adapters/abstract_adapter.rb;Ti*I"Ú      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "This model adapter does not support fetching records from the database.")
      end;Fi[	@Ñi>I"Ï          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server)
          end;Fi[	@™iuI"Õ          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "highest")
          end;Fi[	@œ	iI"      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)))
      end;Fi[	@6iCI"∑        var = var.transpose
        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        dup
      end;Fi[	I"Hdata//cucumber_prok/cucumber/formatter/gherkin_formatter_adapter.rb;TiI"Í  module Formatter
    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.uri(var.file)
        @var.feature(var.gherkin_statement);Fi[	I".data//cucumber_prok/cucumber/rake/task.rb;Ti.I"‡          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("\"%s\"" % @var.join(File::PATH_SEPARATOR))]
        end;Fi[	I"7data//cucumber_prok/cucumber/rb_support/rb_hook.rb;TiI"Ï      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var)
      end;Fi[	I"=data//diaspora_proj/presenters/extreme_post_presenter.rb;TiI"Ãclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = PostPresenter.new(@var, @var)
    var = PostInteractionPresenter.new(@var, @var);Fi[	I"8data//diaspora_proj/presenters/o_embed_presenter.rb;TiI"£  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json
  end;Fi[	@ziI"class PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile))
    if (is_own_profile or person_is_following_current_user) then;Fi[	@}iEI"Yend
class PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    { :likes => (as_api(@var.likes)), :reshares => (PostPresenter.collection_json(@var.reshares, @var)), :comments => (CommentPresenter.as_collection(@var.comments)), :participations => (as_api(@var.participations)) }
  end;Fi[	@›iûI"B  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "#{@name.downcase} cannot be installed alongside #{@formula}.\n"
    (var << "This is because #{@opts[:because]}\n") if @var[:because];Fi[	@ŒiÇI"ø      
      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end;Fi[	@õiI"ì    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@µ
i	I"module Paperclip
  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var)
    end;Fi[	@Øi	I"  module Example
    class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var));Fi[	@œidI"”    class BePredicate < Be
      def function(arglist)
        @var = parse_expected(var.shift)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var = var
        begin;Fi[	@„iI"¬      
      def function(arglist)
        @var = (var[:__declared_as] or "Mock")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end;Fi[@'@œ@–I"end;FI"end;Fi[[	@RilI"ˇ          var.includes!((var[:includes] or var[:includes]))
          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@ni2I"Õ            end
            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@}iJI"ÿ          if var.query then
            var = Hash[var.query.split("&").map { |arglist| var.split("=") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	@£i I"˙        def function(arglist)
          if var.encoding.!=(Encoding::ASCII_8BIT) then
            var = var.force_encoding(Encoding::ASCII_8BIT)
          end
          var
        end
      end
    end
    
    class SQLite3Adapter < AbstractAdapter;Fi[	@g	iáI"¥        end
        configuration.slice("host", "port", "socket").each do |arglist|
          var.concat(["--#{k}", var]) if var
        end
        var
      end
    end
  end
end;Fi[	@'inI"∞              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@ä	iNI"≠          unless var then
            say("Your response must be one of: [#{answers}]. Please try again.")
          end)
        end
        var
      end
    end
  end
end;Fi[	@Si¥I"¯        var = []
        var.each do |arglist|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end
ActiveRecord::Base.class_eval { |arglist| include(CanCan::ModelAdditions) };Fi[	@ùi"I"È        end
        var.each do |arglist|
          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end
DataMapper::Model.append_extensions(CanCan::ModelAdditions::ClassMethods);Fi[	@åi-I"            else
              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	@	iŒI"F              (var << { :raw => (var.send("raw_#{prop}") rescue nil), :value => (var.send("#{prop}_without_default") rescue nil), :default => (var.send("default_#{prop}") rescue nil), :resolved => (var.send(var)) })
            end
            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	@…	iÅI"Å            (var << "\n")
          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	@Éi|I"â        var.each do |arglist|
          var ||= ""
          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	@ikI"Ö        @var.status = var.first
        @var.headers = var.second
        @var.body = var.third
      end
      var
    end
  end
end;Fi[	@·i¢I"≠        FileUtils.mkdir_p("tumblr_files")
        File.open(var, "w") { |arglist| var.write(open(var).read) }
        var = ("/" + var)
      end
      var
    end
  end
end;Fi[	@0iI"™              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end;Fi[	@UiuI"ñ          end
        else
          raise(ScanError, (("undefined state: '" + state.to_s) + "'"))
        end
        var
      end
    end
  end
end;Fi[	@ÄiI"l        @var = var[2]
        @var = var[3]
        @var = var[4]
      end
      var
    end
  end
end;Fi[	@(i&I"ì                [yield(var), var.id]
              end
            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	@÷
i¶I"            var = var[var]
            if var.is_a?(Symbol) then
              var = resolve(var, var, var, var.merge(:scope => (nil)))
            end
            var
          end
        end
      end
      
      include(Implementation);Fi[	@WiI"«          if jsonp.present? then
            var = "#{jsonp}(#{json})"
            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end
end;Fi[	@eiqI"9              var = @var[$1.to_i]
              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end;Fi[	@i&I"              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@i"I"+          if ((var == :state) or ((var == :event) and var)) and var.send("#{self.attribute}_changed?").! then
            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[@@∞I"@var = var;FI"end;FI" ;Fi[[	@ßi{I"ﬂ      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency;Fi[	@¨iI"Ë    end
    
    class Table
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.;Fi[	@}iI"‰      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config;Fi[	@6i5I"´          # +delim+ corresponds to the `typdelim` column in the pg_types
          # table.  +subtype+ is derived from the `typelem` column in the
          # pg_types table.
          def function(arglist)
            @var = var
            @var = var
          end
          
          # FIXME: this should probably split on +delim+ and use +subtype+
          # to cast the values.  Unfortunately, the current Rails behavior;Fi[	@:i
I"     class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@…i˙I"∫    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class;Fi[	@±i	I"Õ  class Splitter
    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##
    # This is called as part of the procedure used to build the final;Fi[	@Ai)I"O        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "This model adapter does not support fetching records from the database.");Fi[	@™itI"Í            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "highest");Fi[	@œ	iI"(        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)));Fi[	@6i÷I"      #   table.hashes.keys
      #   # => ['phone number', 'ADDRESS']
      #
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Returns a new Table where the headers are redefined. See #map_headers!
      def function(arglist);Fi[	@Li
I"Œmodule Cucumber
  module Formatter
    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.uri(var.file);Fi[	@UiI"ôclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = PostPresenter.new(@var, @var);Fi[	@XiI"†  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json;Fi[	@ziI"¡class PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile));Fi[	@}i	I"’class PostPresenter
  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def self.collection_json(arglist)
    var.map { |arglist| PostPresenter.new(var, var) };Fi[	@}iDI"Y  end
end
class PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    { :likes => (as_api(@var.likes)), :reshares => (PostPresenter.collection_json(@var.reshares, @var)), :comments => (CommentPresenter.as_collection(@var.comments)), :participations => (as_api(@var.participations)) };Fi[	I"-data//nokogiri_proj/nokogiri/css/node.rb;TiI"˛      # Get the type of this node
      # Get the value of this node
      # Create a new Node with +type+ and +value+
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Accept +visitor+
      def function(arglist);Fi[	@ŒiÅI"Ω      end
      
      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var;Fi[	@µ
iI"require("uri")
module Paperclip
  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var);Fi[	@ØiI"¬module Spec
  module Example
    class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        var.any? do |arglist|;Fi[	@ÓiI"  module Spec
    module Runner
      class HeckleRunner
        def function(arglist)
          @var = var
          @var = var
        end
        
        # Runs all the example groups held by +rspec_options+ once for each of the
        # methods in the matched classes.;Fi[	I"<data//state_machine_proj/state_machine/helper_module.rb;TiI"Œmodule StateMachine
  class HelperModule < Module
    def function(arglist)
      @var = var
      @var = var
    end
    
    # Provides a human-readable description of the module
    def function(arglist);Fi[@I"	true;FI"end;FI" ;FI"def function(arglist);Fi[[	@	iI"º      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|
        if options.include?(var) then;Fi[	@ªiI"·      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super
      define_constructors if constructable?;Fi[	@0	iI"±        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end;Fi[	@∂iáI"∆      end
      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@∂iêI"∆      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@£iÜI"ì      end
      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@£ièI"ú      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var.!=(false)
      end;Fi[	@£i™I"í      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@>iI"y      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end;Fi[	@Ñi+I"∞          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect
        end;Fi[	@–i(I"        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var);Fi[	@–içI"π        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss
      end;Fi[	@“	iI"á      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value
    end;Fi[	@riBI"      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "deg") and var.denominator_units.empty?))
    end;Fi[	@úiI"º        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/
        print(var);Fi[	@vi&I"ì        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive
      end;Fi[	@”i$I"À        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "remember_#{scope}_token")
      end;Fi[	I"9data//diaspora_proj/models/activity_streams/photo.rb;TiI"  # A hack used in the stream_element partial to display cubbi.es posts correctly.
  # A better solution is needed.
  # @return [Boolean] true
  def function(arglist)
    true
  end
  
  def function(arglist)
    I18n.t("photos.comment_email_subject", :name => (author.name))
  end;Fi[	@4i!I"˛    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("Performing relayable retraction for #{target_guid}")
    if (self.parent_author_signature.nil?.! or self.parent.author.remote?) then;Fi[	I",data//haml_proj/haml/template/plugin.rb;TiI"c    # do. To avoid messy logic figuring this out, we just inherit from whatever
    # the ERB handler does.
    # In Rails 3.1+, we don't need to include Compilable.
    def function(arglist)
      true
    end
    
    def function(arglist)
      var = Haml::Template.options.dup
      if (ActionPack::VERSION::MAJOR >= 4) and var.respond_to?(:type) then;Fi[	I"4data//jekyll_proj/jekyll/converters/identity.rb;TiI"}    
    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end;Fi[	@íiI"{      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@	iI"¨          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "anything"
        end;Fi[I"# do nothing;FI"end;FI"end;FI"end;FI"end;Fi[[	@qiâI"}        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	@êiPI")              when /^-?\D+[\d.]+,\d{2}$/ then
                var.gsub!(/[^-\d,]/, "").sub!(/,/, ".")
              else
                # do nothing
              end
            end
          end
        end
        
        # Queries the database and returns the results in an Array-like object;Fi[	@¯iÀI"ì      when :update then
        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	@ÎicI"¶          begin
            var.mkdir(var.join("/"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@¸iUI"∞          begin
            var.mkdir!(var.join("/"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"6data//bundler_proj/bundler/vendor/thor/actions.rb;TiI"©        [:force, :skip, "force", "skip"].each { |arglist| var.delete(var) }
        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	@Ñ	iLI"o      when :array then
        "one two three"
      else
        # do nothing
      end
    end
  end
end;Fi[	@èiI"ä          when "a" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@∑	i¿I"g      when :scp then
        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	@?i?I"†            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"@data//diaspora_proj/controllers/conversations_controller.rb;TiTI"Ç      render(:layout => (true))
    else
      if render(:layout => (false)) then
        # do nothing
      end
    end
  end
end;Fi[	I"$data//homebrew_proj/cmd/edit.rb;Ti,I"u      when "LinkedKegs", "Aliases" then
        true
      else
        # do nothing
      end
    end
  end
end;Fi[	I"4data//jekyll_proj/jekyll/converters/markdown.rb;TitI"y      when "maruku" then
        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	I"?data//nokogiri_proj/nokogiri/xml/processing_instruction.rb;Ti	I"Ä  module XML
    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@‹imI"¬        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@ΩiII"”              (@var << "#{date_from.to_date}")
              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"-data//rescue_proj/resque/failure/base.rb;Ti8I"e      end
      
      def self.remove(arglist)
        # do nothing
      end
    end
  end
end;Fi[	I",data//rescue_proj/resque/multi_queue.rb;TiMI"f        end
      else
        Kernel.sleep(var)
        # do nothing
      end
    end
  end
end;Fi[	@»iêI"‘        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@ŒiI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@—iI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@⁄iI"z        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@2i*I"è              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[@¨@
I"	true;FI"end;FI" ;Fi[[	@	iI"Œ      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|;Fi[	@ªi
I"œ    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super;Fi[	@0	iI"√      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false;Fi[	@∂iäI"ÿ      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist);Fi[	@∂iìI"ˇ      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax
      # but at the moment (5.5) it doesn't yet implement them;Fi[	@Äi%I"        @var = BindSubstitution.new(self)
        configure_connection
      end
      
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================
      def function(arglist);Fi[	@£iâI"§      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@£i≠I"û      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:
      def function(arglist);Fi[	@>iI"Ü    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false;Fi[	@Ñi*I"¬        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect;Fi[	@–i'I"¸      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then;Fi[	@–iåI"À      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss;Fi[	@“	iI"ô    def function(arglist)
      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value;Fi[	@riAI"/    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "deg") and var.denominator_units.empty?));Fi[	@úiI"º        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/;Fi[	@vi%I"•      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive;Fi[	@]i*I"      def function(arglist)
        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length);Fi[	@”i#I"
          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "remember_#{scope}_token");Fi[	@ÊiI"œ  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  
  scope(:on_statuses, lambda { |arglist| where(:status_message_guid => (var)) })
end;Fi[	@4i I"∆  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("Performing relayable retraction for #{target_guid}");Fi[	@i
I"Ñ    safe(true)
    
    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var;Fi[	@íiI"ç    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing;Fi[	@	iI"æ        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "anything";Fi[@©I"var;FI"end;FI"end;FI" ;Fi[[	@)iI",        if var.respond_to?(:ast) then
          var = var.dup
          visitor.accept(var.ast) { |arglist| quote(*var.shift.reverse) }
        else
          var
        end
      end
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.;Fi[	@≥i<I"≠            end
          end
          var
        else
          var
        end
      end
      
      def function(arglist)
        if options_include_default?(var) then;Fi[	@ãiI"        def function(arglist)
          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",")
          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then;Fi[	@ãiQI"?        def function(arglist)
          if IPAddr.===(var) then
            "#{object.to_s}/#{object.instance_variable_get(:@mask_addr).to_s(2).count("1")}"
          else
            var
          end
        end
        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) };Fi[	@êiëI"              return var unless var
            end
            last_insert_id_result(var)
          else
            var
          end
        end
        
        # Executes an UPDATE query and returns the number of affected tuples.
        def function(arglist);Fi[	@≈i›I"ø      when Relation then
        var ||= "subquery"
        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist)
      var = var.group_by do |arglist|;Fi[	@^	i!I"Ï          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_conditions(var, var)
        else
          var
        end
      end
      
      alias_method(:sanitize_sql, :sanitize_sql_for_conditions)
      ;Fi[	@^	i1I"3          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_assignment(var)
        else
          var
        end
      end
      
      # Accepts a hash of SQL conditions and replaces those attributes
      # that correspond to a +composed_of+ relationship with their expanded;Fi[	@]i@I"ç        shift
        @var = false
        super
      else
        var
      end
    end
    
    def function(arglist)
      @var = var.dup;Fi[	@ji\I"‰          else
            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1));Fi[	@Ui I"
      Sass::Script::String.new(reversed_color_names[var.rgb])
    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then;Fi[	@iNI"ª        end
      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist)
      var[:action] ||= :unauthenticated;Fi[	I"-data//haml_proj/haml/helpers/xss_mods.rb;TirI"          var.map { |arglist| Haml::Util.html_safe(var) }
        when String then
          Haml::Util.html_safe(var)
        else
          var
        end
      end
      
      alias_method(:with_output_buffer_without_haml_xss, :with_output_buffer)
      ;Fi[	@XiI"ó      "beta"
    when /\d+/ then
      var.to_i
    else
      var
    end
  end
  
  def function(arglist)
    return unless var.is_a?(VersionElement);Fi[	@ixI"¸        end
        if var.nil? and (var.autobuilding? and without_autobuild?.!) then
          send("build_#{name}")
        else
          var
        end
      end
      
      # Is the current code executing without autobuild functionality?
      #;Fi[	@Éi±I"Â              var.merge!(var)
              Factory.build(klass, var, base.send(:mass_assignment_options))
            end
          else
            var
          end
        end
        
        # Get the atomic path.
        #;Fi[	@qiµI"     def function(arglist)
      if @var[:restricted_characters] then
        var.gsub(@var[:restricted_characters], "_")
      else
        var
      end
    end
    
    # Check if attachment database table has a created_at field
    def function(arglist);Fi[	@µ
i(I"/      if var[:timestamp] and timestamp_possible? then
        var = var.match(/\?.+=/) ? ("&") : ("?")
        "#{url}#{delimiter_char}#{@attachment.updated_at.to_s}"
      else
        var
      end
    end
    
    def function(arglist)
      @var.respond_to?(:updated_at) and @var.updated_at.present?;Fi[	@ói6I"Y      def function(arglist)
        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist)
        var = I18n.translate(:"number.human.storage_units.format", :locale => (options[:locale]), :raise => (true));Fi[	@üi"I"Ø      require("memcache")
      require("openid/store/memcache")
      OpenID::Store::Memcache.new(MemCache.new(var))
    else
      var
    end
  end
  
  self.store = nil
  ;Fi[	@¥iñI"û        case var
        when Proc then
          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist);Fi[	@i)I"º        @var = case var
        when Symbol then
          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist);Fi[@'@T@;I"@var = var;FI"end;Fi[[	@–iI"“      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@!i@I"       if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private;Fi[	@,i
I"‘    def self.inject(arglist)
      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@3iâI"œ        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        
        # Returns true if one or more steps failed;Fi[	@¢iqI"°        @var.flush
        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@•i/I"±      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@piI"÷      module ClassMethods
        def function(arglist)
          defined? @var ? (@var) : (Devise.scoped_views)
        end
        
        def function(arglist)
          @var = var
        end
      end
    end;Fi[	I"&data//homebrew_proj/exceptions.rb;Ti,I"í    else
      "No available formula for #{name} #{dependent_s}"
    end
  end
  
  def function(arglist)
    @var = var
  end
end
module Homebrew;Fi[	@iI"í    
    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@¸iI"ø    #:nodoc:
    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@üi1I"ã    
    def self.[](arglist)
      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function;Fi[	@.iáI"•  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.iãI"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.i¶I"™    else
      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.i™I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.iÆI"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.i≤I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.i∂I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.i∫I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@.iæI"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@≤iUI"ø      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@ÀiI"≥            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist);Fi[I"#   # => [;FI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;TI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];Ti[[	I"Kdata//activerecord_proj/active_record/associations/collection_proxy.rb;Ti*I"9      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name);Ti[	@ÁicI"h      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@Ái|I"f      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@ÁiöI"c      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái‡I"k      #   person.pets.count # => 3
      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.create(var, &var);Ti[	@Ái	I"q      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')]);Ti[	@Ái>I"J      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@ÁiEI"E      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0;Ti[	@Ái_I"J      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@ÁifI"?      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@ÁixI"J      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@ÁiI"?      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@ÁiïI"K      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all;Ti[	@ÁiµI"S      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@Ái—I"`      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3));Ti[	@ÁiÌI"S      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@Ái	I"K      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1");Ti[	@Ái%I"T      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1));Ti[	@Ái}I"[      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var);Ti[	@ÁiïI"∞      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3;Ti[	@Ái±I"ô      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length;Ti[@©@|@}@~I"end;Fi[[	@]ilI"…        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end
  end
  
  class StrictValidationFailed < StandardError;Fi[	@ÅiI"¡    def function(arglist)
      if var.respond_to?(:permitted?) and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	@wi!I"Ÿ          aliases[var] += 1
          if (aliases[var] > 1) then
            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      
      private;Fi[	@ãi-I"Ë                var = var.gsub(/^"(.*)"$/, "\\1").gsub(/\\(.)/, "\\1")
                [var, var]
              end]
            else
              var
            end
          end
        end
        
        def function(arglist);Fi[	@ãieI"                var = ("(" == var[1]) ? ((var[2].to_i + 1)) : (var[2].to_i)
                var = (")" == var[5]) ? ((var[4].to_i - 1)) : (var[4].to_i)
                (var..var)
              else
                var
              end
            end
          end
        end
        ;Fi[	@ãizI"°                  nil
                end
              end
            else
              var
            end
          end
        end
        
        private;Fi[	@6iLI"          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        
        class Integer < Type;Fi[	@@i`I"W        var = Relation.new(self, arel_table)
        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with;Fi[	@≈iI"Õ          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist);Fi[	I"9data//bundler_proj/bundler/vendor/thor/invocation.rb;TiI"ˇ        case var
        when Symbol, String then
          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    
    # Make initializer aware of invocations and the initialization args.;Ti[	@|i≈I"}          false
        when "nil" then
          nil
        else
          var
        end
      end
    end
  end
end;Fi[	@∆iÑI"ö            "#head"
          when /^\d+/ then
            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end;Fi[	@∑	iØI"Æ          var = StringIO.new(var.read)
          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    
    def function(arglist);Fi[	@ƒ	i*I"        (additional_import_paths or []).map do |arglist|
          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@“	i?I"È        if var.respond_to?(:supports?) and (var.supports?(var) and var.respond_to?(:"to_#{var}")) then
          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  ;Fi[	@RiZI"™    else
      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end
    end
  end
  
  protected;Fi[	@<i⁄I"B        var.gsub(/\A([^:]*\.(?:rb|feature|haml)):(\d*).*\z/) do |arglist|
          if ENV["TM_PROJECT_DIRECTORY"] then
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@Vi•I"£            var.backtrace.push(var.backtrace_line("World"))
            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@biîI"È            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@÷i'I"û            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@üi2I"•          var = default_scoping.try(:call)
          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[I"def self.included(arglist);FI"var.extend(ClassMethods);FI"end;FI" ;FI"module ClassMethods;Fi[[	@‹iI"‰module Backup
  module Configuration
    module Helpers
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        ##
        # Returns or yields the Configuration::Store;Fi[	@iI"0  module Actions
    attr_accessor(:behavior)
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Hold source paths for one Thor instance. source_paths_for_search is the
      # method responsible to gather source_paths from this current class,;Fi[	@'iI"class Thor
  module Invocation
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # This method is responsible for receiving a name and find the proper
      # class and task for it. The key is an optional parameter which is;Ti[	@yi	I")module Capistrano
  class CLI
    module Execute
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Invoke capistrano using the ARGV array as the option parameters. This
        # is what the command-line capistrano utility does.;Fi[	@|i	I"module Capistrano
  class CLI
    module Options
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return a new CLI instance with the given arguments pre-parsed and
        # ready for execution.;Fi[	@i
I"˚module Capistrano
  class CLI
    module UI
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return the object that provides UI-specific methods, such as prompts
        # and more.;Fi[	@ri0I"D  end
  
  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ");Fi[	@	iI"*module Redmine
  module Acts
    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          unless self.included_modules.include?(Redmine::Acts::ActivityProvider::InstanceMethods) then;Fi[	@	iI"#      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Returns events of type event_type visible by user that occured between from and to
          def function(arglist);Fi[	@iI"Îmodule Redmine
  module Acts
    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          cattr_accessor(:attachable_options);Fi[	@iI"module Redmine
  module Acts
    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Customizable::InstanceMethods) then;Fi[	@iI"module Redmine
  module Acts
    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Event::InstanceMethods) then;Fi[	@iI"Õmodule ActiveRecord
  module Acts
    module List
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:
        #;Fi[	@iI"Ûmodule Redmine
  module Acts
    module Searchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Options:
        # * :columns - a column or an array of columns to search;Fi[	@i)I"F      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Searches the model for the given tokens
          # projects argument can be either nil (will search all projects), a project or an array of projects;Fi[	@iI"Õmodule ActiveRecord
  module Acts
    module Tree
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:
        #;Fi[	@"iI"module Redmine
  module Acts
    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Watchable::InstanceMethods) then;Fi[	@Æi	I"˙  module ActionController
    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = breakdown_rfpdf_options(var);Fi[	I"2data//redmine_proj/redmine/safe_attributes.rb;TiI"Ímodule Redmine
  module SafeAttributes
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Declares safe attributes
      # An optional Proc can be given for conditional inclusion;Fi[	I"3data//redmine_proj/redmine/subclass_factory.rb;TiI"∏module Redmine
  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = nil;Fi[	@ iI"»module Resque
  module Failure
    module Thoughtbot
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        attr_accessor(:klass)
        ;Fi[@@@I" ;FI"def function(arglist);Fi[[	@)iÕI"ˆ            within_new_transaction(var) { |arglist| yield }
          end)
        rescue ActiveRecord::Rollback
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (var = begin_transaction(var);Fi[	@∂iI"¸        begin
          execute("BEGIN")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (execute("SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}");Fi[	@∂iI"À        begin
          execute("ROLLBACK")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@≤iI",      when Proc then
        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      raise(RecordNotFound, "Couldn't find #{self.class.reflect_on_association(association_name).klass.name} with ID=#{record_id} for #{self.class.name} with ID=#{id}")
    end;Fi[	@”iCI"√            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic)
      end;Fi[	@Ái‡I"ú      when Array then
        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      var.pp(self.to_a)
    end;Ti[	@Ÿi!I"            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|
          var.index_name = [var, attributes[(var - 1)]].map { |arglist| index_name_for(var) };Fi[	@ÄiI"        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist)
        @var = (var or EmptyBackground.new)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var;Fi[	@<i&I"‰        when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "img_#{@img_id}"
        @var = (@var + 1);Fi[	@—i#I"É    when :ppc, :dunno then
      abort("        Sorry, Homebrew does not support your computer's CPU architecture.\n        For PPC support, see: https://github.com/mistydemeo/tigerbrew\n".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    if HOMEBREW_CELLAR.exist? and HOMEBREW_CELLAR.writable_real?.! then
      raise("Cannot write to #{HOMEBREW_CELLAR}");Fi[	@‘i<I"£    when :gcc then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist)
    (@var.to_sym == var.to_sym)
  end;Fi[	@GiI"√      @var = @var.keys.first
      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var.each_with_index do |arglist|
      if var.is_a?(Hash) then;Fi[	@GiI"÷    when 1 then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var = /https?:\/\/(www\.)?github\.com\/.*\/(zip|tar)ball\//
    if var.match(@var) then;Fi[	@UiZI"ñ      @var = (@var + ".bz2")
      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    @var.nil?.!
  end;Fi[	@›i)I"     when :rbx then
      ["/usr/bin/env", "rbx", "-rubygems", "-e", "require '#{@import_name}'"]
    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var
    when :chicken then;Fi[	@biÜI"Ú    var.gsub!(TEXTILE_REFS_RE) do |arglist|
      var, var = $~[(2..3)]
      @var[var.downcase] = [var, nil]
      # do nothing
    end
  end
  
  def function(arglist)
    var.gsub!(MARKDOWN_REFS_RE) do |arglist|
      var, var = $~[(2..3)];Fi[	@bièI"À      var, var = $~[(2..3)]
      var = $~[6]
      @var[var.downcase] = [var, var]
      # do nothing
    end
  end
  
  def function(arglist)
    var = @var[var.downcase] if var
    (var or [var, nil]);Fi[	@Oi›I"È        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@OiI"          pdf_new_page?(var)
          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Project) and (var.start_date and var.due_date) then
          var[:zoom] ||= 1;Fi[	@OiI"          pdf_new_page?(var)
          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Version) and (var.due_date and var.start_date) then
          var[:zoom] ||= 1;Fi[	@≤i6I"ú        when :twice then
          2
        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0
      end;Fi[I"#;FI"*#   class Person < ActiveRecord::Base;FI"#     has_many :pets;TI"#   end;TI"#;Ti[[	@Ái$I"˛      # Works in two ways.
      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@Ái]I"j      # Finds an object in the collection responding to the +id+. Uses the same
      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@Ái{I"R      # Returns the first record, or the first +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@ÁiîI"P      # Returns the last record, or the last +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@ÁiI"O      
      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>];Ti[	@ÁiéI">      # Deletes the records of the collection directly from the database.
      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@ÁiI"'      #
      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@ÁiI"Å      # Destroys the +records+ supplied and removes them from the collection.
      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@ÁidI"È      end
      
      # Specifies whether the records should be unique or not.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@ÁivI"”      end
      
      # Count all records using SQL.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 3
      #   person.pets;Ti[	@ÁiåI"ƒ      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1;Ti[	@Ái¶I"       # If the collection has been already loaded, +length+ and +size+ are
      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.length # => 3
      #   # executes something like SELECT "pets".* FROM "pets" WHERE "pets"."person_id" = 1;Ti[	@Ái¿I"ç      # it is equivalent to <tt>collection.exists?</tt>. If the collection has
      # not already been loaded and you are going to fetch the records anyway it
      # is better to check <tt>collection.length.zero?</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count  # => 1
      #   person.pets.empty? # => false;Ti[	@Ái—I"ˆ      end
      
      # Returns +true+ if the collection is not empty.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 0
      #   person.pets.any?  # => false;Ti[	@ÁiÛI"(      
      # Returns true if the collection has more than one record.
      # Equivalent to <tt>collection.size > 1</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count #=> 1
      #   person.pets.many? #=> false;Ti[	@ÁiI"       end
      
      # Returns +true+ if the given object is present in the collection.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # => [#<Pet id: 20, name: "Snoop">]
      #;Ti[	@Ái@I"0      # contain the same number of elements and if each element is equal
      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@ÁiZI"&      
      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@ÁiÇI"Ç      # Adds one or more +records+ to the collection by setting their foreign keys
      # to the association√¢¬Ä¬òs primary key. Returns +self+, so several appends may be
      # chained together.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 0
      #   person.pets << Pet.new(name: 'Fancy-Fancy');Ti[	@Ái£I"_      
      # Reloads the collection from the database. Returns +self+.
      # Equivalent to <tt>collection(true)</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # fetches pets from the database
      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>];Ti[@z@{@|@}I" ;Fi[[	@]imI"å      when Proc then
        var.call
      else
        var
      end
    end
  end
  
  class StrictValidationFailed < StandardError
  end;Fi[	@wi"I"ƒ          if (aliases[var] > 1) then
            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      
      private
      ;Fi[	@ãi.I"Â                [var, var]
              end]
            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var);Fi[	@ãi{I"î                end
              end
            else
              var
            end
          end
        end
        
        private
        ;Fi[	@6iMI"            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        
        class Integer < Type
          def function(arglist);Fi[	@£i!I"          if var.encoding.!=(Encoding::ASCII_8BIT) then
            var = var.force_encoding(Encoding::ASCII_8BIT)
          end
          var
        end
      end
    end
    
    class SQLite3Adapter < AbstractAdapter
      class Version;Fi[	@@iaI"ñ        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
    # attributes but not yet saved (pass a hash with key names matching the associated table column names).;Fi[	@≈iI"·            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) };Fi[	@,i I")          var = new(var)
          yield(var) if block_given?
          var.save!
          var
        end
      end
    end
    
    # The validation process on save can be skipped by passing <tt>validate: false</tt>.
    # The regular Base#save method is replaced with this when the validations;Fi[	@'iI"        when Symbol, String then
          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    
    # Make initializer aware of invocations and the initialization args.
    def function(arglist);Ti[	@∑	i∞I"Õ          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("expected a file to upload");Fi[	@ƒ	i+I"$          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1));Fi[	@Ri[I"§      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end
    end
  end
  
  protected
  ;Fi[	@<i€I"∂          if ENV["TM_PROJECT_DIRECTORY"] then
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      
      def function(arglist)
        (@var << "<script type=\"text/javascript\">document.getElementById('duration').innerHTML = \"Finished in <strong>#{format_duration(features.duration)} seconds</strong>\";</script>");Fi[	@biïI"˘              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then;Fi[	I"1data//mongoid_proj/lib/mongoid/attributes.rb;Ti~I"ﬁ            attribute_will_change!(var)
          end
          var ? ((attributes[var] ||= {}).merge!(var)) : (attributes[var] = var)
          var
        end
      end
    end
    
    (alias :[]= :write_attribute)
    ;Fi[	I"2data//mongoid_proj/lib/mongoid/persistence.rb;Ti—I"          else
            var = new(var, var, &var)
            var.save
            var
          end
        end
      end
      
      # Create a new document. This will instantiate a new document and
      # insert it in a single call. Will always return the document;Fi[	@ÙiÒI"t            var = new(var, var, &var)
            fail_validate!(var) unless var.insert.errors.empty?
            fail_callback!(var, :create!) if var.new_record?
            var
          end
        end
      end
      
      # Delete all documents given the supplied conditions. If no conditions
      # are passed, the entire collection will be dropped for performance;Fi[	@ôi’I"¯            @var, @var = {}, true
            @var = var.inject({}) do |arglist|
              var[var.id] = var
              var
            end
          end
        end
        
        # Does the target include the provided document?
        #;Fi[	@÷
ißI"‹            if var.is_a?(Symbol) then
              var = resolve(var, var, var, var.merge(:scope => (nil)))
            end
            var
          end
        end
      end
      
      include(Implementation)
      ;Fi[@©@™@´@¨I"end;Fi[[	@#i6I"€            target.destroy
          when :nullify then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private;Fi[	@qiàI"õ          HasAndBelongsToMany
        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	@êiOI"                var.gsub!(/[^-\d.]/, "")
              when /^-?\D+[\d.]+,\d{2}$/ then
                var.gsub!(/[^-\d,]/, "").sub!(/,/, ".")
              else
                # do nothing
              end
            end
          end
        end
        ;Fi[	@…iΩI"                  { var.foreign_key => (var[primary_key_name]), var.association_foreign_key => (ActiveRecord::FixtureSet.identify(var)) }
                end)
              end
            else
              # do nothing
            end
          end
        end
        var
      end;Fi[	@¯i I"¶        destroyed?
      when :update then
        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	@iI"æ      when Hash then
        [:force, :skip, "force", "skip"].each { |arglist| var.delete(var) }
        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	@Ñ	iKI"~        "key:value"
      when :array then
        "one two three"
      else
        # do nothing
      end
    end
  end
end;Fi[	@èiI"ò            false
          when "a" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[	@∑	iøI"z        var.abort!
      when :scp then
        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	@?i>I"∏          when :stdout then
            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[	@4ioI"›        problem("Use ENV.fortran during install instead of depends_on 'gfortran'")
      when "open-mpi", "mpich2" then
        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@4iÕI"⁄        end
      when /macports\/trunk/ then
        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@,i+I"é      case File.basename(var)
      when "LinkedKegs", "Aliases" then
        true
      else
        # do nothing
      end
    end
  end
end;Fi[	@¿iºI"Ñ        :zip
      when ".7z" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@›iAI"•      "rbx gem install"
    when :ruby then
      "gem install"
    else
      # do nothing
    end
  end
end
class X11Dependency < Requirement
  include(Comparable);Fi[	@/isI"Ä        var
      when "maruku" then
        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	I")data//jekyll_proj/jekyll/core_ext.rb;Ti*I"Ø          var = var[var].split
        when Array then
          var = var[var].compact
        else
          # do nothing
        end
      end
    end
    (var or [])
  end;Fi[	@üiáI"∏      yield(Result[:failed], var, nil)
    when OpenID::Consumer::SETUP_NEEDED then
      yield(Result[:setup_needed], var.setup_url, nil)
    else
      # do nothing
    end
  end
end;Fi[	@ΩiHI"”            when "day" then
              (@var << "#{date_from.to_date}")
              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      ;Fi[	@2i)I"ú            else
              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[@+I"end;FI" ;F@/I"@var = var;Fi[[	@üiI"ı      
      def function(arglist)
        @var = ensure_dir(var, "junit")
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = @var = @var = @var = 0
        @var = OrderedXmlMarkup.new(:indent => 2);Fi[	@•i.I"ú      
      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[	@¯iI"      
      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = @var.class unless Class.===(@var)
          responds? and (has_column? and included?);Fi[	@˛iI"      
      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = var.new if (var.class == Class)
          error_when_not_valid? and no_error_when_valid?;Fi[	@iI"∆      
      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@.iÅI"≠    @var = var
    @var = var
    var = var if (var == -1)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var)
  end;Fi[	@.iäI"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@.iéI"Ü  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var);Fi[	@.i©I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@.i≠I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@.i±I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@.iµI"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@.iπI"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@.iΩI"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@œiI"∂      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!
      end;Fi[	@œieI"ˆ      def function(arglist)
        @var = parse_expected(var.shift)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var = var
        begin
          return @var = var.__send__(predicate, *@var, &@var);Fi[	@œiôI"√    class BeSameAs < Be
      def function(arglist)
        @var = var.shift
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.equal?(@var)
      end;Fi[	@⁄iI"      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var)
        @var = difference_between_arrays(@var, @var);Fi[	@≤iTI"Í      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[@¨@
@fI"@var = var;FI"@var = var;Fi[[	@Ri
I"!    class Preloader
      class Association
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class);Fi[	@öigI"«    
    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	@ÁiI"¿    alias :loaded? :loaded
    
    alias :default_scoped? :default_scoped
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = nil
      @var = false;Ti[	@!iI"≈    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	@i	I"™module Bundler
  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@4iI"∂    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	@3iI"        attr_accessor(:path, :uri, :ref)
        
        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var or Proc.new { |arglist| true });Fi[	I"+data//cancan_proj/cancan/exceptions.rb;TiI"    attr_reader(:action, :subject)
    
    attr_writer(:default_message)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "You are not authorized to access this page.")
    end;Fi[	@Ñi;I"‰        
        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          ;Fi[	@∑	i!I"≠    attr_reader(:logger)
    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@+i"I"            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["cleanup"] ||= Sass::Script::Bool.new(true);Fi[	@9iI"™          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil
      end;Fi[	@Oi)I"Ï      
      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@Ri	I"¥  module RbSupport
    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	@i$I"      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("notifier.invited_you", :name => (@var.name))), :host => (AppConfig.pod_uri.host) };Fi[	@ái
I"˛    module Errors
      class AttributeAssignmentError < Mongoid::Errors::MongoidError
        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end;Fi[	@õiI"±module Paperclip
  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@iI""      REGEX = /^(@(#{KEYWORDS.join("|")})|.+\s+.+\s+.+\s+.+\s+.+.?)$/
      
      attr_accessor(:time, :task)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var.is_a?(String) ? ((Chronic.parse(var) or 0)) : ((var or 0))
      end;Fi[@'@(@@	I"
begin;Fi[[	@áiPI"Ó          var = through_association.build
          var.send("#{source_reflection.name}=", var)
          var)
        end
      end
      
      def function(arglist)
        begin
          build_through_record(var).save!
        ensure;Fi[	@)iŒI"À          end)
        rescue ActiveRecord::Rollback
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (var = begin_transaction(var)
          yield);Fi[	@∂iI"          execute("BEGIN")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (execute("SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}")
          begin_db_transaction);Fi[	@Úi&I"ı          else
            ActiveRecord::Base.configurations[var[:env]]
          end
        end
      end
      
      def function(arglist)
        begin
          (var = var.first
          class_for_adapter(var["adapter"]).new(*var).create);Fi[	@iéI"©        yield)
      ensure
        var.each { |arglist| @var.pop }
      end
    end
    
    def function(arglist)
      begin
        (@var.concat(var)
        yield);Fi[	@-iwI"À        yield)
      ensure
        self.build_args = var
      end
    end
    
    def function(arglist)
      begin
        (require("rubygems/format")
        Gem::Format.from_file_by_path(var).spec);Fi[	@3i^I"#            var
          else
            raise(GitError, "Bundler is trying to run a `git #{command}` at runtime. You probably need to run `bundle install`. However, this error message could probably be more useful. Please submit a ticket at http://github.com/carlhuda/bundler/issues with steps to reproduce as well as the following\n\nCALLER: #{caller.join("\n")}")
          end
        end
        
        def function(arglist)
          begin
            (return unless @var
            in_path { |arglist| git("cat-file -e #{@revision}") };Fi[	@…	i/I"‡      def function(arglist)
        var[:pattern_name] ||= var
        Compass::Installers::Manifest.new(manifest_file(var), var)
      end
    end
    
    def function(arglist)
      begin
        (@var = nil
        yield;Fi[	@bi'I"‚      ensure
        ($stderr.write(color(:clear))
        $stdout.write(color(:clear)))
      end
    end
    
    def function(arglist)
      begin
        ($stderr.write(color(:yellow))
        $stdout.write(color(:yellow));Fi[	@PijI"
      def function(arglist)
        hooks_for(:after, var).reverse_each do |arglist|
          invoke(var, "After", var, true)
        end
      end
      
      def function(arglist)
        begin
          var.invoke(var, var, &var)
        rescue Exception => var;Fi[	@i≤I"∞      end
    else
      respond_with(@var, :location => (photos_path), :error => (message))
    end
  end
  
  def function(arglist)
    begin
      yield
    rescue TypeError;Fi[	@—iRI"ÿ    unless var.empty? then
      perform_preinstall_checks
      var.each { |arglist| install_formula(var) }
    end
  end
  
  def function(arglist)
    begin
      (var = FormulaInstaller.new(var)
      var.install;Fi[	@o
i¢I"˙  def function(arglist)
    unless (install_bottle or (ARGV.interactive? or @var.nil?)) then
      @var ||= (Time.now - @var)
    end
  end
  
  def function(arglist)
    begin
      (FileUtils.rm(Dir["#{HOMEBREW_LOGS}/#{f}/*"])
      @var = Time.now;Fi[	@o
iÔI"„      puts("formula against it.")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    begin
      (ohai("Cleaning") if ARGV.verbose?
      if f.class.skip_clean_all? then;Fi[	@qiwI"C      end
      styles.reject { |arglist| (var == :original) }.each do |arglist|
        post_process_style(var, var) if process_style?(var, var)
      end
    end
    
    def function(arglist)
      begin
        (if var.processors.blank? then
          raise(RuntimeError.new("Style #{name} has no processors defined."));Fi[	@iCI"            self
          end.class_eval do |arglist|
            define_method(var, &var)
          end
        end
        
        def function(arglist)
          begin
            (var = StringIO.new(".")
            override_method(var, :size) { |arglist| var };Fi[	@Ti#I"‘            var)
          rescue CommandFailed
            return nil
          end
        end
        
        def function(arglist)
          begin
            (var = Entries.new
            var = target(var);Fi[	@TiAI"<          rescue => var
            logger.error("scm: filesystem: error: #{err.message}")
            raise(CommandFailed.new(var.message))
          end
        end
        
        def function(arglist)
          begin
            (var = scm_iconv(@var, "UTF-8", target(var))
            File.new(var, "rb").read);Fi[@·@‚@„I"#   #    ];TI"#;Ti[[	@Ái+I"<      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@ÁidI"∑      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #   person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=4;Ti[	@Ái}I"`      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #;Ti[	@ÁiõI"]      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #;Ti[	@Ái
I"ã      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')])
      #   person.pets.size # => 5;Ti[	@Ái?I"S      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@ÁiFI"W      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0
      #   person.pets      # => [];Ti[	@Ái`I"S      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@ÁigI"Z      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@ÁiyI"S      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@ÁiÄI"Z      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@ÁiñI"K      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all
      #;Ti[	@Ái∂I"å      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@Ái“I"i      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3))
      #   # => [;Ti[	@ÁiÓI"å      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@Ái
I"Ñ      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1")
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@Ái&I"ç      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@ÁiñI"ü      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3
      #   # Because the collection is already loaded, this will behave like;Ti[@'@TI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;Fi[[	@<iPI"      # @since 3.0.0
      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@<iäI"#          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ]);Fi[	@?iI"      # @since 3.0.3
      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@EiI"      # @since 3.0.0
      def function(arglist)
        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date.mongoize;Fi[	@Ei.I"9        # @since 3.0.0
        def function(arglist)
          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Date.mongoize("2012-1-1");Fi[	@JiI"          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize;Fi[	@Ji4I"6        # @since 3.0.0
        def function(arglist)
          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   DateTime.mongoize("2012-1-1");Fi[	@PilI"ﬁ          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@Si~I"€        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@Si˘I"        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11");Fi[	@YiI"Ô      # @since 3.0.0
      def function(arglist)
        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   range.mongoize;Fi[	@Yi:I"=        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : (::Range.new(var["min"], var["max"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Range.mongoize(1..3);Fi[	@_i"I"        # @since 3.0.0
        def function(arglist)
          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Set.mongoize(1..3);Fi[	@bi±I"        # @since 3.0.0
        def function(arglist)
          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   String.mongoize("123.11");Fi[	@ei!I"        # @since 3.0.0
        def function(arglist)
          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Symbol.mongoize("123.11");Fi[	@hi4I"            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1");Fi[	@mi#I"A        def function(arglist)
          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   TimeWithZone.mongoize("2012-1-1");Fi[@'@œ@–@mI" ;Fi[[	@qiuI"f          var = var.class.reflections[var]
          unless var then
            raise(ActiveRecord::ConfigurationError, "Association named '#{association}' was not found; perhaps you misspelled it?")
          end
          var
        end
      end
      
      def function(arglist)
        if (var.macro == :belongs_to) and var.options[:polymorphic] then;Fi[	@zibI"G            super(var, var)
            serialized_attributes.each do |arglist|
              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then;Fi[	@L	i†I"P        return nil if (var.blank? or (var == self.name))
        unless var = subclasses.detect { |arglist| (var.name == var) } then
          raise(ActiveRecord::SubclassNotFound.new("Invalid single-table inheritance type: #{subclass_name} is not a subclass of #{name}"))
        end
        var
      end
    end
    
    private
    ;Fi[	@¬i!I"•          else
            var.send("#{k}!", var)
          end
        end
        var
      end
    end
    
    class Merger
      attr_reader(:relation, :values);Fi[	@9iXI"ü          (var << "\n")
        end
        (var << "end\n") if var
      end
      var
    end
  end
  
  class Dependency
    attr_accessor(:source, :groups);Fi[	@á	iÖI"6          if var.enum and var.enum.include?(var).! then
            raise(MalformattedArgumentError, "Expected '#{name}' to be one of #{switch.enum.join(", ")}; got #{value}")
          end
        end
        var
      end
    end
    
    # Raises an error if @non_assigned_required array is not empty.
    #;Fi[	@ri*I"é        else
          (var << stop.inspect)
        end
      end
      var
    end
  end
  
  module Gradient
    def self.included(arglist);Fi[	@gi]I"        var = File.basename(var, ".png")
        unless VAILD_FILE_NAME.=~(var) then
          raise(Compass::Error, "Sprite file names must be legal css identifiers. Please rename #{File.basename(file)}")
        end
        var
      end
    end
    
    def self.sass_options(arglist)
      var.merge!(:filename => (var.gsub(/\*\//, "*\\/")), :syntax => :scss, :importer => (var));Fi[	@ìiI"˛        var = send(var, *var)
      ensure
        InstanceExecHelper.module_eval { |arglist| remove_method(var) } rescue nil
      end
      var
    end
  end
  
  # TODO: Move most of this stuff out to an InstanceExecutor class.
  def function(arglist);Fi[	I"!data//haml_proj/haml/util.rb;TiI"Õ        var.each do |arglist|
          (var << var)
          (var << (var + [var]))
        end
        var
      end
    end
    
    # Returns information about the caller of the previous method.
    #;Fi[	@‰ipI"–        _children.each do |arglist|
          var.process_flagged_destroys
          generate_atomic_updates(var, var)
        end
        var
      end
    end
    
    (alias :_updates :atomic_updates)
    ;Fi[	I"9data//mongoid_proj/lib/mongoid/relations/metadata.rb;TifI"V            if (var.as == name) and (var.class_name == inverse_class_name) then
              var.push(var.name)
            end
          end
          var
        end
      end
      
      # For polymorphic children, we need to figure out the inverse from the
      # actual instance on the other side, since we cannot know the exact class;Fi[	@ii}I"&        xpath("//namespace::*").inject({}) do |arglist|
          if var.prefix.!=("xml") then
            var[["xmlns", var.prefix].compact.join(":")] = var.href
          end
          var
        end
      end
      
      # Get the list of decorators given +key+
      def function(arglist);Fi[	@iOI"p              var = custom_values.detect { |arglist| (var.custom_field == var) }
              var ||= custom_values.build(:customized => (self), :custom_field => (var), :value => (nil))
              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist)
          custom_field_values.select(&:visible?);Fi[	@bi±I"        end
      else
        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist)
    (@var << var);Fi[	@⁄i5I"Œ          if var = var.index(var) then
            var.delete_at(var)
          end
        end
        var
      end
    end
    
    OperatorMatcher.register(Array, "=~", Spec::Matchers::MatchArray)
  end;Fi[	@fiãI"‹        var.each do |arglist|
          var = var ? (var.to_s) : ("nil")
          (var << var.add_edge(var, (var ? (var) : (var)), :label => (var.to_s)))
        end
        var
      end
    end
    
    protected
    ;Fi[@¨@ÃI"# type.;FI"#;FI"$# @example Mongoize the object.;Fi[[	@<iQI"ˇ      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@<iãI"            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ])
        #;Fi[	@?iI"„      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@EiI"      def function(arglist)
        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date.mongoize
      #;Fi[	@Ei/I",        def function(arglist)
          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Date.mongoize("2012-1-1")
        #;Fi[	@JiI"          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #;Fi[	@Ji5I")        def function(arglist)
          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   DateTime.mongoize("2012-1-1")
        #;Fi[	@PimI"“        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@SiI"÷          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@Si˙I"         def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11")
        #;Fi[	@YiI"‚      def function(arglist)
        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   range.mongoize
      #;Fi[	@Yi;I"0        def function(arglist)
          var.nil? ? (nil) : (::Range.new(var["min"], var["max"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Range.mongoize(1..3)
        #;Fi[	@_i#I"        def function(arglist)
          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Set.mongoize(1..3)
        #;Fi[	@bi≤I"        def function(arglist)
          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   String.mongoize("123.11")
        #;Fi[	@ei"I"        def function(arglist)
          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Symbol.mongoize("123.11")
        #;Fi[	@hi5I"          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1")
        #;Fi[	@mi$I"-          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   TimeWithZone.mongoize("2012-1-1")
        #;Fi[@'@T@;I"
false;FI"end;Fi[[	@Ñi2I"≠          end
          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end
  end;Fi[	@0	iI"ó      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@0	iI"∑      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions;Fi[	@0	ikI"Œ            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@5	i}I"      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,;Fi[	@>i!I"É    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist);Fi[	@>i%I"Ñ    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist);Fi[	@>i=I"{    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@”iI"Ú      # ThroughReflection.
      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false
      end
      
      # An array of arrays of scopes. Each item in the outside array corresponds to a reflection;Fi[	@JiI"Ü    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI;Fi[	@<iI"Ô    def function(arglist)
      super(var)
      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    
    # By default, a task invokes a method in the thor class. You can change this;Fi[	@jicI"∫      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end;Fi[	@_i7I"Õ      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@ÉiI"ü      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	I"/data//diaspora_proj/models/conversation.rb;Ti0I"ë  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist);Fi[	@áiyI"—  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist);Fi[I"#   person.pets;TI"#   # => [;T@·@‚@„i[[	@Ái)I"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁibI"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái{I"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁiôI"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁiI"D      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái=I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái^I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁiwI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁiîI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái¥I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái–I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁiÏI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁiI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái$I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái|I"L      #   end
      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist);Ti[	@Ái∞I"ç      #
      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist);Ti[@°I"def function(arglist);FI"@var = var;FI"end;FI" ;Fi[[	@1iîI"∫  	# @param float :scale image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_image_scale, :SetImageScale)
  ;Fi[	@1i˙I"Í  	# @param float :margin The margin.
  	# @since 1.5
  	# @see SetLeftMargin(), SetRightMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_top_margin, :SetTopMargin)
  ;Fi[	@1iI"Ï  	# @param float :margin The margin.
  	# @since 1.5
  	# @see SetLeftMargin(), SetTopMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_right_margin, :SetRightMargin)
  ;Fi[	@1iBI"”  	# @param string :title The title.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetSubject()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_title, :SetTitle)
  ;Fi[	@1iNI"Ÿ  	# @param string :subject The subject.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_subject, :SetSubject)
  ;Fi[	@1iZI"‚  	# @param string :author The name of the author.
  	# @since 1.2
  	# @see SetCreator(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_author, :SetAuthor)
  ;Fi[	@1ifI"‰  	# @param string :keywords The list of keywords.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_keywords, :SetKeywords)
  ;Fi[	@1irI"Â  	# @param string :creator The name of the creator.
  	# @since 1.2
  	# @see SetAuthor(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_creator, :SetCreator)
  ;Fi[	@1iBI"Ï   	# Set header margin.
  	# (minimum distance between header and top page margin)
  	# @param int :hm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_margin, :SetHeaderMargin)
  ;Fi[	@1iMI"Ô   	# Set footer margin.
  	# (minimum distance between footer and bottom page margin)
  	# @param int :fm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_margin, :SetFooterMargin)
  ;Fi[	@1iWI"  #
   	# Set a flag to print page header.
  	# @param boolean :val set to true to print the page header (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_header, :SetPrintHeader)
  ;Fi[	@1iaI"Ú  #
   	# Set a flag to print page footer.
  	# @param boolean :value set to true to print the page footer (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_footer, :SetPrintFooter)
  ;Fi[	@1i:I"¨   	# Set header font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_font, :SetHeaderFont)
  ;Fi[	@1iEI"¨   	# Set footer font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_font, :SetFooterFont)
  ;Fi[	@1iPI"¥   	# Set language array.
  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_language_array, :SetLanguageArray)
  ;Fi[	@1iZI"å  #
   	# Set document barcode.
  	# @param string :bc barcode
  	#
  def function(arglist)
    @var = var
  end
  
  #
   	# Print Barcode.;Fi[@'I"return var;FI"end;FI" ;FI"def function(arglist);Fi[[	@∂iTI"„          else
            # do nothing
          end
        end
        return var
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, ""] }]
        var = add_index_length(var, var, var);Fi[	@-ilI"¸        Gem::SpecFetcher.new.list(false, true).each { |arglist| var[var] += var }
      rescue Gem::RemoteFetcher::FetchError
        # do nothing
      end
      return var
    end
    
    def function(arglist)
      var = self.build_args
      begin;Fi[	@ΩiuI":          var = yield(var).to_s.strip
          unless var =~ /^[0-9a-f]{40}$/ then
            raise("Unable to resolve revision for '#{revision}' on repository '#{repository}'.")
          end
          return var
        end
        
        def function(arglist)
          (variable(:git) or super)
        end;Fi[	I"+data//compass_proj/compass/compiler.rb;TinI"˚      end
      if options[:time] then
        puts("Compilation took #{((result.__duration * 1000).round / 1000.0)}s")
      end
      return var
    end
    
    def function(arglist)
      if should_compile?(var, var) then
        compile(var, var);Fi[	@<iñI"/              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "<span class=\"param\">#{param}</span>" })
        @var.div(:class => "step_name") do |arglist|;Fi[	@∏i&I"”        yield(var, var) if block_given?
        (var << var)
      end
    end
    return var
  end
  
  def function(arglist)
    if (Pathname.pwd == HOMEBREW_REPOSITORY) then
      "Library/Formula/#{name}.rb";Fi[	@¿i!I"õ      else
        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var then
      var = File.basename(var);Fi[	@¿iHI"±      else
        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then
      var = (self + File.basename(var));Fi[	@íihI"ˆ          end
        else
          var = public_url
        end
        return var
      end
      
      def function(arglist)
        var = find_credentials(var).stringify_keys
        var = Object.const_defined?(:Rails) ? (Rails.env) : (nil);Fi[	I"data//redmine_proj/diff.rb;Ti/I"∂          var[var[1]] = var[2]
          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist)
      var = Diff.lcs(var, var)
      var = var = 0;Fi[	@…iñI"Ò    var.each do |arglist|
      var = self[var]
      var.has_key?(var) ? (var[var].push(var)) : (var[var] = [var])
    end
    return var
  end
  
  def function(arglist)
    var ||= self.length
    if (self.empty? or (var > self[-1])) then;Fi[	I",data//redmine_proj/SVG/Graph/BarBase.rb;Ti/I"”          var = (var > 0) ? (0) : (var)
        else
          var = min_scale_value
        end
        return var
      end
      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end;Fi[	@£i5I"Ó          var = var.max
        else
          var = @var.collect { |arglist| var[:data].max }.max
        end
        return var
      end
      
      def function(arglist)
        var = 0
        if (min_scale_value.nil? == false) then;Fi[	@£iCI"»          else
            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[	I"'data//rspec_proj/autotest/rspec.rb;TiI"Œ    var = new_hash_of_arrays
    var.each do |arglist|
      (var[$2] << var) if var =~ /\n(\.\/)?(.*spec\.rb):[\d]+:/
    end
    return var
  end
  
  def function(arglist)
    if var.empty? then
      "";Fi[	I"5data//SiriProxy_proj/siriproxy/plugin_manager.rb;Ti,I"      var = var.process_filters(var, var)
      var = var if ((var == false) or (var.class == var))
      return nil if (var == false)
    end
    return var
  end
  
  def function(arglist)
    var = super(var)
    self.guzzoni_conn.block_rest_of_session if var;Fi[@'@(@)I"var;FI"end;Fi[[	@áieI"„          else
            if (var.macro == :has_one) then
              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      
      def function(arglist);Fi[	@…iøI"è              end
            else
              # do nothing
            end
          end
        end
        var
      end
      var
    end;Fi[	@i´I"Û        var.gem_platforms(@var).each do |arglist|
          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist);Fi[	@'ilI"               (var << "gem '#{clean_req(requirement.required_by.first)}', in any of the sources.")
            else
              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end;Fi[	@îi|I"            warn(var)
            var = var.map do |arglist|
              (var == "deploy:symlink") ? ("deploy:create_symlink") : (var)
            end
          end
        end
        var
      end
      
      # Trigger the named event for the named task. All associated callbacks;Fi[	@…	iI"î              (var << " - #{description}")
            end
            (var << "\n")
          end
        end
      end
      var
    end
  end
end;Fi[	@riFI"        else
          if (var.value.last == var.value.last) and (var.value.first.value == 0) then
            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    
    # returns the end position of the gradient from the color stop;Fi[	@æiYI"Æ          person_link(var, :class => "mention hovercardable")
        else
          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  
  def function(arglist);Fi[	@ iJI"∆        next if (var.symlink? or var.directory?)
        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@6iêI"’            var.add_atomic_changes(self, var, var, var, var, var)
          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private;Fi[	@Zi,I"—              var.push(var)
              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end
    
    # Marks all children as being persisted.;Fi[	@Hi1I"¢                  var = 0
                end
              end
            end
          end
        end
        var
      end
      
      def function(arglist);Fi[	@i$I"µ              (var << "#{item.inspect} and ")
            else
              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end;Fi[	@ı
iÓI"               (var << var)
            else
              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      
      def function(arglist);Fi[	@vi+I"+        each_value do |arglist|
          if var.dynamic_initial_state? then
            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    
    # Runs one or more events in parallel on the given object.  See;Fi[@°I"# @return [ nil ] Nil.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	I"8data//mongoid_proj/lib/mongoid/contextual/atomic.rb;TiI"B      #
      # @param [ String, Symbol ] field The name of the field to add to.
      # @param [ Object ] value The single value to add.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$addToSet" => ({ database_field_name(var) => (var) }))
      end;Fi[	@iI"É      # @param [ String, Symbol ] field The name of the field to operate on.
      # @param [ Hash ] value The bitwise operations to perform. Keys may be
      #   "and" or "or" and must have numeric values.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$bit" => ({ database_field_name(var) => (var) }))
      end;Fi[	@i.I"8      #
      # @param [ String, Symbol ] field The field to increment.
      # @param [ Integer ] value The amount to increment by.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$inc" => ({ database_field_name(var) => (var) }))
      end;Fi[	@iBI"      #   from.
      # @param [ Integer ] value 1 to pop from the end, -1 to pop from the
      #   front.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pop" => ({ database_field_name(var) => (var) }))
      end;Fi[	@iSI"6      #
      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Object ] value The single value to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pull" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ibI";      #
      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Array<Object> ] values The values to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pullAll" => ({ database_field_name(var) => (var) }))
      end;Fi[	@iqI"-      #
      # @param [ String, Symbol ] field The field to push to.
      # @param [ Object ] value The value to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$push" => ({ database_field_name(var) => (var) }))
      end;Fi[	@i{I"9      #
      # @param [ String, Symbol ] field The field to push to.
      # @param [ Array<Object> ] values The values to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pushAll" => ({ database_field_name(var) => (var) }))
      end;Fi[	@iäI"A      #
      # @param [ String, Symbol ] old_name The old field name.
      # @param [ String, Symbol ] new_name The new field name.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$rename" => ({ database_field_name(var) => (var.to_s) }))
      end;Fi[	@iôI",      #
      # @param [ String, Symbol ] field The name of the field.
      # @param [ Object ] value The value to set.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$set" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ißI"U      #   context.unset(:name)
      #
      # @param [ String, Symbol, Array ] fields The name of the fields.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = var.__find_args__.collect { |arglist| [database_field_name(var), true] }
        query.update_all("$unset" => (Hash[var]));Fi[	I"8data//mongoid_proj/lib/mongoid/contextual/memory.rb;Ti(I"‹      #
      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count
        var = map do |arglist|;Fi[	@i>I"Ÿ      #
      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count
        each do |arglist|;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/mongo.rb;TiCI"È      #
      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        self.count.tap { |arglist| query.remove_all }
      end;Fi[	@iQI"Î      #
      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = self.count
        each { |arglist| var.destroy };Fi[@@I" ;F@ I"# do nothing;Fi[[	@)iI"      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@5	i˝I"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@5	iI"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@”iÂI"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Ji	I"çmodule Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@JiI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@JiI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@JiI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@JiI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@biSI"â  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@jiI"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Si>I"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@.iI"ä  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  ;Fi[	@ŒiI"©        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@—iI"©        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[I"
super;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@zikI">          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist)
          self.class.serialized_attributes.include?(var) ? (var.!=(var)) : (super)
        end;Fi[	@ziwI"/          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist)
          super.dup.tap do |arglist|
            self.class.serialized_attributes.each_key do |arglist|;Fi[	@∂i>I"ƒ          when /bit/i then
            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var
          when /blob|text/i then;Fi[	@∂iI"Ó            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      
      def function(arglist)
        if var[:first] then
          (var << " FIRST");Fi[	@∂ifI">        when 1452 then
          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
        add_column_options!(var, var);Fi[	@ãiI""          when / BC$/ then
            super(("-" + var.sub(/ BC$/, "")))
          else
            super
          end
        end
        
        def function(arglist)
          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",");Fi[	@ìiRI"ƒ              super
            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var
          case var;Fi[	@£i«I"—          var = var.class.string_to_binary(var).unpack("H*")[0]
          "x'#{s}'"
        else
          super
        end
      end
      
      def function(arglist)
        @var.class.quote(var)
      end;Fi[	@£iŸI"        if var.respond_to?(:usec) then
          "#{super}.#{sprintf("%06d", value.usec)}"
        else
          super
        end
      end
      
      def function(arglist)
        return var.to_f if BigDecimal.===(var)
        return super unless String.===(var);Fi[	@L	i}I"        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column)
      end;Fi[	@∫iI"œ          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super
        if ActiveRecord::Base.connected? then;Fi[	@`iuI"ı          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "-" then;Fi[	@cicI"ı          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "-" then;Fi[	@]iI"#          if (var.size == 1) and var.first.is_a?(::Time) then
            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var)
        end;Fi[@@∞@°I"@var = var;FI"@var = var;Fi[[	@RiI""      class Association
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class)
          @var = nil;Fi[	@”idI"k      # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>{ class_name: "Money" }</tt>
      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s);Fi[	@!iI"è    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@i
I"´  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = [];Fi[	@4iI"è    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@3iI"‰        
        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var or Proc.new { |arglist| true })
        end;Fi[	@∑	i"I"•    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@+i#I"          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["cleanup"] ||= Sass::Script::Bool.new(true)
          @var["layout"] ||= Sass::Script::String.new("vertical");Fi[	@Oi*I"Ò      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end;Fi[	@i%I"7    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("notifier.invited_you", :name => (@var.name))), :host => (AppConfig.pod_uri.host) }
    I18n.with_locale(var) do |arglist|;Fi[	I"%data//jekyll_proj/jekyll/page.rb;TiI"<    # base - The String path to the source.
    # dir  - The String path between the source and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      self.process(var)
      self.read_yaml(File.join(var, var), var);Fi[	I",data//jekyll_proj/jekyll/static_file.rb;TiI"    # base - The String path to the <source>.
    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@9iI"/      # The worker object who detected the failure
      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	I")data//twitter_proj/twitter/cursor.rb;TiI"-    # @param method_name [String, Symbol]
    # @param method_options [Hash]
    # @return [Twitter::Cursor]
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = Array(var[var.to_sym]).map do |arglist|
        var ? (var.fetch_or_new(var)) : (var);Fi[@I"2broadcast(var) { |arglist| var.accept(self) };FI"end;FI" ;FI"def function(arglist);Fi[[	@àiI"¯        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@àiI"        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@àiI"Ê        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@ài"I"«        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@ài/I"      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ài3I"ı        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@ài;I"ı        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ài?I"Î        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@àiGI"€        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@àiOI"ı        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@àiSI"D        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|
          visit_step_name(var, var, var, var, var, var);Fi[	@àicI"Â        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@àioI"Ê        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@àisI"Î        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[@¨@
@åI"end;FI" ;Fi[[	@àiI"
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@àiI"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@àiI"¯      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@ài!I"Ÿ      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@ài2I"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@ài:I"      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ài>I"˝      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@àiFI"Ì      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@àiNI"      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@àiRI"(      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|;Fi[	@àibI"˜      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@àinI"¯      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@àirI"˝      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[@'@T@;@ØI"@var = var;Fi[[	@Ai'I"¸      
      def self.matches_condition?(arglist)
        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@ÑiUI"∑              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var)
        end;Fi[	@™irI"Î            var = var[1]
            var = (var[3] or "highest")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          ;Fi[	@œ	i
I"æ    class TemplateContext
      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@+i!I"˝            var = File.expand_path(var)
            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@9iI"æ        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil;Fi[	@˙i$I"Ò      
      def self.parse(arglist)
        new(var, var, var).parse!(var)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var[:default_profile]
        @var = var[:skip_profile_information];Fi[	@i#I"Ç      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var;Fi[	@.i{I"£  
  def function(arglist)
    return [@var, @var, @var]
  end
  
  def function(arglist)
    @var = var
    @var = var
    var = var if (var == -1)
    @var = var;Fi[	@.ièI"Ü  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var)
  end;Fi[	@(iuI"¸      # Run all the after(:each) blocks for this example
      def function(arglist)
        example_group_hierarchy.run_after_each(self)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = caller
      end;Fi[	@ØiI"I      def self.allow_message_expectations_on_nil(arglist)
        @@warn_about_expectations_on_nil = false
        $rspec_mocks.add(nil) unless $rspec_mocks.nil?
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = ErrorGenerator.new(var, var, var)
        @var = OrderGroup.new(@var);Fi[	@iI"ñ    
    def function(arglist)
      @var[var.to_s] = var
    end
    
    def function(arglist)
      @var = var
      @var = var
      yield
    end;Fi[@¨@
I"
false;FI"end;FI" ;Fi[[	@0	iI"û      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false;Fi[	@0	iI"Ã      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions
      def function(arglist);Fi[	@0	ilI"é          end
        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true;Fi[	@5	i~I"›      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,
      # SQLite < 3.6.8 does not.;Fi[	@>i"I"ä    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false;Fi[	@>i&I"ë    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= "";Fi[	@”iÒI"Ó      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false
      end
      
      # An array of arrays of scopes. Each item in the outside array corresponds to a reflection
      # in the #chain.;Fi[	@JiI"õ    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI
      attr_writer(:shell);Fi[	@<iI"      super(var)
      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    
    # By default, a task invokes a method in the thor class. You can change this
    # implementation to create custom tasks.;Fi[	@_i8I"◊      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "#{options[:pattern_name]}/" if options[:pattern_name];Fi[	@ÉiI"©      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped;Fi[	@ai1I"‘  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join(";");Fi[	@áizI"ñ  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("notifier.a_post_you_shared");Fi[@'@(I"return var;FI"end;FI" ;Fi[[	@≥imI"            var.each { |arglist| var[var] += " #{order.upcase}" }
          else
            # do nothing
          end
        end
        return var
      end
      
      # Overridden by the mysql adapter for supporting index lengths
      def function(arglist);Fi[	@∂iSI"Ú            var.each { |arglist| var[var] += "(#{length})" }
          else
            # do nothing
          end
        end
        return var
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, ""] }];Fi[	@<iïI"8              var = var.instance_variable_get("@cell_matrix")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "<span class=\"param\">#{param}</span>" });Fi[	@∏i%I"‚      unless (var.include?(var) or var.nil?) then
        yield(var, var) if block_given?
        (var << var)
      end
    end
    return var
  end
  
  def function(arglist)
    if (Pathname.pwd == HOMEBREW_REPOSITORY) then;Fi[	@¿i I"∏        var.each { |arglist| (var << install_p(var, var)) }
      else
        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var then;Fi[	@¿iGI"Õ        var.each { |arglist| (var << install_symlink_p(var, var)) }
      else
        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then;Fi[	@…i.I"∑        while var do
          var[var[1]] = var[2]
          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist)
      var = Diff.lcs(var, var);Fi[	@üiVI"         var = var.normalize.to_s)
      rescue URI::InvalidURIError
        raise(InvalidOpenId.new("#{identifier} is not an OpenID identifier"))
      end
    end
    return var
  end
  
  protected
  ;Fi[	@1iÔ
I"ã          var = []
          var = 1
        end
      end
    end
    return var
  end
  
  #
  	# Converts UTF-8 strings to UTF16-BE.<br>;Fi[	@1i0I"∑          (var << (var >> 8).chr)
          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  
  # ====================================================
  	#;Fi[	@√itI"Ã            var = var.read
          else
            (var << "<!-- Ruby Zlib not available for SVGZ -->")
          end
        end
        return var
      end
      
      attr_accessor(:height)
      ;Fi[	@√ifI"            (var = var[var]
            var = var ? (((var + "; ") + var)) : (var)
            var[var] = var.strip.squeeze(" "))
          end
        end
        return var
      end
      
      # Override and place code to add defs here
      def function(arglist);Fi[	@£iBI"‰            var = @var[-1][:data].min
          else
            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist)
        @var[:fields];Fi[@'@T@;@åI"end;Fi[[	@àiI"„      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àiI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àiI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ài I"…      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ài1I"!      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ài9I"ÿ      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ài=I"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àiEI"Œ      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àiMI"ÿ      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àiQI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àiaI"‚      
      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àimI"…      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@àiqI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[@@@@I"###;Fi[[	@5	i–I"]      #
      # The default implementation does nothing; the implementation should be
      # overridden by concrete adapters.
      def function(arglist)
        # do nothing
      end
      
      ###
      # Clear any caching the database adapter may be doing, for example
      # clearing the prepared statement cache. This is database specific.;Fi[	@liMI"      # XInclude start type
      # XInclude end type
      # DOCB document node type
      def function(arglist)
        # do nothing
      end
      
      ###
      # Decorate this node with the decorators set up in this node's Document
      def function(arglist);Fi[	@‹iI"ı      class Document
        ###
        # Called when an XML declaration is parsed
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document starts parsing
        def function(arglist);Fi[	@‹iI"‚        
        ###
        # Called when document starts parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document ends parsing
        def function(arglist);Fi[	@‹iI"        
        ###
        # Called when document ends parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element
        # * +name+ is the name of the tag;Fi[	@‹i I"\        # * +name+ is the name of the tag
        # * +attrs+ are an assoc list of namespaces and attributes, e.g.:
        #     [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the end of an element
        # +name+ is the tag name;Fi[	@‹i'I"        ###
        # Called at the end of an element
        # +name+ is the tag name
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element
        # +name+ is the element name;Fi[	@‹iHI"%        # times given one contiguous string of characters.
        #
        # +string+ contains the character data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when comments are encountered
        # +string+ contains the comment data;Fi[	@‹iOI"        ###
        # Called when comments are encountered
        # +string+ contains the comment data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document warnings
        # +string+ contains the warning;Fi[	@‹iVI"˘        ###
        # Called on document warnings
        # +string+ contains the warning
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document errors
        # +string+ contains the error;Fi[	@‹i]I"        ###
        # Called on document errors
        # +string+ contains the error
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when cdata blocks are found
        # +string+ contains the cdata content;Fi[	@‹idI"&        ###
        # Called when cdata blocks are found
        # +string+ contains the cdata content
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when processing instructions are found
        # +name+ is the target of the instruction;Fi[@+@,I"@var = var;FI"end;FI" ;Fi[[	@öiiI"Î      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?;Fi[	@ﬂibI"A        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##
        # Wrapper method for the #send_message (private) method;Fi[	@!iI"é    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@4iI"˜    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick
    # specs don't bother to include the arch in the platform string;Fi[	@Ñi=I"          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server);Fi[	@6iBI"ﬁ        var = ensure_array_of_array(rubify(var))
        var = var.transpose
        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        dup;Fi[	@Oi-I"Ú        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("\"%s\"" % @var.join(File::PATH_SEPARATOR))];Fi[	@RiI"      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var);Fi[	@›iùI"ˇ  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "#{@name.downcase} cannot be installed alongside #{@formula}.\n";Fi[	@ÑiI"“    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.
    def function(arglist);Fi[	@õi
I"ª    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing;Fi[	@9iI"      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created
      # and #save is called.;Fi[@I"raise(NotImplementedError);FI"end;FI" ;FI"def function(arglist);Fi[[	I"Ndata//activerecord_proj/active_record/associations/builder/association.rb;Ti9I"°      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options
    end;Fi[	@?ipI"      end
      
      # Do the relevant stuff to insert the given record into the association collection.
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        scope.scope_for_create.stringify_keys
      end;Fi[	@?iåI"a      
      # Delete the given records from the association, using one of the methods :destroy,
      # :delete_all or :nullify (or nil, in which case a default is used).
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        delete((target - var))
        unless concat((var - target)) then;Fi[	@RiI"           preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope
        end;Fi[	@∂i(I"¸        end
        
        # Must return the relevant concrete adapter
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          collation and collation.match(/_ci$/).!
        end;Fi[	@:iI"º        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@:iI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@:iI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@:iI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@:iI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@:i#I"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@çi&I"P    # @abstract This method is called when the user is on the request path. You should
    # perform any information gathering you need to be able to authenticate
    # the user in this phase.
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      self.class.uid_stack(self).last
    end;Fi[I"	self;FI"end;FI"end;FI"end;FI"end;Fi[[	I"<data//activemodel_proj/active_model/serializers/json.rb;TiÖI"ö        var = ActiveSupport::JSON.decode(var)
        var = var.values.first if var
        self.attributes = var
        self
      end
    end
  end
end;Fi[	@fi‘I"ß      #   person.awesome       # => true
      def function(arglist)
        self.attributes = Hash.from_xml(var).values.first
        self
      end
    end
  end
end;Fi[	@ÁiµI"Ø      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
      def function(arglist)
        proxy_association.reload
        self
      end
    end
  end
end;Ti[	@i¸I"¥          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	@\iTI"ê            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end
end;Fi[	@ui3I"©        # @since 2.0.0.rc.1
        def function(arglist)
          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	@êi I"ë              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end
end;Fi[	@ñiåI"ø        # @since 2.2.1
        def function(arglist)
          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	@úiI"¶        # @since 3.0.0
        def function(arglist)
          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	@Æi.I"é        # @since 2.3.0
        def function(arglist)
          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	@Œi§I"~            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end
end;Fi[	I"2data//twitter_proj/twitter/core_ext/kernel.rb;Ti
I"ò    # Returns the object's singleton class (exists in Ruby 1.9.2)
    def function(arglist)
      class << self
        self
      end
    end
  end
end;Fi[@'@(@@	I"@var = var;Fi[[	@–iI"Ó      # If it's not, it will execute the given block.
      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@!i?I"ÿ    def function(arglist)
      if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@PiI"~      var = var.delete(:prepend) ? (:prepend_before_filter) : (:before_filter)
      var.send(var, var.slice(:only, :except, :if, :unless)) do |arglist|
        var.class.cancan_resource_class.new(var, var, var.except(:only, :except, :if, :unless)).send(var)
      end
    end
    
    def function(arglist)
      @var = var
      @var = var.params
      @var = var.extract_options!;Fi[	@ÑiTI"¡                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var);Fi[	@ÑicI"ﬂ        
        def function(arglist)
          "#{condition.inspect} :: #{command.inspect}"
        end
      end
      
      def function(arglist)
        @var = var
        @var = []
        yield(self) if block_given?;Fi[	@+i I"+          Compass.configuration.sprite_load_path.each do |arglist|
            var = File.expand_path(var)
            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var;Fi[	@ıi1I"T          var.visit_steps(@var)
          @var = @var.detect { |arglist| (var.exception or var.status.!=(:passed)) }
          var.step_mother.after(hook_context) if (@var or @var.empty?)
        end
      end
      
      def function(arglist)
        @var = var
        init
        if self.!=(var) and var.respond_to?(:with_visitor) then;Fi[	@9iI"ø      class << self
        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var;Fi[	@i"I"é    mail(var) do |arglist|
      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var;Fi[	@¡i+I"      "      No available formula for #{$3} #{dependent_s}\n      Please tap it and then try again: brew tap #{$1}/#{$2}\n".undent
    else
      "No available formula for #{name} #{dependent_s}"
    end
  end
  
  def function(arglist)
    @var = var
  end
end;Fi[	@¿iÆI"’            end)
          rescue Nokogiri::SyntaxError, RuntimeError
            nil
          end
        end
        
        def function(arglist)
          @var = var
          @var = nil
          @var = nil;Fi[	@.i•I"£      @var = var
    else
      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[@¨@
I"@var = true;FI"end;FI" ;Fi[[	@BiI"≥        @var = var["version"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@Bi#I"‹      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def self.from_lock(arglist)
        new(var.merge("path" => (var.delete("remote"))));Fi[	@GiI"        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@GiI"≥      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash;Fi[	@Ji>I"∞      def function(arglist)
        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      ;Fi[	@JiHI"Œ      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?;Fi[	@Ñi&I"±        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true;Fi[	@Ei I"ì      def function(arglist)
        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      protected
      ;Fi[	I"+data//cucumber_prok/cucumber/errors.rb;TiI"¶      super("Undefined step: \"#{step_name}\"")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function
  end;Fi[	@üi3I"ÿ        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false;Fi[	@•i>I"∞        var ||= @var
        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      
      private
      ;Fi[	@i†I"¥      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false;Fi[@F@G@HI"end;FI"end;Fi[[	@ziÇI"æ          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	@£iI"¢        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@Ωi;I"√              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    ;Fi[	@‹ikI"µ          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	@4i5I"û      if Gem::Specification.new.respond_to?(var) then
        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	@ÑiQI"Ù              if configuration.respond_to?(var) then
                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        
        def function(arglist);Fi[	@¥iI"∑        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	@˙iI"∂        end
        def function(arglist)
          owner_class.set_callback(:validation, :after, "value", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	@˝ikI"ø          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Gdata//state_machine_proj/state_machine/integrations/data_mapper.rb;TiÜI"ç      # DataMapper/Extlib callbacks
      def function(arglist)
        var[:bind_to_object] = true
        super
      end
    end
  end
end;Fi[	@
iSI"ø          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/integrations/sequel.rb;Ti§I"±      def function(arglist)
        var[:bind_to_object] = true
        var[:terminator] = @var ||= lambda { |arglist| (var == false) }
        super
      end
    end
  end
end;Fi[@'@T@;I"@var = true;FI"end;Fi[[	@BiI"∫        @var = var["name"]
        @var = var["version"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@Bi"I"™      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def self.from_lock(arglist);Fi[	@GiI"	        @var = false
        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@GiI"§      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@Ji=I"∞      
      def function(arglist)
        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function;Fi[	@JiGI"¨      
      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@EiI"ì      
      def function(arglist)
        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      protected;Fi[	@ÏiI"∫    def function(arglist)
      super("Undefined step: \"#{step_name}\"")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function;Fi[	@üi2I"        write_file(feature_result_filename(var.file), @var.target!)
        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@•i=I"ƒ        return unless @var
        var ||= @var
        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      
      private;Fi[	@iüI"≠      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	I"9data//SiriProxy_proj/siriproxy/connection/guzzoni.rb;TiI"ì  
  def function(arglist)
    return plugin_manager.process_filters(var, :from_guzzoni)
  end
  
  def function(arglist)
    @var = true
  end
end;Fi[I"@var = true;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@i"I"          return if attribute_methods_generated?
          superclass.define_attribute_methods unless (self == base_class)
          super(column_names)
          @var = true
        end
      end
      
      def function(arglist)
        @var ||= false
      end;Fi[	@iVI"          Sass::Plugin.on_compilation_error do |arglist|
            Compass.configuration.run_stylesheet_error(var, var.message)
          end
          @var = true
        end
      end
      
      def function(arglist)
        configuration.to_sass_engine_options
      end;Fi[	@<ioI"U          @var.text!("makeRed('cucumber-header');") unless @var
          @var = true
          @var.text!("makeRed('scenario_#{@scenario_number}');") unless @var
          @var = true
        end
      end
      
      def function(arglist)
        @var.script do |arglist|
          @var.text!("makeYellow('cucumber-header');") unless @var;Fi[	@√i'I"(      if ["if", "case", "unless"].include?(var) then
        @var.push([var.to_sym, @var.tabs])
        (@var.last << false) if (var == "case")
        @var = true
      end
    end
    
    def function(arglist)
      @var = block_opened?
      ParseNode.new(:haml_comment, @var, :text => (var));Fi[	@o
iÓI"      puts("The formula built, but you may encounter issues using it or linking other")
      puts("formula against it.")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    begin
      (ohai("Cleaning") if ARGV.verbose?;Fi[	@o
iI"Y      opoo("The cleaning step did not complete successfully")
      puts("Still, the installation was successful, so we will link it into your prefix")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    var, var = f.fetch
    f.verify_download_integrity(var) unless var.local_bottle_path;Fi[	@o
i I"i      opoo("A top-level \"man\" directory was found.")
      puts("Homebrew requires that man pages live under share.")
      puts("This can often be fixed by passing \"--mandir=\#{man}\" to configure.")
      @var = true
    end
  end
  
  def function(arglist)
    if (f.prefix + "info").directory? then
      opoo("A top-level \"info\" directory was found.");Fi[	@o
i)I"p      opoo("A top-level \"info\" directory was found.")
      puts("Homebrew suggests that info pages live under share.")
      puts("This can often be fixed by passing \"--infodir=\#{info}\" to configure.")
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?
    var = f.lib.children.select { |arglist| var.to_s =~ /\.jar$/ };Fi[	@o
i8I"8      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?
    var = [".a", ".dylib", ".framework", ".jnilib", ".la", ".o", ".so", ".jar", ".prl", ".pm", ".sh"];Fi[	@o
iHI"+      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?
    var = f.bin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@o
iTI"/      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?
    var = f.sbin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@o
i`I"ﬁ      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars
    check_non_libraries;Fi[@'@(@@I"end;Fi[[	@¬i I"¬            Hash.===(var) ? (var.joins!(var)) : (var.joins!(*var))
          else
            var.send("#{k}!", var)
          end
        end
        var
      end
    end
    
    class Merger;Fi[	@'imI"¡            else
              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@á	iÑI"e        if @var.is_a?(Hash) and var = @var[var] then
          if var.enum and var.enum.include?(var).! then
            raise(MalformattedArgumentError, "Expected '#{name}' to be one of #{switch.enum.join(", ")}; got #{value}")
          end
        end
        var
      end
    end
    
    # Raises an error if @non_assigned_required array is not empty.;Fi[	@åi,I"±              warn("[err :: #{ch[:server]}] #{data}")
            else
              # do nothing
            end
          end
          var
        end
      end
    end
  end;Fi[	@…	iÄI"ë            end
            (var << "\n")
          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	@ri)I"ª          (var << stop.times(Sass::Script::Number.new(100, ["%"])).inspect)
        else
          (var << stop.inspect)
        end
      end
      var
    end
  end
  
  module Gradient;Fi[	@ iKI"ï        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@0iI"⁄                var.push(Factory.from_db(klass, var))
              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end;Fi[	@ieI"=          var.class.relations.values.each do |arglist|
            if (var.as == name) and (var.class_name == inverse_class_name) then
              var.push(var.name)
            end
          end
          var
        end
      end
      
      # For polymorphic children, we need to figure out the inverse from the;Fi[	@bi&I"§            end
            var = (var - 1) unless var.zero?
            var = {} if var.zero?
          end
        end
        var
      end
    end
    var
  end;Fi[	@⁄i4I"Ê        var.each do |arglist|
          if var = var.index(var) then
            var.delete_at(var)
          end
        end
        var
      end
    end
    
    OperatorMatcher.register(Array, "=~", Spec::Matchers::MatchArray);Fi[	@i%I"ã            else
              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end
end;Fi[@¨@
I"@var = false;FI"end;FI" ;Fi[[	@5	i_I"˚        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      
      # Returns the human-readable name of the adapter. Use mixed case - one
      # can always use downcase if needed.;Fi[	@Ã	ikI"¨      attr_reader :function
      
      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false;Fi[	@Ã	ioI"≠      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin;Fi[	@üi7I"ﬁ      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?;Fi[	@üiYI"±        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@•iI"Ω        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var;Fi[	@•i'I"ª        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var);Fi[	@®i"I"Á      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then;Fi[	@®i<I"±        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@√i´I"À      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["if", "case", "unless"].include?(var.value[:keyword]);Fi[	@ı
iI"√      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        Spec::Runner.configuration.mock_framework;Fi[@I"
false;FI"end;FI" ;FI"def function(arglist);Fi[[	@0	iI"å        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end;Fi[	@0	imI"ä        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end;Fi[	@5	i{I"V      # Does this adapter support DDL rollbacks in transactions? That is, would
      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end;Fi[	@>i#I"}      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end;Fi[	@>i'I"      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= ""
    end;Fi[	@_i9I"≈        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "#{options[:pattern_name]}/" if options[:pattern_name]
      end;Fi[	@ÄiI"µ      attr_reader(:line)
      
      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end;Fi[	@ÉiI"ó        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped
      end;Fi[	@ai2I"¬    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join(";")
  end;Fi[	@áiwI"ø  end
  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end;Fi[	@ái{I"Ñ    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("notifier.a_post_you_shared")
  end;Fi[@©I"
false;FI"end;FI"end;FI" ;Fi[[	@?iI"            load_target if options[:finder_sql]
            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end
      end
      
      def function(arglist)
        @var = merge_target_lists(find_target, target) if find_target?;Fi[	@iWI"—          else
            true
          end
        else
          false
        end
      end
      
      # Returns +true+ if +attribute+ is an attribute method and table exists,
      # +false+ otherwise.;Fi[	@]ièI"‘      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super);Fi[	@iivI"H      def function(arglist)
        if unlock_strategy_enabled?(:time) then
          locked_at and (locked_at < self.class.unlock_in.ago)
        else
          false
        end
      end
      
      # Checks whether the record is locked or not, yielding to the block
      # if it's locked, otherwise adds an error to email.;Fi[	@(iãI"‡    var = var.class.base_class.name
    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist)
    var = var.id.to_s;Fi[	@(iNI"«    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  
  def self.build(arglist)
    var = User.new(var);Fi[	@Si{I"      def function(arglist)
        if instance_variable_defined?("@#{name}") then
          return instance_variable_get("@#{name}")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.;Fi[	@Si≠I"%      def function(arglist)
        if instance_variable_defined?("@#{name}") then
          return remove_instance_variable("@#{name}")
        else
          false
        end
      end
      
      # Is the object's size changable? Only returns true for arrays and hashes
      # currently.;Fi[	I"?data//mongoid_proj/lib/mongoid/relations/nested_builder.rb;Ti'I"          (var.method(var).arity == 0) ? (var.send(var)) : (var.send(var, var))
        when Proc then
          var.call(var)
        else
          false
        end
      end
      
      # Determines if only updates can occur. Only valid for one-to-one
      # relations.;Fi[	@.iÁI"Ã  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then;Fi[	@vi@I"G      end.compact
      if (var.length == var.length) then
        TransitionCollection.new(var, :actions => (var)).perform
      else
        false
      end
    end
    
    # Builds the collection of transitions for all event attributes defined on
    # the given object.  This will only include events whose machine actions;Fi[@@∞I"	self;FI"end;FI" ;Fi[[	I"Hdata//capistrano_proj/capistrano/recipes/deploy/local_dependency.rb;TiI"ç        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@ßiTI"ç        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@iI"≥          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var;Fi[	@i I"√          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last;Fi[	I"3data//rspec_proj/spec/example/example_proxy.rb;Ti I")      
      # Convenience method for example group - updates the value of
      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        (var.description == description).&((var.location == location));Fi[	@ûiCI"˜        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@ûiHI"ô        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@ûiMI"ô        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@ûiRI"ô        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@ûiWI"§        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "change ##{@message}";Fi[	I"1data//rspec_proj/spec/matchers/respond_to.rb;Ti"I"¥        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self;Fi[@'@(@I"#:nodoc:;FI"def function(arglist);Fi[[	@∂i~I"‹          @var = Arel::Visitors::MySQL.new(self)
        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        self.class::ADAPTER_NAME
      end;Fi[	@∂iI"∑          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("COMMIT");Fi[	@∂iI"µ          execute("COMMIT")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("ROLLBACK");Fi[	@£imI"Õ          @var = Arel::Visitors::SQLite.new(self)
        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        "SQLite"
      end;Fi[	@ØivI"Ú          else
            compute_table_name
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        (parents.detect { |arglist| var.respond_to?(:table_name_prefix) } or self).table_name_prefix
      end;Fi[	@ØiëI"          @var ||= reset_sequence_name
        else
          (@var ||= nil or base_class.sequence_name)
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var = false
        @var = connection.default_sequence_name(table_name, primary_key);Fi[	@¢	i\I"            puts(format_text(var.description))
          end
          puts
        end
      end
      
      #:nodoc:
      def function(arglist)
        var = File.read(File.join(File.dirname("(string)"), "help.txt"))
        self.class.ui.page_at = (self.class.ui.output_rows - 2);Fi[	@6i–I"€          end
          var[0].value = var
          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          require("diff/lcs");Fi[	@OiµI"ˆ          else
            InProcessCucumberRunner.new(libs, var, feature_files)
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var ? ([cucumber_opts, "--profile", @var]) : (cucumber_opts)
      end;Fi[	@qiJI"ﬂ        true
      else
        instance.errors.none? { |arglist| var.to_s.start_with?(@var.to_s) }
      end
    end
    
    #:nodoc:
    def function(arglist)
      var = @var[:storage].to_s.downcase.camelize
      begin;Fi[	@ØiGI"          @var.delete(var)
        else
          raise(MockExpectationError, "The method `#{message}` was not stubbed or was already unstubbed")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          verify_expectations;Fi[@'@T@;@|I"end;Fi[[	@Çi7I"Œ      @var = model.create_reflection(macro, name, scope, options, model)
      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist);Fi[	@Çi[I">      end
      mixin.class_eval("        def #{macro}_dependent_for_#{name}\n          association(:#{name}).handle_dependency\n        end\n", "(string)", (102 + 1))
      model.before_destroy("#{macro}_dependent_for_#{name}")
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
  end
end;Fi[	@OiI"        
        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # An Arel::Table for the active_record;Fi[	@RiI"¸        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist);Fi[	@:iI"æ      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@:iI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@:iI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@:iI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@:iI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@:i!I"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@:i%I"≠      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end
  end;Fi[@'@(@I"attr_reader :function;FI" ;Fi[[	@)iﬂI"Ø            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?;Fi[	@GiFI"±      # the single-table inheritance discriminator.
      def function(arglist)
        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    ;Fi[	@”iI"          else
            raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      
      # Returns whether or not the association should be validated as part of
      # the parent's validation.;Fi[	@]i4I"¯      var.each do |arglist|
        @var[var.switch_name] = var
        var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist)
      return super unless @var;Fi[	@ä	iI"√          yield)
        ensure
          @var = false
        end
      end
      
      attr_reader :function
      
      # Sets the output padding, not allowing less than zero values.
      #;Fi[	@Øi:I"            end
          else
            LocalProxy.new(self)
          end
        end
        
        attr_reader :function
        
        # Returns the string used to identify the latest revision in the
        # repository. This will be passed as the "revision" parameter of;Fi[	@˙iÈI"¥            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then;Fi[	@Gi0I"ﬁ      @var = (HOMEBREW_CACHE + (@var + ext))
    else
      @var = (HOMEBREW_CACHE + File.basename(@var))
    end
  end
  
  attr_reader :function
  
  # Private method, can be overridden if needed.
  def function(arglist);Fi[	@itI"å      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function
  
  def function(arglist)
    case @var;Fi[	I"'data//rescue_proj/resque/worker.rb;TiII"Õ        end
      rescue SystemCallError
        Resque.logger.debug("Child #{@child} already quit and reaped.")
      end
    end
    
    attr_reader :function
    
    alias :paused? :should_pause?
    ;Fi[	I"'data//twitter_proj/twitter/base.rb;TiFI"î        send(var.to_sym)
      rescue NoMethodError
        nil
      end
    end
    
    attr_reader :function
    
    alias :to_hash :attrs
    ;Fi[I"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;FI" ;Fi[[	@ﬂiI"Â      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@‚i/I"·        @var ||= "yellow"
        @var ||= "yellow"
        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@îinI"Â      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@•iI"	      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@®iI"Î      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@´iI"‹      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@ÂiI"Î        super(var, var)
        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage;Fi[	@Ëi$I"Ú        super(var, var)
        @var ||= "backups"
        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # The initial connection to Dropbox will provide the user with an;Fi[	@ÛiI"Ì      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage;Fi[	@ˆiI"Á      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage;Fi[@¨@
@fI"	self;FI"end;Fi[[	@√iI"ß        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@ßiSI"í        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@iI"º        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@iI"≠          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@ûiBI"       def function(arglist)
        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@ûiGI"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@ûiLI"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@ûiQI"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@ûiVI"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@Ÿi!I"√      def function(arglist)
        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[I"var = 0;FI"var = 0;FI"var = 0;FI"var = 1;FI"while (var < var) do;Fi[[	@•ioI"¿      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@•i≥I"‡    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@®idI"∏      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@®iÆI"ÿ    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@´i^I"¿      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@´i¢I"‡    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@.iEI"ù    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[	@.iãI"ª    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[	@1i>I"ù    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[	@1ißI"û      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[@+I"	self;FI"end;FI" ;FI"def function(arglist);Fi[[	@iI"≠        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self;Fi[	@i!I"√        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last
          self;Fi[	@Ãi!I",      # Convenience method for example group - updates the value of
      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        (var.description == description).&((var.location == location))
      end;Fi[	@ûiDI"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@ûiII"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@ûiNI"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@ûiSI"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@ûiXI"°      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "change ##{@message}"
      end;Fi[	@◊iSI"—          @var = var.pluralize(var.to_s)
        end
        @var = var
        @var = var
        self
      end
      
      def function(arglist)
        "#{relativities[@relativity]}#{@expected}"
      end;Fi[	@Ÿi#I"ê      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end;Fi[@'@(@)@	I"##;Fi[[	@Âi5I"ë          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@ËiWI"Ñ          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@ÎiAI"î          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@Ûi=I"Ü          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@ˆi8I"´          Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to bucket '#{bucket}'."))
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@˘i5I"ú          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@¸i3I"ò          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@ÿiI"          @var = Backup::Binder.new(var).get_binding
        else
          @var = nil
        end
      end
    end
    
    ##
    # Renders the provided file (in the context of the binding if any) to the console
    def function(arglist);Fi[	@pi%I"∞          finish(var, var)
          var.delete(var.object_id) if var
        end
      end
    end
  end
  
  ##
  # Creates a new connection for +uri+
  def function(arglist);Fi[	@piëI"¨        Net::HTTP
      else
        Net::HTTP::Persistent::SSLReuse
      end
    end
  end
  
  ##
  # Returns the HTTP protocol version for +uri+
  def function(arglist);Fi[I"var = -1;FI"var = var;FI"var = 0;FI"if (var == 1) then;FI"@var = @var;Fi[[	@•iΩI"9      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@•i€I"K          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@®i∏I"3      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@®i„I"K          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@´i¨I"9      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@´i I"K          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@.iîI";      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@.iµI",          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@1i∞I"&      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[	@1iŒI"          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[@¨@
I"@var[var];FI"end;FI" ;Fi[[	@6i™I"ﬁ          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var);Fi[	@)i}I"ê    end
    
    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist)
      @var[(var or false)] ||= {};Fi[	@'iNI"ƒ      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "#{name} (#{version})";Fi[	@∑	i~I"√      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	I"1data//cucumber_prok/cucumber/ast/features.rb;TiI"±      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var);Fi[	@6iAI"»        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line;Fi[	@˙i0I"º        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	@¢i›I"€        var[(1..-1)].each { |arglist| @var.puts("    #{s}") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var);Fi[	@ŒiâI"È        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({});Fi[	@˘iAI"∑          @var = Hash.new(var)
          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        
        protected
        ;Fi[@¨@
@≠@ÆI"end;Fi[[	@Pi'I"è    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"Edata//cancan_proj/generators/cancan/ability/templates/ability.rb;TiI"cclass Ability
  include(CanCan::Ability)
  
  def function(arglist)
    # do nothing
  end
end;Fi[	@ÄiI"¬        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@6iI"∂        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable);Fi[	@Mi[I"ê      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    
    class JsLanguage;Fi[	@biI"˙        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize);Fi[	@íi&I"Ï    var = "#{truncated}#{url}"
    return var
  end
  
  def function(arglist)
    # do nothing
  end
end
require(Rails.root.join("app", "models", "services", "facebook"))
require(Rails.root.join("app", "models", "services", "twitter"));Fi[	@ŒiI"¢        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@—iI"¢        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@⁄iI"Ü        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[@¨@
@f@TI"end;Fi[[	@ßiI"ƒ      
      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@}iI"’      
      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@:i	I"√  module ConnectionAdapters
    class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@…i˘I"ú    end
    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[	@±iI"ïmodule Backup
  class Splitter
    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##;Fi[	@Ai(I"      def self.matches_condition?(arglist)
        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@™isI"Ú            var = (var[3] or "highest")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@œ	iI"¿      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@Xi
I"û  include(PostsHelper)
  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@}iI"“require(Rails.root.join("lib", "template_picker"))
class PostPresenter
  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def self.collection_json(arglist);Fi[@'@œ@–@—I"private;Fi[[	@1i6I"£        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send);Fi[	@ÑiI"%        else
          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist);Fi[	@tiI"]        var = super
        chain[(1..-1)].each do |arglist|
          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      
      # Construct attributes for :through pointing to owner and associate. This is used by the;Fi[	@ˇi©I"         var = self.class.reflect_on_association(var)
        var = var.association_class.new(self, var)
        association_instance_set(var, var)
      end
      var
    end
    
    private
    
    # Returns the specified association instance if it responds to :loaded?, nil otherwise.;Fi[	@…i√I"v          end
        end
        var
      end
      var
    end
    
    private
    
    def function(arglist);Fi[	@riTI"ø        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist);Fi[	@iNI"Å    var = self
    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist);Fi[	@@i`I"≥        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist);Fi[	@1iáI"◊        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist);Fi[	@6iíI"≈            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.;Fi[@©@r@s@tI"end;Fi[[	@ziÅI"ÿ        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end;Fi[	@êi0I"Ó            if var then
              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist);Fi[	@£iI"ª        case var.message
        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@Ωi:I"Ë            if arel.respond_to?(var) then
              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end;Fi[	@‹ijI"…        if var then
          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	@4i4I"∏    def function(arglist)
      if Gem::Specification.new.respond_to?(var) then
        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	@ÑiPI"Á            else
              if configuration.respond_to?(var) then
                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        ;Fi[	@ii]I"Œ        else
          if lock_strategy_enabled?(:failed_attempts) and attempts_exceeded? then
            :locked
          else
            super
          end
        end
      end
      
      protected;Fi[	@¥iI"⁄        var = var.fields[var.to_s]
        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	I"/data//paperclip_proj/paperclip/tempfile.rb;TiI"“        end
        var = Time.now.strftime("%y%m%d")
        var = "#{prefix}#{t}-#{$$}-#{rand(4294967296).to_s(36)}-#{n}#{suffix}"
      else
        super
      end
    end
  end
  
  module TempfileEncoding;Fi[@'@T@;@ØI"	self;Fi[[	@√iI"‹        @var ||= "`#{command}' could not be found in the path on the local host"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ßiRI"ç          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@iI"»      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        ;Fi[	@iI"≠        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        ;Fi[	@ûiAI"Î      
      def function(arglist)
        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ûiFI"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ûiKI"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ûiPI"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ûiUI"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@Ÿi I"Æ      
      def function(arglist)
        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[I"var = var;FI"var = 0;F@≠I"@var = @var;FI"!var = ((@var - @var) - @var);Fi[[	@•iæI"%        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@•i‹I"          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@®iπI"%        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@®i‰I"          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@´i≠I"%        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@´iÀI"          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@.iïI"(        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@.i∂I"Ò          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@1i±I"        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[	@1iœI"ﬂ          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[I"
false;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@?iI"˛            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end
      end
      
      def function(arglist)
        @var = merge_target_lists(find_target, target) if find_target?
        loaded!;Fi[	@ÉißI"          (@var.respond_to?(:stat) ? (@var.stat) : (@var.query("select 1"))
          @var.respond_to?(:errno) ? (@var.errno.zero?) : (true))
        rescue Mysql::Error
          false
        end
      end
      
      def function(arglist)
        super
        disconnect!;Fi[	@]iêI"Ã      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super)
    end;Fi[	@iiSI"º          else
            save(:validate => (false))
          end
          false
        end
      end
      
      def function(arglist)
        if Devise.paranoid then
          super;Fi[	@(iåI"‡    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist)
    var = var.id.to_s
    var = var.class.base_class.to_s;Fi[	@¿iäI"      unless ((var.errno == Errno::ENOTEMPTY::Errno) or ((var.errno == Errno::EACCES::Errno) or (var.errno == Errno::ENOENT::Errno))) then
        raise
      end
      false
    end
  end
  
  def function(arglist)
    require("fileutils")
    FileUtils.chmod_R(var, to_s);Fi[	@i≤I"'        begin
          original_filename ? (s3_object(var).exists?) : (false)
        rescue AWS::Errors::Base => var
          false
        end
      end
      
      def function(arglist)
        var = (@var[var] or @var[:default])
        var = var.call(self, var) if var.respond_to?(:call);Fi[	@.iËI"≈    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var;Fi[	@Ài{I"√          begin
            @var.tty?
          rescue NoMethodError
            false
          end
        end
        
        def function(arglist)
          colour(var, "\e[32m")
        end;Fi[	@i"I"!          send(var.to_sym, var, var.options)
          true)
        rescue Twitter::Error::NotFound, Twitter::Error::Forbidden
          false
        end
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop);Fi[@I"0;FI"end;FI" ;FI"def function(arglist);Fi[[	@0	iI"∆    end
    
    class ClosedTransaction < Transaction
      def function(arglist)
        0
      end
      
      def function(arglist)
        RealTransaction.new(connection, self, var)
      end;Fi[	@>iI"s      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@>iI"r      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@>iI"r      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@>iI"u      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[	@>i3I"s      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@>i7I"}      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@íiI"v      ""
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[	@√iuI"î      
      # Where in the X area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        if show_data_values then
          @var.add_element("text", "x" => (var.to_s), "y" => (var.to_s), "class" => "dataPointLabel", "style" => ("#{style} stroke: #fff; stroke-width: 2;")).text = var.to_s;Fi[	@√i™I",      
      # Where in the Y area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        ((@var.to_f - ((font_size * 2) * right_font)) / (get_x_labels.length - right_align))
      end;Fi[@I"@var = false;FI"end;FI" ;FI"def function(arglist);Fi[[	@Ã	ilI"ö      
      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@Ã	ipI"ß        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin
          (@var = var;Fi[	@üi8I"„        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?
        var = var.split(/\r?\n/);Fi[	@üiZI"µ        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
        @var = Time.now;Fi[	@•iI"¿        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var
        @var = false;Fi[	@•i(I"¨        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var)
        @var = var;Fi[	@®i#I"Ë        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then
          (@var << var.line);Fi[	@®i=I"ß        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
      end;Fi[	@√i¨I"Ó      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["if", "case", "unless"].include?(var.value[:keyword])
      return unless (var.value[:keyword] == "case");Fi[	@ı
iÄI"√      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        Spec::Runner.configuration.mock_framework
      end;Fi[@°I"$# @example Do the values match?;FI")#   matcher.matches?({ :key => 10 });FI"#;FI"1# @param [ Hash ] value The values to check.;Fi[[	I"3data//mongoid_proj/lib/mongoid/matchers/all.rb;Ti	I"F  module Matchers
    class All < Default
      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If the values match.;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/gt.rb;Ti	I"7  module Matchers
    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/gte.rb;Ti	I"D  module Matchers
    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/in.rb;Ti	I".  module Matchers
    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/lt.rb;Ti	I"4  module Matchers
    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/lte.rb;Ti	I"A  module Matchers
    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/ne.rb;Ti	I";  module Matchers
    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/nin.rb;Ti	I"7  module Matchers
    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	I"4data//mongoid_proj/lib/mongoid/matchers/size.rb;Ti	I"@  module Matchers
    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[@'@T@;I"@var[var];FI"end;Fi[[	@6i©I"Œ          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist);Fi[	@'iMI"¨      
      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@∑	i}I"≤      
      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@“iI"†      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@6i@I"∫        
        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist);Fi[	@˙i/I"∂        @var = []
        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@¢i‹I"Œ        @var.puts
        var[(1..-1)].each { |arglist| @var.puts("    #{s}") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@ŒiàI"∫        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist);Fi[	@˘i@I"√          var = @var
          @var = Hash.new(var)
          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        
        protected;Fi[@I"@var[var];FI"end;FI" ;FI"def function(arglist);Fi[[	@6i´I"Ã            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var)
          end;Fi[	@)i~I"≤    
    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist)
      @var[(var or false)] ||= {}
      @var[(var or false)][var] ||= begin;Fi[	@'iOI"≤        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "#{name} (#{version})"
      end;Fi[	@∑	iI"±        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	@“iI"ü        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end;Fi[	@6iBI"∂          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line
        end;Fi[	@˙i1I"ß        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	@¢iﬁI"∫        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var)
        print_snippets(@var);Fi[	@ŒiäI"„          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({})
          case var.to_s;Fi[@¨I"private;FI" ;F@WI"
begin;Fi[[	@öi%I"±    end
    
    (alias :attributes= :assign_attributes)
    
    private
    
    def function(arglist)
      begin
        public_send("#{k}=", var)
      rescue NoMethodError;Fi[	@$i'I"∏      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip
      rescue Errno::ENOENT;Fi[	@ßi`I"ﬂ        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var
          configuration.invoke_command(var, var) do |arglist|;Fi[	@9i<I"˙        Cucumber.logger = @var.log
        @var
      end
      
      private
      
      def function(arglist)
        begin
          (return false unless configuration.drb?
          @var = DRbClient.run(@var, @var, @var, configuration.drb_port);Fi[	@ƒi4I"Í      def function(arglist)
        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin
          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var;Fi[	@@i-I"ë      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir[".git/*"].empty? then
        safe_system("git init");Fi[	@}iI"V      var = GeometryParser.new(geometry_string.strip).make
      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin
        silence_stream(STDERR) do |arglist|
          Paperclip.run("identify", "-format '%wx%h,%[exif:orientation]' :file", :file => ("#{path}[0]"));Fi[	@∏i
I"˚    def function(arglist)
      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find_ids(var);Fi[	@	i[I"    def function(arglist)
      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin
        connection.send(var.to_sym, var, var) do |arglist|
          var.headers[:authorization] = auth_header(var.to_sym, var, var).to_s;Fi[@I"var;FI"end;FI"end;FI" ;Fi[[	@ÉiÏI"¬            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type
          def function(arglist);Fi[	@ÉiÚI"¬        end
        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Integer < Type
          def function(arglist);Fi[	@6iI"¬            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type
          def function(arglist);Fi[	@6iI"¿        end
        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Bytea < Type
          def function(arglist);Fi[	@6i=I"M          # FIXME: this should probably split on +delim+ and use +subtype+
          # to cast the values.  Unfortunately, the current Rails behavior
          # is to just return the string.
          def function(arglist)
            var
          end
        end
        
        class Array < Type
          attr_reader(:subtype);Fi[	@ãiµI"ﬁ      end
      
      class LogFormatter < ::Logger::Formatter
        def function(arglist)
          var
        end
      end
      
      def function(arglist)
        @var[:env_vars].each { |arglist| ENV[var] = var };Fi[	@<iI"Õ      
      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin
          (require("syntax/convertors/html");Fi[	@¶iëI"ú      include(Base)
      
      # @see Base#render
      def function(arglist)
        var
      end
    end
    
    module Javascript
      include(Base);Fi[	@„i
I"€    module Formatter
      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin
          (require("syntax/convertors/html");Fi[@I"@var ||= [];FI"end;FI" ;FI"def function(arglist);Fi[[	@9i1I"      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, ".git")) then
        var = Dir.chdir(full_gem_path) { |arglist| `git rev-parse HEAD`.strip };Fi[	@PiWI"         @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|
          proc do |arglist|;Fi[	@i%I".          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end;Fi[	@i)I"ÿ          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then
            var = var.stringify_keys;Fi[	@˘iI"          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|
            var.register_example_group(var);Fi[	I":data//rspec_proj/spec/example/module_reopening_fix.rb;TiI"¿module Spec
  module Example
    module ModuleReopeningFix
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (child_modules << var)
      end;Fi[	@Ãi!I"–        
        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          var = find(var.description)
          return false unless var;Fi[	@≤iﬁI"∞        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var)
      end;Fi[	@iùI"õ      end
      
      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end;Fi[@'@T@;I"0;FI"end;Fi[[	@>iI"}    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@>iI"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@>iI"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@>iI"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@>i1I"}    
    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@>i5I"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	I"Pdata//cucumber_prok/cucumber/core_ext/disable_mini_and_test_unit_autorun.rb;TiI"ü    class MiniTest::Unit
      class << self
        @@installed_at_exit = true
      end
      
      def function(arglist)
        0
      end
    end
  end);Fi[	@siI"ö    class Stepdefs < Usage
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0
      end
    end
  end;Fi[	@íiI"}    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[@AI"end;FI" ;F@DI"def function(arglist);Fi[[	@	iI"@      def self.included(arglist)
        var.send(:attr_accessor, :inherited_data, :set_attributes, :top_level)
        var.send(:include, InstanceMethods)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          var.each do |arglist|
            var = (20 + 1);Fi[	@ri1I"H  
  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end;Fi[	@	i	I"R  module Acts
    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          unless self.included_modules.include?(Redmine::Acts::ActivityProvider::InstanceMethods) then
            cattr_accessor(:activity_provider_options);Fi[	@i	I"  module Acts
    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          cattr_accessor(:attachable_options)
          self.attachable_options = {};Fi[	@i	I""  module Acts
    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Customizable::InstanceMethods) then
            return;Fi[	@i	I"  module Acts
    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Event::InstanceMethods) then
            return;Fi[	@"i	I"  module Acts
    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Watchable::InstanceMethods) then
            return;Fi[	@Æi
I"    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var);Fi[	@niI"∆module Redmine
  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = nil
        begin;Fi[@õ@úI" ;FI"def function(arglist);FI"@var = var;Fi[[	@√iI"Ò      def function(arglist)
        @var ||= "`#{command}' could not be found in the path on the local host"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@ßiQI"Ó          @var = "the output #{output.inspect} from #{command.inspect} did not match #{expect.inspect}"
          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@˚i#I"!        
        def function(arglist)
          @var = var.flatten
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class)
          @var and (@var and (allowed_types_allowed? and rejected_types_rejected?));Fi[	@iI"≠        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@i'I"9        
        def function(arglist)
          @var, @var = var.first, var.last
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class)
          lower_than_low? and (higher_than_low? and (lower_than_high? and higher_than_high?));Fi[	@ûiEI"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@ûiJI"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@ûiOI"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@ûiTI"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[@'I"	self;FI"end;FI" ;F@Éi[[	@iI"P      def function(arglist)
        var.each do |arglist|
          (join_associations.detect { |arglist| (var == var) } or build(var.reflection.name, (var.find_parent_in(self) or join_base), var.join_type))
        end
        self
      end
      
      def function(arglist)
        join_parts.last((join_parts.length - 1))
      end;Fi[	@)iiI"—          @var[var.name] -= var
        end
        (@var[var.name] << var)
      end
      self
    end
    
    def function(arglist)
      @var.inject(@var.size) { |arglist| var = (var + var.size) }
    end;Fi[	@ZiEI"˛          var = @var
          while var = var.next do
            yield([var.key, var.value])
          end
          self
        end
        
        def function(arglist)
          var = self.class.new
          self.each { |arglist| var[var] = var };Fi[	@ßiPI"          var = var[var.first]
          @var = "the output #{output.inspect} from #{command.inspect} did not match #{expect.inspect}"
          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@	ioI"Á            self.inherited_data.inherit_from!(var)
          else
            self.inherited_data = var
          end
          self
        end
        
        def function(arglist)
          self.inherited_data = nil
        end;Fi[	@àiåI"˝          send_to_all("after_#{message}", *var)
        else
          send_to_all(var, *var)
        end
        self
      end
      
      def function(arglist)
        @var.each { |arglist| var.__send__(var, *var) if var.respond_to?(var) }
      end;Fi[	@˙iI"        else
          @var[:formats] += var[:formats]
          @var[:formats] = (stdout_formats[(0..0)] + non_stdout_formats)
        end
        self
      end
      
      def function(arglist)
        require("gherkin/i18n")
        @var.write(Gherkin::I18n.get(var).keyword_table);Fi[	@4i>I"•          return
        end
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.parent_author_signature, self.parent.author)
  end;Fi[	@7i^I"R        Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.sender_handle} payload_type=#{self.class}")
        return
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.target_author_signature, self.target.author)
  end;Fi[@@@I"end;FI"end;Fi[[	@Pi(I"z      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"0data//bundler_proj/bundler/gem_installer.rb;TiI"ërequire("rubygems/installer")
module Bundler
  class GemInstaller < Gem::Installer
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"'data//jekyll_proj/jekyll/plugin.rb;Ti&I"î    # config - The Hash of configuration options.
    #
    # Returns a new instance.
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@2iI"êmodule Nokogiri
  module XML
    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@‹ilI"˙        # Called when processing instructions are found
        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@»ièI"‡        end
        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@ŒiI"à          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@—iI"à          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@⁄iI"~        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[@'@T@;I"@var = false;FI"end;Fi[[	@5	i^I"Ï      def function(arglist)
        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      
      # Returns the human-readable name of the adapter. Use mixed case - one;Fi[	@Ã	inI"¶      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@üi6I"•      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@üiXI"≤      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@•iI"≠        @var.puts
        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@•i&I"¡      def function(arglist)
        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@®i!I"§      
      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@®i;I"≤      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@√i™I"ï      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist);Fi[@Ω@æI"#;F@¿I"#;Fi[[	@√i
I"P    class All < Default
      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If the values match.
      def function(arglist);Fi[	@∆i
I"A    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@…i
I"N    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@Ãi
I"8    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@œi
I">    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@“i
I"K    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@’i
I"E    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@ÿi
I"A    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@€i
I"J    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[I"#   end;FI"#;FI" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;Ti[[	@Ái:I"U      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@Ái[I"B      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁitI"E      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁiëI"-      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@Ái±I"U      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁiÕI"B      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁiÈI"E      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁiI"-      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@Ái!I"-      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@°@äI"return @var;FI"end;FI" ;Fi[[	@1i†I"µ  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale)
  ;Fi[	@1i¨I"∞  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth)
  ;Fi[	@1i∏I"≥  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight)
  ;Fi[	@1iƒI"ª  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin)
  ;Fi[	@1i–I"∂  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor)
  ;Fi[	@1ißI"¢  	# @return int page number
  	# @since 1.0
  	# @see alias_nb_pages()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:page_no, :PageNo)
  ;Fi[	@1i¨I"Ø  	# @return boolean
  	# @since 1.4
  	# @see SetAutoPageBreak()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:accept_page_break, :AcceptPageBreak)
  ;Fi[	@1ieI"ö  	# @return float
  	# @since 1.2
  	# @see SetX(), GetY(), SetY()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_x, :GetX)
  ;Fi[	@1i}I"ö  	# @return float
  	# @since 1.0
  	# @see SetY(), GetX(), SetX()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_y, :GetY)
  ;Fi[@æI"#;F@¿I"#;FI"1# @return [ true, false ] If a value exists.;Fi[[	I"6data//mongoid_proj/lib/mongoid/matchers/exists.rb;TiI"(      # non-existence.
      #
      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first);Fi[	@∆iI"E      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>);Fi[	@…iI"R      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=);Fi[	@ÃiI"@      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var);Fi[	@œiI"B      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<);Fi[	@“iI"O      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=);Fi[	@’iI"P      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first);Fi[	@ÿiI"u      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) };Fi[	@€iI"Y      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first);Fi[@°@ˆI"#   person.pets;TI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[[	@Ái;I"ç      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái\I"z      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁiuI"}      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁiíI"e      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái≤I"ç      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁiŒI"z      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁiÍI"}      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁiI"e      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái"I"e      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[I" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;T@>I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[[	@Ái<I"r      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@Ái]I"_      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁivI"b      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiìI"J      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@Ái≥I"r      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiœI"_      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiÎI"b      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiI"J      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@Ái#I"J      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@°@¿I"#;F@&I"def function(arglist);Fi[[	@)iI"      #
      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first)
      end;Fi[	@∆iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>)
      end;Fi[	@…iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=)
      end;Fi[	@ÃiI"Y      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var)
        var.values.first.any? { |arglist| var.any? { |arglist| var.===(var) } };Fi[	@œiI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<)
      end;Fi[	@“iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=)
      end;Fi[	@’iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first)
      end;Fi[	@ÿiI"@      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) }
      end;Fi[	@€iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first)
      end;Fi[@¨@
@|I"end;FI" ;Fi[[	@Çi8I"•      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options;Fi[	@OiI"        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # An Arel::Table for the active_record
        def function(arglist);Fi[	@RiI"        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope;Fi[	@:iI"≈        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@:iI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@:iI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@:iI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@:iI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@:i"I"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[@I"(@var << var);FI"end;FI" ;FI"def function(arglist);Fi[[	@¥i$I"±        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init;Fi[	@Ÿ	iI"»        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self }
      end;Fi[	@6iI"¥          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@<i3I"∆        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?
        @var.each do |arglist|;Fi[	@∑iI"†        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@äi6I"W      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "\n<fieldset#{" style='#{options[:style]}'" if options[:style]}#{" id='#{options[:id]}'" if options[:id]}>\n  <legend>#{legend}</legend>\n")
      self.instance_eval(&var);Fi[	I"/data//rspec_proj/spec/mocks/order_group.rb;TiI"µ        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var)
      end;Fi[	@ı
i/I"§        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!
      end;Fi[I"	true;FI"end;FI"end;FI"end;FI"end;Fi[[	@~i·I"≤        if File.exist?(var) then
          return yes?("A file already exists at '#{path}'. Do you want to overwrite? [y/n]")
        end
        true
      end
    end
  end
end;Fi[	@6iÇI"n        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@<i§I"¨        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array);Fi[	@Pi¡I"™        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash);Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/and.rb;TiI"ó            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/persistence/deletion.rb;TiI"è        document.destroyed = true
        IdentityMap.remove(document)
        Threaded.clear_options!
        true
      end
    end
  end
end;Fi[	@©i&I"à              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end
end;Fi[	@ßi‰I"‚        end
        var.class.changed if var.class.respond_to?(:changed)
        var.class.notify_observers("update_with_transition", ObserverUpdate.new("#{type}_transition", var, var))
        true
      end
    end
  end
end;Fi[I"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;FI"#     end;FI"#   end;Fi[[	@˛iI"˙    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events;Fi[	@˛iDI"Ú    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events;Fi[	@˛idI"9    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">;Fi[	@ iI"        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@ iYI"        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@ i}I"        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	I"9data//state_machine_proj/state_machine/transition.rb;TiÂI"—    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new;Fi[	@⁄i˛I"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">;Fi[@'@T@;I"(@var << var);FI"end;Fi[[	@¥i"I"´          var.init
          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@Ÿ	iI"ß      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@6iI"∏        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist);Fi[	@<i1I"Ã        build_cell(@var, var, var)
        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@∑iI"§      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@äi4I"»    def function(arglist)
      @var = true
      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist);Fi[	@©iI"∑      def function(arglist)
        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@ı
i-I"©        @var = []
        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[I"@var = @var;F@WI"/var = (((var - (2 * @var)) * 1000) / @var);FI"end;FI"var = (var + 1);Fi[[	@•i¡I"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@•iﬂI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@®iºI"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@®iÁI"˜        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var);Fi[	@´i∞I"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@´iŒI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@.iòI"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@.iπI"ı        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1);Fi[@'@(@I"##;FI"I# Removes the transferred archive file(s) from the storage location.;Fi[[	@Âi6I"É          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@ËiXI"v          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@ÎiBI"•            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@i!I"o          var = File.join(local_path, var)
          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@Ûi>I"x          File.open(File.join(local_path, var), "r") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@ˆi9I"Ä          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@˘i6I"≠            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@¸i4I"©            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[@'@T@;I"@var.empty?;FI"end;Fi[[	@Æi8I"Æ      rescue Exception => var
        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end
    
    ##;Fi[	@ZiNI"’          self.each { |arglist| var[var] = var }
          var.each { |arglist| var[var] = var }
          var
        end
        
        def function(arglist)
          @var.empty?
        end
      end
    end;Fi[	@á	i7I"®    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist);Fi[	I"8data//cucumber_prok/cucumber/ast/step_collection.rb;Ti,I"«      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist);Fi[	@bidI"      def function(arglist)
        load_programming_language("rb") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist);Fi[	@iI"å  def function(arglist)
    @var = var
    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function;Fi[	@i©I"ï  
  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist);Fi[	@UiI"Ä  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist);Fi[@¨@
I"@var = [];FI"end;FI" ;Fi[[	@“iI"±      include(Enumerable)
      
      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var];Fi[	@6iI"ª      
      class Builder
        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var);Fi[	@ôi™I"∞        @var.puts(format_string(var, :tag).indent(@var))
        @var.flush
      end
      
      def function(arglist)
        @var = []
      end
      
      private
      ;Fi[	@<iDI"         @var.td(:class => "message") { |arglist| (@var << @var.join(", ")) }
        empty_messages
      end
      
      def function(arglist)
        @var = []
      end
      
      protected
      ;Fi[	@∑i
I"œ  module PySupport
    class PyLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var);Fi[	@_iI"“  module WireSupport
    class WireLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing;Fi[	I""data//homebrew_proj/debrew.rb;TiI"µ  attr_accessor(:prompt)
  
  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist)
    (entries << { :name => (var), :action => (var) });Fi[	I";data//paperclip_proj/paperclip/io_adapters/registry.rb;TiI"£    end
    
    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      (@var << [var, var]);Fi[@»I"#       end;FI"#     end;FI"#   end;FI"#;Fi[[	@˛i I"◊    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events
    #   ;Fi[	@˛iEI"œ    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events
    #   ;Fi[	@˛ieI"`    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">
    #   events = Vehicle.state_machine.events;Fi[	@ iI""        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@ iZI""        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@ i~I".        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|;Fi[	@⁄iÊI"7    #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[	@⁄iˇI"z    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[@¨I"module ClassMethods;FI"I# Convert the object from its mongo friendly ruby type to this type.;FI"#;FI"&# @example Demongoize the object.;Fi[[	@?i I"      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Object.demongoize(object)
        #;Fi[	@Ei I"      def function(arglist)
        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Date.demongoize(object)
        #;Fi[	@Ji&I"      def function(arglist)
        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   DateTime.demongoize(object)
        #;Fi[	@Yi,I"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Range.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@_iI"%      def function(arglist)
        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Set.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@bi£I"ˆ          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   String.demongoize(object)
        #;Fi[	@eiI"      def function(arglist)
        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Symbol.demongoize(object)
        #;Fi[	@miI"2      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   TimeWithZone.demongoize(object)
        #;Fi[@¨@
I"@var ||= [];FI"end;FI" ;Fi[[	@9i0I"“    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, ".git")) then;Fi[	@MiI"˘      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end
    
    # Returns an array of Rule instances which match the action and subject
    # This does not take into consideration any hash conditions or block statements;Fi[	@PiVI"       def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|;Fi[	@i$I"@        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= [];Fi[	@i(I"—        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then;Fi[	@˘iI"Ì          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|;Fi[	@Ãi I"∫        end
        
        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          var = find(var.description);Fi[	@≤i›I"¬      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var);Fi[@
 I"6# Any error raised will be rescued during Cycling;FI"B# and a warning will be logged, containing the error message.;FI"def function(arglist);FI"var = remote_path_for(var);Fi[[	@Âi:I"¬      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|
          Logger.message(("#{storage_name} started removing '#{local_file}' " + "from container '#{container}'."));Fi[	@Ëi\I"`      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@ÎiFI"q      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[	@i%I"`      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@ÛiBI"[      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then
          var = [];Fi[	@ˆi=I"m      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock
        transferred_files_for(var) do |arglist|;Fi[	@˘i:I"`      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@¸i8I"q      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[@'@(@@	I"case var;Fi[[	@∂i?I"æ            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var
          when /blob|text/i then
            case var;Fi[	@ãiÜI"¯            "NULL"
          else
            (var == "") ? ("\"\"") : (("\"%s\"" % var.to_s.gsub(/(["\\])/, "\\\\\\1")))
          end
        end
        
        def function(arglist)
          case var
          when "NULL" then
            var;Fi[	@≈i»I"-      (var - var).each do |arglist|
        var = Arel.sql(var) if String.===(var)
        var.where(Arel::Nodes::Grouping.new(var))
      end
    end
    
    def function(arglist)
      case var
      when String, Array then
        [@var.send(:sanitize_sql, (var.empty? ? (var) : (([var] + var))))];Fi[	@|i≤I"Ú          options[var].keys.each do |arglist|
            options[var][var] = coerce_variable(options[var][var])
          end
        end
      end
      
      def function(arglist)
        case var
        when /^"(.*)"$/ then
          $1;Fi[	@Ui¡I"˝      Sass::Script::Color::HTML4_COLORS_REVERSE
    else
      Sass::Script::Color::COLOR_NAMES_REVERSE
    end
  end
  
  def function(arglist)
    case var
    when Sass::Script::Color then
      Sass::Script::String.new(reversed_color_names[var.rgb]);Fi[	@ï
iWI"≈        arrenc(var)
      else
        raise(Error, "root value must be an Array or a Hash")
      end
    end
    
    def function(arglist)
      case var
      when Hash then
        objenc(var);Fi[	@íiçI"          "#{@options[:fog_directory]}.s3.amazonaws.com"
        else
          "s3.amazonaws.com/#{@options[:fog_directory]}"
        end
      end
      
      def function(arglist)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@ı
iîI"            warn("You must 'gem install win32console' to use colour on Windows")
            @var = false
          end
        end
      end
      
      def function(arglist)
        case var
        when :context, "context", "c" then
          @var = :context;Fi[@I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@>iI"ãmodule ActiveRecord
  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end;Fi[	@“iI"°      
      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end;Fi[	@6iI"¿      class Builder
        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end;Fi[	@∑iI"∆    class PyLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@_iI"«    class WireLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@C iI"¢  
  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist)
    (entries << { :name => (var), :action => (var) })
  end;Fi[	@F iI"£    
    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      (@var << [var, var])
    end;Fi[	@ßiI"∏module Spec
  module Runner
    class BacktraceTweaker
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        var.gsub!("//", "/")
      end;Fi[@¨I"##;F@
 @ä @ã i[[	@Âi8I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@ËiZI"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@ÎiDI"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@i#I"_          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@Ûi@I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@ˆi;I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@˘i8I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@¸i6I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[@^@≠I"@var = @var;F@W@Ùi[[	@•iøI"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@•i›I"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@®i∫I"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@®iÂI"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@´iÆI"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@´iÃI"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@.iñI"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@.i∑I"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[@°I"#   class BlogPost;FI"%#     extend ActiveModel::Naming;FI"#   end;FI"#;Fi[[	@ciI"=    #
    # Equivalent to <tt>String#==</tt>. Returns +true+ if the class name and
    # +other+ are equal, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name == 'BlogPost'  # => true
    #   BlogPost.model_name == 'Blog Post' # => false;Fi[	@ci'I"˚    #   ===(other)
    #
    # Equivalent to <tt>#==</tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name === 'BlogPost'  # => true
    #   BlogPost.model_name === 'Blog Post' # => false;Fi[	@ci5I"˙    #   ==(other)
    #
    # Equivalent to <tt>String#<=></tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name <=> 'BlogPost'  # => 0
    #   BlogPost.model_name <=> 'Blog'      # => 1;Fi[	@ciFI"]    # Equivalent to <tt>String#=~</tt>. Match the class name against the given
    # regexp. Returns the position where the match starts or +nil+ if there is
    # no match.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name =~ /Post/ # => 4
    #   BlogPost.model_name =~ /\d/   # => nil;Fi[	@ciUI"O    #
    # Equivalent to <tt>String#!~</tt>. Match the class name against the given
    # regexp. Returns +true+ if there is no match, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name !~ /Post/ # => false
    #   BlogPost.model_name !~ /\d/   # => true;Fi[	@cidI"\    #
    # Equivalent to <tt>String#eql?</tt>. Returns +true+ if the class name and
    # +other+ have the same length and content, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.eql?('BlogPost')  # => true
    #   BlogPost.model_name.eql?('Blog Post') # => false;Fi[	@cirI"æ    #   to_s()
    #
    # Returns the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.to_s # => "BlogPost"
    ##;Fi[	@ciöI"    
    # Transform the model name into a more humane format, using I18n. By default,
    # it will underscore then humanize the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.human # => "Blog post"
    #;Fi[@©I"
raise;FI"end;FI"end;FI"end;Fi[[	@∂iÌI"z        rescue ActiveRecord::StatementInvalid => var
          if var.message.split(":").first =~ /Packets out of order/ then
            raise(ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.")
          else
            raise
          end
        end
      end
      
      # MysqlAdapter has to free a result after using it, so we use this method to write;Fi[	@l	iI"        rescue ActiveRecord::StatementInvalid => var
          if /database .* already exists/.===(var.message) then
            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist);Fi[	@i4I"H        if var.message =~ /GraphViz not installed or dot not in PATH/ then
          Bundler.ui.error(var.message)
          Bundler.ui.warn("The ruby graphviz gem requires GraphViz to be installed")
        else
          raise
        end
      end
    end
    
    desc("gem GEM", "Creates a skeleton for creating a rubygem");Fi[	I"4data//devise_proj/devise/rails/warden_compat.rb;Ti(I"ÿ      if var.message =~ /uninitialized constant/ then
        Rails.logger.debug("[Devise] Trying to deserialize invalid class #{klass_name}")
        # do nothing
      else
        raise
      end
    end
  end
end;Fi[	I"!data//homebrew_proj/build.rb;Ti{I"Ÿ      else
        if ((var = var.rack.children).size == 1) and var.first.directory? then
          var.first
        else
          raise
        end
      end
    end
    Keg.new(var).optlink)
  rescue StandardError;Fi[	@GiJI"?          ignore_interrupts { |arglist| @var.unlink if @var.exist? }
          if var.kind_of?(ErrorDuringExecution) then
            raise(CurlDownloadStrategyError, "Download failed: #{@url}")
          else
            raise
          end
        end
      end
      return @var)
    rescue CurlDownloadStrategyError;Fi[	@Li9I"n    rescue FormulaUnavailableError
      if var then
        raise("        Multiple kegs installed to #{rack}\n        However we don't know which one you refer to.\n        Please delete (with rm -rf!) all but one and then try again.\n        Sorry, we know this is lame.\n".undent)
      else
        raise
      end
    end
  end
  
  # self documenting perhaps?;Fi[	@ÒiI"      rescue RuntimeError => var
        if (var.message == "no acceptor") then
          raise("Cannot start the server on port #{$APP_CONFIG.port} - are you root, or have another process on this port already?")
        else
          raise
        end
      end
    end
  end
end;Fi[@°I"L# There is also a list of default options supported by every validator:;FI"-# +:if+, +:unless+, +:on+ and +:strict+.;FI"J# See <tt>ActiveModel::Validation#validates</tt> for more information;FI"def function(arglist);Fi[[	I"?data//activemodel_proj/active_model/validations/absence.rb;TiI"≤      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AbsenceValidator, _merge_attributes(var))
      end;Fi[	I"Bdata//activemodel_proj/active_model/validations/acceptance.rb;Ti1I"ˆ      #   an HTML checkbox. This should be set to +true+ if you are validating
      #   a database column, since the attribute is typecast from "1" to +true+
      #   before validation.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AcceptanceValidator, _merge_attributes(var))
      end;Fi[	I"Ddata//activemodel_proj/active_model/validations/confirmation.rb;Ti3I"∆      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "doesn't match
      #   confirmation").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ConfirmationValidator, _merge_attributes(var))
      end;Fi[	I"Adata//activemodel_proj/active_model/validations/exclusion.rb;Ti+I"Ì      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the
      #   attribute is blank(default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ExclusionValidator, _merge_attributes(var))
      end;Fi[	@lilI"*      # * <tt>:multiline</tt> - Set to true if your regular expression contains
      #   anchors that match the beginning or end of lines as opposed to the
      #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(FormatValidator, _merge_attributes(var))
      end;Fi[	I"Adata//activemodel_proj/active_model/validations/inclusion.rb;Ti*I"      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(InclusionValidator, _merge_attributes(var))
      end;Fi[	@oimI"      #   (e.g. <tt>tokenizer: ->(str) { str.scan(/\w+/) }</tt> to count words
      #   as in above example). Defaults to <tt>->(value) { value.split(//) }</tt>
      #   which counts individual characters.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(LengthValidator, _merge_attributes(var))
      end;Fi[	I"@data//activemodel_proj/active_model/validations/presence.rb;Ti I"¥      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end;Fi[I"if (var == 1) then;FI"@var = @var;F@W@ÙI"end;Fi[[	@•i¿I"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@•iﬁI"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@®iªI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@®iÊI"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@´iØI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@´iÕI"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@.ióI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@.i∏I"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[@™I"var = 0;FI"var = 0;FI"var = 0;FI"var = 1;Fi[[	@•inI"‚        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@•i≤I"˜    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@®icI"‚        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@®i≠I"˜    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@´i]I"‚        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@´i°I"˜    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@.iäI"À    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[	@1i¶I"©      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[I"##;F@
 @ä @ã @å i[[	@Âi9I"[        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|;Fi[	@Ëi[I"<        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@ÎiEI"K        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[	@i$I"<        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@ÛiAI"T        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then;Fi[	@ˆi<I"I        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock;Fi[	@˘i9I"<        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@¸i7I"K        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[@'@T@;I"@var = nil;FI"end;Fi[[	@<iTI"ı      # actually gets built.
      def function(arglist)
        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      
      # Set the inverse association, if possible;Fi[	@”iœI"æ      
      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@<igI"∞      def function(arglist)
        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@¢i©I"À      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@•i3I"¢      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@Pi.I"∑      def function(arglist)
        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@ViÄI"†      
      def function(arglist)
        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      private;Fi[	@†
i?I"        log("Duplicate path for #{name} with #{default_path}. This will clash with attachment defined in #{@names_path[name][:class]} class")
      end
      @var[var] = { :path => (var), :class => (var) }
    end
    
    def function(arglist)
      @var = nil
    end
  end
end;Fi[@°I"-# @return [ Time ] The object mongoized.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@EiI"›      #
      # @example Mongoize the object.
      #   date.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self)
      end;Fi[	@Ei7I"-        #   Date.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          unless var.blank? then
            var = var.__mongoize_time__;Fi[	@JiI"Ê      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self)
      end;Fi[	@Ji=I"        #   DateTime.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end;Fi[	@hiI"›      #
      # @example Mongoize the object.
      #   time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Time.mongoize(self)
      end;Fi[	@hi=I"        #   Time.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return nil if var.blank?
          begin;Fi[	@miI"˘      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end;Fi[	@mi,I"        #   TimeWithZone.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end;Fi[@'@TI"##;F@
 @ä i[[	@Âi7I"]            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@ËiYI"P            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@ÎiCI"[            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@i"I"`          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@Ûi?I"R            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@ˆi:I"Z            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@˘i7I"c            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@¸i5I"_            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[@¨@
I"(@var << var);FI"end;FI" ;Fi[[	@¥i#I"¡          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@Ÿ	iI"⁄      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self };Fi[	@6iI"∆        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing;Fi[	@<i2I"«        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?;Fi[	@∑iI"≤      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing;Fi[	@äi5I"J      @var = true
      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "\n<fieldset#{" style='#{options[:style]}'" if options[:style]}#{" id='#{options[:id]}'" if options[:id]}>\n  <legend>#{legend}</legend>\n");Fi[	@©iI"æ        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var);Fi[	@ı
i.I"Ø        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!;Fi[@'@TI"module ClassMethods;F@` I"#;Fi[[	@?iI"      # @since 3.0.0
      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Object.demongoize(object);Fi[	@EiI"      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Date.demongoize(object);Fi[	@Ji%I"&      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   DateTime.demongoize(object);Fi[	@Yi+I""      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Range.demongoize({ "min" => 1, "max" => 5 });Fi[	@_iI"0      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Set.demongoize({ "min" => 1, "max" => 5 });Fi[	@bi¢I"˘        else
          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   String.demongoize(object);Fi[	@eiI"      # @since 2.3.1
      def function(arglist)
        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Symbol.demongoize(object);Fi[	@miI"=      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   TimeWithZone.demongoize(object);Fi[@¨@
I"@var.empty?;FI"end;FI" ;Fi[[	@Æi9I"⁄        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end
    
    ##
    # Returns a multi-line String, reporting all STDERR messages received;Fi[	@á	i8I"ü      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first;Fi[	@' i-I"Í        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length };Fi[	@bieI"4        load_programming_language("rb") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) };Fi[	@iI"|    @var = var
    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  ;Fi[	@i™I"¶  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var);Fi[	@UiI"°  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?;Fi[@Ù@ıI"7# @param [ Symbol ] name The name of the relation.;FI"4# @param [ Hash ] options The relation options.;FI"D# @param [ Proc ] block Optional block for defining extensions.;Fi[[	@ài/I"ê        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then;Fi[	@àiMI"ì        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var);Fi[	@àiiI"è        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var);Fi[	@àiÄI"î        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = reference_one_to_one(var, var, Referenced::In, &var);Fi[	@àiôI"ë        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Referenced::Many, var, &var);Fi[	@àiµI"m        #   class Preference
        #     include Mongoid::Document
        #     has_and_belongs_to_many :people
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        #
        # @since 2.0.0.rc.1;Fi[	@ài”I"è        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var);Fi[@¨@
I"0;FI"end;FI" ;Fi[[	@>iI"Ä    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@>iI"    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@>iI"    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@>iI"Ç    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[	@>i2I"Ä    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@>i6I"ä    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing;Fi[	@íiI"É    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[@I"@var, @var = var, var;FI"end;FI" ;FI"def function(arglist);Fi[[	@}iI"„    class ConnectionSpecification
      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        @var = var.config.dup
      end;Fi[	I"Idata//activerecord_proj/active_record/tasks/sqlite_database_tasks.rb;Ti
I"V    class SQLiteDatabaseTasks
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        raise(DatabaseAlreadyExists) if File.exist?(configuration["database"])
        establish_connection(configuration);Fi[	@	i&I"Ì        end
        
        class ArrayProxy
          def function(arglist)
            @var, @var = var, var
          end
          
          def function(arglist)
            @var.send(:"read_inherited_#{@var}_array")
          end;Fi[	@6i)I"        
        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) };Fi[	I"-data//cucumber_prok/cucumber/ast/tags.rb;TiI"˚    class Tags
      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        @var.each { |arglist| var.visit_tag_name(var.name) };Fi[	I":data//cucumber_prok/cucumber/step_definition_light.rb;Ti	I"  class StepDefinitionLight
    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist)
      (regexp_source == var.regexp_source) and (file_colon_line == var.file_colon_line)
    end;Fi[	I"=data//cucumber_prok/cucumber/wire_support/wire_packet.rb;TiI"Ã      
      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        var = [@var]
        (var << @var) if @var;Fi[I"!Compass.projectize(var, var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@–i.I"<      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then
          Compass.projectize(var, var);Fi[	@–i4I">      
      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then
          Compass.projectize(var, var);Fi[	@–i:I"K      
      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.generated_images_dir then
          Compass.projectize(var, var);Fi[	@–iHI"J      
      def function(arglist)
        if var = top_level.project_path and var = top_level.javascripts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then
          Compass.projectize(var, var);Fi[	@–iNI"D      
      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then
          Compass.projectize(var, var);Fi[	@–iTI"?      
      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then
          Compass.projectize(var, var);Fi[	@–iZI"Ù      
      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        top_level.images_dir
      end;Fi[@'@(@@	I""with_temp_folder do |arglist|;Fi[[	I"6data//homebrew_proj/test/test_pathname_install.rb;TiI"-  def function(arglist)
    assert_raises(RuntimeError) do |arglist|
      Pathname.getwd.install("non_existant_file")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt")
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.");Fi[	@F"i!I"v      TARGET_FOLDER.install("a.txt")
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(["a.txt", "b.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.");Fi[	@F"i)I"y      TARGET_FOLDER.install(["a.txt", "b.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(Dir["*.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.");Fi[	@F"i1I">      TARGET_FOLDER.install(Dir["*.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("bin")
      system("mv *.txt bin");Fi[	@F"i;I"z      TARGET_FOLDER.install("bin")
      assert((TARGET_FOLDER + "bin/a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "bin/b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt" => "c.txt")
      assert((TARGET_FOLDER + "c.txt").exist?, "c.txt not installed.");Fi[	@F"iDI"æ      assert((TARGET_FOLDER + "c.txt").exist?, "c.txt not installed.")
      assert((TARGET_FOLDER + "a.txt").exist?.!, "a.txt was installed but not renamed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt" => "c.txt", "b.txt" => "d.txt")
      assert((TARGET_FOLDER + "c.txt").exist?, "c.txt not installed.");Fi[	@F"iNI"      assert((TARGET_FOLDER + "d.txt").exist?, "d.txt not installed.")
      assert((TARGET_FOLDER + "a.txt").exist?.!, "a.txt was installed but not renamed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed but not renamed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("bin")
      system("mv *.txt bin");Fi[@©I"nil;FI"end;FI"end;FI"end;Fi[[	@∂i I"=          if var.to_s =~ /PRIMARY KEY\s+(?:USING\s+\w+\s+)?\((.+)\)/ then
            var = $1.split(",").map { |arglist| var.delete("`\"") }
            (var.length == 1) ? ([var.first, nil]) : (nil)
          else
            nil
          end
        end
      end
      
      # Returns just a table's primary key;Fi[	@*i)I"‡        else
          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end;Fi[	I"Fdata//bundler_proj/bundler/vendor/thor/actions/empty_directory.rb;TiqI":        else
          if base.respond_to?(var, true) then
            raise(Thor::PrivateMethodEncodedError, "Method #{base.class}##{sym} should be public, not private")
          else
            nil
          end
        end
      end
      
      # Receives a hash of options and just execute the block if some;Fi[	@YiI"¨            var = var.offset(var)[0]
            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@bi±I"            (@var << var)
            nil
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@A
i#I"ä        if var then
          var.email_the_user(var, var)
          var
        else
          nil
        end
      end
    end
  end
  ;Fi[	@=ifI"∏      "#{$1}/#{$2}/#{File.basename($3, ".rb")}"
    when /^#{HOMEBREW_LIBRARY}\/Formula\/(.+)/ then
      "mxcl/master/#{File.basename($1, ".rb")}"
    else
      nil
    end
  end
end;Fi[@I"@var = nil;FI"end;FI" ;FI"def function(arglist);Fi[[	@”i—I"        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!
        if has_and_belongs_to_many? and (association_foreign_key == foreign_key) then;Fi[	@i:I"¿      end
      
      # Support for testing.
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        configuration.to_sass_plugin_options
      end;Fi[	@&i	I"Xmodule Cucumber
  module Cli
    class ProfileLoader
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        unless cucumber_yml.has_key?(var) then
          raise(ProfileNotFound, "Could not find profile: '#{profile}'\n\nDefined profiles in cucumber.yml:\n  * #{cucumber_yml.keys.join("\n  * ")}\n");Fi[	@<iiI"∞        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var
        @var = " ";Fi[	@¢i´I"≥        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var)
        @var = 0;Fi[	@•i5I"Ø        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var
        var ||= @var;Fi[	@Pi0I"§        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var)
        var;Fi[@©I""";FI"end;FI"end;FI" ;Fi[[	@¯iI"U      def function(arglist)
        if top_level.line_comments then
          "# To disable debugging comments that display the original location of your selectors. Uncomment:\n# line_comments = false\n"
        else
          ""
        end
      end
      
      def function(arglist)
        if top_level.output_style_without_default then;Fi[	@bi8I"    def function(arglist)
      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("") : ("[#{COLORS[c.to_sym]}m")
      else
        ""
      end
    end
    
    def function(arglist)
      print(var);Fi[	@OiI"¢          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format];Fi[	@Oi6I"           else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do;Fi[	@OisI"ª          else
            # do nothing
          end
        else
          ""
        end
      end
      
      if Object.const_defined?(:Magick) then
        # Generates a gantt image;Fi[	@ÃiI"£          redirect_from_hash
        when NilClass then
          ">> /dev/null 2>&1"
        else
          ""
        end
      end
      
      protected
      ;Fi[	@Ãi6I"π          "> /dev/null"
        when stdout then
          ">> #{stdout}"
        else
          ""
        end
      end
      
      def function(arglist)
        ">> #{@output} 2>&1";Fi[@'@(I"	self;FI"end;FI" ;Fi[[	@4i=I"à          Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.parent.author.diaspora_handle} payload_type=#{self.class} parent_id=#{self.parent.id}")
          return
        end
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.parent_author_signature, self.parent.author);Fi[	@7i]I"W      else
        Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.sender_handle} payload_type=#{self.class}")
        return
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.target_author_signature, self.target.author);Fi[	I"/data//mongoid_proj/lib/mongoid/observer.rb;Ti,I"ü            end
          end
          var.send(var, var)
        end
      end
      self
    end
    
    # Are the observers disabled for the object?
    #;Fi[	@iÂI"%              else
                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        
        # Defines the setter method that allows you to set documents
        # in this relation by their ids. The defined setter, finds;Fi[	@\i:I"1              var = send("#{name}=", var)
              var.run_callbacks(:build)
              var
            end
          end
          self
        end
        
        # Defines a creator method for an embeds_one relation. This is
        # defined as #create_name. After the object is built it will;Fi[	@»i:I"I              var.value[0].value = ["*"]
              var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["#{match.value[1].value.first}("]), Node.new(:FUNCTION, ["self(", var])])
            end
          end
        end
        self
      end
      
      # Find a node by type using +types+
      def function(arglist);Fi[	I"1data//nokogiri_proj/nokogiri/xml/node_set.rb;Ti±I"»            end
          else
            var.delete("class")
          end
        end
        self
      end
      
      ###
      # Set the attribute +key+ to +value+ or the return value of +blk+;Fi[@@@@sI"private;Fi[[	@}i%I"∆          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist);Fi[	@ÉiêI"¨        begin
          exec_query("BEGIN")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist);Fi[	@µiTI"Œ          when /\(yes\/no\)/ then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option;Fi[	@ΩiéI"Ì          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the;Fi[	@¿iJI"¿          when /yes\/no/i then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands;Fi[	@∆iLI"1          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.;Fi[	@ÀiWI"Ì          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line;Fi[@¨@
I"@var = nil;FI"end;FI" ;Fi[[	@<iUI"Ù      def function(arglist)
        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      
      # Set the inverse association, if possible
      def function(arglist);Fi[	@”i–I"⁄      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!;Fi[	@<ihI"µ        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var;Fi[	@¢i™I"“        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var);Fi[	@•i4I"∂      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var;Fi[	@Pi/I"ª        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var);Fi[	@ViÅI"†      def function(arglist)
        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      ;Fi[@I"@var = true;FI"end;FI" ;FI"def function(arglist);Fi[[	@Bi I"ü        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@GiI"˝        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@GiI"°        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash
      end;Fi[	@JiII"º        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?
      end;Fi[	@Ñi'I"±        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end;Fi[	@üi4I"∑        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@i°I"¢        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false
      end;Fi[@¨@
@"I"end;FI" ;Fi[[	@}i
I"ı  module ConnectionAdapters
    class ConnectionSpecification
      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        @var = var.config.dup;Fi[	@"i	I"9  module Tasks
    class SQLiteDatabaseTasks
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        raise(DatabaseAlreadyExists) if File.exist?(configuration["database"]);Fi[	@6i(I"˚        include(Gherkin::Formatter::Escaping)
        
        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit;Fi[	@%"i
I"À  module Ast
    class Tags
      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	I"Fdata//cucumber_prok/cucumber/runtime/for_programming_languages.rb;Ti
I"˛  class Runtime
    class ForProgrammingLanguages
      extend(Forwardable)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def_delegators(:@user_interface, :embed, :ask, :puts, :features_paths, :step_match)
      ;Fi[	@("iI"module Cucumber
  class StepDefinitionLight
    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist)
      (regexp_source == var.regexp_source) and (file_colon_line == var.file_colon_line);Fi[	@+"iI"∏      end
      
      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        var = [@var];Fi[@¢@£I"#   end;TI"#;TI"#   person.pets;Ti[[	@Ái%I"&      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@Ái^I"]      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@Ái|I"D      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@ÁiïI"D      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@ÁiI"P      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>]
      #;Ti[	@ÁiAI")      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@Ái[I"\      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,;Ti[@'@T@;I"var;FI"end;Fi[[	@5	iI"ù      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist);Fi[	@∂i2I"√      
      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist);Fi[	@ÉiÍI"∑        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[	@6iI"∑        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[	@hi+I".          def function(arglist)
            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end
          
          alias :handle_snippet_text :handle_success;Fi[	@iI"Å    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist);Fi[	@iI"p    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[@'@(@@	I"
super;Fi[[	I"+data//activemodel_proj/active_model.rb;Ti7I"´    eager_autoload do |arglist|
      autoload(:JSON)
      autoload(:Xml)
    end
  end
  
  def function(arglist)
    super
    ActiveModel::Serializer.eager_load!
  end;Fi[	@ÉixI"Û        
        def function(arglist)
          @var[Process.pid]
        end
      end
      
      def function(arglist)
        super
        @var = StatementPool.new(@var, var.fetch(:statement_limit) { |arglist| 1000 })
        @var = nil;Fi[	@Éi®I"ÿ          @var.respond_to?(:errno) ? (@var.errno.zero?) : (true))
        rescue Mysql::Error
          false
        end
      end
      
      def function(arglist)
        super
        disconnect!
        connect;Fi[	@∫iI"          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super
        if ActiveRecord::Base.connected? then
          var[:db_runtime] = ((db_runtime or 0) + ActiveRecord::LogSubscriber.reset_runtime);Fi[	@'i$I"        @var = {}
        ALL.each do |arglist|
          @var[var] = reverse.find { |arglist| var.match_platform(var) }
        end
      end
      
      def function(arglist)
        super
        @var = var.required_by.dup
        @var = var.activated.dup;Fi[	@˘iI"ˇ      flash[:error] = @var.errors.full_messages.join(" - ")
      Rails.logger.info("event=registration status=failure errors='#{@user.errors.full_messages.join(", ")}'")
      redirect_to(:back)
    end
  end
  
  def function(arglist)
    super
  end
  ;Fi[	@iI"ﬂ    @var = var
    if other_connection.last_ref_id.!=(var) then
      self.other_connection.last_ref_id = var
    end
  end
  
  def function(arglist)
    super
    self.processed_headers = false
    self.output_buffer = "";Fi[@'@(@)@	I"protected;Fi[[	@iÖI"ü          false
        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[	@	i/I"ˆ            unless var.send(CHECKS[var], var) then
              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@Ωi(I"¬          @var.synchronize do |arglist|
            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@PiJI"¥          else
            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[	@Ri\I"u        var.value.first
      else
        var
      end
    end
  end
  
  protected
  
  def function(arglist);Fi[	@ii_I"í            :locked
          else
            super
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@≈i,I"           puts("## [message] Above is your schedule file converted to cron syntax; your crontab file was not updated.")
          puts("## [message] Run `whenever --help' for more options.")
          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[@°I"# @since 3.0.0;FI"def function(arglist);FI"@var = var;FI"end;Fi[[	@i,I"÷      # @param [ Integer ] value The limit.
      #
      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Get the skiping value.;Fi[	@iHI"’      # @param [ Integer ] value The skip.
      #
      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Apply criteria options.;Fi[	I"/data//mongoid_proj/lib/mongoid/criteria.rb;TieI"¸    # @param [ Array<Document> ] docs The embedded documents.
    #
    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Is the criteria for embedded documents?;Fi[	@D#iI"
    # @param [ Array<Metadata> ] The inclusions.
    #
    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Merges another object with this +Criteria+ and returns a new criteria.;Fi[	I"/data//mongoid_proj/lib/mongoid/loggable.rb;TiI"∂    # @param [ Logger ] The logger to set.
    #
    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private;Fi[	@ÉióI"        # @param [ true, false ] value The flag.
        #
        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Normalize the documents, in case they were provided as an array of;Fi[	@ÉiŒI"        # @param [ String ] value The path.
        #
        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Get the selector for executing atomic operations on the collection.;Fi[@z@{@I"protected;FI" ;Fi[[	@fi%I"*            var[:encoding] = "base64" if (type == :binary)
            var[:type] = (type == :string) ? (nil) : (type)
            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist)
            return if value.nil?;Fi[	@¯iêI"‰        end
        raise(ActiveRecord::Rollback) unless var
      end
      var
    end
    
    protected
    
    # Save the new record state and id of a record so it can be restored later if a transaction fails.
    #:nodoc:;Fi[	@ä	iÏI"¡      # Thor::Shell::Basic class.
      #
      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist)
        return var unless var.is_a?(Symbol);Fi[	@≠	ilI"        trigger(var[:before], var) if var[:before]
        var = execute_task(var)
        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist)
        return if Thread.current[:rollback_requests].nil?;Fi[	@viπI"              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected
        
        def function(arglist)
          @var ||= Devise::ParamFilter.new(case_insensitive_keys, strip_whitespace_keys);Fi[	I"0data//paperclip_proj/paperclip/thumbnail.rb;TiZI")      (var << "-auto-orient") if auto_orient
      ((var << "-resize") << "\"#{scale}\"") unless (var.nil? or var.empty?)
      (((var << "-crop") << "\"#{crop}\"") << "+repage") if var
      var
    end
    
    protected
    
    # Return true if the format is animated
    def function(arglist);Fi[	@πiI"·        var = true
        example_groups.each { |arglist| var = var.&(var.run(@var)) }
        finish
        var
      end
      
      protected
      
      def function(arglist)
        reporter.start(number_of_examples);Fi[I"require("formula");FI"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);Fi[[	@,i I"Frequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    unless (HOMEBREW_REPOSITORY / ".git").directory? then
      raise("        Changes will be lost!\n        The first time you `brew update', all local changes will be lost, you should\n        thus `brew update' before you `brew edit'!\n".undent);Fi [	I"%data//homebrew_proj/cmd/fetch.rb;Ti I"®require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("--deps") then;Fi [	@Ei I"árequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    var = []
    HOMEBREW_CELLAR.subdirs.each do |arglist|;Fi [	I""data//homebrew_proj/cmd/sh.rb;TiI"ãrequire("superenv")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    if superenv? then
      ENV.x11 = true;Fi[	I")data//homebrew_proj/cmd/uninstall.rb;TiI"úrequire("keg")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    begin
      (raise(KegUnspecifiedError) if ARGV.named.empty?;Fi[	I"$data//homebrew_proj/cmd/uses.rb;Ti I"™require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    var = Formula.select do |arglist|;Fi [	@∏i I"«require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise("Please `brew install git` first") unless which("git")
    unless (HOMEBREW_REPOSITORY / ".git").directory? then;Fi [@°@:#@;#I"	self;FI"end;Fi[[	@D#iHI"¥    #   criteria.to_criteria
    #
    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    
    # Convert the criteria to a proc.;Fi[	@SiI"·      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__);Fi[	@SiI"À      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.;Fi[	@Si(I"—      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.;Fi[	@Si@I"‘      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.;Fi[	@SiÇI"¡      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Is the object multi args.;Fi[	@ViI"Û      #   object_id.__evolve_object_id__
      #
      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__);Fi[@n@o@pI"end;FI"end;Fi[[	@Ñi5I"[      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@ái®I"ë      
      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@`iåI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@ciI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@jifI"[      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@C iWI"ü      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist)
  puts("#{exception.backtrace.first}");Fi[	@≈iI"†          true)
        rescue DRb::DRbConnError
          var.error_stream.puts("No server is running")
          false
        end
      end
    end
  end
end;Fi[@°@:#@;#I"	true;FI"end;Fi[[	@<iwI"≥      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@<i°I"≥        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[	@MiI"∏      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@Pi|I"·      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the;Fi[	@PiæI"∞        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[	I"9data//mongoid_proj/lib/mongoid/extensions/integer.rb;TiI"Ê      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Is the object not to be converted to bson on criteria creation?;Fi[	@Yi'I"≤      #   range.resizable?
      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[@'I"	else;FI"var;FI"end;FI"end;Fi[[	@ãiyI"¶                else
                  nil
                end
              end
            else
              var
            end
          end
        end
        ;Fi[	@≈iI"         when Hash then
          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    ;Fi[	@ji[I"æ            var[:project_name]
          else
            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist);Fi[	@Vi§I"ø            var.backtrace.clear
            var.backtrace.push(var.backtrace_line("World"))
            raise(var)
          end
        else
          var
        end
      end
    end
  end;Fi[	@biìI"·            end.min
            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      ;Fi[	@÷i&I"∫            var = var.call(var)
            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end;Fi[	@Éi∞I"              var = { :metadata => (metadata), :_parent => (base) }
              var.merge!(var)
              Factory.build(klass, var, base.send(:mass_assignment_options))
            end
          else
            var
          end
        end
        
        # Get the atomic path.;Fi[I"#homepage("http://example.com");FI" ;FI",url("file:///foo.com/testball-0.1.tbz");FI" ;FI"5sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5");Fi[[	I")data//homebrew_proj/test/testball.rb;TiíI"Ã  end
end
class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@Œ#i¢I"Ò  end
end
class AncientBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle("file:///foo.com/testball-0.1-bottle.tar.gz");Fi[	@Œ#iﬂI"‘  end
end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@Œ#iÓI"Õ  end
end
class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@Œ#i˝I"–  end
end
class AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@Œ#iI"–  end
end
class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@Œ#i"I"class CustomVersionScheme < Version
end
class CustomVersionSchemeTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  version("1.0" => (CustomVersionScheme));Fi[@@∞@°@iI"end;Fi[[	@öihI"ﬁ    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@ﬂiaI"        ##
        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##;Fi[	@Ñi<I"˚        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@Ri
I"Ω    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@›iúI"À  fatal(ARGV.force?.!)
  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@áiI"Û      class AttributeAssignmentError < Mongoid::Errors::MongoidError
        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      ;Fi[	@õi	I"∫  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[@'@T@;I"@var ||= [];FI"end;Fi[[	@9i/I"¨    # RubyGems 1.8+ used only.
    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist);Fi[	@MiI"Ë        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end
    
    # Returns an array of Rule instances which match the action and subject;Fi[	@PiUI"∆      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist);Fi[	@i#I"3        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@i'I"∏        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@˘iI"Œ        def function(arglist)
          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@≤i‹I"ß      
      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist);Fi[@¨@…#I" ;F@À#I" ;Fi[[	@Œ#iìI"¸end
class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    url("file:///foo.com/testball-0.1-bottle.tar.gz");Fi[	@Œ#i£I"Óend
class AncientBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle("file:///foo.com/testball-0.1-bottle.tar.gz")
  ;Fi[	@Œ#i‡I"end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[	@Œ#iÔI"end
class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :lion);Fi[	@Œ#i˛I"end
class AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[	@Œ#iI"Ÿend
class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    version(1);Fi[	@Œ#i#I"„end
class CustomVersionSchemeTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  version("1.0" => (CustomVersionScheme))
  ;Fi[@Æ@Ø@∞I" ;FI"def function(arglist);Fi[[	@áivI"ƒ        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested
        var = load_target if (var == :all);Fi[	@-i≥I"°            raise(var)
          end
        end
        true
      end
    end
    
    def function(arglist)
      var = class << Gem::SourceIndex
        self;Fi[	@9i1I"          var.results.failure?)
        rescue ProfilesNotDefinedError, YmlLoadError, ProfileNotFound => var
          @var.puts(var.message)
          true
        end
      end
      
      def function(arglist)
        return @var if @var
        @var = Configuration.new(@var, @var);Fi[	@Êi@I"    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist)
    var = StatusMessage.find_by_guid(self.status_message_guid)
    if self.status_message_guid and var then;Fi[	@(iöI"Ω    else
      self.add_hidden_shareable(var, var)
      self.save
      true
    end
  end
  
  def function(arglist)
    var = var.base_class.to_s
    self.hidden_shareables[var].present?;Fi[	@íi5I"»            @var[:fog_public]
          end
        else
          true
        end
      end
      
      def function(arglist)
        for var, var in @var do
          (log("saving #{path(style)}");Fi[	@TiI"      class FilesystemAdapter < AbstractAdapter
        class << self
          def function(arglist)
            true
          end
        end
        
        def function(arglist)
          @var = with_trailling_slash(var)
          @var = var.blank? ? ("UTF-8") : (var);Fi[I"# @since 3.0.0;F@;#I"	self;FI"end;FI" ;Fi[[	@D#iII"ù    #
    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    
    # Convert the criteria to a proc.
    #;Fi[	@SiI"¬      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[	@SiI"¥      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.
      #;Fi[	@Si)I"∂      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.
      #;Fi[	@SiAI"æ      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.
      #;Fi[	@SiÉI"Ø      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Is the object multi args.
      #;Fi[	@ViI"—      #
      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[@'I"
super;FI"end;FI" ;FI"def function(arglist);Fi[[	@oiI"        end
        if (var[:allow_blank] == false) and (var[:minimum].nil? and var[:is].nil?) then
          var[:minimum] = 1
        end
        super
      end
      
      def function(arglist)
        var = CHECKS.keys.&(options.keys)
        if var.empty? then;Fi[	@ái"I"”            raise_on_type_mismatch(var)
            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested
        var = super;Fi[	@¨i\I"W      def function(arglist)
        if (var.size == 1) and (var == nil) then
          raise(ActiveRecord::IrreversibleMigration, "To avoid mistakes, drop_table is only reversible if given options or a block (can be empty).")
        end
        super
      end
      
      def function(arglist)
        [:rename_table, var.reverse]
      end;Fi[	@¨igI"3      def function(arglist)
        if (var.size <= 2) then
          raise(ActiveRecord::IrreversibleMigration, "remove_column is only reversible if given a type.")
        end
        super
      end
      
      def function(arglist)
        [:rename_index, ([var.first] + var.last(2).reverse)]
      end;Fi[	@ıiI"Ÿ            write_attribute(var.to_s, var)
          end
        end
      end
      super
    end
    
    def function(arglist)
      if should_record_timestamps? then
        var = current_time_from_proper_timezone;Fi[	@ıi)I"&          next if attribute_changed?(var)
          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist)
      self.record_timestamps and (partial_writes?.! or (changed? or attributes.keys.&(self.class.serialized_attributes.keys).present?))
    end;Fi[	@Ji$I"ñ        if var.name.nil? then
          var = StepDefKey.new(var.step_definition.regexp_source, var.step_definition.file_colon_line)
          (@var[var] << { :keyword => (var), :step_match => (var), :status => (var), :file_colon_line => (@var.file_colon_line), :duration => (@var) })
        end
        super
      end
      
      def function(arglist)
        add_unused_stepdefs
        aggregate_info;Fi[@$$@;#I"@var = var;FI"end;FI" ;Fi[[	@i-I"≤      #
      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Get the skiping value.
      #;Fi[	@iII"≤      #
      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Apply criteria options.
      #;Fi[	@D#ifI"ƒ    #
    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Is the criteria for embedded documents?
    #;Fi[	@D#iÒI"!    #
    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Merges another object with this +Criteria+ and returns a new criteria.
    # The other object may be a +Criteria+ or a +Hash+. This is used to;Fi[	@I#i I"ê    #
    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@ÉiòI"˝        #
        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Normalize the documents, in case they were provided as an array of
        # hashes.;Fi[	@ÉiœI"Ò        #
        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Get the selector for executing atomic operations on the collection.
        #;Fi[I"C# : Notification will be sent, including a copy of the current;FI"6# : backup log, if `on_warning` was set to `true`;FI"#;FI"# `:failure`;FI"%# : The backup operation failed.;Fi[[	@ﬂi&I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@‚i>I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@îi}I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@•i$I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@®i.I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@´i"I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[@£I"#   end;TI"#;TI"#   person.pets;TI"#   # => [;Ti[[	@Ái&I"[      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@Ái_I"9      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@Ái}I"0      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁiñI"0      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁiBI"      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>;Ti[	@Ái\I"K      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[@¨I"module InstanceMethods;FI"def self.included(arglist);FI"var.extend(ClassMethods);FI"end;Fi[[	@	iI"‰          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@iI"„          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@iI"‚          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@iI"%          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["datetime", "title", "description", "author", "type"].each do |arglist|;Fi[	@i'I"ı          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@"iI"          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers;Fi[@™@´@¨I"var = (var + 1);FI"$var = var if var and (var == 2);Fi[[	@•iyI"      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@•içI"/          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[	@®inI"˚      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@®iáI"!          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var);Fi[	@´ihI"      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@´i|I"/          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[I"(@var << var);FI"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@ßi[I"        raise(ConnectionNotEstablished) unless @var
        var = new_connection
        var.pool = self
        (@var << var)
        var
      end
      
      def function(arglist)
        var.run_callbacks(:checkout) { |arglist| var.verify! }
        var;Fi[	I"Ddata//capistrano_proj/capistrano/recipes/deploy/dependencies.rb;TiI"Í      
      def function(arglist)
        var = RemoteDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        var = LocalDependency.new(configuration)
        (@var << var);Fi[	@Ø$i!I"⁄      
      def function(arglist)
        var = LocalDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        @var.each { |arglist| yield(var) }
        self;Fi[	@VipI"Û      
      def function(arglist)
        var = RbStepDefinition.new(self, var, var, var)
        (@var << var)
        var
      end
      
      def function(arglist)
        if var then
          raise(MultipleWorld.new(@var, var)) if @var;Fi[	@OiàI"a          (var << "width:#{(params[:subject_width] - params[:indent])}px;")
        end
        var = view.content_tag(:div, var, :class => (var[:css]), :style => (var), :title => (var[:title]), :id => (var[:id]))
        (@var << var)
        var
      end
      
      def function(arglist)
        var[:pdf].SetY(var[:top])
        var[:pdf].SetX(15);Fi[	@OiÎI"/          (var << "height:12px;")
          (var << view.content_tag(:div, var.html_safe, :style => (var), :class => "tooltip"))
        end
        (@var << var)
        var
      end
      
      def function(arglist)
        var = (var[:height] or 2)
        if var[:bar_start] and var[:bar_end] then;Fi[I"[];FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@U	i∫I"2        var = connection.select_all(var, "SQL", var.bind_values.dup)
        var.instantiate(var))
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = (eager_load_values + includes_values).uniq
      ActiveRecord::Associations::JoinDependency.new(@var, var, []);Fi[	@…	i$I"…            File.basename(var)
          end
        else
          []
        end
      end
      
      def function(arglist)
        File.join(templates_directory, var.to_s, "manifest.rb")
      end;Fi[	I"Cdata//diaspora_proj/helpers/interim_stream_hackiness_helper.rb;Ti$I"’    if defined? @var and (params[:controller] == "multis") then
      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist)
    defined? @var ? (@var.publisher.open?) : (false)
  end;Fi[	@ï
iΩI"Ï          end
        end
      else
        []
      end
    end
    
    def function(arglist)
      var = /"([^"\\]|\\["\/\\bfnrt]|\\u[0-9a-fA-F]{4})*"/.match(var)
      raise(Error, "invalid string literal at #{abbrev(s)}") if var.!;Fi[	@Xi$I"6      if compiled_parser_version.!=(loaded_parser_version) then
        ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end
    
    def function(arglist)
      var = {}
      var["warnings"] = [];Fi[	@∏iI"B        var = connection.select_all(var, "SQL", var.bind_values)
        var.map { |arglist| var["id"].to_i })
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = except(:includes, :eager_load, :preload, :select).select("#{table_name}.id")
      apply_join_dependency(var, var);Fi[@'@T@Ñ$@Ö$@Ü$i[[	@	iI"÷          end
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@iI"
          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@iI"ˆ          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@iI"          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@i&I"=          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@"iI"          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[I"1# @param [ String ] name The attribute name.;FI"7# @param [ String ] meth The name of the accessor.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@6iI"î      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_change") { |arglist| attribute_change(var) };Fi[	@6iI"í      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed?") { |arglist| attribute_changed?(var) };Fi[	@6i)I"é      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed_from_default?") do |arglist|;Fi[	@6i:I"ñ      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_was") { |arglist| attribute_was(var) };Fi[	@6iII"{      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_will_change!") do |arglist|;Fi[	@6iZI"á      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) };Fi[I"var.puts(var);FI"var.puts("---");FI"var.puts(var);FI"end;FI"end;Fi[[	@ÊiI"€          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@Èi#I"€          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@ÏiI"⁄          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
    ;Fi[	I"4data//jekyll_proj/jekyll/migrators/posterous.rb;Ti2I"l            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end
        var = (var + 1)
        var = JSON.parse(self.fetch("/api/v2/users/me/sites/#{blog}/posts?api_token=#{@api_token}&page=#{page}").body);Fi[	@ÚiI"€          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@¯i`I"Á        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end
    
    def self.clean_entities(arglist);Fi[I"end.to_yaml;FI"2File.open("_posts/#{name}", "w") do |arglist|;FI"var.puts(var);FI"var.puts("---");FI"var.puts(var);Fi[[	@ÊiI"æ        var = ("%02d-%02d-%02d-%s.markdown" % [var.year, var.month, var.day, var])
        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@Èi!I"â        var = ([var.year, var.month, var.day, var].join("-") + ".markdown")
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@ÏiI"ß        var = (([var.year, var.month, var.day, var].join("-") + ".") + self.suffix(var))
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@¸$i0I"ô          var = ("%02d-%02d-%02d-%s.html" % [var.year, var.month, var.day, var])
          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end;Fi[	@ÚiI"é        var = ([var.strftime("%Y-%m-%d"), var].join("-") + ".textile")
        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@¯i^I"(      end
      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end;Fi[I"(var.nil? or (var == ""));FI"end.to_yaml;F@%I"var.puts(var);F@%i[[	@ÊiI"–        var = var[:content]
        var = ("%02d-%02d-%02d-%s.markdown" % [var.year, var.month, var.day, var])
        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@Èi I"ò        var = var[:body]
        var = ([var.year, var.month, var.day, var].join("-") + ".markdown")
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@ÏiI"–        var = ((var + " \n") + var) if var.!=(nil)
        var = (([var.year, var.month, var.day, var].join("-") + ".") + self.suffix(var))
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@¸$i/I"±          var = var["is_private"].!
          var = ("%02d-%02d-%02d-%s.html" % [var.year, var.month, var.day, var])
          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end;Fi[	@ÚiI"ù        var = var[:Body]
        var = ([var.strftime("%Y-%m-%d"), var].join("-") + ".textile")
        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@¯i]I"Z        var.sort! { |arglist| (var["id"] <=> var["id"]) }
      end
      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end;Fi[@›$I"#;FI"# @since 3.0.0;F@‡$I"/generated_methods.module_eval do |arglist|;Fi[[	@6iI"z      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_change") { |arglist| attribute_change(var) }
        end;Fi[	@6iI"{      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed?") { |arglist| attribute_changed?(var) }
        end;Fi[	@6i*I"ú      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed_from_default?") do |arglist|
            attribute_changed_from_default?(var);Fi[	@6i;I"|      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_was") { |arglist| attribute_was(var) }
        end;Fi[	@6iJI"Å      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_will_change!") do |arglist|
            attribute_will_change!(var);Fi[	@6i[I"p      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) }
        end;Fi[@|I"end;FI" ;F@I"raise(NotImplementedError);Fi[[	@:iI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@:iI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@:iI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@:iI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@:i I"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@:i$I"±      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end;Fi[@°I"%# @return [ Mongo ] The context.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@i∏I"¯      #   context.limit(20)
      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.limiting = var
        self;Fi[	@i«I"ı      #   context.skip(20)
      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.skipping = var
        self;Fi[	@i◊I"˘      #
      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        in_place_sort(var) and self
      end;Fi[	@iÙI"˚      #   context.limit(20)
      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.limit(var) and self
      end;Fi[	@i$I"˜      #   context.skip(20)
      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.skip(var) and self
      end;Fi[	@i3I"˛      #
      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          super(&var);Fi[@°@‹$@›$I"#;FI"# @since 3.0.0;Fi[[	@6i
I"K      #
      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@6iI"E      #
      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@6i(I"M      #
      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@6i9I"S      #
      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@6iHI"C      #
      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@6iYI">      #
      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[@°I"7# @param [ Symbol ] name The name of the relation.;F@Ò!@Ú!I"def function(arglist);Fi[[	@ài0I"Ø        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then
            raise(Errors::VersioningNotOnRoot.new(self));Fi[	@àiNI"¶        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@àijI"•        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@àiÅI"∞        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = reference_one_to_one(var, var, Referenced::In, &var)
          aliased_fields[var.to_s] = var.foreign_key;Fi[	@àiöI"ï        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Referenced::Many, var, &var)
          relate(var, var);Fi[	@ài‘I"Ç        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var)
        end;Fi[@F@GI" ;FI"private;FI" ;Fi[[	@riOI"¥  class BlockValidator < EachValidator
    def function(arglist)
      @var = var
      super
    end
    
    private
    
    def function(arglist)
      @var.call(var, var, var);Fi[	@ıiI"®    
    def function(arglist)
      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist)
      if self.record_timestamps then;Fi[	@i!I"Ó      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Lzma is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        (" --best" if @var or " --fast" if @var);Fi[	@i'I"ˆ      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Pbzip2 is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        var = (" --best" if @var or " --fast" if @var);Fi[	@˘iI"î  end
  
  def function(arglist)
    super
  end
  
  private
  
  def function(arglist)
    return true if AppConfig.settings.enable_registrations?;Fi[	I"2data//mongoid_proj/lib/mongoid/validations.rb;TiœI"”            end
          end
        end
        super
      end
      
      private
      
      # Adds an associated validator for the relation if the validate option
      # was not provided or set to true.;Fi[I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;FI"#     end;Fi[[	@˛icI"Ó    # == Examples
    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@ iI"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@ iXI"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@ i|I"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	I"<data//state_machine_proj/state_machine/macro_methods.rb;TiçI".    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do;Fi[	@⁄i˝I"ÿ    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[@'@≥#I"# do nothing;FI"end;FI"end;Fi[[	@iPI"“              end
            end
            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      
      protected;Fi[	@…iºI"G                var[var].concat(var.map do |arglist|
                  { var.foreign_key => (var[primary_key_name]), var.association_foreign_key => (ActiveRecord::FixtureSet.identify(var)) }
                end)
              end
            else
              # do nothing
            end
          end
        end
        var;Fi[	@”iAI"ÿ            Associations::HasOneThroughAssociation
          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@ŸiI"—            @var = "join"
            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@1i=I"ó          SetLineWidth(0.1)
        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #;Fi[	@2i(I"Ω              LoopbackMatcher.instance
            else
              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end;Fi[@¨@… I"7# Notify the user of the backup operation results.;FI"/# `status` indicates one of the following:;FI"#;Fi[[	@ﬂiI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@‚i3I"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@îirI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@•iI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@®i#I"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@´iI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[I"6var = (var[var].chr == " ") ? ((var + 1)) : (var);FI"end;FI"var = -1;FI"var = var;FI"var = 0;Fi[[	@•iãI"K          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@•iŸI"@          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@®iÖI"K          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@®i·I"@          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@´iI"K          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@´i»I"@          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[I"@var = nil;FI"@var = nil;FI"@var = nil;FI"@var = nil;FI"@var = nil;Fi[[	@ØiI"        connection.clear_cache!
        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@ØiI"
        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@ØiI"        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var;Fi[	@ØiI"€        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var
        @var = nil;Fi[	@^ioI"÷      def function(arglist)
        FileUtils.rm_rf(@var, :secure => (true)) if @var
        @var = []
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
      end
      ;Fi[	@piÔI"    @var = [var, "ssl_generations"].join("_").intern
    @var = [var, "requests"].join("_").intern
    @var = [var, "timeouts"].join("_").intern
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = OpenSSL::SSL::VERIFY_PEER
    @var = nil;Fi[I"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);FI"assert(var.dylib?.!);FI"%assert(var.mach_o_executable?.!);Fi[[	I"*data//homebrew_proj/test/test_mach.rb;TiFI"9    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@%iTI":    var = Pathname.new("#{TEST_FOLDER}/mach/i386.bundle")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@%ipI"G    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@%ièI"    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@%iüI"&    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@%iØI"    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs);Fi[@'I"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;Fi[[	@•imI"€        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@®ibI"€        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@´i\I"€        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@.iBI"À        var = (var + "R") unless var.index("R").nil?
        var = var.index("T").nil?.! ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@1i;I"†          var = var.include?("T") ? ((var + "T")) : (var)
        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@1i•I"º    if (var == 1) and (var == " ") then
      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[I"assert(var.i386?.!);F@È%@Í%@Î%@Ï%i[[	@%i7I"+  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/a.out")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?)
    assert(var.text_executable?.!);Fi[	@%iEI"2  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@%ioI">  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@%iéI"'    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@%iûI"1    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@%iÆI"#    var = (HOMEBREW_PREFIX / "foo_script")
    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[@¨@@I"##;F@≤%i[[	@ﬂiI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@‚i1I"Ê        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@îipI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@•iI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@®i!I"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@´iI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[@¨@@I"attr_reader :function;FI" ;Fi[[	@g	iOI"Ù        var.concat(["--database", "#{configuration["database"]}"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("database" => (nil));Fi[	@l	iEI"˚        set_psql_env
        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["encoding"] or DEFAULT_ENCODING);Fi[	@"i*I"∏        var = configuration["database"]
        `sqlite3 #{var} < "#{var}"`
      end
      
      private
      
      attr_reader :function
      
      attr_reader :function
    end;Fi[	@∑	iSI"Û    def function(arglist)
      to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("#{transport} #{operation} #{from} -> #{to}") if logger;Fi[	I"4data//state_machine_proj/state_machine/state.rb;TiÊI"l      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "#<#{self.class} #{(attributes.map { |attr, value| "#{attr}=#{value.inspect}" } * " ")}>"
    end
    
    private
    
    attr_reader :function
    
    # Adds a predicate method to the owner class so long as a name has
    # actually been configured for the state;Fi[	@iiMI"Ä    protected
    
    attr_reader(:results)
    
    private
    
    attr_reader :function
    
    attr_reader :function
    ;Fi[I"#@var = (HOMEBREW_CACHE + @var);FI"end;FI" ;FI"attr_reader :function;FI" ;Fi[[	@GiΩI"/    @@svn ||= "svn"
    @var = "#{name}--svn" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (@var + "-HEAD") if ARGV.include?("--HEAD")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.sub!(/^svn\+/, "") if @var =~ /^svn\+http:\/\//;Fi[	@GiI"˘    super
    @@git ||= "git"
    @var = "#{name}--git" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.!=(:revision) and host_supports_depth?;Fi[	@GidI"Ó  def function(arglist)
    super
    @var = "#{name}--cvs" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    ohai("Checking out #{@url}");Fi[	@GièI"A  def function(arglist)
    super
    @var = "#{name}--hg" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|;Fi[	@GiπI"  def function(arglist)
    super
    @var = "#{name}--bzr" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|;Fi[	@GiŸI"'  def function(arglist)
    super
    @var = "#{name}--fossil" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|;Fi[I"
raise;FI"end;FI"end;FI"end;FI" ;Fi[[	@)i›I"≈            commit_transaction unless var
          rescue Exception
            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      ;Fi[	@∂iÓI"†          if var.message.split(":").first =~ /Packets out of order/ then
            raise(ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.")
          else
            raise
          end
        end
      end
      
      # MysqlAdapter has to free a result after using it, so we use this method to write
      # stuff in an abstract way without concerning ourselves about whether it needs to be;Fi[	@l	iI"Ù          if /database .* already exists/.===(var.message) then
            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist)
        establish_master_connection;Fi[	@i5I"          Bundler.ui.error(var.message)
          Bundler.ui.warn("The ruby graphviz gem requires GraphViz to be installed")
        else
          raise
        end
      end
    end
    
    desc("gem GEM", "Creates a skeleton for creating a rubygem")
    ;Fi[	@Li:I"c      if var then
        raise("        Multiple kegs installed to #{rack}\n        However we don't know which one you refer to.\n        Please delete (with rm -rf!) all but one and then try again.\n        Sorry, we know this is lame.\n".undent)
      else
        raise
      end
    end
  end
  
  # self documenting perhaps?
  def function(arglist);Fi[	@%i”I"          retry
        else
          Resque.logger.info("Error reconnecting to Redis; quitting")
          raise
        end
      end
    end
    
    # Returns a list of queues to use when searching for a job.
    # A splat ("*") means you want every queue (in alpha order) - this;Fi[@^@_I"var = 1;F@bI"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[[	@•ipI"÷    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@•i¥I"„    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@®ieI"»    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@®iØI"’    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@´i_I"÷    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@´i£I"„    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[I"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);FI"if ARGV.named.empty? then;Fi[[	I"'data//homebrew_proj/cmd/--cache.rb;Ti I"{module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CACHE)
    else;Fi [	I"(data//homebrew_proj/cmd/--cellar.rb;Ti I"|module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CELLAR)
    else;Fi [	I"(data//homebrew_proj/cmd/--prefix.rb;Ti I"|module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_PREFIX)
    else;Fi [	@∞i	I"Írequire("keg")
require("bottles")
require("cmd/prune")
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      if HOMEBREW_CELLAR.directory? then
        HOMEBREW_CELLAR.children.each do |arglist|;Fi[	I"$data//homebrew_proj/cmd/home.rb;Ti I"Åmodule Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      exec_browser(HOMEBREW_WWW)
    else;Fi [	I"#data//homebrew_proj/cmd/log.rb;Ti I"¢module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      cd(HOMEBREW_REPOSITORY)
      exec("git", "log", *ARGV.options_only);Fi [@≤%@≥%I"#;FI"# `:success`;FI"+# : The backup completed successfully.;Fi[[	@ﬂiI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@‚i5I"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@îitI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@•iI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@®i%I"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@´iI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[@≥%I"#;FI"# `:success`;F@é&I"D# : Notification will be sent if `on_success` was set to `true`;Fi[[	@ﬂiI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@‚i6I""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@îiuI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@•iI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@®i&I""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@´iI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[I"# `:success`;F@é&@ü&I"#;FI"# `:warning`;Fi[[	@ﬂi I"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@‚i8I"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@îiwI"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@•iI"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@®i(I"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@´iI"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[@é&@ü&I"#;FI"# `:warning`;FI"D# : The backup completed successfully, but warnings were logged;Fi[[	@ﬂi!I"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@‚i9I"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@îixI"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@•iI"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@®i)I"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@´iI"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[@ü&I"#;FI"# `:warning`;F@¡&@_$i[[	@ﬂi"I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@‚i:I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@îiyI"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@•i I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@®i*I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@´iI"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[@'@(@)@	I"module ClassMethods;Fi[[	@Ωi>I"∂              super
            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2)
      ;Fi[	I"Ddata//activerecord_proj/active_record/validations/associated.rb;TiI"h          (var.marked_for_destruction? or var.valid?(var.validation_context))
        end.any?) then
          var.errors.add(var, :invalid, options.merge(:value => (var)))
        end
      end
    end
    
    module ClassMethods
      # Validates whether the associated object or objects are all valid
      # themselves. Works with any kind of association.;Fi[	@_iI"f          if var.present? and var.all? { |arglist| var.marked_for_destruction? } then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods
      # Validates that the specified attributes are not blank (as defined by
      # Object#blank?), and, if the attribute is an association, that the;Fi[	@ui!I"4              var = var.cascade_strategy
              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods
        # Attempt to add the cascading information for the document to know how
        # to handle associated documents on a removal.;Fi[	@ñiZI"          end
          unless var.empty? then
            var.criteria(var, self.class).without_options.pull(var.inverse_foreign_key, id)
          end
        end
      end
      
      module ClassMethods
        # Set up the syncing of many to many foreign keys.
        #;Fi[	@÷iêI"          if (_parent.nil? or instance_variable_get("@#{name}").!=(_parent)) then
            remove_instance_variable("@#{name}")
          end
        end
      end
    end
    
    module ClassMethods
      # This is convenience for librarys still on the old API.
      #;Fi[I"private;FI" ;FI"##;F@≤%@≥%i[[	@ﬂiI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@‚i2I"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@îiqI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@•iI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@®i"I"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@´iI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[@'@(@@Ñ$@Ö$i[[	@	iI"            var[:author_key] = "#{table_name}.#{options[:author_key]}"
          end
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@iI"∞          has_many(:attachments, var.merge(:as => :container, :order => ("#{Attachment.table_name}.created_on ASC, #{Attachment.table_name}.id ASC"), :dependent => :destroy))
          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@iI"4          send(:include, Redmine::Acts::Customizable::InstanceMethods)
          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@iI""          cattr_accessor(:event_options)
          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@i%I"Ö          searchable_options[:order_column] ||= searchable_options[:date_column]
          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@"iI"          end
          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[I"# `:warning`;F@¡&@_$@`$I"#;Fi[[	@ﬂi$I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@‚i<I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@îi{I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@•i"I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@®i,I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@´i I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[@¨@
@f@gI"end;Fi[[	@0	i	I"«  module ConnectionAdapters
    class Transaction
      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    
    class ClosedTransaction < Transaction;Fi[	I"4data//activerecord_proj/active_record/errors.rb;TiaI"≈  
  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  
  class UnknownPrimaryKey < ActiveRecordError;Fi[	@biI"        include(Devise::Controllers::Rememberable)
        
        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      
      # Remembers the given resource by setting up a cookie;Fi[	@piI"¬        def function(arglist)
          defined? @var ? (@var) : (Devise.scoped_views)
        end
        
        def function(arglist)
          @var = var
        end
      end
    end
  end;Fi[	@¡i-I"≤      "No available formula for #{name} #{dependent_s}"
    end
  end
  
  def function(arglist)
    @var = var
  end
end
module Homebrew
  class InstallationError < RuntimeError;Fi[	@áiI"Õ      
      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError
        attr_reader(:errors)
        
        def function(arglist)
          @var = var
        end
      end
    end
    ;Fi[@¡&@_$@`$I"#;FI"# `:failure`;Fi[[	@ﬂi%I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@‚i=I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@îi|I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@•i#I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@®i-I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@´i!I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[@'@T@;I"@var[var] = var;FI"end;Fi[[	@6i•I"Ÿ        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist);Fi[	@∑	iÅI"¶      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[	@ÚiI"é        else
          eval(@var[var])
        end
      end
      
      def function(arglist)
        @var[var] = var
      end
    end
    ;Fi[	@˙i3I"¶      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[	@ŒiÑI"«        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist);Fi[	@"itI"       
      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[I"nil;FI"end;FI"end;FI"end;FI"end;Fi[[	@…iCI"          begin
            var.instance_variable_set("@#{fixture_name}", var.find)
          rescue FixtureClassNotFound
            nil
          end
        end
      end
    end
    
    def self.instantiate_all_loaded_fixtures(arglist);Fi[	@*i*I"÷          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  ;Fi[	@YiI"á            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@bi≤I"e            nil
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@A
i$I"é          var.email_the_user(var, var)
          var
        else
          nil
        end
      end
    end
  end
  
  def function(arglist);Fi[	@∏iMI"¨        Object.send(:remove_const, Formula.class_s(name))
        var)
      rescue SyntaxError, TypeError, NameError, ArgumentError
        nil
      end
    end
  end
end;Fi[@°I"# `:failure`;F@c$I"H# : Notification will be sent, including the Exception which caused;FI"F# : the failure, the Exception's backtrace, a copy of the current;Fi[[	@ﬂi(I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@‚i@I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@îiI"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@•i&I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@®i0I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@´i$I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[@åI"end;FI" ;F@èI"2broadcast(var) { |arglist| var.accept(self) };Fi[[	@àiI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@àiI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ài0I"      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ài<I"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@àiPI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@àipI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[@©I"[];FI"end;FI"end;FI" ;Fi[[	@>iOI"    def function(arglist)
      if self[:without] then
        self[:without].split(":").map { |arglist| var.to_sym }
      else
        []
      end
    end
    
    # @local_config["BUNDLE_PATH"] should be prioritized over ENV["BUNDLE_PATH"]
    def function(arglist);Fi[	@…	i#I"          Dir.glob(File.join(templates_directory, "*")).map do |arglist|
            File.basename(var)
          end
        else
          []
        end
      end
      
      def function(arglist)
        File.join(templates_directory, var.to_s, "manifest.rb");Fi[	@≈$i#I"Á  def function(arglist)
    if defined? @var and (params[:controller] == "multis") then
      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist)
    defined? @var ? (@var.publisher.open?) : (false);Fi[	@ï
iºI"“            [:val, var[0], Integer(var[0])]
          end
        end
      else
        []
      end
    end
    
    def function(arglist)
      var = /"([^"\\]|\\["\/\\bfnrt]|\\u[0-9a-fA-F]{4})*"/.match(var);Fi[	@D#iõI"?    def function(arglist)
      if options[:fields] then
        options[:fields].keys.reject { |arglist| (var == "_type") }
      else
        []
      end
    end
    
    # When freezing a criteria we need to initialize the context first
    # otherwise the setting of the context on attempted iteration will raise a;Fi[	@Xi#I";      return [] unless libxml2?
      if compiled_parser_version.!=(loaded_parser_version) then
        ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end
    
    def function(arglist)
      var = {};Fi[@°I"# `:warning`;F@¡&@_$@`$i[[	@ﬂi#I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@‚i;I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@îizI"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@•i!I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@®i+I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@´iI"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[@©@U"@V"@W"I" ;Fi[[	I"%data//jekyll_proj/jekyll/post.rb;TiÁI"ı      var = self.site.posts.index(self)
      if var and (var < (self.site.posts.length - 1)) then
        self.site.posts[(var + 1)]
      else
        nil
      end
    end
    
    def function(arglist)
      var = self.site.posts.index(self);Fi[	@i\I"Ï      def function(arglist)
        if relation.stores_foreign_key? and polymorphic? then
          "#{name}_#{field}"
        else
          nil
        end
      end
      
      # Deterimene the inverses that can be memoized.
      #;Fi[	I"5data//paperclip_proj/paperclip/interpolations.rb;TiéI"        ("%09d" % var).scan(/\d{3}/).join("/")
      when String then
        var.scan(/.{3}/).first(3).join("/")
      else
        nil
      end
    end
    
    # Returns the pluralized form of the attachment name. e.g.
    # "avatars" for an attachment of :avatar;Fi[	@%i.I"ï        var = new(*var)
        var.to_s = var
        var
      else
        nil
      end
    end
    
    def self.attach(arglist)
      find(var);Fi[	@Ú
iI"           else
            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist)
        determine_best_match(var, var);Fi[	@iI"N            var.jump(:ident).source.to_sym
          when :string_literal then
            var.jump(:tstring_content).source
          else
            nil
          end
        end
        
        # Extracts the values from the node as either strings or symbols.
        # If the node isn't an array, it'll be converted to an array.;Fi[@¨@
@I@JI"end;Fi[[	@0	ipI"¶      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end
    end
    
    class RealTransaction < OpenTransaction;Fi[	@6iÄI"ñ        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end;Fi[	@„i,I"É  def function(arglist)
    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	I"%data//haml_proj/haml/template.rb;TiI"º  
  module Util
    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end
Haml::Template.options[:ugly] = Rails.env.development?.!;Fi[	@íiI"≥    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|;Fi[	I":data//rspec_proj/spec/interop/test/unit/autorunner.rb;TiI"nclass Test::Unit::AutoRunner
  remove_method(:process_args)
  
  def function(arglist)
    true
  end
end;Fi[@Ñ$@Ö$@Ü$I"end;FI" ;Fi[[	@	iI"        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Returns events of type event_type visible by user that occured between from and to;Fi[	@iI"A        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:view_permission], self.project);Fi[	@iI"        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          CustomField.where("type = '#{self.class.name}CustomField'").sorted.all;Fi[	@iI"'        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["datetime", "title", "description", "author", "type"].each do |arglist|
          var = "            def event_#{attr}\n              option = event_options[:#{attr}]\n              if option.is_a?(Proc)\n                option.call(self)\n              elsif option.is_a?(Symbol)\n                send(option)\n              else\n                option\n              end\n            end\n";Fi[	@i(I"‰        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Searches the model for the given tokens;Fi[	@"iI"Ù        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers
        def function(arglist);Fi[@°I"# `:success`;F@é&@ü&I"#;Fi[[	@ﬂiI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@‚i7I"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@îivI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@•iI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@®i'I"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@´iI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[@9!I"var = "LTRB";FI"var = "LRT";FI"var = "LR";FI"	else;Fi[[	@•icI"¸    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@®iXI"¸    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@´iRI"¸    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@.i8I"    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "\n")
    var = 0
    if var.!=(0) then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.index("L").nil?;Fi[	@1i/I"≈    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then
          var = "";Fi[	@1i˙I"ﬁ    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then
          var = "";Fi[I"out("endobj");FI"end;FI" @var.each_pair do |arglist|;FI"newobj;FI"@var[var]["n"] = @var;Fi[[	@•iÙI"C    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@•iI"ˆ      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[	@®i˝I"C    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@®iI"ˆ      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[	@´i„I"C    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@´iıI"ˆ      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[@@@@∞I" ;Fi[[	@riGI"O    # Hook method that gets called by the initializer allowing verification
    # that the arguments supplied are valid. You could for example raise an
    # +ArgumentError+ when invalid options are supplied.
    def function(arglist)
      # do nothing
    end
  end
  
  class BlockValidator < EachValidator
    def function(arglist);Fi[	@0	i%I"‡      end
      
      # This is a noop when there are no open transactions
      def function(arglist)
        # do nothing
      end
    end
    
    class OpenTransaction < Transaction
      attr_reader(:parent, :records);Fi[	@ÄiI"–          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist)
        @var = (var or EmptyBackground.new);Fi[	@6iI"ü          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable)
      ;Fi[	@Mi\I"∂      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    
    class JsLanguage
      include(LanguageSupport::LanguageMethods);Fi[	@biI"„          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize)
      ;Fi[@°I"#   class Person;FI"0#     include ActiveModel::AttributeMethods;FI"#;FI"#     attr_accessor :name;Fi[[	@i#I"K      #
      # An instance method <tt>#{prefix}attribute</tt> must exist and accept
      # at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_prefix 'clear_'
      #     define_attribute_methods :name;Fi[	@iGI"L      #
      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@ikI"s      #
      # An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and
      # accept at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
      #     define_attribute_methods :name;Fi[	@iÅI"      end
      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@i√I"x      # To use, pass an attribute name (as string or symbol), be sure to declare
      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #;Fi[	@iÍI"0      end
      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name;Fi[@'@T@;I"var = TestBall.new;FI"*var.stable.instance_eval do |arglist|;Fi[[	I"/data//homebrew_proj/test/test_checksums.rb;TiI"	    assert_raises(ChecksumMismatchError) do |arglist|
      nostdout { |arglist| var.brew { |arglist| } }
    end
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end;Fi[	@1(iI"‰      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("61aa838a9e4050d1876a295a9e62cbe6")
    end;Fi[	@1(i"I"Ï      md5("61aa838a9e4050d1876a295a9e62cbe6")
    end
    bad_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end;Fi[	@1(i*I"ˆ      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e")
    end;Fi[	@1(i2I"      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e")
    end
    bad_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end;Fi[	@1(i:I"*      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("dcbf5f44743b74add648c7e35e414076632fa3b24463d68d1f6afc5be77024f8")
    end;Fi[@@Ö@ÜI"end;FI"end;Fi[[	I"1data//activemodel_proj/active_model/model.rb;Ti'I"ê    #
    #  person = Person.new(id: 1, name: 'bob')
    #  person.persisted? # => false
    def function(arglist)
      false
    end
  end
end;Fi[	@Ñi4I"g        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@áißI"õ      end
      
      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@>i?I"\      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@jieI"õ        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/railties/document.rb;TiI"∫    # only supports immediate deletion of associations.
    #
    # See ActionView::Helpers::FormHelper::fields_for for more info.
    def function(arglist)
      false
    end
  end
end;Fi[@'@(@@	I"var = [];Fi[[	@<i,I"I            var[(var..var)].join("\n")
          else
            "# Couldn't get snippet for #{file}"
          end
        end
        
        def function(arglist)
          var = []
          var.split("\n").each_with_index do |arglist|
            var = "<span class=\"linenum\">#{((offending_line + i) - 2)}</span>#{line}";Fi[	@1i+I"Å  def function(arglist)
    if keg and keg.completion_installed?(:zsh) then
      "      zsh completion has been installed to:\n        #{HOMEBREW_PREFIX}/share/zsh/site-functions\n".undent
    end
  end
  
  def function(arglist)
    var = []
    if (f.plist or (keg and keg.plist_installed?)) then
      var = f.plist_startup ? ("/Library/LaunchDaemons") : ("~/Library/LaunchAgents");Fi[	@:iLI"Ø          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = []
    var = []
    var = "";Fi[	@ i=I"Ú  def function(arglist)
    join("lib").find do |arglist|
      break var if (var.basename == Pathname.new(var))
    end
  end
  
  def function(arglist)
    var = []
    var = ["bin", "lib", "Frameworks"]
    var.map! { |arglist| join(var) };Fi[	@iiI"C        def function(arglist)
          if (new_record? or custom_field_values_changed?) then
            custom_field_values.each(&:validate_value)
          end
        end
        
        def function(arglist)
          var = []
          custom_field_values.each do |arglist|
            if var.value.is_a?(Array) then;Fi[	@„i4I"I            var[(var..var)].join("\n")
          else
            "# Couldn't get snippet for #{file}"
          end
        end
        
        def function(arglist)
          var = []
          var.split("\n").each_with_index do |arglist|
            var = "<span class=\"linenum\">#{((offending_line + i) - 2)}</span>#{line}";Fi[I"# `:failure`;F@c$@c'@d'I"K# : backup log and other information if `on_failure` was set to `true`;Fi[[	@ﬂi)I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@‚iAI"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@îi{I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@•i'I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@®i1I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@´i%I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[I"	end);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@#iQI"ö          if target.persisted? and (owner.persisted? and target.save.!) then
            set_owner_attributes(target)
            raise(RecordNotSaved, ("Failed to remove the existing associated #{reflection.name}. " + "The record failed to save after its foreign key was set to nil."))
          end)
        end
      end
      
      def function(arglist)
        var[reflection.foreign_key] = nil
      end;Fi[	@£ipI"∏        exec_query("PRAGMA index_list(#{quote_table_name(table_name)})", "SCHEMA").map do |arglist|
          IndexDefinition.new(var, var["name"], var["unique"].!=(0), exec_query("PRAGMA index_info('#{row["name"]}')", "SCHEMA").map do |arglist|
            var["name"]
          end)
        end
      end
      
      def function(arglist)
        var = table_structure(var).find { |arglist| (var["pk"] == 1) }
        var and var["name"];Fi[	@iGI"      var.any? do |arglist|
        (var or specs_changed?(var) do |arglist|
          var.class.===(var.class) and (var.uri == var.uri)
        end)
      end
    end
    
    def function(arglist)
      @var.any? do |arglist|
        next unless var.instance_of?(Source::Path);Fi[	@)iíI"Ø        var.reject! { |arglist| var.version.prerelease? } unless (var or var)
        var.sort_by do |arglist|
          [var.version, (var.platform.to_s == "ruby") ? ("\x00") : (var.platform.to_s)]
        end)
      end
    end
    
    def function(arglist)
      specs_by_name(var.name).select do |arglist|
        same_version?(var.version, var.version) and (Gem::Platform.new(var.platform) == Gem::Platform.new(var.platform));Fi[	@'i.I"∫          end
        else
          var = []
        end)
      end
    end
    
    def function(arglist)
      if var.to_s.include?(">= 0") then
        var.to_s.gsub(/ \(.*?\)$/, "");Fi[	@!i@I"g            if @var.any?(&:repeat_x?) then
              calculate_repeat_extra_width!
              tile_images_that_repeat
            end)
          end
        end
        
        def function(arglist)
          @var.map { |arglist| var if var.repeat_x? }.compact.each do |arglist|
            var = (var.left - ((var.left / var.width).ceil * var.width));Fi[@c$@c'@d'@`(I"#;Fi[[	@ﬂi*I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@‚iBI"ò      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@îi|I"ò      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@•i(I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@®i2I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@´i&I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[@c'@d'@`(I"#;FI"def function(arglist);Fi[[	@ﬂi+I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@‚iCI"{      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@îi}I"{      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@•i)I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@®i3I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@´i'I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[@d!@≤%@≥%I"#;FI"# `:success`;Fi[[	@ﬂiI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@‚i4I"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@îisI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@•iI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@®i$I"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@´iI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[@+@)@*@/I"
begin;Fi[[	@–iI"⁄    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled
        var = ActiveRecord::Base.connection_id;Fi[	@g	iI"R      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database)
          connection.create_database(configuration["database"], creation_options);Fi[	@l	iI"}      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var
          connection.create_database(configuration["database"], configuration.merge("encoding" => (encoding)));Fi[	@,iI"ﬂ    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then
          Bundler.definition.ensure_equivalent_gemfile_and_lockfile(true);Fi[	@	i9I"      
      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false unless var.has_key?(var) and (var == var[var]);Fi[	@	iNI"
      
      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false if var.has_key?(var) and (var == var[var]);Fi[@°@(I"+#     include ActiveModel::Validations;FI"#;FI"#     attr_accessor :name;Fi[[	@4i~I"k      # <tt>ActiveModel::StrictValidationFailed</tt> instead of adding error
      # when validation fails. See <tt>validates</tt> for more information about
      # the validation itself.
      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name
      #     validates! :name, presence: true
      #   end;Fi[	I"7data//activemodel_proj/active_model/validations.rb;TiπI"    
    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@«(i I"    
    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@«(i⁄I"D    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[	@«(iÒI"    
    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@«(iI"D    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[@©I"	true;FI"end;FI"end;FI" ;Fi[[	@áiuI"ÿ          inverse_updates_counter_cache?(through_reflection).!
        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested;Fi[	@Êi?I"	  def function(arglist)
    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist)
    var = StatusMessage.find_by_guid(self.status_message_guid);Fi[	@ÊiHI"    var = StatusMessage.find_by_guid(self.status_message_guid)
    if self.status_message_guid and var then
      (self.diaspora_handle == var.diaspora_handle)
    else
      true
    end
  end
  
  def self.diaspora_initialize(arglist)
    var = self.new(var.to_hash);Fi[	@irI"•    @var = case @var
    when :provided_pre_mountain_lion then
      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function
  ;Fi[	@íi4I"Ø          else
            @var[:fog_public]
          end
        else
          true
        end
      end
      
      def function(arglist)
        for var, var in @var do;Fi[	@⁄i\I"        @var = @var = nil
        raise(var) if var
        var.!
      else
        true
      end
    end
    
    # Runs the machine's +before+ callbacks for this transition.  Only
    # callbacks that are configured to match the event, from state, and to;Fi[@`$I"#;FI"# `:failure`;F@c$@c'i[[	@ﬂi'I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@‚i?I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@îi~I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@•i%I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@®i/I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@´i#I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[I"2File.open("_posts/#{name}", "w") do |arglist|;FI"var.puts(var);F@%I"var.puts(var);FI"end;Fi[[	@ÊiI"s        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@Èi"I"E        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@ÏiI"V        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@¸$i1I"`          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end
        var = (var + 1);Fi[	@ÚiI"O        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@¯i_I"#      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end
    ;Fi[@'@T@;I"teardown_db;FI"end;Fi
[
[	I">data//redmine_proj/plugins/acts_as_list/test/list_test.rb;Ti2I"∆  def function(arglist)
    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@
)iºI"ﬁ    (1..4).each do |arglist|
      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	I"Fdata//redmine_proj/plugins/acts_as_tree/test/acts_as_tree_test.rb;Ti?I"¡    @var = TreeMixin.create!(:parent_id => (@var.id))
    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@)ióI",    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@)iΩI"∞    setup_db
    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[@¨@
I"@var ||= {};FI"end;FI" ;Fi
[
[	@‹iI"        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("#{self}##{name} has been deprecated as of " + "backup v.#{deprecation[:version]}");Fi[	@PiJI"ñ      end
      
      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {};Fi[	@PiNI"”      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] };Fi[	@÷
iìI">          load_translations(var)
          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        # Looks up a translation from the translations hash. Returns nil if
        # eiher key is nil, or locale, scope or key do not exist as a key in the;Fi[	@„iI"Ë        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("#{intro} received unexpected message :#{sym}#{arg_message(*args)}");Fi[@+@,@_I"@var = var;FI"@var = var;Fi
[
[	@”ieI"      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s)
      end;Fi[	@iI"‘    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = []
      @var = Hash.new { |arglist| var[var] = Set.new };Fi[	@∑	i#I"ƒ    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var.fetch(:via, :sftp);Fi[	@∑	i$I"…    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var.fetch(:via, :sftp)
      @var = var.delete(:logger);Fi[	@Oi+I"Ÿ        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        ;Fi[I"#     end;FI"#   end;FI"#;FI"#   person = Person.new;FI"#   person.name = 'Bob';Fi
[
[	@i/I"˘      #
      #     def clear_attribute(attr)
      #       send("#{attr}=", nil)
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.clear_name;Fi[	@iSI"      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.name_short?   # => true;Fi[	@ièI"      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob"
      #   person.nickname        # => "Bob";Fi[	@i”I"      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob"
      #   person.name_short? # => true;Fi[	@iˆI"„      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true
      #;Fi[@¨@
I"	to_s;FI"end;FI" ;Fi
[
[	@“	iI"°      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var);Fi[	@riI"‹      end
      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    
    def self.color_to_s(arglist)
      var.is_a?(Sass::Script::String) ? (var.value.dup) : (var.inspect.dup);Fi[	@ri9I"2        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var);Fi[	I"Qdata//compass_proj/compass/sass_extensions/monkey_patches/browser_support.rb;Ti%I"ß    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "#{name}(#{args.join(", ")})";Fi[	I"1data//mongoid_proj/lib/mongoid/extensions.rb;TiI"≥end
class Moped::BSON::ObjectId
  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist)
    ActiveSupport::XmlMini.to_tag(var[:root], self.to_s, var);Fi[@+@,@_@%)I"end;Fi
[
[	@!iI"§    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function;Fi[	@4iI"Œ    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick;Fi[	@Oi,I"¬        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@ÑiI"Ù    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.;Fi[	@9iI"H      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created;Fi[@¨@
I"[];FI"end;FI" ;Fi
[
[	@>i
I"à    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0;Fi[	@ÄiI"¬        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var);Fi[	@áiAI"s  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    [];Fi[	@áiEI"©  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end
  
  def self.excluding_blocks(arglist)
    var = var.blocks.map { |arglist| var.person_id };Fi[	@ßiI"∫      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?;Fi[@'@T@€@‹I"private;Fi
[
[	I"Qdata//activerecord_proj/active_record/associations/belongs_to_association.rb;TiI"£      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function
      
      private
      
      def function(arglist);Fi[	I"Pdata//activerecord_proj/active_record/attribute_methods/before_type_cast.rb;TiI"˝      #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      
      private
      
      # Handle *_before_type_cast for method_missing.;Fi[	@i∫I"Í            @var = var.slice((4..-36))
            @var = var.slice((-32..-1))
            @var = @var.sub((@var + "/"), "")
          end
          
          attr_reader :function
          
          private
          
          ##;Fi[	@á	i.I"Ñ      end
      check_requirement!
      @var
    end
    
    attr_reader :function
    
    private
    
    def function(arglist);Fi[	@√iI"œ      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      
      private
      
      # Searches the path, looking for the given utility. If an executable;Fi[I"if var then;F@9!I"var = "LTRB";FI"var = "LRT";FI"var = "LR";Fi
[
[	@•ibI"ﬂ    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@®iWI"ﬂ    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@´iQI"ﬂ    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@1i.I"œ    var = var.gsub("\r", "")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then;Fi[	@1i˘I"Ÿ    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then;Fi[@'@(@@	I"var = 0;Fi
[
[	@<iwI"O        @var.script do |arglist|
          @var.text!("makeYellow('cucumber-header');") unless @var
          @var.text!("makeYellow('scenario_#{@scenario_number}');") unless @var
        end
      end
      
      def function(arglist)
        var = 0
        var = var.instance_variable_get("@features")
        var.each do |arglist|;Fi[	@(iãI"    end
    if unconfirmed_email_changed? then
      self.confirm_email_token = unconfirmed_email ? (SecureRandom.hex(15)) : (nil)
    end
  end
  
  def function(arglist)
    var = 0
    var.each do |arglist|
      self.aspects.find(var).update_attributes(:order_id => (var));Fi[	@•i;I"¢      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[	@®i+I"§      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[	@´i*I"¢      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[@'@TI"#:nodoc:;FI"def function(arglist);FI"
begin;Fi
[
[	@∂iI"¶        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("COMMIT")
        rescue;Fi[	@∂iI"®        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("ROLLBACK")
        rescue;Fi[	@ñiI"      module ReferentialIntegrity
        def function(arglist)
          true
        end
        
        #:nodoc:
        def function(arglist)
          begin
            (if supports_disable_referential_integrity? then
              execute(tables.collect do |arglist|;Fi[	@6i—I"Ì          var[0].value = var
          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          require("diff/lcs")
        rescue LoadError => var;Fi[	@ØiHI"˘        else
          raise(MockExpectationError, "The method `#{message}` was not stubbed or was already unstubbed")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          verify_expectations
        ensure;Fi[@@@@I" ;Fi
[
[	@#i7I"«          when :nullify then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private
      ;Fi[	@óiéI"#          begin
            sessions.delete(var).close
          rescue IOError
            # do nothing
          end
        end
      end
      
      # Determines the set of servers within the current task's scope and
      # establishes connections to them, and then yields that list of;Fi[	@4ipI"¨      when "open-mpi", "mpich2" then
        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|;Fi[	@4iŒI",      when /macports\/trunk/ then
        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then;Fi[	@¿iΩI"≥      when ".7z" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("r") { |arglist| var.read(1024) });Fi[@'@(@@	I"# do nothing;Fi
[
[	@”i·I"ﬁ          if has_inverse? and inverse_of.nil? then
            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ıi+I"˜        def function(arglist)
          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@ôiÖI"          print_elements(var, :passed, "scenarios")
        else
          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@£iyI"ß            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@ŒiI"€            @var.puts(@var.description.gsub(/ \(druby.*\)/, ""))
            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[@¨@
@?'I"end;FI" ;Fi
[
[	@6i¶I"Ÿ          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var];Fi[	@∑	iÇI"≥      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!;Fi[	@˙i4I"ª      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var;Fi[	@ŒiÖI"Ω          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var];Fi[	@"iuI"      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call);Fi[@@∞I"reconnect_ssl;FI"end;FI" ;Fi
[
[	@piˇI"õ  
  ##
  # Sets this client's OpenSSL::X509::Certificate
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :cert= :certificate=
  ;Fi[	@pi	I"‘  # For Net::HTTP parity
  ##
  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Overrides the default SSL certificate store used for verifying;Fi[	@piI"Î  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Finishes all connections on the given +thread+ that were created before;Fi[	@pi‰I"è  
  ##
  # Sets this client's SSL private key
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :key= :private_key=
  ;Fi[	@piÊI")  # Setting this to VERIFY_NONE is a VERY BAD IDEA and should NEVER be used.
  # Securely transfer the correct certificate and update the default
  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # SSL verification callback.;Fi[I"require("rubygems");FI"require("sequel");FI"require("fileutils");FI"require("yaml");FI"module Jekyll;Fi
[
[	@‹i I"órequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Drupal
    QUERY = "SELECT n.nid,                     n.title,                     nr.body,                     n.created,                     n.status              FROM node AS n,                   node_revisions AS nr              WHERE (n.type = 'blog' OR n.type = 'story')              AND n.vid = nr.vid";Fi [	@Êi I"Ürequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Joomla
    def self.process(arglist);Fi [	@Ïi I"xrequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module MT
    QUERY = "SELECT entry_id,                     entry_basename,                     entry_text,                     entry_text_more,                     entry_authored_on,                     entry_title,                     entry_convert_breaks              FROM mt_entry";Fi [	@Úi I"\require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module TextPattern
    QUERY = "SELECT Title,                     url_title,                     Posted,                     Body,                     Keywords              FROM textpattern              WHERE Status = '4' OR                    Status = '5'";Fi [	@¯i I"ârequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module WordPress
    def self.process(arglist);Fi [@@÷@◊@ÿI"module ClassMethods;Fi
[
[	@]i+I"ˇ        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length)
      end;Fi[	@<iyI"„      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.
        #;Fi[	@MiI"Ù      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@Æ#i(I"      # @return [ true ] If the object is unconvertable.
      #
      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@Yi)I"Ê      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #;Fi[@@÷@◊I"end;FI"end;Fi
[
[	@6iÅI"|          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@ø'iI"Â  module Util
    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end
Haml::Template.options[:ugly] = Rails.env.development?.!
Haml::Template.options[:escape_html] = true;Fi[	@<i£I"ñ        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@Pi¿I"ñ        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@íiI"›      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|
  (var.nil? or (Paperclip::Attachment.===(var) and var.present?.!));Fi[@O'@P'@Q'I" ;FI"def function(arglist);Fi
[
[	@ƒi;I"        begin
          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var
          nil
        end
      end
      
      def function(arglist)
        var = nil
        var = java.lang.Thread.new { |arglist| var = STDIN.gets };Fi[	@(ikI"æ    begin
      self.invitations_to_me.first.sender.invitation_code
    rescue Exception => var
      nil
    end
  end
  
  def function(arglist)
    self.invited_by = var.user
    var.use!;Fi[	@®'iËI"      if var and (var < (self.site.posts.length - 1)) then
        self.site.posts[(var + 1)]
      else
        nil
      end
    end
    
    def function(arglist)
      var = self.site.posts.index(self)
      var and (var > 0) ? (self.site.posts[(var - 1)]) : (nil);Fi[	@¿i≠I"€              # do nothing
            end)
          rescue Nokogiri::SyntaxError, RuntimeError
            nil
          end
        end
        
        def function(arglist)
          @var = var
          @var = nil;Fi[	@Ú
iI"’            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist)
        determine_best_match(var, var)
        best_match[:line];Fi[@I"@var.empty?;TI"end;TI" ;TI"def function(arglist);Fi
[
[	@á	i9I"Å      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first
    end;Fi[	@' i.I"‘        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length }
        var.max;Fi[	@bifI"ı        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) }
      end;Fi[	@i´I"î    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end;Fi[	@UiI"ß    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?
    curl(*external_curl_args);Fi[@'@(@I"# :nodoc:;FI"def function(arglist);Fi
[
[	@piÖI"ü      var.finish)
    rescue IOError
      # do nothing
    end
  end
  
  # :nodoc:
  def function(arglist)
    if (RUBY_VERSION > "2.0") then
      Net::HTTP;Fi[	@’i-I"·    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist)
    if File.exist?("spec/spec.opts") then
      "-O #{File.join("spec", "spec.opts")} ";Fi[	@(iI"€          var
        else
          Spec.warn(Spec::Example::NoDescriptionError.message("example", @var.location))
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var.options
      end;Fi[	@¥iòI"≤          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["SPEC"] then
          FileList[ENV["SPEC"]];Fi[	@i+I"√          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= mock_framework_path("rspec")
      end;Fi[@¨I"protected;FI" ;F@
I"
begin;Fi
[
[	@5	iI"%      def function(arglist)
        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin
          @var.instrument("sql.active_record", :sql => (var), :name => (var), :connection_id => (object_id), :binds => (var)) do |arglist|
            yield;Fi[	@U	i∞I"÷        false
      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find(var);Fi[	@JiI"©        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift
        var = Compass::Commands[$command];Fi[	@√i≤I"«    end
    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin
      if var.symlink? and var.directory? then
        var = (var.parent + var.readlink).cleanpath;Fi[	@≤iéI"‚        (var << var) unless var.nil?
        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin
          @var.call(*var)
        rescue => var;Fi[@¨@
I"teardown_db;FI"end;FI" ;Fi
[
[	@
)i3I"    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi[	@
)iΩI"4      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id));Fi[	@)i@I"π    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var]);Fi[	@)iòI"[    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "mixins.parent_id IS NULL", :order => "mixins.id");Fi[	@)iæI"·    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root));Fi[@I"@var[var] = var;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@6ißI"«            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end;Fi[	@∑	iÉI"°        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!
      end;Fi[	@˙i5I"ª        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var
        @var = (var = false;Fi[	@ŒiÜI"¥          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end;Fi[	@"ivI"¸        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end;Fi[@'@T@ù)@û)I"@var.each do |arglist|;Fi
[
[	@qiüI"=      instance_write(:fingerprint, nil)
      instance_write(:created_at, nil) if has_enabled_but_unset_created_at?
      instance_write(:updated_at, nil)
    end
    
    #:nodoc:
    def function(arglist)
      @var.each do |arglist|
        [var].flatten.each { |arglist| instance.errors.add(name, var) }
      end;Fi[	I"9data//paperclip_proj/paperclip/storage/filesystem.rb;TiI"#      
      def function(arglist)
        original_filename ? (File.exist?(path(var))) : (false)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          FileUtils.mkdir_p(File.dirname(path(var)))
          File.open(path(var), "wb") do |arglist|;Fi[	@n*i!I"»        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}");Fi[	@iƒI"Ë      
      def function(arglist)
        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("saving #{path(style)}");Fi[	@i‡I"»        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}");Fi[@'@T@;I"@var.each(&var);FI"end;Fi
[
[	@“iI"¶      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist);Fi[	@' i#I"˛      # Duplicates this instance and adds +step_invocations+ to the end
      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist);Fi[	@6iXI"Ê          map do |arglist|
            var.value ? (escape_cell(var.value.to_s).unpack("U*").length) : (0)
          end.max
        end
        
        def function(arglist)
          @var.each(&var)
        end
      end
      ;Fi[	@i≠I"Ä  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist);Fi[	@UiI"ê  
  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist);Fi[@'@T@;I"+source_tags.map { |arglist| var.name };FI"end;Fi
[
[	@ıigI"ø      # backgrounds don't have tags.
      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
    end
  end;Fi[	@¥i=I"Ω      
      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@Ÿ	iGI"ı      
      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@3i'I"ƒ      
      def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@3iQI"Ÿ        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist);Fi[@õ@ú@Ç@ÉI"@var = var if var;Fi
[
[	@≤iˇI"¿      
      def function(arglist)
        set_expected_received_count(:at_most, var)
        self
      end
      
      def function(arglist)
        @var = var if var
        self
      end;Fi[	@≤iI"±      
      def function(arglist)
        @var = var if var
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = :any
        self;Fi[	@≤iI"•      
      def function(arglist)
        @var = 0
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 1
        self;Fi[	@≤iI"∏      def function(arglist)
        @var = var if var
        @var = 1
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 2
        self;Fi[	@≤iI"       def function(arglist)
        @var = var if var
        @var = 2
        self
      end
      
      def function(arglist)
        @var = var if var
        @var.register(self)
        @var = true;Fi[@°I"$# @example Define the relation.;FI"#;FI"#   class Person;FI"$#     include Mongoid::Document;Fi
[
[	@ài$I"è        # necessary to set the references from the child back to the parent
        # document. If a child does not define this relation calling
        # persistence methods on the child object will cause a save to fail.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses
        #   end;Fi[	@àiBI"Y        # Adds the relation from a parent document to its children. The name
        # of the relation needs to be a pluralized form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses
        #   end;Fi[	@ài^I"N        # Adds the relation from a parent document to its child. The name
        # of the relation needs to be a singular form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_one :name
        #   end;Fi[	@àiéI"1        
        # Adds a relational association from a parent Document to many
        # Documents in another database or collection.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_many :posts
        #   end;Fi[	@ài™I"C        
        # Adds a relational many-to-many association between many of this
        # Document and many of another Document.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_and_belongs_to_many :preferences
        #   end;Fi[@°I"0# @return [ Class ] The class being set up.;FI"#;FI"# @since 2.0.0.rc.1;FI"def function(arglist);Fi
[
[	@i∂I"m        #
        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method(var) { |arglist| get_relation(var, var, var) }
          self;Fi[	@iŸI"s        #
        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("#{name}=") do |arglist|
            without_autobuild do |arglist|;Fi[	@\i.I"R        #   Person.builder("name")
        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("build_#{name}") do |arglist|
            var, var = parse_args(*var);Fi[	@\iGI"S        #   Person.creator("name")
        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("create_#{name}") do |arglist|
            var, var = parse_args(*var);Fi[	@êiI"6        #   Movie.polymorph(metadata)
        #
        # @param [ Metadata ] metadata The relation metadata.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          if var.polymorphic? then
            self.polymorphic = true;Fi[@t&@u&@v&@w&I"8raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi
[
[	I"#data//homebrew_proj/cmd/cat.rb;Ti I"Àmodule Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    cd(HOMEBREW_REPOSITORY)
    exec("cat", ARGV.formulae.first.path, *ARGV.options_only);Fi [	@l#iI"∑require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("--deps") then
      var = [];Fi[	@—iI"require("formula_installer")
require("hardware")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("--head") then
      raise("Specify `--HEAD` in uppercase to build from trunk.");Fi[	I"$data//homebrew_proj/cmd/test.rb;TiI"Ôrequire("extend/ENV")
require("hardware")
require("keg")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    ENV.extend(HomebrewEnvExtension)
    ENV.setup_build_environment;Fi[	@w#iI"–require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    var = Formula.select do |arglist|
      ARGV.formulae.all? do |arglist|;Fi[@÷%@◊%I"end;FI" ;FI"def function(arglist);Fi
[
[	@RiI"          @var = var
          @var = var
          @var = (var.first and var.first.class)
          @var = nil
          @var = nil
        end
        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end;Fi[	@iI"±      @var = []
      @var = []
      @var = []
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      begin
        (var ||= Bundler.read_file(var.to_s);Fi[	@√i®I"ï    
    def function(arglist)
      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end;Fi[	@◊iI"      def function(arglist)
        @var = (var == :no) ? (0) : (var)
        @var = var
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var ||= { :exactly => "", :at_least => "at least ", :at_most => "at most " }
      end;Fi[	@ıiI"ﬁ        @var = []
        @var = 0
        @var = 0
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var = var
        formatters.each { |arglist| var.example_group_started(var) };Fi[I"# @author Nicola Asuni;FI"# @since 1.5.2;FI"#;FI"def function(arglist);FI"return @var;Fi
[
[	@1iûI"£  #
  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@1i™I"®  #
  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@1i∂I"™  #
  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@1i¬I"≠  #
  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@1iŒI"√  #
  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[@'@˝%I"var = var;FI"var = 0;FI"if (var == 1) then;Fi
[
[	@•i⁄I"#        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@®i‚I"#        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@´i…I"#        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@.i¥I"        else
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@1iÕI"        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[@Í%@Î%@Ï%@Ì%I"#assert(var.text_executable?.!);Fi
[
[	@%iGI"7    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var));Fi[	@%iUI"-    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var));Fi[	@%icI"4    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var));Fi[	@%iqI"%    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert((var.arch == :dunno));Fi[	@%i∞I"$    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs)
    assert((var.arch == :dunno));Fi[I"# @since 1.5.2;FI"#;FI"def function(arglist);FI"return @var;FI"end;Fi
[
[	@1iüI"–  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale);Fi[	@1i´I"”  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth);Fi[	@1i∑I"◊  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight);Fi[	@1i√I"‹  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin);Fi[	@1iœI"Ú  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor);Fi[@¨@€I" ;FI"private;FI" ;Fi
[
[	@t)iI"æ        super
        @var = false
      end
      
      attr_reader :function
      
      private
      
      def function(arglist)
        loaded?.! and (foreign_key_present? and klass);Fi[	@w)iI"»      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      
      private
      
      # Handle *_before_type_cast for method_missing.
      def function(arglist);Fi[	@iªI"	            @var = var.slice((-32..-1))
            @var = @var.sub((@var + "/"), "")
          end
          
          attr_reader :function
          
          private
          
          ##
          # Sanitize string and replace any invalid UTF-8 characters.;Fi[	@á	i/I"†      check_requirement!
      @var
    end
    
    attr_reader :function
    
    private
    
    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/;Fi[	@√iI"¯        @var = var
        self
      end
      
      attr_reader :function
      
      private
      
      # Searches the path, looking for the given utility. If an executable
      # file is found that matches the parameter, this returns true.;Fi[@¨@€@+I"attr_reader :function;FI" ;Fi
[
[	@GiHI"‰        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Returns true if the record is persisted, i.e. it's not a new record and it was
    # not destroyed, otherwise returns false.;Fi[	@Ã	ieI"¥      def function(arglist)
        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      
      protected
      ;Fi[	@qiûI"7      var = @var[:processors]
      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Saves the file, if there are no errors. If there are, it flushes them to
    # the instance's errors and returns false, cancelling the save.;Fi[	@‘iI"Ω          @var = 0
          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist)
          @var = var;Fi[	@iiOI"∞    attr_reader(:results)
    
    private
    
    attr_reader :function
    
    attr_reader :function
    
    # Gets the object being transitioned
    def function(arglist);Fi[@I"super(var);FI"(instance_eval(&var) if block_given?;FI"end;FI" ;Fi
[
[	@ﬂiI"—      # Campfire account's subdomain
      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@îilI"-      # Folder where mail will be kept when using the `:file` `delivery_method` option.
      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@•iI"‡      ##
      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@®iI"Ã      # The message title
      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@´iI"Ã      # Twitter consumer key credentials
      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[@'@TI"J# Creates a scope for finding records *without* a particular state or;FI"# states for the attribute;FI"def function(arglist);Fi
[
[	@™iLI"å      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} NOT IN (?)", var] })
      end;Fi[	@ixI"]      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) }
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute.to_sym.not => (var)) }
      end;Fi[	@≠iGI"ç        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "$in" => (var) }) }) }
        end)
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "$nin" => (var) }) }) };Fi[	@∞iII"ç      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$nin" => (var) }) } })
      end;Fi[	@izI"ç      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.exclude(attribute_column => (var)) })
      end;Fi[@°I"-# @return [ Hash ] The object mongoized.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi
[
[	@PiØI"A        #   Hash.mongoize([ 1, 2, 3 ])
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return if var.nil?
          evolve(var).update_values { |arglist| var.mongoize };Fi[	@YiI"ﬂ      #
      # @example Mongoize the object.
      #   range.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Range.mongoize(self)
      end;Fi[	@YiCI"7        #   Range.mongoize(1..3)
        #
        # @param [ Range ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : ({ "min" => (var.first), "max" => (var.last) })
        end;Fi[	@_iI"€      #
      # @example Mongoize the object.
      #   set.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self)
      end;Fi[	@_i+I"˘        #   Set.mongoize(1..3)
        #
        # @param [ Set ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.to_a
        end;Fi[@…#I" ;F@À#I" ;FI"bottle do |arglist|;Fi
[
[	@Œ#iîI"-class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    url("file:///foo.com/testball-0.1-bottle.tar.gz")
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");Fi[	@Œ#i·I"class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
  end;Fi[	@Œ#iI"class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :lion)
  end;Fi[	@Œ#iˇI"Iclass AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion);Fi[	@Œ#iI"class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[@I"@var = {};FI"end;FI" ;FI"def function(arglist);Fi
[
[	@6i£I"√        end
        
        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end;Fi[	@'iI"Ù      search(var).size
    end
    
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      if var = @var[var.name] and var.any? then
        var = [var.requirement.as_list, var.first.version.to_s].flatten.compact;Fi[	@ZiI"‡        
        Node = Struct.new(:key, :value, :next, :prev)
        
        def function(arglist)
          @var = {}
        end
        
        def function(arglist)
          @var[var] and @var[var].value
        end;Fi[	@Mi∞I"    end
    
    # Removes previously aliased actions including the defaults.
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      var = ModelAdapters::AbstractAdapter.adapter_class(var)
      var.new(var, relevant_rules_for_query(var, var));Fi[	I"Bdata//paperclip_proj/paperclip/interpolations/plural_cache.rb;TiI"«module Paperclip
  module Interpolations
    class PluralCache
      def function(arglist)
        @var = {}
      end
      
      def function(arglist)
        @var[var] ||= var.pluralize
      end;Fi[@'I"def function(arglist);FI"# do nothing;FI"end;FI"def function(arglist);Fi
[
[	@˚i.I"«      end
      def function(arglist)
        super(var)
      end
      def function(arglist)
        # do nothing
      end
      def function(arglist)
        puts("No plugin responded")
      end;Fi[	@
i0I"Ï        end
        def function(arglist)
          (action == :save) ? (:create_or_update) : (super)
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          false
        end;Fi[	@
i9I"‘        end
        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          var.to_s.humanize.downcase
        end;Fi[	@i!I";      version("2.8.x - 2.11.x") do |arglist|
        def self.active?(arglist)
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == 2) and (::Sequel::MINOR <= 11)))
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing
        end;Fi[	@i$I"Á        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          (action == :save) ? (:save) : (super)
        end;Fi[@I"[];FI"end;FI" ;FI"def function(arglist);Fi
[
[	@>iI"{      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end;Fi[	@ıieI"<      # Override this method, as there are situations where the background
      # wind up being the one called fore Before scenarios, and
      # backgrounds don't have tags.
      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end;Fi[	@ÄiI"∞          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var)
        end;Fi[	@áiBI"a    ""
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end;Fi[	@ßiI"œ        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?
        var = var.backtrace.collect do |arglist|;Fi[@'@TI"G# Creates a scope for finding records *with* a particular state or;FI"# states for the attribute;FI"def function(arglist);Fi
[
[	@™iFI"¢      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] })
      end;Fi[	@irI"c      # Uses internal save hooks if using the :save action
      def function(arglist)
        (action == :save) ? (:save_self) : (super)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) }
      end;Fi[	@≠i?I"∑      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "$in" => (var) }) }) };Fi[	@∞iCI"§      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } })
      end;Fi[	@itI"¨      # Uses the DB literal to match the default against the specified state
      def function(arglist)
        (owner_class.db.literal(var.value) == owner_class_attribute_default)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) })
      end;Fi[@'I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi
[
[	@$iI"Õ            else
              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist)
          send("#{style}_fit")
          @var;Fi[	@n*i7I"          rescue SystemCallError => var
            log("There was an unexpected error while deleting directories: #{e.class}")
          end
        end
        @var = []
      end
      
      def function(arglist)
        FileUtils.cp(path(var), var)
      end;Fi[	@íiPI"        for var in @var do
          (log("deleting #{path}")
          directory.files.new(:key => (var)).destroy)
        end
        @var = []
      end
      
      def function(arglist)
        if @var[:fog_host] then
          "#{dynamic_fog_host_for_style(style)}/#{path(style)}";Fi[	@iÎI"Û          rescue AWS::Errors::Base => var
            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist)
        begin
          (log("copying #{path(style)} to local file #{local_dest_path}");Fi[	@ÀiI"¬            @var = File.open(var, "w")
          else
            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end;Fi[@'@T@;I"[];FI"end;Fi
[
[	@>i	I"ñ  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist);Fi[	@ÄiI"º      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist);Fi[	@ái@I"o  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist);Fi[	@áiDI"|  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end
  
  def self.excluding_blocks(arglist);Fi[	@ßiI"ú      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist);Fi[I""";FI"end;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@¯iI"F        if top_level.line_comments then
          "# To disable debugging comments that display the original location of your selectors. Uncomment:\n# line_comments = false\n"
        else
          ""
        end
      end
      
      def function(arglist)
        if top_level.output_style_without_default then
          "";Fi[	@bi9I"      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("") : ("[#{COLORS[c.to_sym]}m")
      else
        ""
      end
    end
    
    def function(arglist)
      print(var)
    end;Fi[	@OiI"´            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@Oi7I"Œ            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do
          @var.pop;Fi[	@Ãi7I"´        when stdout then
          ">> #{stdout}"
        else
          ""
        end
      end
      
      def function(arglist)
        ">> #{@output} 2>&1"
      end;Fi[I"# @since 2.4.0;FI"def function(arglist);FI"@var ||= {};FI"end;FI" ;Fi
[
[	@‰i4I"∆    #
    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the pulls that need to happen.
    #;Fi[	@‰i@I"À    #
    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the unique adds that need to happen.
    #;Fi[	@‰iLI"    #
    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the atomic updates that need to happen for the current
    # +Document+. This includes all changes that need to happen in the;Fi[	@6i4I"«    #
    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the changes for the document.
    #;Fi[	@6imI"    #
    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Remove a change from the dirty attributes hash. Used by the single field
    # atomic updators.;Fi[I"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;F@≠i
[
[	@•iºI"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@®i∑I"      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@´i´I"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@.iìI"      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@1iØI"      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[@ÆI"	else;FI"
false;TI"end;TI"end;Ti
[
[	@Ái*I"~      else
        if (var - var).any? then
          ActiveSupport::Deprecation.warn("It looks like you are eager loading table(s) (one of: #{string_tables.join(", ")}) that are referenced in a string SQL snippet. For example: \n\n    Post.includes(:comments).where(\"comments.title = 'foo'\")\n\nCurrently, Active Record recognises the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:\n\n    Post.includes(:comments).where(\"comments.title = 'foo'\").references(:comments)\n\n")
          true
        else
          false
        end
      end
    end
    ;Ti[	@]iéI"¡    def function(arglist)
      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist);Fi[	@°i>I"»        protect(var) do |arglist|
          if @var.key?(var) then
            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      ;Fi[	@(iMI"∑    end
    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  
  def self.build(arglist);Fi[	@.iÊI"´  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist);Fi[@'I"	@var;FI"end;FI"end;FI"end;Fi
[
[	@®iVI"⁄        @var = {}
        [:token, :user, :message, :title, :priority, :device].each do |arglist|
          @var.merge!(var => (self.instance_variable_get("@#{k}")))
        end
        @var
      end
    end
  end
end;Fi[	@¢	iI"~          else
            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end
end;Fi[	@J
i)I"◊        @var = MacOS::Xcode.version
        unless MacOS::Xcode.default_prefix? then
          @var = (@var + " => #{MacOS::Xcode.prefix}")
        end
        @var
      end
    end
  end
  
  def function(arglist);Fi[	@Æi&I"±      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!((self.class.read_inheritable_attribute(:rfpdf) or {})) do |arglist|
        var
      end
      @var
    end
  end
end;Fi[	@ΩiVI"p        var = (var + TimeEntryActivityCustomField.all)
        var.select { |arglist| ["list", "bool"].include?(var.field_format) }.each do |arglist|
          @var["cf_#{cf.id}"] = { :sql => ("#{cf.join_alias}.value"), :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[@¨I"&def self.required_fields(arglist);FI"[];FI"end;FI" ;Fi
[
[	@viI"P        before_validation(:downcase_keys)
        before_validation(:strip_whitespace)
      end
      
      def self.required_fields(arglist)
        []
      end
      
      # Check if the current object is valid for authentication. This method and
      # find_for_authentication are the methods used in a Warden::Strategy to check;Fi[	I"4data//devise_proj/devise/models/omniauthable.rb;Ti
I"Í  module Models
    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        Devise::Models.config(self, :omniauth_providers);Fi[	@~i	I"˝  module Models
    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        # A convenience method that receives both parameters and session to;Fi[	@–i
I"   module Models
    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      # Checks whether the user session has expired based on configured time.
      def function(arglist);Fi[	@]i	I"I  module Models
    module Validatable
      VALIDATIONS = [:validates_presence_of, :validates_uniqueness_of, :validates_format_of, :validates_confirmation_of, :validates_length_of].freeze
      
      def self.required_fields(arglist)
        []
      end
      
      def self.included(arglist)
        var.extend(ClassMethods);Fi[@$$@;#I"	true;FI"end;FI" ;Fi
[
[	@<ixI"·      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.;Fi[	@MiI"Ï      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly;Fi[	@Pi}I"      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the
      # hash which must correspond to method on a criteria object. The hash;Fi[	@Æ#iI"‘      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Is the object not to be converted to bson on criteria creation?
      #;Fi[	@Yi(I"‰      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.;Fi[@F@G@{%I"protected;FI" ;Fi
[
[	@jiI"†      end
      
      def function(arglist)
        super
      end
      
      protected
      
      def function(arglist)
        add_project_configuration;Fi[	@÷
iàI"æ        def function(arglist)
          @var = nil
          @var = nil
          super
        end
        
        protected
        
        def function(arglist)
          var = var.to_s;Fi[	@™iI"Ê      
      def self.extended(arglist)
        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist);Fi[	@∞iI"‡      
      def self.extended(arglist)
        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist);Fi[	@i4I"˘      # Pluralizes the name using the built-in inflector
      def function(arglist)
        load_inflector
        super
      end
      
      protected
      
      # Initializes class-level extensions for this machine
      def function(arglist);Fi[@'@≥#I"
super;FI"end;FI"end;Fi
[
[	@∂iI"‹            "longtext"
          else
            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      
      def function(arglist);Fi[	@ìiPI"®              end
            else
              super
            end
          else
            super
          end
        end
        
        def function(arglist);Fi[	@ùiMI"Y              "int8range"
            else
              raise(ActiveRecordError, "No range type has byte size #{limit}. Use a numeric with precision 0 instead.")
            end
          else
            super
          end
        end
        
        # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.;Fi[	@i5I"          Kernel.exec("#{groff} #{root}/#{command} | #{pager}")
        else
          puts(File.read("#{root}/#{command}.txt"))
        end
      else
        super
      end
    end
    
    desc("init", "Generates a Gemfile into the current working directory");Fi[	@ii I"Ù        end
        if skip_after and success? then
          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    
    # Tracks that before callbacks have now completed;Fi[@z@{@I"def function(arglist);FI"var = {};Fi
[
[	@∂ixI"∞        var = "CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end
      
      def function(arglist)
        var = {}
        if var = columns(var).find { |arglist| (var.name == var.to_s) } then
          var[:default] = var.default;Fi[	@riKI"      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {}
      if @var.kind_of?(Hash) then
        @var.each do |arglist|;Fi[	@	i√I"ı          while var.last.inherited_data do
            (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {}
          ATTRIBUTES.each do |arglist|
            var = [];Fi[	@√iÕI"•          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var)
      var.scan(/\s+/);Fi[	@EiI"      var = Formula.factory(var.basename.to_s) rescue nil
      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {}
    var.each do |arglist|
      var = var.recursive_deps.uniq.reject do |arglist|;Fi[@z@{@@d,I"
begin;Fi
[
[	@i&I"¸    
    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) }
      var
    end
    
    def function(arglist)
      begin
        (var = send(var, var)
        var.duplicable? ? (var.clone) : (var));Fi[	@-iÄI"˛        end
        var = {}
        var.each { |arglist| var[var.uri] = var.map { |arglist| var.to_a } }
        var
      end
      
      def function(arglist)
        begin
          Gem::Package.new(var).spec
        rescue Gem::Package::FormatError;Fi[	@0i£I"U        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm_rf(var) if File.exists?(var) }
      end
      var
    end
    
    def function(arglist)
      begin
        ENV["BUNDLE_BIN_PATH"] = Bundler.rubygems.bin_path("bundler", "bundle", VERSION)
      rescue Gem::GemNotFoundException;Fi[	I"0data//diaspora_proj/models/o_embed_cache.rb;TiI"*    var = OEmbedCache.find_or_initialize_by_url(var)
    return var if var.persisted?
    var.fetch_and_save_oembed_data!
    var
  end
  
  def function(arglist)
    begin
      var = OEmbed::Providers.get(self.url, :maxwidth => 420, :maxheight => 420, :frame => 1, :iframe => 1)
    rescue => var;Fi[	@Xi>I"µ          var["nekohtml"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin
        require("psych")
      rescue LoadError;Fi[@I"teardown_db;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@
)i4I"2    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@
)iæI"Ì    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@)iAI"ƒ    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var])
    assert_equal(@var.children, [@var]);Fi[	@)iôI"<    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "mixins.parent_id IS NULL", :order => "mixins.id")
    assert_equal([@var, @var, @var], var);Fi[	@)iøI"æ    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root))
  end;Fi[@°I"# @since 2.4.0;F@Á+I"@var ||= {};FI"end;Fi
[
[	@‰i3I"„    #   person.atomic_array_pushes
    #
    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the pulls that need to happen.;Fi[	@‰i?I"Á    #   person.atomic_array_pulls
    #
    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the unique adds that need to happen.;Fi[	@‰iKI"Ú    #   person.atomic_array_add_to_sets
    #
    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the atomic updates that need to happen for the current;Fi[	@6i3I"‚    #   model.changed_attributes
    #
    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the changes for the document.;Fi[	@6ilI"    #   model.previous_changes
    #
    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Remove a change from the dirty attributes hash. Used by the single field;Fi[@'@(@)@	I"module HelperMethods;Fi
[
[	@,!iI"H      def function(arglist)
        if include?(var, var) then
          var.errors.add(var, :exclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates that the value of the specified attribute is not in a
      # particular enumerable object.;Fi[	@li3I"=          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var[:multiline].!=(true))) then
            raise(ArgumentError, "The provided regular expression is using multiline anchors (^ or $), which may present a security risk. Did you mean to use \\A and \\z, or forgot to add the :multiline => true option?")
          end
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is of the correct
      # form, going by the regular expression provided.You can require that the;Fi[	@1!iI"U      def function(arglist)
        unless include?(var, var) then
          var.errors.add(var, :inclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is available in a
      # particular enumerable object.;Fi[	I"Sdata//paperclip_proj/paperclip/validators/attachment_content_type_validator.rb;Ti2I"Ç      def function(arglist)
        unless (options.has_key?(:content_type) or options.has_key?(:not)) then
          raise(ArgumentError, "You must pass in either :content_type or :not to the validator")
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the content type of the file
      # assigned. The possible options are:;Fi[	@ﬂiI"0          if var.send(:read_attribute_for_validation, "#{attribute}_file_name").blank? then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the presence of a file.
      # Options:;Fi[I"raise(var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@5	i%I"          @var.error(var) if @var
          var = translate_exception(var, var)
          var.set_backtrace(var.backtrace)
          raise(var)
        end
      end
      
      def function(arglist)
        ActiveRecord::StatementInvalid.new(var)
      end;Fi[	@6iŸI"˚          require("diff/lcs")
        rescue LoadError => var
          (var.message << "\n Please gem install diff-lcs\n")
          raise(var)
        end
      end
      
      def function(arglist)
        @var = @var = @var = @var = nil
      end;Fi[	@ñi1I"        var)
      rescue Gherkin::Lexer::LexingError, Gherkin::Parser::ParseError => var
        var.message.insert(0, "#{@path}: ")
        raise(var)
      end
    end
    
    def function(arglist)
      @var ||= if @var =~ /^http/ then
        require("open-uri");Fi[	@∑i3I"Ó        begin
          var = RubyPython.import(var)
        rescue RubyPython::PythonError => var
          raise(var)
        end
      end
      
      def function(arglist)
        var = File.expand_path(var)
        @var.unshift(var);Fi[	@œirI"        begin
          return @var = var.__send__(present_tense_predicate, *@var, &@var)
        rescue NameError
          raise(var)
        end
      end
      
      def function(arglist)
        "expected #{predicate}#{args_to_s} to return true, got #{@result.inspect}"
      end;Fi[@'@(I"var = -1;FI"var = 0;FI"var = 0;Fi
[
[	@•ilI"Ù        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@®iaI"Ù        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@´i[I"Ù        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@.iAI"Ï        var = "L" unless var.index("L").nil?
        var = (var + "R") unless var.index("R").nil?
        var = var.index("T").nil?.! ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0;Fi[	@1i:I"¿          (var << "R") if var.include?("R")
          var = var.include?("T") ? ((var + "T")) : (var)
        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0;Fi[I"super(var);F@:+I"end;FI" ;FI"private;Fi
[
[	@ﬂiI"µ      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@îimI"ﬁ      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@•iI"‡      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@®iI"ª      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@´iI"¨      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[@'@(I"module Homebrew;FI"extend(self);FI" ;Fi
[
[	I"$data//homebrew_proj/cmd/deps.rb;Ti
I"‡  var.deps.each do |arglist|
    puts((("> " * var) + var.to_s))
    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--all") then;Fi[	I"#data//homebrew_proj/cmd/irb.rb;TiI"¶class String
  def function(arglist)
    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--help") then;Fi[	@_
iI"≤      raise(FormulaUnspecifiedError) if ARGV.named.empty?
      ARGV.formulae
    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    ff.each do |arglist|;Fi[	I"'data//homebrew_proj/cmd/upgrade.rb;Ti	I"“class Fixnum
  def function(arglist)
    (self > 1) ? ("s") : ("")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then;Fi[	@¡iìI";  
  def function(arglist)
    (super + advice.to_s)
  end
end
module Homebrew
  extend(self)
  
  SUDO_BAD_ERRMSG = "    You can use brew with sudo, but only if the brew executable is owned by root.\n    However, this is both not recommended and completely unsupported so do so at\n    your own risk.\n".undent
end;Fi[I"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;FI"&# @return [Array<Twitter::Tweet>];FI";# @param options [Hash] A customizable set of options.;Fi
[
[	I"0data//twitter_proj/twitter/api/timelines.rb;TiI"Ø      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ˆ,iZI"≠      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ˆ,ioI"ø      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ˆ,iÅI"ø      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@ˆ,iñI"Õ      # Returns the 20 most recent tweets of the authenticated user that have been retweeted by others
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets_of_me
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[@¨I"J# Defines an initialization hook into the owner class for setting the;FI"J# initial state of the machine *before* any attributes are set on the;FI"# object;FI"def function(arglist);Fi
[
[	@™i'I"F          var.default
        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_static_state_initializer
        define_dynamic_state_initializer;Fi[	@iSI"˚      def function(arglist)
        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (426 + 1))
      end;Fi[	@≠i%I"      def function(arglist)
        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (325 + 1))
      end;Fi[	@∞i)I"ﬂ      def function(arglist)
        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              @attributes ||= {}\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false)\n              \n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (386 + 1))
      end;Fi[	@iII"ˆ      def function(arglist)
        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize_set(*)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (344 + 1))
      end;Fi[@°I"# == Examples;FI"#;FI"#   class Vehicle;F@ç%i
[
[	@˛iI"i    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@˛i;I"i    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@-iI"E    # object's current value doesn't match the state, then this will return
    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@-i&I"[    # Determines the current state of the given object as configured by this
    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@-iAI"8    # Determines the current state of the given object as configured by this
    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[@^I"if var then;F@9!I"var = "LTRB";FI"var = "LRT";Fi
[
[	@•iaI"Î    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@®iVI"Î    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@´iPI"Î    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@1i-I"     var = (var - (3 * @var))
    var = var.gsub("\r", "")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@1i¯I"≈    SetX(var)
    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[@'@T@U@V@-&i
[
[	@g	iNI"3        var.concat(["--execute", "SET FOREIGN_KEY_CHECKS = 0; SOURCE #{filename}; SET FOREIGN_KEY_CHECKS = 1"])
        var.concat(["--database", "#{configuration["database"]}"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist);Fi[	@l	iDI"ﬂ      def function(arglist)
        set_psql_env
        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist);Fi[	@"i)I"Ã      def function(arglist)
        var = configuration["database"]
        `sqlite3 #{var} < "#{var}"`
      end
      
      private
      
      attr_reader :function
      
      attr_reader :function;Fi[	@∑	iRI"Æ    
    def function(arglist)
      to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist);Fi[	@9&iÂI"Y    def function(arglist)
      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "#<#{self.class} #{(attributes.map { |attr, value| "#{attr}=#{value.inspect}" } * " ")}>"
    end
    
    private
    
    attr_reader :function
    
    # Adds a predicate method to the owner class so long as a name has;Fi[@'@T@-@-I"# object;Fi
[
[	@™i&I"ó        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default
        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_static_state_initializer;Fi[	@iRI"*      # Pluralizes the name using the built-in inflector
      def function(arglist)
        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (426 + 1));Fi[	@≠i$I"/      # Gets the Mongoid key for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (325 + 1));Fi[	@∞i(I"      # Gets the field for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              @attributes ||= {}\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false)\n              \n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (386 + 1));Fi[	@iHI"      # Loads the built-in inflector
      def function(arglist)
        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize_set(*)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (344 + 1));Fi[I"module ClassMethods;FI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;FI"$# @example Mongoize the object.;Fi
[
[	@BiI"module Mongoid
  module Extensions
    module Boolean
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Boolean.mongoize("123.11")
        #;Fi[	@Mi I"ˆ        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11")
        #;Fi[	@PißI"        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ])
        #;Fi[	@Æ#i,I"˚        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #;Fi[	@\iI"module Mongoid
  module Extensions
    module Regexp
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Regexp.mongoize(/^[abc]/)
        #;Fi[@°@¢I"#   end;FI"#;FI"#   person = Person.new;Fi
[
[	@iáI"|    # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
    # which will all return +true+. It also define the attribute methods if they have
    # not been generated.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.respond_to(:name)    # => true
    #   person.respond_to(:name=)   # => true;Fi[	@iõI"(    end
    
    # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.has_attribute?(:name)    # => true
    #   person.has_attribute?('age')    # => true;Fi[	@i®I"    end
    
    # Returns an array of names for the attributes available on this object.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.attribute_names
    #   # => ["id", "created_at", "updated_at", "name", "age"];Fi[	@iÒI"¥    
    # Returns the column object for the named attribute. Returns +nil+ if the
    # named attribute not exists.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter
    #   # => #<ActiveRecord::ConnectionAdapters::SQLite3Column:0x007ff4ab083980 @name="name", @sql_type="varchar(255)", @null=true, ...>;Fi[	@iI"5    
    # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
    # (Alias for the protected <tt>write_attribute</tt> method).
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person[:age] = '22'
    #   person[:age] # => 22;Fi[@'@(I"
super;FI"end;FI" ;Fi
[
[	@ái!I"Á          var.flatten.each do |arglist|
            raise_on_type_mismatch(var)
            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested;Fi[	@L	iI"'        if (var = var.first).is_a?(Hash) then
          if var = subclass_from_attrs(var) then
            return var.new(*var, &var)
          end
        end
        super
      end
      
      # True if this isn't a concrete subclass needing a STI type condition.
      def function(arglist);Fi[	@ıiI"          if respond_to?(var) and (respond_to?("#{column}=") and self.send(var).nil?) then
            write_attribute(var.to_s, var)
          end
        end
      end
      super
    end
    
    def function(arglist)
      if should_record_timestamps? then;Fi[	@ıi(I"7          var = var.to_s
          next if attribute_changed?(var)
          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist)
      self.record_timestamps and (partial_writes?.! or (changed? or attributes.keys.&(self.class.serialized_attributes.keys).present?));Fi[	@ä%iÕI"             if var and var[:autosave].!=(false) then
              autosave(var.merge!(:autosave => (true)))
            end
          end
        end
        super
      end
      
      private
      ;Fi[I";# @param options [Hash] A customizable set of options.;FI"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;FI"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;FI"¥# @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi
[
[	@ˆ,iI"ø      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user
      #   Twitter.mentions;Fi[	@ˆ,iGI"r      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@ˆ,i^I"@      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@ˆ,isI"Ø      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.;Fi[	@ˆ,iÖI"@      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[I"!var = ((@var - @var) - @var);FI"/var = (((var - (2 * @var)) * 1000) / @var);FI"end;FI"var = (var + 1);FI"	else;Fi	[	[	@•i‡I"˝        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@®iËI"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@´iœI"˝        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@.i∫I"Ì        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1)
      end;Fi[@^I"var = 1;F@bI"var = var[var];FI"if (var == "\n"[0]) then;Fi	[	[	@.iGI"∂    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@.içI"Ê    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1);Fi[	@1i@I"∂    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@1i©I"„    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[@°I"#     private;FI"#;FI"%#     def attribute_short?(attr);FI""#       send(attr).length < 5;Fi	[	[	@iNI"      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@iäI"Ï      #     define_attribute_methods :name
      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@iŒI"'      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@iÒI"      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[@°@¶-@ß-I"#     end;FI"#   end;Fi	[	[	@iPI"›      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@iåI"ﬂ      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@i–I"‹      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@iÛI"‹      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[@H-I"end;FI"end;FI"end;FI"end;Fi	[	[	@i\I"°          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@iÑI"s          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@i?I"{          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@"iSI"Ñ          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[I"/var = (((var - (2 * @var)) * 1000) / @var);FI"end;FI"var = (var + 1);FI"	next;FI"end;Fi	[	[	@•i√I"/        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@®iæI"        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@´i≤I"/        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@.iöI"˜        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == " "[0]) then
        var = var;Fi[I"var = var.gsub("\r", "");FI"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;Fi	[	[	@•i∞I"”    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@®i´I"”    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@´iüI"”    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@.iàI"”    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[I"@var.each do |arglist|;FI"newobj;FI"]out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));FI"out("endobj");FI"end;Fi	[	[	@•iÒI"˘  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@®i˙I"˘  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@´i‡I"˘  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@1i&I"ˆ  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each do |arglist|
      newobj;Fi[@°@äI"var = case var;FI"when :success then;FI""Success";Fi	[	[	@ﬂi.I"w      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[	@•i,I"w      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[	@®i6I"w      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :failure then
          "Failure";Fi[	@´i*I"w      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[@'@TI"E# Unbinds the base object and the inverse, caused by setting the;FI"# reference to nil.;FI"#;Fi	[	[	@ˆi$I"X                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true);Fi[	@iI"e            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true);Fi[	@i%I"!                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true);Fi[	@$iI"o          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.game.unbind(:continue => true);Fi[@9!@:!I"	else;FI"if (var == 0) then;FI"@var = var;Fi	[	[	@•iòI"    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@®iìI"    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@´iáI"    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@1i{I"    end
    (var << "B") if var.is_a?(String) and var.include?("B")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var);Fi[@°I"#   person.pets;TI"#   # => [;T@·@‚i	[	[	@Ái(I"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiaI"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiI"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiòI"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[I"var = "LTRB";FI"var = "LRT";FI"var = "LR";FI"	else;FI"var = "";Fi	[	[	@•idI"¯    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@®iYI"¯    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@´iSI"¯    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@.i9I"Ù    var = 0
    if var.!=(0) then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.index("L").nil?
        var = (var + "R") unless var.index("R").nil?;Fi[@^@ó-@b@e&I"var = (var < 128);Fi	[	[	@•iqI"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@•iµI"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@´i`I"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@´i§I"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[@Ã-@€-I"var = var.length;FI"var = -1;FI"var = 0;Fi	[	[	@•iØI"ﬂ  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@®i™I"ﬂ  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@´iûI"ﬂ  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@.iáI"ﬂ  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[@^@_@d&@bI"var = var[var];Fi	[	[	@.iFI"∞    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then;Fi[	@.iåI"„    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var);Fi[	@1i?I"∞    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then;Fi[	@1i®I"”    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[@T@UI"var = 0;FI"var = (var + 1);FI"$var = var if var and (var == 2);Fi	[	[	@.iTI"        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == " "[0]) then;Fi[	@.iqI"ﬂ            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1);Fi[	@1iNI"Î        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@1ilI"À          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1);Fi[I"0;FI"end;FI" ;F@åI"0;Fi	[	[	@>iI"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@>iI"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@>iI"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@>i4I"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[@Õ,I"end;FI"end;FI"end;FI"end;Fi	[	[	I"=data//mongoid_proj/lib/mongoid/extensions/false_class.rb;Ti I"Ë      # @since 1.0.0
      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::FalseClass.__send__(:include, Mongoid::Extensions::FalseClass);Fi[	I"<data//mongoid_proj/lib/mongoid/extensions/true_class.rb;Ti I"Ê      # @since 1.0.0
      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::TrueClass.__send__(:include, Mongoid::Extensions::TrueClass);Fi[	I"0data//twitter_proj/twitter/api/arguments.rb;TiI"ä      
      def function(arglist)
        @var = var.last.is_a?(::Hash) ? (var.pop) : ({})
        super(var)
      end
    end
  end
end;Fi[	I"7data//twitter_proj/twitter/response/raise_error.rb;TiI"i      
      def function(arglist)
        @var = var
        super(var)
      end
    end
  end
end;Fi[@¨I")undef_method(:namespace_definitions);FI" ;FI"2undef_method(:line) if method_defined?(:line);FI" ;Fi	[	[	I"7data//nokogiri_proj/nokogiri/xml/attribute_decl.rb;TiI"       undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";Fi[	I",data//nokogiri_proj/nokogiri/xml/dtd.rb;TiI"Í      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys;Fi[	I"5data//nokogiri_proj/nokogiri/xml/element_decl.rb;Ti	I"5  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";Fi[	I"4data//nokogiri_proj/nokogiri/xml/entity_decl.rb;TiI"˙      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist)
        var.create_entity(var, *var);Fi[I"rescue;FI"# do nothing;FI"end;FI"end;FI" ;Fi	[	[	@∂iI"±      def function(arglist)
        begin
          execute("BEGIN")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin;Fi[	@∂iI"        begin
          (execute("SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}")
          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@∂iI"≥      def function(arglist)
        begin
          execute("COMMIT")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@∂iI"›      def function(arglist)
        begin
          execute("ROLLBACK")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}");Fi[@'@TI"# For testing only;FI"#:nodoc:;FI"def function(arglist);Fi	[	[	I"3data//cucumber_prok/cucumber/ast/doc_string.rb;Ti)I"¬      
      def function(arglist)
        index(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:doc_string, to_step_definition_arg]
      end;Fi[	@6iÆI"¯      def function(arglist)
        var = "table:#{headers.join(",")}"
        var.match(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:table, *cells_rows.map { |arglist| var.to_sexp }]
      end;Fi[	@6i1I"          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) }
          nil
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:row, line, *@var.map { |arglist| var.to_sexp }]
        end;Fi[	@6isI"‚        
        def function(arglist)
          (SurplusCell.===(var) or (value == var.value))
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:cell, @var]
        end;Fi[I"class Base;FI""include(Backup::CLI::Helpers);FI" ;FI",include(Backup::Configuration::Helpers);FI" ;Fi	[	[	@ÅiI"‰module Backup
  module Compressor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##
      # Yields to the block the compressor command and filename extension.;Fi[	@áiI"’module Backup
  module Database
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##
      # Creates a new instance of the MongoDB database object;Fi[	@ìiI"¬module Backup
  module Encryptor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      def function(arglist)
        load_defaults!;Fi[	@iI"Æmodule Backup
  module Syncer
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      attr_accessor(:path)
      ;Fi[@¨I"J# Initialize the new cascade strategy, which will set up the relation;FI"# and the metadata.;FI"#;FI"(# @example Instantiate the strategy;Fi	[	[	@_i
I">    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@fi
I"?    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@mi
I"?    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@pi
I"@    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[@Q&@R&@S&I" ;FI"def function(arglist);Fi	[	[	@¶i+I"‘          var)
        rescue Exception
          send((var + "="), var)
          raise
        end
      end
      
      def function(arglist)
        var = super
        if locking_enabled? and var.!=(1) then;Fi[	@o
i<I"Y      end)
    rescue FormulaUnavailableError => var
      var.dependent = f.name
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? then
      raise(CannotInstallFormulaError, "        #{f}-#{f.linked_keg.realpath.basename} already installed\n        To install this version, first `brew unlink #{f}'\n".undent);Fi[	@o
i»I"        f.prefix.rmtree if f.prefix.directory?
        f.rack.rmdir_if_possible
      end
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? and (f.linked_keg.realpath == f.prefix) then
      opoo("This keg was marked linked already, continuing anyway");Fi[	@√i•I"–    rescue Exception
      opoo("Could not link #{fname}. Unlinking...")
      unlink
      raise
    end
  end
  
  def function(arglist)
    var = ((HOMEBREW_PREFIX / :opt) / fname)
    if var.symlink? then;Fi[@¨@.@.I"#;FI"$# @example Unbind the document.;Fi	[	[	@ˆi%I"-              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true)
          #   name.person = nil;Fi[	@i I"d              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true)
          #   person.name = nil;Fi[	@i&I"-              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true)
          #   game.person = nil;Fi[	@$iI"q          def function(arglist)
            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.game.unbind(:continue => true)
          #   person.game = nil;Fi[I"var = @var["cw"];F@à-@â-I"var = var.gsub("\r", "");FI"var = var.length;Fi	[	[	@•i≠I"–  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@®i®I"–  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@´iúI"–  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@.iÖI"–  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[I"var = 1;F@b@e&I"var = (var < 128);FI"if (var.chr == "\n") then;Fi	[	[	@•irI"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@•i∂I"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[	@´iaI"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@´i•I"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[I"yield(var);FI"end;FI"end;FI" ;FI"##;Fi	[	[	@Îi4I"4        Net::FTP.send(:const_set, :FTP_PORT, port)
        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@¡i4I"G      # Establishes a connection to the remote server
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@˘i(I"O      # Net::SCP will use this connection to transfer backups
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@¸i&I"H      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[@¨I"acts_as_api;FI" ;FI"+api_accessible(:backbone) do |arglist|;FI"var.add(:id);Fi	[	[	I"'data//diaspora_proj/models/like.rb;TiI"Õ  after_destroy { |arglist| self.parent.update_likes_counter }
  
  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author);Fi[	I"0data//diaspora_proj/models/participation.rb;TiI"ü      { :target => (@var) }
    end
  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author);Fi[	@iI"≠  include(Encryptor::Public)
  
  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:name);Fi[	@ÊiI"º  include(Diaspora::Commentable)
  
  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:created_at);Fi[@'@TI"J# Determines what the response should be for a particular bit of text;FI"H# from the SCM. Password prompts, connection requests, passphrases,;FI"# etc. are handled here.;Fi	[	[	@µiGI"u            var[/^date: (.*?);/, 1]
          end.sort.last + " UTC")
          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          logger.info("[#{stream}] #{text}");Fi[	@Ωi{I"]        
        def function(arglist)
          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host];Fi[	@∆i<I"v        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          case var;Fi[	@ÀiCI"à        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host];Fi[@˜+I"end;FI"var = -1;FI"var = var;FI"var = 0;Fi	[	[	@.inI"              out(sprintf("%.3f Tw", (@var * @var)))
            end
            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1);Fi[	@.i≥I"$          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        else
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@1iiI"˝            out(sprintf("%.3f Tw", (@var * @var)))
          end
          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1);Fi[	@1iÃI"          Cell(var, var, var[var, (var - 1)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[@¨@(/@)/@*/I"def function(arglist);Fi	[	[	@µiHI"d          end.sort.last + " UTC")
          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          logger.info("[#{stream}] #{text}")
          case var;Fi[	@Ωi|I"å        def function(arglist)
          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}");Fi[	@∆i=I"n        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          case var
          when /\(P4PASSWD\) invalid or unset\./i then;Fi[	@ÀiDI"Å        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}");Fi[I"# Returns true;FI"def function(arglist);FI"	true;FI"end;FI" ;Fi	[	[	@£iuI"€        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.
      def function(arglist);Fi[	@£iéI"ü        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var.!=(false);Fi[	@£i§I"£        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@£i©I"ï        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true;Fi[@°I"# @return [ true ] true.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@<iuI"ƒ      #
      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@<iüI"◊        #
        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end;Fi[	@PiI"æ      #
      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@PiºI"“        #
        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end;Fi[@™@´@¨I"var = 0;FI"var = (var + 1);Fi	[	[	@.iSI"        var = (var == 0) ? (0) : ((var - 1))
        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@.ipI"            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else;Fi[	@1iMI"        var = (var == 0) ? (1) : (var)
        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@1ikI"Ô          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[@°I"$# @return [ true ] Always true.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@(iI"      #   context.eager_load(docs)
      #
      # @param [ Array<Document> ] docs The docs returning from the db.
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        load_inclusions(var)
        self.eager_loaded = true;Fi[	@MiI"…      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@Æ#iI"…      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@ÎiI",        #
        # @example Execute the upsert.
        #   operation.persist
        #
        # @return [ true ] Always true.
        #
        # @since 3.0.0
        def function(arglist)
          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert]);Fi[@¨I"attr_accessor(:ip, :port);FI" ;FI"attr_accessor(:path);FI" ;Fi	[	[	@Îi
I"…  module Storage
    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:passive_mode)
      ;Fi[	@¡iI"«      include(Backup::CLI::Helpers)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:local)
      ;Fi[	@˘iI"√  module Storage
    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[	@¸iI"ƒ  module Storage
    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[@+I"!@var = path.sub(/^\~\//, "");FI"end;FI" ;FI"private;Fi	[	[	@Îi I"≈        @var ||= 21
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[	@¡i"I"≈        @var ||= 22
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[	@˘iI"∆        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[	@¸iI"∆        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[@°I"C# @return [ nil, false ] False if no attributes were provided.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@iÂI"/      #   context.update(name: "Smiths")
      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, [first])
      end;Fi[	@iÛI"4      #   context.update_all(name: "Smiths")
      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, entries)
      end;Fi[	@iGI"7      #   context.update({ "$set" => { name: "Smiths" }})
      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var)
      end;Fi[	@iUI"E      #   context.update({ "$set" => { name: "Smiths" }})
      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, :update_all)
      end;Fi[I"var = @var;FI"if (var > 0) then;FI"@var = 0;FI"out("0 Tw");FI"end;Fi	[	[	@.iÔI"Œ  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("0 Tw")
      end
      self.AddPage(@var)
      @var = var;Fi[	@1iÕI"    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var;Fi[	@1iI"D      var = 1 if (var >= 1)
      if ((var + ((var["h"] * var) / (@var * @var))) > @var) and (@var.! and AcceptPageBreak) then
        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("0 Tw")
          end
          AddPage(@var)
          if (var > 0) then;Fi[	@1iLI"¸    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var;Fi[@Ø/I"@var.each do |arglist|;FI"newobj;F@Ï-I"out("endobj");Fi	[	[	@•iI"ˆ  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@®i˘I"ˆ  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@´iﬂI"ˆ  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@1i%I"   	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each do |arglist|;Fi[@°I")# @return [ Criteria ] The criteria.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@D#iåI"s    # @option options [ String, Symbol ] :collection The collection name.
    # @option options [ String, Symbol ] :database The database name.
    # @option options [ String, Symbol ] :session The session name.
    #
    # @return [ Criteria ] The criteria.
    #
    # @since 3.0.0
    def function(arglist)
      Threaded.set_persistence_options(klass, var)
      self;Fi[	@1iI"D      #
      # @example Apply the default scope.
      #   criteria.apply_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        klass.without_default_scope { |arglist| merge!(klass.default_scoping.call) }
        self.scoping_options = true, false;Fi[	@1iI"/      #
      # @example Get the criteria with the default scope.
      #   criteria.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then;Fi[	@üiúI"˝      #
      # @example Get a criteria with the default scope.
      #   Model.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        queryable.with_default_scope
      end;Fi[@Ø/I"var = @var;FI"var = @var;FI"var = @var;FI"var = @var;Fi	[	[	@.i⁄I"≈    self.Open if (@var == 0)
    var = @var
    var = (@var + (@var ? ("U") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then;Fi[	@.i€I"∫    var = @var
    var = (@var + (@var ? ("U") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then
      @var = true;Fi[	@1i«I"⁄    Open if (@var == 0)
    var = @var
    var = ((@var + (@var ? ("U") : (""))) + (@var ? ("D") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then;Fi[	@1i»I"‘    var = @var
    var = ((@var + (@var ? ("U") : (""))) + (@var ? ("D") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then
      @var = true;Fi[@°I"1# @return [ Array<Object> ] The dumped data.;FI"#;FI"# @since 3.0.15;FI"def function(arglist);Fi	[	[	@`iI"a      #
      # @example Dump the criteria.
      #   Marshal.dump(criteria)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        var = [klass, driver, inclusions, documents, strategy, negating]
        var.push(scoping_options).push(dump_hash(:selector)).push(dump_hash(:options));Fi[	I"<data//mongoid_proj/lib/mongoid/relations/marshalable.rb;TiI"Ê      #
      # @example Dump the proxy.
      #   Marshal.dump(proxy)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        [base, target, metadata]
      end;Fi[	@ôi/I"˛        #
        # @example Dump the proxy.
        #   Marshal.dump(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          [_added, _loaded, _unloaded]
        end;Fi[	@ôi;I"¯        #
        # @example Load the proxy.
        #   Marshal.load(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          @var, @var, @var = var
        end;Fi[@¨I"# Returns true;F@O/I"	true;FI"end;Fi	[	[	@£itI"€      def function(arglist)
        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.;Fi[	@£içI"§      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@£i£I"£      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@£i®I"§      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[I"puts(var);FI"@var = true;FI"end;FI"end;FI" ;Fi	[	[	@o
i7I"'      puts("install to \"libexec\" and then symlink or wrap binaries into \"bin\".")
      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?;Fi[	@o
iGI"      opoo("Non-libraries were installed to \"lib\".")
      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?;Fi[	@o
iSI"      opoo("Non-executables were installed to \"bin\".")
      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?;Fi[	@o
i_I"       opoo("Non-executables were installed to \"sbin\".")
      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars;Fi[@°I"%# @return [ Object ] The object.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@?iI"∆      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        to_s
      end;Fi[	@?i(I"/        #   Object.demongoize(object)
        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var.numeric? ? (::BigDecimal.new(var.to_s)) : (var) if var
        end;Fi[	@SiÄI"∆      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@SiÛI"¯        #   Object.demongoize(object)
        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var
        end;Fi[@°I"/# @return [ String ] The object mongoized.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@BiI"ˆ        #
        # @example Mongoize the object.
        #   Boolean.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          evolve(var)
        end;Fi[	@Mi(I"3        #   Float.mongoize("123.11")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0)
        end;Fi[	@Æ#i2I"#        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_i rescue 0)
        end;Fi[	@bi∫I"        #   String.mongoize("123.11")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end;Fi[@'@T@°!I"A# Transfers the archived file to the specified remote server;FI"def function(arglist);Fi	[	[	@Îi6I"
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	@¡i6I"0        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin
          (write_password_file! unless local;Fi[	@˘i*I"9        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	@¸i(I":        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[I"(self.class.to_s.sub("Backup::", "");FI"end;FI" ;FI"##;FI";# Logs a message to the console and log file to inform;Fi	[	[	@ÅiI"<      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor
      def function(arglist);Fi[	@ái(I":      ##
      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database
      def function(arglist);Fi[	@ìiI"=      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive
      def function(arglist);Fi[	@aiGI"A      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process
      def function(arglist);Fi[@°I"# @return [ Object ] self.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@SiI"       #
      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@SiI"Ã      #
      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@Si&I"…      #
      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@Si>I"–      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[@0@1@2I"end;FI"end;Fi	[	[	@®iMI"m      
      def function(arglist)
        yield if @var
        @var = true
      end
    end
  end
end;Fi[	@o
iI"˜        unless ORIGINAL_PATHS.include?(var) then
          opoo("#{bin} is not in your PATH")
          puts("You can amend this by altering your ~/.bashrc file")
          @var = true
        end
      end
    end
  end
  
  def function(arglist);Fi[	@liI"V            content_for(:header_tags) do |arglist|
              ((javascript_include_tag("jstoolbar/jstoolbar-textile.min") + javascript_include_tag("jstoolbar/lang/jstoolbar-#{current_language.to_s.downcase}")) + stylesheet_link_tag("jstoolbar"))
            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	@i¢I"ó          failure_hooks.each { |arglist| payload_class.send(var, var, *var) }
        end)
      ensure
        @var = true
      end
    end
  end
end;Fi[@'@TI"# Returns true;F@O/I"	true;Fi	[	[	@£isI"õ      #:nodoc:
      def function(arglist)
        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@£iåI"è      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@£i¢I"º      # Clears the prepared statements cache.
      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@£ißI"ù      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;FI"@var = @var;FI"	else;F@.i	[	[	@•ióI"      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@®iíI"      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@´iÜI"      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@1izI"      out("0 Tw")
    end
    (var << "B") if var.is_a?(String) and var.include?("B")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = var;Fi[@¨@@I"%# @param request_method [Symbol];FI"# @param path [String];Fi	[	[	@i˛I"!      def function(arglist)
        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[	I"5data//twitter_proj/twitter/api/places_and_geo.rb;TiqI"
      def function(arglist)
        object_from_response(Twitter::Place, :post, "/1.1/geo/place.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash]
      # @return [Array];Fi[	@-i¸I""          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>];Fi[	@iI"⁄  module API
    module Utils
      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[@'@TI"# @param klass [Class];FI"%# @param request_method [Symbol];FI"# @param path [String];Fi	[	[	@i$I"2          merge_user!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::User, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@i/I":        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        objects_from_response(var, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Array];Fi[	@i@I"      # @return [Array]
      def function(arglist)
        var.map { |arglist| var.fetch_or_new(var) }
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@iLI"1        var.flatten.threaded_map do |arglist|
          object_from_response(var, var, var, var.options.merge(:id => (var)))
        end
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Object];Fi[@°I"<# @return [ Array<Object> ] The new value of the field.;FI"#;FI"# @since 2.0.0;FI"def function(arglist);Fi	[	[	I"9data//mongoid_proj/lib/mongoid/persistence/atomic.rb;Ti"I"{      # @param [ Symbol ] field The name of the field.
      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        AddToSet.new(self, var, var, var).persist
      end;Fi[	@ù0iKI"d      # @param [ Symbol ] field The name of the field.
      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Inc.new(self, var, var, var).persist
      end;Fi[	@ù0iI"j      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        PullAll.new(self, var, var, var).persist
      end;Fi[	@ù0iêI"_      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Push.new(self, var, var, var).persist
      end;Fi[@°@ó0@ò0I"# @since 2.1.0;FI"def function(arglist);Fi	[	[	@ù0i_I"n      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pop.new(self, var, var, var).persist
      end;Fi[	@ù0irI"_      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pull.new(self, var, var, var).persist
      end;Fi[	@ù0i°I"j      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        PushAll.new(self, var, var, var).persist
      end;Fi[	@ù0i√I"_      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Sets.new(self, var, var, var).persist
      end;Fi[@¨@@@WI"var = @var;Fi	[	[	@•iÏI"¿      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@®iıI"¿      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@´i€I"¿      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@.iI"‰      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "")) then
      1.upto(var) { |arglist| @var[var].gsub!(@var, var.to_s) };Fi[@¨@@@WI"case var;Fi	[	[	@qiDI"Ï      def function(arglist)
        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var
        when Hash then
          preload_hash(var);Fi[	@i)I"€      def function(arglist)
        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var
        when BigDecimal then
          var.to_s;Fi[	@i˚I"æ          false
        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@GiI"©        end
        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var
        when /\.jpe?g/i then
          "image/jpeg";Fi[@‡I";#   #       #<Pet id: 4, name: "Benny", person_id: 1>,;TI";#   #       #<Pet id: 5, name: "Brain", person_id: 1>,;TI":#   #       #<Pet id: 6, name: "Boss",  person_id: 1>;TI"#   #    ];Ti	[	[	@ÁiEI"B      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4");Ti[	@Ái`I"5      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary;Ti[	@ÁigI"Z      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')]);Ti[	@ÁitI"U      #
      #   person.pets
      #   # This is not affected by replace
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      def function(arglist)
        load_target.dup;Ti[@°@Ã.I")#   Strategy.new(document, metadata);FI"#;FI"A# @param [ Document ] document The document to cascade from.;Fi	[	[	@_iI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@fiI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@miI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@piI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[@°@ÿ0I"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;FI"-# @return [ Strategy ] The new strategy.;Fi	[	[	@_iI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@fiI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@miI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@piI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[@°@Â0I"def function(arglist);FI"@var, @var = var, var;FI"@var = var.send(var.name);Fi	[	[	@_iI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@fiI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@miI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@piI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[@‡I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];TI"#;Ti	[	[	@Ái¿I"=      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>;Ti[	@Ái¯I"E      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=1;Ti[	@Ái0I"/      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [;Ti[	@Ái6I">      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => [];Ti[I"(attr_accessor(:username, :password);FI" ;F@Ö/I" ;F@á/i	[	[	@Îi	I"–module Backup
  module Storage
    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:passive_mode);Fi[	@¡iI"◊    class RSync < Base
      include(Backup::CLI::Helpers)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:local);Fi[	@˘i
I"∂module Backup
  module Storage
    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##;Fi[	@¸i
I"∑module Backup
  module Storage
    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##;Fi[@¨@
I"var = @var["cw"];F@à-@â-i	[	[	@•i´I"ﬂ      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@®i¶I"ﬂ      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@´iöI"ﬂ      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@.iÉI"    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[I"O# * <tt>:if</tt> - Specifies a method, proc or string to call to determine;FI"M#   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;FI"O#   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;FI"O#   proc or string should return or evaluate to a +true+ or +false+ value.;FI"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi	[	[	@«(i)I"      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@«(icI"      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@Â&i)I"˛      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@ıiÑI"      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should ot occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[@¨@
I"Avar = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);FI"var;FI"end;Fi	[	[	@Ji√I"Î        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@Ji»I"˚        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@JiÕI"˚        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@Ji“I"˚        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[@°I"/# @return [ String, Symbol ] The override.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	I"/data//mongoid_proj/lib/mongoid/threaded.rb;TiI"˜    #
    # @example Get the global database override.
    #   Threaded.database_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:db-override"]
    end;Fi[	@E1i*I"    #   Threaded.database_override = :testing
    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:db-override"] = var
    end;Fi[	@E1i:I"˙    #
    # @example Get the global session override.
    #   Threaded.session_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:session-override"]
    end;Fi[	@E1iHI"    #   Threaded.session_override = :testing
    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:session-override"] = var
    end;Fi[@'@(@@	I"var = {};Fi	[	[	@öiOI"j      unless var.empty? then
        var = var.map { |arglist| var.message }.join(",")
        raise(MultiparameterAssignmentErrors.new(var), "#{errors.size} error(s) on assignment of multiparameter attributes [#{error_descriptions}]")
      end
    end
    
    def function(arglist)
      var = {}
      var.each do |arglist|
        var = var.split("(").first;Fi[	@Û	iTI"Â        (attempted_path or scope_path)
      else
        scope_path
      end
    end
    
    def function(arglist)
      var = {}
      var = :"new_#{scope}_session_path"
      var[:format] = request_format unless skip_format?;Fi[	@Xi%I"         ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end
    
    def function(arglist)
      var = {}
      var["warnings"] = []
      var["nokogiri"] = Nokogiri::VERSION;Fi[	@Ëi2I"-          super(var, *var, &var))
        rescue NameError
          __mock_proxy.raise_unexpected_message_error(var, *var)
        end
      end
      
      def function(arglist)
        var = {}
        extract_option(var, var, :null_object)
        extract_option(var, var, :__declared_as, "Mock");Fi[@¨@
I"broadcast(var, var);FI"end;FI" ;Fi	[	[	@ài)I"Ë      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist);Fi[	@àiBI"˝      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@àifI"ﬁ      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var);Fi[	@àivI"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.
      def function(arglist);Fi[@¨@
I"var = @var;F@æ/I"newobj;Fi	[	[	@•iÓI"◊  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@®i˜I"◊  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@´i›I"◊  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@.i@I"Ò    out(">>")
    out("endobj")
  end
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out(((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences " + "[") + var) + "]>>"))
      out("endobj");Fi[@d'@`(I"#;F@í(I"var = case var;Fi	[	[	@ﬂi,I"Ç      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@•i*I"Ç      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@®i4I"Ç      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@´i(I"Ç      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[@d!I"-# Credentials for the specified database;FI"##;FI"# Connectivity options;FI"##;Fi	[	[	@UiI"‡      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # IPv6 support (disabled by default)
      ##;Fi[	@XiI""      ##
      # Name of the database that needs to get dumped
      # To dump all databases, set this to `:all` or leave blank.
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	I"4data//backup_proj/backup/database/postgresql.rb;TiI"Á      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	@éiI"H      
      ##
      # Name of and path to the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Determines whether Backup should invoke the SAVE command through
      # the 'redis-cli' utility to persist the most recent data before;Fi[@'@T@€@‹@++i	[	[	@GiGI"“      def function(arglist)
        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Returns true if the record is persisted, i.e. it's not a new record and it was;Fi[	@Ã	idI"ÿ      # Enumerates over the manifest files
      def function(arglist)
        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      
      protected;Fi[	@qiùI"    def function(arglist)
      var = @var[:processors]
      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Saves the file, if there are no errors. If there are, it flushes them to;Fi[	@‘iI"ª          @var = 0
          @var = 0
          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist);Fi[@¨@
I"@var.each(&var);FI"end;FI" ;Fi	[	[	@“iI"ª      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self;Fi[	@' i$I"‹      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1);Fi[	@iÆI"ú  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag };Fi[	@UiI"ù  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?;Fi[@°I"#   class Vehicle;FI"7#     state_machine :state, :initial => :parked do;FI"#       ...;FI"#     end;Fi	[	[	@ú%i◊I"»    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   ;Fi[	@ú%iÂI"6    # the default behavior of initializing the state machine attributes is used.
    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize;Fi[	@ú%iˆI"R    # never get initialized.  In order to ensure that all initialization hooks
    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[	@ú%iI"/    # 
    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[@+I"@var = (var + var);FI"	else;FI"@var = var if (var == 2);FI"end;Fi	[	[	@•iúI"•      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@®ióI"•      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@´iãI"•      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@1iÄI"¶    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[@`(I"#;F@í(I"var = case var;F@˙-i	[	[	@ﬂi-I"ä      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[	@•i+I"ä      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[	@®i5I"ä      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :failure then;Fi[	@´i)I"ä      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[@°I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;Fi	[	[	@ iI"!        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@ iWI"!        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@ i{I"!        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@ú%iåI"    #   class Vehicle
    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     ;Fi[@+@)I"end;FI" ;FI"def function(arglist);Fi	[	[	@i°I"!        (@var, var = var, @var
        yield)
      ensure
        @var = var
      end
    end
    
    def function(arglist)
      var = caller[0].split(":")[(0..1)].join(":")
      raise(GemfileError, "Undefined local variable or method `#{name}' for Gemfile\n        from #{location}");Fi[	@i,I"©    @var = var
    unless var.nil? then
      @var = var.delete(:using)
      @var = var
    end
  end
  
  def function(arglist)
    @var ||= case var
    when nil then;Fi[	@.iBI"Ö        @var = @var
      end
      @var = (@var - @var)
      @var = var
    end
  end
  
  def function(arglist)
    @var = 1
  end;Fi[	@›i*I"¬          (@var[@var]
          @var = true)
        rescue Exception => var
          @var = var
        end
      end
      
      def function(arglist)
        case @var
        when nil then;Fi[@+@)@*I"private;FI" ;Fi	[	[	@!iCI"ß    end
    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "#{base_dir}/specifications/#{full_name}.gemspec";Fi[	@4i(I"Û    # once the remote gem is downloaded, the backend specification will
    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      @var ||= @var.fetch_spec([@var, @var, @var]);Fi[	@I#i"I"ó    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    
    # Gets the default Mongoid logger - stdout.
    #;Fi[	@<i6I"÷              @var = var
            end
            @var = var
            @var = var
          end
          
          private
          
          # Can the existing relation potentially be deleted?
          #;Fi[@°I"%# @return [Array<Twitter::User>];FI"def function(arglist);FI"S@var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) };FI"end;Fi	[	[	I"0data//twitter_proj/twitter/action/follow.rb;TiI"¸      end
      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	I";data//twitter_proj/twitter/action/list_member_added.rb;TiI"      end
      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	I"1data//twitter_proj/twitter/action/mention.rb;Ti&I"˝      end
      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	I"1data//twitter_proj/twitter/action/retweet.rb;TiI"˝      end
      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[@+@)@*I"attr_reader :function;FI" ;Fi	[	[	@!iI"‘      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    
    # needed for standalone, load required_paths from local gemspec
    # after the gem in installed;Fi[	@MiWI"®    
    class JsArg
      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing;Fi[	@Xi2I"é  
  def function(arglist)
    @var = var.to_s
    @var = var
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == "HEAD");Fi[	@üi4I"     end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    
    ERROR_MESSAGES.keys.each do |arglist|
      define_method("#{state}?") { |arglist| (@var == var) };Fi[@≤1I"	else;F@¥1I"end;FI"end;Fi	[	[	@•iùI"ñ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@®iòI"ñ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@´iåI"ñ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@1iÅI"†      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[@¨@
I"@var ||= var;FI"end;FI" ;Fi	[	[	@±iI"ƒ      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@¥iI"ø      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var;Fi[	@Ÿ	iI"Á      attr_accessor(:feature)
      
      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var);Fi[	@ÉiI"©      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false;Fi[I"#   class Person;F@(I"#;F@(I",#     attribute_method_suffix '_short?';Fi	[	[	@iHI"L      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@iÇI"      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@iƒI"k      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #
      #     # Call to define_attribute_method must appear after the;Fi[	@iÎI".      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #;Fi[@¥1I"end;FI"end;FI"end;FI" ;Fi	[	[	@•iüI"≤        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@®iöI"≤        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@´iéI"≤        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@1iÉI"ü        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell)
  ;Fi[@¨@
@Ö*I"end;FI" ;Fi	[	[	@¥i>I"’      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var);Fi[	@Ÿ	iHI"6      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq;Fi[	@3i(I"       def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init;Fi[	@3iRI"÷          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags;Fi[I"#     private;FI"#;F@¶-@ß-I"#     end;Fi	[	[	@iOI"Ì      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@iãI"…      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@iœI"Ì      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@iÚI"Ï      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[@'@(@@	I"var = "";Fi	[	[	@iøI"§        File.open(var, "wb") { |arglist| var.puts(var) })
      rescue Errno::EACCES
        raise(Bundler::InstallError, "There was an error while trying to write to Gemfile.lock. It is likely that \nyou need to allow write permissions for the file at path: \n#{File.expand_path(file)}")
      end
    end
    
    def function(arglist)
      var = ""
      sorted_sources.each do |arglist|
        (var << var.to_lock);Fi[	@…	ioI"        else
          "          No Usage!\n".gsub(/^ {8}/, "")
        end
      end
    end
    
    def function(arglist)
      var = ""
      var = Compass::Frameworks::ALL.inject(0) do |arglist|
        var = var.template_directories.inject(0) do |arglist|;Fi[	@riƒI"        end
      else
        var.all? { |arglist| color_stop?(var) } ? (var) : (nil) if var.is_a?(Array)
      end
    end
    
    def function(arglist)
      var = ""
      if angle?(position_or_angle) then
        var = " gradientTransform = \"rotate(#{position_or_angle.value})\"";Fi[	@iI"          " #{words[0]} and #{words[1]}"
        else
          " #{words[(0...-1)].join(", ")}, and #{words[-1]}"
        end
      end
      
      def function(arglist)
        var = ""
        var.each_with_index do |arglist|
          if (var < (var.length - 2)) then;Fi[@3)@4)@5)I"K#   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;FI".#   vehicle.state           # => "parked";Fi	[	[	@ú%i€I"L    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,;Fi[	@ú%iˇI"9    #     def initialize(attributes = {})
    #       ...
    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling;Fi[	@ú%iI"R    #     def initialize(attributes = {})
    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually;Fi[	@ú%i+I"P    #       initialize_state_machines(:static => :force) do
    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid;Fi[@Ù@ıI"#   person.pets;TI"#   # => [;T@·i	[	[	@Ái'I"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái`I"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái~I"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁióI"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@'@T@;I"var = @var["cw"];F@à-i	[	[	@•i™I"”    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@®i•I"”    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@´iôI"”    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@.iÇI"*    var = (var + "B") if var.!=(0) and var.index("B").nil?.!
    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[@Ô.I"/var = ((@var - @var) - @var) if (var == 0);F@Ã-@€-I"var = var.length;Fi	[	[	@•i[I"$  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@®iPI"$  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@´iJI"$  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@.i0I"  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "\n")
    var = 0;Fi[@¨@
I"	name;FI"end;FI" ;Fi	[	[	@Bi\I"£        @var = app_cache_path if has_app_cache?
        local_specs
      end
      
      def function(arglist)
        name
      end
      
      private
      ;Fi[	I")data//diaspora_proj/models/aspect.rb;TiI"π  attr_accessible(:name, :contacts_visible, :order_id)
  
  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var;Fi[	I"Idata//redmine_proj/plugins/awesome_nested_set/spec/support/models.rb;Ti$I"»  def function(arglist)
    @@var
  end
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } });Fi[	I"Ldata//redmine_proj/plugins/awesome_nested_set/test/fixtures/category.rb;TiI"Ÿclass Category < ActiveRecord::Base
  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } });Fi[@à-@â-@.I"var = var.length;FI"var = -1;Fi	[	[	@•iÆI"÷  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@®i©I"÷  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@´iùI"÷  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@.iÜI"÷  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[@à-@â-@ä-@ã-I"	next;Fi	[	[	@•i¬I"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "));Fi[	@®iΩI"Ò        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then;Fi[	@´i±I"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "));Fi[	@.iôI"ı        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == " "[0]) then;Fi[@Ù@ı@j2@k2I"#;Fi	[	[	@ú%i‹I"á    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,
    # the default behavior of initializing the state machine attributes is used.;Fi[	@ú%i I"\    #       ...
    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling
    # <tt>super()</tt> will not only call the superclass's +initialize+, but;Fi[	@ú%iI"x    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually
    # in cases where you want to change how static / dynamic initial states get;Fi[	@ú%i,I"a    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid
    # initialization issues when +nil+ is a valid state.  Without passing in;Fi[@I"@var ||= {};FI"end;FI" ;FI"def function(arglist);Fi	[	[	@‹iI";          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("#{self}##{name} has been deprecated as of " + "backup v.#{deprecation[:version]}")
          (var << "\n#{deprecation[:message]}") if var[:message];Fi[	@PiKI"ñ      
      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@PiOI"¡        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end;Fi[	@„iI"ﬂ        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("#{intro} received unexpected message :#{sym}#{arg_message(*args)}")
      end;Fi[@ì/I"end;FI" ;FI"private;FI" ;Fi	[	[	@Îi!I"Á        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@¡i#I"˙        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored;Fi[	@˘iI"‰        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@¸iI"‰        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[@˘'I"newobj;FI"#out("<</Type /FontDescriptor");FI"'out(("/FontName /" + var["name"]));FI"out("/Flags 6");Fi	[	[	@•iXI"Ô      end
    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[	@®iYI"	    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[	@´iCI"˝      var = (var + "]")
    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[	@1iñI"	    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[@^I"var = (var + 1);F@ó$I"	next;FI"end;Fi	[	[	@•i{I"«        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[	@®ipI"Â        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@´ijI"«        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[	@1iPI"…        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var == " "[0]) then
        var = var;Fi[I">Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);FI"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;Fi	[	[	@•iªI"6      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@®i∂I"(      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@´i™I"6      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@1iÆI"
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[@˘'@Á2I"out("<</Type /Font");FI""out("/Subtype /CIDFontType0");FI"'out(("/BaseFont /" + var["name"]));Fi	[	[	@•iCI"Ì    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((((("/CIDSystemInfo <</Registry " + textstring("Adobe")) + " /Ordering ") + textstring(var["registry"]["ordering"])) + " /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@®iLI"À    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@´i2I"À    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@1iâI"À    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[@@@@sI"#;Fi	[	[	@1ißI"û      end
      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #
  	# Calculate closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@1i∑I"Æ      @var = (@var + 1)
      @var.push([])
    else
      # do nothing
    end
  end
  
  #
  	# Convert to accessible file path
  	# @param string :attrname image file name;Fi[	@1iíI"Æ      SetStyle("b", true)
      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #
  	# Process closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@1i?I"µ        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.
  	# @param string :tag tag name (in lowercase);Fi[@¨@
I"if var.nil? then;FI"nil;FI"	else;Fi	[	[	@ãiI"Á            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if String.===(var) then
              Hash[var.scan(HstorePair).map do |arglist|;Fi[	@ãiYI"        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if ("empty" == var) then
              (nil..nil);Fi[	@ãikI"˝            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if Range.===(var) then
              if [var.first, var.last].all? { |arglist| Integer.===(var) } then;Fi[	@iI"—        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then
            var;Fi[@'@T@;@21I"var;Fi	[	[	@Ji¬I"Î      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@Ji«I"˚      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@JiÃI"˚      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@Ji—I"˚      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[I"G# destination<String>:: the relative path to the destination root.;FI"C# config<Hash>:: give :verbose => false to not log the status.;FI"#;FI"# ==== Examples;FI"#;Fi	[	[	@_"i
I"    # Creates an empty directory.
    #
    # ==== Parameters
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   empty_directory "doc"
    #;Fi[	I"Hdata//bundler_proj/bundler/vendor/thor/actions/file_manipulation.rb;Ti,I"1    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   link_file "README", "doc/README"
    #;Fi[	@J3iBI">    #
    # ==== Parameters
    # source<String>:: the address of the given content.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   get "http://gist.github.com/103208", "doc/README"
    #;Fi[	@J3ibI"0    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   template "README", "doc/README"
    #;Fi[I"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;Fi	[	[	@•i±I"◊    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@®i¨I"◊    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@´i†I"◊    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@.iâI"◊    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[@¨@
I"var;FI"end;FI" ;Fi	[	[	@5	iI"¿      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var));Fi[	@∂i3I"ﬁ      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true);Fi[	@hi,I"            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end
          
          alias :handle_snippet_text :handle_success
        end;Fi[	@iI"Ü    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var;Fi[@@"@Ú0I"end;FI" ;Fi	[	[	@_iI"é        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@fiI"é        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@miI"l        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead
        # sets the foreign key values to nil.;Fi[	@piI"é        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[I"out(">>");FI"out("endobj");FI"newobj;F@3@3i	[	[	@•iBI"Ò    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((((("/CIDSystemInfo <</Registry " + textstring("Adobe")) + " /Ordering ") + textstring(var["registry"]["ordering"])) + " /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@®iKI"œ    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@´i1I"œ    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@1iàI"œ    out(((("/BaseFont /" + var["name"]) + "-") + var["cMap"]))
    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[I">out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));FI"out(">>");FI"out("endobj");FI"newobj;F@3i	[	[	@•iAI"K    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@®iJI"K    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@´i0I"K    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@1iáI"K    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["cMap"]))
    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[@'@(@@	I"if @var then;Fi	[	[	@i∂I"Ó  def function(arglist)
    if (self.tag_string.count("#") > 5) then
      (errors[:base] << "Profile cannot have more than five tags")
    end
  end
  
  def function(arglist)
    if @var then
      errors.add(:birthday)
      @var = nil;Fi[	@›i6I"ø          @var.=~(@var.message)
        else
          (@var == @var.message)
        end
      end
      
      def function(arglist)
        if @var then
          @var.message
        else;Fi[	@‡i#I"	          @var.nil?.!
        else
          @var.nil? ? ((@var == @var)) : ((@var == @var).&((@var == @var)))
        end
      end
      
      def function(arglist)
        if @var then
          "expected #{expected}, got #{@caught_symbol.inspect}"
        else;Fi[	@‡i+I"          "expected #{expected}, got #{@caught_symbol.inspect}"
        else
          "expected #{expected} but nothing was thrown"
        end
      end
      
      def function(arglist)
        if @var then
          "expected #{expected} not to be thrown"
        else;Fi[@Ë2@È2I"out("/Flags 6");FI"'out("/FontBBox [0 -200 1000 900]");FI"out("/ItalicAngle 0");Fi	[	[	@•iZI"    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@®i[I"˘    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@´iEI"    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@1iòI"˘    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[I"newobj;F@Ë2@È2I"out("/Flags 6");F@†3i	[	[	@•iYI"¸    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@®iZI"    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@´iDI"¸    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@1ióI"    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[I".assert(Category.left_and_rights_valid?.!);FI"end;FI" ;FI"def function(arglist);FI",assert(Category.left_and_rights_valid?);Fi	[	[	I"Rdata//redmine_proj/plugins/awesome_nested_set/test/awesome_nested_set_test.rb;TiﬂI":    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false);Fi[	@ø3iÊI"]    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false);Fi[	@ø3iÌI"v    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false);Fi[	@ø3iÙI"l    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false);Fi[@'@T@;I""";FI"end;Fi	[	[	@Mi2I"Â      def function(arglist)
        var = eval_js("#{@regexp}.exec('#{step_name}')")
        var.to_a[(1..-1)].map { |arglist| JsArg.new(var) } if var
      end
      
      def function(arglist)
        ""
      end
    end
    ;Fi[	@ái<I"y  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist);Fi[	@íi	I"®  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist);Fi[	@íiI"~    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist);Fi[@I"
super;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@Éi…I"^      
      # Many Rails applications monkey-patch a replacement of the configure_connection method
      # and don't call 'super', so leave this here even though it looks superfluous.
      def function(arglist)
        super
      end
      
      def function(arglist)
        @var.query_with_result = true
        var = exec_query(var, var, var);Fi[	@iCI"É  end
end
class HeadSoftwareSpec < SoftwareSpec
  def function(arglist)
    super
  end
  
  def function(arglist)
    return
  end;Fi[	I"Ödata//redmine_proj/plugins/open_id_authentication/generators/open_id_authentication_tables/open_id_authentication_tables_generator.rb;TiI"ﬁclass OpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("migration.rb", "db/migrate") }
  end;Fi[	I"ïdata//redmine_proj/plugins/open_id_authentication/generators/upgrade_open_id_authentication_tables/upgrade_open_id_authentication_tables_generator.rb;TiI"Âclass UpgradeOpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("migration.rb", "db/migrate") }
  end;Fi[@@‘3I"@var = nil;FI"end;FI" ;Fi	[	[	I"Gdata//bundler_proj/bundler/vendor/net/http/persistent/ssl_reuse.rb;TiI"y  
  @var = nil
  
  def function(arglist)
    super
    @var = nil
  end
  
  if (RUBY_VERSION > "1.9") then
    ##;Fi[	I",data//compass_proj/compass/test_case.rb;TiI"ô  else
    Test::Unit::TestCase
  end
    def function(arglist)
      super
      @var = nil
    end
    
    def function(arglist)
      var = open(var);Fi[	@3iNI"        attr_reader(:scenario_outline)
        
        # https://rspec.lighthouseapp.com/projects/16211/tickets/342
        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name };Fi[	@iI"Æ      @var = var[:guard]
    end
    
    def function(arglist)
      super
      @var = nil
    end
    
    # The initial state name for this path
    def function(arglist);Fi[@'@T@;@Y1I"end;Fi	[	[	@ài(I"”      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # +feature_element+ is either Scenario or ScenarioOutline;Fi[	@àiAI"Œ      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@àieI"Œ      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@àiuI"      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.;Fi[@È2I"out("/Flags 6");F@†3@°3I"out("/Ascent 800");Fi	[	[	@•i[I"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@®i\I"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@´iFI"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@1iôI"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[@'@(@@	I"var = @var["cw"];Fi	[	[	@•i©I"ÿ      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@®i§I"⁄      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@´iòI"ÿ      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@.i,I"ﬁ      @var = @var if (var == 1)
    else
      @var = (@var + var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[I"out("/Flags 6");F@†3@°3I"out("/Ascent 800");FI"out("/Descent -200");Fi	[	[	@•i\I"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50");Fi[	@®i]I"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60");Fi[	@´iGI"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50");Fi[	@1iöI"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60");Fi[@†3@°3I"out("/Ascent 800");F@4I"out("/CapHeight 800");Fi	[	[	@•i]I"    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>");Fi[	@®i^I"    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>");Fi[	@´iHI"    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>");Fi[	@1iõI"    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>");Fi[I"%categories(:child_2).save(false);F@∏3I"end;FI" ;FI"def function(arglist);Fi	[	[	@ø3iﬁI"-  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil;Fi[	@ø3iÂI"L  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt];Fi[	@ø3iÛI"_  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt];Fi[	@ø3i˙I")  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    var = Category.create
    var = Category.create;Fi[@¢@£@Ú"@Û"I" #   person.pets.size # => 3;Ti	[	[	@ÁièI"      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@ÁiI"0      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@ÁiI"D      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@ÁiçI"Ç      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #;Ti[I"var.move_to_child_of(var);FI"var.move_to_child_of(var);FI"&var = Category.roots.last.to_text;FI"2Category.update_all("lft = null, rgt = null");FI"Category.rebuild!;Fi	[	[	I"Rdata//redmine_proj/plugins/awesome_nested_set/spec/awesome_nested_set_spec.rb;TiNI"c    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end;Fi[	@N4iYI"f    var = Category.create(:name => "Node-1")
    var = Category.create(:name => "Node-2")
    var = Category.create(:name => "Node-3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end;Fi[	@ø3iéI"f    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var)
  end;Fi[	@ø3iõI"i    var = Category.create(:name => "Node-1")
    var = Category.create(:name => "Node-2")
    var = Category.create(:name => "Node-3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var)
  end;Fi[@'@(@@	 @.0i	[	[	@Îi5I"%        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@¡i5I"      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin;Fi[	@˘i)I"5      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@¸i'I"6      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[I"@var.puts;FI"@var.flush;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@ôi~I"•        if var then
          @var.puts(format_string((("\nIf you want snippets in a different programming language,\n" + "just make sure a file with the appropriate file extension\n") + "exists where cucumber looks for step definitions."), :failed))
        end
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        return unless var[:wip]
        var = step_mother.scenarios(:passed);Fi[	@¢iDI"ø      
      def function(arglist)
        @var.puts("#{keyword}: #{name}")
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2
        @var = 2;Fi[	@¢iNI"†      end
      
      def function(arglist)
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2
        @var = 2;Fi[	@¢iZI"»      
      def function(arglist)
        @var = nil
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        print_feature_element_name(var, var, var, var)
      end;Fi[@I"var = @var;T@æ/I"newobj;F@Ï-i	[	[	@•iÔI"Ÿ  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@®i¯I"Ÿ  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@´iﬁI"Ÿ  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@1i$I"Û  	# putfonts
  	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[@¨@_ I"end;FI"end;FI"end;Fi	[	[	@i[I"ø        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@iÉI"É          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@i>I"™          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@"iRI"¢        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[I"/render(:nothing => (true), :status => 422);FI"end;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@ﬂiI"Á        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id])
    if (current_user.owns?(@var) or current_user.owns?(@var.parent)) then;Fi[	@çiI"Ê        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id)
    current_user.retract(@var);Fi[	@ÌiÇI"      Webfinger.in_background(params[:diaspora_handle], :single_aspect_form => (true))
      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id])
    if @var then;Fi[	@iJI"Ô        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first
    if var then;Fi[I",@var = sprintf("%.3f g", (var / 255.0));FI"	else;FI"U@var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0));FI"end;FI"@var = @var.!=(@var);Fi	[	[	@.iI"5  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
  end;Fi[	@.i$I"  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end
  ;Fi[	@1iÃI"S  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
    @var = [var, var, var] if var;Fi[	@1iÏI":  	#
  def function(arglist)
    if (((var == 0) and ((:g == 0) and (:b == 0))) or (:g == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    @var = [var, var, var] if var
  end;Fi[@@#@$I" ;FI"def function(arglist);Fi	[	[	@¨iI"    end
    
    class ColumnDefinition < Struct.new(:base, :name, :type, :limit, :precision, :scale, :default, :null)
      def function(arglist)
        var
      end
      
      def function(arglist)
        base.type_to_sql(type.to_sym, limit, precision, scale)
      end;Fi[	@5	iI"Æ        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var))
      end;Fi[	@∂i4I"Ã        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true)
      end;Fi[	@iI"y      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end;Fi[I"undef_method(:namespace);FI" ;F@ã.I" ;F@ç.i	[	[	@ë.iI"Ÿ      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@î.iI"Ÿ      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@ó.iI"˜module Nokogiri
  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@ö.iI"‹      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist);Fi[I"acts_as_api;FI" ;F@/I"var.add(:id);FI"var.add(:guid);Fi	[	[	@/iI"ß  
  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	@!/iI"ú    end
  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	@iI"€  
  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:name)
    var.add(lambda { |arglist| var.diaspora_handle }, :as => :diaspora_id);Fi[	@ÊiI"∞  
  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:created_at)
    var.add(:author);Fi[I"%puts("The offending files are:");FI"puts(var);FI"@var = true;FI"end;FI"end;Fi	[	[	@o
i6I"O      puts("For Java software, it is typically better for the formula to")
      puts("install to \"libexec\" and then symlink or wrap binaries into \"bin\".")
      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@o
iFI"    unless var.empty? then
      opoo("Non-libraries were installed to \"lib\".")
      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@o
iRI"
    unless var.empty? then
      opoo("Non-executables were installed to \"bin\".")
      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@o
i^I"    unless var.empty? then
      opoo("Non-executables were installed to \"sbin\".")
      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[@'@T@;I"	to_s;FI"end;Fi	[	[	@“	iI"•    def function(arglist)
      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[	@riI"‘        raise(Sass::SyntaxError, "Expected a number. Got: #{stop}")
      end
      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    
    def self.color_to_s(arglist);Fi[	@ri8I")      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[	@O)i$I"Ç    
    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[I"assert(var.universal?.!);FI"assert(var.i386?.!);FI"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);Fi	[	[	@%inI"  
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@%içI"  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@%iùI"(  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@%i≠I"  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[@'I"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);Fi	[	[	@‚,iI"	    puts((("> " * var) + var.to_s))
    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--all") then
      Formula.each { |arglist| puts("#{f.name}: #{(f.deps * " ")}") };Fi[	@Â,iI"œ  def function(arglist)
    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--help") then
      puts("'v8'.f # => instance of the Ack formula");Fi[	@_
iI"ó      ARGV.formulae
    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    ff.each do |arglist|
      next if var.build.empty?;Fi[	@Í,i
I"˝  def function(arglist)
    (self > 1) ? ("s") : ("")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then
      abort("Cowardly refusing to `sudo brew upgrade'");Fi[I"$var = read_file("libexec/NOOP");FI":assert(var.include?("NOOP").!, "File was unpatched.");FI"Fassert(var.include?("ABCD"), "File was not patched as expected.");FI"end;FI"end;Fi	[	[	@é
i#I"5  def function(arglist)
    shutup do |arglist|
      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  ;Fi[	@é
i-I"7  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  ;Fi[	@é
i7I"3  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  ;Fi[	@é
iAI"4  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
end;Fi[@5@5I"end;FI"end;FI"end;Fi	[	[	@é
i$I"5    shutup do |arglist|
      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@é
i.I"7    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@é
i8I"3    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@é
iBI"    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
end;Fi[@n@oI" ;F@àI"
false;Fi	[	[	@0	iI"Ü      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@5	i|I"      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@>i$I"w    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@áixI"º  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  ;Fi[@'@à+I"	true;FI"end;FI"def function(arglist);Fi	[	[	@˝i.I"˙        end
        def function(arglist)
          defined? I18n ? (super) : (var ? (var.to_s.humanize.downcase) : ("nil"))
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end;Fi[	@˝i1I"∂        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end;Fi[	@˝i4I"ø        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          :activerecord
        end;Fi[	@
i6I"ø        end
        def function(arglist)
          false
        end
        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing
        end;Fi[I"if (@var > @var) then;FI"@var = @var;FI"@var = (@var + var);FI"!var = ((@var - @var) - @var);FI"/var = (((var - (2 * @var)) * 1000) / @var);Fi	[	[	@•iÃI"p      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[	@®i‘I"C      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var)
            var = (var + 1);Fi[	@´iªI"p      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[	@.i¶I"P      var = (var + GetCharWidth(var, var))
      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[@$I"var.puts(var);FI"end;FI"end;FI"end;Fi	[	[	@ÊiI"ª        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@Èi$I"ª        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@ÏiI"”        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
    
    def self.suffix(arglist);Fi[	@ÚiI"ª        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[@@:0I"end;FI" ;FI"##;Fi	[	[	@ÅiI"'      
      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor;Fi[	@ái'I"%      
      ##
      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database;Fi[	@ìiI"(      
      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive;Fi[	@aiFI",      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process;Fi[@21I"var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@Ji≈I"˚      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@Ji I"˚      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@JiœI"˚      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@Ji‘I"⁄      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var;Fi[@'@T@;I"@var ||= {};FI"end;Fi	[	[	@‹iI"ÿ        # Used only within the specs
        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist);Fi[	@PiMI"§      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist);Fi[	@÷
iíI"E          var = ::I18n.load_path.select { |arglist| (File.basename(var, ".*") == var) }
          load_translations(var)
          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        # Looks up a translation from the translations hash. Returns nil if;Fi[	@„iI"¬        @var = (var[:__declared_as] or "Mock")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist);Fi[@I"%@var, @var, @var = var, var, var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@6idI"        
        attr_accessor(:status, :value)
        
        def function(arglist)
          @var, @var, @var = var, var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          var.visit_table_cell_value(value, status);Fi[	@àiI"÷      
      #:nodoc:
      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@øiI"⁄    class FeaturesLoader
      include(Formatter::Duration)
      
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        load unless @var
        @var;Fi[	@‘iI"€module Spec
  module Matchers
    class Has
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        var.__send__(predicate(@var), *@var, &@var)
      end;Fi[@'@ô@öI"end;FI"end;Fi	[	[	@i˚I"‰          var = "#{name.to_s.singularize}_ids="
          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	@\iSI"•            var.save
            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end
end;Fi[	@êiI"               field(var.inverse_type, :type => (String))
              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end
end;Fi[	@Œi£I"§            var = @var.instance_eval(&var)
            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end
end;Fi[@Æ@ØI" ;F@ŸI"	true;Fi	[	[	@∂iàI"√      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@∂iëI"√      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@£iáI"ê      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@£i´I"è      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[I"#     relation.push(doc);FI"#   end;FI"#;FI"8# @return [ Object ] The return value of the block.;FI"#;Fi	[	[	@•i1I"Ó      #
      # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@•iPI"Ò      #
      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@•i{I"Ô      #
      # @example Execute in loading mode.
      #   _loading do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.3.2
      def function(arglist);Fi[	@•i©I"        #
        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist);Fi[@F@G@H@ıI" ;Fi	[	[	@êi1I"Ì              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist)
          super.insert;Fi[	@Ωi'I"ƒ        def function(arglist)
          @var.synchronize do |arglist|
            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      ;Fi[	@ii^I"»          if lock_strategy_enabled?(:failed_attempts) and attempts_exceeded? then
            :locked
          else
            super
          end
        end
      end
      
      protected
      ;Fi[	@:iI"        var = Time.now.strftime("%y%m%d")
        var = "#{prefix}#{t}-#{$$}-#{rand(4294967296).to_s(36)}-#{n}#{suffix}"
      else
        super
      end
    end
  end
  
  module TempfileEncoding
    # This overrides Tempfile#binmode to make sure that the extenal encoding;Fi[@I"	to_s;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@“	iI"í      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var)
    end;Fi[	@ri:I"è      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end;Fi[	@O)i&I"ï      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "#{name}(#{args.join(", ")})"
    end;Fi[	@R)iI"µclass Moped::BSON::ObjectId
  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist)
    ActiveSupport::XmlMini.to_tag(var[:root], self.to_s, var)
  end;Fi[@@Ö*I"end;FI" ;FI"def function(arglist);Fi	[	[	@¥i?I"√        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end;Fi[	@Ÿ	iII"$        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq
      end;Fi[	@3i)I"Á        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init
        example_rows.each { |arglist| var.skip_invoke! };Fi[	@3iSI"“          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags
        end;Fi[@I"@var ||= var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@±iI"Ì      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_comment(@var) unless @var.empty?;Fi[	@¥iI"œ      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var
        @var.init if @var;Fi[	@Ÿ	iI"”      
      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@ÉiI"©      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end;Fi[@'@,@,I" ;FI"def function(arglist);Fi	[	[	@Oi6I"P            ([primary_key] + (column_names - [primary_key])).compact.each_with_index do |arglist|
              (@var << [var, "#{aliased_prefix}_r#{i}"])
            end
          end
          @var
        end
        
        def function(arglist)
          Hash[column_names_with_alias.map { |arglist| [var, var[var]] }]
        end;Fi[	@˙iRI"        end)
        unless (@var.include?(NO_PROFILE_LONG_FLAG) or @var.include?(NO_PROFILE_SHORT_FLAG)) then
          @var.push("--no-profile")
        end
        @var
      end
      
      def function(arglist)
        @var = var
        @var = @var.dup;Fi[	I"-data//homebrew_proj/test/test_updater.rb;Ti,I"    unless @var then
      require("yaml")
      @var = YAML.load_file((Pathname.new(ABS__FILE__).parent.realpath + "fixtures/updater_fixture.yaml"))
    end
    @var
  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new;Fi[	@qiêI"        var.each_pair do |arglist|
          @var[var.to_sym] = Paperclip::Style.new(var.to_sym, var.dup, self)
        end
      end
      @var
    end
    
    def function(arglist)
      var = @var[:only_process].dup
      var = var.call(self) if var.respond_to?(:call);Fi[@I"@var.each(&var);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@“iI"µ        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self
        (@var << var);Fi[	@' i%I"ÿ        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)];Fi[	@iØI"ä    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag }
  end;Fi[	@UiI"ã    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end;Fi[@'@T@;@)3I"nil;Fi	[	[	@ãiI"Ω          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if String.===(var) then;Fi[	@ãiXI"˚        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if ("empty" == var) then;Fi[	@ãijI"ø              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if Range.===(var) then;Fi[	@iI"Í        var.inherit_from!(configuration)
        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then;Fi[I"%#         transition all => :off;FI"#       end;FI"#     end;FI"#   end;FI"#;Fi	[	[	@¬iQI"N    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.state                                 # => "parked";Fi[	@¬i~I"J    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.fire_events(:ignite, :disable_alarm)  # => true;Fi[	@ú%iïI"A    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly
    #   vehicle = Vehicle.create    # => #<Vehicle id=1 state="parked" alarm_state="active">;Fi[	@ú%i–I"5    #       end
    #       
    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end
    #   end
    # 
    # The above class defines two state machines: +heater_state+ and +alarm_state+.
    # For the +heater_state+ machine, the following methods are generated since;Fi[@]/I"#;FI"# @since 3.0.0;F@`/I"	true;Fi	[	[	@<ivI"√      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@<i†I"◊        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[	@Pi{I"Ω      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@PiΩI"“        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[@ÃI"# type.;FI"#;F@I"#   object.mongoize;Fi	[	[	@<iRI"	        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.;Fi[	@?iI"Ó        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[	@PinI"Î        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.;Fi[	@Si{I"Ì        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[@z@{@@d,@21i	[	[	@Ji¡I"Î      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@Ji∆I"˚      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@JiÀI"˚      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@Ji–I"˚      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[@Â0@0@Ò0@Ú0I"end;Fi	[	[	@_iI"Ü        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@fiI"Ü        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@miI"É        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead;Fi[	@piI"Ü        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[@@21I"var;FI"end;FI" ;Fi	[	[	@JiƒI"˚        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@Ji…I"˚        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@JiŒI"˚        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@Ji”I"⁄        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[@ÿ0@„0I"#;F@Â0@0i	[	[	@_iI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@fiI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@miI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@piI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[@I"%var = Node.new(:COMBINATOR, var);FI"var;FI"end;FI" ;Fi	[	[	@Ji(I"·      
      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@Ji-I"√        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@Ji2I"√        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@Ji7I"≤        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted
      # reduce 56 omitted;Fi[I"# type.;FI"#;F@@,6I"#;Fi	[	[	@<iSI"Ë      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.
      #;Fi[	@?iI"È      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[	@PioI"Á      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.
      #;Fi[	@Si|I"È      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[@I0I"#;FI"# @since 3.0.0;F@L0I"	self;Fi	[	[	@SiI"…      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@SiI"À      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@Si'I"»      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@Si?I"œ      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[I"&# @return [Array<Twitter::Tweet>];F@Û,I"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;FI"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi	[	[	@ˆ,iI"æ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user;Fi[	@ˆ,i]I"®      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@ˆ,irI"®      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@ˆ,iÑI"®      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[@I"var = @var["cw"];F@à-@â-@.i	[	[	@•i¨I"Ã    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@®ißI"Ã    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@´iõI"Ã    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@.iÑI"‘    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[@Û1@Ù1@ı1I"end;FI"end;Fi	[	[	@˘1iI"ˆ      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@¸1i I"˚      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@ˇ1i'I"˜      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@2iI"˜      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@÷0I"#;F@ÿ0@„0I"#;Fi	[	[	@_iI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@fiI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@miI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@piI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[@ı1I"end;FI"end;FI"end;FI"end;Fi	[	[	@˘1iI"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@¸1i"I"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@ˇ1i)I"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@2iI"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[I"=# @param [ Hash ] options The mongo persistence options.;FI"#;F@ó0I"#;FI"# @since 2.0.0;Fi	[	[	@ù0i!I"y      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        AddToSet.new(self, var, var, var).persist;Fi[	@ù0iJI"b      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Inc.new(self, var, var, var).persist;Fi[	@ù0i~I"h      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        PullAll.new(self, var, var, var).persist;Fi[	@ù0ièI"]      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Push.new(self, var, var, var).persist;Fi[@©@¥1I"end;FI"end;FI"end;Fi	[	[	@•iûI"•      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@®iôI"•      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@´içI"•      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@1iÇI"Ø        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell);Fi[@©@â4I"end;FI"end;FI" ;Fi	[	[	@ﬂiI"           render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id]);Fi[	@çiI"          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id);Fi[	@ÌiÅI"2    if params[:diaspora_handle] then
      Webfinger.in_background(params[:diaspora_handle], :single_aspect_form => (true))
      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id]);Fi[	@iII"Í      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first;Fi[@À6@Ã6@ó0@Õ6I"# @since 2.1.0;Fi	[	[	@ù0i^I"l      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pop.new(self, var, var, var).persist;Fi[	@ù0iqI"]      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pull.new(self, var, var, var).persist;Fi[	@ù0i†I"h      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        PushAll.new(self, var, var, var).persist;Fi[	@ù0i¬I"]      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Sets.new(self, var, var, var).persist;Fi[I"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;F@Â0@0@Ò0i	[	[	@_iI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@fiI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@miI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@piI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[@@ı1I"end;FI"end;FI"end;Fi	[	[	@˘1iI"Ô      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@¸1i!I"Ù      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@ˇ1i(I"      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@2iI"      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@'@(I"
false;FI"end;FI" ;Fi	[	[	@pi;I"‰    @var.each do |arglist|
      if ((var[-var.length, var.length] == var) or (var[-var.length, var.length] == var)) then
        return true
      end
    end
    false
  end
  
  ##
  # Forces reconnection of HTTP connections.;Fi[	@√i-I"          var.each do |arglist|
            var = File.join(var, (var + var))
            return true if File.executable?(var)
          end
        end
        false
      end
      
      def self.on_windows?(arglist)
        RUBY_PLATFORM =~ /mswin|mingw/;Fi[	@çiQI"ƒ          return options.skip_info.call(uid)
        else
          return true
        end
      end
      false
    end
    
    def function(arglist)
      self.env["omniauth.auth"] = auth_hash;Fi[	I">data//rescue_proj/resque/vendor/utf8_util/utf8_util_18.rb;Ti>I"i            var.pos -= 1
          end
        end
      end
    end
    false
  end
  
  private
  ;Fi[I"J# Binds the base object to the inverse of the relation. This is so we;FI"E# are referenced to the actual objects themselves on both sides.;FI"#;FI"G# This case sets the metadata on the inverse object as well as the;FI"# document itself.;Fi	[	[	@ˆi
I"ä    module Bindings
      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.;Fi[	@i
I"ä    module Bindings
      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.;Fi[	@i
I"å    module Bindings
      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.;Fi[	@$i
I"å    module Bindings
      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.;Fi[@Ã.@÷0I"#;F@ÿ0@„0i	[	[	@_iI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@fiI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@miI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@piI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[@¶-@ß-I"#     end;FI"#   end;FI"#;Fi	[	[	@iQI"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@içI"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@i—I"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@iÙI"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[@ß-I"#     end;FI"#   end;FI"#;FI"#   person = Person.new;Fi	[	[	@iRI"Ú      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob";Fi[	@iéI"Ù      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob";Fi[	@i“I"      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob";Fi[	@iıI"Ô      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true;Fi[@,@Ò,@Ú,@Û,@ç6i	[	[	@ˆ,iI"       # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ˆ,i[I"      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ˆ,ipI"0      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@ˆ,iÇI"0      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[@Ò,@Ú,@Û,@ç6@é6i	[	[	@ˆ,iI"ä      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ˆ,i\I"å      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ˆ,iqI"û      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@ˆ,iÉI"û      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[@&7I"#;F@(7@)7I"#;Fi	[	[	@ˆiI"®      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   name.person.bind(:continue => true);Fi[	@iI"®      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.name.bind(:continue => true);Fi[	@iI"™      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   game.person.bind(:continue => true);Fi[	@$iI"™      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.game.bind(:continue => true);Fi[I"3attr_accessor(:document, :relation, :metadata);FI" ;F@….@ .I"#;Fi	[	[	@_i	I"G  module Relations
    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@fi	I"H  module Relations
    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@mi	I"H  module Relations
    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@pi	I"I  module Relations
    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[@ .I"#;F@Ã.@÷0I"#;Fi	[	[	@_iI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@fiI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@miI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@piI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[@©@“(@”(@‘(I"end;Fi	[	[	@igI"∏    if user and user.blocks.where(:person_id => (person_id)).exists? then
      (errors[:base] << "Cannot connect to an ignored user")
      false
    else
      true
    end
  end
end;Fi[	@iaI"’  def function(arglist)
    if self.parent and self.parent.participants.include?(self.author).! then
      (errors[:base] << "Author is not participating in the conversation")
    else
      true
    end
  end
end;Fi[	@Í,iI"›        else
          if (var.rack.exist?.! or var.rack.children.empty?) then
            onoe("#{f} not installed")
          else
            true
          end
        end
      end
      exit(1) if var.empty?
    end;Fi[	@‘i I"`              if var.last then
                if [:attribute_nodes, :children].include?(var.first) then
                  var.last.empty?.!
                else
                  true
                end
              end
            end
            var.seplist(var) do |arglist|
              if [:attribute_nodes, :children].include?(var.first) then;Fi[@'@T@…!I"end;FI"end;Fi	[	[	@iZI"ƒ        
        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@iÇI"ù        def function(arglist)
          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@i=I"Õ          var = project.notified_users
          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@"iQI"÷        # Returns an array of watchers' email addresses
        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[@x-@y-@z-@{-I"S# @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi	[	[	@ˆ,iHI"O      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik;Fi[	@ˆ,i_I"h      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user;Fi[	@ˆ,itI"3      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@ˆ,iÜI"ñ      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.;Fi[@….@ .I"#;F@Ã.@÷0i	[	[	@_iI"n      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@fiI"o      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@miI"o      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@piI"p      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[I"assert_not_nil(var.head);FI"assert_nil(var.stable);FI"assert_nil(var.bottle);FI"assert_nil(var.devel);FI",assert_equal(var.head, var.active_spec);Fi[[	@ã
i≥I"&  
  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum);Fi[	@ã
i¬I".  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum);Fi[	@ã
i—I".  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum);Fi[@©@™@´I"	else;FI""";Fi[[	@OiI"&            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end;Fi[	@Oi3I"&            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end;Fi[	@OipI"‡            image_task(var, var, :label => (var))
          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end;Fi[@©@°@¢@£I"end;Ti[[	@Ái+I"ç        if (var - var).any? then
          ActiveSupport::Deprecation.warn("It looks like you are eager loading table(s) (one of: #{string_tables.join(", ")}) that are referenced in a string SQL snippet. For example: \n\n    Post.includes(:comments).where(\"comments.title = 'foo'\")\n\nCurrently, Active Record recognises the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:\n\n    Post.includes(:comments).where(\"comments.title = 'foo'\").references(:comments)\n\n")
          true
        else
          false
        end
      end
    end
    
    def function(arglist);Ti[	@°i?I"¯          if @var.key?(var) then
            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      
      # Access a named variable. If the value of the variable responds_to? :call,;Fi[	I"'data//compass_proj/compass/util.rb;TiI"i      true
    when String, Array then
      var.length.zero?
    else
      false
    end
  end
end;Fi[@I"+var = Twitter::API::Arguments.new(var);FI"Eunless (var.options[:user_id] or var.options[:screen_name]) then;FI"7merge_user!(var.options, (var.pop or screen_name));FI"end;Fi[[	I",data//twitter_proj/twitter/api/users.rb;Ti∞I"¯      #   @example Return the specified user's profile banner
      #     Twitter.profile_banner('sferik')
      #     Twitter.profile_banner(7505382)  # Same as above
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::ProfileBanner, :get, "/1.1/users/profile_banner.json", var.options)
      end;Fi[	@iI"ä      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::User, var, var, var.options)
      end;Fi[	@i_I"ã      # @param args [Array]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(var, var, var, var, var.options, var)
      end;Fi[@@·7I"&merge_list!(var.options, var.pop);FI"Lunless (var.options[:owner_id] or var.options[:owner_screen_name]) then;FI"8merge_owner!(var.options, (var.pop or screen_name));Fi[[	@iHI"      #     Twitter.list_timeline('sferik', 8863586)
      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::Tweet, :get, "/1.1/lists/statuses.json", var.options);Fi[	@iI"±      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options);Fi[	@iI"≤        object_from_response(Twitter::List, var, var, var.options)
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var);Fi[@I"9@var = Array(@var[:target_objects]).map do |arglist|;FI"%Twitter::Tweet.fetch_or_new(var);FI"end;FI"end;Fi[[	@ˇ1iI"6      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user;Fi[	I"/data//twitter_proj/twitter/action/reply.rb;TiI"=      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets;Fi[	@2iI"$      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user;Fi[@I"Rvar.class.state_machines.transitions(var, action).perform { |arglist| yield };FI"end;FI" ;F@®+i[[	@™iDI"U      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@≠i=I"U      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@∞iAI"U      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[@I"(action == :save);FI"end;FI" ;FI"6# Gets the db default for the machine's attribute;Fi[[	@™iI"o      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then;Fi[	@≠iI"+      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value;Fi[	@∞iI")      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default;Fi[@©I"var = "";FI".var = "L" unless var.to_s.index("L").nil?;FI"6var = (var + "R") unless var.to_s.index("R").nil?;FI"6var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[[	@•igI"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[	@®i\I"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[	@´iVI"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[@©I"	@var;FI"end;FI"end;FI" ;Fi[[	@Ã	iTI"ß        if var then
          @var = var
          @var = var
        else
          @var
        end
      end
      
      def function(arglist)
        (@var or {});Fi[	@Oi=I".        def function(arglist)
          if @var.nil? then
            File.exist?("./Gemfile") and gem_available?("bundler")
          else
            @var
          end
        end
        
        def function(arglist)
          (gem_available_new_rubygems?(var) or gem_available_old_rubygems?(var));Fi[	@9&iëI"Ù        else
          @var.call
        end
      else
        @var
      end
    end
    
    # Determines whether this state matches the given value.  If no matcher is
    # configured, then this will check whether the values are equivalent.;Fi[@©I"&if list_of_color_stops?(var) then;FI"var = (var.value + var);FI"var = nil;FI"end;Fi[[	@ri˙I"Û      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@riI"Û      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@riI"Û      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[@©I"clean_url(var);FI"end;FI"end;FI"end;Fi[[	@éi(I"Œ      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl;Fi[	@éiAI"√      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl;Fi[	@éitI"      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl;Fi[@I"#if (action_hook == :save) then;FI"Gowner_class.set_callback(:save, :around, self, :prepend => (true));FI"	else;FI"
super;Fi[[	@™i;I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@≠i4I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@∞i8I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[@©I"/render(:nothing => (true), :status => 404);FI"end;FI"end;FI" ;Fi[[	@
i4I"6    if var.present? then
      var = OEmbedPresenter.new(var, params.slice(:format, :maxheight, :minheight))
      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).newer(@var);Fi[	@ˆi#I"2    @var = Person.find_by_guid_and_closed_account(params[:guid], false)
    if @var.present? and @var.local? then
      render("publics/hcard")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    render("host_meta", :content_type => "application/xrd+xml");Fi[	@êiïI"¯    var = User.find_by_username(var)
    if var.present? then
      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    if current_user.confirm_email(params[:token]) then;Fi[@©I"%super(absolutify_local_url(var));FI"end;FI"end;FI" ;Fi[[	@ipI"Â    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "");Fi[	@iyI"Â    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "");Fi[	@i}I"    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["month", "day"].all? { |arglist| var[var].present? } then;Fi[@©I"return super(var);FI"end;FI"end;FI" ;Fi[[	@•i9I"∂  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[	@®i)I"∏  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[	@´i(I"∂  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[@©I"var = (var + 1000);FI"var = (var + 2);FI"end;FI"end;Fi[[	@•iHI"€      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[	@®i<I"Ê        if (var >= 161) and (var <= 223) then
          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000);Fi[	@´i7I"€      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[@©I"-super(var, var, var, var, var, var, var);FI"end;FI"end;FI" ;Fi[[	@•iSI"‚  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[	@®iHI"‰  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[	@´iBI"‚  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[@©I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);F@√%I"end;FI"var = -1;Fi[[	@•iâI"s        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@®iÉI"e        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@´i}I"s        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[@©@.I"@var = var;F@≤1I"	else;Fi[[	@•iöI"Í    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@®iïI"Í    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@´iâI"Í    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[@@M8I"Iowner_class.set_callback(:save, :after, "value", :prepend => (true));FI"end;FI"
super;Fi[[	@˝igI"S        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[	@
iOI"K        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[	@iI"p        def function(arglist)
          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[@©I"super(var, var, var, var);FI"end;FI"end;FI" ;Fi[[	@•ißI"∆  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"];Fi[	@®i¢I"»  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"];Fi[	@´iñI"∆  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"];Fi[@©I">Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);FI"6var = (var[var].chr == " ") ? ((var + 1)) : (var);FI"end;FI"var = -1;Fi[[	@•i◊I"W          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@®iﬂI"I          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@´i∆I"W          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[@©I"var = var["name"];FI"out(("/BaseFont /" + var));FI"$if (var["type"] == "core") then;FI"out("/Subtype /Type1");Fi[[	@•iI"T      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[	@®iI"T      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[	@´i˝I"T      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[@©I"&out(("/Subtype /" + var["type"]));FI"out("/FirstChar 32");FI"out("/LastChar 255");FI".out((("/Widths " + (@var + 1)) + " 0 R"));Fi[[	@•iI"}          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[	@®iI"}          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[	@´iI"}          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[@©I"&out("/Encoding /WinAnsiEncoding");FI"end;FI"end;FI"end;Fi[[	@•iI"          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[	@®i(I"          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[	@´iI"          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[I"protected;FI" ;FI"B# Only runs validations on the action if using <tt>:save</tt>;FI"def function(arglist);F@8i[[	@™iI"¿        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@≠iI"‘        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@∞iI"¿        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[@&@Ò&@WI"# do nothing;FI"end;Fi[[	@ficI"£          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@1iEI"µ      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@⁄iI"é          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[@&@Ò&@WI"var = @var;F@æ/i[[	@•iÌI"À    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[	@®iˆI"À    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[	@´i‹I"À    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[@&@Ò&@-&I" ;FI"def function(arglist);Fi[[	@g	iPI"ª        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("database" => (nil))
      end;Fi[	@l	iFI"        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["encoding"] or DEFAULT_ENCODING)
      end;Fi[	@∑	iTI"       to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("#{transport} #{operation} #{from} -> #{to}") if logger
      @var = sessions.map do |arglist|;Fi[@I"var = max_value;FI"var = min_value;FI"var = (var - var);FI"-var = (var == 0) ? (10) : ((var / 20.0));Fi[[	@qiI"        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@tiI"      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@£iQI"        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[@&@Ò&@}0@~0I"# @param args [Array];Fi[[	@iˇI"!        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[	@-i˝I"’        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>]
      def function(arglist);Fi[	@iI"È    module Utils
      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[I"var = nil;FI"	else;F@58@68I"var = nil;Fi[[	@ri˘I"‰    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@riI"Û      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@riI"‰    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[@I"@var[:fields];FI"end;FI" ;FI"def function(arglist);Fi[[	@qiI"¨      
      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value;Fi[	@ti$I"°        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        (var / -2.0)
      end;Fi[	@£iGI"“        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super
        var = (((@var[:fields][0].length / 2) * font_size) * 0.6);Fi[@z@{@|@ÒI"# :nodoc:;Fi[[	@’i,I"À  def function(arglist)
    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist)
    if File.exist?("spec/spec.opts") then;Fi[	@¥ióI"©        when Proc then
          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["SPEC"] then;Fi[	@i*I"“        when Symbol then
          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= mock_framework_path("rspec");Fi[@I"Jif (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then;F@ò4I"	else;F@ö4i[[	@.iI"5    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[	@.i"I"5    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[	@1i I"k  	# @since 1.3
  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[@I"out("/Subtype /Type0");FI"?out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));FI"'out(("/Encoding /" + var["CMap"]));F@Ü3i[[	@•i=I"    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[	@®iFI"    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[	@´i,I"    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[@I",AddCIDFont(var, "", var, var, var, var);FI"9AddCIDFont(var, "B", (var + ",Bold"), var, var, var);FI";AddCIDFont(var, "I", (var + ",Italic"), var, var, var);FI"@AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[[	@•iI"ù    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[	@®iI"ù    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[	@´iI"ù    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[@I"J"#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";FI"end;FI"end;FI"end;Fi[[	@ë.iI"«      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ó.iI"«      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ö.iI"ª        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[@I" var = [var.first, var.last];FI"var;FI"end;FI" ;Fi[[	@JiÿI"π        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@Ji›I"π        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@Ji‚I"≠        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted
      # reduce 42 omitted;Fi[@I"/var = Node.new(:CONDITIONAL_SELECTOR, var);FI"var;FI"end;FI" ;Fi[[	@JijI"æ        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      # reduce 13 omitted
      def function(arglist);Fi[	@JipI"Â      end
      
      # reduce 13 omitted
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var);Fi[	@JiuI"        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [Node.new(:ELEMENT_NAME, ["*"]), Node.new(:COMBINATOR, var)]);Fi[@I"$return image_url if (var == "");FI"4if (var.nil? or var.match(/^https?:\/\//)) then;FI"super(var);FI"	else;Fi[[	@ilI"	    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@iuI"…    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@i~I"…    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[@z@{@@d,@|9i[[	@Ji’I"⁄      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[	@Ji⁄I"π      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[	@JiﬂI"π      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[@z@{@@d,I"%var = Node.new(:COMBINATOR, var);Fi[[	@Ji*I"÷      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@Ji/I"√      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@Ji4I"√      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[@z@{@I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;Fi[[	@PikI"          var = (var[var] or var[var.to_i])
          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@Si¯I"Ò        #
        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@hi3I"5          if Mongoid::Config.use_activesupport_time_zone? then
            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[@zI"	else;FI"var;FI"end;FI"end;Fi[[	@?iWI"ˆ            (var.attribute_names.&(var.attribute_names) - var.changes.keys).each do |arglist|
              var[var] = var[var]
            end
            var
          else
            var
          end
        end
        (var + var)
      end;Fi[	@≥i;I"£              (var << "(#{limit})")
            end
          end
          var
        else
          var
        end
      end
      
      def function(arglist);Fi[	@∑	iÆI"¨          var = var.pos
          var = StringIO.new(var.read)
          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    ;Fi[@I"+self.author = Webfinger.new(var).fetch;FI"end;FI" ;FI"def function(arglist);Fi[[	@>
i;I"„    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then
      return Notifications::CommentOnPost;Fi[	@ai.I"ú    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end;Fi[	@i3I"≠    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid
  end;Fi[@I" self.author.diaspora_handle;FI"end;FI" ;FI"def function(arglist);Fi[[	@>
i7I"  after_destroy { |arglist| self.parent.update_comments_counter }
  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[	@ai*I"∫    (self.participants - [self.author])
  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[	@i/I"«  
  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[@I"broadcast(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@àiI"Ê        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ài&I"Ã        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@àikI"Ã        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[@F@G@H@II":# Runs state events around the machine's :save action;Fi[[	@™i?I"[        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@≠i8I"[        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@∞i<I"[        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[@I"@var.accept_hook?(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@¥iCI"“        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init
        var = @var.index(var);Fi[	@3i!I"ß        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags
      end;Fi[	@3iÉI"π          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end;Fi[@I""";FI"end;FI" ;FI"def function(arglist);Fi[[	@ái>I"k    # do nothing
  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end;Fi[	@íiI"      # do nothing
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end;Fi[	@íiI"t      ""
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end;Fi[@FI"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@?i%I"—      end
      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist)
        if block_given? then
          load_target.select.each { |arglist| yield(var) };Fi[	@◊iI"‚        INDENT = "  "
        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super
          var.nested_descriptions.each_with_index do |arglist|;Fi[	@›iI"Û    module Formatter
      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          @var.puts("Profiling enabled.")
        end;Fi[@I"	name;FI"end;FI" ;FI"def function(arglist);Fi[[	@†2iI"ï  
  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var
    when Post then;Fi[	@£2i%I"∂    @@var
  end
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[	@¶2iI"ﬂclass Category < ActiveRecord::Base
  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[@I"(@var or @var);FI"end;FI" ;FI"def function(arglist);Fi[[	@8i«I"∫        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        options["revision"]
      end;Fi[	@3iáI"¿          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end;Fi[	@SiI"Ü    class GherkinBuilder
      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("\n")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, [])
        @var.gherkin_statement(var);Fi[@I"var = case var;F@˙-I""Success";FI"when :warning then;Fi[[	@ﬂi/I"H      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[	@•i-I"H      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[	@´i+I"H      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[@I"binding;FI"end;FI"end;FI"end;Fi[[	I"'data//backup_proj/backup/binder.rb;TiI"ù    
    ##
    # Returns the binding (needs a wrapper method because #binding is a private method)
    def function(arglist)
      binding
    end
  end
end;Fi[	@Ã	iÑI"i        end
      end
      
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	I":data//compass_proj/compass/sprite_importer/binding.rb;Ti	I"Ümodule Compass
  module Sprites
    class Binding < OpenStruct
      def function(arglist)
        binding
      end
    end
  end
end;Fi[@nI"	else;FI"	true;FI"end;FI"end;Fi[[	@áitI"Ÿ        when :destroy then
          inverse_updates_counter_cache?(through_reflection).!
        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist);Fi[	@]iπI"È        else
          if ["false", "FALSE", "f", "F", false].include?(peek) then
            shift
            false
          else
            true
          end
        end
      else
        (@var.key?(var) or no_or_skip?(var).!);Fi[	@ifI"–  def function(arglist)
    if user and user.blocks.where(:person_id => (person_id)).exists? then
      (errors[:base] << "Cannot connect to an ignored user")
      false
    else
      true
    end
  end
end;Fi[@I"var = 0;FI"var = @var["cw"];FI"var = var.length;FI"var = 0;Fi[[	@•i>I"ƒ    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@®i.I"ƒ    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@´i-I"ƒ    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[@I"?execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");FI"end;FI" ;FI"def function(arglist);Fi[[	@∂i&I"        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@êiπI"0          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end;Fi[	@£i8I"        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end;Fi[@I"3execute("SAVEPOINT #{current_savepoint_name}");FI"end;FI" ;FI"def function(arglist);Fi[[	@∂i"I"È        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@êiµI"+          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end;Fi[	@£i4I"ˇ        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end;Fi[@n@o@p@é#I" ;Ti[[	@Ái,I"ä          ActiveSupport::Deprecation.warn("It looks like you are eager loading table(s) (one of: #{string_tables.join(", ")}) that are referenced in a string SQL snippet. For example: \n\n    Post.includes(:comments).where(\"comments.title = 'foo'\")\n\nCurrently, Active Record recognises the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:\n\n    Post.includes(:comments).where(\"comments.title = 'foo'\").references(:comments)\n\n")
          true
        else
          false
        end
      end
    end
    
    def function(arglist)
      return [] if var.blank?;Ti[	@°i@I"&            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      
      # Access a named variable. If the value of the variable responds_to? :call,
      # #call will be invoked (without parameters) and the return value cached;Fi[	@"i,I"Â          begin
            instance_exec(var, &@var)
          rescue Spec::Expectations::ExpectationNotMetError
            false
          end
        end
      end
      
      # See Spec::Matchers
      def function(arglist);Fi[@@9+I"@var = var;FI"end;FI"end;Fi[[	@$'i-I"›  class WrappedDatabaseException < StatementInvalid
    attr_reader(:original_exception)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class RecordNotUnique < WrappedDatabaseException;Fi[	I""data//haml_proj/haml/error.rb;TiI"◊    # @return [Fixnum]
    # @param message [String] The error message
    # @param line [Fixnum] See \{#line}
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class SyntaxError < Error;Fi[	@¡i6I"Ω  class InstallationError < RuntimeError
    attr(:formula)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
end
class CannotInstallFormulaError < RuntimeError;Fi[@@#@$@%I"end;Fi[[	@iI"Q      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[	@“i©I"ì      # @return [ Object ] The serialized default.
      #
      # @since 3.0.0
      def function(arglist)
        var
      end
    end
  end
end;Fi[	I"Cdata//paperclip_proj/paperclip/io_adapters/identity_adapter.rb;TiI"Âmodule Paperclip
  class IdentityAdapter < AbstractAdapter
    def function(arglist)
      var
    end
  end
end
Paperclip.io_adapters.register(Paperclip::IdentityAdapter.new) do |arglist|
  Paperclip.io_adapters.registered?(var);Fi[@õ@ú@ÇI"private;FI" ;Fi[[	@Mi‡I"≈    
    def function(arglist)
      var.send(:rules).each { |arglist| (rules << var.dup) }
      self
    end
    
    private
    
    def function(arglist)
      unless var.kind_of?(Symbol) then;Fi[	I"*data//diaspora_proj/models/request.rb;TiUI"    if var.auto_follow_back and var.receiving.! then
      var.share_with(var, var.auto_follow_back_aspect)
    end
    self
  end
  
  private
  
  # Checks if a [Contact] does not already exist between the requesting [User] and receiving [Person]
  def function(arglist);Fi[	@ÁiI""      IdentityMap.set(self)
      run_callbacks(:find) unless _find_callbacks.empty?
      run_callbacks(:initialize) unless _initialize_callbacks.empty?
      self
    end
    
    private
    
    # Reload the document, determining if it's embedded or not and what
    # behaviour to use.;Fi[@I"@var.clear;FI"end;FI" ;FI"def function(arglist);Fi[[	@ØiƒI"¨        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@Øi»I"ú        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@ØiÃI"§        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var
          self;Fi[@@p4I"var = @var;FI"var = @var["cw"];F@ç2i[[	@•iXI"÷    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@®iMI"÷    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@´iGI"÷    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[@@÷@◊@*I" ;Fi[[	@0	iqI"¶        false
      end
      
      def function(arglist)
        true
      end
    end
    
    class RealTransaction < OpenTransaction
      def function(arglist);Fi[	@<ixI"ç  end
  
  class HiddenTask < Task
    def function(arglist)
      true
    end
  end
  
  class DynamicTask < Task
    def function(arglist);Fi[	@TiI"ˆ    module Adapters
      class FilesystemAdapter < AbstractAdapter
        class << self
          def function(arglist)
            true
          end
        end
        
        def function(arglist)
          @var = with_trailling_slash(var);Fi[I"
begin;FI"!var = (var + var.iconv(var));FI""rescue Iconv::IllegalSequence;FI"var = (var + $!.success);FI"1var = ("?" + $!.failed[1, $!.failed.length]);Fi[[	@:iI"-        else
          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@:i>I")        else
          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@:i|I")        else
          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[@@‘3I" @var = file_name.underscore;FI" @var = plugin_name.titleize;FI"$@var = "plugins/#{plugin_name}";Fi[[	I"Mdata//redmine_proj/generators/redmine_plugin/redmine_plugin_generator.rb;Ti
I"”  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
  end
  ;Fi[	I"cdata//redmine_proj/generators/redmine_plugin_controller/redmine_plugin_controller_generator.rb;TiI"Ô  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = controller.camelize
  end;Fi[	I"Ydata//redmine_proj/generators/redmine_plugin_model/redmine_plugin_model_generator.rb;TiI"˝  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = model.camelize
    @var = @var.tableize;Fi[@@@$@ I"var;Fi[[	@5	iI"ã      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      ;Fi[	@ÉiÈI"¬      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[	@6iI"ø      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[@@@$@ I"
false;Fi[[	@>i<I"    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end;Fi[	@JiI"~    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@_i6I"Á      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      ;Fi[@@‘3I"@var = [];FI"end;FI" ;Fi[[	@?i$I"Â        replace(klass.find(var).index_by { |arglist| var.id }.values_at(*var))
      end
      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist)
        if block_given? then;Fi[	@◊iI"◊      class NestedTextFormatter < BaseTextFormatter
        INDENT = "  "
        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super;Fi[	@›i
I"˜  module Runner
    module Formatter
      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          @var.puts("Profiling enabled.");Fi[@@‘3I"@var = false;FI"end;FI" ;Fi[[	@t)iI"ù        self.target = var
      end
      
      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function
      ;Fi[	I"<data//activerecord_proj/active_record/log_subscriber.rb;TiI"à      var
    end
    
    def function(arglist)
      super
      @var = false
    end
    
    def function(arglist)
      if var then;Fi[	@ii◊I"Ÿ    end
    
    # Resets callback tracking
    def function(arglist)
      super
      @var = false
    end
    
    # Resets the event attribute so it can be re-evaluated if attempted again
    def function(arglist);Fi[@@∞@±I"end;FI" ;Fi[[	@0	i
I"«    class Transaction
      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    
    class ClosedTransaction < Transaction
      def function(arglist);Fi[	@$'ibI"⁄  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  
  class UnknownPrimaryKey < ActiveRecordError
    attr_reader(:model);Fi[	@biI"Î        
        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      
      # Remembers the given resource by setting up a cookie
      def function(arglist);Fi[@@∞@±@≤I"private;Fi[[	@!iBI"~      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist);Fi[	@4i'I"
    # Because Rubyforge cannot be trusted to provide valid specifications
    # once the remote gem is downloaded, the backend specification will
    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist);Fi[	@I#i!I"∫    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    
    # Gets the default Mongoid logger - stdout.;Fi[@Ù@ıI"A# @param [ Array ] args The names of the fields to validate.;FI"#;FI"# @since 2.4.0;Fi[[	@ä%iéI"I      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::FormatValidator, _merge_attributes(var));Fi[	@ä%iüI"=      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::LengthValidator, _merge_attributes(var));Fi[	@ä%i∞I"      #     field :title
      #
      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var));Fi[@@I"	else;FI""";FI"end;Fi[[	@OiI"Ÿ          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[	@Oi4I"Ÿ          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[	@OiqI"µ          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[@@I"var;FI"end;FI" ;Fi[[	@?i0I"–            var = $stderr
            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        
        def self.wrap(arglist)
          validate_pipe(var);Fi[	@iKI"·          var[:list_id] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      
      # Take an owner and merge it into the hash with the correct key
      #;Fi[	@iíI"        when Twitter::User then
          var[[var, "user_id"].compact.join("_").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      
      # Take a multiple users and merge them into the hash with the correct keys
      #;Fi[@Ù@ı@®5I"#;FI"# @since 2.1.0;Fi[[	@•i2I"Ù      # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@•iQI"˜      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@•i™I"
        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin;Fi[@+@,@-@.I"##;Fi[[	@ﬂicI"        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##
        # Wrapper method for the #send_message (private) method
        def function(arglist);Fi[	@±i
I"    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##
    # This is called as part of the procedure used to build the final
    # backup package file(s). It yields it's portion of the command line;Fi[	@¥iI"ı      # * Called with super(model, storage_id) from each subclass
      def function(arglist)
        load_defaults!
        @var = var
        @var = var
      end
      
      ##
      # Performs the backup transfer
      def function(arglist);Fi[@+@,@-I"end;FI" ;Fi[[	@$'iAI"€    
    def function(arglist)
      super("Attempted to #{attempted_action} a stale object: #{record.class.name}")
      @var = var
      @var = var
    end
  end
  
  class ConfigurationError < ActiveRecordError
  end;Fi[	@$'iZI"∂    
    def function(arglist)
      super(var)
      @var = var
      @var = var
    end
  end
  
  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors);Fi[	@áiI"Í        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      
      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError
        attr_reader(:errors);Fi[@Ù@ıI"-# @return [ Enumerator ] The enumerator.;FI"#;FI"# @since 3.0.0;Fi[[	@.i"I"*      # @example Iterate over the results.
      #   map_reduce.each do |doc|
      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        block_given? ? (documents.each { |arglist| yield(var) }) : (to_enum);Fi[	@iaI"ˇ      # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then;Fi[	@iqI"ˇ      # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then;Fi[@(I"&#     validates_presence_of :name;FI"#   end;FI"#;FI"#   person = Person.new;Fi[[	@«(iΩI"?    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false
    #   person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:["can't be blank"]}>;Fi[	@«(iŒI"Ò    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.valid? # => false;Fi[	@«(iıI"Ú    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.invalid? # => true;Fi[@+2@¿(I"#;F@¬(@b;i[[	@«(i∫I"    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@«(iÀI"    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@«(iÚI"    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[@°I"# @note Undocumented;FI"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	I"3data//twitter_proj/twitter/api/undocumented.rb;TiI"à      include(Twitter::API::Utils)
      
      # Returns activity about me
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.;Fi[	@};iMI"o      end
      
      # Returns activity summary for a Tweet
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.;Fi[	@};i`I"ù      (alias :tweet_activity :status_activity)
      
      # Returns activity summary for Tweets
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.
      # @overload statuses_activity(*ids);Fi[@°I"K# @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline;FI"<# @note This method can only return up to 3,200 Tweets.;FI"# @rate_limited Yes;FI",# @authentication Requires user context;Fi[[	@ˆ,i'I"‰      (alias :mentions :mentions_timeline)
      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@ˆ,i?I"≈      end
      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@ˆ,iWI"Ô      (alias :retweeted_by :retweeted_by_user)
      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[@+@)@*@/I"@var = nil;Fi[[	@¢itI"ö      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
        @var = 4
      end;Fi[	@¢i®I"∂      
      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@•i2I"ê      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[@°I"E# @see https://dev.twitter.com/docs/api/1.1/get/friendships/show;FI"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	I"<data//twitter_proj/twitter/api/friends_and_followers.rb;TiŒI"˝      end
      
      # Returns detailed information about the relationship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship]
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;Fi[	@ü;iÏI".      (alias :relationship :friendship)
      
      # Test for the existence of friendship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if user_a follows user_b, otherwise false.
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;Fi[	@ü;iI"Ê      end
      
      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={});Fi[@°@Û1@Ù1I"S@var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) };FI"end;Fi[[	@˘1iI"^      attr_reader(:max_position, :min_position, :target_objects)
      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection containing the followed user;Fi[	@¸1iI"S      attr_reader(:max_position, :min_position)
      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection of lists that were added to;Fi[	@ˇ1iI"B      attr_reader(:max_position, :min_position)
      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # The user who mentioned a user;Fi[@°@å6I"def function(arglist);FI"9@var = Array(@var[:target_objects]).map do |arglist|;F@˙7i[[	@ˇ1iI"      end
      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[	@8i
I"6  module Action
    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[	@2i
I"%  module Action
    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[@+I"@var = nil;FI"end;FI" ;FI"def function(arglist);Fi[[	@1iI"‹      @var = var
      @var = []
      @var = var
      @var = var
      @var = nil
    end
    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "#{@name}-#{@version}";Fi[	@9iI"º      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil
      end
      
      def function(arglist)
        begin
          (trap_interrupt;Fi[	@≤i$I"¿        @var = []
        @var = nil
        @var = false
        @var = var
        @var = nil
      end
      
      def function(arglist)
        var = clone
        var.expected_from = var;Fi[@+I"reconnect_ssl;FI"end;FI" ;FI"##;Fi[[	@pi
I"Ã  ##
  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.;Fi[	@piI"'  # Overrides the default SSL certificate store used for verifying
  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Finishes all connections on the given +thread+ that were created before
  # the given +generation+ in the threads +generation_key+ list.;Fi[	@piÁI"Ù  # Securely transfer the correct certificate and update the default
  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # SSL verification callback.
  def function(arglist);Fi[@°I"#     property :id, Serial;FI"##     property :state, :String;FI"#;F@Ã1i[[	@ iI";        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@ iTI";        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@ ixI";        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[@°I"#       event :park do;FI",#         transition :idling => :parked;FI"#       end;FI"#     end;Fi[[	@¬iEI"%    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do;Fi[	@¬iwI")    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do;Fi[	@ú%i¢I"ﬂ    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end
    #   ;Fi[@°@§1I"'#     include DataMapper::Resource;FI"#;F@“;i[[	@ iI"!        # information about the various configuration options available.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@ iQI"        # as the given requirements match the transition.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@ iuI"&        # be performed so long as the given requirements match the transition.
        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[@Ä)I"svar = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));FI"end;FI"out((var + ">>"));FI"out("endobj");Fi[[	@•i3I"I            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[	@®i<I"I            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[	@´i"I"I            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[I"var = [];FI"5var = ((var % var) == 0) ? (var) : ((var + var));FI"2var.step(var, var) { |arglist| (var << var) };FI"return var;FI"end;Fi[[	@qi!I"O        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@tiI"O        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@£iYI"O        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[I"when Proc then;FI"var.call;FI"	else;FI"var;FI"end;Fi[[	@]ijI"Ω      case var
      when Symbol then
        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end
  end;Fi[	@≤i´I"9        var = case var
        when Symbol then
          send(var)
        when Proc then
          var.call
        else
          var
        end
        if var and (var.size > var) then
          raise(TooManyRecords, "Maximum #{limit} records are allowed. Got #{attributes_collection.size} records instead.");Fi[	@¥iîI"ï      
      def function(arglist)
        case var
        when Proc then
          var.call
        else
          var
        end
      end
      ;Fi[@°@§1@ç%I"!#       other_states :idling;FI"#     end;Fi[[	@-iI"æ    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@-i(I"ÿ    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@-iCI"∂    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[@°@§1@ç%I"#       event :ignite do;FI",#         transition :parked => :idling;Fi[[	@¬i?I"    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@¬iqI"    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@⁄i˚I"     # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[@°I"!# Valid requirement options:;FI"N# * <tt>:from</tt> - One or more states being transitioned from.  If none;FI"E#   are specified, then this will be the object's current state.;FI"N# * <tt>:to</tt> - One or more states being transitioned to.  If none are;Fi[[	I"4data//state_machine_proj/state_machine/event.rb;Ti|I"$    
    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless;Fi[	@˛iI"›    end
    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[	@˛i1I"‡    end
    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[@d!I"3# Creates a new instance of the storage object;FI"def function(arglist);FI"super(var, var);FI"@var ||= "backups";Fi[[	@ËiI"0      #   :dropbox (full access)
      ##
      # Path to where the backups will be stored
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        @var ||= :app_folder
        instance_eval(&var) if block_given?;Fi[	@ÛiI"      # Ninefold Credentials
      ##
      # Ninefold directory path
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end;Fi[	@ˆiI"      # Amazon S3 bucket name and path
      ##
      # Region of the specified S3 bucket
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end;Fi[@d!@:<@;<@<<I"@var ||= 22;Fi[[	@¡iI"      # Path to store backups to
      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        @var ||= false;Fi[	@˘iI"      # Server IP Address and SCP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?;Fi[	@¸iI"      # Server IP Address and SFTP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?;Fi[@°I"# == Example;FI"#;FI"#   class Vehicle;FI"/#     state_machine :initial => :parked do;Fi[[	@¬i=I"z    # On the other hand, any <tt>:halt</tt> error that's thrown within an
    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@¬ioI"?    # a StateMachine::InvalidTransition exception will be raised.
    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@⁄i˘I"6    
    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[@d!@.0@/0I" var = remote_path_for(@var);FI"connection do |arglist|;Fi[[	@Îi8I""        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[	@˘i,I",        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("mkdir -p '#{remote_path}'")
          files_to_transfer_for(@var) do |arglist|;Fi[	@¸i*I""        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[I"+#     include ActiveModel::Validations;FI"#;F@¬(@b;I"#   end;Fi[[	@«(iªI"”    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@«(iÃI"‹    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@«(iÛI"›    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[I"#       end;FI"#     end;FI"#   end;FI"#;FI"#   class VehicleObserver;Fi[[	@ iI""        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@ i[I""        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@ iI"=        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|
        #       # log failure;Fi[@p<I"#;F@›;@ﬁ;I"#       end;Fi[[	@¬iDI"    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@¬ivI"    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@ú%i°I"    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end;Fi[@"@Ú0I"end;FI" ;FI"L# Execute the cascading deletion for the relation if it already exists.;Fi[[	@_iI"m        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@fiI"m        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@piI"m        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[@°I"/#    it "should do small edition stuff" do;FI"#      ...;FI"#    end;FI"#  end;Fi[[	@Äi1I"Ù      #
      #  describe SmallEdition do
      #    it_should_behave_like "All Editions"
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist)
        add_options(var);Fi[	@ÄiFI"      #
      #  describe SmallEdition do
      #    it_should_behave_like AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      #
      # And, for those of you who prefer to use something more like Ruby, you;Fi[	@ÄiQI"      #
      #  describe SmallEdition do
      #    include AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist)
        Spec.deprecate("share_as", "shared_examples_for");Fi[@O'@P'@Q'@R'I" ;Fi[[	@	i=I"›          begin
            Kernel.Float(var)
          rescue ArgumentError, TypeError
            nil
          end
        end
      end
      
      def function(arglist)
        var.to_i if var.to_s =~ /\A[+-]?\d+\Z/;Fi[	@∂i!I"            var = $1.split(",").map { |arglist| var.delete("`\"") }
            (var.length == 1) ? ([var.first, nil]) : (nil)
          else
            nil
          end
        end
      end
      
      # Returns just a table's primary key
      def function(arglist);Fi[	@_"irI"I          if base.respond_to?(var, true) then
            raise(Thor::PrivateMethodEncodedError, "Method #{base.class}##{sym} should be public, not private")
          else
            nil
          end
        end
      end
      
      # Receives a hash of options and just execute the block if some
      # conditions are met.;Fi[@°@;I"#;FI"# @since 2.4.0;FI"def function(arglist);Fi[[	@ä%ièI":      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::FormatValidator, _merge_attributes(var))
      end;Fi[	@ä%i†I".      #
      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::LengthValidator, _merge_attributes(var))
      end;Fi[	@ä%i±I"      #
      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end;Fi[@°@®5I"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	@•i3I"ˆ      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("bind");Fi[	@•iRI"˘      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("build");Fi[	@•i´I"        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("create");Fi[@°I"0# @return [ Hash ] The reloaded attributes.;FI"#;FI"# @since 2.3.2;FI"def function(arglist);Fi[[	@Ái)I"˘    #
    # @example Reload the document.
    #   document._reload
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      embedded? ? (reload_embedded_document) : (reload_root_document)
    end;Fi[	@Ái5I"    #
    # @example Reload the document.
    #   document.reload_root_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      {}.merge((with(:consistency => :strong).collection.find(:_id => (id)).one or {}))
    end;Fi[	@ÁiAI"=    #
    # @example Reload the document.
    #   document.reload_embedded_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      extract_embedded_attributes({}.merge(_root.with(:consistency => :strong).collection.find(:_id => (_root.id)).one))
    end;Fi[@$1@%1@&1@'1I"^#   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[[	@«(i*I"      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@«(idI"      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@Â&i*I"      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[@%1@&1@'1@…<I"L#   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[[	@«(i+I"Ê      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@«(ieI"Ê      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@Â&i+I"Ω      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[@&1@'1@…<@“<I"P#   method, proc or string should return or evaluate to a +true+ or +false+;Fi[[	@«(i,I"π      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@«(ifI"π      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@Â&i,I"π      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[I"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;F@…<@“<@€<I"#   value.;Fi[[	@«(i-I"≠      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var);Fi[	@«(igI"ã      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!;Fi[	@Â&i-I"¨      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var));Fi[@…<@“<@€<I"#   value.;FI"def function(arglist);Fi[[	@«(i.I"h      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var)
      end;Fi[	@«(ihI"Z      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!
        if var.key?(:on) then;Fi[	@Â&i.I"g      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var))
      end;Fi[I"(var << var);FI"end;FI"end;FI"end;FI"end;Fi[[	@≥i$I"Î          else
            if (var < var) then
              execute("INSERT INTO #{sm_table} (version) VALUES ('#{v}')")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist);Fi[	@öiªI"◊      def function(arglist)
        if self.class.current_feature then
          var = self.class.recipes_per_feature[self.class.current_feature] ||= []
          (var << var)
        end
      end
    end
  end
end;Fi[	@eiTI"-                    var = true
                  end
                else
                  (var << var)
                end
              end
            end
          end
          var = [var.strip, var.strip, var.strip]
          var.each { |arglist| smooth_offtags_without_code_highlighting(var) };Fi[@°I"#   class Game;FI"$#     include Mongoid::Document;FI"#     belongs_to :person;FI"#   end;Fi[[	@ài|I"¯        # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person;Fi[	@àiïI"        #     include Mongoid::Document
        #     has_many :posts
        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.;Fi[	@ài I"¯        # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person;Fi[@‡I":#   #      #<Pet id: 2, name: "Spook", person_id: 1>,;TI"=#   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];TI"#;Ti[[	@ÁiLI"J      # Array#select.
      #
      #   person.pets.select { |pet| pet.name =~ /oo/ }
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name) { |pet| pet.name =~ /oo/ }
      #   # => [;Ti[	@Ái£I"Ö      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #
      #   person.pets.last(2)
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   another_person_without.pets         # => []
      #   another_person_without.pets.last    # => nil;Ti[	@Ái◊I"v      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #
      #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 3
      #   person.pets.count # => 3;Ti[@°I"+# @return [ Array<Hash> ] The inserts.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@ÉiI"1        #   batchable.batch_insert([ doc_one, doc_two ])
        #
        # @param [ Array<Document> ] docs The docs to add.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          execute_batch_insert(var, "$pushAll")
        end;Fi[	@ÉiEI"a        #   batchable.batch_replace([ doc_one, doc_two ])
        #
        # @param [ Array<Document> ] docs The docs to replace with.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          if var.blank? then
            base.add_atomic_unset(first) if _assigning? and empty?.!;Fi[	@ÉitI"N        #
        # @param [ Array<Document> ] docs The docs to persist.
        # @param [ String ] operation The atomic operation.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          self.inserts_valid = true
          var = pre_process_batch_insert(var);Fi[@°I"N# @option options [ true, false ] :continue Continue binding the inverse.;FI"E# @option options [ true, false ] :binding Are we in build mode?;FI"#;FI"# @since 2.0.0.rc.1;Fi[[	@ˆiI"≥          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata;Fi[	@ˇiI"ö          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base);Fi[	@ˇi&I"∆          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) };Fi[I"#   #    ];FI"#;TI"#   person.pets.delete_all;TI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[[	@ÁiBI"       #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁicI"       #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái|I"       #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@°I"&# @return [ Proxy ] The relation.;FI"#;FI"# @since 2.0.0.rc.1;FI"def function(arglist);Fi[[	@iI"ç      # @param [ Hash, Moped::BSON::ObjectId ] object The id or attributes to use.
      # @param [ Metadata ] metadata The relation's metadata.
      # @param [ true, false ] building If we are in a build operation.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = create_relation(var, var)
        set_relation(var, var);Fi[	@i$I"N      #
      # @param [ Document, Array<Document ] object The relation target.
      # @param [ Metadata ] metadata The relation metadata.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = @var[var.inverse_type]
        var = var.builder(self, var).build(var);Fi[	@iQI"&      #
      # @param [ String, Symbol ] name The name of the relation.
      # @param [ Proxy ] relation The relation to set.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        instance_variable_set("@#{name}", var)
      end;Fi[@°I".# @return [ Object ] The new array value.;FI"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	@ûiI"
        #
        # @example Persist the new values.
        #   pop.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@•iI"        #
        # @example Persist the new values.
        #   pull.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@∂iI"˘        #
        # @example Persist the new values.
        #   pushAll.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          append_with("$pushAll")
        end;Fi[@÷%I"end;FI" ;FI"private;FI" ;Fi[[	@Íi2I"Õ    def function(arglist)
      @var = columns.dup
      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist)
      @var ||= (var = @var.map { |arglist| var.dup.freeze };Fi[	@ÄimI"∞      def function(arglist)
        @var = var
        yield
        @var = nil
      end
      
      private
      
      def function(arglist)
        (@var.failed? or @var);Fi[	@ViÉI"ñ      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist)
        if @var then;Fi[@÷%@Z=I"end;FI"end;FI"end;Fi[[	@wirI"¨        #   Project.primary_key # => "foo_id"
        def function(arglist)
          @var = (var and var.to_s)
          @var = nil
        end
      end
    end
  end
end;Fi[	@iiI"´        # (temporary file containing the password)
        def function(arglist)
          @var.delete if @var
          @var = nil
        end
      end
    end
  end
end;Fi[	@_i1I"ì      def function(arglist)
        var = @var
        @var.each { |arglist| var.end_scenario(var) }
        @var = nil
      end
    end
  end
end;Fi[@÷%@Z=@f=I" ;FI"def function(arglist);Fi[[	@ixI"Ù          yield if block_given?
          return @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      source(Source::Path.new(_normalize_hash(var).merge("path" => (Pathname.new(var)))), var, &var)
    end;Fi[	@…	i8I"ª        yield
        @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      @var = Framework.new(var, *var)
      if var = ALL.index(self[var]) then;Fi[	@ŒiI"È          if @var then
            @var.puts(@var.description.gsub(/ \(druby.*\)/, ""))
            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end;Fi[I"ensure;FI"@var = nil;FI"end;FI"end;FI" ;Fi[[	@iwI"8          var[:prepend] ? (@var = [@var].|(@var)) : (@var = @var.|([@var]))
          yield if block_given?
          return @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      source(Source::Path.new(_normalize_hash(var).merge("path" => (Pathname.new(var)))), var, &var);Fi[	@…	i7I"¶        (@var = nil
        yield
        @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      @var = Framework.new(var, *var);Fi[	@Ã	ixI"‹        begin
          (@var = var
          yield)
        ensure
          @var = nil
        end
      end
      
      # parses a manifest file which is a ruby script
      # evaluated in a Manifest instance context;Fi[I"@var[var] = var;FI"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@¨iI"      def function(arglist)
        var = ColumnDefinition.new(var, var, var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        var = columns.detect { |arglist| (var.type == :primary_key) }
        var and var.name;Fi[	@Zi%I"Œ              @var = var
            end
          end
          @var[var] = var
          var
        end
        
        def function(arglist)
          if var = @var[var] then
            var = var.prev;Fi[	@biNI"(        var = constantize("Cucumber::#{ext.capitalize}Support::#{ext.capitalize}Language")
        var = var.new(@var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        log.debug("Code:\n")
        var.each { |arglist| load_file(var) };Fi[@°@N=@O=I"# @since 2.0.0;FI"def function(arglist);Fi[[	@éiI"#        #
        # @example Persist the new values.
        #   addToSet.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            document[field] = [] unless document[field];Fi[	@¨iI"        #
        # @example Persist the new values.
        #   pull_all.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@≥iI"Û        #
        # @example Persist the new values.
        #   push.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          append_with("$push")
        end;Fi[@°I"<# @raise [ Errors::InvalidIndex ] If validation failed.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@ziI"x        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var)
          validate_options(var, var, var);Fi[	@zi,I"Ä        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|
            unless VALID_OPTIONS.include?(var) then;Fi[	@ziBI"ú        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!
          var.each_pair do |arglist|;Fi[@0@1I" ;FI"def function(arglist);FI"@var = false;Fi[[	@üi5I"ì      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@üiWI"ù      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@®i:I"ù      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[@Ø/@Ÿ/I"var = @var["cw"];F@ç2@Ã-i[[	@•iYI"„  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@®iNI"„  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@´iHI"„  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[@°I":# @return [ Array<Document> ] The matching documents.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	I"9data//mongoid_proj/lib/mongoid/criterion/findable.rb;TizI"H      #   criteria.from_database(ids)
      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        ((var.size > 1) ? (any_in(:id => (var))) : (where(:id => (var.first)))).entries
      end;Fi[	@≈=iÖI"&      #   criteria.from_identity_map(ids)
      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        var = []
        var = selector_with_type_selection;Fi[	I"3data//mongoid_proj/lib/mongoid/identity_map.rb;Ti3I"7    #
    # @param [ Class ] klass The class of the document.
    # @param [ Hash ] idenfier The selector.
    #
    # @return [ Array<Document> ] The matching documents.
    #
    # @since 3.0.0
    def function(arglist)
      documents_for(var)[var].try(:values) if Mongoid.using_identity_map? and var
    end;Fi[@Ø/@Ÿ/I"if (var > 0) then;FI"@var = 0;FI"out("0 Tw");Fi[[	@.iÓI"¿  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("0 Tw")
      end
      self.AddPage(@var);Fi[	@1iÃI"     var = @var
    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var);Fi[	@1iKI"¯    var = @var
    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var);Fi[@Ø/I"var = @var["cw"];F@ç2@Ã-@€-i[[	@•iZI"  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[	@®iOI"  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[	@´iII"  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[@°I".# @param [ Class ] klass The model class.;FI"4# @param [ Hash ] spec The index specification.;FI"1# @param [ Hash ] options The index options.;FI"#;Fi[[	@ziI"^        #
        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[	@zi(I"c        #
        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[	@zi>I"]        #
        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[@°I"1# @return [ Array<Document> ] The documents.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@i˝I"‡      #
      # @example Get the cached documents.
      #   context.documents
      #
      # @return [ Array<Document> ] The documents.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= []
      end;Fi[	@D#iVI"∆    #
    # @example Get the documents.
    #   criteria.documents
    #
    # @return [ Array<Document> ] The documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= []
    end;Fi[	@Éi8I"Y        #
        # @param [ Array<Document> ] docs The documents.
        # @param [ Symbol ] method Delete or destroy.
        #
        # @return [ Array<Document> ] The documents.
        #
        # @since 3.0.0
        def function(arglist)
          var.each do |arglist|
            var.run_after_callbacks(:destroy) if (var == :destroy);Fi[I"	@var;FI"end;FI"end;FI"end;FI"end;Fi[[	@®iWI"»        [:token, :user, :message, :title, :priority, :device].each do |arglist|
          @var.merge!(var => (self.instance_variable_get("@#{k}")))
        end
        @var
      end
    end
  end
end;Fi[	@¢	i{I"t            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end
end;Fi[	@ΩiWI"9        var.select { |arglist| ["list", "bool"].include?(var.field_format) }.each do |arglist|
          @var["cf_#{cf.id}"] = { :sql => ("#{cf.join_alias}.value"), :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[@°@W;I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@.i#I"	      #   map_reduce.each do |doc|
      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        block_given? ? (documents.each { |arglist| yield(var) }) : (to_enum)
      end;Fi[	@ibI"3      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          (documents[(skipping or 0), (limiting or documents.length)] or []).each do |arglist|;Fi[	@irI"ı      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          selecting do |arglist|;Fi[I"@var = [];FI"end;FI" ;F@:I"@var = var;Fi[[	@œiGI"”    class BeComparedTo < Be
      def function(arglist)
        @var, @var = var, var
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.__send__(@var, @var)
      end;Fi[	@ŸiI"      def function(arglist)
        @var = var
        @var = nil
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.each do |arglist|
          (@var << var) unless var.respond_to?(var) and matches_arity?(var, var);Fi[	@ÀiI"§          else
            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        ;Fi[@°I"5# @param [ String, Symbol ] name The config key.;FI"0# @param [ Hash ] config The configuration.;FI"#;FI"# @since 3.0.0;Fi[[	@i&I"à        #
        # @example Validate the session has database.
        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionDatabase.new(var, var)) if no_database_or_uri?(var);Fi[	@i5I"|        #
        # @example Validate the session has hosts.
        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionHosts.new(var, var)) if no_hosts_or_uri?(var);Fi[	@iEI"W        #
        # @example Validate the uri and options.
        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          if both_uri_and_standard?(var) then;Fi[@°I"# @since 2.3.0;FI"def function(arglist);FI"@var ||= {};FI"end;Fi[[	@‰i
I"◊    #   person.delayed_atomic_sets
    #
    # @return [ Hash ] The delayed $sets.
    #
    # @since 2.3.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get a hash of atomic pulls that are pending.;Fi[	I"5data//mongoid_proj/lib/mongoid/config/options.rb;TiI"‰      #   options.defaults
      #
      # @return [ Hash ] The default options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
      
      # Define a configuration option with a default.;Fi[	@1>i6I"µ      #   options.settings
      #
      # @return [ Hash ] The setting options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
    end
  end;Fi[@f@gI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];Ti[[	@ÁiøI"=      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@Ái˜I"=      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@Ái/I"_      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3));Ti[@°I"K# @param [ Document ] document The document to generate the paths for.;FI"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	@iI"M          #
          # @example Create the path util.
          #   Many.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent
            @var, @var = "$push", "$pull";Fi[	@iI"L          #
          # @example Create the path util.
          #   One.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent
            @var, @var = "$set", "$unset";Fi[	@iI"-        #
        # @example Create the root path util.
        #   Root.new(document)
        #
        # @param [ Document ] document The document to generate the paths for.
        #
        # @since 2.1.0
        def function(arglist)
          @var, @var, @var, @var = var, "", "", ""
        end;Fi[@£@r$@s$@<4I"#   person.pets;Ti[[	@ÁiêI"       # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@ÁiI",      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@Ái I"<      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[@°I"# @since 2.2.0;FI"def function(arglist);FI"@var ||= {};FI"end;Fi[[	I"7data//mongoid_proj/lib/mongoid/atomic/modifiers.rb;Ti’I"Ù      #   modifiers.pull_fields
      #
      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be pushed.;Fi[	@\>i·I"Ò      #   modifiers.push_fields
      #
      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be set.;Fi[	@\>iÌI"Ú      #   modifiers.set_fields
      #
      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the $pullAll operations or intialize a new one.;Fi[@·@‚@„@§I"def function(arglist);Ti[[	@Ái·I"R      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.create(var, &var)
      end;Ti[	@Ái~I"]      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var)
      end;Ti[	@Ái≤I"m      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length
      end;Ti[@‚@„I"#   #    ];TI"#;T@7=i[[	@Ái@I"t      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@ÁiaI"t      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@ÁizI"t      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[@„I"#   #    ];TI"#;T@7=I"#   # => [;Ti[[	@ÁiAI"õ      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@ÁibI"õ      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@Ái{I"õ      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@°@:#@;#I"
false;FI"end;Fi[[	@SiéI"æ      #   object.multi_arged?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Is the object a number?;Fi[	@SiöI"›      #   object.numeric?
      #
      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Remove the instance variable for the provided name.;Fi[	@SiπI"–      #   object.resizable?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Get the substitutable version of an object.;Fi[@7=I"#   # => [;T@9=I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[[	@ÁiDI"c      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁieI"c      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái~I"c      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[I"?#   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];TI"#;TI" #   person.pets.size # => 2;TI"#   person.pets;TI"#   # => [;Ti[[	@ÁiºI"Q      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@ÁiÙI"Q      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@Ái,I"R      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@ò>I"#   person.pets;TI"#   # => [;T@6>@7>i[[	@ÁiæI"Q      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@ÁiˆI"Q      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@Ái.I"R      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[@»0@…0@ 0I"#   #    ];TI"#;Ti[[	@ÁiFI"s      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4")
      #   # => #<Pet id: 4, name: "Benny", person_id: 1>;Ti[	@ÁiaI"8      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [;Ti[	@ÁihI"Q      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')])
      #;Ti[@Q&@R&@S&@T&I"end;Fi[[	@ßiÈI"≈          ActiveRecord::Base.clear_active_connections! unless var
        end
        var) rescue ActiveRecord::Base.clear_active_connections! unless var
          raise
      end
    end
  end
end;Fi[	@!i)I"¢        Rails.logger.debug("[Devise] Trying to deserialize invalid class #{klass_name}")
        # do nothing
      else
        raise
      end
    end
  end
end;Fi[	@ÒiI"¯        if (var.message == "no acceptor") then
          raise("Cannot start the server on port #{$APP_CONFIG.port} - are you root, or have another process on this port already?")
        else
          raise
        end
      end
    end
  end
end;Fi[@°@:#@;#I"@var.!.!;FI"end;Fi[[	@i!I"Ó      #   context.cached?
      #
      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the number of documents matching the query.;Fi[	@iÒI"Ë      #   context.cache_loaded?
      #
      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the documents for cached queries.;Fi[	@D#iqI"Ù    #   criteria.embedded?
    #
    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    
    # Extract a single id from the provided criteria. Could be in an $and;Fi[@°@:#@;#I"@var ||= {};FI"end;Fi[[	@‰i"I"Ë    #   document.delayed_atomic_unsets
    #
    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Flag the document as destroyed and return the atomic path.;Fi[	I"-data//mongoid_proj/lib/mongoid/config.rb;Ti’I"œ    #   config.sessions
    #
    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Set the session configuration options.;Fi[	I"9data//mongoid_proj/lib/mongoid/contextual/command.rb;TiI"       #   command.command
      #
      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the database session.;Fi[@°I"=# base - The String path to the dir containing the file.;FI".# name - The String filename of the file.;FI"#;FI"# Returns nothing.;Fi[[	@ŸiI"·    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin;Fi[	@Åi!I"Î    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[	@®'i?I"Î    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[@°I"# @example;FI"#   class Person;FI"$#     include Mongoid::Document;FI"#     field :title;Fi[[	@ä%iáI"Ò      end
      
      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i;Fi[	@ä%iòI"Â      end
      
      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_length_of :title, minimum: 100;Fi[	@ä%i©I"¸      end
      
      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_presence_of :title;Fi[@°I"# For example,;FI"#;FI"#   class Vehicle;F@•1i[[	@ú%iiI"    # * <tt>human_state_event_name(event)</tt> - Gets the humanized value for
    #   the given event.  This may be generated by internationalization
    #   libraries if supported by the integration.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@ú%iöI"p    #   specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@ú%i’I"H    # automatically assigned when a new object is created.  However, this
    # behavior will *not* work if the class defines an +initialize+ method
    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end;Fi[@°I"# ==== Parameters;FI"=# source<String>:: the relative path to the source root.;FI"G# destination<String>:: the relative path to the destination root.;F@B3i[[	@Mi&I"ò    # <b>Encoded path note:</b> Since Thor internals use Object#respond_to? to check if it can
    # expand %something%, this `something` should be a public method in the class calling
    # #directory. If a method is private, Thor stack raises PrivateMethodEncodedError.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #                If :recursive => false, does not look for paths recursively.
    #                If :mode => :preserve, preserve the file mode from the source.;Fi[	@J3i)I"ö    
    # Links the file from the relative source to the relative destination. If
    # the destination is not given it's assumed to be equal to the source.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples;Fi[	@J3i_I"‹    # Gets an ERB template at the relative source, executes it and makes a copy
    # at the relative destination. If the destination is not given it's assumed
    # to be equal to the source removing .tt from the filename.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples;Fi[@^@_I"var = (var + 1);F@`.I"	else;Fi[[	@.iUI"Ÿ        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == " "[0]) then
          var = var;Fi[	@.irI"œ          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1)
        end;Fi[	@1imI"ª        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1)
      end;Fi[@^I"while (var < var) do;FI"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);FI"if (var < 128) then;FI"/var = (var + var[var.chr]) if var[var.chr];Fi[[	@•iBI"    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@®i2I"    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@´i1I"    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[@^I"var = @var["cw"];FI"var = var.length;FI"var = 0;FI"while (var < var) do;Fi[[	@•i?I"÷  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@®i/I"÷  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@´i.I"÷  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[@°@ò>I"#   person.pets;TI"#   # => [;T@6>i[[	@ÁiΩI"Q      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁiıI"Q      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@Ái-I"R      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@°@7=I"#   # => [;T@9=@å>i[[	@ÁiCI"ò      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@ÁidI"ò      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@Ái}I"ò      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@°@(@b;I"#   end;FI"#;Fi[[	@«(iºI"ﬁ    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false;Fi[	@«(iÕI"÷    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[	@«(iÙI"÷    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[@°@(I"#     has_many :pets;TI"#   end;TI"#;Ti[[	@Ái≥I"`      # with +attributes+ and linked to this object, but have not yet been saved.
      # You can pass an array of attributes hashes, this will return an array
      # with the new objects.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.build
      #   # => #<Pet id: nil, name: nil, person_id: 1>;Ti[	@ÁiŒI"Ü      # Returns a new object of the collection type that has been instantiated with
      # attributes, linked to this object and that has already been saved (if it
      # passes the validations).
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.create(name: 'Fancy-Fancy')
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@ÁiÍI"Ú      end
      
      # Like +create+, except that if the record is invalid, raises an exception.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   class Pet
      #     validates :name, presence: true;Ti[I"#extend(ActiveSupport::Concern);FI" ;FI"&def self.required_fields(arglist);FI"[];FI"end;Fi[[	@/,i	I"ømodule Devise
  module Models
    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods;Fi[	@~iI"ømodule Devise
  module Models
    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods;Fi[	@–i	I"Úmodule Devise
  module Models
    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      # Checks whether the user session has expired based on configured time.;Fi[@¨@}0@~0@&9I"%# @return [Array<Twitter::User>];Fi[[	@i I"˜      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[	@iI"      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[	@iI"D          object_from_response(Twitter::User, var, var, merge_user(var.options, var))
        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[I"C# +binds+ as the bind substitutes. +name+ is logged along with;FI"$# the executed +sql+ statement.;FI"def function(arglist);FI"exec_query(var, var, var);FI"end;Fi[[	@)iII"j      end
      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes delete +sql+ statement in the context of this connection using;Fi[	@)iPI"j      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes update +sql+ statement in the context of this connection using;Fi[	@)iWI"^      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Returns the last auto-generated ID from the affected table.;Fi[@e?@f?@g?I"end;FI" ;Fi[[	@)iJI"•      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@)iQI"•      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@)iXI"\      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Returns the last auto-generated ID from the affected table.
      #;Fi[I"# == Examples;FI"#;FI"#   class Vehicle;F@ç%@<i[[	@-iI"    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@-i'I"    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@-iBI"˜    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[@TI"end;FI"end;FI"var;FI"end;Fi[[	@JiÚI"             var = ["2", "n", "+", "1"]
            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      
      def function(arglist);Fi[	@:iI"¢          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8(arglist);Fi[	@:iGI"≠          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8_by_setting(arglist);Fi[@T@UI"var = (var + 1);F@ó$I"	next;Fi[[	@•izI"ı        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[	@®ioI"˚        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then;Fi[	@´iiI"ı        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[@T@U@í?@ó$I"	else;Fi[[	@•iéI"˜          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@®iàI"          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@´i}I"˜          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[@¨@Î9I"def function(arglist);F@8I"end;Fi[[	@™iBI"4          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@≠i;I"4          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@∞i?I"4          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[@¨I"H# Uses around callbacks to run state events if using the :save hook;FI"def function(arglist);FI"#if (action_hook == :save) then;F@N8i[[	@™i9I"E      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@≠i2I"U        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@∞i6I"d        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[@¨@Û8@Ù8@8I"end;Fi[[	@™iI"Í      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@≠iI"Í      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@∞iI"Í      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[@Õ,I"	else;F@e8I"end;FI"end;Fi[[	@ioI"Ÿ  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@ixI"Ÿ  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@i|I"Ÿ  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[@¨I"L# Describes the current validation errors on the given object.  If none;FI"F# are specific, then the default error is interpeted as a "halt".;FI"def function(arglist);FI"if var.errors.empty? then;Fi[[	@ßi$I"N          var.errors.add(var, var, var.merge(var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[	@iI"e          var.errors.add(self.attribute(var), generate_message(var, var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[	@i!I"s      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[@¨I"Aattr_reader(:plugin_path, :plugin_name, :plugin_pretty_name);FI" ;FI"def function(arglist);FI"
super;Fi[[	@‘:iI"class RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[	@◊:iI"+  argument(:controller, :type => :string)
  
  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[	@⁄:iI"Ü  class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[@¨@≥4I" ;F@ã.I" ;Fi[[	@ë.iI"›      undef_method(:attributes)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[	@î.iI"Ÿ      undef_method(:values)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[	@ö.iI"Â      undef_method(:attribute_nodes)
      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[@≠,@Æ,@Ø,I"end;FI"end;Fi[[	@içI"            Bundler.ui.info("#{@output_file}.#{@output_format}"))
          rescue ArgumentError => var
            $stderr.puts("Unsupported output format. See Ruby-Graphviz/lib/graphviz/constants.rb")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	@yiPI"ä        when Capistrano::Error then
          abort(var.message)
        else
          raise(var)
        end
      end
    end
  end
end;Fi[	I"Bdata//diaspora_proj/models/jobs/receive_unencrypted_salmon.rb;TiI"Ñ        var.perform!)
      rescue => var
        FEDERATION_LOGGER.info(var.message)
        raise(var)
      end
    end
  end
end;Fi[@≠,@Æ,@Ø,@?I" ;Fi[[	@<i3I"&        if handle_no_method_error?(var, var, caller) then
          var.class.handle_no_task_error(name)
        else
          raise(var)
        end
      end
    end
    
    # Returns the formatted usage by injecting given required arguments
    # and required options into the given usage.;Fi[	@ãiØI"            var.new(var, var, @var))
          rescue Exception => var
            (var.message << "\nError creating formatter: #{format}")
            raise(var)
          end
        end
      end
      
      class LogFormatter < ::Logger::Formatter
        def function(arglist);Fi[	@ñiJI"ˇ            STDERR.puts("You don't have a 'features' directory.  Please create one to get started.", "See http://cukes.info/ for more information.")
            exit(1)
          end
          raise(var)
        end
      end
    end
    
    private
    ;Fi[I"super(var, var, var, var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@•i®I"œ    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[	@®i£I"—    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[	@´ióI"œ    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[@¨@â<I"I# This should be optimized in the future potentially not to load all;FI"# objects from the db.;FI"#;Fi[[	@_iI"l          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[	@fiI"m          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.
        #   strategy.cascade;Fi[	@piI"l          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[@ù.I"var = (var + $!.success);FI"end;FI"var = var;FI"end;Fi[[	@:iI"Á            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@:iDI"Á            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@:iÇI"Â            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end;Fi[@m:I"end;FI" ;F@p:@a:i[[	@∂i#I"‰      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[	@êi∂I"¯        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        ;Fi[	@£i5I"‰      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[@a:I"end;FI" ;F@d:I";execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[[	@∂i'I"Ï      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[	@êi∫I"        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end;Fi[	@£i9I"Ï      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[@¨I"# Obtain destination path.;FI"#;FI"5# dest - The String path to the destination dir.;FI"#;Fi[[	@ÅitI".    def function(arglist)
      self.data.deep_merge("url" => (File.join(@var, self.url)), "content" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.
    def function(arglist);Fi[	@®'i¿I"Q      var = { "site" => ({ "related_posts" => (related_posts(var["site"]["posts"])) }), "page" => (self.to_liquid) }.deep_merge(var)
      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.
    def function(arglist);Fi[	@ÑiI"Á    def function(arglist)
      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.
    def function(arglist);Fi[@¨I"!# Read the YAML frontmatter.;FI"#;F@÷>@◊>i[[	@ŸiI"    def function(arglist)
      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@ÅiI"      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@®'i=I"        self.categories = self.data.pluralized_array("category", "categories")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[I"rescue LoadError;FI"
false;FI"end;FI"end;FI"end;Fi[[	@`iãI"î        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@ci~I"î        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@C iVI"ì      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist);Fi[@˜+@5/I"end;FI"end;FI"end;Fi[[	@riçI"S              var[var].stop = var[(var - 1)].stop.plus(var[var].stop.minus(var[(var - 1)].stop).div(Sass::Script::Number.new(var)))
              break
            else
              var = (var + 1)
            end
          end
        end
      end
      var.each do |arglist|
        if var.stop.unitless? and (var.stop.value <= 1) then;Fi[	@qiAI"∂            make_datapoint_text((var + (var / 2.0)), (var - 6), var.to_s)
            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	@tiAI"…            make_datapoint_text(((var + var) + 5), (var + var), var, "text-anchor: start; ")
            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[@¨I"$attr_reader(:gherkin_statement);FI" ;FI"def function(arglist);FI"@var ||= var;Fi[[	@±iI"⁄      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@¥iI"      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@ÉiI"œ      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[@˜+I"	else;F@}8I"var = (var + 2);FI"end;Fi[[	@•iGI"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000);Fi[	@®i;I"–      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end
    end;Fi[	@´i6I"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000);Fi[@˜+@¯+@˘+@˙+I"var = (var + 1);Fi[[	@•ixI"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@®imI"      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@´igI"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[@¨I"I# Returns the command that will sync the given revision to the given;FI"L# destination directory. The perforce client has a fixed destination so;FI"K# the files must be copied from there to their intended resting place.;FI"def function(arglist);Fi[[	@∆iI"É        def function(arglist)
          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@∆iI"ú        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@∆i!I"ú        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[I"var = "";F@8@8@ 8I"end;Fi[[	@•ihI"        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[	@®i]I"        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[	@´iWI"        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[@ó@I"
begin;F@√:@ƒ:@≈:i[[	@:iI"m          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry;Fi[	@:i=I"i          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry;Fi[	@:i{I"i          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry;Fi[@¨I";# Increments the given revision number and returns it.;FI"def function(arglist);FI"(var.to_i + 1);FI"end;Fi[[	@≤iAI"Û          var = scm("revno", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private;Fi[	@∆i8I"Ü          var = scm(authentication, :changes, "-s submitted", "-m 1", "//#{p4client}/...#{rev_no(revision)}")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[	@Ài?I"L          end
          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[@¨I"def self.process(arglist);FI"evar = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8");FI" FileUtils.mkdir_p("_posts");FI"!var[QUERY].each do |arglist|;Fi[[	@ÈiI"V    end
    
    QUERY = "SELECT id,                     permalink,                     body,                     published_at,                     title              FROM contents              WHERE user_id = 1 AND                    type = 'Article' AND                    published_at IS NOT NULL              ORDER BY published_at"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:title]
        var = var[:permalink];Fi[	@ÏiI"Nmodule Jekyll
  module MT
    QUERY = "SELECT entry_id,                     entry_basename,                     entry_text,                     entry_text_more,                     entry_authored_on,                     entry_title,                     entry_convert_breaks              FROM mt_entry"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:entry_title]
        var = var[:entry_basename].gsub(/_/, "-");Fi[	@ÚiI"module Jekyll
  module TextPattern
    QUERY = "SELECT Title,                     url_title,                     Posted,                     Body,                     Keywords              FROM textpattern              WHERE Status = '4' OR                    Status = '5'"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:Title]
        var = var[:url_title];Fi[I"var = case var;F@˙-I""Success";F@2:I""Warning";Fi[[	@ﬂi0I"      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[	@•i.I"      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[	@´i,I"      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[@¨I"@var = nil;FI" ;FI"@var = nil;FI" ;Fi[[	@È3iI"xclass Net::HTTP::Persistent::SSLReuse < Net::HTTP
  @var = false
  
  @var = nil
  
  @var = nil
  
  @var = nil
  ;Fi[	@È3i	I"V  @var = false
  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  @var = nil
  ;Fi[	@È3iI"f  @var = nil
  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  def function(arglist)
    super;Fi[I"var.save;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@iPI"(  def function(arglist)
    if var = ConversationVisibility.where(:conversation_id => (self.conversation_id), :person_id => (var.person.id)).first then
      var.unread += 1
      var.save
    end
  end
  
  def function(arglist)
    Notifications::PrivateMessage unless (var.person == var)
  end;Fi[	@Êi}I"‹    var = Profile.where(:image_url => (url(:thumb_large)))
    var.each do |arglist|
      var.image_url = nil
      var.save
    end
  end
  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end;Fi[	I"Hdata//redmine_proj/plugins/acts_as_versioned/test/versioned_test.rb;TizI"    assert_equal(2, var.versions.size)
    assert_raises(ActiveRecord::StaleObjectError) do |arglist|
      var.title = "stale title"
      var.save
    end
  end
  
  def function(arglist)
    var = Page.create!(:title => "title")
    assert_equal(1, var.version);Fi[I"end.new;FI"assert(var.satisfied?);FI"end;FI" ;FI"def function(arglist);Fi[[	I"1data//homebrew_proj/test/test_requirement.rb;Ti(I",  def function(arglist)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (false)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (false)) { |arglist| false };Fi[	@Ó@i9I"    var = Class.new(Requirement) do |arglist|
      env(:userpaths)
      satisfy(:build_env => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    ENV.expects(:with_build_environment).yields.returns(true)
    ENV.expects(:userpaths!);Fi[	@Ó@iBI";    ENV.expects(:userpaths!)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (true), :userpaths => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) { |arglist| satisfy(true) }.new
    assert(var.satisfied?);Fi[@¨I"attr_accessor(:source);FI" ;FI"def function(arglist);FI"@var = var;Fi[[	@!iI"Ã    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var;Fi[	@1iI"À    include(MatchPlatform)
    
    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = [];Fi[	@4iI"Ω    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var;Fi[@¨I"1class_option(:timestamps, :type => :boolean);FI" ;FI"aclass_option(:parent, :type => :string, :desc => "The parent class for the generated model");FI" ;Fi[[	I"Tdata//activerecord_proj/rails/generators/active_record/model/model_generator.rb;TiI"à      check_class_collision
      
      class_option(:migration, :type => :boolean)
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
      
      class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
      ;Fi[	I"Mdata//mongoid_proj/lib/rails/generators/mongoid/model/model_generator.rb;TiI"•      argument(:attributes, :type => :array, :default => ([]), :banner => "field:type field:type")
      
      check_class_collision
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
      
      class_option(:versioning, :type => :boolean, :default => (false), :desc => "Enable mongoid versioning")
      ;Fi[	@⁄:iI"ª  argument(:attributes, :type => :array, :default => ([]), :banner => "field[:type][:index] field[:type][:index]")
  
  class_option(:migration, :type => :boolean)
  
  class_option(:timestamps, :type => :boolean)
  
  class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  ;Fi[I"if @var.compressor then;FI"/@var.compressor.compress_with do |arglist|;FI"(var << var);FI"(var << var);FI"end;Fi[[	@PiII"q      var = "tar"
      var = Pipeline.new
      (var << ("#{utility(:tar)} #{tar_args} -cPf - " + "#{paths_to_exclude} #{paths_to_package}"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "cat > '#{File.join(archive_path, "#{name}.#{archive_ext}")}'");Fi[	@Xi;I"9        var = Pipeline.new
        var = "sql"
        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, dump_filename)}.#{dump_ext}'");Fi[	@à1i;I"-        var = Pipeline.new
        var = "sql"
        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, name)}.#{dump_ext}'");Fi[@AI"(var << var);FI"(var << var);FI"end;FI"end;Fi[[	@PiJI"m      var = Pipeline.new
      (var << ("#{utility(:tar)} #{tar_args} -cPf - " + "#{paths_to_exclude} #{paths_to_package}"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "cat > '#{File.join(archive_path, "#{name}.#{archive_ext}")}'")
      var.run;Fi[	@Xi<I".        var = "sql"
        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, dump_filename)}.#{dump_ext}'")
        var.run;Fi[	@à1i<I""        var = "sql"
        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, name)}.#{dump_ext}'")
        var.run;Fi[@¨I"#:nodoc:;FI"def function(arglist);F@i*I"
begin;Fi[[	@n*i"I"Ô        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}")
            FileUtils.rm(var) if File.exist?(var));Fi[	@i≈I"      def function(arglist)
        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("saving #{path(style)}")
            var = (@var[var] or @var[:default]);Fi[	@i·I"ˆ        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}")
            s3_bucket.objects[var.sub(/^\//, "")].delete);Fi[@¨@… @.0@/0@[<i[[	@Îi7I"          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[	@˘i+I"          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("mkdir -p '#{remote_path}'");Fi[	@¸i)I"          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[@¨@@@&I"4# Establishes a connection to the remote server;Fi[[	@Îi#I"À        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #
      # Note:;Fi[	@˘iI"        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.
      # Net::SCP will use this connection to transfer backups;Fi[	@¸iI".        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|;Fi[@¨@@@WI"# do nothing;Fi[[	@fibI"≠            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@1iDI"µ    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@⁄iI"‹            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end;Fi[I""next if send(var).to_s.empty?;FI"$"--#{option}='#{send(option)}'";FI"end.compact.join(" ");FI"end;FI" ;Fi[[	@UiâI"R      # to perform the database dumping process
      def function(arglist)
        ["username", "password"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds the MongoDB connectivity options syntax to connect the user;Fi[	@UiìI"6      # to perform the database dumping process
      def function(arglist)
        ["host", "port"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Returns the mongodump syntax for enabling ipv6;Fi[	@XigI"M      # to perform the database dumping process
      def function(arglist)
        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds a MySQL compatible string for the additional options;Fi[@NA@OAI"end;FI" ;FI"##;Fi[[	@UiäI"R      def function(arglist)
        ["username", "password"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds the MongoDB connectivity options syntax to connect the user
      # to perform the database dumping process;Fi[	@UiîI""      def function(arglist)
        ["host", "port"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Returns the mongodump syntax for enabling ipv6
      def function(arglist);Fi[	@XihI";      def function(arglist)
        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds a MySQL compatible string for the additional options
      # specified by the user;Fi[I"
end));FI"end;FI"end;FI"end;FI" ;Fi[[	@ÌijI"L      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display
  # it next to the avatar image in a nice box;Fi[	@iBI"'      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist)
    session[:a_ids] = params[:a_ids] if params[:a_ids].present?;Fi[	@i*I"‹      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  ;Fi[@¨@
I"var = max_value;FI"var = min_value;F@9i[[	@qiI"˚      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[	@tiI"‡      end
      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[	@£iPI".        var = (((@var[:fields][0].length / 2) * font_size) * 0.6)
        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[@¨@
I"@var[:fields];FI"end;FI" ;Fi[[	@qiI"û      end
      
      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value;Fi[	@ti#I"Õ        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        (var / -2.0);Fi[	@£iFI"ú        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super;Fi[@¨@
@Y9@Z9@[9i[[	@•i<I"ˇ      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[	@®iEI"ˇ      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[	@´i+I"ˇ      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[@¨@
@d9@e9@f9i[[	@•iI"∂    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[	@®iI"∂    var = (@var.length + 1)
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[	@´iI"∂    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[@¨@
@p9I"end;FI"end;Fi[[	@ë.iI"Ú      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ó.iI"Ú      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ö.iI"◊      def self.new(arglist)
        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[@¨@
@®9I"var;FI"end;Fi[[	@Ji,I"√        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@Ji1I"√        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@Ji6I"¡        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted;Fi[@¨@
@|9I"var;FI"end;Fi[[	@Ji◊I"⁄        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@Ji‹I"π        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@Ji·I"∑        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted;Fi[@¨@
@î9@ï9I"super(var);Fi[[	@ikI"7    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@itI"Ë      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@i}I"Ë      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[@¨@
@«9I"end;FI" ;Fi[[	@>
i:I"—  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then;Fi[	@ai-I"Æ  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false;Fi[	@i2I"ø  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid;Fi[@¨@
I""";FI"end;FI" ;Fi[[	@ái=I"}  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    [];Fi[	@íi
I"å    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      "";Fi[	@íiI"Å    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0;Fi[@¨@
I"broadcast(var);FI"end;FI" ;Fi[[	@àiI"¯      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ài%I"ﬁ      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@àijI"ﬁ      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[@¨@
I"@var.language;FI"end;FI" ;Fi[[	@3i?I"      def function(arglist)
        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      
      class ExampleRow < Cells
        class InvalidForHeaderRowError < NoMethodError;Fi[	@3ißI"‘        def function(arglist)
          "| #{@cells.collect { |c| c.value }.join(" | ")} |"
        end
        
        def function(arglist)
          @var.language
        end
        
        private
        ;Fi[	@ÉiWI"      def function(arglist)
        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      
      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "_").gsub(/\./, "_").gsub(/:/, "_");Fi[@¨@
@f1I"var = @var;FI"var = @var["cw"];Fi[[	@•iWI"Ë      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@®iLI"Ë      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@´iFI"Ë      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[@¨@
@Ù9I"end;FI" ;Fi[[	@¥iBI"–      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init;Fi[	@3i I"©        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags;Fi[	@3iÇI"Ω            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var);Fi[@˙-I""Success";F@2:I""Warning";FI"when :failure then;Fi[[	@ﬂi1I"‘      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[	@•i/I"‘      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[	@´i-I"‘      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[I""Success";F@2:I""Warning";F@ˇAI""Failure";Fi[[	@ﬂi2I"„      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[	@•i0I"„      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[	@´i.I"„      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[@2:I""Warning";F@ˇAI""Failure";FI"	else;Fi[[	@ﬂi3I"”        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[	@•i1I"”        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[	@´i/I"”        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[I""Warning";F@ˇAI""Failure";FI"	else;FI"# do nothing;Fi[[	@ﬂi4I"        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var);Fi[	@•i2I"·        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s]" % var);Fi[	@´i0I"        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger}) (@ #{@model.time})" % var);Fi[@ˇAI""Failure";FI"	else;FI"# do nothing;FI"end;Fi[[	@ﬂi5I"          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var)
        send_message(var);Fi[	@•i3I"‡          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s]" % var)
        send_message(var);Fi[	@´i1I"          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger}) (@ #{@model.time})" % var)
        send_message(var);Fi[I"if (var > 0) then;FI"@var = 0;FI"out("0 Tw");FI"end;FI"AddPage(@var);Fi[[	@1iŒI"€      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[	@1iI"?      if ((var + ((var["h"] * var) / (@var * @var))) > @var) and (@var.! and AcceptPageBreak) then
        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("0 Tw")
          end
          AddPage(@var)
          if (var > 0) then
            @var = var;Fi[	@1iMI"€      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[@:<@;<I"super(var, var);FI"@var ||= 22;FI"@var ||= "backups";Fi[[	@¡iI"      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@˘iI"      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "");Fi[	@¸iI"      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "");Fi[I"@var ||= "backups";FI"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;Fi[[	@ÂiI"¿      def function(arglist)
        super(var, var)
        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@ÛiI"ﬁ      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@ˆiI"ﬁ      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[@¨@
I"	self;FI"end;FI" ;Fi[[	@JiCI"Ñ      @var = nil
      var
    end
    
    def function(arglist)
      self
    end
    
    def function(arglist)
      sorted.dup;Fi[	@±.iI"µ        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@Ÿi&I"í        @var = var
        self
      end
      
      def function(arglist)
        self
      end
      
      alias :arguments :argument
      ;Fi[@ä @ã @å @ç I"var = [];Fi[[	@Ëi]I"±      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from Dropbox."));Fi[	@i&I"ù      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << "#{storage_name} started removing '#{local_file}'.");Fi[	@˘i;I"±      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from '#{ip}'."));Fi[@ã @å @ç I"var = [];FI",transferred_files_for(var) do |arglist|;Fi[[	@Ëi^I"∂      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from Dropbox."))
        end;Fi[	@i'I"¢      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << "#{storage_name} started removing '#{local_file}'.")
        end;Fi[	@˘i<I"∂      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from '#{ip}'."))
        end;Fi[@¨@
I"(@var or @var);FI"end;FI" ;Fi[[	@8i∆I"º        end
        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        options["revision"];Fi[	@3iÜI"“        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var;Fi[	@SiI"r  module Parser
    class GherkinBuilder
      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("\n")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, []);Fi[@¨@
I"var = 0;FI"var = @var["cw"];FI"var = var.length;Fi[[	@•i=I"õ      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@®i-I"õ      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@´i,I"õ      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[I"if (var == 0) then;FI"@var = var;F@≤1I"	else;F@¥1i[[	@•iõI"∂    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@®iñI"∂    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@´iäI"∂    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[@ı@I" ;F@˜@I"@var = var;FI"@var = var;Fi[[	@!iI"¬    
    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@1iI"¡    
    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = []
      @var = var;Fi[	@4iI"≥    
    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[I"
break;FI"end;FI"end;FI"end;FI"end;Fi[[	@äihI"π          var = I18n.inflector.true_token(var, :gender, var)
          unless var.nil? then
            @var = var
            break
          end
        end
      end
    end
  end
  ;Fi[	@biVI"                var = $1
                next if (var == "src") and var =~ /^(?!http)\w+:/
                (var << "#{prop}=\"#{$1.gsub("\"", "\\\"")}\"")
                break
              end
            end
          end
        end
        "<#{raw[1]}#{pcs.join(" ")}>"
      else;Fi[	@ihI"            if (var == (var[var][(0...var)] + var[var][((var + 1)..-1)])) then
              var[var][var] += ("," + var[var][var])
              var.delete_at(var)
              break
            end
          end
        end
      end
      var.map { |arglist| var.join(" ") }
    end;Fi[I"var = (var - var);F@9I"var = ((var + var) - var);FI",var = (scale_divisions or (var / 10.0));FI":var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[[	@qiI"p      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@tiI"p      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@£iTI"p      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[I"
true);FI"rescue LoadError;FI"
false;FI"end;FI"end;Fi[[	@`iäI"µ        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end;Fi[	@ci}I"µ        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end;Fi[	@C iUI"á    begin
      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end;Fi[@ÛI"	else;F@.I"@var = var;F@≤1i[[	@•iôI"    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@®iîI"    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@´iàI"    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[@¨@
@a:I"end;FI" ;Fi[[	@∂i%I".      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[	@êi∏I"B        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[	@£i7I".      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[@Û@=5@>5@?5I"var = (var + 1);Fi[[	@•iÕI"H      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@´iºI"H      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@.ißI"6      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[I"
retry;FI"rescue;F@@I"end;FI"var = var;Fi[[	@:iI"          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@:iCI"          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@:iÅI"          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[@¨@
@m:I"end;FI" ;Fi[[	@∂i!I"ˆ          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[	@êi¥I"N          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[	@£i3I"      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[I"var.unshift(var);FI"var = nil;FI"	else;F@58@68i[[	@ri¯I"ﬂ    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@riI"Û      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@riI"ﬂ    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[@Q3I"var = 0;F@?@?@?i[[	@•iAI"  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@®i1I"  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@´i0I"  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[@Q3I">var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");FI"var = 0;FI"if var then;F@9!i[[	@•i_I"+    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[	@®iTI"+    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[	@´iNI"+    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[@¨@
@`3@a3I"end;Fi[[	@ÉiÎI"¬          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@6iI"¬          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@iI"k    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[@™@@´@@¨@I"end;FI" ;Fi[[	@≤iBI"”          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        ;Fi[	@∆i9I"d          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[	@Ài@I"ä          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[@ã@@å@@ç@@é@I"$p4_sync(var, var, p4sync_flags);Fi[[	@∆iI"n          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@∆iI"á          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@∆i"I"á          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[@å@@ç@@é@@0CI"end;Fi[[	@∆iI"™        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@∆iI"™        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@∆i#I"≠        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.;Fi[@ç@@é@@0CI"end;FI" ;Fi[[	@∆iI"Ó        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@∆iI"Ó        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@∆i$I"ø        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.
        def function(arglist);Fi[I"@var = (@var + var);F@>5@?5@ﬂBI"var = (var + 1);Fi[[	@•iŒI"<        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@´iΩI"<        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@.i®I"*        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[@¨@
I"@var.clear;FI"end;FI" ;Fi[[	@Øi√I"æ      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@Øi«I"Æ      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@ØiÀI"±      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var;Fi[@¨@
@È@ÍI"end;Fi[[	@Ñi3I"£          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@>i>I"v    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@jidI"∑      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[I"binding;FI"end;FI"end;FI"end;FI"end;Fi[[	@Ã	iÖI"]      end
      
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	@œ	i'I"      
      def function(arglist)
        @var.each { |arglist| eval("#{k} = v") }
        binding
      end
    end
  end
end;Fi[	@F:i
I"|  module Sprites
    class Binding < OpenStruct
      def function(arglist)
        binding
      end
    end
  end
end;Fi[I"if color_stop?(var) then;FI"var.unshift(var);FI"var = nil;FI"	else;F@58i[[	@ri˜I"€    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@riI"Û        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@riI"€    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[@58@68I"var = nil;FI"end;FI"end;Fi[[	@ri˚I"Û        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then;Fi[	@riI"        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then;Fi[	@riI"!        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first);Fi[@68I"var = nil;FI"end;FI"end;FI"'var = nil if var and var.to_bool.!;Fi[[	@ri¸I"Û        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var);Fi[	@riI"        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then
        var = var.first.value;Fi[	@riI"@        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first)
      LinearGradient.new(var, send(:color_stops, *var));Fi[I"if var.to_bool then;FI".Sass::Script::String.new(clean_path(var));FI"	else;FI"clean_url(var);FI"end;Fi[[	@éi&I"–        end
      end
      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[	@éi?I"Ê        Compass.configuration.http_fonts_path
      end
      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[	@éirI"Ë        end
      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[@õCI"	else;FI"clean_url(var);FI"end;FI"end;Fi[[	@éi'I"«      end
      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@éi@I"ª      end
      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@éisI"ﬂ      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[I"clean_url(var);FI"end;FI"end;FI"end;FI" ;Fi[[	@éi)I"∏      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl
    def self.included(arglist);Fi[	@éiBI"π      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl
    def self.included(arglist);Fi[	@éiuI"¬      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl
    def self.included(arglist);Fi[@k@I" ;F@m@I"@var ||= var;FI"end;Fi[[	@±iI"⁄        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@¥iI"        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@ÉiI"œ        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[I" @var.each_pair do |arglist|;FI"newobj;F@˝'I"<var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");FI"var = filesize(var);Fi[[	@•iˆI"g      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[	@®iˇI"g      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[	@´iÂI"g      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[@ÀC@ÃC@˝'I"out("<</Type /Font");FI"%if (var["type"] == "Type0") then;Fi[[	@•iI"Ÿ      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[	@®iI"Ÿ      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[	@´i˜I"Ÿ      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[@¨@
I"
super;F@œ:@–:i[[	@‘:i	I"  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
  end;Fi[	@◊:iI"A  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = controller.camelize;Fi[	@⁄:iI"b  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = model.camelize;Fi[@å@s'@t'@èI"broadcast(var, var);Fi[[	@ài@I"º      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@àidI"º      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@àitI"º      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[@¨@;*@<*@Û8@Ù8i[[	@™iI"‚        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@≠iI"¯      def self.matching_ancestors(arglist)
        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@∞iI"‹        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[I"@var.flush;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@ôi7I"T            @var.puts(format_string(var.backtrace_line, var))
          end
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        @var = step_mother.scenarios(:failed).select do |arglist|
          (var.is_a?(Cucumber::Ast::Scenario) or var.is_a?(Cucumber::Ast::OutlineTable::ExampleRow));Fi[	@¢i7I"Â      def function(arglist)
        if (@var == 1) then
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        var = format_string(var, :tag).indent(@var)
        @var.print(var);Fi[	@®iI"¯        unless @var.empty? then
          after_first_time { |arglist| @var.print(" ") }
          @var.print("#{@file}:#{@lines.join(":")}")
          @var.flush
        end
      end
      
      def function(arglist)
        @var.close
      end;Fi[I"@var.text!(" ");FI"$@var.span(var, :class => "val");FI"end;FI"end;FI" ;Fi[[	@<iàI"         @var = true
        @var.h3(:id => ("background_#{@scenario_number}")) do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = (@var + 1);Fi[	@<iûI"        @var = false
        @var.h3(:id => ("scenario_#{@scenario_number}")) do |arglist|
          @var.span((var + ":"), :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = 0;Fi[	@<i∏I"¸      def function(arglist)
        @var.h4 do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        (@var << "<ol>");Fi[@	DI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@<iâI"!        @var.h3(:id => ("background_#{@scenario_number}")) do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = (@var + 1)
        @var = false;Fi[	@<iüI"%        @var.h3(:id => ("scenario_#{@scenario_number}")) do |arglist|
          @var.span((var + ":"), :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = 0
        (@var << "<table>");Fi[	@<iπI"Í        @var.h4 do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        (@var << "<ol>")
      end;Fi[I"if (var > var) then;FI"*if ((var == -1) or (var == var)) then;FI"if (@var > @var) then;FI"@var = @var;F@=5i[[	@•i I"q      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[	@®i“I")          var = var
        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[	@´iπI"q      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[I"var.json do |arglist|;FI"8render(:json => (@var.stream_posts.map do |arglist|;FI"ILastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));FI"
end));FI"end;Fi[[	@ÌigI"D    end
    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[	@i?I"b    respond_with do |arglist|
      var.html { |arglist| render("layouts/main_stream") }
      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[	@i'I"Ö    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[I"/render(:nothing => (true), :status => 404);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@
i5I"9      var = OEmbedPresenter.new(var, params.slice(:format, :maxheight, :minheight))
      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).newer(@var)
    respond_to do |arglist|;Fi[	@ˆi$I"    if @var.present? and @var.local? then
      render("publics/hcard")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    render("host_meta", :content_type => "application/xrd+xml")
  end;Fi[	@êiñI"8    if var.present? then
      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    if current_user.confirm_email(params[:token]) then
      flash[:notice] = I18n.t("users.confirm_email.email_confirmed", :email => (current_user.email));Fi[@¨@_ I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;Fi[[	@MiI"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11");Fi[	@Pi¶I".        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ]);Fi[	@Æ#i+I"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11");Fi[@.D@/DI"
end));FI"end;FI"end;Fi[[	@ÌihI"?    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	@i@I"G      var.html { |arglist| render("layouts/main_stream") }
      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	@i(I"X    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[@/DI"
end));FI"end;FI"end;FI"end;Fi[[	@ÌiiI"r      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display;Fi[	@iAI"$      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist);Fi[	@i)I"˜    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private;Fi[@”9I"end;FI" ;FI"def function(arglist);F@«9i[[	@>
i8I"≈  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	@ai+I"ï  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	@i0I"«  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[@'@ı;I"out("endobj");FI"end;FI"end;Fi[[	@•i5I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[	@®i>I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[	@´i$I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[@î9@ï9I"super(var);FI"	else;F@e8i[[	@imI"«  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@ivI"«  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@iI"«  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[@ï9I"super(var);FI"	else;F@e8I"end;Fi[[	@inI"ƒ  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@iwI"ƒ  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@i{I"ƒ  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[@e8I"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@iqI"ı    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@izI"ı    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@i~I"    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["month", "day"].all? { |arglist| var[var].present? } then
      var["year"] = "1000" if var["year"].blank?;Fi[I"# @example;FI"#   class Person;F@‰>@Â>I"#;Fi[[	@ä%iàI"ı      
      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end;Fi[	@ä%iôI"È      
      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end;Fi[	@ä%i™I"       
      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_presence_of :title
      #   end;Fi[@'I"var = var["file"];FI"if var then;F@Û;I"end;Fi[[	@•i1I"û          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[	@®i:I"û          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[	@´i I"û          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[@'I"out(">>");FI"out("endobj");FI"#if var["type"].!=("core") then;FI"newobj;Fi[[	@•i#I"Á              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[	@®i,I"Á              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[	@´iI"Á              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[@'@∂DI"var = fopen(var, "rb");FI"putstream(fread(var, var));FI"fclose(var);Fi[[	@•iI"      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[	@®i
I"      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[	@´iI"      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[I"(HOMEBREW_REPOSITORY.cd do |arglist|;FI"var = UpdaterMock.new;FI"1var.in_repo_expect("git checkout -q master");FI"Evar.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd");FI"9var.in_repo_expect("git config core.autocrlf false");Fi[[	@5i1I"º  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[	@5iCI"˚  
  def function(arglist)
    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[	@5iWI"¯  
  def function(arglist)
    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[@'I"if var.!=(var) then;FI"RCell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var);FI"end;FI"end;Fi[[	@•iÁI"À      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[	@®iI"‘        var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[	@´i÷I"À      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[I"File.executable?(var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@GiñI",  
  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install mercurial") unless hgpath
    ohai("Cloning #{@url}");Fi[	@Gi¿I"  
  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install bazaar") unless bzrpath
    ohai("Cloning #{@url}");Fi[	@Gi‡I"  
  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install fossil") unless fossilpath
    ohai("Cloning #{@url}");Fi[@'I"<var = (var + "B") if var and var.to_s.index("B").nil?.!;FI"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;FI"@var = @var;Fi[[	@•iïI"      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@®iêI"        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@´iÑI"      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[I"$1.to_i;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@{
ieI"L  def function(arglist)
    @var ||= if locate("gcc-4.0") then
      `#{locate("gcc-4.0")} --version` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("gcc-4.2") and locate("gcc-4.2").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("gcc-4.2")} --version` =~ /build (\d{4,})/;Fi[	@{
ilI"S  def function(arglist)
    @var ||= if locate("gcc-4.2") and locate("gcc-4.2").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("gcc-4.2")} --version` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("llvm-gcc") then
      `#{locate("llvm-gcc")} --version` =~ /LLVM build (\d{4,})/;Fi[	@{
isI"  def function(arglist)
    @var ||= if locate("llvm-gcc") then
      `#{locate("llvm-gcc")} --version` =~ /LLVM build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("clang") then
      `#{locate("clang")} --version` =~ /clang version (\d\.\d)/;Fi[I"good_checksum(var);FI"end;FI" ;FI"def function(arglist);FI"var = TestBall.new;Fi[[	@1(iI"    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("61aa838a9e4050d1876a295a9e62cbe6");Fi[	@1(i)I"    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e");Fi[	@1(i9I"L    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("dcbf5f44743b74add648c7e35e414076632fa3b24463d68d1f6afc5be77024f8");Fi[I""assert_nil(var.head.checksum);FI"Bassert_equal("https://github.com/mxcl/homebrew.git", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);FI"3assert_instance_of(HeadSoftwareSpec, var.head);Fi[[	@ã
iπI"å    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@ã
i»I"å    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@ã
i◊I"å    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[I",assert_equal(var.head, var.active_spec);FI".assert_version_equal("HEAD", var.version);FI""assert_nil(var.head.checksum);F@E@Ei[[	@ã
i∑I"π    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@ã
i∆I"π    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@ã
i’I"π    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[@'E@(E@E@E@Ei[[	@ã
i∏I"§    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@ã
i«I"§    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@ã
i÷I"§    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[I"Bassert_equal("https://github.com/mxcl/homebrew.git", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);F@EI"end;Fi[[	@ã
i∫I"ä    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@ã
i…I"ä    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@ã
iÿI"ä    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[@:E@;E@EI"end;FI" ;Fi[[	@ã
iªI"â    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@ã
i I"â    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@ã
iŸI"â    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new;Fi[@;E@EI"end;FI" ;FI"def function(arglist);Fi[[	@ã
iºI"x    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@ã
iÀI"x    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@ã
i⁄I"z    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new
    assert_not_nil(var.stable);Fi[I"assert_nil(var.bottle);F@√7@ƒ7I".assert_version_equal("HEAD", var.version);F@(Ei[[	@ã
iµI"ä    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@ã
iƒI"í    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@ã
i”I"í    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[@©@™@´I"var;FI"end;Fi[[	@?i/I"œ          when :stderr then
            var = $stderr
            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        
        def self.wrap(arglist);Fi[	@iJI"˘        when Twitter::List then
          var[:list_id] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      
      # Take an owner and merge it into the hash with the correct key;Fi[	@iëI"B          var[[var, "screen_name"].compact.join("_").to_sym] = var
        when Twitter::User then
          var[[var, "user_id"].compact.join("_").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      
      # Take a multiple users and merge them into the hash with the correct keys;Fi[@¡7@¬7@√7@ƒ7@[Ei[[	@ã
i¥I"e  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[	@ã
i√I"m  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[	@ã
i“I"m  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[@√7@ƒ7@[E@(E@Ei[[	@ã
i∂I"£    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@ã
i≈I"£    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@ã
i‘I"£    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[I")var.extend(StringInreplaceExtension);FI"(var.change_make_var!("FLAG", "def");FI"8assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var);FI"end;FI" ;Fi[[	I"/data//homebrew_proj/test/test_inreplace.rb;Ti
I"Cclass InreplaceTest < Test::Unit::TestCase
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc";Fi[	@ÖEiI"  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "FLAG = \nmv file_a file_b";Fi[	@ÖEi&I"  
  def function(arglist)
    var = "OTHER=def\nFLAG=abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2 = def";Fi[@E@ÄEI"end;FI" ;FI"def function(arglist);Fi[[	@ÖEiI"A  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension);Fi[	@ÖEiI":  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "FLAG = \nmv file_a file_b"
    var.extend(StringInreplaceExtension);Fi[	@ÖEi'I"D  def function(arglist)
    var = "OTHER=def\nFLAG=abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2 = def"
    var.extend(StringInreplaceExtension);Fi[I"assert(var.universal?);FI"assert(var.i386?.!);F@È%@Í%@Î%i[[	@%iI"<class MachOPathnameTests < Test::Unit::TestCase
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.dylib")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!);Fi[	@%i6I"  
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/a.out")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?);Fi[	@%iDI"  
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[@'@˝%@Ô*@*I"var = (var + 1);Fi[[	@•iåI"        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@®iÜI"        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@´i{I"        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[@'I"!return ((var * @var) / 1000);FI"end;FI" ;FI"def function(arglist);Fi[[	@•iLI"·        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[	@®iAI"÷          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var);Fi[	@´i;I"·        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[@Í%@Î%I"assert(var.dylib?);FI"%assert(var.mach_o_executable?.!);FI"#assert(var.text_executable?.!);Fi[[	@%iI"V    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert((var.arch == :universal))
    assert_match(/Mach-O (64-bit )?dynamically linked shared library/, file(var));Fi[	@%iI"H    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O dynamically linked shared library/, file(var));Fi[	@%i+I"O    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O 64-bit dynamically linked shared library/, file(var));Fi[@'I"after_flush_writes;FI"@var = {};FI"end;FI" ;Fi[[	@n*iI"√            FileUtils.chmod(var, path(var))
          end
          var.rewind
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist);Fi[	@íiGI"∑          ensure
            var.rewind
          end)
        end
        after_flush_writes
        @var = {}
      end
      
      def function(arglist)
        for var in @var do;Fi[	@i›I"™          ensure
            var.rewind
          end
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist);Fi[@Î%@Ï%@Ì%@˛*I"assert(var.mach_o_bundle?);Fi[[	@%iHI""    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var))
  end;Fi[	@%iVI"    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var))
  end;Fi[	@%idI"    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var))
  end;Fi[@'I"good_checksum(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@1(iI"Ô    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|;Fi[	@1(i(I"¯    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|;Fi[	@1(i8I"    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|;Fi[I"var = var.patches[0];FI"#assert_equal(:p1, var.patch_p);FI"end;FI" ;FI"def function(arglist);Fi[[	I"-data//homebrew_proj/test/test_patches.rb;TiI"W  def function(arglist)
    var = Patches.new("http://example.com/patch.diff")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(["http://example.com/patch1.diff", "http://example.com/patch2.diff"])
    assert_equal(2, var.patches.length);Fi[	@ÈEiI"&    assert_equal(2, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(:p0 => "http://example.com/patch.diff")
    assert_equal(1, var.patches.length);Fi[	@ÈEi+I"T  def function(arglist)
    var = Patches.new(:p1 => "http://example.com/patch.diff")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = { :p1 => "http://example.com/patch1.diff", :p0 => "http://example.com/patch0.diff" }
    var = Patches.new(var);Fi[@'@ÀCI"newobj;F@˝'@◊Ci[[	@•iI"Ô      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[	@®iI"Ô      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[	@´iˆI"Ô      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[@'@ÀC@E@˝'@ÕCi[[	@•iıI"T      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[	@®i˛I"T      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[	@´i‰I"T      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[@5I"end;FI"end;FI"end;FI" ;Fi[[	@é
i%I"5      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@é
i/I"7      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@é
i9I"3      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[@ŒD@œD@–D@—DI"Zvar.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master");Fi[[	@5i2I"  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef");Fi[	@5iDI"H  def function(arglist)
    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var);Fi[	@5iXI"E  def function(arglist)
    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var);Fi[@œD@–D@—D@FI"Evar.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[[	@5i3I"  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef")
      var.pull!;Fi[	@5iEI"@    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!;Fi[	@5iYI"=    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!;Fi[@'I"nil;FI"end;FI" ;FI"def function(arglist);Fi[[	@ºiRI"      var = File.mtime(var)
      css_files.each do |arglist|
        return var if File.exists?(var) and (var > File.mtime(var))
      end
      nil
    end
    
    def function(arglist)
      remove(options[:cache_location])
      css_files.each { |arglist| remove(var) };Fi[	@giI"Ó    def function(arglist)
      if var.=~(SPRITE_IMPORTER_REGEX) then
        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@3iI"ˇ        init
        cells_rows.each_with_index do |arglist|
          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end;Fi[@'@à+@M8@™8I"end;Fi[[	@˝ifI"m      version("3.0.x") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end;Fi[	@
iNI"e      version("0.9.x") do |arglist|
        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end;Fi[	@iI"r        end
        def function(arglist)
          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end;Fi[I"Esha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);FI">sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion);FI"Fsha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion);FI"end;FI" ;Fi[[	@Œ#itI""  end
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("spectestball");Fi[	@Œ#iI"\  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("allcatsbottlespectestball");Fi[	@Œ#iI"8  
  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("revisedbottlespectestball");Fi[@5F@6FI"end;FI" ;FI"def function(arglist);Fi[[	@Œ#iuI""  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("spectestball")
  end;Fi[	@Œ#iI"/  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("allcatsbottlespectestball")
  end;Fi[	@Œ#iI";  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("revisedbottlespectestball")
  end;Fi[@I@I"#;F@÷>@◊>I"#;Fi[[	@ŸiI"      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@Åi I"      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@®'i>I"ﬂ      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[@÷>@◊>I"#;FI"# Returns nothing.;FI"def function(arglist);Fi[[	@ŸiI"    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin
        (self.content = File.read(File.join(var, var));Fi[	@Åi"I"*    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["layout"] = "page" unless self.data.has_key?("layout");Fi[	@®'i@I"*    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["layout"] = "post" unless self.data.has_key?("layout");Fi[@'I"
false;FI"end;FI" ;FI"def function(arglist);Fi[[	@ºiCI"    def function(arglist)
      sass_files.zip(css_files).each do |arglist|
        return var if needs_update?(var, var)
      end
      false
    end
    
    def function(arglist)
      staleness_checker.stylesheet_needs_update?(var, File.expand_path(var), importer)
    end;Fi[	@…	i^I"      var ||= "project"
      if var = self[var] and var.templates_directory then
        return File.directory?(File.join(var.templates_directory, var))
      end
      false
    end
    
    def function(arglist)
      var, var = var.split(/\//, 2)
      var = self[var];Fi[	@çiRI"ß        else
          return true
        end
      end
      false
    end
    
    def function(arglist)
      self.env["omniauth.auth"] = auth_hash
      call_app!;Fi[@'I"	true;FI"end;FI"end;FI"end;Fi[[	@~i‡I"Œ      def function(arglist)
        if File.exist?(var) then
          return yes?("A file already exists at '#{path}'. Do you want to overwrite? [y/n]")
        end
        true
      end
    end
  end
end;Fi[	@ΩiI"≤            var = var[var]
            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	@©i%I"ô            else
              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end
end;Fi[@'I"@var = true;TI"end;FI"end;FI" ;Fi[[	@iUI"          end
          Sass::Plugin.on_compilation_error do |arglist|
            Compass.configuration.run_stylesheet_error(var, var.message)
          end
          @var = true
        end
      end
      
      def function(arglist)
        configuration.to_sass_engine_options;Fi[	@Äi;I"          var.step_mother.with_hooks(self, skip_hooks?) do |arglist|
            skip_invoke! if failed?
            var.visit_steps(@var)
          end
          @var = true
        end
      end
      
      # Returns true if one or more steps failed
      def function(arglist);Fi[	@⁄iìI"=            var = @var ? (:after) : (:failure)
            machine.callbacks[var].each { |arglist| var.call(object, context, self) }
          end
        end
        @var = true
      end
    end
    
    # Gets a hash of the context defining this unique transition (including
    # event, from state, and to state).;Fi[@'I"	var);FI"end;FI" ;FI"def function(arglist);Fi[[	@idI"        var = Bundler.settings[:frozen] ? (rubygems_index) : (index)
        var = var.search(Gem::Dependency.new("bundler", VERSION)).last
        var["bundler"] = var if var
      end
      var)
    end
    
    def function(arglist)
      (specs - @var)
    end;Fi[	@Gi®I"˜            var.loaded_from = File.expand_path("..", "(string)")
          end
          (var << var)
        end
        var)
      end
      
      def function(arglist)
        @var ||= (var = installed_specs.dup
        var = Bundler.app_cache;Fi[	@iHI"¶          @var ||= (var = (get_var_file("repeat") or (options.get_var("repeat") or Sass::Script::String.new(NO_REPEAT))).value
          unless VALID_REPEATS.include?(var) then
            raise(SpriteException, "Invalid option for repeat \"#{rep}\" - valid options are #{VALID_REPEATS.join(", ")}")
          end
          var)
        end
        
        def function(arglist)
          (repeat == REPEAT_X)
        end;Fi[@'@ÖF@ÜF@áFI"##;Fi[[	@^i3I"a        var = Hash[var.map { |arglist| [clean_identifier(var), var] }]
        if var.keys.count.!=(var.keys.count) then
          Logger.warn("Duplicate public key identifiers were detected in #keys.")
        end
        var)
      end
      
      ##
      # Cleans a public key identifier.
      # Strip out all spaces, upcase non-email identifiers,;Fi[	@ihI"_            @var ||= (var = {}
            local_hashes.lines.map { |arglist| LocalFile.new(@var, var) }.compact.each do |arglist|
              var.merge!(var.relative_path => (var))
            end
            var)
          end
          
          ##
          # Returns a String of file paths and their md5 hashes.
          def function(arglist);Fi[	@i{I"á            @var ||= (var = {}
            @var.files.all(:prefix => (@var)).each do |arglist|
              var.merge!(var.key.sub("#{@remote_base}/", "") => (var))
            end
            var)
          end
          
          ##
          # Performs a sync operation on a file. When mirroring is enabled
          # and a local file has been removed since the last sync, it will also;Fi[@Ô$I"end;FI"end;FI"end;FI"end;Fi[[	@ÊiI"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@Èi%I"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@ÚiI"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[@'I"end.compact;FI"end;FI" ;FI"def function(arglist);Fi[[	@MiÉI"‹            StepMatch.new(var, var, var, var)
          else
            nil
          end
        end.compact
      end
      
      def function(arglist)
        (@var << JsStepDefinition.new(self, var, var))
      end;Fi[	@@i~I"î        Pathname.new($1)
      else
        # do nothing
      end
    end.compact
  end
  
  def function(arglist)
    tapped_formula_for(:A)
  end;Fi[	I"=data//rspec_proj/spec/example/example_group_hierarchy.rb;Ti6I"¬            nil
          else
            nested_description_from(var)
          end
        end.compact
      end
      
      def function(arglist)
        var.description_args.join
      end;Fi[@'@ô@ö@õI"###;Fi[[	@§"iûI"M        each do |arglist|
          var = var["class"].to_s.split(/\s+/)
          var["class"] = var.push(var).uniq.join(" ")
        end
        self
      end
      
      ###
      # Remove the class attribute +name+ from all Node objects in the NodeSet.
      # If +name+ is nil, remove the class attribute from all Nodes in the;Fi[	@§"i≤I"‰          else
            var.delete("class")
          end
        end
        self
      end
      
      ###
      # Set the attribute +key+ to +value+ or the return value of +blk+
      # on all Node objects in the NodeSet.;Fi[	@§"iËI"‰          var = document.parse(var).first
          var.add_next_sibling(var)
          var.add_child(var)
        end
        self
      end
      
      ###
      # Convert this NodeSet to a string.
      def function(arglist);Fi[@$$@;#I"@var ||= {};FI"end;FI" ;Fi[[	@‰i#I"«    #
    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Flag the document as destroyed and return the atomic path.
    #;Fi[	@–>i÷I"Ω    #
    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Set the session configuration options.
    #;Fi[	@”>iI"∏      #
      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the database session.
      #;Fi[@'I"	end);FI"end;FI" ;FI"def function(arglist);Fi[[	@†iFI"          self.instance_variable_get(var).inject({}) do |arglist|
            var[var[0]] = var[1]
            var
          end
        end)
      end
      
      def function(arglist)
        @var, @var, @var, @var, @var = var
        prepare_default_proc;Fi[	@t
i<I"õ            var if (var / "usr/bin/make").executable?
          end
        end
      end
    end)
  end
  
  def function(arglist)
    prefix.nil?.!
  end;Fi[	@Oi#I"™        end
      else
        MacOS.pkgutil_info(FORGE_PKG_ID) =~ /version: (\d\.\d\.\d).+$/ and $1
      end
    end)
  end
  
  def function(arglist)
    "2.7.4"
  end;Fi[@$$@;#I"@var.!.!;FI"end;FI" ;Fi[[	@i"I"‹      #
      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the number of documents matching the query.
      #;Fi[	@iÚI"–      #
      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the documents for cached queries.
      #;Fi[	@D#irI"˛    #
    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    
    # Extract a single id from the provided criteria. Could be in an $and
    # query or a straight _id query.;Fi[@'I"@var = var;FI"end;FI" ;FI"def function(arglist);Fi[[	@¥iUI"      def function(arglist)
        if Cucumber::WINDOWS and (var and ENV["CUCUMBER_FORWARD_SLASH_PATHS"].!) then
          var = var.gsub(/\//, "\\")
        end
        @var = var
      end
      
      def function(arglist)
        "#{@file}:#{line}"
      end;Fi[	@¢iåI"‡        if var.!=(:failed) and @var.^(var) then
          @var = true
          return
        end
        @var = var
      end
      
      def function(arglist)
        return if @var
        var = nil unless @var[:source];Fi[	@√isI"t      unless ((flat? and (closes_flat?(var).! and closes_flat?(@var).!)) or (var and ((@var.text[0] == ":") and var.full =~ /^#{@var.full[/^\s+/]}\s/))) then
        return next_line if var.text.empty?
        handle_multiline(var)
      end
      @var = var
    end
    
    def function(arglist)
      var and (var.text.empty?.! and (not var.full =~ /^#{@var}/))
    end;Fi[@'@ﬁFI"@var = var;FI"end;FI" ;Fi[[	@<i4I"ˇ              @var = var.with_indifferent_access.sort { |arglist| (var[0].to_i <=> var[0].to_i) }
            else
              @var = var
            end
            @var = var
            @var = var
          end
          
          private
          ;Fi[	@.i˛I"é    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage)
  ;Fi[	@1iÎI"é    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage)
  ;Fi[@$$@;#I"
false;FI"end;FI" ;Fi[[	@SièI"®      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Is the object a number?
      #;Fi[	@SiõI"À      #
      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Remove the instance variable for the provided name.
      #;Fi[	@Si∫I"º      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Get the substitutable version of an object.
      #;Fi[I"# @since 2.2.0;F@W>I"@var ||= {};FI"end;FI" ;Fi[[	@\>i÷I"‹      #
      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be pushed.
      #;Fi[	@\>i‚I"Ÿ      #
      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be set.
      #;Fi[	@\>iÓI"€      #
      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the $pullAll operations or intialize a new one.
      #;Fi[I"$#     include Mongoid::Document;FI"#     embedded_in :person;FI"#   end;FI"#;F@!i[[	@ài-I"R        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[	@àiKI"R        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[	@àigI"O        #   end
        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[@>@>I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@i'I"ä        # @example Validate the session has database.
        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionDatabase.new(var, var)) if no_database_or_uri?(var)
        end;Fi[	@i6I"~        # @example Validate the session has hosts.
        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionHosts.new(var, var)) if no_hosts_or_uri?(var)
        end;Fi[	@iFI"ê        # @example Validate the uri and options.
        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          if both_uri_and_standard?(var) then
            raise(Errors::MixedSessionConfiguration.new(var, var));Fi[I"# defined.;FI"#;FI"# @api private;FI"#;FI"%# @example Validate the options.;Fi[[	@iQI"         end
        
        # Return true if the configuration has no database or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config)
        #;Fi[	@ibI"˙        end
        
        # Return true if the configuration has no hosts or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_hosts_or_uri?(config)
        #;Fi[	@isI"        end
        
        # Return true if the configuration has both standard options and a uri
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config)
        #;Fi[@'@≥#I""";FI"end;FI"end;Fi[[	@OiI"‹            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist);Fi[	@Oi5I"‹            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist);Fi[	@OirI"…            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      if Object.const_defined?(:Magick) then;Fi[@·=@‚=@„=I"#;F@ü=i[[	@ziI"k        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@zi)I"p        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@zi?I"j        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[@'@≥#@Ÿ8@⁄8@€8i[[	@•iI"Å          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[	@®iI"Å          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[	@´iI"Å          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[@'@≥#@â4I"end;FI"end;Fi[[	@ﬂiI"˚        var.mobile do |arglist|
          render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	@çiI"„        var.json do |arglist|
          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	@iHI"∂        end
      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[@'@≥#I"nil;FI"end;FI"end;Fi[[	@YiI"ƒ            var = (var + 1)
            var = var.offset(var)[0]
            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end;Fi[	@bi∞I"Ê            log.debug("Failed to load '#{ext}' programming language for file #{step_def_file}: #{e.message}\n")
            (@var << var)
            nil
          end
        else
          nil
        end
      end
    end
  end;Fi[	@Ú
iI"ˇ            "#{best_match[:example_group].description} #{best_match[:example].description}"
          else
            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist);Fi[@'@œ@–@—I"	####;Fi[[	@liYI"9          var.each { |arglist| add_child_node(var) }
        else
          add_child_node(var)
        end
        var
      end
      
      ####
      # Replace this Node with +node_or_tags+.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@liqI"          unlink
        else
          replace_node(var)
        end
        var
      end
      
      ####
      # Swap this Node for +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@liÁI"t        if var.empty? and ((document.errors.length > var) and var.recover?) then
          var = Nokogiri::HTML::DocumentFragment.parse(var)
          var = var.children
        end
        var
      end
      
      ####
      # Set the Node's content to a Text node containing +string+. The string gets XML escaped, not interpreted as markup.
      def function(arglist);Fi[I"A# Get the value of the object as a mongo friendy sort value.;FI"#;FI"0# @example Get the object as sort criteria.;FI"#   object.__sortable__;FI"#;Fi[[	@.iI"module Mongoid
  module Extensions
    module FalseClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 0.
      #;Fi[	@Si:I"Ô        "#{self}="
      end
      
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #;Fi[	@Ç.iI"module Mongoid
  module Extensions
    module TrueClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 1.
      #;Fi[@'@œ@–@—I"##;Fi[[	@ËiKI"f          rescue => var
            Logger.warn(Errors::Storage::Dropbox::CacheError.wrap(var, "              Could not read session data from cache.\n              Cache data might be corrupt.\n"))
          end
        end
        var
      end
      
      ##
      # Transfers the archived file to the specified Dropbox folder
      def function(arglist);Fi[	@i´I"à            if var.invalid? then
              Logger.warn(("  [skipping] #{local_file.path}\n" + "  Path Contains Invalid UTF-8 byte sequences"))
              return nil
            end
            var
          end
          
          ##
          # Creates a new LocalFile object using the given directory and line
          # from the md5 hash checkup. This object figures out the path,;Fi[	@pi/I"5    unless (var.user or var.password) then
      var.user = escape((ENV["http_proxy_user"] or ENV["HTTP_PROXY_USER"]))
      var.password = escape((ENV["http_proxy_pass"] or ENV["HTTP_PROXY_PASS"]))
    end
    var
  end
  
  ##
  # Returns true when proxy should by bypassed for host.
  def function(arglist);Fi[@‚=@„=I"#;F@ü=I"#;Fi[[	@ziI"]        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@zi*I"e        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@zi@I"b        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[@„=I"#;F@ü=I"#;FI"# @since 3.0.0;Fi[[	@ziI"X        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var);Fi[	@zi+I"V        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|;Fi[	@ziAI"Å        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!;Fi[@'@(I"out(">>");FI"out("endobj");F@∏Di[[	@•i"I"‰            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[	@®i+I"‰            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[	@´iI"‰            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[@'@(I"if var.!=(var) then;F@€DI"end;Fi[[	@•iÊI"Ÿ        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  ;Fi[	@®iÔI"’      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  ;Fi[	@´i’I"Ÿ        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  ;Fi[@'@(@ÛD@ÙDI"if (var == 1) then;Fi[[	@•iîI"        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[	@®ièI"      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[	@´iÉI"        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[@'@(@™EI"end;FI" ;Fi[[	@•iKI"∑      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@®i@I"º          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@´i:I"∑      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[@'@(I"@var = [];FI"end;FI" ;Fi[[	@$iI"Ê              (var.width <=> var.width)
            else
              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist)
          send("#{style}_fit");Fi[	@n*i6I"            # do nothing
          rescue SystemCallError => var
            log("There was an unexpected error while deleting directories: #{e.class}")
          end
        end
        @var = []
      end
      
      def function(arglist)
        FileUtils.cp(path(var), var);Fi[	@iÍI"„            s3_bucket.objects[var.sub(/^\//, "")].delete)
          rescue AWS::Errors::Base => var
            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist)
        begin;Fi[@'@(I"	true;FI"end;FI"end;Fi[[	@-i±I"∂              var.version_requirement = var.requirement
            end
            raise(var)
          end
        end
        true
      end
    end
    
    def function(arglist);Fi[	@ΩiI"»            var = var
            var = var[var]
            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	@©i$I"ß              end
            else
              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end;Fi[@'@(I"	@var;FI"end;FI" ;Fi[[	@Oi5I"Z            @var = []
            ([primary_key] + (column_names - [primary_key])).compact.each_with_index do |arglist|
              (@var << [var, "#{aliased_prefix}_r#{i}"])
            end
          end
          @var
        end
        
        def function(arglist)
          Hash[column_names_with_alias.map { |arglist| [var, var[var]] }];Fi[	@qièI"Ú        @var = var.dup
        var.each_pair do |arglist|
          @var[var.to_sym] = Paperclip::Style.new(var.to_sym, var.dup, self)
        end
      end
      @var
    end
    
    def function(arglist)
      var = @var[:only_process].dup;Fi[	@µi I"            @var.self_and_descendants.detect do |arglist|
              @var.allowed_to?("view_#{o}".to_sym, var)
            end
          end
        end
        @var
      end
      
      # Yields to filter the activity scope
      def function(arglist);Fi[I"3# @param [ Hash ] options The binding options.;FI"#;F@)=@*=I"#;Fi[[	@ˆiI"í          #   name.person.bind(:continue => true)
          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[	@ˇiI"´          #   person.addresses.bind_one(address)
          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[	@ˇi%I"ó          # @example Unbind the document.
          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[@)=@*=I"#;F@,=I"def function(arglist);Fi[[	@ˆiI"Ø          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata
            base.parentize(target);Fi[	@ˇiI"Ø          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base)
            binding do |arglist|;Fi[	@ˇi'I"†          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end;Fi[@'@(I"	else;F@â4I"end;Fi[[	@ﬂiI"-        var.html { |arglist| render(:nothing => (true), :status => 201) }
        var.mobile do |arglist|
          render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  ;Fi[	@çiI"        var.mobile { |arglist| redirect_to(post_path(@var.post_id)) }
        var.json do |arglist|
          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  ;Fi[	@iDI"æ        respond_to do |arglist|
          var.js do |arglist|
            render(:json => ({ :photo_id => (@var.id), :image_url => (@var.url(:thumb_large)), :image_url_medium => (@var.url(:thumb_medium)), :image_url_small => (@var.url(:thumb_small)), :author_id => (var) }), :status => 201)
          end
        end
      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422);Fi[@'@(@)I"out(">>");FI"out("endobj");Fi[[	@•i!I"              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[	@®i*I"              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[	@´iI"              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[@'@(@)I"	self;FI"end;Fi[[	@4i<I"N        else
          Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.parent.author.diaspora_handle} payload_type=#{self.class} parent_id=#{self.parent.id}")
          return
        end
      end
    end
    self
  end
  
  def function(arglist);Fi[	@i‰I":                set_relation(var, get_relation(var, var).substitute(var.substitutable))
              else
                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        
        # Defines the setter method that allows you to set documents;Fi[	@»i9I"Z              var = var.value[0].value.first
              var.value[0].value = ["*"]
              var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["#{match.value[1].value.first}("]), Node.new(:FUNCTION, ["self(", var])])
            end
          end
        end
        self
      end
      
      # Find a node by type using +types+;Fi[@'@(@)I"return var;FI"end;Fi[[	@<iîI"˚              next if var.nil?
              var = var.instance_variable_get("@cell_matrix")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist);Fi[	@1iÓ
I"|          (var << 65533)
          var = []
          var = 1
        end
      end
    end
    return var
  end
  
  #;Fi[	@1i/I"‘          (var << var.&(255).chr)
          (var << (var >> 8).chr)
          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  
  # ====================================================;Fi[@'@(@)@	@i[[	@)iﬁI"∑          rescue Exception
            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist);Fi[	@”iI"˛            var
          else
            raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      
      # Returns whether or not the association should be validated as part of;Fi[	@˙iËI"«          if var =~ /^(\w+)=(.*)$/ then
            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist);Fi[@'@(@@Î9@•?i[[	@™i@I">          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@≠i9I">          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@∞i=I">          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[@'@(@I"L# Resets any errors previously added when invalidating the given object;FI"def function(arglist);Fi[[	@ßi,I"          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?
      end;Fi[	@i)I",            var.each { |arglist| (var << "#{field_name} #{error}") }
          end
          (var * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?
      end;Fi[	@i)I"           "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear
      end;Fi[@Ú0I"end;FI" ;F@â<@@i[[	@_iI"m        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@fiI"m        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@piI"m        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[@GI"#   end;FI"#;F@!@Ò!i[[	@ài.I"`        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@àiLI"`        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@àihI"]        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[I"#   class Game;F@=@=I"#   end;FI"#;Fi[[	@ài}I"ˆ        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[	@àiñI"$        #     has_many :posts
        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.;Fi[	@àiÀI"ˆ        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[@'@(@I"extend(ClassMethods);FI" ;Fi[[	@˘iRI"ç              self[nil]
            end
          end
        end
      end
      
      extend(ClassMethods)
      
      self.reset
    end;Fi[	@Ãi/I"∏        
        def function(arglist)
          File.expand_path(var.location)
        end
      end
      
      extend(ClassMethods)
      
      include(ExampleGroupMethods)
      ;Fi[	I"@data//state_machine_proj/state_machine/integrations/base.rb;TiYI"        # active
        def function(arglist)
          versions.each { |arglist| var.extend(var) if var.active? }
        end
      end
      
      extend(ClassMethods)
      
      def self.included(arglist)
        var.class_eval { |arglist| extend(ClassMethods) };Fi[@®5I"#;FI"# @since 2.1.0;F@¥<I"
begin;Fi[[	@•i4I"Ú      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("bind")
          yield);Fi[	@•iSI"Û      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("build")
          yield);Fi[	@•i¨I"        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("create")
            yield);Fi[@'@(@@.@.i[[	@ˆi#I"7              else
                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[	@iI"T            target.parentize(base)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[	@i$I"                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[@d6I"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@Ji)I"Ê      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@Ji.I"√      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@Ji3I"√      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[@'@(@I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;Fi[[	@<iâI"/            var.blank? ? (var) : (var.convert(var))
          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@JiI"        else
          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@Si}I"Ù          return instance_variable_get("@#{name}")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[@ã.I" ;F@ç.I" ;FI"def function(arglist);Fi[[	@ë.iI"      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end;Fi[	@î.iI"◊      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys
      end;Fi[	@ó.i
I"2    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end;Fi[@p9I"end;FI"end;FI"end;FI"end;Fi[[	@ë.iI"¿      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ó.iI"¿      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ö.iI"ñ      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[I"while (var < var) do;F@?@?@?I"var = (var + 1);Fi[[	@•iCI"    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[	@®i3I"-    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then;Fi[	@´i2I"    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[@⁄?I" ;FI"def function(arglist);FI"
super;F@œ:i[[	@‘:iI"Bclass RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[	@◊:iI"%  
  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[	@⁄:iI"K  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[@'@(@@	I"case var[:format];Fi[[	@Oi’I"1          var[:indent] += var[:indent_increment]
          render_issues(var, var)
          var[:indent] -= var[:indent_increment]
        end
      end
      
      def function(arglist)
        case var[:format]
        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top]);Fi[	@OiﬁI"Â          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then
          var = "";Fi[	@OiI"•          end
        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then
          var = "";Fi[I",var = Category.create(:name => "Root1");FI",var = Category.create(:name => "Root2");FI",var = Category.create(:name => "Root3");FI"var.move_to_child_of(var);F@H4i[[	@N4iKI"ë    (categories(:child_2_1).right.should == 9)
  end
  it("move_to_child_more_than_once_per_parent_rebuild") do |arglist|
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null");Fi[	@N4iaI"z    (Category.roots.last.to_text.should == var)
  end
  it("should be able to rebuild without validating each record") do |arglist|
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var.name = nil
    var.save!(:validate => (false));Fi[	@ø3iãI"ò  
  #rebuild swaps the position of the 2 children when added using move_to_child twice onto same parent
  def function(arglist)
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null");Fi[I"0(categories(:child_2).should == var.parent);FI"6(categories(:child_2).id.should == var.parent_id);FI" var.left.should_not(be_nil);FI"!var.right.should_not(be_nil);FI"$Category.valid?.should(be_true);Fi[[	@N4iI"è  end
  it("assigning_parent_id_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_on_create") do |arglist|;Fi[	@N4i	I"ê  end
  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_id_to_nil_on_create") do |arglist|;Fi[	@N4i5I"ò  end
  it("creating_child_from_parent") do |arglist|
    var = categories(:child_2).children.create!(:name => "Child")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  # create a new top-level node and move single-node top-level tree inside it.;Fi[@…H@ H@ÀH@ÃHI"end;Fi[[	@N4iI"Ÿ  it("assigning_parent_id_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)));Fi[	@N4i
I"œ  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_id_to_nil_on_create") do |arglist|
    var = Category.create!(:name => "New Root", :parent_id => (nil));Fi[	@N4i6I"‡  it("creating_child_from_parent") do |arglist|
    var = categories(:child_2).children.create!(:name => "Child")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  # create a new top-level node and move single-node top-level tree inside it.
  # create a new top-level node and move an entire top-level tree inside it.;Fi[I"assert(Category.valid?.!);FI"end;FI" ;FI"def function(arglist);FI"assert(Category.valid?);Fi[[	@ø3i¶I"¯  def function(arglist)
    assert(Category.valid?)
    Category.update_all("lft = null")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.update_all("rgt = null")
    assert(Category.valid?.!);Fi[	@ø3i¨I"˝  def function(arglist)
    assert(Category.valid?)
    Category.update_all("rgt = null")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.delete(categories(:child_2).id)
    assert(Category.valid?);Fi[	@ø3iπI"    assert(Category.valid?)
    categories(:top_level_2)["lft"] = 0
    categories(:top_level_2).save
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    var = Category.root.to_text
    Category.update_all("lft = null, rgt = null");Fi[@'@(@@	@Y9i[[	@•i:I"◊          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[	@®iCI"◊          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[	@´i)I"◊          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[@'@(@@	I"&if (@var["type"] == "Type0") then;Fi[[	@•i°I"Ø      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else;Fi[	@®iúI"±      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else;Fi[	@´iêI"Ø      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else;Fi[I"H# * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.;FI"E# * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.;FI"#;FI"# Example:;FI"#;Fi[[	I"7data//redmine_proj/plugins/rfpdf/lib/core/rfpdf.rb;Ti=I"q  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text(x, y, header_left, :font_size => 10)
  	#;Fi[	@IiUI"æ  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text_block(left_margin, 85, "question", left_margin, 280,
  #       :font_color => ReportHelper::COLOR_PALETTE[:dark_blue],;Fi[	@Ii‡I"p  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>18</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_title(left_margin, 60, 
  	#       "title:", ;Fi[@¨3@Ï-I"out("endobj");FI"end;F@˚'i[[	@•iÚI"  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@®i˚I"  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@´i·I"  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[@¨3@˝'@ÕC@ŒCI"*Error("Font file not found") if var.!;Fi[[	@•i˜I"?      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[	@®i I"?      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[	@´iÊI"?      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[@¨3@˝'@◊C@ÿCI"putType0(var);Fi[[	@•i	I"·      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[	@®iI"·      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[	@´i¯I"·      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[@¨3I"var = var["cw"];FI"var = "[";FI"B32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };FI"out((var + "]"));Fi[[	@•i'I"        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[	@®i0I"        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[	@´iI"        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[@¨3I"8var = ("<</Type /FontDescriptor /FontName /" + var);FI"'var["desc"].each_pair do |arglist|;FI"/var = (var + (((" /" + var) + " ") + var));FI"end;Fi[[	@•i-I"m          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[	@®i6I"m          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[	@´iI"m          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[@¨3@3@3@3I"öout((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[[	@®iMI"∏    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 [";Fi[	@´i3I"“    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    if (var["CMap"] == "KSCms-UHC-HW-H") then;Fi[	@1iäI"∏    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 [";Fi[@'@(@@	I"var = @var;Fi[[	@•iUI"»      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[	@®iJI"       SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[	@´iDI"»      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[@'@(@@	I"shutup do |arglist|;Fi[[	@é
i'I"7        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[	@é
i1I"3        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[	@é
i;I"3        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[@˘'@˙'I"end;FI"end;FI"end;Fi[[	@•i7I"˚            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[	@®i@I"˚            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[	@´i&I"˚            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[@˘'@∏DI"newobj;F@&II"var = "[";Fi[[	@•i%I"
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[	@®i.I"
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[	@´iI"
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[@˘'@Á2@2I@3I@4Ii[[	@•i,I"k          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[	@®i5I"k          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[	@´iI"k          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[@'@(@@	I"if File.file?(var) then;Fi[[	@<iI".            [lines_around(var, var), var]
          else
            ["# Couldn't get snippet for #{error_line}", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("\n")
            var = [0, (var - 3)].max;Fi[	@„i'I".            [lines_around(var, var), var]
          else
            ["# Couldn't get snippet for #{error_line}", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("\n")
            var = [0, (var - 3)].max;Fi[	@ı
i¢I"
        else
          (@var = :custom
          self.differ_class = load_class(var, "differ", "--diff"))
        end
      end
      
      def function(arglist)
        if File.file?(var) then
          @var = [File.open(var).read.split("\n")].flatten
        else;Fi[@'@(@@	I"var = var.value;Fi[[	@éi3I"5      if var.respond_to?(:declare) then
        var.declare(:font_url, [:path])
        var.declare(:font_url, [:path, :only_path])
      end
    end
    
    def function(arglist)
      var = var.value
      return Sass::Script::String.new("url(#{path})") if absolute_path?(var)
      var = if relative? then;Fi[	@éiMI"P        var.declare(:image_url, [:path])
        var.declare(:image_url, [:path, :only_path])
        var.declare(:image_url, [:path, :only_path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_images_path)}\/(.*)/ then
        var = $1;Fi[	@éiI"U      if var.respond_to?(:declare) then
        var.declare(:generated_image_url, [:path])
        var.declare(:generated_image_url, [:path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_generated_images_path)}\/(.*)/ then
        var = $1;Fi[@d9@e9@f9@g9I"end;Fi[[	@•iI"!  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[	@®iI"!  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[	@´iI"!  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[@e9@f9@g9I"end;FI" ;Fi[[	@•iI"1  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths;Fi[	@®iI">  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = "KozMinPro-Regular-Acro";Fi[	@´iI"0  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths;Fi[@f9@g9I"end;FI" ;FI"def function(arglist);Fi[[	@•iI"F  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths
    var = "ETenms-B5-H";Fi[	@®iI"Q  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = "KozMinPro-Regular-Acro"
    var = SJIS_widths;Fi[	@´iI"E  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths
    var = "KSCms-UHC-H";Fi[I"(AddCIDFonts(var, var, cw, var, var);FI"end;FI" ;FI"def function(arglist);FI"&if (@var["type"] == "Type0") then;Fi[[	@•i3I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "GBK-EUC-H"
    var = { "ordering" => "GB1", "supplement" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else;Fi[	@®i#I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "90ms-RKSJ-H"
    var = { "ordering" => "Japan1", "supplement" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else;Fi[	@´i"I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "KSCms-UHC-HW-H"
    var = { "ordering" => "Korea1", "supplement" => 1 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else;Fi[I"return super(var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@•i:I"≥    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[	@®i*I"µ    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[	@´i)I"≥    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[@Ô.I"var = var.length;FI"var = 0;F@?@?i[[	@•i@I"  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@®i0I"  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@´i/I"  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[@'@(@@	I"@var ||= [];Fi[[	@˚iÇI"£              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= []
        (@var << [var, var])
      end;Fi[	@_iI"¸        unless @var.has_key?(var) then
          @var[var] = var
          scenarios.push(var)
        end
      end
      
      def function(arglist)
        @var ||= []
        var ? (@var.select { |arglist| (var.status == var) }) : (@var)
      end;Fi[	@i:I"É      var.new(var)
    else
      Version.new(var)
    end
  end
  
  def function(arglist)
    @var ||= []
    (@var << var)
  end;Fi[@'@T@Î9@•?@8i[[	@™iAI"¯        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@≠i:I"¯        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@∞i>I"¯        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[@?@?@?I"var = (var + 1);FI"	else;Fi[[	@•iDI"    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[	@®i4I"4    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500);Fi[	@´i3I"    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[@™EI"end;FI" ;FI"def function(arglist);FI"&if (@var["type"] == "Type0") then;Fi[[	@•iMI"œ        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@®iBI"≈        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@´i<I"œ        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[@â8I"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@•iTI"Ÿ    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@®iII"€    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@´iCI"Ÿ    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[@ç2@Ã-@€-I"var = var.length;F@Ci[[	@•i\I"    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[	@®iQI"    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[	@´iKI"    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[@Ã-@€-@F.@CI"var = 0;Fi[[	@•i]I"&    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[	@®iRI"&    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[	@´iLI"&    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[@'@T@Ø?@∞?@±?i[[	@™i8I"X      # Initializes dynamic states
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[	@≠i1I"a      def function(arglist)
        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[	@∞i5I"p      def function(arglist)
        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[@'@T@Œ?@œ?@–?i[[	@ßi#I"~          var = default_error_message_options(var, var, var)
          var.errors.add(var, var, var.merge(var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted";Fi[	@iI"~        if supports_validations? then
          var.errors.add(self.attribute(var), generate_message(var, var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted";Fi[	@i I"ö      # Adds a validation error to the given object
      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted";Fi[@Ã-@ﬂB@MCI"	next;FI"end;Fi[[	@•i–I"l            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@´iøI"l            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@.i™I"_            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var)
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var);Fi[@€-@‹-@CI"var = 0;FI"if var then;Fi[[	@•i^I",    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[	@®iSI",    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[	@´iMI",    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[@'@T@â<@@@@i[[	@_iI"m        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[	@fiI"n        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.;Fi[	@piI"m        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[@CI"var = 0;FI"if var then;F@9!I"var = "LTRB";Fi[[	@•i`I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@®iUI"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@´iOI"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[@'@TI" # Unbind a single document.;FI"#;FI"$# @example Unbind the document.;Fi[[	@ˇiI"                var.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.addresses.unbind_one(document)
          #;Fi[	@iI"1          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| bind_from_relational_parent(var) }
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.posts.unbind_one(document)
          #;Fi[	@iI";              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.preferences.unbind_one(document)
          #;Fi[@'@T@=@I"#;F@?@i[[	@ÅisI"H    # Returns the Hash representation of this Page.
    def function(arglist)
      self.data.deep_merge("url" => (File.join(@var, self.url)), "content" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.;Fi[	@®'iøI"Q    def function(arglist)
      var = { "site" => ({ "related_posts" => (related_posts(var["site"]["posts"])) }), "page" => (self.to_liquid) }.deep_merge(var)
      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.;Fi[	@ÑiI"Ì    # Returns source file path.
    def function(arglist)
      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.;Fi[@'@T@I@I"#;F@÷>i[[	@ŸiI"    # Returns the contents as a String.
    def function(arglist)
      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@ÅiI"¸      @var = var
      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@®'i<I""      if self.categories.empty? then
        self.categories = self.data.pluralized_array("category", "categories")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[@'@T@k@I" ;F@m@i[[	@±iI"⁄      
      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[	@¥iI"      
      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[	@ÉiI"œ      
      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[I"var = "LRT";FI"var = "LR";FI"	else;FI"var = "";F@8i[[	@•ieI"&    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[	@®iZI"&    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[	@´iTI"&    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[I"var = "LR";FI"	else;FI"var = "";F@8@8i[[	@•ifI"       if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[	@®i[I"       if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[	@´iUI"       if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[@8@8@ 8I"end;FI"end;Fi[[	@•iiI"ˇ        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@®i^I"ˇ        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@´iXI"ˇ        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[@8@ 8I"end;FI"end;FI"var = -1;Fi[[	@•ijI"¯      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@®i_I"¯      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@´iYI"¯      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[@ 8I"end;FI"end;FI"var = -1;FI"var = 0;Fi[[	@•ikI"˘        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@®i`I"˘        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@´iZI"˘        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[@'@T@ã@@å@@ç@i[[	@∆iI"à        # depot.
        def function(arglist)
          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[	@∆iI"ﬂ        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[	@∆i I"ﬂ        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[@'@T@™@@´@@¨@i[[	@≤i@I"          return var unless (:head == var)
          var = scm("revno", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[	@∆i7I"d          return var if var.to_s =~ /^\d+$/
          var = scm(authentication, :changes, "-s submitted", "-m 1", "//#{p4client}/...#{rev_no(revision)}")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[	@Ài>I"Y            raise("tried to run `#{command}' and got unexpected result #{result.inspect}")
          end
          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[@'@TI"H# Returns the command that will check out the given revision to the;FI"# given destination.;FI"def function(arglist);Fi[[	@≤iI">        # committed revision.
        def function(arglist)
          :head
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, "--lightweight", revswitch(var), repository, var)
        end;Fi[	@µiI"~        # repository.
        def function(arglist)
          "HEAD"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          [prep_destination(var), scm(verbose, cvs_root, :checkout, cvs_revision(var), cvs_destination(var), variable(:scm_module))].join(" && ")
        end;Fi[	@ÀiI"a        # repository.
        def function(arglist)
          "HEAD"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, arguments, arguments(:checkout), verbose, authentication, "-r#{revision}", repository, var)
        end;Fi[@'@TI"alias :== :eql?;FI" ;FI"def function(arglist);Fi[[	@8i3I"S      
      def function(arglist)
        Git.===(var) and ((uri == var.uri) and ((ref == var.ref) and ((branch == var.branch) and ((name == var.name) and ((version == var.version) and (submodules == var.submodules))))))
      end
      
      alias :== :eql?
      
      def function(arglist)
        var = if local? then
          path;Fi[	@Bi=I":      
      def function(arglist)
        var.instance_of?(Path) and ((path.expand_path(Bundler.root) == var.path.expand_path(Bundler.root)) and (version == var.version))
      end
      
      alias :== :eql?
      
      def function(arglist)
        File.basename(path.expand_path(Bundler.root).to_s)
      end;Fi[	@Gi)I"À      
      def function(arglist)
        Rubygems.===(var)
      end
      
      alias :== :eql?
      
      def function(arglist)
        { "remotes" => (@var.map { |arglist| var.to_s }) }
      end;Fi[@o0I"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;Fi[[	@•iwI"C      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@®ilI"5      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@´ifI"C      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[@o0I"	else;F@ï8@√%I"end;Fi[[	@•iàI"}      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@®iÇI"o      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@´i|I"}      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[@o0@√%I"end;FI"var = -1;FI"var = var;Fi[[	@•iäI"]          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@®iÑI"O          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@´i~I"]          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[@'@TI"alias :create :insert_sql;FI" ;FI"def function(arglist);Fi[[	@Äi¡I"Ã      def function(arglist)
        super
        (var or @var.last_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        execute(to_sql(var, var), var)
      end;Fi[	@ÉiI"Ò      def function(arglist)
        super(var, var)
        (var or @var.insert_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        var = 0
        exec_query(var, var, var) { |arglist| var = var };Fi[	@£i,I"“      def function(arglist)
        super
        (var or @var.last_insert_row_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        exec_query(var, var).rows
      end;Fi[@"D@#DI"@var = @var;F@=5@>5i[[	@•iÀI"É      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[	@®i”I"3        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var);Fi[	@´i∫I"É      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[@'@TI"J# Disconnects from the database if already connected. Otherwise, this;FI"# method does nothing.;FI"def function(arglist);Fi[[	@5	i¡I"      def function(arglist)
        clear_cache!
        reset_transaction
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        clear_cache!
        reset_transaction;Fi[	@ÉiØI"Û        super
        disconnect!
        connect
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super
        @var.close rescue nil;Fi[	@£iïI"Ú      
      def function(arglist)
        @var.!=(false)
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super
        @var = false;Fi[@ÛD@ÙDI"if (var == 1) then;FI"@var = @var;FI"	else;Fi[[	@•iñI"        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@®iëI"	        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@´iÖI"        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[@'@T@;I"split_words(@var);FI"end;Fi[[	@œi9I"≈      
      def function(arglist)
        @var.collect { |arglist| var.inspect }
      end
      
      def function(arglist)
        split_words(@var)
      end
      
      def function(arglist);Fi[	@œièI"π      def function(arglist)
        var.to_s =~ /^(be_(an?_)?)(.*)/
        return [$1, $3]
      end
      
      def function(arglist)
        split_words(@var)
      end
    end
    ;Fi[	@"i|I"·      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end
      
      def function(arglist)
        split_words(@var)
      end
      
      def function(arglist);Fi[@'@T@;@Y9@Z9i[[	@•i;I"˝        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[	@®iDI"˝        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[	@´i*I"˝        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[@'@T@;@d9@e9i[[	@•iI"Ã    var = (@var.length + 1)
    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[	@®iI"¯    Error("CID font already added: family style") unless @var[var].nil?
    var = (@var.length + 1)
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[	@´iI"Ã    var = (@var.length + 1)
    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[@'@T@;I"var = Scoped.root;FI"var = var.children.first;Fi[[	@ø3i€I"ì    assert(categories(:child_2_1).is_ancestor_of?(categories(:child_2)).!)
    assert(categories(:child_1).is_ancestor_of?(categories(:child_2)).!)
    assert(categories(:child_1).is_ancestor_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_ancestor_of?(var))
    var.update_attribute(:organization_id, "different");Fi[	@ø3iıI"õ    assert(categories(:child_2).is_descendant_of?(categories(:child_2_1)).!)
    assert(categories(:child_2).is_descendant_of?(categories(:child_1)).!)
    assert(categories(:child_1).is_descendant_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_descendant_of?(var))
    var.update_attribute(:organization_id, "different");Fi[	@ø3i˝I"@    assert(var.is_or_is_descendant_of?(var))
    var.update_attribute(:organization_id, "different")
    assert(var.is_or_is_descendant_of?(var).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.same_scope?(var))
    var.update_attribute(:organization_id, "different");Fi[@'@T@;@®9I"var;Fi[[	@Ji+I"√      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@Ji0I"√      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@Ji5I"√      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[@à-@â-@ﬂB@MCI"	next;Fi[[	@•iœI"H          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@´iæI"H          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@.i©I"8          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var);Fi[@'@T@;@|9I"var;Fi[[	@Ji÷I"⁄      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@Ji€I"π      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@Ji‡I"π      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[@3I"	else;F@¡8@¬8I"end;Fi[[	@•i÷I"X            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@®iﬁI"J            next
          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@´i≈I"X            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[@3@¬8I"end;FI"var = -1;FI"var = var;Fi[[	@•iÿI"d          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@®i‡I"V          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@´i«I"d          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[I"if var.!=(var) then;F@€DI"end;FI"end;FI" ;Fi[[	@•iËI"√        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[	@®iÒI"Ω        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[	@´i◊I"√        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[@€DI"end;FI"end;FI" ;FI"private;Fi[[	@•iÈI"≥      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@®iÚI"≥      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@´iÿI"≥      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[@Ï-I"out("endobj");FI"end;F@˚'I"newobj;Fi[[	@•iÛI"8    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[	@®i¸I"8    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[	@´i‚I"8    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[@˝'@ÕC@ŒC@II"out(("<</Length " + var));Fi[[	@•i¯I"U    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[	@®iI"U    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[	@´iÁI"U    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[@˝'@◊C@ÿCI"putType0(var);FI"	else;Fi[[	@•i
I"    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[	@®iI"    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[	@´i˘I"    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[@ÕC@ŒC@I@åKI"5out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[[	@•i˘I"s    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then;Fi[	@®iI"s    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then;Fi[	@´iËI"q    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then;Fi[@ŒC@I@åK@üKI"(out(("/Length1 " + var["length1"]));Fi[[	@•i˙I"ë      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[	@®iI"ë      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[	@´iÈI"è      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[I":out((("/Length2 " + var["length2"]) + " /Length3 0"));FI"end;FI"out(">>");F@¬D@√Di[[	@•i I"B      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj");Fi[	@®i	I"B      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj");Fi[	@´iÔI"@      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj");Fi[@y3@¬D@√DI"fclose(var);FI"out("endobj");Fi[[	@•iI"	      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@®iI"	      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@´iÒI"      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[@y3@z3@∏DI"newobj;F@&Ii[[	@•i$I"ˇ            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[	@®i-I"ˇ            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[	@´iI"ˇ            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[@'@T@;@î9@ï9i[[	@ijI"    var = { "description" => "bio", "image" => "image_url", "name" => "first_name", "location" => "location" }
    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[	@isI"     else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[	@i|I"     else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[@y3@z3@{3I"#out("<</Type /FontDescriptor");FI"'out(("/FontName /" + var["name"]));Fi[[	@®iXI"      var = (var + (var["cw"][var].to_s + " "))
    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]");Fi[	@1iïI"      var = (var + (var["cw"][var].to_s + " "))
    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]");Fi[	@1iÉ
I"-    out("<</Registry (Adobe)")
    out("/Ordering (UCS)")
    out("/Supplement 0")
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    var["desc"].each { |arglist| out(((("/" + var.to_s) + " ") + var.to_s)) }
    if var["file"] then;Fi[@y3@z3I"end;FI" ;FI"#;Fi[[	@1iI"∑    out((var + "]"))
    out(("/Count " + var.to_s))
    out(sprintf("/MediaBox [0 0 %.2f %.2f]", var, var))
    out(">>")
    out("endobj")
  end
  
  #
  	# Adds fonts
  	# putfonts;Fi[	@1i°I"ö    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>")
    out("endobj")
  end
  
  #
  	# putimages
  	# @access protected;Fi[	@1iÛI"Ö    out("2 0 obj")
    out("<<")
    putresourcedict
    out(">>")
    out("endobj")
  end
  
  #
  	# putinfo
  	# @access protected;Fi[@¬D@√DI"fclose(var);FI"out("endobj");FI"end;Fi[[	@•iI"        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@®iI"        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@´iÚI"        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[@√DI"fclose(var);FI"out("endobj");FI"end;FI" @var.each_pair do |arglist|;Fi[[	@•iI"Œ      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@®iI"Œ      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@´iÛI"Œ      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[I"fclose(var);FI"out("endobj");FI"end;F@˙KI"newobj;Fi[[	@•iI"ﬂ      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[	@®iI"ﬂ      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[	@´iÙI"ﬂ      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[@◊C@ÿCI"putType0(var);FI"	else;F@Õ8i[[	@•iI"    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[	@®iI"    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[	@´i˙I"    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[@◊C@3@3@>II";out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[[	@®iNI"§    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 ["
    var["cw"].keys.sort.each do |arglist|;Fi[	@´i4I"∞    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    if (var["CMap"] == "KSCms-UHC-HW-H") then
      var = "8094 8190 500";Fi[	@1iãI"§    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 ["
    var["cw"].keys.sort.each do |arglist|;Fi[@ÿCI"putType0(var);FI"	else;F@Õ8@Œ8i[[	@•iI"      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[	@®iI"      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[	@´i˚I"      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[I"putType0(var);FI"	else;F@Õ8@Œ8@œ8i[[	@•iI"B      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[	@®iI"B      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[	@´i¸I"B      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[@Õ8@Œ8@œ8@–8I"8if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[[	@•iI"G      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[	@®iI"G      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[	@´i˛I"G      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[@Œ8@œ8@–8@6LI"&out("/Encoding /WinAnsiEncoding");Fi[[	@•iI"-        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[	@®iI"-        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[	@´iˇI"-        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[@œ8@–8@6L@?LI"end;Fi[[	@•iI"C      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[	@®iI"C      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[	@´i I"C      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[@–8@6L@?LI"end;FI"	else;Fi[[	@•iI"W        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[	@®iI"W        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[	@´iI"W        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[@6L@?LI"end;FI"	else;F@Ÿ8i[[	@•iI"\        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[	@®iI"\        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[	@´iI"\        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[@?LI"end;FI"	else;F@Ÿ8@⁄8i[[	@•iI"m        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[	@®iI"m        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[	@´iI"m        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[@?L@eLI"end;FI"end;FI"out(">>");Fi[[	@•i I"#            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[	@®i)I"#            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[	@´iI"#            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[@Ÿ8@⁄8@€8@‹8I"6out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[[	@•iI"f            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[	@®i I"f            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[	@´iI"f            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[@⁄8@€8@‹8@zLI"if var["enc"] then;Fi[[	@•iI"{          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[	@®i!I"{          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[	@´iI"{          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[@€8@‹8@zL@ÉLI"if var["diff"].nil?.! then;Fi[[	@•iI"~        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[	@®i"I"~        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[	@´iI"~        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[@‹8@zL@ÉL@åLI"9out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[[	@•iI"°          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[	@®i#I"°          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[	@´i	I"°          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[@zL@ÉL@åL@ïLI"	else;Fi[[	@•iI"Ö          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[	@®i$I"Ö          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[	@´i
I"Ö          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[@ÉL@åL@ïLI"	else;F@Â8i[[	@•iI"t          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[	@®i%I"t          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[	@´iI"t          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[@åL@ïLI"	else;F@Â8I"end;Fi[[	@•iI"a          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[	@®i&I"a          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[	@´iI"a          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[@ïLI"	else;F@Â8I"end;FI"end;Fi[[	@•iI"?          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[	@®i'I"?          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[	@´iI"?          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[@∏DI"newobj;F@&II"var = "[";F@(Ii[[	@•i&I"        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[	@®i/I"        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[	@´iI"        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[@&II"var = "[";F@(I@)II"out("endobj");Fi[[	@•i(I"E        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[	@®i1I"E        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[	@´iI"E        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[I"var = "[";F@(I@)II"out("endobj");FI"newobj;Fi[[	@•i)I"\        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[	@®i2I"\        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[	@´iI"\        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[@(I@)II"out("endobj");FI"newobj;F@2Ii[[	@•i*I"l          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[	@®i3I"l          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[	@´iI"l          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[@)II"out("endobj");FI"newobj;F@2I@3Ii[[	@•i+I"i          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[	@®i4I"i          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[	@´iI"i          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[@2I@3I@4II"end;F@´Di[[	@•i.I"†          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[	@®i7I"†          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[	@´iI"†          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[@3I@4II"end;F@´DI"if var then;Fi[[	@•i/I"ì          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[	@®i8I"ì          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[	@´iI"ì          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[@4II"end;F@´DI"if var then;F@Û;i[[	@•i0I"ó          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[	@®i9I"ó          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[	@´iI"ó          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[@´DI"if var then;F@Û;I"end;F@ı;i[[	@•i2I"l          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[	@®i;I"l          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[	@´i!I"l          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[@Û;I"end;F@ı;I"out("endobj");FI"end;Fi[[	@•i4I"          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[	@®i=I"          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[	@´i#I"          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[@ı;I"out("endobj");FI"end;FI"end;FI"end;Fi[[	@•i6I"˘          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[	@®i?I"˘          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[	@´i%I"˘          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[@Y9@Z9@[9@Ü3I"out(">>");Fi[[	@•i>I"
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[	@®iGI"
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[	@´i-I"
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[@Z9@[9@Ü3I"out(">>");FI"out("endobj");Fi[[	@•i?I"  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[	@®iHI"  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[	@´i.I"  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[@[9@Ü3I"out(">>");FI"out("endobj");FI"newobj;Fi[[	@•i@I"<  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[	@®iII"<  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[	@´i/I"<  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[@'@T@;@«9I"end;Fi[[	@>
i9I"⁄  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@ai,I"ß  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@i1I"¬  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[@'@T@;I"Cucumber.logger;FI"end;Fi[[	@øi4I"§          end
        end
        raise(TagExcess.new(var)) if var.any?
      end
      
      def function(arglist)
        Cucumber.logger
      end
    end
  end;Fi[	@bi°I"ø        else
          log.debug("  * #{file} [NOT SUPPORTED]\n")
        end
      end
      
      def function(arglist)
        Cucumber.logger
      end
      
      def function(arglist);Fi[	@ói†I"¿    def function(arglist)
      var = (@var.support_to_load + @var.step_defs_to_load)
      @var.load_files!(var)
    end
    
    def function(arglist)
      Cucumber.logger
    end
  end
end;Fi[@'@T@;I"broadcast(var);FI"end;Fi[[	@àiI"…      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[	@ài$I"…      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[	@àiiI"Ø      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[@'@T@;I"var = @var;FI"var = @var;Fi[[	@•iVI"¬    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@®iKI"¬    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@´iEI"¬    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[@'@T@;I"@var.language;FI"end;Fi[[	@3i>I"¿      
      def function(arglist)
        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      
      class ExampleRow < Cells;Fi[	@3i¶I"‘        
        def function(arglist)
          "| #{@cells.collect { |c| c.value }.join(" | ")} |"
        end
        
        def function(arglist)
          @var.language
        end
        
        private;Fi[	@ÉiVI"œ      
      def function(arglist)
        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      
      def function(arglist);Fi[@O9@ò4I"	else;F@ö4I"end;Fi[[	@.iI"5  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[	@.i#I"  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end;Fi[	@1iÀI"w  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[@'@T@;@Ù9I"end;Fi[[	@¥iAI"       
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist);Fi[	@3iI"Â          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist);Fi[	@3iÅI"∂              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist);Fi[@'@T@;I"%return if Cucumber.wants_to_quit;FI"	init;Fi[[	@ıi$I"6          @var = true
          @var.dup(var)
        end
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?
        var.visit_background_name(@var, name, file_colon_line(@var), source_indent(first_line_length));Fi[	@¥i&I"Î      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?
        var.visit_tags(@var);Fi[	@3iI"      def function(arglist)
        init
        super
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        cells_rows.each_with_index do |arglist|
          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var));Fi[@'@T@;I"var = 0;FI"var = @var["cw"];Fi[[	@•i<I"ã    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[	@®i,I"ã    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[	@´i+I"ã    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[I"# @since 1.1;FI"#;FI"def function(arglist);FI"@var = var;FI"end;Fi[[	@1i9I"Æ  	#
   	# Set header font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_font, :SetHeaderFont);Fi[	@1iDI"≠  #
   	# Set footer font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_font, :SetFooterFont);Fi[	@1iOI"µ  #
   	# Set language array.
  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_language_array, :SetLanguageArray);Fi[@√:@ƒ:@≈:@∆:I"
retry;Fi[[	@:iI"E          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@:i?I"A          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@:i}I"A          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[@ƒ:@≈:@∆:I"
retry;FI"rescue;Fi[[	@:iI"'          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@:i@I"'          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@:i~I"'          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[@≈:@∆:I"
retry;FI"rescue;F@@i[[	@:iI"(          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@:iAI"(          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@:iI"(          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[@≈:I"end;FI"var = var;FI"end;FI"end;Fi[[	@:iI"             var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@:iEI"             var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@:iÉI"∆            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end
  end;Fi[@∆:I"
retry;FI"rescue;F@@I"end;Fi[[	@:iI"$            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@:iBI"$            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@:iÄI"$            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[I"var = max_value;FI"var = min_value;F@9@9@≥Bi[[	@qiI"7      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	@tiI"=      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	@£iRI"7      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[I"var = min_value;F@9@9@≥B@¥Bi[[	@qiI">      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@tiI">      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@£iSI">      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[@9@≥B@¥B@µBI"var = [];Fi[[	@qiI"ä        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@tiI"ä        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@£iUI"ä        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[@≥B@¥B@µBI"var = [];F@ <i[[	@qiI"Ö        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@tiI"Ö        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@£iVI"Ö        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[@¥B@µBI"var = [];F@ <@<i[[	@qiI"w        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@tiI"w        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@£iWI"w        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[@µBI"var = [];F@ <@<I"return var;Fi[[	@qi I"d        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@tiI"d        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@£iXI"d        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[@ <@<I"return var;FI"end;FI" ;Fi[[	@qi"I"A        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0);Fi[	@tiI"C        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields];Fi[	@£iZI"P        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 };Fi[@<I"return var;FI"end;FI" ;FI"def function(arglist);Fi[[	@qi#I"        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0)
      end;Fi[	@ti I"        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@£i[I">        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 }
        var[:x] = (var * var);Fi[I"# == Example;FI"#;FI"#   class Vehicle;F@R<@#<i[[	@¬i>I"@    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@¬ipI"    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@⁄i˙I"A    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[@-<@.<@/<@0<I"6#   specified, then this will match any to state.;Fi[[	@3<i}I"\    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.;Fi[	@˛iI"    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[	@˛i2I"    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[I"#   class Vehicle;F@ç%@#<@$<I"#       end;Fi[[	@¬i@I"‰    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@¬irI"‰    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@⁄i¸I"÷    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[@PN@ç%@<I"#     end;FI"#   end;Fi[[	@-iI"÷    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@-i)I"÷    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@-iDI"÷    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[@PN@È;I"#;F@“;@”;i[[	@ iI"        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@ iRI"        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@ ivI"
        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[@PN@•1I"#       ...;FI"#     end;FI"#;Fi[[	@ú%iÊI"Û    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize
    #     end;Fi[	@ú%i˜I"    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[	@ú%iI"8    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[@'@T@;I"	self;FI"end;Fi[[	@JiBI"Ñ      @var = nil
      @var = nil
      var
    end
    
    def function(arglist)
      self
    end
    
    def function(arglist);Fi[	@±.iI"®      def function(arglist)
        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end
      
      def function(arglist);Fi[	@Ÿi%I"ß      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end
      
      alias :arguments :argument;Fi[@ç%@<I"#     end;FI"#   end;FI"#;Fi[[	@-iI"&    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@-i*I"ÿ    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[	@-iEI"ÿ    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[@'@T@;I"(@var or @var);FI"end;Fi[[	@8i≈I"¥          var = uri
        end
        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist);Fi[	@fiI"◊      @var = var
      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "You are not authorized to access this page.")
    end
    
    def function(arglist)
      (@var or @var)
    end
  end
end;Fi[	@3iÖI"∆        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist);Fi[@«@»@…I"#;F@›;i[[	@¬iBI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@¬itI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@ú%iüI"    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[@'@T@;I"
yield;FI"end;Fi[[	@-iWI"ä    
    def function(arglist)
      Gem.refresh
    end
    
    def function(arglist)
      yield
    end
    
    def function(arglist);Fi[	@biXI"{    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end
  end
end;Fi[	@UiI"±        @var = StringScanner.new(var)
        @var = 1
        @var = nil
      end
      
      def function(arglist)
        yield
      end
      
      def function(arglist);Fi[@»@I I"#;F@›;@ﬁ;i[[	@¬iCI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@¬iuI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@ú%i†I"    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[I"#       event :disable do;F@6I"#       end;FI"#     end;FI"#   end;Fi[[	@¬iPI"2    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	@¬i}I"2    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	@ú%iîI"Ú    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly;Fi[@'@T@;@4@I"end;Fi[[	@∂i(I"6      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      
      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE;Fi[	@êiªI"˝        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end
    end;Fi[	@£i:I"Ò      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      
      #:nodoc:;Fi[@Œ?@œ?@–?@—?I""Transition halted";Fi[[	@ßi%I"G        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ");Fi[	@iI".        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          var = [];Fi[	@i"I"É        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ");Fi[@œ?@–?@—?@»NI"	else;Fi[[	@ßi&I"G      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end;Fi[	@iI"N      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          var = []
          var.errors.each_pair do |arglist|;Fi[	@i#I"G      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end;Fi[@M8@™8I"end;FI"
super;FI"end;Fi[[	@˝ihI"9          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@
iPI"1          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@iI"Y          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
      ;Fi[@M8@N8I"	else;FI"
super;FI"end;Fi[[	@™i<I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@≠i5I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@∞i9I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[@™8I"end;FI"
super;FI"end;FI"end;Fi[[	@˝iiI"Â        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@
iQI"Â        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@iI"        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
      
      version("2.0.x") do |arglist|;Fi[@Û8@Ù8@8I"end;FI" ;Fi[[	@™iI"¸      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@≠iI"¸      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@∞iI"¸      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[@8I"end;FI" ;F@8I"def function(arglist);Fi[[	@™iI"u      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default;Fi[	@≠iI"%      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value
      end;Fi[	@∞iI"#      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default
      end;Fi[@Ø?@∞?@±?@N8I"	else;Fi[[	@™i:I"5        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@≠i3I"!        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@∞i7I"!        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[@N8I"	else;FI"
super;FI"end;FI"end;Fi[[	@™i=I"O      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@≠i6I"O      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@∞i:I"O      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[@Î9@•?@8I"end;FI" ;Fi[[	@™iCI"E        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@≠i<I"E        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@∞i@I"E        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[@8I"end;FI" ;F@®+@©+i[[	@™iEI"ü      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] });Fi[	@≠i>I"y      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|;Fi[	@∞iBI"°      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } });Fi[@È;I"#;F@“;@”;I"#;Fi[[	@ iI"!        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@ iSI"!        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@ iwI"         # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[@“;@”;I"#;F@Ã1@Õ1i[[	@ iI"D        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@ iUI"D        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@ iyI"D        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[@”;I"#;F@Ã1@Õ1@Œ1i[[	@ iI"<        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@ iVI"<        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@ izI"<        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[@<I"#     end;FI"#   end;FI"#;FI".#   states = Vehicle.state_machine.states;Fi[[	@-iI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">
    #   ;Fi[	@-i+I"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@-iFI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[@å6@∞;@±;@˙7I"end;Fi[[	@ˇ1iI"
      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@8iI"-    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@2iI"    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[@'@T@;@a:I"end;Fi[[	@∂i$I"ˆ      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[	@êi∑I"
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist);Fi[	@£i6I"ˆ      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[@Û1@Ù1@¶;I"end;FI" ;Fi[[	@˘1iI"%      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection containing the followed user
      #;Fi[	@¸1iI"+      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection of lists that were added to
      #;Fi[	@ˇ1iI"      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # The user who mentioned a user
      #;Fi[@'@T@;@m:I"end;Fi[[	@∂i I"¬        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[	@êi≥I"ô          var = "#outside_transaction? is deprecated. This method was only really used internally, but you can use #transaction_open? instead."
          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist);Fi[	@£i2I"’      
      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[@'@T@;I"@var.clear;FI"end;Fi[[	@Øi¬I"≤      
      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[	@Øi∆I"¢      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[	@Øi I"¢      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[@˘7@˙7I"end;FI"end;FI" ;Fi[[	@ˇ1i I"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user
      #;Fi[	@8iI"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets
      #;Fi[	@2iI"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user
      #;Fi[@Ô,@,@Ò,I" # @return [Twitter::Cursor];FI"'# @overload friend_ids(options={});Fi[[	@ü;iI"Ã      include(Twitter::API::Utils)
      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@ü;i I"      # Returns a cursored collection of user objects for users following the specified user.
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@ü;iI":      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[@'@T@;I")reflection.active_record_primary_key;FI"end;Fi[[	@]iI"        def function(arglist)
          var = super
          klass.connection.select_all(var.arel, "SQL", var.bind_values)
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        def function(arglist);Fi[	@`iI"Í      class HasMany < CollectionAssociation
        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
      end
    end;Fi[	@fiI"Ó      class HasOne < SingularAssociation
        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        private;Fi[@Ô,@,@Ò,I";# @param options [Hash] A customizable set of options.;FI"Í# @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;Fi[[	@É0iI"=      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).;Fi[	@É0i2I"?      # Search for places that can be attached to a {Twitter::API::Tweets#update}
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.;Fi[	@É0iLI"Õ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.;Fi[@,@Ò,@úO@ùOI"[#   Returns an array of numeric IDs for every user the authenticated user is following;Fi[[	@ü;iI"Ë      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@ü;iI"Ï      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@ü;i I"Ó      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[@'@T@;I"
super;FI"@var = false;Fi[[	@t)iI"∑        set_inverse_instance(var)
        @var = true if var
        self.target = var
      end
      
      def function(arglist)
        super
        @var = false
      end
      ;Fi[	@;iI"•    def self.reset_runtime(arglist)
      var, self.runtime = runtime, 0
      var
    end
    
    def function(arglist)
      super
      @var = false
    end
    ;Fi[	@‘i!I"           @var.puts(html_header)
          @var.puts(report_header)
          @var.flush
        end
        
        def function(arglist)
          super
          @var = false
          @var = (@var + 1)
          unless (example_group_number == 1) then;Fi[@,@Ò,@∞O@±OI""# @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[[	@É0i I"ˆ      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).
      # @option options [String] :granularity ('neighborhood') This is the minimal granularity of place types to return and must be one of: 'poi', 'neighborhood', 'city', 'admin' or 'country'.;Fi[	@É0i3I"m      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.
      # @option options [String] :ip An IP address. Used when attempting to fix geolocation based off of the user's IP address.;Fi[	@É0iMI"ì      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.;Fi[@Ò,@úO@ùO@∫OI"#;Fi[[	@ü;iI"      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@ü;iI"      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@ü;i!I"      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@'@T@U@V@}0i[[	@i˝I"H      #     Twitter.list_remove_members(7505382, 8863586, [813286, 18755393])
      def function(arglist)
        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@É0ipI"µ      #   Twitter.place_create(:name => "@sferik's Apartment", :token => "22ff5b1f7159032cf69218c4d8bb78bc", :contained_within => "41bcb736f84a799e", :lat => "37.783699", :long => "-122.393581")
      def function(arglist)
        object_from_response(Twitter::Place, :post, "/1.1/geo/place.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash];Fi[	@-i˚I"(        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[@'@T@@	@Û8i[[	@™iI"˘      def self.extended(arglist)
        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[	@≠iI"ı      
      def self.matching_ancestors(arglist)
        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[	@∞iI"Û      def self.extended(arglist)
        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[@'@T@…!@GDI"# type.;Fi[[	@MiI"¯      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@Pi•I"#      def function(arglist)
        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@Æ#i*I"¯      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[@y-@z-@{-@™7I"´# @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[[	@ˆ,iII"U      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik
      #   Twitter.retweeted_by_user('sferik');Fi[	@ˆ,i`I"!      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user
      #   Twitter.retweeted_by_me;Fi[	@ˆ,iáI"ï      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.
      # @example Return the 20 most recent retweets posted by users followed by the authenticating user;Fi[I"I#   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;FI"=#   @param options [Hash] A customizable set of options.;FI"def function(arglist);F@·7I"*var.flatten.threaded_map do |arglist|;Fi[[	I"0data//twitter_proj/twitter/api/favorites.rb;TiTI"      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)));Fi[	@PivI"      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)));Fi[	@7iYI"E      #   @example Destroys a saved search for the authenticated user with the ID 16129012
      #     Twitter.saved_search_destroy(16129012)
      # @overload saved_search_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "/1.1/saved_searches/destroy/#{id}.json", var.options)
        end;Fi[@·7@Ó7@Ô7@7I"end;Fi[[	@iII"‚      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::Tweet, :get, "/1.1/lists/statuses.json", var.options)
      end;Fi[	@iI"û      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options)
      end;Fi[	@iI"y      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var)
      end;Fi[@úO@ùO@∫OI"#;FI"=#   @param options [Hash] A customizable set of options.;Fi[[	@ü;iI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs;Fi[	@ü;iI"U      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@ü;i"I"U      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@ùO@∫OI"#;F@PI"-#   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@ü;iI"      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids;Fi[	@ü;iI"≈      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@ü;i#I"≈      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[I">#   @example Return the authenticated user's friends' IDs;FI"#     Twitter.friend_ids;FI"-# @overload friend_ids(user, options={});FI"W#   Returns an array of numeric IDs for every user the specified user is following;FI"#;Fi[[	@ü;iI"
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@ü;iI"œ      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@ü;i*I"œ      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[@,P@-P@.PI"#;FI"`#   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[[	@ü;iI"÷      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@ü;iI"o      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@ü;i+I"o      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@-P@.PI"#;F@9PI"=#   @param options [Hash] A customizable set of options.;Fi[[	@ü;iI"»      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs;Fi[	@ü;iI"o      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@ü;i,I"o      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@.PI"#;F@9P@CPI"Õ#   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@ü;iI"Ω      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs
      #     Twitter.friend_ids('sferik');Fi[	@ü;iI"o      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@ü;i-I"o      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[@}0@~0@&9@[?I"def function(arglist);Fi[[	@iI"      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop);Fi[	@iI"      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|;Fi[	@iI"7        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then;Fi[@~0@&9@[?@VPI"+var = Twitter::API::Arguments.new(var);Fi[[	@iI"`      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then;Fi[	@iI"j      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::User, var, var, merge_user(var.options, var));Fi[	@iI"h      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name));Fi[@Ñ;@Ö;@Ü;@á;I"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	@ˆ,i(I"Î      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={});Fi[	@ˆ,i@I"      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@ˆ,iXI"˝      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[@Ö;@Ü;@á;@hPI"&# @return [Array<Twitter::Tweet>];Fi[[	@ˆ,i)I"F      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@ˆ,iAI"Q      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.;Fi[	@ˆ,iYI"x      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[I"/var[var] = Twitter::Size.fetch_or_new(var);FI"var;FI"end;FI"end;FI"end;Fi[[	@iI"⁄    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	@DiI"Í      # @return [Array<Twitter::Size>]
      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	@iI"‘    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi
