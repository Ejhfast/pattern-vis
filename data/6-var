[{:lociüÕ:projects[I"activemodel_proj:ETI"activerecord_proj;TI"backup_proj;TI"bundler_proj;TI"cancan_proj;TI"capistrano_proj;TI"compass_proj;TI"cucumber_prok;TI"devise_proj;TI"diaspora_proj;TI"haml_proj;TI"homebrew_proj;TI"jekyll_proj;TI"mongoid_proj;TI"nokogiri_proj;TI"omni_proj;TI"paperclip_proj;TI"redmine_proj;TI"rescue_proj;TI"rspec_proj;TI"sinatra_proj;TI"SiriProxy_proj;TI"state_machine_proj;TI"twitter_proj;TI"whenever_proj;T:options[I"
--var;TI"
--fun;TI"--fargs;T[[I"end;FI"end;FI"end;FI"end;FI"end;FI"end;Fi§[§[	I":data//activerecord_proj/active_record/aggregations.rb;TicI"Ø          else
            var.each { |arglist| self[var.first] = var.send(var.last) }
            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	I"Vdata//activerecord_proj/active_record/associations/has_one_through_association.rb;TiI"ª              var.update(var)
            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	@2iI"ù            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	I"[data//activerecord_proj/active_record/associations/preloader/collection_association.rb;TiI"±            var.loaded!
            var.target.concat(var)
            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/associations/preloader/singular_association.rb;TiI"Ø            var = var.association(reflection.name)
            var.target = var
            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/attribute_methods/serialization.rb;TiÉI"}            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/connection_adapters/postgresql/array_parser.rb;Ti]I"≈        def function(arglist)
          unless (var.length == 0) then
            var.! and (var == "NULL") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/postgresql/cast.rb;TièI"Å            var
          else
            "\"#{value.gsub(/"/, "\\\"")}\""
          end
        end
      end
    end
  end
end;Fi[	I"bdata//activerecord_proj/active_record/connection_adapters/postgresql/referential_integrity.rb;TiI"˙              end.join(";")) rescue execute(tables.collect do |arglist|
                  "ALTER TABLE #{quote_table_name(name)} ENABLE TRIGGER USER"
                end.join(";"))
            end
          end
        end
      end
    end
  end
end;Fi[	@Fi I"≤                  "ALTER TABLE #{quote_table_name(name)} ENABLE TRIGGER USER"
                end.join(";"))
            end
          end
        end
      end
    end
  end
end;Fi[	I"5data//activerecord_proj/active_record/railtie.rb;TiEI"ó                self.connection.schema_cache = var
              else
                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end
    
    initializer("active_record.set_configs") do |arglist|;Fi[	I"=data//activerecord_proj/active_record/scoping/default.rb;TiqI"                    var.merge(unscoped { |arglist| var.call })
                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist);Fi[	@NiÜI"á            yield)
          ensure
            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	I";data//activerecord_proj/active_record/scoping/named.rb;TiòI"‡            var = var.respond_to?(:call) ? (unscoped { |arglist| var.call(*var) }) : (var)
            var = all.merge(var)
            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/storage/ftp.rb;TidI"ñ            var.mkdir(var.join("/"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"-data//backup_proj/backup/storage/sftp.rb;TiVI"†            var.mkdir!(var.join("/"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/cloud/base.rb;TiúI"                else
                  MUTEX.synchronize do |arglist|
                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end
        
        class LocalFile;Fi[	@\i»I"•              var if var.unpack("U").!.! rescue @var = true
                "\xEF\xBF\xBD"
            end.join
          end
        end
      end
    end
  end
end;Fi[	I"(data//bundler_proj/bundler/graph.rb;TiéI"’          rescue ArgumentError => var
            $stderr.puts("Unsupported output format. See Ruby-Graphviz/lib/graphviz/constants.rb")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	I"7data//bundler_proj/bundler/source/git/git_proxy.rb;Ti}I"˝            in_path { |arglist| yield }
          else
            raise(GitError, "The git source #{uri} is not yet checked out. Please run `bundle install` before trying to start your application")
          end
        end
      end
    end
  end
end;Fi[	I"8data//bundler_proj/bundler/source/path/installer.rb;Ti#I"            Bundler.mkdir_p("#{Bundler.rubygems.gem_dir}/bin")
            spec.executables.each do |arglist|
              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end
end;Fi[	@gi$I"”            spec.executables.each do |arglist|
              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end
end;Fi[	I".data//bundler_proj/bundler/source/path.rb;TiªI"Ì            var = " at #{$1}" if var.inspect =~ /@(.*:\d+)/
            var = "#{type} hook#{location} failed for #{installer.spec.full_name}"
            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	I"@data//bundler_proj/bundler/vendor/thor/actions/directory.rb;Ti^I"¿            var = base.template(var, var[(0..-4)], config, &@var)
          else
            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//bundler_proj/bundler/vendor/thor/actions/inject_into_file.rb;TiYI"“          if (var or var.include?(replacement).!) then
            var.gsub!(var, var)
            File.open(destination, "wb") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	I"?data//cancan_proj/cancan/model_adapters/mongoid_adapter.rb;Ti&I"ﬁ                var.or(var.conditions)
              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ui'I"ﬁ              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods;Fi[	@ui(I"˚                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods
  include(CanCan::ModelAdditions::ClassMethods);Fi[	I"%data//cancan_proj/cancan/rule.rb;TiÄI"„                end
              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"/data//capistrano_proj/capistrano/cli/ui.rb;Ti#I"∫            var.default = "y"
            var.validate = /(y(es)?)|(no?)|(a(bort)?|\n)/i
            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	I"Ldata//capistrano_proj/capistrano/configuration/actions/file_transfer.rb;Ti.I"Ò          execute_on_servers(var) do |arglist|
            var = var.map { |arglist| sessions[var] }
            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/configuration/actions/invocation.rb;TiI"w            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I">data//capistrano_proj/capistrano/configuration/loading.rb;TijI"F                  instance_eval(&var[:proc])
                else
                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,;Fi[	I"Cdata//capistrano_proj/capistrano/recipes/deploy/scm/accurev.rb;Ti~I"Æ          
          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	I"Adata//capistrano_proj/capistrano/recipes/deploy/scm/darcs.rb;Ti[I"j            nil
          else
            "-v"
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//capistrano_proj/capistrano/recipes/deploy/scm/perforce.rb;TiÜI"t            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	I"7data//capistrano_proj/capistrano/recipes/deploy.rb;TiyI"¬                :perforce
              else
                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@èizI"Ù              else
                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your;Fi[	@èi{I"ı                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your
# own dependencies.;Fi[	I"5data//compass_proj/compass/configuration/data.rb;Ti∞I"”        else
          if (var.size > 0) then
            raise(Error, "Illegal configuration attributes: #{illegal_attrs.map { |a| a.inspect }.join(", ")}")
          end
        end
      end
    end
  end
end;Fi[	I"8data//compass_proj/compass/configuration/helpers.rb;Ti1I"                     Compass::AppIntegration.lookup(var).configuration
                  else
                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end
      ;Fi[	@ôi2I"˜                  else
                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end
      
      # Support for testing.;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/row_fitter.rb;TiPI"                        var = true
                        (var << var)
                        throw(:done)
                      end
                    end
                  end
                end
              end
            end
          end while var
        end;Fi[	I"Idata//compass_proj/compass/sass_extensions/sprites/sprite_methods.rb;TiÄI"¯        def function(arglist)
          if options[:compass] and (options[:compass][:logger] and options[:quiet].!) then
            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	I":data//cucumber_prok/cucumber/formatter/interceptor.rb;Ti@I"}            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//cucumber_prok/cucumber/wire_support/wire_protocol/requests.rb;TipI"á          
          def function(arglist)
            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	I"7data//devise_proj/devise/models/authenticatable.rb;Ti«I"∫          loop do |arglist|
            var = Devise.friendly_token
            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	I"8data//diaspora_proj/controllers/users_controller.rb;TiMI":                    flash[:notice] = I18n.t("users.update.follow_settings_changed")
                  else
                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end
      end
    else;Fi[	@≠iNI"                  else
                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end
      end
    else
      if var = params[:reorder_aspects] then;Fi[	I"#data//homebrew_proj/cleaner.rb;Ti:I"◊              var.unlink unless @var.skip_clean?(var)
            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end
class Pathname;Fi[	@≤i;I"«            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end
class Pathname
  alias_method(:orig_unlink, :unlink);Fi[	I",data//homebrew_proj/extend/fileutils.rb;TiCI"            end
          else
            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	I"data//homebrew_proj/keg.rb;Ti˘I"Â            unless resolve_any_conflicts(var) then
              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	@∫i˙I"≤              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	I"1data//homebrew_proj/keg_fix_install_names.rb;TiI"                  system(MacOS.locate("install_name_tool"), "-change", var, var, var)
                else
                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@øiI"¡                else
                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end
  end
  ;Fi[	@øiI"∂                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end
  end
  
  private;Fi[	I"1data//jekyll_proj/jekyll/migrators/drupal.rb;Ti4I"„              var.puts("layout: refresh")
              var.puts("refresh_to_post_id: /#{(time.strftime("%Y/%m/%d/") + slug)}")
              var.puts("---")
            end
          end
        end
      end
    end
  end
end;Fi[	@∆i5I"π              var.puts("refresh_to_post_id: /#{(time.strftime("%Y/%m/%d/") + slug)}")
              var.puts("---")
            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/atomic/paths/embedded/many.rb;Ti'I"˙            var = parent.atomic_position
            var = document.new_record? ? ("") : (".#{document._index}")
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}#{locator}"
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/atomic/paths/embedded/one.rb;Ti&I"»          def function(arglist)
            var = parent.atomic_position
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}"
          end
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/config/validators/option.rb;TiI"À        def function(arglist)
          unless Config.settings.keys.include?(var.to_sym) then
            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/criterion/scoping.rb;TiëI"ƒ        var.each do |arglist|
          send(var).reject! do |arglist|
            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/date.rb;Ti?I"*          unless var.blank? then
            var = var.__mongoize_time__
            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end
::Date.__send__(:include, Mongoid::Extensions::Date)
::Date.__send__(:extend, Mongoid::Extensions::Date::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/time.rb;TiII"%            ::Time.at(var.to_i, var).utc)
          rescue ArgumentError
            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end
::Time.__send__(:include, Mongoid::Extensions::Time)
::Time.__send__(:extend, Mongoid::Extensions::Time::ClassMethods);Fi[	I">data//mongoid_proj/lib/mongoid/fields/validators/macro.rb;TiCI"          var.keys.each do |arglist|
            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	@›iDI"‡            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/indexes/validators/options.rb;TiLI"⁄            next if (var == :options)
            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	@‚iMI"¥            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/nested_attributes.rb;Ti6I"Ê          re_define_method(var) do |arglist|
            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ái7I"π            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/bit.rb;TiI"}            end
            execute("$bit")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/persistence/atomic/operation.rb;TiâI"ù            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/pop.rb;TiI"©              (value > 0) ? (var.pop) : (var.shift)
              execute("$pop")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@ÚiI"z              execute("$pop")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/pull.rb;TiI"ñ              var.delete(value)
              execute("$pull")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@˜iI"{              execute("$pull")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/persistence/atomic/pull_all.rb;TiI"∑              var.delete_if { |arglist| value.include?(var) }
              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@¸iI"~              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/persistence/atomic/rename.rb;TiI"ö            execute("$rename")
            document.remove_change(value)
            document[value]
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/sets.rb;TiI"ë            document[field] = value
            execute("$set")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/persistence/atomic/unset.rb;TiI"∏          prepare do |arglist|
            fields.each { |arglist| document.attributes.delete(var) }
            execute("$unset")
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/insert.rb;TiI"–                parent.insert
              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"≤              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"ü                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/remove.rb;TiI"              parent.remove_child(var) if notifying_parent?
              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"«              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"ü                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/insert.rb;TiI"§          prepare do |arglist|
            collection.insert(var.as_document)
            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/update.rb;TiI"˝              collection.find(selector).update(updates)
              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"≈              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"ñ                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/upsert.rb;TiI"¿        def function(arglist)
          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/bindings/embedded/in.rb;Ti8I"ˇ                target.do_or_do_not(metadata.inverse(target)).delete(base)
              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@%i9I"¥              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@%i:I"°                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/many.rb;Ti-I"Ã          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/one.rb;Ti1I"Œ          def function(arglist)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	@/i2I"Æ            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/in.rb;Ti>I"Ê                  target.__send__(var).delete(base)
                else
                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@4i?I"∂                else
                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@4i@I"°                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@4iAI"p                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many.rb;Ti!I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many_to_many.rb;Ti/I"Ã              end
              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	@@i0I"∫              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/one.rb;Ti#I"ª          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/builders/embedded/in.rb;TiI"Æ              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@HiI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/embedded/many.rb;Ti!I"l              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/builders/embedded/one.rb;TiI"Æ              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@PiI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Pdata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/many.rb;Ti®I"≤              var.assign_attributes(var, var)
            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ui©I"Ñ            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Odata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/one.rb;Ti~I"´          # @since 2.0.0
          def function(arglist)
            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/referenced/in.rb;TiI"‘            return object unless query?
            var = var ? (var.constantize) : (metadata.klass)
            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/builders/referenced/many.rb;TiI"˘            return [] if object.is_a?(Array)
            var = metadata.criteria(Conversions.flag(object, metadata), base.class)
            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/builders/referenced/many_to_many.rb;Ti%I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/builders/referenced/one.rb;TiI"Â            return object unless query?
            return nil if base.new_record?
            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/relations/cascading/delete.rb;Ti(I"∂              relation.clear
            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	@ii)I"ô            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/destroy.rb;Ti'I"´              relation.each { |arglist| var.destroy }
            else
              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	@ni(I"z            else
              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/cascading/restrict.rb;Ti#I"√        def function(arglist)
          unless relation.blank? then
            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/relations/constraint.rb;Ti+I"ó            var.map! { |arglist| var.mongoize(var) }
          else
            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/embedded/batchable.rb;TiBI"ë            var.freeze
            var.destroyed = true
            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/options.rb;TiI"¬        var.keys.each do |arglist|
          if var.include?(var).! then
            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	I"<data//nokogiri_proj/nokogiri/html/sax/parser_context.rb;TiI"x            super
          else
            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/pp/node.rb;Ti1I"v              end
            end
            var.breakable
          end
        end
      end
    end
  end
end;Fi[	I"3data//nokogiri_proj/nokogiri/xml/sax/parser.rb;Ti`I"æ          var.upcase!
          unless ENCODINGS[var] then
            raise(ArgumentError.new("'#{encoding}' is not a valid encoding"))
          end
        end
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/xml/sax/parser_context.rb;TiI"à            io(var, Parser::ENCODINGS[var])
          else
            memory(var)
          end
        end
      end
    end
  end
end;Fi[	I"1data//paperclip_proj/paperclip/storage/s3.rb;TiI"∑            var[$1.downcase] = var
          else
            var[var.to_s.downcase.sub(/^x-amz-/, "").tr("-", "_").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	I"Zdata//redmine_proj/plugins/acts_as_activity_provider/lib/acts_as_activity_provider.rb;Ti>I"É              end
            end
            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	I"Ldata//redmine_proj/plugins/acts_as_searchable/lib/acts_as_searchable.rb;Ti^I"{            end
            var = var.all
            [var, var]
          end
        end
      end
    end
  end
end;Fi[	I"2data//redmine_proj/plugins/rfpdf/lib/tcpdf.rb;TizI"∆              Error(("Unsupported font type: " + var))
            else
              self.send(var, var)
            end
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@îi◊I"ˆ                var.gsub!(/[\t\r\n\f]/, "")
                var.gsub!(/&nbsp;/, " ")
                Write(@var, unhtmlentities(var), "", var)
              end
            end
          end
        end
      end
    end
    Ln(@var) if var
  end;Fi[	I">data//redmine_proj/redmine/core_ext/string/conversions.rb;TiI"ó          # Object#to_a removed in ruby1.9
          def function(arglist)
            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	I"-data//redmine_proj/redmine/export/pdf.rb;TiØI"w            return var
          else
            return nil
          end
        end
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/views/my_page/block.rb;TiI"¨            var = File.basename(var).split(".").first.gsub(/^_/, "")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//redmine_proj/redmine/wiki_formatting/textile/formatter.rb;TisI"ﬂ                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@¢itI"n              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//redmine_proj/redmine/wiki_formatting/textile/helper.rb;TiI"#              ((javascript_include_tag("jstoolbar/jstoolbar-textile.min") + javascript_include_tag("jstoolbar/lang/jstoolbar-#{current_language.to_s.downcase}")) + stylesheet_link_tag("jstoolbar"))
            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	I"8data//rspec_proj/spec/example/predicate_matchers.rb;Ti-I"÷        predicate_matchers.each_pair do |arglist|
          define_method(var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/example/subject.rb;Ti{I"§            self.__should_not_for_example_group__(var)
          else
            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"6data//rspec_proj/spec/extensions/instance_exec.rb;Ti"I"À            return send(:__instance_exec, *var)
          ensure
            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/matchers/change.rb;Ti4I"j                  "#{@message} should have been changed by at most #{@maximum.inspect}, but was changed by #{actual_delta.inspect}"
                else
                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	I")data//rspec_proj/spec/mocks/proxy.rb;Ti|I"                  @var.superclass.send(var, *var, &var)
                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"4data//rspec_proj/spec/runner/differs/default.rb;TiOI"          
          def function(arglist)
            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/text_mate_formatter.rb;TiI"Ì        def function(arglist)
          var.gsub(/([^:]*\.rb):(\d*)/) do |arglist|
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          end
        end
      end
    end
  end
end;Fi[	I"Pdata//state_machine_proj/state_machine/integrations/data_mapper/observer.rb;Ti¢I"˚                var.state_machines.values
              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|;Fi[	@øi£I"              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|
  include(StateMachine::Integrations::DataMapper::Observer);Fi[	I"Adata//state_machine_proj/state_machine/yard/handlers/base.rb;TiI"è          else
            var = extract_node_name(var)
            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/event.rb;TiI"Ê            var.each do |arglist|
              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@«iI"ƒ              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@«iI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//state_machine_proj/state_machine/yard/handlers/machine.rb;Ti∆I"W            end
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "#{state.qualified_name}?")))
            var.docstring = ["Checks whether #{state.name.inspect} is the current state.", "@return [Boolean] +true+ if this is the current state, otherwise +false+"]
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/state.rb;TiI"Ê            var.each do |arglist|
              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@—iI"ƒ              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@—iI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//state_machine_proj/state_machine/yard/handlers/transition.rb;Ti+I"r            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/error/client_error.rb;TiI"€            if var[:errors] then
              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	@€iI"∫              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	I"6data//twitter_proj/twitter/response/parse_json.rb;TiI"∆        if respond_to?(:parse) then
          unless [204, 301, 302, 304].include?(var[:status]) then
            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	I"7data//whenever_proj/whenever/capistrano/support.rb;Ti I"            var = var.empty? ? ("") : (" --roles #{roles.join(",")}")
            var = "cd #{args[:path]} && #{args[:command]} #{args[:flags]}#{roles_arg}"
            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[@'@(I" ;FI"private;FI" ;FI"def function(arglist);FiI[I[	I"5data//activemodel_proj/active_model/callbacks.rb;Ti4I"à      var.each do |arglist|
        define_callbacks(var, var)
        var.each { |arglist| send("_define_#{type}_model_callback", self, var) }
      end
    end
    
    private
    
    def function(arglist)
      var.class_eval("        def self.before_#{callback}(*args, &block)\n          set_callback(:#{callback}, :before, *args, &block)\n        end\n", "(string)", (126 + 1))
    end;Fi[	I";data//activemodel_proj/active_model/serializers/xml.rb;Ti`I"Ÿ            add_extra_behavior
            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	I"Adata//activemodel_proj/active_model/validations/clusivity.rb;TiI"c      def function(arglist)
        unless (delimiter.respond_to?(:include?) or (delimiter.respond_to?(:call) or delimiter.respond_to?(:to_sym))) then
          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist)
        var = if delimiter.respond_to?(:call) then
          delimiter.call(var);Fi[	I">data//activemodel_proj/active_model/validations/length.rb;Ti5I"3          var = options[MESSAGES[var]]
          var[:message] ||= var if var
          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist)
        (if options[:tokenizer] and var.kind_of?(String) then
          options[:tokenizer].call(var);Fi[	I"Hdata//activerecord_proj/active_record/associations/alias_tracker.rb;Ti$I"„          else
            var
          end
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins)
        var = connection.quote_table_name(var).downcase;Fi[	I"Xdata//activerecord_proj/active_record/associations/preloader/through_association.rb;TiI"R          var.each do |arglist|
            var.map! { |arglist| var.send(source_reflection.name) }.flatten!
            var.compact!
          end
        end
        
        private
        
        def function(arglist)
          Preloader.new(owners, through_reflection.name, through_scope).run
          Hash[owners.map do |arglist|;Fi[	I"Bdata//activerecord_proj/active_record/attribute_assignment.rb;TivI"!          read_time
        else
          (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist)
        if object.class.send(:create_time_zone_conversion_attribute?, name, column) then
          Time.zone.local(*var);Fi[	I"Tdata//activerecord_proj/active_record/attribute_methods/time_zone_conversion.rb;Ti+I"o            generated_attribute_methods.module_eval(var, "(string)", var)
          else
            super
          end
        end
        
        private
        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end;Fi[	@i2I"C        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist)
        var.change(:usec => 0) if var
      end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/abstract/connection_pool.rb;TiEI"        def function(arglist)
          synchronize do |arglist|
            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist)
          @var.synchronize(&var)
        end;Fi[	@i¿I"–            break unless (var <= Base))
          end
          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist)
        @var[Process.pid]
      end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/connection_specification.rb;Ti&I"W            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) }
          raise(AdapterNotSpecified, "#{spec} database is not configured") unless var;Fi[	I"Odata//activerecord_proj/active_record/connection_adapters/mysql_adapter.rb;TiëI"◊          exec_query("BEGIN")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {}
        log(var, var, var) do |arglist|;Fi[	I"9data//activerecord_proj/active_record/query_cache.rb;Ti&I"      rescue Exception => var
        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    
    def function(arglist)
      ActiveRecord::Base.connection_id = var
      ActiveRecord::Base.connection.clear_query_cache;Fi[	I">data//activerecord_proj/active_record/relation/batches.rb;TiMI"·        else
          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    
    def function(arglist)
      "#{quoted_table_name}.#{quoted_primary_key} ASC"
    end;Fi[	I"3data//activerecord_proj/active_record/store.rb;Ti,I"¯      if var.!=(var[var]) then
        send(:"#{var}_will_change!")
        var[var] = var
      end
    end
    
    private
    
    def function(arglist)
      var = send(var)
      unless var.is_a?(ActiveSupport::HashWithIndifferentAccess) then;Fi[	I"-data//bundler_proj/bundler/definition.rb;TiI"”          # do nothing
        end
        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist)
      @var.! and (@var.! and (@var.! and (@var.! and @var.!)))
    end;Fi[	I"(data//bundler_proj/bundler/index.rb;Ti~I"√        @var.uniq!
      else
        raise(ArgumentError, "Source must be an index, not #{index.class}")
      end
    end
    
    private
    
    def function(arglist)
      @var[var]
    end;Fi[	I"+data//bundler_proj/bundler/injector.rb;Ti!I"Ë        return @var)
      ensure
        Bundler.settings[:frozen] = "1" if var
      end
    end
    
    private
    
    def function(arglist)
      @var.map { |arglist| "gem '#{d.name}', '#{d.requirement}'" }.join("\n")
    end;Fi[	I",data//bundler_proj/bundler/installer.rb;TiîI"_          Bundler.ui.warn("Skipped #{skipped} since they already exist."))
        end
        Bundler.ui.warn("If you want to overwrite skipped stubs, use --force.")
      end
    end
    
    private
    
    def function(arglist)
      var = Bundler.bin_path
      var = File.read(File.expand_path("../templates/Executable.standalone", "(string)"));Fi[	I"*data//bundler_proj/bundler/runtime.rb;TiπI"          var.unshift("-I#{File.expand_path("../..", "(string)")}")
        end
        ENV["RUBYOPT"] = var.join(" ")
      end
    end
    
    private
    
    def function(arglist)
      var = Dir["#{cache_path}/*.gem"]
      var = var.delete_if do |arglist|;Fi[	I"Edata//cancan_proj/cancan/model_adapters/active_record_adapter.rb;TixI"O          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact
        if defined? ActiveRecord::Relation and var.any? { |arglist| var.kind_of?(ActiveRecord::Relation) } then;Fi[	@âiNI"Á            return var[/hash='(.*?)'/, 1]
          else
            return var
          end
        end
        
        private
        
        def function(arglist)
          case variable(:scm_verbose)
          when nil then;Fi[	I"Mdata//capistrano_proj/capistrano/recipes/deploy/strategy/remote_cache.rb;TiI"N          super.check do |arglist|
            var.remote.command("rsync") unless copy_exclude.empty?
            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist)
          File.join(shared_path, (configuration[:repository_cache] or "cached-copy"))
        end;Fi[	I"8data//compass_proj/compass/commands/project_base.rb;TiHI"I          if File.directory?(project_directory).! then
            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then
          File.basename(strip_trailing_separator(var[:project_name]));Fi[	I"@data//compass_proj/compass/sass_extensions/sprites/image.rb;TiéI"6          if [hover?, target?, active?].any? then
            PARENT.match(name)
            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end;Fi[	I";data//cucumber_prok/cucumber/core_ext/instance_exec.rb;Ti1I"Ω      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity
    Cucumber::RUBY_1_9 ? (var) : ((var == -1) ? (0) : (var));Fi[	I"1data//cucumber_prok/cucumber/feature_file.rb;TiLI"Æ          end
          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING
      var.each_line do |arglist|;Fi[	I"9data//diaspora_proj/controllers/blocks_controller.rb;Ti!I"5    respond_with do |arglist|
      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist)
    if var = current_user.contact_for(var) then
      current_user.disconnect(var, :force => (true));Fi[	I";data//diaspora_proj/controllers/comments_controller.rb;Ti@I"4        render(:json => (CommentPresenter.as_collection(@var)), :status => 200)
      end
      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist)
    if user_signed_in? then
      @var = current_user.find_visible_shareable_by_id(Post, params[:post_id]);Fi[	I">data//diaspora_proj/controllers/invitations_controller.rb;TiHI"Ó    unless AppConfig.settings.invitations.open? then
      flash[:error] = I18n.t("invitations.create.no_more")
      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist)
    User.email_regexp.match(var).present?
  end;Fi[	I"8data//diaspora_proj/controllers/likes_controller.rb;Ti+I"s    respond_to do |arglist|
      var.all { |arglist| render(:layout => (false)) }
      var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist)
    @var ||= if params[:post_id] then
      (current_user.find_visible_shareable_by_id(Post, params[:post_id]) or raise(ActiveRecord::RecordNotFound.new));Fi[	I"9data//diaspora_proj/controllers/people_controller.rb;TißI"ÿ        flash[:error] = I18n.t("tags.show.none", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id }
    var = {};Fi[	I"9data//diaspora_proj/controllers/photos_controller.rb;Ti{I"       end
    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist)
    if request.params[:qqfile].is_a?(String).! then
      var[:qqfile];Fi[	I";data//diaspora_proj/controllers/profiles_controller.rb;Ti9I"          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("profiles.edit.your_tags_placeholder"))) then
      @var[:tag_string].split(" ").each do |arglist|;Fi[	I"Bdata//diaspora_proj/controllers/status_messages_controller.rb;TiBI"Q        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "all_aspects")) then
      current_user.aspect_ids;Fi[	I"7data//diaspora_proj/controllers/tags_controller.rb;Ti,I"„          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name])
  end;Fi[	I"4data//diaspora_proj/helpers/analytics_helper.rb;Ti!I"]      javascript_tag do |arglist|
        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var)
    yield(var);Fi[	I"*data//diaspora_proj/models/contact.rb;TiRI"      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist)
    if person_id and person.closed_account? then
      (errors[:base] << "Cannot be in contact with a closed account");Fi[	I")data//diaspora_proj/models/person.rb;Ti=I"    if self.url then
      self.url = ("http://" + self.url) unless self.url.match(/https?:\/\//)
      self.url = (self.url + "/") if self.url[-1, 1].!=("/")
    end
  end
  
  private
  
  def function(arglist)
    Webfinger.new(self.diaspora_handle).fetch
    self.reload;Fi[	I"*data//diaspora_proj/models/profile.rb;TiΩI"Ê    if @var then
      errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["created_at", "updated_at", "person_id"])
  end;Fi[	I"3data//diaspora_proj/models/share_visibility.rb;TiI"@    else
      var = var.map { |arglist| [var, var.id, var.class.base_class.to_s] }
      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist)
    if shareable.public? then
      (errors[:base] << "Cannot create visibility for a public object");Fi[	I"$data//haml_proj/haml/options.rb;TiÂI"»      self.class.buffer_option_keys.inject({}) do |arglist|
        var[var] = send(var)
        var
      end
    end
    
    private
    
    def function(arglist)
      self.class.defaults
    end;Fi[	I"$data//homebrew_proj/cmd/info.rb;TiyI"◊      else
        raise("No such formula or keg")
      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "http://") or ((var[(0..7)] == "https://") or (var[(0..5)] == "ftp://")))
  end;Fi[	I"$data//homebrew_proj/cmd/list.rb;TiI"˘          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|
      var.basename.to_s;Fi[	I"&data//homebrew_proj/cmd/update.rb;Ti+I"Ù    else
      puts("Updated Homebrew from #{master_updater.initial_revision[0, 8]} to #{master_updater.current_revision[0, 8]}.")
      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir[".git/*"].empty? then;Fi[	I"(data//homebrew_proj/cmd/versions.rb;Ti/I"      "Library/Formula/#{name}.rb"
    else
      "#{HOMEBREW_REPOSITORY}/Library/Formula/#{name}.rb"
    end
  end
  
  private
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-list --abbrev-commit HEAD -- Library/Formula/#{name}.rb`.split;Fi[	I"-data//homebrew_proj/download_strategy.rb;TirI"∑      safe_system("7zr", "x", @var)
    else
      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist)
    var = Dir["*"]
    case var.length;Fi[	@viI"ø        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "").split(/:/)
    var = var.pop;Fi[	I"'data//homebrew_proj/extend/ARGV.rb;Ti¨I"ª      yield)
    ensure
      replace(var)
    end
  end
  
  private
  
  def function(arglist)
    @var ||= named.map { |arglist| var.include?("/") ? (var) : (var.downcase) }.uniq
  end;Fi[	I"#data//homebrew_proj/version.rb;TißI"–      else
        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  
  def function(arglist)
    raise("Unknown version scheme #{@scheme} was requested.")
  end;Fi[	I"6data//jekyll_proj/jekyll/generators/pagination.rb;Ti0I"º        else
          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["paginate_path"]
      var.sub(":num", var.to_s);Fi[	I"-data//nokogiri_proj/nokogiri/xml/node.rb;Ti1I"Ñ        document.canonicalize(var, var, var) do |arglist|
          var = var.is_a?(XML::Node) ? (var) : (var)
          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist)
        var = (var == :next) ? (:add_next_sibling_node) : (:add_previous_sibling_node)
        var = (var == :next) ? (:reverse_each) : (:each);Fi[	I"/data//paperclip_proj/paperclip/geometry.rb;Ti{I"∆        end
      else
        scale_to(var)
      end
    end
    
    private
    
    def function(arglist)
      if (var.horizontal? or var.square?) then
        [("%dx" % var.width), var.width];Fi[	I">data//paperclip_proj/paperclip/geometry_parser_factory.rb;TiI"    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist)
      if var = (@var and @var.match(FORMAT)) then
        @var = var[1];Fi[	I"2data//paperclip_proj/paperclip/storage/fog.rb;Ti|I"5        rescue ::Fog::Errors::Error => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        if @var[:fog_host].respond_to?(:call) then
          @var[:fog_host].call(self);Fi[	@ãi˘I"        rescue AWS::Errors::Base => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then;Fi[	I"Kdata//paperclip_proj/paperclip/validators/attachment_size_validator.rb;Ti"I"z      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator")
        end
      end
      
      private
      
      def function(arglist)
        if var = var[:in] then
          if var[:in].respond_to?(:call).! then;Fi[	I"Tdata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication.rb;TilI"€      complete_open_id_authentication(&var)
    else
      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist)
    (params[:openid_identifier] or params[:openid_url])
  end;Fi[	I"Sdata//redmine_proj/plugins/open_id_authentication/test/mem_cache_store_test.rb;TiLI"i      assert_nonce(var, false, var, "#{url}: nonce not allowed third time")
      var = OpenID::Nonce.mk_nonce(3600)
      assert_nonce(var, false, var, "Old nonce #{old_nonce.inspect} passed")
    end
  end
  
  private
  
  def function(arglist)
    var = OpenID::CryptUtil.random_string(20, nil)
    var = OpenID::CryptUtil.random_string(128, ALLOWED_HANDLE);Fi[	I"9data//redmine_proj/plugins/rfpdf/lib/fpdf/chinese.rb;TiÍI"”    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I":data//redmine_proj/plugins/rfpdf/lib/fpdf/japanese.rb;TiÛI"”    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I"8data//redmine_proj/plugins/rfpdf/lib/fpdf/korean.rb;TiŸI"”    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I"7data//redmine_proj/plugins/rfpdf/lib/rfpdf/fpdf.rb;TiI"ø      return @var
    else
      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "")) then;Fi[	I"*data//redmine_proj/SVG/Graph/Graph.rb;Ti&I"            # do nothing
          end
          var.attributes["transform"] = "translate(#{x_offset} #{y_offset})"
        end
      end
      
      private
      
      def function(arglist)
        if (var < var) then
          var = partition(var, var, var);Fi[	I"Cdata//rspec_proj/spec/runner/formatter/no_op_method_missing.rb;TiI"Ú            true
          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	I"-data//rspec_proj/spec/runner/reporter.rb;TilI"◊        
        def function(arglist)
          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist)
        @var.formatters
      end;Fi[	I"1data//sinatra_proj/sinatra/showexceptions.rb;Ti%I"u        end
        var["rack.errors"] = var
        [500, { "Content-Type" => (var), "Content-Length" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist)
      (Request.new(var).preferred_type("text/plain", "text/html") == "text/html").! and [/curl/].index { |arglist| var.=~(var["HTTP_USER_AGENT"]) }
    end;Fi[@'@(@)@*I" ;FI"def function(arglist);Fi5[5[	I"\data//activerecord_proj/active_record/connection_adapters/abstract/schema_statements.rb;Ti%I"Q            if (var < var) then
              execute("INSERT INTO #{sm_table} (version) VALUES ('#{v}')")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist)
        if var = native_database_types[var.to_sym] then
          var = (var.is_a?(Hash) ? (var[:name]) : (var)).dup;Fi[	@CigI"œ                (var..var)
              else
                var
              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil;Fi[	I"6data//activerecord_proj/active_record/fixtures.rb;Ti„I"ˇ        FixtureSet::File.open(var) do |arglist|
          var.each do |arglist|
            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "#{@path}.yml"
    end;Fi[	I":data//activerecord_proj/active_record/sanitization.rb;TiñI"l              quote_bound_value(var[var])
            else
              raise(PreparedStatementInvalid, "missing value for :#{match} in #{statement}")
            end
          end
        end
      end
      
      def function(arglist)
        if var.respond_to?(:map) and var.acts_like?(:string).! then
          if var.respond_to?(:empty?) and var.empty? then;Fi[	@NisI"Ù                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["#{self}_ignore_default_scope"]
        end;Fi[	I"Hdata//activerecord_proj/active_record/tasks/mysql_database_tasks.rb;Ti*I"ƒ            $stderr.puts("Couldn't create database for #{configuration.inspect}, #{creation_options.inspect}")
            if configuration["encoding"] then
              $stderr.puts("(If you set the charset manually, make sure you have a matching collation)")
            end
          end
        end
      end
      
      def function(arglist)
        establish_connection(configuration)
        connection.drop_database(configuration["database"]);Fi[	I"+data//bundler_proj/bundler/resolver.rb;TiÏI"              debug { |arglist| "    -> Jumping to: #{savepoint}" }
              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by)
      (var.required_by << var);Fi[	@&i?I"              raise(var) if (var.autorequire or (var and var.gsub("-", "/").!=(var)))
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then
        dependencies;Fi[	@)iìI"˘              "(#{conditions}) OR (#{sql})"
            else
              "not (#{conditions}) AND (#{sql})"
            end
          end
        end
      end
      
      def function(arglist)
        sanitize_sql(["?=?", true, false])
      end;Fi[	@|i1I"«            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!
    end;Fi[	@|iÇI")                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first
      matches_conditions_hash?(var, (@var[var.class.name.downcase.to_sym] or {}));Fi[	I"0data//capistrano_proj/capistrano/command.rb;TiRI"È                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var;Fi[	I"4data//compass_proj/compass/commands/registry.rb;TiI"g            raise(Compass::Error, "Ambiguous abbreviation '#{name}'. Did you mean one of: #{matching.join(", ")}")
          else
            raise(Compass::Error, "Command not found: #{name}")
          end
        end
      end
    end
    
    def function(arglist)
      var = /^#{Regexp.escape(var)}/
      @var.keys.detect { |arglist| var.to_s.=~(var) };Fi[	@ñiÄI"              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= []
        (@var << [var, var]);Fi[	I"Rdata//compass_proj/compass/sass_extensions/functions/cross_browser_support.rb;TiAI"§          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  
  def function(arglist)
    CSS2FallbackValue.new(var, var)
  end;Fi[	I"8data//cucumber_prok/cucumber/ast/feature_element.rb;Ti/I"Z              (((Ast::Step::INDENT + @var.unpack("U*").length) + ": ".length) + var.unpack("U*").length)
            else
              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("U*").length)
            end
          end
        end
      end
      
      def function(arglist)
        var.detect { |arglist| var.=~(name) }
      end;Fi[	I"6data//cucumber_prok/cucumber/ast/outline_table.rb;Ti~I")                var.invoke(var.step_mother, var.configuration)
                @var ||= var.reported_exception
                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end;Fi[	I"3data//cucumber_prok/cucumber/formatter/html.rb;TiGI"5            @var.div(:id => "expand-collapse") do |arglist|
              @var.p("Expand All", :id => "expander")
              @var.p("Collapse All", :id => "collapser")
            end
          end
        end
      end
      
      def function(arglist)
        print_stats(var)
        (@var << "</div>");Fi[	I">data//diaspora_proj/controllers/application_controller.rb;TijI"ç            @var = var
            break
          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil)
  end;Fi[	I":data//diaspora_proj/controllers/aspects_controller.rb;Ti I"Ë        var.html do |arglist|
          flash[:error] = I18n.t("aspects.create.failure")
          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist)
    @var = Aspect.new
    @var = params[:person_id];Fi[	I"0data//diaspora_proj/helpers/posts_helper.rb;TiI"&          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516
    var[:height] ||= 315;Fi[	I"1data//diaspora_proj/helpers/stream_helper.rb;TiI"Ô          else
            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare)
  end;Fi[	I"/data//diaspora_proj/models/notification.rb;Ti%I"ö          var
        else
          nil
        end
      end
    end
  end
  
  def function(arglist)
    super(var.merge(:methods => :note_html))
  end;Fi[	I"%data//haml_proj/haml/compiler.rb;TiwI"          if Parser::MID_BLOCK_KEYWORDS.include?(var) then
            @var = @var.parent.value[:dont_indent_next_line]
            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	I"%data//homebrew_proj/cmd/audit.rb;TiæI"4        end
        unless (var.hexdigest == var.hexdigest.downcase) then
          problem("#{cksum.hash_type} should be lowercase")
        end
      end
    end
  end
  
  def function(arglist)
    ENV.setup_build_environment
    Patches.new(f.patches).select { |arglist| var.external? }.each do |arglist|;Fi[	I"'data//homebrew_proj/cmd/cleanup.rb;TiMI"À            puts("Removing: #{pn}...")
            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist)
    system("find #{HOMEBREW_PREFIX} -name .DS_Store -delete")
  end;Fi[	@miJI"˝          var.symlink? ? (puts("#{pn} -> #{pn.readlink}")) : (print_dir(var))
        else
          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = []
    var = [];Fi[	I"&data//homebrew_proj/cmd/search.rb;Ti4I"L            puts("No formula found for \"#{query}\". Searching open pull requests...")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist)
    (if (HOMEBREW_LIBRARY / "Taps/#{user.downcase}-#{repo.downcase}").directory? then
      return [];Fi[	I"+data//homebrew_proj/extend/pathname.rb;Ti	I"          else
            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s)
  end;Fi[	I"-data//homebrew_proj/formula_installer.rb;TiI"'          opoo("#{bin} is not in your PATH")
          puts("You can amend this by altering your ~/.bashrc file")
          @var = true
        end
      end
    end
  end
  
  def function(arglist)
    if (f.prefix + "man").directory? then
      opoo("A top-level \"man\" directory was found.");Fi[	I"!data//homebrew_proj/macos.rb;TiI"
          :snowleopard
        else
          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist)
    (@var ||= {}).fetch(var.to_s) do |arglist|
      @var[var.to_s] = if File.executable?("/usr/bin/#{tool}") then;Fi[	@	i6I"&      else
        if File.exist?("#{Xcode.prefix}/usr/bin/make") then
          Pathname.new("#{Xcode.prefix}/usr/bin")
        end
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new("#{Xcode.prefix}/Toolchains/XcodeDefault.xctoolchain")
    var if var.exist?);Fi[	I"Xdata//paperclip_proj/paperclip/matchers/validate_attachment_content_type_matcher.rb;TiAI"x                (var << "  #{@missing_allowed_types.join(", ")} were rejected.")
              else
                (var << "  All were accepted successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          if @var.present? then
            "Reject content types: #{@rejected_types.join(", ")}\n".tap do |arglist|;Fi[	@iMI"<                (var << "  #{@missing_rejected_types.join(", ")} were accepted.")
              else
                (var << "  All were rejected successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          "Expected #{@attachment_name}:\n"
        end;Fi[	@íiI"5            unless var.send(CHECKS[var], var) then
              var = options[:in] ? (:in_between) : (var)
              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator");Fi[	@õi8I"⁄          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@ûiAI"⁄          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@°i'I"⁄          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@§iêI"%          var = ("put" + var.downcase)
          self.Error(("Unsupported font type: " + var)) unless self.respond_to?(var)
          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist)
    var = @var ? ("/Filter /FlateDecode ") : ("")
    @var.each do |arglist|;Fi[	@§i
I"Ÿ        else
          (var = freadshort(var)
          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist)
    while true do
      while (var = freadbyte(var)).!=(255) do;Fi[	@îi|I"¢              self.send(var, var)
            end
          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj
    out("<</Type /Font");Fi[	I"6data//redmine_proj/redmine/helpers/time_report.rb;TiJI"ï              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist)
        @var = { "project" => ({ :sql => ("#{TimeEntry.table_name}.project_id"), :klass => (Project), :label => :label_project }), "status" => ({ :sql => ("#{Issue.table_name}.status_id"), :klass => (IssueStatus), :label => :field_status }), "version" => ({ :sql => ("#{Issue.table_name}.fixed_version_id"), :klass => (Version), :label => :label_version }), "category" => ({ :sql => ("#{Issue.table_name}.category_id"), :klass => (IssueCategory), :label => :field_category }), "user" => ({ :sql => ("#{TimeEntry.table_name}.user_id"), :klass => (User), :label => :label_user }), "tracker" => ({ :sql => ("#{Issue.table_name}.tracker_id"), :klass => (Tracker), :label => :label_tracker }), "activity" => ({ :sql => ("#{TimeEntry.table_name}.activity_id"), :klass => (TimeEntryActivity), :label => :label_activity }), "issue" => ({ :sql => ("#{TimeEntry.table_name}.issue_id"), :klass => (Issue), :label => :label_issue }) }
        var = @var.nil? ? (IssueCustomField.for_all) : (@var.all_issue_custom_fields);Fi[	I";data//redmine_proj/redmine/views/builders/structure.rb;Ti9I"                @var.last[var].merge!(var)
              else
                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist)
          raise("Need to implement #{self.class.name}#output")
        end;Fi[	@≥i6I"Ò                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        (@var - @var)
      end;Fi[	I"+data//rspec_proj/spec/matchers/have.rb;Ti:I"‰          else
            if (@var == :at_least) then
              return "Isn't life confusing enough?\nInstead of having to figure out the meaning of this:\n  should_not have_at_least(#{@expected}).#{@collection_name}\nWe recommend that you use this instead:\n  should have_at_most(#{(@expected - 1)}).#{@collection_name}\n"
            end
          end
        end
      end
      
      def function(arglist)
        "have #{relative_expectation} #{@collection_name}"
      end;Fi[	I"3data//rspec_proj/spec/mocks/error_generator.rb;Ti?I"/              "<#{@target.inspect} (class)>"
            else
              @var ? (@var) : ("nil")
            end
          end
        end
      end
      
      def function(arglist)
        var = opts[:message] unless opts[:message].nil?
        Kernel.raise(Spec::Mocks::MockExpectationError, var);Fi[	@∂i~I"                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var)
      end;Fi[	@∂iªI"≈              "protected"
            else
              "public"
            end
          end
        end
      end
      
      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end;Fi[@'I" ;FI"def function(arglist);FI"# do nothing;FI"end;FI" ;Fi2[2[	I"]data//activerecord_proj/active_record/associations/belongs_to_polymorphic_association.rb;TiI"⁄      
      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super;Fi[	I"^data//activerecord_proj/active_record/connection_adapters/abstract/database_statements.rb;TiI",      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.
      def function(arglist);Fi[	I"Rdata//activerecord_proj/active_record/connection_adapters/abstract_adapter.rb;Ti˙I"B        var = "#transaction_joinable= is deprecated. Please pass the :joinable option to #begin_transaction instead."
        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@@i˛I"ª      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@@iI"≤      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var;Fi[	I";data//activerecord_proj/active_record/null_relation.rb;Ti9I"ì    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	I"8data//activerecord_proj/active_record/reflection.rb;Ti‚I"‹            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@JiÊI"      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in
      # ThroughReflection.;Fi[	I"%data//bundler_proj/bundler/ui.rb;Ti
I"´  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@OiI"•    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@OiI"•    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@OiI"•    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@OiI"û    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	I"Hdata//compass_proj/compass/app_integration/stand_alone/installer.rb;Ti,I"G          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then;Fi[	I"=data//compass_proj/compass/exec/command_option_parser.rb;TiI"     
    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s;Fi[	I"<data//compass_proj/compass/installers/bare_installer.rb;TiI"      def function(arglist)
        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("config.rb");Fi[	I")data//compass_proj/compass/logger.rb;TiTI"¨  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield;Fi[	I"2data//compass_proj/compass/sprite_importer.rb;Ti I"›        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name;Fi[	I"(data//compass_proj/compass/stats.rb;TiI"        end
        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@ii I"ª      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false;Fi[	I"9data//cucumber_prok/cucumber/ast/scenario_outline.rb;TiAI"%        var.visit_steps(@var)
        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! };Fi[	I"6data//cucumber_prok/cucumber/formatter/console.rb;TiÜI"H        else
          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to
      #activate this feature;Fi[	I"4data//cucumber_prok/cucumber/formatter/junit.rb;TiEI"0      def function(arglist)
        @var = (var.nil? or (var == "")) ? ("Unnamed scenario") : (var.split("\n")[0])
        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var);Fi[	I";data//cucumber_prok/cucumber/js_support/js_language.rb;TitI"       
      def function(arglist)
        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language;Fi[	@wi|I"À      
      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|;Fi[	I";data//cucumber_prok/cucumber/parser/gherkin_builder.rb;Ti;I"9        var = Ast::Step.new(var.line, var.keyword, var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@|i?I"ü      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	I";data//cucumber_prok/cucumber/py_support/py_language.rb;TiI"ﬂ      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "python snippet: #{code_keyword}, #{step_name}";Fi[	@Åi"I"        RubyPython.start
        @var = import((File.dirname("(string)") + "/py_language.py"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var);Fi[	I"9data//cucumber_prok/cucumber/runtime/support_code.rb;TiI"        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)));Fi[	I"Adata//cucumber_prok/cucumber/wire_support/request_handler.rb;TiI"≠      
      def function(arglist)
        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	I"?data//cucumber_prok/cucumber/wire_support/wire_language.rb;TiI"»      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var);Fi[	@™i,I"∞      
      def function(arglist)
        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      
      var = ["serializable_hash"]
      ;Fi[	I"@data//devise_proj/devise/models/database_authenticatable.rb;TiOI"        var = update_attributes(var, *var)
        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A reliable way to expose the salt regardless of the implementation.
      def function(arglist);Fi[	I"3data//devise_proj/devise/models/recoverable.rb;TiOI"(      def function(arglist)
        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new;Fi[	I"'data//diaspora_proj/models/post.rb;Ti8I"à  
  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "";Fi[	@ıizI"õ          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value;Fi[	I"8data//omni_proj/omniauth/test/strategy_test_case.rb;TiI"            [404, { "Content-Type" => "text/plain" }, [(var or var.key?("omniauth.auth").to_s)]]
          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["rack.session"];Fi[	I">data//paperclip_proj/paperclip/io_adapters/nil_adapter.rb;TiI"ï    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true;Fi[	I"0data//paperclip_proj/paperclip/processor.rb;TiI"≤      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    
    def self.make(arglist)
      new(var, var, var).make;Fi[	@§iI"Å  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  ;Fi[	I"6data//rspec_proj/spec/runner/backtrace_tweaker.rb;TiI"π      
      def function(arglist)
        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        [];Fi[	I"Odata//rspec_proj/spec/runner/formatter/failing_example_groups_formatter.rb;TiI"œ            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	I"Idata//rspec_proj/spec/runner/formatter/failing_examples_formatter.rb;TiI"        def function(arglist)
          @var.puts("#{example_group.description} #{example.description}")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	I"=data//rspec_proj/spec/runner/formatter/html_formatter.rb;Ti|I"˛            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then;Fi[I" ;FI"def function(arglist);FI"# do nothing;FI"end;FI" ;FI"def function(arglist);Fi,[,[	@ÔidI"        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          serializable_collection.each do |arglist|
            var = ActiveSupport::XmlMini.rename_key(var.name, options);Fi[	@:iI"      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super
        var and [var.to_s, owner[reflection.foreign_type].to_s];Fi[	@@i˚I"÷        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@@iˇI"æ      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@@iI"µ      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end;Fi[	@Gi:I"ñ    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@Ji„I"ß          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	I"5data//bundler_proj/bundler/lazy_specification.rb;TiFI"Ó    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      unless @var then
        raise("LazySpecification has not been materialized yet (calling :#{method} #{args.inspect})");Fi[	@OiI"®    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@OiI"®    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@OiI"®    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@OiI"®    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@OiI"°    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@Zi-I"Ø            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then
            puts("\n*********************************************************************\nCongratulations! Your compass project has been created.\n\nYou may now add and edit sass stylesheets in the #{Compass.configuration.sass_dir} subdirectory of your project.\n\nSass files beginning with an underscore are called partials and won't be\ncompiled to CSS, but they can be imported into other sass stylesheets.\n\nYou can configure your project by editing the config.rb configuration file.\n\nYou must compile your sass stylesheets into CSS when they change.\nThis can be done in one of the following ways:\n  1. To compile on demand:\n     compass compile [path/to/project]\n  2. To monitor your project for changes and automatically recompile:\n     compass watch [path/to/project]\n\nMore Resources:\n  * Website: http://compass-style.org/\n  * Sass: http://sass-lang.com\n  * Community: http://groups.google.com/group/compass-users/\n\n");Fi[	@]iI"Õ    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s
    end;Fi[	@`iI"        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("config.rb")
        write_file(var, config_contents);Fi[	@ciUI"°    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end;Fi[	@fi!I"í      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name
    end;Fi[	@iiI"        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ii!I"‘      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false
        var = var.send(:import);Fi[	@niBI"N        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
        @var.next_feature_element(self) { |arglist| var.skip_invoke! };Fi[	@tiFI"4        @var = (var.nil? or (var == "")) ? ("Unnamed scenario") : (var.split("\n")[0])
        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var)
        var = (Time.now - @var);Fi[	@wiuI"      def function(arglist)
        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language
      end;Fi[	@wi}I"Ù      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|
          if var = var.arguments_from(var) then;Fi[	@|i<I"À        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ÅiI"‚      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "python snippet: #{code_keyword}, #{step_name}"
      end;Fi[	@Åi#I"        @var = import((File.dirname("(string)") + "/py_language.py"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var)
      end;Fi[	@ÜiI"        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end;Fi[	@åiI"Á      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var)
        (@var << Connection.new(var));Fi[	@ói9I"ã  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end;Fi[	@ıi{I"¡        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value
      rstrip_buffer! if var[:nuke_outer_whitespace];Fi[	@úiI"√          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["rack.session"]
      end;Fi[	@üiI"ò    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end;Fi[	@§iI"ê  end
  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end;Fi[	I"?data//rspec_proj/spec/adapters/mock_frameworks/flexmock.rb;TiI"ÿ  module Adapters
    module MockFramework
      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        flexmock_verify
      end;Fi[	@ßiI"º      def function(arglist)
        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end;Fi[	@™iI"ƒ            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@≠iI"ˇ          @var.puts("#{example_group.description} #{example.description}")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@∞i}I"⁄          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then
            var = "This was a dry-run";Fi[@'@(@)I" ;FI"private;FI" ;Fi$[$[	@¯i#I"Ï            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins);Fi[	I"Ndata//activerecord_proj/active_record/associations/has_one_association.rb;Ti8I"b            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private
      
      # The reason that the save param for replace is false, if for create (not just build),
      # is because the setting of the foreign keys is actually handled by the scoping when;Fi[	@i0I"g          var = (Time.now - @var)
          connections.dup.each do |arglist|
            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      
      # Acquire a connection by one of 1) immediately removing one
      # from the queue of available connections, 2) creating a new;Fi[	@Ci|I"˘              end
            else
              var
            end
          end
        end
        
        private
        
        HstorePair = (var = /"[^"\\]*(?:\\.[^"\\]*)*"/
        var = /(?:\\.|[^\s,])[^\s=,\\]*(?:\\.[^\s=,\\]*|=[^,>])*/;Fi[	@iLI"          var = var.where(table[primary_key].gt(var)).to_a
        else
          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    
    def function(arglist)
      "#{quoted_table_name}.#{quoted_primary_key} ASC";Fi[	I".data//backup_proj/backup/database/riak.rb;Ti.I"(          @var.compressor.compress_with do |arglist|
            run("#{command} -c #{backup_file} > #{(backup_file + ext)}")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes;Fi[	@)iwI"Ô            end
          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact;Fi[	@1iGI"        else
          if File.directory?(project_directory).! then
            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then;Fi[	@7i0I"å        end
      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity;Fi[	@:iKI"°            exit(1)
          end
          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING;Fi[	I",data//cucumber_prok/cucumber/runtime.rb;TiçI"-        FileUtils.mkdir_p(@var.dotcucumber) if File.directory?(@var.dotcucumber).!
        File.open(File.join(@var.dotcucumber, "stepdefs.json"), "w") do |arglist|
          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    
    #:nodoc
    def function(arglist);Fi[	@Ii¶I"÷      else
        flash[:error] = I18n.t("tags.show.none", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id };Fi[	@Oi8I"Ú        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("profiles.edit.your_tags_placeholder"))) then;Fi[	@RiAI"e        var.html { |arglist| redirect_to(:back) }
        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "all_aspects")) then;Fi[	@Ui+I"        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name]);Fi[	@Xi I"~    include_analytics("chartbeat") do |arglist|
      javascript_tag do |arglist|
        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var);Fi[	@[iQI"        aspects.detect { |arglist| (var.id == var.id) }
      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist)
    if person_id and person.closed_account? then;Fi[	@≤iI"˚      if var.children.empty? and var.skip_clean?(var).! then
        puts("rmdir: #{d} (empty)") if ARGV.verbose?
        var.rmdir
      end
    end
  end
  
  private
  
  # Set permissions for executables and non-executables
  def function(arglist);Fi[	@jixI"        var.children.each { |arglist| puts("#{keg} (#{keg.abv})") }
      else
        raise("No such formula or keg")
      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "http://") or ((var[(0..7)] == "https://") or (var[(0..5)] == "ftp://")));Fi[	I"$data//homebrew_proj/cmd/link.rb;Ti"I"      end
      print("Linking #{keg}... ") do |arglist|
        puts("#{keg.link(mode)} symlinks created")
      end
    end
  end
  
  private
  
  # Allows us to ensure a puts happens before the block exits so that if say,
  # an exception is thrown, its output starts on a new line.;Fi[	@miI"Ó        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|;Fi[	@vi~I"ˆ      if FileTest.directory?(var) and (File.basename(var) == "CVS") then
        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "").split(/:/);Fi[	@øiI"≠            end
          end
        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/
  ;Fi[	@~i¶I"Â        detect_from_symbol
      else
        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  
  def function(arglist)
    raise("Unknown version scheme #{@scheme} was requested.");Fi[	@Åi/I"π          (var.pages << var)
        else
          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["paginate_path"];Fi[	I"1data//jekyll_proj/jekyll/migrators/tumblr.rb;Ti&I"e        var[:name] = truncate_post_name(var[:name]) if (var[:name].size > 255)
        File.open("_posts/tumblr/#{post[:name]}", "w") do |arglist|
          var.puts(((var[:header].to_yaml + "---\n") + var[:content]))
        end
      end
    end
    
    private
    
    def self.truncate_post_name(arglist)
      var = var.match(/^(.+)\.(.+)$/).captures;Fi[	I":data//mongoid_proj/lib/mongoid/matchers/strategies.rb;Ti6I"            Matchers::And.new(var, var)
          else
            Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      
      # Extract the attribute from the key, being smarter about dot notation.
      #;Fi[	I";data//mongoid_proj/lib/mongoid/validations/presence.rb;Ti!I"˜            end
          else
            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      
      # Returns true if the relation is blank or the foreign key is blank.
      #;Fi[	I"=data//mongoid_proj/lib/mongoid/validations/uniqueness.rb;Ti,I"”            validate_embedded(var, var, var)
          else
            validate_root(var, var, var)
          end
        end
      end
      
      private
      
      # Add the error to the document.
      #;Fi[	I")data//redmine_proj/redmine/themes.rb;TiRI"
          end
        else
          Dir.glob("#{path}/#{dir}/*").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    
    def self.scan_themes(arglist)
      var = Dir.glob("#{Rails.public_path}/themes/*").select do |arglist|;Fi[	I".data//rspec_proj/spec/matchers/matcher.rb;TiXI"Ô          define_method(var) do |arglist|
            var.call(*var)
            self
          end
        end
      end
      
      private
      
      # :nodoc:
      # Our home-grown instance_exec in ruby 1.8.6 results in any methods;Fi[@'@(@)@*@+I" ;Fi"["[	I"?data//activerecord_proj/active_record/nested_attributes.rb;TiÅI"e              send(var, var.except(*UNASSIGNABLE_KEYS))
            else
              raise(ArgumentError, "Cannot build association `#{association_name}'. Are you trying to build a polymorphic one-to-one association?")
            end
          end
        end
      end
    end
    
    # Assigns the given attributes to the collection association.
    #;Fi[	@KiFI"ù              else
                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end
    
    initializer("active_record.set_configs") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|;Fi[	I"Adata//activerecord_proj/active_record/relation/delegation.rb;Ti<I"È              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2);Fi[	@NirI"ˇ                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["#{self}_ignore_default_scope"];Fi[	@\iùI"-                  MUTEX.synchronize do |arglist|
                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end
        
        class LocalFile
          attr_reader(:path, :relative_path, :md5);Fi[	@«iÎI"            if var.include?(var) then
              debug { |arglist| "    -> Jumping to: #{savepoint}" }
              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by);Fi[	I"/data//bundler_proj/bundler/ruby_version.rb;Ti+I"◊            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion
    def function(arglist);Fi[	I"7data//bundler_proj/bundler/rubygems_integration.rb;Ti°I"’            @var = RubygemsIntegration::Legacy.new
          else
            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  
  class << self
    attr_reader(:rubygems);Fi[	@&i>I"              var = $1
              raise(var) if (var.autorequire or (var and var.gsub("-", "/").!=(var)))
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then;Fi[	I"3data//bundler_proj/bundler/vendor/thor/util.rb;TiZI"              ENV["APPDATA"]
            else
              File.expand_path("~") rescue File::ALT_SEPARATOR ? ("C:/") : ("/")
            end
          end
        end
      end
    end
    
    def self.thor_root(arglist)
      File.join(user_home, ".thor").gsub(/\\/, "/");Fi[	@|i0I"Î              matches_conditions_hash?(var)
            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!;Fi[	@|iÅI"Í              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first;Fi[	@ÉikI"m                else
                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,
      # with the exception that it sets the receiver as the "current" configuration;Fi[	@ñiI"            else
              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= [];Fi[	@ôi3I"¸                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end
      
      # Support for testing.
      def function(arglist);Fi[	I"6data//cucumber_prok/cucumber/formatter/unicode.rb;TiDI"              rescue Iconv::IllegalSequence => var
                STDERR.cucumber_puts("WARNING: #{e.message}")
                cucumber_puts(*var)
              end
            end
          end
        end
      end
      
      Kernel.extend(self)
      ;Fi[	@ÊiiI"¶          unless var.nil? then
            @var = var
            break
          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil);Fi[	@ÏiI"        else
          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516;Fi[	@ÔiI"'            stream_path(:max_time => (time_for_scroll(@var)))
          else
            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare);Fi[	@ıiI"ß              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">"
            else
              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
            end
          end
        end
      end
    end
    
    # Evaluates `text` in the context of the scope object, but
    # does not output the result.;Fi[	@˚iLI"‘          else
            puts("Removing: #{pn}...")
            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist)
    system("find #{HOMEBREW_PREFIX} -name .DS_Store -delete");Fi[	@ i3I"t          if ($found == 0) and blacklisted?(var).! then
            puts("No formula found for \"#{query}\". Searching open pull requests...")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist)
    (if (HOMEBREW_LIBRARY / "Taps/#{user.downcase}-#{repo.downcase}").directory? then;Fi[	@iI"π            raise("            Could not symlink file: #{src.expand_path}\n            #{dirname} is not writable. You should change its permissions.\n".undent)
          else
            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s);Fi[	@øiI"|                end
              end
            end
          end
        end
      end
    end
  end
  
  private
  ;Fi[	I"%data//jekyll_proj/jekyll/site.rb;Ti|I"@              (pages << Page.new(self, self.source, var, var))
            else
              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    
    # Read all the files in <source>/<dir>/_posts and create a new Post
    # object with each one.;Fi[	@4i!I"ä                    target.__send__(var).push(base) unless Mongoid.using_identity_map?
                  else
                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.;Fi[	@îi{I"ö            else
              self.send(var, var)
            end
          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj;Fi[	@≥i5I"¸                else
                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        (@var - @var);Fi[	@∂i}I"                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var);Fi[@≥@¥I"@var = var;FI"end;FI" ;FI"def function(arglist);Fi![![	I"Pdata//activerecord_proj/active_record/connection_adapters/postgresql/oid.rb;TiDI"0        
        class Array < Type
          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var);Fi[	@iI"        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled;Fi[	@ƒiI"(      ACCESS_DENIED_ERROR = 1045
      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database);Fi[	I"Mdata//activerecord_proj/active_record/tasks/postgresql_database_tasks.rb;TiI"I      DEFAULT_ENCODING = (ENV["CHARSET"] or "utf8")
      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var;Fi[	@ iI"Ó      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then;Fi[	I"5data//cucumber_prok/cucumber/formatter/pretty.rb;TirI"≤        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
        @var = 4;Fi[	I"7data//cucumber_prok/cucumber/formatter/progress.rb;Ti0I"≤        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end;Fi[	@ÜiI"—      
      class StepInvoker
        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	I"<data//cucumber_prok/cucumber/wire_support/connection.rb;TiI"ƒ      end
      
      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = WirePacket.new(var, var)
        begin;Fi[	I"#data//homebrew_proj/caveats.rb;TiI"éclass Caveats
  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = []
    (var << f.caveats);Fi[	I"1data//omni_proj/omniauth/failure_endpoint.rb;TiI"„    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["RACK_ENV"].to_s == "development")
      redirect_to_failure;Fi[	I"<data//paperclip_proj/paperclip/content_type_detector.rb;Ti
I"›    EMPTY_TYPE = "inode/x-empty"
    
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      (if blank? then
        SENSIBLE_DEFAULT;Fi[	I"Idata//paperclip_proj/paperclip/file_command_content_type_detector.rb;TiI"Âmodule Paperclip
  class FileCommandContentTypeDetector
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      type_from_file_command
    end;Fi[	@äiI"6module Paperclip
  class GeometryParser
    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var));Fi[	I"-data//paperclip_proj/paperclip/logger.rb;TiI"Œ    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log]
    end;Fi[	@§iàI"¢    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@§iåI"ï  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var;Fi[	@§ißI"∂      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@§i´I"å  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@§iØI"å  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@§i≥I"å  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@§i∑I"å  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@§iªI"å  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@§iøI"ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("FPDF error: " + var))
  end;Fi[	I")data//rspec_proj/spec/matchers/be.rb;TiI"À  module Matchers
    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!;Fi[	I"2data//rspec_proj/spec/matchers/match_array.rb;Ti	I"˜  module Matchers
    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var);Fi[	I"7data//rspec_proj/spec/mocks/message_expectation.rb;TiVI"≈      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then
          @var.clear;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/base_text_formatter.rb;TiI"          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["#{@example_group.description} #{example.description}", var, var.location])
        end;Fi[I"var;FI"end;FI"end;FI"end;FI"end;FI"end;Fi![![	I"Pdata//activerecord_proj/active_record/associations/preloader/association.rb;TimI"√          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@˚i3I"Ω            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@iKI"º            var = Hash[var.query.split("&").map { |arglist| var.split("=") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/connection_adapters/postgresql/quoting.rb;TiòI"æ            var = "#{result}.#{sprintf("%06d", value.usec)}"
          end
          var = (var.sub(/^-/, "") + " BC") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	I"Idata//activerecord_proj/active_record/railties/controller_runtime.rb;Ti,I"æ        def function(arglist)
          var, var = super, var[:db_runtime]
          (var << ("ActiveRecord: %.1fms" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	I"4data//capistrano_proj/capistrano/cli/options.rb;Ti∆I"m        when "nil" then
          nil
        else
          var
        end
      end
    end
  end
end;Fi[	I"Fdata//capistrano_proj/capistrano/configuration/actions/inspect.rb;Ti.I"s              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/scm/base.rb;Ti±I"®        def function(arglist)
          var = variable(:scm_arguments)
          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	@åiÖI"ä          when /^\d+/ then
            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	I"<data//compass_proj/compass/configuration/inheritance.rb;TiœI"s            end
            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	@|iNI"Ç            attr_accessor(:line)
          end
          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/rb_support/rb_language.rb;Ti¶I"l            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	I">data//homebrew_proj/vendor/multi_json/adapters/ok_json.rb;Ti(I"z            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/eager.rb;TiñI"À          return nil unless var
          var = Factory.from_db(klass, var, criteria.object_id)
          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	@ÔiàI"’            document[field] = [] unless document[field]
            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	@ÚiI"“              var = document.send(field)
              (value > 0) ? (var.pop) : (var.shift)
              execute("$pop")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@˜iI"ø              var = document.send(field)
              var.delete(value)
              execute("$pull")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@¸iI"‡              var = document.send(field)
              var.delete_if { |arglist| value.include?(var) }
              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@Mi I"õ                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/conversions.rb;TiI"ê          var
        else
          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	I".data//mongoid_proj/lib/mongoid/scoping.rb;Ti3I"          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	I"5data//omni_proj/omniauth/strategies/developer.rb;TiI"™      info do |arglist|
        options.fields.inject({}) do |arglist|
          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	I"Sdata//redmine_proj/plugins/awesome_nested_set/lib/awesome_nested_set/helper.rb;Ti'I"s              end
            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	I"6data//redmine_proj/redmine/views/builders/json.rb;TiI"¶            var = "#{jsonp}(#{json})"
            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end
end;Fi[	@üiI"4          @@additional_blocks ||= Dir.glob("#{Redmine::Plugin.directory}/*/app/views/my/blocks/_*.{rhtml,erb}").inject({}) do |arglist|
            var = File.basename(var).split(".").first.gsub(/^_/, "")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	@¢irI"!              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ldata//state_machine_proj/state_machine/integrations/mongoid/versions.rb;Ti#I"Ω            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[	I".data//twitter_proj/twitter/media/photo.rb;TiI"√      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[@'@(I"var;FI"end;FI" ;FI"def function(arglist);Fi[[	I"Ldata//activerecord_proj/active_record/associations/association_scope.rb;TiUI"            var = eval_scope(var.klass, var)
            var.includes!(var.includes_values)
            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist)
        reflection.name
      end;Fi[	I"Wdata//activerecord_proj/active_record/associations/has_many_through_association.rb;TifI"E            if (var.macro == :has_one) then
              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!
      end;Fi[	I"Jdata//activerecord_proj/active_record/associations/join_dependency.rb;Ti¥I"5            set_target_and_inverse(var, var, var)
          else
            raise(ConfigurationError, "unknown macro: #{join_part.reflection.macro}")
          end
        end
        var
      end
      
      def function(arglist)
        var = var.association(var.reflection.name)
        var.target = var;Fi[	I"Fdata//activerecord_proj/active_record/associations/join_helper.rb;TiI"ß          (var << alias_tracker.aliased_table_for(table_name_for(var), table_alias_for(var, var.!=(self.reflection))))
          if (var.source_macro == :has_and_belongs_to_many) then
            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist)
        var.table_name
      end;Fi[	@i_I"6        if var.respond_to?(:unlock!) and @var[:sources].include?(var.name) then
          var.unlock!
          var = true
        end
      end
      var
    end
    
    def function(arglist)
      (@var + @var).each do |arglist|
        var.source = @var.find { |arglist| (var.source == var) } if var.source;Fi[	@iëI"9        next unless var.respond_to?(:unlock!)
        unless var.any? { |arglist| (var.source == var) } then
          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist)
      var and (var.source == var.source)
    end;Fi[	@i¨I"          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|
        [var.is_a?(Source::Rubygems) ? (1) : (0), var.to_s];Fi[	@i4I"q        var.search(var, var).each do |arglist|
          (var << var) unless var.include?([var.name, var.version, var.platform])
          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist)
      case var
      when Gem::Specification, RemoteSpecification, LazySpecification, EndpointSpecification then;Fi[	@liáI"|            raise(PathError, "The path `#{expanded_path}` is not a directory.")
          else
            raise(PathError, "The path `#{expanded_path}` does not exist.")
          end
        end
        var
      end
      
      def function(arglist)
        if path.to_s.match(/^#{Regexp.escape(Bundler.root.to_s)}/) then
          return path.relative_path_from(Bundler.root);Fi[	I">data//compass_proj/compass/configuration/serialization.rb;Ti?I""            (var << var)
          else
            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist)
        if var.respond_to?(:serialize_to_config) then
          (var.serialize_to_config(var) + "\n");Fi[	I"Mdata//compass_proj/compass/sass_extensions/functions/gradient_support.rb;Ti€I"‰          Sass::Script::Number.new(50, ["%"])
        else
          var
        end
      end
      var
    end
    
    def function(arglist)
      Sass::Script::List.new(var.map do |arglist|
        if ColorStop.===(var) then;Fi[	@:iXI"ﬁ        if ENCODING_PATTERN.=~(var) then
          var = $1
          break
        end
      end
      var
    end
    
    def function(arglist)
      if var.respond_to?(:encode) then
        var.encode(DEFAULT_ENCODING);Fi[	I"1data//cucumber_prok/cucumber/formatter/io.rb;TiI"          unless var.closed? then
            var.flush
            var.close
          end
        end
        var
      end
      
      def function(arglist)
        unless String.===(var) then
          raise("You *must* specify --out FILE for the #{name} formatter");Fi[	I"1data//diaspora_proj/models/status_message.rb;TiZI"∫        else
          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then
      create_mentions if self.mentions.empty?;Fi[	I"#data//haml_proj/haml/parser.rb;TiÀI"∂          var["id"] = var
        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var);Fi[	I"'data//homebrew_proj/cmd/missing.rb;TiI"      unless var.empty? then
        yield(var.name, var) if block_given?
        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist)
    return unless HOMEBREW_CELLAR.exist?
    var = ARGV.named.empty? ? (installed_brews) : (ARGV.formulae);Fi[	I"/data//nokogiri_proj/nokogiri/css/parser.rb;TiÛI"Ì            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then
          var = Node.new(:AN_PLUS_B, var);Fi[	@iiI"            var = Node.new(:AN_PLUS_B, var)
          else
            raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then
          (var << "+");Fi[	I",data//nokogiri_proj/nokogiri/version.rb;Ti<I"Ë        if jruby? then
          var["xerces"] = Nokogiri::XERCES_VERSION
          var["nekohtml"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin
        require("psych");Fi[	I"$data//redmine_proj/redcloth3.rb;Ti)I"µ          end
        end
        var
      end
    end
    var
  end
  
  def function(arglist)
    var.gsub!(/<redpre#(\d+)>/) { |arglist| @var[$1.to_i] } unless @var.empty?
  end;Fi[	@úi2I"—                end
              end
            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("B", 8)
        var.SetFillColor(230, 230, 230);Fi[	I"0data//redmine_proj/redmine/helpers/gantt.rb;Ti¢I"&        if relations[var.id] then
          relations[var.id].each do |arglist|
            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = ""
        if var[:bar_start] and var[:bar_end] then;Fi[	I",data//rspec_proj/spec/runner/options.rb;TiÔI"–            else
              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true)
      end;Fi[	I")data//SiriProxy_proj/siri_objects.rb;Ti)I"Í        end
      else
        var["properties"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist)
    self.extend(SiriRootObject)
    self.ref_id = (var or random_ref_id);Fi[@'@3@4I"	true;FI"end;FI" ;Fi[[	I"Ydata//activerecord_proj/active_record/associations/builder/collection_association.rb;TiI"‡      var = super
      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|;Fi[	I"Wdata//activerecord_proj/active_record/associations/builder/singular_association.rb;Ti	I"˘  class SingularAssociation < Association
    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super;Fi[	I"Vdata//activerecord_proj/active_record/connection_adapters/abstract/transaction.rb;TiI"       
      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false;Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract_mysql_adapter.rb;TiâI"!      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist);Fi[	@çiíI"H      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax
      # but at the moment (5.5) it doesn't yet implement them;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/mysql2_adapter.rb;Ti$I"˛        super
        @var = BindSubstitution.new(self)
        configure_connection
      end
      
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================
      def function(arglist);Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/sqlite3_adapter.rb;TiàI"∫      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@ïi¨I"≥      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:
      def function(arglist);Fi[	@GiI"ã    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false;Fi[	@“i)I"À        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect;Fi[	I"9data//compass_proj/compass/configuration/defaults.rb;Ti&I"      
      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then;Fi[	@ûiãI"“      
      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss;Fi[	@⁄iI"û    
    def function(arglist)
      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value;Fi[	@Xi@I"4    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "deg") and var.denominator_units.empty?));Fi[	I"4data//cucumber_prok/cucumber/formatter/debug.rb;TiI"ÿ      def function(arglist)
        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/;Fi[	@™i$I"¨      
      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive;Fi[	I"3data//devise_proj/devise/models/validatable.rb;Ti)I"B      # or confirmation are being set somewhere.
      def function(arglist)
        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length);Fi[	I"8data//devise_proj/devise/strategies/rememberable.rb;Ti"I"D        if var.respond_to?(:extend_remember_period=) then
          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "remember_#{scope}_token");Fi[	I"(data//diaspora_proj/models/photo.rb;Ti~I"“  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  
  scope(:on_statuses, lambda { |arglist| where(:status_message_guid => (var)) })
end;Fi[	I"7data//diaspora_proj/models/relayable_retraction.rb;TiI"…  
  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("Performing relayable retraction for #{target_guid}");Fi[	@üiI"í    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing;Fi[	I"5data//rspec_proj/spec/mocks/argument_matchers.rb;TiI"ÿ      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "anything";Fi[@'@3@4I"@var = var;FI"end;FI" ;Fi[[	@iI"ﬁ      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	I"9data//bundler_proj/bundler/endpoint_specification.rb;Ti@I"œ      if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@ i
I"‡    def self.inject(arglist)
      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	@‡iâI"Ì        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        
        # Returns true if one or more steps failed
        def function(arglist);Fi[	@ÆiqI"¥        @var.flush
        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@±i/I"ƒ      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@ºiI"Œ    
    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["RACK_ENV"].to_s == "development");Fi[	@«iI"”    #:nodoc:
    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log];Fi[	@ïi1I"ê    
    def self.[](arglist)
      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@§iáI"¥  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§iãI"â  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§i¶I"π    else
      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§i™I"â  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§iÆI"â  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§i≤I"â  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§i∂I"â  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§i∫I"â  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@§iæI"ú  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("FPDF error: " + var));Fi[	@‚iUI"‘      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then;Fi[	@ÂiI"            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["#{@example_group.description} #{example.description}", var, var.location]);Fi[@'I"var;FI"end;FI"end;FI"end;FI"end;Fi[[	@ilI"ˇ          var.includes!((var[:includes] or var[:includes]))
          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@˚i2I"Õ            end
            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@iJI"ÿ          if var.query then
            var = Hash[var.query.split("&").map { |arglist| var.split("=") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	@ƒiáI"¥        end
        configuration.slice("host", "port", "socket").each do |arglist|
          var.concat(["--#{k}", var]) if var
        end
        var
      end
    end
  end
end;Fi[	@«inI"∞              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/basic.rb;TiNI"≠          unless var then
            say("Your response must be one of: [#{answers}]. Please try again.")
          end)
        end
        var
      end
    end
  end
end;Fi[	@)i¥I"¯        var = []
        var.each do |arglist|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end
ActiveRecord::Base.class_eval { |arglist| include(CanCan::ModelAdditions) };Fi[	I"Cdata//cancan_proj/cancan/model_adapters/data_mapper_adapter.rb;Ti"I"È        end
        var.each do |arglist|
          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end
DataMapper::Model.append_extensions(CanCan::ModelAdditions::ClassMethods);Fi[	@ i-I"            else
              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	@iŒI"F              (var << { :raw => (var.send("raw_#{prop}") rescue nil), :value => (var.send("#{prop}_without_default") rescue nil), :default => (var.send("default_#{prop}") rescue nil), :resolved => (var.send(var)) })
            end
            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	I"-data//cucumber_prok/cucumber/ast/step.rb;Ti|I"â        var.each do |arglist|
          var ||= ""
          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	@MiI"Æ              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	I"2data//nokogiri_proj/nokogiri/css/tokenizer.rb;TiuI"ñ          end
        else
          raise(ScanError, (("undefined state: '" + state.to_s) + "'"))
        end
        var
      end
    end
  end
end;Fi[	@)i&I"ì                [yield(var), var.id]
              end
            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	@,iI"«          if jsonp.present? then
            var = "#{jsonp}(#{json})"
            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end
end;Fi[	@¢iqI"?              var = @var[$1.to_i]
              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end;Fi[	I"-data//rspec_proj/spec/matchers/pretty.rb;Ti&I"              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@3i"I"+          if ((var == :state) or ((var == :event) and var)) and var.send("#{self.attribute}_changed?").! then
            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[I"#   # => [;FI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;TI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];TI"#;Ti[[	I"Kdata//activerecord_proj/active_record/associations/collection_proxy.rb;Ti*I"J      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@#icI"≈      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #   person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=4;Ti[	@#i|I"n      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #;Ti[	@#iöI"k      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #;Ti[	@#i	I"ì      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')])
      #   person.pets.size # => 5;Ti[	@#i>I"[      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@#iEI"h      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0
      #   person.pets      # => [];Ti[	@#i_I"[      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@#ifI"k      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@#ixI"[      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@#iI"k      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@#iïI"S      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all
      #;Ti[	@#iµI"î      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@#i—I"q      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3))
      #   # => [;Ti[	@#iÌI"î      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@#i	I"å      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1")
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@#i%I"ï      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@#iïI"¸      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3
      #   # Because the collection is already loaded, this will behave like;Ti[@'@(@ÊI"protected;FI" ;FI"def function(arglist);Fi[[	I"=data//activemodel_proj/active_model/attribute_methods.rb;TiÜI"Ê        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var)
    end;Fi[	I"Ddata//activemodel_proj/active_model/validations/numericality.rb;Ti0I"              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      
      def function(arglist)
        case var
        when /\A0[xX]/ then;Fi[	@EiSI"´          end
        else
          # do nothing
        end
      end
      
      protected
      
      def function(arglist)
        var = []
        var = var.parent;Fi[	@`i)I"Û            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then
          self.class.delegate_to_scoped_klass(var);Fi[	I"Edata//activerecord_proj/active_record/relation/finder_methods.rb;TiÆI"˝        connection.select_value(var, "#{name} Exists", var.bind_values))
      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@iI"‡        end
        self.stored_attributes[var] ||= []
        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist)
      var = initialize_store_attribute(var)
      var[var];Fi[	I">data//bundler_proj/bundler/vendor/thor/parser/argument.rb;Ti,I"˘        default.empty?.!
      else
        default
      end
    end
    
    protected
    
    def function(arglist)
      if required? and default.nil?.! then
        raise(ArgumentError, "An argument cannot be required and have default value.");Fi[	I"4data//cancan_proj/cancan/controller_resource.rb;TiKI"            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then
        build_resource;Fi[	I">data//capistrano_proj/capistrano/configuration/servers.rb;Ti?I"∫          var = var.select { |arglist| var.all? { |arglist| (var.options[var] == var) } }
          var = var.reject { |arglist| var.any? { |arglist| (var.options[var] == var) } }
          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist)
        return var unless (ENV["HOSTFILTER"] or ENV["HOSTROLEFILTER"])
        if ENV["HOSTFILTER"] then;Fi[	I"6data//compass_proj/compass/exec/sub_command_ui.rb;TiI"Œ          ::Compass::Exec::Helpers.report_error(var, (@var or {}))
        end
        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift;Fi[	I"Bdata//compass_proj/compass/sass_extensions/functions/lists.rb;Ti]I"«      else
        var
      end
    end
  end
  
  protected
  
  def function(arglist)
    unless var.is_a?(Sass::Script::List) then
      raise(ArgumentError.new("#{value.inspect} is not a list"));Fi[	I"0data//devise_proj/devise/models/lockable.rb;Ti`I"≈          else
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts)
      end;Fi[	I"Adata//mongoid_proj/lib/mongoid/multi_parameter_attributes.rb;TiEI"Í        super(var, var, var)
      else
        super
      end
    end
    
    protected
    
    def function(arglist)
      return nil if var.all? { |arglist| var.nil? }
      var = var.collect { |arglist| var.nil? ? (1) : (var) };Fi[	I"5data//rspec_proj/spec/example/example_matcher.rb;TiI"É      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist)
        var =~ /(^#{example_group_regex} #{example_regexp}$|^#{example_group_regex}$|^#{example_group_with_before_all_regexp}$|^#{example_regexp}$)/
      end;Fi[	I"1data//whenever_proj/whenever/command_line.rb;Ti-I"‘          puts("## [message] Run `whenever --help' for more options.")
          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file])
    end;Fi[	I")data//whenever_proj/whenever/cron.rb;Ti6I"=          parse_as_string
        else
          parse_time
        end
      end
      
      protected
      
      def function(arglist)
        var = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
        @var.is_a?(String) and var.any? { |arglist| @var.downcase.index(var) };Fi[	I"7data//whenever_proj/whenever/output_redirection.rb;TiI"˜          ">> /dev/null 2>&1"
        else
          ""
        end
      end
      
      protected
      
      def function(arglist)
        return unless @var.has_key?(:standard)
        @var[:standard].nil? ? ("/dev/null") : (@var[:standard]);Fi[@'@3I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;FI"$# @example Mongoize the object.;Fi[[	I"7data//mongoid_proj/lib/mongoid/extensions/array.rb;TiPI"      # @since 3.0.0
      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@ÉiäI"-          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ])
        #;Fi[	I"=data//mongoid_proj/lib/mongoid/extensions/big_decimal.rb;TiI"¯      # @since 3.0.3
      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@◊iI"      # @since 3.0.0
      def function(arglist)
        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date.mongoize
      #;Fi[	@◊i.I"C        # @since 3.0.0
        def function(arglist)
          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Date.mongoize("2012-1-1")
        #;Fi[	I";data//mongoid_proj/lib/mongoid/extensions/date_time.rb;TiI"          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #;Fi[	@èi4I"@        # @since 3.0.0
        def function(arglist)
          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   DateTime.mongoize("2012-1-1")
        #;Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/hash.rb;TilI"Ê          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/object.rb;Ti~I"„        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@ói˘I"        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11")
        #;Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/range.rb;TiI"˜      # @since 3.0.0
      def function(arglist)
        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   range.mongoize
      #;Fi[	@úi:I"G        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : (::Range.new(var["min"], var["max"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Range.mongoize(1..3)
        #;Fi[	I"5data//mongoid_proj/lib/mongoid/extensions/set.rb;Ti"I"        # @since 3.0.0
        def function(arglist)
          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Set.mongoize(1..3)
        #;Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/string.rb;Ti±I""        # @since 3.0.0
        def function(arglist)
          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   String.mongoize("123.11")
        #;Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/symbol.rb;Ti!I"$        # @since 3.0.0
        def function(arglist)
          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Symbol.mongoize("123.11")
        #;Fi[	@⁄i4I"&            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1")
        #;Fi[	I"@data//mongoid_proj/lib/mongoid/extensions/time_with_zone.rb;Ti#I"K        def function(arglist)
          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   TimeWithZone.mongoize("2012-1-1")
        #;Fi[@Ë@ÈI" ;FI"private;FI" ;FI"def function(arglist);Fi[[	I"^data//activerecord_proj/active_record/associations/has_and_belongs_to_many_association.rb;TiI";          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size
      end;Fi[	@Bi:I"⁄        end
        save_through_record(var)
        update_counter(1)
        var
      end
      
      private
      
      def function(arglist)
        @var ||= owner.association(through_reflection.name)
      end;Fi[	I"Odata//activerecord_proj/active_record/associations/singular_association.rb;Ti"I"˛        var = build_record(var)
        yield(var) if block_given?
        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist)
        scope.scope_for_create.stringify_keys.except(klass.primary_key)
      end;Fi[	I"]data//activerecord_proj/active_record/connection_adapters/abstract/schema_definitions.rb;TiI"E        var[:null] = null unless null.nil?
        var[:default] = default unless default.nil?
        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist)
        base.add_column_options!(var, var.merge(:column => (self)))
      end;Fi[	@ºiƒI"§        end
        var
      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key)
    end;Fi[	I"Ddata//activerecord_proj/active_record/relation/query_methods.rb;Ti¨I"       var.distinct(uniq_value)
      var.from(build_from) if from_value
      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist)
      var = var.reject { |arglist| var.blank? }
      return [] if var.empty?;Fi[	I";data//activerecord_proj/active_record/schema_dumper.rb;TiI"±      header(var)
      tables(var)
      trailer(var)
      var
    end
    
    private
    
    def function(arglist)
      @var = var
      @var = @var.native_database_types;Fi[	I"&data//bundler_proj/bundler/env.rb;Ti%I"˜      ((var << read_file("Gemfile")) << "\n")
      ((var << "\n\n") << "Gemfile.lock\n")
      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip;Fi[	@|iUI"          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class
      ((var == Class) or (var == Module));Fi[	I"Idata//capistrano_proj/capistrano/recipes/deploy/remote_dependency.rb;Ti^I"‘      def function(arglist)
        var = @var.dup
        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/strategy/base.rb;TiBI"U            var = Benchmark.realtime { |arglist| var = super }
          end
          logger.trace("command finished in #{(elapsed * 1000).round}ms")
          var
        end
        
        private
        
        def function(arglist)
          @var ||= (configuration.logger or Capistrano::Logger.new(:output => (STDOUT)))
        end;Fi[	I"*data//diaspora_proj/models/reshare.rb;TiOI"∫    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch
    var.save! unless var.persisted?;Fi[	@piaI"ó        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp
  end;Fi[	@‘iàI"
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|
          send(var).reject! do |arglist|;Fi[	I"3data//redmine_proj/redmine/activity/fetcher.rb;TiHI"˘        end
        var.sort! { |arglist| (var.event_datetime <=> var.event_datetime) }
        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist)
        @@var[var]
      end;Fi[	I"?data//state_machine_proj/state_machine/event_collection.rb;TiI"≠          false
        end
      end)
      var
    end
    
    private
    
    def function(arglist)
      var and var[:on] ? ([fetch(var.delete(:on))]) : (self)
    end;Fi[@≥@¥I"	true;FI"end;FI" ;FI"def function(arglist);Fi[[	@ÑiI"Ù      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|
        if options.include?(var) then;Fi[	@ái
I"˚    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super
      define_constructors if constructable?;Fi[	@äiI"Õ      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end;Fi[	@GiI"é    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end;Fi[	@“i*I"Œ        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect
        end;Fi[	@ûi'I"#      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var);Fi[	@ûiåI"’      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss
      end;Fi[	@⁄iI"°    def function(arglist)
      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value
    end;Fi[	@XiAI"7    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "deg") and var.denominator_units.empty?))
    end;Fi[	@ßiI"œ        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/
        print(var);Fi[	@™i%I"Ø      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive
      end;Fi[	@Øi#I"          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "remember_#{scope}_token")
      end;Fi[	@µi I"  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("Performing relayable retraction for #{target_guid}")
    if (self.parent_author_signature.nil?.! or self.parent.author.remote?) then;Fi[	I"4data//jekyll_proj/jekyll/converters/identity.rb;Ti
I"å    safe(true)
    
    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end;Fi[	@üiI"ï    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@∫iI"         def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "anything"
        end;Fi[I"#   person.pets;TI"#   # => [;T@@@I"#   #    ];Ti[[	@#i)I"T      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name);Ti[	@#ibI"É      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@#i{I"Å      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@#iôI"~      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#iI"ì      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')]);Ti[	@#i=I"X      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@#i^I"X      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@#iwI"X      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@#iîI"Y      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all;Ti[	@#i¥I"a      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@#i–I"n      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3));Ti[	@#iÏI"a      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@#iI"Y      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1");Ti[	@#i$I"b      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1));Ti[	@#i|I"i      #   end
      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var);Ti[	@#i∞I"°      #
      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length;Ti[I"def function(arglist);FI"@var = var;FI"@var = var;FI"end;FI" ;FI"def function(arglist);Fi[[	@i{I"      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency
          Thread.new(frequency, pool) do |arglist|;Fi[	@iI"¸      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config
          when nil then;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/statement_pool.rb;Ti
I"‘    class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ºi˙I"¬    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class
    end;Fi[	I"@data//cancan_proj/cancan/model_adapters/abstract_adapter.rb;Ti)I"Y        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "This model adapter does not support fetching records from the database.")
      end;Fi[	@ÜitI"¯            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "highest")
          end;Fi[	I">data//compass_proj/compass/installers/template_context.rb;TiI"2        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)))
      end;Fi[	I"Hdata//cucumber_prok/cucumber/formatter/gherkin_formatter_adapter.rb;Ti
I"˙module Cucumber
  module Formatter
    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.uri(var.file)
        @var.feature(var.gherkin_statement);Fi[	I"=data//diaspora_proj/presenters/extreme_post_presenter.rb;TiI"Ãclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = PostPresenter.new(@var, @var)
    var = PostInteractionPresenter.new(@var, @var);Fi[	I"8data//diaspora_proj/presenters/o_embed_presenter.rb;TiI"¶  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json
  end;Fi[	I"7data//diaspora_proj/presenters/person_presenter.rb;TiI"class PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile))
    if (is_own_profile or person_is_following_current_user) then;Fi[	I"5data//diaspora_proj/presenters/post_presenter.rb;TiDI"_  end
end
class PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    { :likes => (as_api(@var.likes)), :reshares => (PostPresenter.collection_json(@var.reshares, @var)), :comments => (CommentPresenter.as_collection(@var.comments)), :participations => (as_api(@var.participations)) }
  end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/builder.rb;TiÅI"…      end
      
      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end;Fi[	I"4data//paperclip_proj/paperclip/url_generator.rb;TiI"require("uri")
module Paperclip
  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var)
    end;Fi[	@qiI"module Spec
  module Example
    class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var));Fi[@,I"# do nothing;FI"end;FI" ;F@∏I"# do nothing;Fi[[	@=iI"!      
      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@@i¸I"∞        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@@i I"©        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Ji‰I"†        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@OiI"≤require("rubygems/user_interaction")
module Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@OiI"ì      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@OiI"ì      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@OiI"ì      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@OiI"ì      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@ciRI"è  end
  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@iiI"÷        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@|i=I"Ø        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@§iI"ç  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  ;Fi[	@™iI"∑          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@≠iI"æ          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[I"# do nothing;FI"end;FI" ;F@∏I"# do nothing;FI"end;Fi[[	@=iI"[      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.;Fi[	@@i˝I"∞      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@@iI"∞      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@JiÂI"Ù      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in;Fi[	@Oi	I"ßmodule Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@OiI"ö    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@OiI"ö    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@OiI"ö    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@OiI"ö    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@ciSI"£  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@iiI"∞      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@|i>I"¢      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private;Fi[	@§iI"¢  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function;Fi[	@™iI"±        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[	@≠iI"±        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[I"	else;FI"# do nothing;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@[iÔI"n        (method(var).arity == 0) ? (send(var)) : (send(var, var))
      when Proc then
        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      raise(RecordNotFound, "Couldn't find #{self.class.reflect_on_association(association_name).klass.name} with ID=#{record_id} for #{self.class.name} with ID=#{id}")
    end;Fi[	@JiBI"“          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic)
      end;Fi[	I"6data//activerecord_proj/active_record/relation.rb;TiﬂI"ª        (var.to_sql == to_sql)
      when Array then
        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      var.pp(self.to_a)
    end;Ti[	I"\data//activerecord_proj/rails/generators/active_record/migration/migration_generator.rb;Ti I"E            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|
          var.index_name = [var, attributes[(var - 1)]].map { |arglist| index_name_for(var) };Fi[	@„i%I"ı        case var
        when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "img_#{@img_id}"
        @var = (@var + 1);Fi[	I"'data//homebrew_proj/cmd/install.rb;Ti"I"û    case Hardware.cpu_type
    when :ppc, :dunno then
      abort("        Sorry, Homebrew does not support your computer's CPU architecture.\n        For PPC support, see: https://github.com/mistydemeo/tigerbrew\n".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    if HOMEBREW_CELLAR.exist? and HOMEBREW_CELLAR.writable_real?.! then
      raise("Cannot write to #{HOMEBREW_CELLAR}");Fi[	I"%data//homebrew_proj/compilers.rb;Ti;I"«      MacOS.llvm_build_version.to_i
    when :gcc then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist)
    (@var.to_sym == var.to_sym)
  end;Fi[	@viI"÷    when Hash then
      @var = @var.keys.first
      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var.each_with_index do |arglist|
      if var.is_a?(Hash) then;Fi[	@vi~I"Û      raise("Empty archive")
    when 1 then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var = /https?:\/\/(www\.)?github\.com\/.*\/(zip|tar)ball\//
    if var.match(@var) then;Fi[	I"#data//homebrew_proj/patches.rb;TiYI"´    when :bzip2 then
      @var = (@var + ".bz2")
      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    @var.nil?.!
  end;Fi[	I"(data//homebrew_proj/requirements.rb;Ti(I"      ["/usr/bin/env", "ruby", "-rubygems", "-e", "require '#{@import_name}'"]
    when :rbx then
      ["/usr/bin/env", "rbx", "-rubygems", "-e", "require '#{@import_name}'"]
    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var
    when :chicken then;Fi[	@vi‹I"        case var[:format]
        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@viÔI"        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Project) and (var.start_date and var.due_date) then
          var[:zoom] ||= 1;Fi[	@viI"&        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Version) and (var.due_date and var.start_date) then
          var[:zoom] ||= 1;Fi[	@‚i5I"®          1
        when :twice then
          2
        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0
      end;Fi[@•I"
super;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@=ijI"\        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist)
          self.class.serialized_attributes.include?(var) ? (var.!=(var)) : (super)
        end;Fi[	@=ivI"M        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist)
          super.dup.tap do |arglist|
            self.class.serialized_attributes.each_key do |arglist|;Fi[	@çi=I"Ÿ            :integer
          when /bit/i then
            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var
          when /blob|text/i then;Fi[	@çiI"˝          else
            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      
      def function(arglist)
        if var[:first] then
          (var << " FIRST");Fi[	@çieI"f          RecordNotUnique.new(var, var)
        when 1452 then
          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
        add_column_options!(var, var);Fi[	@CiI";            (-1.0 / 0.0)
          when / BC$/ then
            super(("-" + var.sub(/ BC$/, "")))
          else
            super
          end
        end
        
        def function(arglist)
          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",");Fi[	@˜iQI"’            else
              super
            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var
          case var;Fi[	@ïi∆I"I        if var.kind_of?(String) and (var and ((var.type == :binary) and var.class.respond_to?(:string_to_binary))) then
          var = var.class.string_to_binary(var).unpack("H*")[0]
          "x'#{s}'"
        else
          super
        end
      end
      
      def function(arglist)
        @var.class.quote(var)
      end;Fi[	@ïiÿI"'      def function(arglist)
        if var.respond_to?(:usec) then
          "#{super}.#{sprintf("%06d", value.usec)}"
        else
          super
        end
      end
      
      def function(arglist)
        return var.to_f if BigDecimal.===(var)
        return super unless String.===(var);Fi[	I"9data//activerecord_proj/active_record/inheritance.rb;Ti|I"9      def function(arglist)
        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column)
      end;Fi[	@˙iI"	          var = ActiveRecord::LogSubscriber.reset_runtime
          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super
        if ActiveRecord::Base.connected? then;Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/color.rb;TitI"(          var = File.binread(var).to_s.split("\n")
          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "-" then;Fi[	I"9data//bundler_proj/bundler/vendor/thor/shell/html.rb;TibI"(          var = File.binread(var).to_s.split("\n")
          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "-" then;Fi[	I"5data//redmine_proj/redmine/views/builders/xml.rb;TiI"A        def function(arglist)
          if (var.size == 1) and var.first.is_a?(::Time) then
            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var)
        end;Fi[@,@-I"end;FI" ;FI"def function(arglist);FI"@var = var;Fi[[	I"Jdata//paperclip_proj/paperclip/matchers/have_attached_file_matcher.rb;TiI"      end
      
      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = @var.class unless Class.===(@var)
          responds? and (has_column? and included?);Fi[	I"Tdata//paperclip_proj/paperclip/matchers/validate_attachment_presence_matcher.rb;TiI"#      end
      
      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = var.new if (var.class == Class)
          error_when_not_valid? and no_error_when_valid?;Fi[	I"Pdata//paperclip_proj/paperclip/matchers/validate_attachment_size_matcher.rb;TiI"–      end
      
      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@§iâI"ñ    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@§içI"ï    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var);Fi[	@§i®I"u    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@§i¨I"|    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@§i∞I"|    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@§i¥I"|    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@§i∏I"|    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@§iºI"|    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@‹iI"√    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!
      end;Fi[	@ﬂi
I"    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var)
        @var = difference_between_arrays(@var, @var);Fi[	@‚iSI"4      # raise an instance of it, creating it with +new+. If the exception
      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[@•I"var;FI"end;FI"end;FI"end;FI" ;Fi[[	I"2data//activemodel_proj/active_model/errors.rb;TilI"œ        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end
  end
  
  class StrictValidationFailed < StandardError
  end;Fi[	@¯i!I"‡          aliases[var] += 1
          if (aliases[var] > 1) then
            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      
      private
      ;Fi[	@Ci-I",                var = var.gsub(/^"(.*)"$/, "\\1").gsub(/\\(.)/, "\\1")
                [var, var]
              end]
            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var);Fi[	@CizI"™                  nil
                end
              end
            else
              var
            end
          end
        end
        
        private
        ;Fi[	@¢iLI"$          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        
        class Integer < Type
          def function(arglist);Fi[	I"2data//activerecord_proj/active_record/core.rb;Ti`I"√        var = Relation.new(self, arel_table)
        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
    # attributes but not yet saved (pass a hash with key names matching the associated table column names).;Fi[	@¬iI"          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) };Fi[	I"9data//bundler_proj/bundler/vendor/thor/invocation.rb;TiI"        case var
        when Symbol, String then
          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    
    # Make initializer aware of invocations and the initialization args.
    def function(arglist);Ti[	I"1data//capistrano_proj/capistrano/transfer.rb;TiØI"Ù          var = StringIO.new(var.read)
          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("expected a file to upload");Fi[	I"9data//compass_proj/compass/configuration/adapters.rb;Ti*I"]        (additional_import_paths or []).map do |arglist|
          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1));Fi[	@hiZI"≠    else
      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end
    end
  end
  
  protected
  ;Fi[	@„i⁄I"         var.gsub(/\A([^:]*\.(?:rb|feature|haml)):(\d*).*\z/) do |arglist|
          if ENV["TM_PROJECT_DIRECTORY"] then
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      
      def function(arglist)
        (@var << "<script type=\"text/javascript\">document.getElementById('duration').innerHTML = \"Finished in <strong>#{format_duration(features.duration)} seconds</strong>\";</script>");Fi[	@ÜiîI"            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then;Fi[@≥@¥I"2broadcast(var) { |arglist| var.accept(self) };FI"end;FI" ;FI"def function(arglist);Fi[[	I"4data//cucumber_prok/cucumber/ast/tree_walker.rb;TiI"      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@IiI"!      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@IiI"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@Ii!I"„      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@Ii2I"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@Ii:I"      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@Ii>I"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@IiFI"˜      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@IiNI"      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@IiRI"`      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|
          visit_step_name(var, var, var, var, var, var);Fi[	@IibI"      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@IinI"      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@IirI"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[@'@3@4@CI"end;FI" ;Fi[[	@IiI"      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@IiI"      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@IiI"ˇ      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@Ii I"‡      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@Ii1I"G      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@Ii9I"      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@Ii=I"      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@IiEI"Ù      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@IiMI"      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@IiQI"/      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|;Fi[	@IiaI"˛      
      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@IimI"ˇ      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@IiqI"      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[@'@3@4I"
false;FI"end;FI" ;Fi[[	@äiI"•      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false;Fi[	@äiI"”      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions
      def function(arglist);Fi[	@äikI"€            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true;Fi[	@@i}I"#      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,
      # SQLite < 3.6.8 does not.;Fi[	@Gi!I"è    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false;Fi[	@Gi%I"ñ    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= "";Fi[	@JiI"	      # ThroughReflection.
      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false
      end
      
      # An array of arrays of scopes. Each item in the outside array corresponds to a reflection
      # in the #chain.;Fi[	@OiI"†    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI
      attr_writer(:shell);Fi[	I"3data//bundler_proj/bundler/vendor/thor/task.rb;TiI"    def function(arglist)
      super(var)
      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    
    # By default, a task invokes a method in the thor class. You can change this
    # implementation to create custom tasks.;Fi[	I"2data//compass_proj/compass/installers/base.rb;Ti7I"      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "#{options[:pattern_name]}/" if options[:pattern_name];Fi[	@iI"∞      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped;Fi[	I"/data//diaspora_proj/models/conversation.rb;Ti0I"◊  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join(";");Fi[	@óiyI"˙  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("notifier.a_post_you_shared");Fi[@•@¶@ß@®I"end;FI"end;Fi[[	I"Ddata//activerecord_proj/active_record/associations/preloader.rb;TiàI"õ          HasAndBelongsToMany
        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	I"`data//activerecord_proj/active_record/connection_adapters/postgresql/database_statements.rb;TiOI"R                var.gsub!(/[^-\d.]/, "")
              when /^-?\D+[\d.]+,\d{2}$/ then
                var.gsub!(/[^-\d,]/, "").sub!(/,/, ".")
              else
                # do nothing
              end
            end
          end
        end
        
        # Queries the database and returns the results in an Array-like object;Fi[	I":data//activerecord_proj/active_record/transactions.rb;Ti I"¶        destroyed?
      when :update then
        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	I"6data//bundler_proj/bundler/vendor/thor/actions.rb;TiI"æ      when Hash then
        [:force, :skip, "force", "skip"].each { |arglist| var.delete(var) }
        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	@\iKI"~        "key:value"
      when :array then
        "one two three"
      else
        # do nothing
      end
    end
  end
end;Fi[	@ÄiI"ú            false
          when "a" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@7iøI"z        var.abort!
      when :scp then
        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	@§i>I"º          when :stdout then
            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"$data//homebrew_proj/cmd/edit.rb;Ti+I"é      case File.basename(var)
      when "LinkedKegs", "Aliases" then
        true
      else
        # do nothing
      end
    end
  end
end;Fi[	I"4data//jekyll_proj/jekyll/converters/markdown.rb;TisI"Ä        var
      when "maruku" then
        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	@!iHI"Ô            when "day" then
              (@var << "#{date_from.to_date}")
              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist);Fi[	@ÿi)I"†            else
              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[@'@3@4I"@var = true;FI"end;FI" ;Fi[[	@liI"Œ        @var = var["name"]
        @var = var["version"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@li"I"„      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def self.from_lock(arglist)
        new(var.merge("path" => (var.delete("remote"))));Fi[	I"2data//bundler_proj/bundler/source/rubygems.rb;TiI"        @var = false
        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@œiI"∫      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash;Fi[	@Oi=I"∑      
      def function(arglist)
        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      ;Fi[	@OiGI"’      
      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?;Fi[	I"0data//compass_proj/compass/commands/base.rb;TiI"ö      
      def function(arglist)
        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      protected
      ;Fi[	I"+data//cucumber_prok/cucumber/errors.rb;TiI"¿    def function(arglist)
      super("Undefined step: \"#{step_name}\"")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function
  end;Fi[	@ti2I"        write_file(feature_result_filename(var.file), @var.target!)
        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false;Fi[	@±i=I"À        return unless @var
        var ||= @var
        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      
      private
      ;Fi[	I"2data//rspec_proj/spec/runner/configuration.rb;TiüI"ƒ      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false;Fi[@Ä@ÅI"end;FI"end;FI"end;FI"end;Fi[[	@®iâI"}        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	@VicI"¶          begin
            var.mkdir(var.join("/"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@YiUI"∞          begin
            var.mkdir!(var.join("/"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ÄiI"ä          when "a" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@§i?I"†            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"5data//nokogiri_proj/nokogiri/xml/sax/document.rb;TimI"¬        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/runner/formatter/base_formatter.rb;TiêI"‘        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@™iI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@≠iI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@™iI"z        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@ÿi*I"è              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[@•@@@I" ;FI"def function(arglist);Fi[[	@∑i<I"˘            end
          end
          var
        else
          var
        end
      end
      
      def function(arglist)
        if options_include_default?(var) then
          (var << " DEFAULT #{quote(options[:default], options[:column])}");Fi[	@CiI"        def function(arglist)
          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",")
          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil;Fi[	@CiQI"K        def function(arglist)
          if IPAddr.===(var) then
            "#{object.to_s}/#{object.instance_variable_get(:@mask_addr).to_s(2).count("1")}"
          else
            var
          end
        end
        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end;Fi[	@¬i›I"–      when Relation then
        var ||= "subquery"
        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist)
      var = var.group_by do |arglist|
        case var;Fi[	I"=data//bundler_proj/bundler/vendor/thor/parser/options.rb;Ti@I"ü        shift
        @var = false
        super
      else
        var
      end
    end
    
    def function(arglist)
      @var = var.dup
      @var = true;Fi[	@1i\I"Ó          else
            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end;Fi[	I"Ddata//compass_proj/compass/sass_extensions/functions/sprites.rb;Ti I"%      Sass::Script::String.new(reversed_color_names[var.rgb])
    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then
      missing_sprite!(var);Fi[	I"-data//devise_proj/devise/test_helpers.rb;TiNI"’        end
      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist)
      var[:action] ||= :unauthenticated
      var = var["warden"];Fi[	@~iI"¡      "beta"
    when /\d+/ then
      var.to_i
    else
      var
    end
  end
  
  def function(arglist)
    return unless var.is_a?(VersionElement)
    return -1 if string? and var.numeric?;Fi[	@Wi(I"7      if var[:timestamp] and timestamp_possible? then
        var = var.match(/\?.+=/) ? ("&") : ("?")
        "#{url}#{delimiter_char}#{@attachment.updated_at.to_s}"
      else
        var
      end
    end
    
    def function(arglist)
      @var.respond_to?(:updated_at) and @var.updated_at.present?
    end;Fi[	@íi6I"Á      def function(arglist)
        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist)
        var = I18n.translate(:"number.human.storage_units.format", :locale => (options[:locale]), :raise => (true))
        var = I18n.translate(:"number.human.storage_units.units.byte", :locale => (options[:locale]), :count => (var.to_i), :raise => (true));Fi[@≥@¥I"@var = false;FI"end;FI" ;FI"def function(arglist);Fi[[	I"6data//compass_proj/compass/installers/manifest.rb;TikI"∂      attr_reader :function
      
      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@&	ioI"√      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin
          (@var = var;Fi[	@ti7I"ˇ      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?
        var = var.split(/\r?\n/);Fi[	@tiYI"…        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
        @var = Time.now;Fi[	@±iI"“        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var
        @var = false;Fi[	@±i'I"Œ        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var)
        @var = var;Fi[	I"4data//cucumber_prok/cucumber/formatter/rerun.rb;Ti"I"      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then
          (@var << var.line);Fi[	@3	i<I"ª        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
      end;Fi[	@ci´I"ˇ      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["if", "case", "unless"].include?(var.value[:keyword])
      return unless (var.value[:keyword] == "case");Fi[	@yiI"Õ      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        Spec::Runner.configuration.mock_framework
      end;Fi[I"var = -1;FI"var = var;FI"var = 0;FI"if (var == 1) then;FI"@var = @var;FI"!var = ((@var - @var) - @var);Fi[[	@õiΩI"E      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@õi€I"W          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@ûi∏I"?      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@ûi„I"W          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@°i¨I"E      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@°i I"W          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@§iîI"G      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@§iµI"8          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@îi∞I"2      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[	@îiŒI"#          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[@'@(@)I"var;FI"end;FI" ;Fi[[	@BieI"J          else
            if (var.macro == :has_one) then
              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!;Fi[	@i´I"        var.gem_platforms(@var).each do |arglist|
          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|;Fi[	I"@data//capistrano_proj/capistrano/configuration/callbacks.rb;Ti|I"S            warn(var)
            var = var.map do |arglist|
              (var == "deploy:symlink") ? ("deploy:create_symlink") : (var)
            end
          end
        end
        var
      end
      
      # Trigger the named event for the named task. All associated callbacks
      # will be fired, in the order they were defined.;Fi[	@XiFI"9        else
          if (var.value.last == var.value.last) and (var.value.first.value == 0) then
            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    
    # returns the end position of the gradient from the color stop
    def function(arglist);Fi[	@`iYI"           person_link(var, :class => "mention hovercardable")
        else
          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then;Fi[	I",data//mongoid_proj/lib/mongoid/dirty.rb;TiêI"⁄            var.add_atomic_changes(self, var, var, var, var, var)
          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    ;Fi[	I"0data//mongoid_proj/lib/mongoid/hierarchy.rb;Ti,I"◊              var.push(var)
              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end
    
    # Marks all children as being persisted.
    #;Fi[	@úi1I"√                  var = 0
                end
              end
            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("B", 8);Fi[	@yiÓI"·              (var << var)
            else
              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true);Fi[	I"Adata//state_machine_proj/state_machine/machine_collection.rb;Ti+I"q        each_value do |arglist|
          if var.dynamic_initial_state? then
            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    
    # Runs one or more events in parallel on the given object.  See
    # StateMachine::InstanceMethods#fire_events for more information.;Fi[@'@3@4@ΩI"	self;FI"end;Fi[[	I"Hdata//capistrano_proj/capistrano/recipes/deploy/local_dependency.rb;TiI"¯        @var ||= "`#{command}' could not be found in the path on the local host"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@ÕiRI"©          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@iI"Ê      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@iI"À        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@≥iAI"      
      def function(arglist)
        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@≥iFI"µ      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@≥iKI"µ      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@≥iPI"µ      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@≥iUI"µ      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	I"1data//rspec_proj/spec/matchers/respond_to.rb;Ti I"       
      def function(arglist)
        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[@'@Î@ÏI" ;FI"private;FI" ;Fi[[	I"9data//activemodel_proj/active_model/serialization.rb;Ti6I"®        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send)
    ;Fi[	@µiI">        else
          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size;Fi[	I"Ndata//activerecord_proj/active_record/associations/through_association.rb;TiI"°        var = super
        chain[(1..-1)].each do |arglist|
          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      
      # Construct attributes for :through pointing to owner and associate. This is used by the
      # methods which create and delete records on the association.;Fi[	I":data//activerecord_proj/active_record/associations.rb;Ti©I":        var = self.class.reflect_on_association(var)
        var = var.association_class.new(self, var)
        association_instance_set(var, var)
      end
      var
    end
    
    private
    
    # Returns the specified association instance if it responds to :loaded?, nil otherwise.
    def function(arglist);Fi[	@ºi√I"™          end
        end
        var
      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key);Fi[	@|iTI"        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class;Fi[	@”iNI"•    var = self
    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch;Fi[	@pi`I"ﬁ        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp;Fi[	@‘iáI"ı        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|;Fi[	@h	iíI"À            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.
    #;Fi[I"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;FI" ;FI"##;Fi[[	I"2data//backup_proj/backup/notifier/campfire.rb;TiI"      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"1data//backup_proj/backup/notifier/hipchat.rb;Ti/I"        @var ||= "yellow"
        @var ||= "yellow"
        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I".data//backup_proj/backup/notifier/mail.rb;TinI"      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"/data//backup_proj/backup/notifier/prowl.rb;TiI":      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"2data//backup_proj/backup/notifier/pushover.rb;TiI"      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"1data//backup_proj/backup/notifier/twitter.rb;TiI"      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"3data//backup_proj/backup/storage/cloudfiles.rb;TiI"        super(var, var)
        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage
      def function(arglist);Fi[	I"0data//backup_proj/backup/storage/dropbox.rb;Ti$I">        super(var, var)
        @var ||= "backups"
        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # The initial connection to Dropbox will provide the user with an
      # authorization url. The user must open this URL and confirm that the;Fi[	I"1data//backup_proj/backup/storage/ninefold.rb;TiI"	      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage
      def function(arglist);Fi[	I"+data//backup_proj/backup/storage/s3.rb;TiI"      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage
      def function(arglist);Fi[@≥@¥@úI"@var = var;FI"end;FI" ;Fi[[	@iI"Ê      
      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency;Fi[	@iI"Î      
      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config;Fi[	@8i	I"Ê  module ConnectionAdapters
    class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@ºi˘I"¬    end
    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class;Fi[	I")data//backup_proj/backup/splitter.rb;TiI"€module Backup
  class Splitter
    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##
    # This is called as part of the procedure used to build the final;Fi[	@=i(I"z      def self.matches_condition?(arglist)
        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "This model adapter does not support fetching records from the database.");Fi[	@ÜisI"            var = (var[3] or "highest")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "highest");Fi[	@BiI"D      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)));Fi[	@Ki
I"∑  include(PostsHelper)
  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json;Fi[	@QiI"require(Rails.root.join("lib", "template_picker"))
class PostPresenter
  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def self.collection_json(arglist)
    var.map { |arglist| PostPresenter.new(var, var) };Fi[@≥@¥@úI"	self;FI"end;FI" ;Fi[[	@y	iI"Æ        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@ÕiSI"ô        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@iI"—        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var;Fi[	@iI"ÿ          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last;Fi[	@≥iBI"      def function(arglist)
        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@≥iGI"¨        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@≥iLI"¨        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@≥iQI"¨        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@≥iVI"∑        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "change ##{@message}";Fi[	@å	i!I"–      def function(arglist)
        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self;Fi[@'@3@4I"raise(NotImplementedError);FI"end;FI" ;Fi[[	I"Ndata//activerecord_proj/active_record/associations/builder/association.rb;Ti7I"Ó      @var = model.create_reflection(macro, name, scope, options, model)
      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options;Fi[	I"Tdata//activerecord_proj/active_record/associations/join_dependency/join_part.rb;TiI"!        
        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # An Arel::Table for the active_record
        def function(arglist);Fi[	@iI"        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope;Fi[	@8iI"·      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@8iI"Â      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@8iI"Â      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@8iI"Â      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@8iI"Â      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@8i!I"Â      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[I")#   matcher.matches?({ :key => 10 });FI"#;FI"1# @param [ Hash ] value The values to check.;FI"#;FI"1# @return [ true, false ] If a value exists.;FI"def function(arglist);Fi[[	I"6data//mongoid_proj/lib/mongoid/matchers/exists.rb;TiI"2      # non-existence.
      #
      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first)
      end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/gt.rb;TiI"O      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>)
      end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/gte.rb;TiI"\      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=)
      end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/in.rb;TiI"ê      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var)
        var.values.first.any? { |arglist| var.any? { |arglist| var.===(var) } };Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/lt.rb;TiI"L      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<)
      end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/lte.rb;TiI"Y      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=)
      end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/ne.rb;TiI"Z      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first)
      end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/nin.rb;TiI"      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) }
      end;Fi[	I"4data//mongoid_proj/lib/mongoid/matchers/size.rb;TiI"c      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first)
      end;Fi[I"@var = var;FI"end;FI" ;FI"def function(arglist);FI"@var = var;FI"end;Fi[[	@±i.I"∏      
      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@§iäI"Ä  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@§i©I"Ä  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@§i≠I"Ä  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@§i±I"Ä  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@§iµI"Ä  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@§iπI"Ä  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@§iΩI"Ä  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@‚iTI"      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[I"#   end;FI"#;FI" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[[	@#i:I"ï      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#i[I"Ç      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#itI"Ö      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#iëI"m      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#i±I"ï      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#iÕI"Ç      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#iÈI"Ö      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#iI"m      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#i!I"m      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@≥@¥@ú@—	I"@var = var;FI"@var = var;Fi[[	@i
I"6    class Preloader
      class Association
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class)
          @var = nil;Fi[	@ƒiI"     attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@ai	I"∫module Bundler
  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = [];Fi[	I"7data//bundler_proj/bundler/remote_specification.rb;TiI"ª    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@diI"        attr_accessor(:path, :uri, :ref)
        
        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var or Proc.new { |arglist| true })
        end;Fi[	@7i!I"æ    attr_reader(:logger)
    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/sprite_map.rb;Ti"I"R            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["cleanup"] ||= Sass::Script::Bool.new(true)
          @var["layout"] ||= Sass::Script::String.new("vertical");Fi[	I".data//cucumber_prok/cucumber/rake/task.rb;Ti)I"¯      
      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end;Fi[	I",data//diaspora_proj/mailers/notifier.rb;Ti$I"F      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("notifier.invited_you", :name => (@var.name))), :host => (AppConfig.pod_uri.host) }
    I18n.with_locale(var) do |arglist|;Fi[@'@(@Ê@Á@ËI"##;Fi[[	I"(data//backup_proj/backup/archive.rb;TiUI"6        Logger.message("#{self.class} Complete!")
      else
        raise(Errors::Archive::PipelineError, ("Failed to Create Backup Archive\n" + var.error_messages))
      end
    end
    
    private
    
    ##
    # Returns a "tar-ready" string of all the specified paths combined
    def function(arglist);Fi[	I"1data//backup_proj/backup/database/mongodb.rb;TiKI"’        ensure
          (unlock_database if @var
          package! unless var)
        end
      end
      
      private
      
      ##
      # Builds and runs the mongodump command
      def function(arglist);Fi[	I"/data//backup_proj/backup/database/mysql.rb;TiGI"F          Logger.message("#{database_name} Complete!")
        else
          raise(Errors::Database::PipelineError, ("#{database_name} Dump Failed!\n" + var.error_messages))
        end
      end
      
      private
      
      ##
      # Builds the full mysqldump string based on all attributes
      def function(arglist);Fi[	@i/I"            run("#{command} -c #{backup_file} > #{(backup_file + ext)}")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes
      def function(arglist);Fi[	I".data//backup_proj/backup/encryptor/gpg.rb;TidI"˚          yield("#{utility(:gpg)} #{base_options} #{mode_options}", ".gpg"))
        ensure
          cleanup
        end
      end
      
      private
      
      ##
      # Remove any temporary directories and reset all instance variables.
      #;Fi[	I".data//backup_proj/backup/notifier/base.rb;Ti?I"–        if var then
          log!
          notify!(var)
        end
      end
      
      private
      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist);Fi[	@\iRI"ü              Parallel.each(all_file_names, { :in_processes => (var) }, &var)
            else
              raise(Errors::Syncer::Cloud::ConfigurationError, "Unknown concurrency_type setting: #{concurrency_type.inspect}")
            end
          end
          
          private
          
          ##
          # Gathers all the relative paths to the local files
          # and merges them with the , removing;Fi[	I"2data//backup_proj/backup/syncer/rsync/pull.rb;TiI"‚            end)
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return expanded @path, since this path is local
        def function(arglist);Fi[	I"2data//backup_proj/backup/syncer/rsync/push.rb;Ti5I"?            run(("#{utility(:rsync)} #{options} #{directories_option} " + "'#{username}@#{ip}:#{dest_path}'")))
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return @path with any preceeding "~/" removed
        def function(arglist);Fi[@≥@¥I"@var[var];FI"end;FI" ;FI"def function(arglist);Fi[[	@¢i™I"Ï          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var)
          end;Fi[	@i}I"∫    end
    
    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist)
      @var[(var or false)] ||= {}
      @var[(var or false)][var] ||= begin;Fi[	@«iNI"Œ      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "#{name} (#{version})"
      end;Fi[	@7i~I"Õ      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	I"1data//cucumber_prok/cucumber/ast/features.rb;TiI"ª      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end;Fi[	I".data//cucumber_prok/cucumber/ast/table.rb;TiAI"‘        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line
        end;Fi[	I"0data//cucumber_prok/cucumber/cli/options.rb;Ti0I"∆        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	@Æi›I"¯        var[(1..-1)].each { |arglist| @var.puts("    #{s}") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var)
        print_snippets(@var);Fi[	@TiâI"        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({})
          case var.to_s;Fi[I"#;F@\
I"#   person.pets;TI"#   # => [;T@_
I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[[	@#i;I"û      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#i\I"ã      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#iuI"é      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#iíI"v      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#i≤I"û      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#iŒI"ã      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#iÍI"é      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#iI"v      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#i"I"v      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[I" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;T@_
@»
I">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[[	@#i<I"z      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#i]I"g      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#ivI"j      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iìI"R      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#i≥I"z      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iœI"g      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iÎI"j      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iI"R      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#i#I"R      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[@'@3@4I"@var[var];FI"end;FI" ;Fi[[	@¢i©I"È          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var);Fi[	@«iMI"À      
      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "#{name} (#{version})";Fi[	@7i}I"       
      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	@∏
iI"∏      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var);Fi[	@ª
i@I"—        
        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line;Fi[	@æ
i/I"Œ        @var = []
        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	@Æi‹I"Ì        @var.puts
        var[(1..-1)].each { |arglist| @var.puts("    #{s}") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var);Fi[	@TiàI"Ú        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({});Fi[	I";data//rspec_proj/spec/example/example_group_factory.rb;Ti@I"Ã          var = @var
          @var = Hash.new(var)
          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        
        protected
        ;Fi[@,@-I"	self;FI"end;FI" ;FI"def function(arglist);Fi[[	@iI"¬          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self;Fi[	@i I"“          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last
          self;Fi[	I"3data//rspec_proj/spec/example/example_proxy.rb;Ti I"3      
      # Convenience method for example group - updates the value of
      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        (var.description == description).&((var.location == location))
      end;Fi[	@≥iCI"        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@≥iHI"¶        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@≥iMI"¶        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@≥iRI"¶        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@≥iWI"Æ        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "change ##{@message}"
      end;Fi[	@å	i"I"æ        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end;Fi[@≈
I"$# @example Do the values match?;F@
I"#;F@
I"#;Fi[[	I"3data//mongoid_proj/lib/mongoid/matchers/all.rb;Ti	I"b  module Matchers
    class All < Default
      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If the values match.
      def function(arglist);Fi[	@(
i	I"S  module Matchers
    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@+
i	I"`  module Matchers
    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@.
i	I"J  module Matchers
    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@1
i	I"P  module Matchers
    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@4
i	I"]  module Matchers
    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@7
i	I"W  module Matchers
    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@:
i	I"S  module Matchers
    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@=
i	I"\  module Matchers
    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[@'@3@4I"@var = false;FI"end;FI" ;Fi[[	@@i^I"      def function(arglist)
        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      
      # Returns the human-readable name of the adapter. Use mixed case - one
      # can always use downcase if needed.;Fi[	@&	inI"¥      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin;Fi[	@ti6I"Â      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?;Fi[	@tiXI"Õ      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@±iI"œ        @var.puts
        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var;Fi[	@±i&I"◊      def function(arglist)
        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var);Fi[	@3	i!I"Ó      
      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then;Fi[	@3	i;I"Õ      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@ci™I"ﬁ      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["if", "case", "unless"].include?(var.value[:keyword]);Fi[I"	self;FI"end;FI"end;FI"end;FI"end;FI"end;Fi[[	I":data//mongoid_proj/lib/mongoid/relations/accessors.rb;Ti¸I"¥          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/relations/builders.rb;TiTI"ê            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/cascading.rb;Ti3I"©        # @since 2.0.0.rc.1
        def function(arglist)
          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/polymorphic.rb;Ti I"ë              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/relations/synchronization.rb;TiåI"ø        # @since 2.2.1
        def function(arglist)
          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/touchable.rb;TiI"¶        # @since 3.0.0
        def function(arglist)
          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/timestamps/timeless.rb;Ti.I"é        # @since 2.3.0
        def function(arglist)
          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	@Ti§I"~            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end
end;Fi[@'@3I"private;FI" ;F@ÈI"
begin;Fi[[	@»i&I"‰      ((var << "\n\n") << "Gemfile.lock\n")
      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip
      rescue Errno::ENOENT;Fi[	@Õi_I"ˆ        var = @var.dup
        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var
          configuration.invoke_command(var, var) do |arglist|;Fi[	I"-data//cucumber_prok/cucumber/cli/main.rb;Ti;I"        @var.parse!(@var)
        Cucumber.logger = @var.log
        @var
      end
      
      private
      
      def function(arglist)
        begin
          (return false unless configuration.drb?
          @var = DRbClient.run(@var, @var, @var, configuration.drb_port);Fi[	I";data//cucumber_prok/cucumber/runtime/user_interface.rb;Ti3I"Ú      #
      def function(arglist)
        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin
          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var;Fi[	@pi,I"      puts("Updated Homebrew from #{master_updater.initial_revision[0, 8]} to #{master_updater.current_revision[0, 8]}.")
      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir[".git/*"].empty? then
        safe_system("git init");Fi[	I"@data//paperclip_proj/paperclip/geometry_detector_factory.rb;TiI"p    def function(arglist)
      var = GeometryParser.new(geometry_string.strip).make
      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin
        silence_stream(STDERR) do |arglist|
          Paperclip.run("identify", "-format '%wx%h,%[exif:orientation]' :file", :file => ("#{path}[0]"));Fi[	I"9data//redmine_proj/redmine/core_ext/active_record.rb;Ti	I"  module FinderMethods
    def function(arglist)
      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find_ids(var);Fi[	I")data//twitter_proj/twitter/client.rb;TiZI"'    # Perform an HTTP PUT request
    def function(arglist)
      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin
        connection.send(var.to_sym, var, var) do |arglist|
          var.headers[:authorization] = auth_header(var.to_sym, var, var).to_s;Fi[I"
super;FI"end;FI"end;FI"end;FI"end;FI"end;Fi[[	@=iÇI"æ          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	@ïiI"¢        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@`i;I"€              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods;Fi[	I"6data//backup_proj/backup/configuration/helpers.rb;TikI"µ          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/validations/localizable.rb;TiI"∑        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/active_model/versions.rb;TiI"∂        end
        def function(arglist)
          owner_class.set_callback(:validation, :after, "value", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	I"Rdata//state_machine_proj/state_machine/integrations/active_record/versions.rb;TikI"ø          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/mongo_mapper/versions.rb;TiSI"ø          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[@<	I"var = 0;FI"var = 0;FI"var = 0;FI"var = 1;FI"while (var < var) do;Fi[[	@õinI"˙        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@õi≤I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@ûicI"Ú        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@ûi≠I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@°i]I"˙        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@°i°I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@§iäI"Í    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[	@îi¶I"»      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[@≥@¥I"
false;FI"end;FI" ;FI"def function(arglist);Fi[[	@äiI"®      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end;Fi[	@äilI"ò          end
        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end;Fi[	@Gi"I"í    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end;Fi[	@Gi&I"ô    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= ""
    end;Fi[	@öi8I"·      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "#{options[:pattern_name]}/" if options[:pattern_name]
      end;Fi[	@iI"≥      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped
      end;Fi[	@üi1I"⁄  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join(";")
  end;Fi[	@óizI"ú  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("notifier.a_post_you_shared")
  end;Fi[I"if (var == 1) then;FI"@var = @var;F@A	I"/var = (((var - (2 * @var)) * 1000) / @var);FI"end;FI"var = (var + 1);Fi[[	@õi¿I"˙        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@õiﬁI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@ûiªI"˙        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@ûiÊI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var);Fi[	@°iØI"˙        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@°iÕI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@§ióI"˙        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@§i∏I"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1);Fi[I"var = var;FI"var = 0;F@?	I"@var = @var;F@A	@⁄i[[	@õiæI"=        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@õi‹I"+          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@ûiπI"=        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@ûi‰I"+          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@°i≠I"=        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@°iÀI"+          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@§iïI"@        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@§i∂I"	          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[@≥@¥I"(@var << var);FI"end;FI" ;FI"def function(arglist);Fi[[	I"0data//cucumber_prok/cucumber/ast/feature.rb;Ti#I"Œ          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init;Fi[	@›iI"‰      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self }
      end;Fi[	@ª
iI"“        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@„i2I"Ê        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?
        @var.each do |arglist|;Fi[	@ÅiI"º      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	I"%data//omni_proj/omniauth/form.rb;Ti5I"i      @var = true
      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "\n<fieldset#{" style='#{options[:style]}'" if options[:style]}#{" id='#{options[:id]}'" if options[:id]}>\n  <legend>#{legend}</legend>\n")
      self.instance_eval(&var);Fi[	I"/data//rspec_proj/spec/mocks/order_group.rb;TiI"»        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var)
      end;Fi[	@yi.I"π        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!
      end;Fi[I"var = 0;F@?	I"@var = @var;F@A	@⁄I"end;Fi[[	@õiøI"        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@õi›I"˙        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@ûi∫I"        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@ûiÂI"˙        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@°iÆI"        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@°iÃI"˙        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@§iñI"        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@§i∑I"˙        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[I"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;FI"#     end;FI"#   end;FI"#;Fi[[	@›iI"    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events
    #   ;Fi[	@›iDI"˚    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events
    #   ;Fi[	@›idI"g    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">
    #   events = Vehicle.state_machine.events;Fi[	@øiI"I        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@øiYI"I        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@øi}I"U        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|;Fi[	I"9data//state_machine_proj/state_machine/transition.rb;TiÂI">    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[	@Fi˛I"Å    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[@'@3@4I"(@var << var);FI"end;FI" ;Fi[[	@
i"I"‘          var.init
          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@›iI"·      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self };Fi[	@ª
iI"œ        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing;Fi[	@„i1I"Í        build_cell(@var, var, var)
        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?;Fi[	@ÅiI"π      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing;Fi[	@i4I"d    def function(arglist)
      @var = true
      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "\n<fieldset#{" style='#{options[:style]}'" if options[:style]}#{" id='#{options[:id]}'" if options[:id]}>\n  <legend>#{legend}</legend>\n");Fi[	@iI"⁄      def function(arglist)
        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var);Fi[	@yi-I"¡        @var = []
        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!;Fi[@≥I"##;FI"I# Removes the transferred archive file(s) from the storage location.;FI"6# Any error raised will be rescued during Cycling;FI"B# and a warning will be logged, containing the error message.;FI"def function(arglist);Fi[[	@≈	i8I"i          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|;Fi[	@»	iZI"J          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@ViDI"Y          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[	I".data//backup_proj/backup/storage/local.rb;Ti#I"p          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@À	i@I"b          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then;Fi[	@Œ	i;I"W          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock;Fi[	I",data//backup_proj/backup/storage/scp.rb;Ti8I"J          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@Yi6I"Y          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[@'@3I"##;F@a@b@ci[[	@≈	i7I"Ä            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@»	iYI"s            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@ViCI"~            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@mi"I"É          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@À	i?I"u            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@Œ	i:I"}            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@ti7I"Ü            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@Yi5I"Ç            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[@&@
I"#;F@
I"#;FI"1# @return [ true, false ] If a value exists.;Fi[[	@(
i
I"\    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>);Fi[	@+
i
I"j    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=);Fi[	@.
i
I"W    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var);Fi[	@1
i
I"Y    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<);Fi[	@4
i
I"g    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=);Fi[	@7
i
I"g    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first);Fi[	@:
i
I"ç    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) };Fi[	@=
i
I"r    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first);Fi[@'@(@ÊI"##;F@a@bi[[	@≈	i6I"ü          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@»	iXI"í          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@ViBI"¡            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@mi!I"ã          var = File.join(local_path, var)
          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@À	i>I"î          File.open(File.join(local_path, var), "r") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@Œ	i9I"ú          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@ti6I"…            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@Yi4I"≈            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[I"def self.included(arglist);FI"var.extend(ClassMethods);FI"end;FI" ;FI"module ClassMethods;FI"def function(arglist);Fi[[	@Xi0I"N  end
  
  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end;Fi[	@éiI"amodule Redmine
  module Acts
    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          unless self.included_modules.include?(Redmine::Acts::ActivityProvider::InstanceMethods) then
            cattr_accessor(:activity_provider_options);Fi[	I"Ldata//redmine_proj/plugins/acts_as_attachable/lib/acts_as_attachable.rb;TiI"module Redmine
  module Acts
    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          cattr_accessor(:attachable_options)
          self.attachable_options = {};Fi[	I"Pdata//redmine_proj/plugins/acts_as_customizable/lib/acts_as_customizable.rb;TiI"1module Redmine
  module Acts
    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Customizable::InstanceMethods) then
            return;Fi[	I"Bdata//redmine_proj/plugins/acts_as_event/lib/acts_as_event.rb;TiI"#module Redmine
  module Acts
    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Event::InstanceMethods) then
            return;Fi[	I"Jdata//redmine_proj/plugins/acts_as_watchable/lib/acts_as_watchable.rb;TiI"+module Redmine
  module Acts
    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Watchable::InstanceMethods) then
            return;Fi[	I"Ddata//redmine_proj/plugins/rfpdf/lib/rfpdf/action_controller.rb;Ti	I"&  module ActionController
    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var);Fi[	I"3data//redmine_proj/redmine/subclass_factory.rb;TiI"∆module Redmine
  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = nil
        begin;Fi[@•@@@@ I"end;Fi[[	I"Kdata//activemodel_proj/active_model/forbidden_attributes_protection.rb;TiI"¡    def function(arglist)
      if var.respond_to?(:permitted?) and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	@CieI"<                var = ("(" == var[1]) ? ((var[2].to_i + 1)) : (var[2].to_i)
                var = (")" == var[5]) ? ((var[4].to_i - 1)) : (var[4].to_i)
                (var..var)
              else
                var
              end
            end
          end
        end
        
        def function(arglist);Fi[	@˝i≈I"}          false
        when "nil" then
          nil
        else
          var
        end
      end
    end
  end
end;Fi[	@åiÑI"û            "#head"
          when /^\d+/ then
            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	@⁄i?I"        if var.respond_to?(:supports?) and (var.supports?(var) and var.respond_to?(:"to_#{var}")) then
          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  
  def function(arglist);Fi[	@i•I"£            var.backtrace.push(var.backtrace_line("World"))
            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@i'I"û            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@#i2I"•          var = default_scoping.try(:call)
          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[@≥@¥@
I"end;FI" ;FI"def function(arglist);Fi[[	@	
i8I"≠      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options
    end;Fi[	@iI"        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope
        end;Fi[	@8iI"œ        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@8iI"Ë      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@8iI"Ë      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@8iI"Ë      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@8iI"Ë      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@8i"I"Ë      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[I"##;F@a@b@c@dI"var = remote_path_for(var);Fi[[	@≈	i9I"Œ        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|
          Logger.message(("#{storage_name} started removing '#{local_file}' " + "from container '#{container}'."));Fi[	@»	i[I"l        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@ViEI"}        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[	@mi$I"l        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@À	iAI"g        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then
          var = [];Fi[	@Œ	i<I"y        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock
        transferred_files_for(var) do |arglist|;Fi[	@ti9I"l        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@Yi7I"}        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[@'@3I"module ClassMethods;FI"I# Convert the object from its mongo friendly ruby type to this type.;FI"#;FI"&# @example Demongoize the object.;Fi[[	@àiI"      # @since 3.0.0
      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Object.demongoize(object)
        #;Fi[	@◊iI"(      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Date.demongoize(object)
        #;Fi[	@èi%I"0      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   DateTime.demongoize(object)
        #;Fi[	@úi+I",      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Range.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@°iI":      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Set.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@§i¢I"        else
          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   String.demongoize(object)
        #;Fi[	@ßiI"%      # @since 2.3.1
      def function(arglist)
        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Symbol.demongoize(object)
        #;Fi[	@¨iI"G      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   TimeWithZone.demongoize(object)
        #;Fi[@≈
I"# @since 3.0.0;FI"def function(arglist);FI"	self;FI"end;FI" ;Fi[[	I"/data//mongoid_proj/lib/mongoid/criteria.rb;TiHI"∫    #   criteria.to_criteria
    #
    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    
    # Convert the criteria to a proc.
    #;Fi[	@óiI"Ë      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[	@óiI"”      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.
      #;Fi[	@ói(I"Ÿ      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.
      #;Fi[	@ói@I"‹      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.
      #;Fi[	@óiÇI"…      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Is the object multi args.
      #;Fi[	I";data//mongoid_proj/lib/mongoid/extensions/object_id.rb;TiI"˙      #   object_id.__evolve_object_id__
      #
      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[@•@—@“@”I"end;FI"end;Fi[[	@=iÅI"‹        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	@ïiI"ª        case var.message
        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@`i:I"Ì            if arel.respond_to?(var) then
              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    ;Fi[	@úijI"…        if var then
          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	@~
i4I"∏    def function(arglist)
      if Gem::Specification.new.respond_to?(var) then
        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	@“iPI"            else
              if configuration.respond_to?(var) then
                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        
        def function(arglist);Fi[	@üiI"⁄        var = var.fields[var.to_s]
        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[@'@3@4I"0;FI"end;FI" ;Fi[[	@GiI"Ö    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@GiI"Ñ    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@GiI"Ñ    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@GiI"á    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[	@Gi1I"Ö    
    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@Gi5I"è    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing;Fi[	@üiI"à    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[@'@3@4I"@var ||= [];FI"end;FI" ;Fi[[	I"/data//bundler_proj/bundler/rubygems_ext.rb;Ti/I"Ò    # RubyGems 1.8+ used only.
    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, ".git")) then;Fi[	I"(data//cancan_proj/cancan/ability.rb;TiI"<        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end
    
    # Returns an array of Rule instances which match the action and subject
    # This does not take into consideration any hash conditions or block statements;Fi[	I"Fdata//cucumber_prok/cucumber/language_support/language_methods.rb;TiUI"      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|;Fi[	@¿i#I"I        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= [];Fi[	@¿i'I"⁄        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then;Fi[	@
iI"        def function(arglist)
          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|;Fi[	@‚i‹I"…      
      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var);Fi[@≥@¥I"@var = true;FI"end;FI" ;FI"def function(arglist);Fi[[	@liI"Ω        @var = var["version"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@œiI"        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@œiI"Ω      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash
      end;Fi[	@OiHI"ÿ      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?
      end;Fi[	@“i&I"Ω        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end;Fi[	@ti3I"‚        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@‚i†I"æ      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false
      end;Fi[@@
I"@var = var;FI"@var = var;FI"end;FI" ;FI"def function(arglist);Fi[[	@˛iiI"R      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?
        @var = (object.class.reflect_on_aggregation(name.to_sym) or object.column_for_attribute(name));Fi[	@“i=I"'          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server)
          end;Fi[	@ª
iBI"Ë        var = ensure_array_of_array(rubify(var))
        var = var.transpose
        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        dup
      end;Fi[	@à
i-I"˛        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("\"%s\"" % @var.join(File::PATH_SEPARATOR))]
        end;Fi[	I"7data//cucumber_prok/cucumber/rb_support/rb_hook.rb;TiI"      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var)
      end;Fi[	@∆iùI"E  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "#{@name.downcase} cannot be installed alongside #{@formula}.\n"
    (var << "This is because #{@opts[:because]}\n") if @var[:because];Fi[	@¢i
I"√    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end;Fi[@≈
@%@&I"@var = var;FI"end;FI" ;Fi[[	I"8data//mongoid_proj/lib/mongoid/contextual/memory.rb;Ti,I"ﬁ      # @param [ Integer ] value The limit.
      #
      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Get the skiping value.
      #;Fi[	@¶iHI"›      # @param [ Integer ] value The skip.
      #
      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Apply criteria options.
      #;Fi[	@,ieI"    # @param [ Array<Document> ] docs The embedded documents.
    #
    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Is the criteria for embedded documents?
    #;Fi[	@,iI"R    # @param [ Array<Metadata> ] The inclusions.
    #
    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Merges another object with this +Criteria+ and returns a new criteria.
    # The other object may be a +Criteria+ or a +Hash+. This is used to;Fi[	I"/data//mongoid_proj/lib/mongoid/loggable.rb;TiI"ª    # @param [ Logger ] The logger to set.
    #
    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@yióI".        # @param [ true, false ] value The flag.
        #
        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Normalize the documents, in case they were provided as an array of
        # hashes.;Fi[	@yiŒI"        # @param [ String ] value The path.
        #
        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Get the selector for executing atomic operations on the collection.
        #;Fi[@'@(@)@I"##;F@ai[[	@≈	i5I"’          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@»	iWI"»          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@ViAI"ÿ          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@À	i=I"           Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@Œ	i8I"Ô          Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to bucket '#{bucket}'."))
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@ti5I"‡          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@Yi3I"‹          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[@'@3@4@5@6I"end;Fi[[	I".data//bundler_proj/bundler/environment.rb;Ti&I"î    
    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"1data//cucumber_prok/cucumber/ast/scenario.rb;TiI"À        
        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@ª
iI"ø        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable);Fi[	@ÜiI"        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize);Fi[	I"*data//diaspora_proj/models/service.rb;Ti%I"    var = truncate(var, :length => ((var - var)))
    var = "#{truncated}#{url}"
    return var
  end
  
  def function(arglist)
    # do nothing
  end
end
require(Rails.root.join("app", "models", "services", "facebook"))
require(Rails.root.join("app", "models", "services", "twitter"));Fi[	@™iI"´        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@≠iI"´        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[@'@3@4I"@var = nil;FI"end;FI" ;Fi[[	I"Fdata//activerecord_proj/active_record/associations/association.rb;TiTI"      # actually gets built.
      def function(arglist)
        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      
      # Set the inverse association, if possible
      def function(arglist);Fi[	@JiœI"·      
      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!;Fi[	@„igI"—      def function(arglist)
        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var;Fi[	@Æi©I"Ó      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var);Fi[	@±i3I"Ω      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var;Fi[	@li.I"◊      def function(arglist)
        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var);Fi[	@iÄI"ß      
      def function(arglist)
        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      ;Fi[@'@(I"return var;FI"end;FI" ;FI"def function(arglist);Fi[[	@çiSI"             var.each { |arglist| var[var] += "(#{length})" }
          else
            # do nothing
          end
        end
        return var
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, ""] }]
        var = add_index_length(var, var, var);Fi[	@„iïI"m              var = var.instance_variable_get("@cell_matrix")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "<span class=\"param\">#{param}</span>" })
        @var.div(:class => "step_name") do |arglist|;Fi[	@si%I"      unless (var.include?(var) or var.nil?) then
        yield(var, var) if block_given?
        (var << var)
      end
    end
    return var
  end
  
  def function(arglist)
    if (Pathname.pwd == HOMEBREW_REPOSITORY) then
      "Library/Formula/#{name}.rb";Fi[	@i I"◊        var.each { |arglist| (var << install_p(var, var)) }
      else
        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var then
      var = File.basename(var);Fi[	@iGI"ı        var.each { |arglist| (var << install_symlink_p(var, var)) }
      else
        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then
      var = (self + File.basename(var));Fi[	I"data//redmine_proj/diff.rb;Ti.I"À        while var do
          var[var[1]] = var[2]
          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist)
      var = Diff.lcs(var, var)
      var = var = 0;Fi[	I")data//redmine_proj/SVG/Graph/Line.rb;TiBI"Ó            var = @var[-1][:data].min
          else
            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[@Ä@Å@ÂI" ;FI"private;FI" ;Fi[[	@i%I"          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) };Fi[	@iêI"Ω        begin
          exec_query("BEGIN")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {};Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/cvs.rb;TiTI"Ï          when /\(yes\/no\)/ then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option
        def function(arglist);Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/git.rb;TiéI"          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the
        # command-line switch for "quiet" ("-q").;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/scm/mercurial.rb;TiJI"ﬁ          when /yes\/no/i then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands
        def function(arglist);Fi[	@åiLI"O          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.
        def function(arglist);Fi[	I"Fdata//capistrano_proj/capistrano/recipes/deploy/scm/subversion.rb;TiWI"9          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line
        # switches for that. Note that we don't need to return the password;Fi[@≥@¥I"@var ||= [];FI"end;FI" ;FI"def function(arglist);Fi[[	@fi0I""    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, ".git")) then
        var = Dir.chdir(full_gem_path) { |arglist| `git rev-parse HEAD`.strip };Fi[	@liVI"      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|
          proc do |arglist|;Fi[	@¿i$I"L        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end;Fi[	@¿i(I"ˆ        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then
            var = var.stringify_keys;Fi[	@
iI"          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|
            var.register_example_group(var);Fi[	I":data//rspec_proj/spec/example/shared_example_group.rb;Ti I"‹        end
        
        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          var = find(var.description)
          return false unless var;Fi[	@‚i›I"Ã      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var)
      end;Fi[@≥@¥I"0;FI"end;FI" ;FI"def function(arglist);Fi[[	@GiI"à    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@GiI"á    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@GiI"á    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@GiI"ä    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[	@Gi2I"à    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@Gi6I"í    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@üiI"ã    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[@≈
I"*#   class Person < ActiveRecord::Base;FI"#     has_many :pets;TI"#   end;TI"#;TI"#   person.pets;Ti[[	@#i$I"A      # Works in two ways.
      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#i]I"≠      # Finds an object in the collection responding to the +id+. Uses the same
      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#i{I"ï      # Returns the first record, or the first +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#iîI"ì      # Returns the last record, or the last +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#iI"W      
      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>]
      #;Ti[	@#i@I"r      # contain the same number of elements and if each element is equal
      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#iZI"c      
      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,;Ti[I"#homepage("http://example.com");FI" ;FI",url("file:///foo.com/testball-0.1.tbz");FI" ;FI"5sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5");FI" ;Fi[[	I")data//homebrew_proj/test/testball.rb;TiíI"  end
end
class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    url("file:///foo.com/testball-0.1-bottle.tar.gz");Fi[	@bi¢I"Ù  end
end
class AncientBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle("file:///foo.com/testball-0.1-bottle.tar.gz")
  ;Fi[	@biﬂI"  end
end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[	@biÓI"  end
end
class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :lion);Fi[	@bi˝I"  end
end
class AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[	@biI"ﬂ  end
end
class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    version(1);Fi[	@bi"I"class CustomVersionScheme < Version
end
class CustomVersionSchemeTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  version("1.0" => (CustomVersionScheme))
  ;Fi[@U@VI" ;FI"def function(arglist);FI"@var = var;FI"	self;Fi[[	@y	iI"¯      def function(arglist)
        @var ||= "`#{command}' could not be found in the path on the local host"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ÕiQI"ı          @var = "the output #{output.inspect} from #{command.inspect} did not match #{expect.inspect}"
          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@iI"∂        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        ;Fi[	@≥iEI"†      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@≥iJI"†      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@≥iOI"†      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@≥iTI"†      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[@'@3@4I"@var.empty?;FI"end;FI" ;Fi[[	I")data//backup_proj/backup/pipeline.rb;Ti8I"¯      rescue Exception => var
        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end
    
    ##
    # Returns a multi-line String, reporting all STDERR messages received;Fi[	I"?data//bundler_proj/bundler/vendor/thor/parser/arguments.rb;Ti7I"π    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first;Fi[	I"8data//cucumber_prok/cucumber/ast/step_collection.rb;Ti,I"      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length };Fi[	@ÜidI"P      def function(arglist)
        load_programming_language("rb") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) };Fi[	I"%data//homebrew_proj/checksums.rb;TiI"è  def function(arglist)
    @var = var
    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  ;Fi[	I"+data//homebrew_proj/formula_support.rb;Ti©I"©  
  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var);Fi[	@√iI"§  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?;Fi[@'@(@)@I"protected;FI" ;Fi[[	@MiÖI"Ó          false
        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var);Fi[	@Pi/I"            unless var.send(CHECKS[var], var) then
              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      
      def function(arglist)
        case var;Fi[	@`i(I"Ë          @var.synchronize do |arglist|
            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then;Fi[	@_iJI"˚          else
            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then;Fi[	@hi\I"û        var.value.first
      else
        var
      end
    end
  end
  
  protected
  
  def function(arglist)
    unless var.is_a?(Sass::Script::List) then;Fi[	@ki_I"œ            :locked
          else
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts);Fi[	@ti,I"D          puts("## [message] Above is your schedule file converted to cron syntax; your crontab file was not updated.")
          puts("## [message] Run `whenever --help' for more options.")
          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file]);Fi[@≥@¥I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@∏
iI"ª      include(Enumerable)
      
      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end;Fi[	@ª
iI"«      
      class Builder
        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end;Fi[	@Åi
I"Ÿ  module PySupport
    class PyLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@åiI"‹  module WireSupport
    class WireLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	I""data//homebrew_proj/debrew.rb;TiI"ª  attr_accessor(:prompt)
  
  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist)
    (entries << { :name => (var), :action => (var) })
  end;Fi[	I";data//paperclip_proj/paperclip/io_adapters/registry.rb;TiI"´    end
    
    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      (@var << [var, var])
    end;Fi[@I"var = 0;FI"var = 0;FI"var = 1;F@ØI"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[[	@õioI"‡      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@õi≥I"     var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@ûidI"“      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@ûiÆI"Ú    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@°i^I"‡      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@°i¢I"     var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[@
I"end;FI" ;F@ËI"raise(NotImplementedError);FI"end;Fi[[	@8iI"Ã      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@8iI"Ã      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@8iI"Ã      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@8iI"Ã      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@8i I"Ã      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@8i$I"∑      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end
  end;Fi[@'@(@ÊI"module InstanceMethods;FI"def self.included(arglist);FI"var.extend(ClassMethods);Fi[[	@éiI"            var[:author_key] = "#{table_name}.#{options[:author_key]}"
          end
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@¿iI"π          has_many(:attachments, var.merge(:as => :container, :order => ("#{Attachment.table_name}.created_on ASC, #{Attachment.table_name}.id ASC"), :dependent => :destroy))
          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@√iI"=          send(:include, Redmine::Acts::Customizable::InstanceMethods)
          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@∆iI"+          cattr_accessor(:event_options)
          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@ëi%I"é          searchable_options[:order_column] ||= searchable_options[:date_column]
          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@…iI""          end
          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[@'@3@Á@Ë@ÈI"end;Fi[[	@éiI"Ú          end
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@¿iI"(          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@√iI"          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@∆iI"S          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["datetime", "title", "description", "author", "type"].each do |arglist|;Fi[	@ëi&I"Y          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@…iI"V          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers;Fi[I"7# Notify the user of the backup operation results.;FI"/# `status` indicates one of the following:;FI"#;FI"# `:success`;FI"+# : The backup completed successfully.;FI"D# : Notification will be sent if `on_success` was set to `true`;Fi[[	@≥	iI"0      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@∂	i5I"0      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@π	itI"0      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@º	iI"0      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@ø	i%I"0      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@¬	iI"0      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[@˚@@I"#;FI"# `:success`;F@i[[	@≥	iI"$      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@∂	i4I"$      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@π	isI"$      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@º	iI"$      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@ø	i$I"$      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@¬	iI"$      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[@≥I"private;FI" ;FI"##;F@@i[[	@≥	iI"Ú        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@∂	i1I"˘        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@π	ipI"Ú        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@º	iI"Ú        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@ø	i!I"Ú        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@¬	iI"Ú        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[@≥@`@@I"#;FI"# `:success`;Fi[[	@≥	iI"&      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@∂	i3I"&      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@π	irI"&      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@º	iI"&      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@ø	i#I"&      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@¬	iI"&      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[@≥@Á@Ë@ÈI"end;FI" ;Fi[[	@éiI"C          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Returns events of type event_type visible by user that occured between from and to;Fi[	@¿iI"r          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:view_permission], self.project);Fi[	@√iI"3          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          CustomField.where("type = '#{self.class.name}CustomField'").sorted.all;Fi[	@∆iI"g          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["datetime", "title", "description", "author", "type"].each do |arglist|
          var = "            def event_#{attr}\n              option = event_options[:#{attr}]\n              if option.is_a?(Proc)\n                option.call(self)\n              elsif option.is_a?(Symbol)\n                send(option)\n              else\n                option\n              end\n            end\n";Fi[	@ëi'I")          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Searches the model for the given tokens;Fi[	@…iI"0          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers
        def function(arglist);Fi[I"#@var = (HOMEBREW_CACHE + @var);FI"end;FI" ;FI"attr_reader :function;FI" ;FI"def function(arglist);Fi[[	@viΩI"P    @@svn ||= "svn"
    @var = "#{name}--svn" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (@var + "-HEAD") if ARGV.include?("--HEAD")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.sub!(/^svn\+/, "") if @var =~ /^svn\+http:\/\//
    ohai("Checking out #{@url}");Fi[	@viI"ˇ    super
    @@git ||= "git"
    @var = "#{name}--git" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.!=(:revision) and host_supports_depth?
  end;Fi[	@vidI"  def function(arglist)
    super
    @var = "#{name}--cvs" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    ohai("Checking out #{@url}")
    var, var = split_url(@var);Fi[	@vièI"]  def function(arglist)
    super
    @var = "#{name}--hg" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|
      File.executable?(var);Fi[	@viπI":  def function(arglist)
    super
    @var = "#{name}--bzr" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|
      File.executable?(var);Fi[	@viŸI"C  def function(arglist)
    super
    @var = "#{name}--fossil" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|
      File.executable?(var);Fi[@Ë@È@Í@ÎI" ;FI"def function(arglist);Fi[[	@Ci.I"Ò                [var, var]
              end]
            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var)
        end;Fi[	@¬iI"È            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) }
    end;Fi[	@7i∞I"Ú          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("expected a file to upload")
      var = session_map[var.session];Fi[	@:i+I".          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end;Fi[	@„i€I"F          if ENV["TM_PROJECT_DIRECTORY"] then
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      
      def function(arglist)
        (@var << "<script type=\"text/javascript\">document.getElementById('duration').innerHTML = \"Finished in <strong>#{format_duration(features.duration)} seconds</strong>\";</script>")
        (@var << "<script type=\"text/javascript\">document.getElementById('totals').innerHTML = \"#{print_stat_string(features)}\";</script>");Fi[	@ÜiïI"              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then
          log.debug("  * #{file}\n");Fi[I"1# @param [ String ] name The attribute name.;FI"7# @param [ String ] meth The name of the accessor.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);FI"/generated_methods.module_eval do |arglist|;Fi[[	@h	iI"†      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_change") { |arglist| attribute_change(var) }
        end;Fi[	@h	iI"û      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed?") { |arglist| attribute_changed?(var) }
        end;Fi[	@h	i)I"ø      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed_from_default?") do |arglist|
            attribute_changed_from_default?(var);Fi[	@h	i:I"¢      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_was") { |arglist| attribute_was(var) }
        end;Fi[	@h	iII"£      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_will_change!") do |arglist|
            attribute_will_change!(var);Fi[	@h	iZI"ì      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) }
        end;Fi[I"private;FI" ;FI"##;F@@I"#;Fi[[	@≥	iI"        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@∂	i2I"        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@π	iqI"        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@º	iI"        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@ø	i"I"        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@¬	iI"        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[@≈
I"# `:success`;F@@I"#;FI"# `:warning`;Fi[[	@≥	iI"¶      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@∂	i7I"¶      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@π	ivI"¶      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@º	iI"¶      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@ø	i'I"¶      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@¬	iI"¶      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[@≈
I"# `:warning`;FI"D# : The backup completed successfully, but warnings were logged;FI"C# : Notification will be sent, including a copy of the current;FI"6# : backup log, if `on_warning` was set to `true`;FI"#;Fi[[	@≥	i#I"•      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@∂	i;I"•      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@π	izI"•      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@º	i!I"•      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@ø	i+I"•      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@¬	iI"•      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[@I"#;FI"# `:success`;F@@I"#;Fi[[	@≥	iI"h      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@∂	i6I"h      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@π	iuI"h      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@º	iI"h      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@ø	i&I"h      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@¬	iI"h      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[@≈
I"# `:failure`;FI"%# : The backup operation failed.;FI"H# : Notification will be sent, including the Exception which caused;FI"F# : the failure, the Exception's backtrace, a copy of the current;FI"K# : backup log and other information if `on_failure` was set to `true`;Fi[[	@≥	i(I"      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@∂	i@I"      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@π	iI"      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@º	i&I"      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@ø	i0I"      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@¬	i$I"      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[@≈
@Ä@ÅI"#;FI"# @since 3.0.0;F@Ñi[[	@h	i
I"ú      #
      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_change") { |arglist| attribute_change(var) };Fi[	@h	iI"ö      #
      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed?") { |arglist| attribute_changed?(var) };Fi[	@h	i(I"ñ      #
      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed_from_default?") do |arglist|;Fi[	@h	i9I"û      #
      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_was") { |arglist| attribute_was(var) };Fi[	@h	iHI"É      #
      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_will_change!") do |arglist|;Fi[	@h	iYI"è      #
      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) };Fi[@•@¶@ß@®@©I"private;Fi[[	@i$I"˘            resolve_string_connection(config.to_s)
          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist);Fi[	@iSI"            "#{(variable(:scm_password) or variable(:password))}\n"
          when /\(yes\/no\)/ then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option;Fi[	@içI"            "#{pass}\n"
          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the;Fi[	@iII"ÿ            "#{pass}\n"
          when /yes\/no/i then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands;Fi[	@åiKI"v            raise(Capistrano::Error, "p4port is incorrect or unset")
          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.;Fi[	@iVI"r            raise(Capistrano::Error, "subversion can't update because directory '#{$1}' was replaced. Please add it to svn:ignore.")
          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line;Fi[@,@\@]I"end;FI"end;FI"end;Fi[[	I"?data//nokogiri_proj/nokogiri/xml/processing_instruction.rb;TiI"êmodule Nokogiri
  module XML
    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@ıilI"˙        # Called when processing instructions are found
        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@¯ièI"‡        end
        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@™iI"à          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@≠iI"à          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@™iI"~        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[@,@CI"end;FI" ;F@FI"2broadcast(var) { |arglist| var.accept(self) };Fi[[	@IiI"ˇ        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@IiI"        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@Ii/I"      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@Ii;I"¸        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@IiOI"¸        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@IioI"Ì        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[I"end.to_yaml;FI"2File.open("_posts/#{name}", "w") do |arglist|;FI"var.puts(var);FI"var.puts("---");FI"var.puts(var);FI"end;Fi[[	I"1data//jekyll_proj/jekyll/migrators/joomla.rb;TiI"∆        var = ("%02d-%02d-%02d-%s.markdown" % [var.year, var.month, var.day, var])
        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	I"3data//jekyll_proj/jekyll/migrators/mephisto.rb;Ti!I"ë        var = ([var.year, var.month, var.day, var].join("-") + ".markdown")
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	I"-data//jekyll_proj/jekyll/migrators/mt.rb;TiI"Ø        var = (([var.year, var.month, var.day, var].join("-") + ".") + self.suffix(var))
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	I"4data//jekyll_proj/jekyll/migrators/posterous.rb;Ti0I"±          var = ("%02d-%02d-%02d-%s.html" % [var.year, var.month, var.day, var])
          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end
        var = (var + 1);Fi[	I"6data//jekyll_proj/jekyll/migrators/textpattern.rb;TiI"ñ        var = ([var.strftime("%Y-%m-%d"), var].join("-") + ".textile")
        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	I"4data//jekyll_proj/jekyll/migrators/wordpress.rb;Ti^I"-      end
      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end
    ;Fi[I"(var.nil? or (var == ""));FI"end.to_yaml;F@1I"var.puts(var);F@3I"var.puts(var);Fi[[	@8iI"⁄        var = var[:content]
        var = ("%02d-%02d-%02d-%s.markdown" % [var.year, var.month, var.day, var])
        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@;i I"¢        var = var[:body]
        var = ([var.year, var.month, var.day, var].join("-") + ".markdown")
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@>iI"⁄        var = ((var + " \n") + var) if var.!=(nil)
        var = (([var.year, var.month, var.day, var].join("-") + ".") + self.suffix(var))
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@Ai/I"Ω          var = var["is_private"].!
          var = ("%02d-%02d-%02d-%s.html" % [var.year, var.month, var.day, var])
          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end;Fi[	@DiI"ß        var = var[:Body]
        var = ([var.strftime("%Y-%m-%d"), var].join("-") + ".textile")
        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@Gi]I"b        var.sort! { |arglist| (var["id"] <=> var["id"]) }
      end
      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end;Fi[@≥@¥I"@var, @var = var, var;FI"end;FI" ;FI"def function(arglist);Fi[[	@i
I"ˇ  module ConnectionAdapters
    class ConnectionSpecification
      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        @var = var.config.dup
      end;Fi[	I"Idata//activerecord_proj/active_record/tasks/sqlite_database_tasks.rb;Ti	I"e  module Tasks
    class SQLiteDatabaseTasks
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        raise(DatabaseAlreadyExists) if File.exist?(configuration["database"])
        establish_connection(configuration);Fi[	@ª
i(I"2        include(Gherkin::Formatter::Escaping)
        
        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) };Fi[	I"-data//cucumber_prok/cucumber/ast/tags.rb;Ti
I"  module Ast
    class Tags
      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        @var.each { |arglist| var.visit_tag_name(var.name) };Fi[	I":data//cucumber_prok/cucumber/step_definition_light.rb;TiI"module Cucumber
  class StepDefinitionLight
    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist)
      (regexp_source == var.regexp_source) and (file_colon_line == var.file_colon_line)
    end;Fi[	I"=data//cucumber_prok/cucumber/wire_support/wire_packet.rb;TiI"÷      end
      
      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        var = [@var]
        (var << @var) if @var;Fi[@'@3@t@uI"##;F@i[[	@≥	iI"˚      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@∂	i0I"         @var ||= "yellow"
        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@π	ioI"˚      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@º	iI"˚      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@ø	i I"˚      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@¬	iI"˚      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[I"# `:success`;F@@I"#;FI"# `:warning`;F@∏i[[	@≥	i I"’      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@∂	i8I"’      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@π	iwI"’      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@º	iI"’      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@ø	i(I"’      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@¬	iI"’      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[@@I"#;FI"# `:warning`;F@∏@πi[[	@≥	i!I"§      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@∂	i9I"§      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@π	ixI"§      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@º	iI"§      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@ø	i)I"§      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@¬	iI"§      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[I"2File.open("_posts/#{name}", "w") do |arglist|;FI"var.puts(var);F@3I"var.puts(var);FI"end;FI"end;Fi[[	@8iI"y        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@;i"I"K        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@>iI"[        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
    ;Fi[	@Ai1I"◊          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end
        var = (var + 1)
        var = JSON.parse(self.fetch("/api/v2/users/me/sites/#{blog}/posts?api_token=#{@api_token}&page=#{page}").body);Fi[	@DiI"U        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@Gi_I"H      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end
    
    def self.clean_entities(arglist);Fi[@Z
@[
I"7# @param [ Symbol ] name The name of the relation.;FI"4# @param [ Hash ] options The relation options.;FI"D# @param [ Proc ] block Optional block for defining extensions.;FI"def function(arglist);Fi[[	I"7data//mongoid_proj/lib/mongoid/relations/macros.rb;Ti/I"…        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then
            raise(Errors::VersioningNotOnRoot.new(self));Fi[	@ªiMI"¿        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@ªiiI"º        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@ªiÄI"…        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = reference_one_to_one(var, var, Referenced::In, &var)
          aliased_fields[var.to_s] = var.foreign_key;Fi[	@ªiôI"¨        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Referenced::Many, var, &var)
          relate(var, var);Fi[	@ªi”I"õ        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var)
        end;Fi[@,@-@.I"@var = var;FI"end;FI" ;Fi[[	@˛ihI"    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?;Fi[	@≥	iaI"L        ##
        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##
        # Wrapper method for the #send_message (private) method;Fi[	@“i<I"1        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server);Fi[	@öi
I"    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var);Fi[	@∆iúI"  fatal(ARGV.force?.!)
  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "#{@name.downcase} cannot be installed alongside #{@formula}.\n";Fi[	@¢i	I"Õ  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing;Fi[@I"#;FI"# `:warning`;F@∏@π@∫i[[	@≥	i"I"Ü      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@∂	i:I"Ü      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@π	iyI"Ü      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@º	i I"Ü      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@ø	i*I"Ü      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@¬	iI"Ü      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[I"# `:warning`;F@∏@π@∫I"#;FI"# `:failure`;Fi[[	@≥	i$I"‹      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@∂	i<I"‹      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@π	i{I"‹      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@º	i"I"‹      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@ø	i,I"‹      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@¬	i I"‹      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[@∏@π@∫I"#;FI"# `:failure`;F@‹i[[	@≥	i%I"˜      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@∂	i=I"˜      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@π	i|I"˜      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@º	i#I"˜      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@ø	i-I"˜      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@¬	i!I"˜      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[@π@∫I"#;FI"# `:failure`;F@‹@›i[[	@≥	i&I"˛      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@∂	i>I"˛      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@π	i}I"˛      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@º	i$I"˛      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@ø	i.I"˛      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@¬	i"I"˛      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[@∫I"#;FI"# `:failure`;F@‹@›@ﬁi[[	@≥	i'I"˛      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@∂	i?I"˛      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@π	i~I"˛      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@º	i%I"˛      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@ø	i/I"˛      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@¬	i#I"˛      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[I"# `:failure`;F@‹@›@ﬁ@ﬂI"#;Fi[[	@≥	i)I"ÿ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@∂	iAI"›      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@π	i{I"›      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@º	i'I"ÿ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@ø	i1I"ÿ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@¬	i%I"ÿ      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[@,@-@¯@˘@˙I"
begin;Fi[[	@iI"‰      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled
        var = ActiveRecord::Base.connection_id;Fi[	@ƒiI"Y      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database)
          connection.create_database(configuration["database"], creation_options);Fi[	@©iI"Ñ      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var
          connection.create_database(configuration["database"], configuration.merge("encoding" => (encoding)));Fi[	@ iI"#      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then
          Bundler.definition.ensure_equivalent_gemfile_and_lockfile(true);Fi[	@∫i8I"      end
      
      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false unless var.has_key?(var) and (var == var[var]);Fi[	@∫iMI"      end
      
      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false if var.has_key?(var) and (var == var[var]);Fi[@‹@›@ﬁ@ﬂI"#;FI"def function(arglist);Fi[[	@≥	i*I"Æ      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@∂	iBI"≥      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@π	i|I"≥      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@º	i(I"Æ      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@ø	i2I"Æ      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@¬	i&I"Æ      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[@,@
I"end;FI" ;F@Ë@◊i[[	@8iI"√        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@8iI"”        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@8iI"”        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@8iI"”        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@8iI"”        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@8i#I"‘        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end;Fi[@CI"end;FI" ;F@F@!I"end;Fi[[	@IiI"Ú      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@IiI"Ú      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@Ii0I"(      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@Ii<I"Ú      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@IiPI"Ú      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@IipI"Ú      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[@E@FI"#   end;TI"#;TI"#   person.pets;TI"#   # => [;Ti[[	@#i%I"c      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#i^I"ö      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#i|I"Å      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#iïI"Å      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#iAI"d      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>;Ti[	@#i[I"ô      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[@'I"	else;FI"
super;FI"end;FI"end;FI" ;Fi
[
[	@çiI"¯            "longtext"
          else
            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      
      def function(arglist)
        if var[:first] then;Fi[	@˜iPI"‘              end
            else
              super
            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var;Fi[	I"^data//activerecord_proj/active_record/connection_adapters/postgresql/schema_statements.rb;TiMI"c              "int8range"
            else
              raise(ActiveRecordError, "No range type has byte size #{limit}. Use a numeric with precision 0 instead.")
            end
          else
            super
          end
        end
        
        # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.
        #;Fi[	I"&data//bundler_proj/bundler/cli.rb;Ti5I"          Kernel.exec("#{groff} #{root}/#{command} | #{pager}")
        else
          puts(File.read("#{root}/#{command}.txt"))
        end
      else
        super
      end
    end
    
    desc("init", "Generates a Gemfile into the current working directory")
    ;Fi[	I"Ddata//state_machine_proj/state_machine/transition_collection.rb;Ti I"        end
        if skip_after and success? then
          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    
    # Tracks that before callbacks have now completed
    def function(arglist);Fi[@'@åI"var;FI"end;FI"end;FI"end;Fi
[
[	@CiyI"∂                else
                  nil
                end
              end
            else
              var
            end
          end
        end
        
        private;Fi[	@¬iI"‰        when Hash then
          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist);Fi[	@i§I"√            var.backtrace.clear
            var.backtrace.push(var.backtrace_line("World"))
            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@ÜiìI"˝            end.min
            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@i&I"æ            var = var.call(var)
            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[@'@3I"protected;FI" ;F@¥I"
begin;Fi
[
[	@@iI"a      # Check the connection back in to the connection pool
      def function(arglist)
        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin
          @var.instrument("sql.active_record", :sql => (var), :name => (var), :connection_id => (object_id), :binds => (var)) do |arglist|
            yield;Fi[	@WiØI"Ô      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find(var);Fi[	@eiI"µ        end
        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift
        var = Compass::Commands[$command];Fi[	@∫i±I"      var.directory? ? (var.rmdir) : (var.delete if var.exist?)
    end
    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin
      if var.symlink? and var.directory? then
        var = (var.parent + var.readlink).cleanpath;Fi[	@‚içI"˛      def function(arglist)
        (var << var) unless var.nil?
        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin
          @var.call(*var)
        rescue => var;Fi[@,I"super(var);FI"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;Fi
[
[	@≥	iI"⁄      # Campfire account's subdomain
      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@π	ilI"6      # Folder where mail will be kept when using the `:file` `delivery_method` option.
      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@º	iI"È      ##
      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@ø	iI"’      # The message title
      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@¬	iI"’      # Twitter consumer key credentials
      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[@'@3@t@uI"attr_reader :function;FI" ;Fi
[
[	@ƒiNI"d        var.concat(["--execute", "SET FOREIGN_KEY_CHECKS = 0; SOURCE #{filename}; SET FOREIGN_KEY_CHECKS = 1"])
        var.concat(["--database", "#{configuration["database"]}"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("database" => (nil));Fi[	@©iDI"      def function(arglist)
        set_psql_env
        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["encoding"] or DEFAULT_ENCODING);Fi[	@di)I"‘      def function(arglist)
        var = configuration["database"]
        `sqlite3 #{var} < "#{var}"`
      end
      
      private
      
      attr_reader :function
      
      attr_reader :function
    end;Fi[	@7iRI"¯    
    def function(arglist)
      to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("#{transport} #{operation} #{from} -> #{to}") if logger;Fi[	I"4data//state_machine_proj/state_machine/state.rb;TiÂI"Ü    def function(arglist)
      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "#<#{self.class} #{(attributes.map { |attr, value| "#{attr}=#{value.inspect}" } * " ")}>"
    end
    
    private
    
    attr_reader :function
    
    # Adds a predicate method to the owner class so long as a name has
    # actually been configured for the state;Fi[I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;FI"#     end;FI"#   end;Fi
[
[	@›icI"K    # == Examples
    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">;Fi[	@øiI"A        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@øiXI"A        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@øi|I"A        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@Fi˝I"%    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">;Fi[I"# @since 1.5.2;FI"#;FI"def function(arglist);FI"return @var;FI"end;FI" ;Fi
[
[	@îiüI"”  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale)
  ;Fi[	@îi´I"÷  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth)
  ;Fi[	@îi∑I"⁄  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight)
  ;Fi[	@îi√I"ﬂ  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin)
  ;Fi[	@îiœI"ı  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor)
  ;Fi[I"# @author Nicola Asuni;FI"# @since 1.5.2;FI"#;FI"def function(arglist);FI"return @var;FI"end;Fi
[
[	@îiûI"‘  #
  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale);Fi[	@îi™I"◊  #
  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth);Fi[	@îi∂I"€  #
  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight);Fi[	@îi¬I"‡  #
  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin);Fi[	@îiŒI"ˆ  #
  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor);Fi[@'@3@4I"@var[var] = var;FI"end;FI" ;Fi
[
[	@¢i•I"Ô        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var];Fi[	@7iÅI"∫      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!;Fi[	@æ
i3I"¬      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var;Fi[	@TiÑI"€        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var];Fi[	@UitI"      
      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call);Fi[@'@3@4I"[];FI"end;FI" ;Fi
[
[	@Gi	I"û  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0;Fi[	@ÕiI"ﬁ      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var);Fi[	@ói@I"v  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    [];Fi[	@óiDI"¨  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end
  
  def self.excluding_blocks(arglist)
    var = var.blocks.map { |arglist| var.person_id };Fi[	@ßiI"¡      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?;Fi[@≈
@%@&I"	true;FI"end;FI" ;Fi
[
[	@ÉiwI"˝      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.;Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/float.rb;TiI"      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly;Fi[	@îi|I"-      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the
      # hash which must correspond to method on a criteria object. The hash;Fi[	I"9data//mongoid_proj/lib/mongoid/extensions/integer.rb;TiI"Ó      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Is the object not to be converted to bson on criteria creation?
      #;Fi[	@úi'I"ˇ      #   range.resizable?
      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.;Fi[@•I""";FI"end;FI"end;FI" ;FI"def function(arglist);Fi
[
[	I"9data//compass_proj/compass/configuration/comments.rb;TiI"b      def function(arglist)
        if top_level.line_comments then
          "# To disable debugging comments that display the original location of your selectors. Uncomment:\n# line_comments = false\n"
        else
          ""
        end
      end
      
      def function(arglist)
        if top_level.output_style_without_default then
          "";Fi[	@ci8I"    def function(arglist)
      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("") : ("[#{COLORS[c.to_sym]}m")
      else
        ""
      end
    end
    
    def function(arglist)
      print(var)
    end;Fi[	@viI"∫          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@vi6I"›          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do
          @var.pop;Fi[	@zi6I"√          "> /dev/null"
        when stdout then
          ">> #{stdout}"
        else
          ""
        end
      end
      
      def function(arglist)
        ">> #{@output} 2>&1"
      end;Fi[@≈
I"# @since 2.4.0;FI"def function(arglist);FI"@var ||= {};FI"end;FI" ;Fi
[
[	I"-data//mongoid_proj/lib/mongoid/atomic.rb;Ti3I"È    #   person.atomic_array_pushes
    #
    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the pulls that need to happen.
    #;Fi[	@]i?I"Ì    #   person.atomic_array_pulls
    #
    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the unique adds that need to happen.
    #;Fi[	@]iKI"9    #   person.atomic_array_add_to_sets
    #
    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the atomic updates that need to happen for the current
    # +Document+. This includes all changes that need to happen in the;Fi[	@h	i3I"Ë    #   model.changed_attributes
    #
    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the changes for the document.
    #;Fi[	@h	ilI"'    #   model.previous_changes
    #
    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Remove a change from the dirty attributes hash. Used by the single field
    # atomic updators.;Fi[@Ë@È@ØI"protected;FI" ;FI"def function(arglist);Fi
[
[	@Ôi%I"q            var[:encoding] = "base64" if (type == :binary)
            var[:type] = (type == :string) ? (nil) : (type)
            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist)
            return if value.nil?
            var = ActiveSupport::XmlMini::TYPE_NAMES[value.class.name];Fi[	@¸iÏI"Ô      # Thor::Shell::Basic class.
      #
      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist)
        return var unless var.is_a?(Symbol)
        self.class.const_get(var.to_s.upcase);Fi[	I"@data//capistrano_proj/capistrano/configuration/execution.rb;TilI"A        trigger(var[:before], var) if var[:before]
        var = execute_task(var)
        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist)
        return if Thread.current[:rollback_requests].nil?
        rollback_requests.reverse.each do |arglist|;Fi[	@™iπI"#              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected
        
        def function(arglist)
          @var ||= Devise::ParamFilter.new(case_insensitive_keys, strip_whitespace_keys)
        end;Fi[	I"9data//rspec_proj/spec/runner/example_group_runner.rb;TiI"        var = true
        example_groups.each { |arglist| var = var.&(var.run(@var)) }
        finish
        var
      end
      
      protected
      
      def function(arglist)
        reporter.start(number_of_examples)
        example_groups.reverse! if reverse;Fi[@é@èI" ;FI"private;FI" ;FI"def function(arglist);Fi
[
[	I"5data//activemodel_proj/active_model/validator.rb;TiOI"º  class BlockValidator < EachValidator
    def function(arglist)
      @var = var
      super
    end
    
    private
    
    def function(arglist)
      @var.call(var, var, var)
    end;Fi[	I"7data//activerecord_proj/active_record/timestamp.rb;TiI"ÿ    
    def function(arglist)
      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist)
      if self.record_timestamps then
        var = current_time_from_proper_timezone;Fi[	I"0data//backup_proj/backup/compressor/lzma.rb;Ti!I"¯      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Lzma is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        (" --best" if @var or " --fast" if @var)
      end;Fi[	I"2data//backup_proj/backup/compressor/pbzip2.rb;Ti'I"       # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Pbzip2 is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        var = (" --best" if @var or " --fast" if @var)
        var = " -p#{@processors}" if @var;Fi[	I"@data//diaspora_proj/controllers/registrations_controller.rb;TiI"∆  end
  
  def function(arglist)
    super
  end
  
  private
  
  def function(arglist)
    return true if AppConfig.settings.enable_registrations?
    return true if invite and invite.can_be_used?;Fi[@'I"var = -1;FI"var = var;FI"var = 0;FI"if (var == 1) then;FI"@var = @var;Fi
[
[	@õi⁄I"X        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@ûi‚I"X        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@°i…I"X        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@§i¥I"9        else
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@îiÕI"$        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[I"assert(var.i386?.!);FI"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);FI"assert(var.dylib?.!);FI"%assert(var.mach_o_executable?.!);Fi
[
[	I"*data//homebrew_proj/test/test_mach.rb;TiEI"Q  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@ßioI"_  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@ßiéI"G    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@ßiûI"Q    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@ßiÆI"C    var = (HOMEBREW_PREFIX / "foo_script")
    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs);Fi[@'@3@4I"teardown_db;FI"end;FI" ;Fi
[
[	I">data//redmine_proj/plugins/acts_as_list/test/list_test.rb;Ti2I"6  def function(arglist)
    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi[	@∑iºI"Q    (1..4).each do |arglist|
      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id));Fi[	I"Fdata//redmine_proj/plugins/acts_as_tree/test/acts_as_tree_test.rb;Ti?I"Ô    @var = TreeMixin.create!(:parent_id => (@var.id))
    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var]);Fi[	@ºióI"§    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "mixins.parent_id IS NULL", :order => "mixins.id");Fi[	@ºiΩI"Ó    setup_db
    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root));Fi[@≥@\I" ;F@^I" ;FI"bottle do |arglist|;Fi
[
[	@biìI"1end
class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    url("file:///foo.com/testball-0.1-bottle.tar.gz")
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");Fi[	@bi‡I"end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
  end;Fi[	@biÔI"end
class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :lion)
  end;Fi[	@bi˛I"Mend
class AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion);Fi[	@biI"end
class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[@'@(I"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;Fi
[
[	@õilI"        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@ûiaI"        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@°i[I"        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@§iAI"¯        var = "L" unless var.index("L").nil?
        var = (var + "R") unless var.index("R").nil?
        var = var.index("T").nil?.! ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@îi:I"Ã          (var << "R") if var.include?("R")
          var = var.include?("T") ? ((var + "T")) : (var)
        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[@'@3I"attr_reader :function;FI" ;FI"private;FI" ;Fi
[
[	I"Qdata//activerecord_proj/active_record/associations/belongs_to_association.rb;TiI"⁄      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function
      
      private
      
      def function(arglist)
        loaded?.! and (foreign_key_present? and klass);Fi[	I"Pdata//activerecord_proj/active_record/attribute_methods/before_type_cast.rb;TiI"      #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      
      private
      
      # Handle *_before_type_cast for method_missing.
      def function(arglist);Fi[	@\i∫I"0            @var = var.slice((4..-36))
            @var = var.slice((-32..-1))
            @var = @var.sub((@var + "/"), "")
          end
          
          attr_reader :function
          
          private
          
          ##
          # Sanitize string and replace any invalid UTF-8 characters.;Fi[	@çi.I"™      end
      check_requirement!
      @var
    end
    
    attr_reader :function
    
    private
    
    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/;Fi[	@y	iI"      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      
      private
      
      # Searches the path, looking for the given utility. If an executable
      # file is found that matches the parameter, this returns true.;Fi[@@
@ã@åI"@var = var;FI"end;FI" ;Fi
[
[	@ƒiI"©    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@~
iI"    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick
    # specs don't bother to include the arch in the platform string;Fi[	@à
i,I"˚        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("\"%s\"" % @var.join(File::PATH_SEPARATOR))];Fi[	I",data//jekyll_proj/jekyll/static_file.rb;TiI"    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.
    def function(arglist);Fi[	I"-data//rescue_proj/resque/failure/base.rb;TiI"e      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created
      # and #save is called.;Fi[@'@(@9@:I"end;FI"end;Fi
[
[	@«imI"¡            else
              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@ i,I"µ              warn("[err :: #{ch[:server]}] #{data}")
            else
              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	I"-data//compass_proj/compass/frameworks.rb;TiÄI"ë            end
            (var << "\n")
          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	@MiI"‡                var.push(Factory.from_db(klass, var))
              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end;Fi[	@i%I"ã            else
              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end
end;Fi[@@
I"	self;FI"end;FI" ;F@I"@var = var;Fi
[
[	@iI"π        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@≥iDI"£      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@≥iII"£      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@≥iNI"£      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@≥iSI"£      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[@'@(@9@:@I" ;Fi
[
[	I"=data//activerecord_proj/active_record/relation/merger.rb;Ti I"Ë            Hash.===(var) ? (var.joins!(var)) : (var.joins!(*var))
          else
            var.send("#{k}!", var)
          end
        end
        var
      end
    end
    
    class Merger
      attr_reader(:relation, :values);Fi[	@çiÑI"k        if @var.is_a?(Hash) and var = @var[var] then
          if var.enum and var.enum.include?(var).! then
            raise(MalformattedArgumentError, "Expected '#{name}' to be one of #{switch.enum.join(", ")}; got #{value}")
          end
        end
        var
      end
    end
    
    # Raises an error if @non_assigned_required array is not empty.
    #;Fi[	@Xi)I"⁄          (var << stop.times(Sass::Script::Number.new(100, ["%"])).inspect)
        else
          (var << stop.inspect)
        end
      end
      var
    end
  end
  
  module Gradient
    def self.included(arglist);Fi[	I"9data//mongoid_proj/lib/mongoid/relations/metadata.rb;TieI"ç          var.class.relations.values.each do |arglist|
            if (var.as == name) and (var.class_name == inverse_class_name) then
              var.push(var.name)
            end
          end
          var
        end
      end
      
      # For polymorphic children, we need to figure out the inverse from the
      # actual instance on the other side, since we cannot know the exact class;Fi[	@ﬂi4I"Ï        var.each do |arglist|
          if var = var.index(var) then
            var.delete_at(var)
          end
        end
        var
      end
    end
    
    OperatorMatcher.register(Array, "=~", Spec::Matchers::MatchArray)
  end;Fi[I"if var then;F@ÿI"var = "LTRB";FI"var = "LRT";FI"var = "LR";FI"	else;Fi
[
[	@õibI"    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@ûiWI"    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@°iQI"    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@îi.I"‚    var = var.gsub("\r", "")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then
          var = "";Fi[	@îi˘I"Ï    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then
          var = "";Fi[@≥@¥I"teardown_db;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@∑i3I"?    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@∑iΩI"U      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@ºi@I"·    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var])
    assert_equal(@var.children, [@var]);Fi[	@ºiòI"Ö    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "mixins.parent_id IS NULL", :order => "mixins.id")
    assert_equal([@var, @var, @var], var);Fi[	@ºiæI"Á    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root))
  end;Fi[@≥@¥@ú@—	@t
I"end;Fi
[
[	@˛igI"„    
    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@“i;I"        
        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@öi	I"–  module RbSupport
    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@ni
I"    module Errors
      class AttributeAssignmentError < Mongoid::Errors::MongoidError
        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      ;Fi[	@¢iI"Àmodule Paperclip
  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[@'@3I"J# Defines an initialization hook into the owner class for setting the;FI"J# initial state of the machine *before* any attributes are set on the;FI"# object;FI"def function(arglist);Fi
[
[	I"Idata//state_machine_proj/state_machine/integrations/active_record.rb;Ti&I"¿        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default
        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_static_state_initializer
        define_dynamic_state_initializer;Fi[	I"Gdata//state_machine_proj/state_machine/integrations/data_mapper.rb;TiRI"4      # Pluralizes the name using the built-in inflector
      def function(arglist)
        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (426 + 1))
      end;Fi[	I"Hdata//state_machine_proj/state_machine/integrations/mongo_mapper.rb;Ti$I"9      # Gets the Mongoid key for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (325 + 1))
      end;Fi[	I"Cdata//state_machine_proj/state_machine/integrations/mongoid.rb;Ti(I""      # Gets the field for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              @attributes ||= {}\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false)\n              \n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (386 + 1))
      end;Fi[	I"Bdata//state_machine_proj/state_machine/integrations/sequel.rb;TiHI"      # Loads the built-in inflector
      def function(arglist)
        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize_set(*)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (344 + 1))
      end;Fi[@I"if var then;F@ÿI"var = "LTRB";FI"var = "LRT";FI"var = "LR";Fi
[
[	@õiaI"¸    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@ûiVI"¸    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@°iPI"¸    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@îi-I"Ï    var = (var - (3 * @var))
    var = var.gsub("\r", "")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then;Fi[	@îi¯I"Á    SetX(var)
    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then;Fi[@≥@¥I"@var.empty?;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@çi8I"ß      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first
    end;Fi[	@êi-I"˙        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length }
        var.max;Fi[	@ÜieI">        load_programming_language("rb") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) }
      end;Fi[	@òi™I"¨  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end;Fi[	@√iI"ø  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?
    curl(*external_curl_args);Fi[@'@(@ÊI"def function(arglist);FI"# do nothing;FI"end;Fi
[
[	@Ji·I"˙          if has_inverse? and inverse_of.nil? then
            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@Zi+I"        def function(arglist)
          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@qiÖI"_          print_elements(var, :passed, "scenarios")
        else
          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to;Fi[	@ıiyI"¡            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@™iI"˘            @var.puts(@var.description.gsub(/ \(druby.*\)/, ""))
            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[@≥@¥@I"end;FI" ;FI"def function(arglist);Fi
[
[	@¢i¶I"Á          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end;Fi[	@7iÇI"Ω      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!
      end;Fi[	@æ
i4I"◊      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var
        @var = (var = false;Fi[	@TiÖI"…          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end;Fi[	@UiuI"      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end;Fi[I"super(var);F@¿I"end;FI" ;FI"private;FI" ;Fi
[
[	@≥	iI"Ó      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@π	imI"      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@º	iI"      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@ø	iI"Ù      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@¬	iI"Â      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[I"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;F@?	I"@var = @var;Fi
[
[	@õiºI"Q      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@ûi∑I"C      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@°i´I"Q      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@§iìI"P      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@îiØI";      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[@≥@¥I"@var = nil;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@Ji–I"0      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!
        if has_and_belongs_to_many? and (association_foreign_key == foreign_key) then;Fi[	@„ihI"»        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var
        @var = " ";Fi[	@Æi™I"„        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var)
        @var = 0;Fi[	@±i4I"À      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var
        var ||= @var;Fi[	@li/I"«        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var)
        var;Fi[@•I"
raise;FI"end;FI"end;FI"end;FI" ;Fi	[	[	@çiÌI"’        rescue ActiveRecord::StatementInvalid => var
          if var.message.split(":").first =~ /Packets out of order/ then
            raise(ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.")
          else
            raise
          end
        end
      end
      
      # MysqlAdapter has to free a result after using it, so we use this method to write
      # stuff in an abstract way without concerning ourselves about whether it needs to be;Fi[	@©iI")        rescue ActiveRecord::StatementInvalid => var
          if /database .* already exists/.===(var.message) then
            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist)
        establish_master_connection;Fi[	@öi4I"M        if var.message =~ /GraphViz not installed or dot not in PATH/ then
          Bundler.ui.error(var.message)
          Bundler.ui.warn("The ruby graphviz gem requires GraphViz to be installed")
        else
          raise
        end
      end
    end
    
    desc("gem GEM", "Creates a skeleton for creating a rubygem")
    ;Fi[	@{i9I"Ü    rescue FormulaUnavailableError
      if var then
        raise("        Multiple kegs installed to #{rack}\n        However we don't know which one you refer to.\n        Please delete (with rm -rf!) all but one and then try again.\n        Sorry, we know this is lame.\n".undent)
      else
        raise
      end
    end
  end
  
  # self documenting perhaps?
  def function(arglist);Fi[I"=# @param [ Hash ] options The mongo persistence options.;FI"#;FI"<# @return [ Array<Object> ] The new value of the field.;FI"#;FI"# @since 2.1.0;FI"def function(arglist);Fi	[	[	I"9data//mongoid_proj/lib/mongoid/persistence/atomic.rb;Ti^I"v      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pop.new(self, var, var, var).persist
      end;Fi[	@˝iqI"g      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pull.new(self, var, var, var).persist
      end;Fi[	@˝i†I"r      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        PushAll.new(self, var, var, var).persist
      end;Fi[	@˝i¬I"g      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Sets.new(self, var, var, var).persist
      end;Fi[@'@(@Ê@°I"A# Transfers the archived file to the specified remote server;FI"def function(arglist);Fi	[	[	@Vi5I"E        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	I".data//backup_proj/backup/storage/rsync.rb;Ti5I"L      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin
          (write_password_file! unless local;Fi[	@ti)I"U      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	@Yi'I"V      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[I"(attr_accessor(:username, :password);FI" ;FI"attr_accessor(:ip, :port);FI" ;FI"attr_accessor(:path);FI" ;Fi	[	[	@Vi	I"◊module Backup
  module Storage
    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:passive_mode)
      ;Fi[	@iI"ﬁ    class RSync < Base
      include(Backup::CLI::Helpers)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:local)
      ;Fi[	@ti
I"—module Backup
  module Storage
    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[	@Yi
I"“module Backup
  module Storage
    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[I"puts(var);FI"@var = true;FI"end;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@i7I"ç      puts("install to \"libexec\" and then symlink or wrap binaries into \"bin\".")
      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?
    var = [".a", ".dylib", ".framework", ".jnilib", ".la", ".o", ".so", ".jar", ".prl", ".pm", ".sh"];Fi[	@iGI"b      opoo("Non-libraries were installed to \"lib\".")
      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?
    var = f.bin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@iSI"h      opoo("Non-executables were installed to \"bin\".")
      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?
    var = f.sbin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@i_I"      opoo("Non-executables were installed to \"sbin\".")
      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars
    check_non_libraries;Fi[@'@(@ÊI"#:nodoc:;FI"def function(arglist);FI"
begin;Fi	[	[	@çiI"∆          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("COMMIT")
        rescue;Fi[	@çiI"ƒ          execute("COMMIT")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("ROLLBACK")
        rescue;Fi[	@ª
i–I"˚          end
          var[0].value = var
          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          require("diff/lcs")
        rescue LoadError => var;Fi[	@∂iGI"          @var.delete(var)
        else
          raise(MockExpectationError, "The method `#{message}` was not stubbed or was already unstubbed")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          verify_expectations
        ensure;Fi[@´	I"!@var = path.sub(/^\~\//, "");FI"end;FI" ;FI"private;FI" ;Fi	[	[	@Vi I"˚        @var ||= 21
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@i"I"        @var ||= 22
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored;Fi[	@tiI"¸        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@YiI"¸        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[@'@(@ÊI"attr_reader :function;FI" ;FI"def function(arglist);Fi	[	[	@=iﬂI"π            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?
      end;Fi[	@	i4I"
      var.each do |arglist|
        @var[var.switch_name] = var
        var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist)
      return super unless @var
      var = super;Fi[	@æ
iÈI"·            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then
          @var.puts("Disabling profiles...");Fi[	@òitI"´      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function
  
  def function(arglist)
    case @var
    when :provided_by_osx then;Fi[I"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;FI"-# @return [ Strategy ] The new strategy.;FI"def function(arglist);FI"@var, @var = var, var;FI"@var = var.send(var.name);Fi	[	[	@iiI"m        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@niI"m        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/nullify.rb;TiI"m        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@siI"m        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[I"J# Binds the base object to the inverse of the relation. This is so we;FI"E# are referenced to the actual objects themselves on both sides.;FI"#;FI"G# This case sets the metadata on the inverse object as well as the;FI"# document itself.;FI"#;Fi	[	[	@%i
I"º    module Bindings
      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   name.person.bind(:continue => true);Fi[	@/i
I"º    module Bindings
      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.name.bind(:continue => true);Fi[	@4i
I"æ    module Bindings
      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   game.person.bind(:continue => true);Fi[	@Ei
I"æ    module Bindings
      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.game.bind(:continue => true);Fi[@≥@¥@µ@∂I"end;FI" ;Fi	[	[	@ÕiI"Ó        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist)
        @var = (var or EmptyBackground.new);Fi[	@ª
iI"Ω        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable)
      ;Fi[	@wi[I"¿      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    
    class JsLanguage
      include(LanguageSupport::LanguageMethods);Fi[	@ÜiI"        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize)
      ;Fi[I"yield(var);FI"end;FI"end;FI" ;FI"##;F@i	[	[	@Vi4I"X        Net::FTP.send(:const_set, :FTP_PORT, port)
        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@i4I"U      # Establishes a connection to the remote server
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin;Fi[	@ti(I"s      # Net::SCP will use this connection to transfer backups
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@Yi&I"l      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[@≥@¥@µ@∂@}I"end;Fi	[	[	@ i'I"è    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@™iI"¶        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@≠iI"¶        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@™iI"ä        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[I"# @return [ Object ] self.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);FI"	self;FI"end;Fi	[	[	@óiI"      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__);Fi[	@óiI"¯      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.;Fi[	@ói'I"˜      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.;Fi[	@ói?I"      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.;Fi[I"3attr_accessor(:document, :relation, :metadata);FI" ;FI"J# Initialize the new cascade strategy, which will set up the relation;FI"# and the metadata.;FI"#;FI"(# @example Instantiate the strategy;Fi	[	[	@ii	I"Q  module Relations
    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@ni	I"R  module Relations
    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@hi	I"R  module Relations
    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@si	I"S  module Relations
    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[@µ@∂I"#;F@∏I")#   Strategy.new(document, metadata);FI"#;Fi	[	[	@iiI"Æ      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@niI"Ø      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@hiI"Ø      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@siI"∞      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[@≥@¥I"[];FI"end;FI" ;FI"def function(arglist);Fi	[	[	@Gi
I"ê    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end;Fi[	@ÕiI"Œ        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var)
        end;Fi[	@óiAI"y  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end;Fi[	@ßiI"Î      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?
        var = var.backtrace.collect do |arglist|;Fi[@}I"# type.;FI"#;F@ÄI"#   object.mongoize;FI"#;Fi	[	[	@ÉiRI"        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.
      #;Fi[	@àiI"ˆ        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[	@îinI"Û        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.
      #;Fi[	@ói{I"ı        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[@≥@¥I"@var ||= {};FI"end;FI" ;FI"def function(arglist);Fi	[	[	@úiI"Y        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("#{self}##{name} has been deprecated as of " + "backup v.#{deprecation[:version]}")
          (var << "\n#{deprecation[:message]}") if var[:message];Fi[	@liJI"†      end
      
      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@liNI"›      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end;Fi[	@,iI"Ú        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("#{intro} received unexpected message :#{sym}#{arg_message(*args)}")
      end;Fi[@'@(@)@*@≥I"module ClassMethods;Fi	[	[	@`i=I"«            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2)
      ;Fi[	I"Bdata//activerecord_proj/active_record/validations/presence.rb;TiI"ã          var = Array(var.send(var))
          if var.present? and var.all? { |arglist| var.marked_for_destruction? } then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods
      # Validates that the specified attributes are not blank (as defined by
      # Object#blank?), and, if the attribute is an association, that the;Fi[	@ci I"]            if var = relations[var] then
              var = var.cascade_strategy
              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods
        # Attempt to add the cascading information for the document to know how
        # to handle associated documents on a removal.;Fi[	I"0data//mongoid_proj/lib/mongoid/relations.rb;TièI"I        if instance_variable_defined?("@#{name}") then
          if (_parent.nil? or instance_variable_get("@#{name}").!=(_parent)) then
            remove_instance_variable("@#{name}")
          end
        end
      end
    end
    
    module ClassMethods
      # This is convenience for librarys still on the old API.
      #;Fi[@'@(@Ê@ñI"@var = var;FI"@var = var;Fi	[	[	@“iTI"Õ                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var)
        end;Fi[	@Ö
i I"@          Compass.configuration.sprite_load_path.each do |arglist|
            var = File.expand_path(var)
            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@}iI"“      class << self
        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil;Fi[	@ã
i"I"ù    mail(var) do |arglist|
      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var;Fi[I"0;FI"end;FI" ;FI"def function(arglist);FI"0;FI"end;Fi	[	[	@GiI"Ñ    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@GiI"Ñ    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@GiI"Ñ    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@Gi4I"Ñ    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[@'@(@Ê@ñ@I"end;Fi	[	[	@iI"      # If it's not, it will execute the given block.
      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@ƒi?I"‰    def function(arglist)
      if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private;Fi[	I"&data//homebrew_proj/exceptions.rb;Ti+I"      "      No available formula for #{$3} #{dependent_s}\n      Please tap it and then try again: brew tap #{$1}/#{$2}\n".undent
    else
      "No available formula for #{name} #{dependent_s}"
    end
  end
  
  def function(arglist)
    @var = var
  end
end
module Homebrew;Fi[	@§i•I"ª      @var = var
    else
      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[@∂I"#;F@∏@ƒI"#;FI"A# @param [ Document ] document The document to cascade from.;Fi	[	[	@iiI"•        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@niI"•        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@hiI"•        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@siI"•        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[@≥@¥I"	to_s;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@⁄iI"©      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var)
    end;Fi[	@Xi9I":        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end;Fi[	I"Qdata//compass_proj/compass/sass_extensions/monkey_patches/browser_support.rb;Ti%I"Ø    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "#{name}(#{args.join(", ")})"
    end;Fi[	I"1data//mongoid_proj/lib/mongoid/extensions.rb;TiI"πend
class Moped::BSON::ObjectId
  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist)
    ActiveSupport::XmlMini.to_tag(var[:root], self.to_s, var)
  end;Fi[@≥@¥I"+source_tags.map { |arglist| var.name };FI"end;FI" ;FI"def function(arglist);Fi	[	[	@
i>I"ﬂ      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end;Fi[	@›iHI"@      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq
      end;Fi[	@‡i(I"      def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init
        example_rows.each { |arglist| var.skip_invoke! };Fi[	@‡iRI"‚          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags
        end;Fi[@≥@¥I"@var ||= var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	I"1data//cucumber_prok/cucumber/ast/examples.rb;TiI"˜      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_comment(@var) unless @var.empty?;Fi[	@
iI"Ÿ      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var
        @var.init if @var;Fi[	@›iI"Ò      attr_accessor(:feature)
      
      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@iI"≥      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end;Fi[@∏@ƒI"#;F@1I"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;Fi	[	[	@iiI"¥        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@niI"¥        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@hiI"¥        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@siI"¥        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[@≥@¥I"@var.each(&var);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@∏
iI"—      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self
        (@var << var);Fi[	@êi$I"Ù      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)];Fi[	@òiÆI"¢  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag }
  end;Fi[	@√iI"£  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end;Fi[@I"var = 1;F@Ø@∆I"var = (var < 128);FI"if (var.chr == "\n") then;Fi	[	[	@õiqI"&    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@õiµI"(    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[	@°i`I"&    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@°i§I"(    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[I"# @return [ true ] true.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);FI"	true;FI"end;Fi	[	[	@ÉivI"›      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@Éi†I"ﬂ        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[	@îi{I"	      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the;Fi[	@îiΩI"⁄        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[@'@(@)@X	@Y	I"end;Fi	[	[	@«ilI"$              (var << "gem '#{clean_req(requirement.required_by.first)}', in any of the sources.")
            else
              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@iI"º              (var << " - #{description}")
            end
            (var << "\n")
          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	@øiJI"∆        next if (var.symlink? or var.directory?)
        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@i$I"π              (var << "#{item.inspect} and ")
            else
              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end
end;Fi[@@√I"var = 1;F@ØI"var = var[var];FI"if (var == "\n"[0]) then;Fi	[	[	@§iFI"√    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@§iåI"˚    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1);Fi[	@îi?I"√    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@îi®I"Î    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[@@√@¨@Ø@∆I"var = (var < 128);Fi	[	[	@õipI"    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@õi¥I"%    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@°i_I"    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@°i£I"%    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[@@√@ƒ@≈@ØI"var = var[var];Fi	[	[	@§iEI"∏    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then;Fi[	@§iãI"     var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var);Fi[	@îi>I"∏    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then;Fi[	@îißI"‡      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[@ƒI"#;F@1@jI"#;F@^i	[	[	@iiI"Ü        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@niI"Ü        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@hiI"Ü        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@siI"Ü        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[@≥@¥I"Avar = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);FI"var;FI"end;FI" ;Fi	[	[	@ii√I"0        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@ii»I"@        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@iiÕI"@        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@ii“I"        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[@1@jI"#;F@^@_@`i	[	[	@iiI"ê        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@niI"ê        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@hiI"ê        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@siI"ê        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[@FI"#   end;TI"#;TI"#   person.pets;TI"#   # => [;T@i	[	[	@#i&I"õ      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#i_I"y      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#i}I"p      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#iñI"p      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@'@3I"E# Unbinds the base object and the inverse, caused by setting the;FI"# reference to nil.;FI"#;FI"$# @example Unbind the document.;Fi	[	[	@%i$I"x                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true)
          #   name.person = nil;Fi[	@/iI"Ö            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true)
          #   person.name = nil;Fi[	@4i%I"A                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true)
          #   game.person = nil;Fi[	@EiI"è          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.game.unbind(:continue => true)
          #   person.game = nil;Fi[I"var.puts(var);FI"var.puts("---");FI"var.puts(var);FI"end;FI"end;FI"end;Fi	[	[	@8iI"ﬂ          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@;i#I"ﬂ          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@>iI"˜          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
    
    def self.suffix(arglist);Fi[	@DiI"ﬂ          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[@^@_@`@aI"end;FI" ;Fi	[	[	@iiI"”        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@niI"”        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@hiI"±        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead
        # sets the foreign key values to nil.;Fi[	@siI"”        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[@≥@¥I"var = @var["cw"];FI"!var = ((@var - @var) - @var);FI"/var = (((var - (2 * @var)) * 1000) / @var);FI"var = var.gsub("\r", "");Fi	[	[	@õi´I"Ï      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@ûi¶I"Ï      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@°iöI"Ï      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@§iÉI"    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[I"var = @var;FI"@var.each do |arglist|;FI"newobj;FI"]out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));FI"out("endobj");FI"end;Fi	[	[	@õiI"  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@ûi˘I"  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@°iﬂI"  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@îi%I"  	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each do |arglist|
      newobj;Fi[I"undef_method(:namespace);FI" ;FI")undef_method(:namespace_definitions);FI" ;FI"2undef_method(:line) if method_defined?(:line);FI" ;Fi	[	[	I"7data//nokogiri_proj/nokogiri/xml/attribute_decl.rb;TiI"'      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";Fi[	I",data//nokogiri_proj/nokogiri/xml/dtd.rb;TiI"Ò      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys;Fi[	I"5data//nokogiri_proj/nokogiri/xml/element_decl.rb;TiI"Emodule Nokogiri
  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";Fi[	I"4data//nokogiri_proj/nokogiri/xml/entity_decl.rb;TiI"      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist)
        var.create_entity(var, *var);Fi[I"newobj;FI"#out("<</Type /FontDescriptor");FI"'out(("/FontName /" + var["name"]));FI"out("/Flags 6");FI"'out("/FontBBox [0 -200 1000 900]");FI"out("/ItalicAngle 0");Fi	[	[	@õiYI"    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@ûiZI"1    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@°iDI"    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@îióI"1    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[I"out("endobj");FI"newobj;F@_@`I"out("/Flags 6");F@bi	[	[	@õiXI"      end
    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@ûiYI"     end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@°iCI"      var = (var + "]")
    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@îiñI"     end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[@'@3I"J# Determines what the response should be for a particular bit of text;FI"H# from the SCM. Password prompts, connection requests, passphrases,;FI"# etc. are handled here.;FI"def function(arglist);Fi	[	[	@iGI"à            var[/^date: (.*?);/, 1]
          end.sort.last + " UTC")
          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          logger.info("[#{stream}] #{text}")
          case var;Fi[	@i{I"ï        
        def function(arglist)
          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}");Fi[	@åi<I"≠        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          case var
          when /\(P4PASSWD\) invalid or unset\./i then;Fi[	@iCI"¿        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}");Fi[@'@(@9@:@;I"private;Fi	[	[	@î	i5I"Â          var.to_ary.map { |arglist| var.serializable_hash(var) }
        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send);Fi[	@|iSI"·      if @var.kind_of?(Hash) then
        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist);Fi[	@pi_I"ø        end
        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist);Fi[	@h	iëI"‘          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.;Fi[I"var = @var["cw"];F@-@.@/I"var = var.length;FI"var = -1;Fi	[	[	@õi≠I"‹  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@ûi®I"‹  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@°iúI"‹  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@§iÖI"‹  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[@@
I"@var = (var + var);FI"	else;FI"@var = var if (var == 2);FI"end;FI"end;Fi	[	[	@õiúI"®      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@ûióI"®      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@°iãI"®      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@îiÄI"©    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[I"/var = (((var - (2 * @var)) * 1000) / @var);FI"var = var.gsub("\r", "");FI"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;Fi	[	[	@õiØI"Î  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@ûi™I"Î  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@°iûI"Î  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@§iáI"Î  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[@'@3I"# Returns true;FI"def function(arglist);FI"	true;FI"end;Fi	[	[	@ïisI"Í      #:nodoc:
      def function(arglist)
        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.;Fi[	@ïiåI"´      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@ïi¢I"—      # Clears the prepared statements cache.
      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@ïißI"π      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[@≥I"module ClassMethods;FI"end;FI"end;FI"end;FI"end;Fi	[	[	@¿i[I"ø        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@√iÉI"É          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@∆i>I"™          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@…iRI"¢        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[@≥I"# Returns true;F@¡I"	true;FI"end;FI" ;Fi	[	[	@ïitI"˜      def function(arglist)
        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.
      def function(arglist);Fi[	@ïiçI"ª      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var.!=(false);Fi[	@ïi£I"ø      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@ïi®I"±      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true;Fi[@±I"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;Fi	[	[	@õi∞I"Ï    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@ûi´I"Ï    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@°iüI"Ï    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@§iàI"Ï    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[@'@3@‚@„I"attr_reader :function;FI" ;Fi	[	[	I"9data//activerecord_proj/active_record/persistence.rb;TiGI"       def function(arglist)
        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Returns true if the record is persisted, i.e. it's not a new record and it was
    # not destroyed, otherwise returns false.;Fi[	@&	idI"ﬂ      # Enumerates over the manifest files
      def function(arglist)
        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      
      protected
      ;Fi[	I"1data//paperclip_proj/paperclip/attachment.rb;TiùI"Q    def function(arglist)
      var = @var[:processors]
      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Saves the file, if there are no errors. If there are, it flushes them to
    # the instance's errors and returns false, cancelling the save.;Fi[	@∞iI"–          @var = 0
          @var = 0
          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist)
          @var = var;Fi[@'@(I"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);Fi	[	[	I"$data//homebrew_proj/cmd/deps.rb;Ti
I"&  var.deps.each do |arglist|
    puts((("> " * var) + var.to_s))
    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--all") then
      Formula.each { |arglist| puts("#{f.name}: #{(f.deps * " ")}") };Fi[	I"#data//homebrew_proj/cmd/irb.rb;TiI"‹class String
  def function(arglist)
    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--help") then
      puts("'v8'.f # => instance of the Ack formula");Fi[	I"'data//homebrew_proj/cmd/options.rb;TiI"—      raise(FormulaUnspecifiedError) if ARGV.named.empty?
      ARGV.formulae
    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    ff.each do |arglist|
      next if var.build.empty?;Fi[	I"'data//homebrew_proj/cmd/upgrade.rb;Ti	I"
class Fixnum
  def function(arglist)
    (self > 1) ? ("s") : ("")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then
      abort("Cowardly refusing to `sudo brew upgrade'");Fi[I"$var = read_file("libexec/NOOP");FI":assert(var.include?("NOOP").!, "File was unpatched.");FI"Fassert(var.include?("ABCD"), "File was not patched as expected.");FI"end;FI"end;FI"end;Fi	[	[	I".data//homebrew_proj/test/test_patching.rb;Ti#I"M  def function(arglist)
    shutup do |arglist|
      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@"i-I"O  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@"i7I"K  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@"iAI"4  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
end;Fi[@ÿI"var = "LTRB";FI"var = "LRT";FI"var = "LR";FI"	else;FI"var = "";Fi	[	[	@õicI"6    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@ûiXI"6    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@°iRI"6    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@§i8I"6    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "\n")
    var = 0
    if var.!=(0) then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.index("L").nil?
        var = (var + "R") unless var.index("R").nil?;Fi[@≥I"acts_as_api;FI" ;FI"+api_accessible(:backbone) do |arglist|;FI"var.add(:id);FI"var.add(:guid);Fi	[	[	I"'data//diaspora_proj/models/like.rb;TiI"Ê  after_destroy { |arglist| self.parent.update_likes_counter }
  
  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	I"0data//diaspora_proj/models/participation.rb;TiI"∏      { :target => (@var) }
    end
  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	@^iI"¯  include(Encryptor::Public)
  
  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:name)
    var.add(lambda { |arglist| var.diaspora_handle }, :as => :diaspora_id);Fi[	@≤iI"—  include(Diaspora::Commentable)
  
  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:created_at)
    var.add(:author);Fi[I"assert(var.universal?.!);FI"assert(var.i386?.!);FI"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);FI"assert(var.dylib?.!);Fi	[	[	@ßinI"A  
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@ßiçI"?  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@ßiùI"I  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@ßi≠I";  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[@'@3@4I"var = @var["cw"];F@-@.i	[	[	@õi™I"Ë    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@ûi•I"Ë    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@°iôI"Ë    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@§iÇI"?    var = (var + "B") if var.!=(0) and var.index("B").nil?.!
    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[@≥@}I"# type.;FI"#;F@Ä@‡i	[	[	@ÉiQI"%      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.;Fi[	@àiI"
      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[	@îimI"˜        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.;Fi[	@óiI"˝          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[@≥@µ@∂I"#;F@∏@ƒi	[	[	@ii
I"É    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@ni
I"Ñ    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@hi
I"Ñ    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@si
I"Ö    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[@†@°@¢@£@§I"#assert(var.text_executable?.!);Fi	[	[	@ßiFI"p    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var));Fi[	@ßiTI"g    var = Pathname.new("#{TEST_FOLDER}/mach/i386.bundle")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var));Fi[	@ßipI"h    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert((var.arch == :dunno));Fi[	@ßiØI"9    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs)
    assert((var.arch == :dunno));Fi[@'@3@4@€I"var;FI"end;Fi	[	[	@ii¬I"      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@ii«I"      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@iiÃI"      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@ii—I"      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[@<	@=	@>	I"var = 0;FI"var = (var + 1);FI"$var = var if var and (var == 2);Fi	[	[	@§iSI"1        var = (var == 0) ? (0) : ((var - 1))
        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == " "[0]) then;Fi[	@§ipI""            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1);Fi[	@îiMI"        var = (var == 0) ? (1) : (var)
        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@îikI"          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1);Fi[I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;FI"@var = @var;FI"	else;FI"if (var == 0) then;FI"@var = var;Fi	[	[	@õióI"      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@ûiíI"      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@°iÜI"      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@îizI"      out("0 Tw")
    end
    (var << "B") if var.is_a?(String) and var.include?("B")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var);Fi[I"
false;FI"end;FI" ;F@≈I"
false;FI"end;Fi	[	[	@äiI"¡      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions;Fi[	@@i|I"T      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,;Fi[	@Gi$I"å    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist);Fi[	@óixI"‘  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist);Fi[I"	true;FI"end;FI"end;FI"end;FI"end;FI"end;Fi	[	[	@ª
iÇI"n        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@Éi§I"        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array)
::Array.__send__(:extend, Mongoid::Extensions::Array::ClassMethods);Fi[	@îi¡I"Ï        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash)
::Hash.__send__(:extend, Mongoid::Extensions::Hash::ClassMethods);Fi[	I".data//rspec_proj/spec/matchers/include.rb;Ti&I"à              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end
end;Fi[@¿@¡I" ;F@„I"	true;FI"end;Fi	[	[	@çiàI"      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.;Fi[	@çiëI"      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax;Fi[	@ïiáI"•      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@ïi´I"û      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:;Fi[@°I"	else;F@£I"end;FI"end;FI"end;Fi	[	[	@õiùI"Æ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@ûiòI"Æ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@°iåI"Æ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@îiÅI"»      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell);Fi[@'@Î@Ï@è	@<I"var = {};Fi	[	[	@|iJI"      var = {}
      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {}
      if @var.kind_of?(Hash) then
        @var.each do |arglist|;Fi[	@i¬I"          var = [self]
          while var.last.inherited_data do
            (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {}
          ATTRIBUTES.each do |arglist|
            var = [];Fi[	@ciÃI"≤        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var)
      var.scan(/\s+/);Fi[	@fiI"I    HOMEBREW_CELLAR.subdirs.each do |arglist|
      var = Formula.factory(var.basename.to_s) rescue nil
      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {}
    var.each do |arglist|
      var = var.recursive_deps.uniq.reject do |arglist|;Fi[I"module ClassMethods;FI"end;FI"end;FI"end;FI"end;FI"end;Fi	[	[	@¿i\I"°          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@√iÑI"s          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@∆i?I"{          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@…iSI"Ñ          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[@≈
I"#   class Person;FI"0#     include ActiveModel::AttributeMethods;FI"#;FI"#     attr_accessor :name;FI",#     attribute_method_suffix '_short?';Fi	[	[	@MiGI"T      #
      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@MiÅI"      end
      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@Mi√I"º      # To use, pass an attribute name (as string or symbol), be sure to declare
      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #
      #     # Call to define_attribute_method must appear after the;Fi[	@MiÍI"8      end
      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #;Fi[@Ë@È@ØI"def function(arglist);F@€I"var;Fi	[	[	@ii¡I"Ú      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@ii∆I"      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@iiÀI"      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@ii–I"      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[@'@éI"var = 0;FI"var = 0;FI"var = 0;FI"var = 1;Fi	[	[	@õimI"        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@ûibI"        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@°i\I"        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@îi•I"—    if (var == 1) and (var == " ") then
      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[@≈
I"#     private;FI"#;FI"%#     def attribute_short?(attr);FI""#       send(attr).length < 5;FI"#     end;Fi	[	[	@MiNI"      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@MiäI"Ù      #     define_attribute_methods :name
      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@MiŒI"/      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@MiÒI"      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[@≈
@2@3I"#     end;FI"#   end;FI"#;Fi	[	[	@MiPI"˚      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@MiåI"˝      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@Mi–I"˙      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@MiÛI"˙      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[@'@3@4I"broadcast(var, var);FI"end;FI" ;Fi	[	[	@Ii(I"Ô      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist);Fi[	@IiAI"      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@IieI"Â      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var);Fi[	@IiuI"      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.
      def function(arglist);Fi[@≈
@E@F@G@HI" #   person.pets.size # => 3;Ti	[	[	@#iéI"O      # Deletes the records of the collection directly from the database.
      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@#iI"8      #
      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@#iI"í      # Destroys the +records+ supplied and removes them from the collection.
      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@#iåI"Ã      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #;Ti[@-@.@/I"var = var.length;FI"var = -1;FI"var = 0;Fi	[	[	@õiÆI"‚  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@ûi©I"‚  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@°iùI"‚  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@§iÜI"‚  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[@≈
I"#   person.pets;TI"#   # => [;T@@@i	[	[	@#i(I"\      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iaI"\      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iI"\      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iòI"\      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[@-@.I"end;FI"var = (var + 1);FI"	next;FI"end;Fi	[	[	@õi¬I"?        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@ûiΩI"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@°i±I"?        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@§iôI"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == " "[0]) then
        var = var;Fi[I">Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);FI"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;F@?	i	[	[	@õiªI"]      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@ûi∂I"O      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@°i™I"]      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@îiÆI"1    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[@'@3@4I"@var.each(&var);FI"end;FI" ;Fi	[	[	@∏
iI"¬      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self;Fi[	@êi#I"$      # Duplicates this instance and adds +step_invocations+ to the end
      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1);Fi[	@òi≠I"ü  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag };Fi[	@√iI"†  
  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?;Fi[I"out(">>");FI"out("endobj");FI"newobj;FI"out("<</Type /Font");FI""out("/Subtype /CIDFontType0");FI"'out(("/BaseFont /" + var["name"]));Fi	[	[	@õiBI",    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((((("/CIDSystemInfo <</Registry " + textstring("Adobe")) + " /Ordering ") + textstring(var["registry"]["ordering"])) + " /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@ûiKI"
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@°i1I"
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@îiàI"
    out(((("/BaseFont /" + var["name"]) + "-") + var["cMap"]))
    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[@'@3@4@LI"end;FI" ;Fi	[	[	@
i=I"‹      
      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var);Fi[	@›iGI"=      
      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq;Fi[	@‡i'I"—      
      def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init;Fi[	@‡iQI"Ù        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags;Fi[@'@3@4I"	to_s;FI"end;FI" ;Fi	[	[	@⁄iI"ª    def function(arglist)
      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var);Fi[	@XiI"         raise(Sass::SyntaxError, "Expected a number. Got: #{stop}")
      end
      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    
    def self.color_to_s(arglist)
      var.is_a?(Sass::Script::String) ? (var.value.dup) : (var.inspect.dup);Fi[	@Xi8I"N      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var);Fi[	@Fi$I"¨    
    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "#{name}(#{args.join(", ")})";Fi[I">out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));FI"out(">>");FI"out("endobj");FI"newobj;F@™@´i	[	[	@õiAI"    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((((("/CIDSystemInfo <</Registry " + textstring("Adobe")) + " /Ordering ") + textstring(var["registry"]["ordering"])) + " /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@ûiJI"Í    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@°i0I"Í    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@îiáI"Í    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["cMap"]))
    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[@•@£I"end;FI"end;FI"end;FI" ;Fi	[	[	@õiûI"À      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@ûiôI"À      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@°içI"À      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@îiÇI"≤        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell)
  ;Fi[@•I"/render(:nothing => (true), :status => 422);FI"end;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@@iI"J          render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id])
    if (current_user.owns?(@var) or current_user.owns?(@var.parent)) then;Fi[	@FiI"3          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id)
    current_user.retract(@var);Fi[	@IiÅI"C    if params[:diaspora_handle] then
      Webfinger.in_background(params[:diaspora_handle], :single_aspect_form => (true))
      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id])
    if @var then;Fi[	@LiII"˙      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first
    if var then;Fi[@›@ﬁ@ﬂI"#;F@JI"var = case var;Fi	[	[	@≥	i+I"ä      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@º	i)I"ä      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@ø	i3I"ä      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@¬	i'I"ä      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[@•I"[];FI"end;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@i#I"          Dir.glob(File.join(templates_directory, "*")).map do |arglist|
            File.basename(var)
          end
        else
          []
        end
      end
      
      def function(arglist)
        File.join(templates_directory, var.to_s, "manifest.rb")
      end;Fi[	I"Cdata//diaspora_proj/helpers/interim_stream_hackiness_helper.rb;Ti#I"Ì  def function(arglist)
    if defined? @var and (params[:controller] == "multis") then
      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist)
    defined? @var ? (@var.publisher.open?) : (false)
  end;Fi[	I";data//homebrew_proj/vendor/multi_json/vendor/okjson.rb;TiºI"            [:val, var[0], Integer(var[0])]
          end
        end
      else
        []
      end
    end
    
    def function(arglist)
      var = /"([^"\\]|\\["\/\\bfnrt]|\\u[0-9a-fA-F]{4})*"/.match(var)
      raise(Error, "invalid string literal at #{abbrev(s)}") if var.!;Fi[	@ni#I"V      return [] unless libxml2?
      if compiled_parser_version.!=(loaded_parser_version) then
        ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end
    
    def function(arglist)
      var = {}
      var["warnings"] = [];Fi[@_@`I"out("/Flags 6");F@b@cI"out("/Ascent 800");Fi	[	[	@õiZI"'    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@ûi[I"    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@°iEI"'    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@îiòI"    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[@ﬁ@ﬂI"#;F@JI"var = case var;FI"when :success then;Fi	[	[	@≥	i,I"ù      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[	@º	i*I"ù      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[	@ø	i4I"ù      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :failure then;Fi[	@¬	i(I"ù      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[@'@3@4I"@var ||= {};FI"end;FI" ;Fi	[	[	@úiI"=        # Used only within the specs
        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("#{self}##{name} has been deprecated as of " + "backup v.#{deprecation[:version]}");Fi[	@liMI"⁄      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] };Fi[	I"'data//redmine_proj/redmine/i18n.rb;TiíI"ñ          var = ::I18n.load_path.select { |arglist| (File.basename(var, ".*") == var) }
          load_translations(var)
          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        # Looks up a translation from the translations hash. Returns nil if
        # eiher key is nil, or locale, scope or key do not exist as a key in the;Fi[	@,iI"        @var = (var[:__declared_as] or "Mock")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("#{intro} received unexpected message :#{sym}#{arg_message(*args)}");Fi[@ﬂI"#;F@JI"var = case var;F@&I""Success";Fi	[	[	@≥	i-I"û      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[	@º	i+I"û      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[	@ø	i5I"û      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :failure then
          "Failure";Fi[	@¬	i)I"û      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[@•I"nil;FI"end;FI"end;FI"end;FI"end;Fi	[	[	@ii)I"„        else
          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  ;Fi[	I"Gdata//cucumber_prok/cucumber/rb_support/regexp_argument_matcher.rb;TiI"¨            var = var.offset(var)[0]
            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@Üi±I"            (@var << var)
            nil
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@Úi#I"¢        if var then
          var.email_the_user(var, var)
          var
        else
          nil
        end
      end
    end
  end
  
  def function(arglist);Fi[@ı@ˆ@˜@¯I"# @since 2.0.0;FI"def function(arglist);Fi	[	[	@˝i!I"É      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        AddToSet.new(self, var, var, var).persist
      end;Fi[	@˝iJI"l      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Inc.new(self, var, var, var).persist
      end;Fi[	@˝i~I"r      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        PullAll.new(self, var, var, var).persist
      end;Fi[	@˝ièI"g      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Push.new(self, var, var, var).persist
      end;Fi[@`I"out("/Flags 6");F@b@cI"out("/Ascent 800");FI"out("/Descent -200");Fi	[	[	@õi[I"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50");Fi[	@ûi\I"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60");Fi[	@°iFI"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50");Fi[	@îiôI"    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60");Fi[@≈
@ëI"#;FI"# @since 3.0.0;F@îI"	true;Fi	[	[	@ÉiuI"À      #
      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@ÉiüI"·        #
        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[	@îiI"≈      #
      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@îiºI"‹        #
        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[I"out("/Flags 6");F@b@cI"out("/Ascent 800");F@jI"out("/CapHeight 800");Fi	[	[	@õi\I"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>");Fi[	@ûi]I"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>");Fi[	@°iGI"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>");Fi[	@îiöI"    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>");Fi[@@I"end;FI" ;FI"private;FI" ;FI"##;Fi	[	[	@Vi!I"Ô        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #;Fi[	@i#I"        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored
      #;Fi[	@tiI"        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.;Fi[	@YiI"         @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist);Fi[@≈
@£I"#;FI"# @since 3.0.0;F@¶I"	self;Fi	[	[	@óiI"—      #
      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@óiI"”      #
      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@ói&I"–      #
      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@ói>I"◊      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[I"@var = @var;F@A	@⁄I"end;FI"var = (var + 1);FI"	next;Fi	[	[	@õi¡I"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "));Fi[	@ûiºI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then;Fi[	@°i∞I"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "));Fi[	@§iòI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == " "[0]) then;Fi[@•@¶@ß@®@©I"#;Fi	[	[	@îi¶I"∏        var = (var + var)
      end
      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #
  	# Calculate closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@îi∂I"›      @var[@var] = @var if (@var[@var] < @var)
      @var = (@var + 1)
      @var.push([])
    else
      # do nothing
    end
  end
  
  #
  	# Convert to accessible file path
  	# @param string :attrname image file name;Fi[	@îiëI"Œ      SetFontSize((@var + var))
      SetStyle("b", true)
      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #
  	# Process closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@îi>I"¡        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.
  	# @param string :tag tag name (in lowercase);Fi[@≈
@∏@ƒI"#;F@1@ji	[	[	@iiI"ü        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@niI"ü        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@hiI"ü        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@siI"ü        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[@≈
@1@jI"#;F@^@_i	[	[	@iiI"é        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@niI"é        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@hiI"é        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@siI"é        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[@≈
@^@_@`@aI"end;Fi	[	[	@iiI"ê        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@niI"ê        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@hiI"ç        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead;Fi[	@siI"ê        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[@'@3@4I"if var.nil? then;FI"nil;FI"	else;Fi	[	[	@CiI"ˆ          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if String.===(var) then
              Hash[var.scan(HstorePair).map do |arglist|;Fi[	@CiXI"        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if ("empty" == var) then
              (nil..nil);Fi[	@CijI"              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if Range.===(var) then
              if [var.first, var.last].all? { |arglist| Integer.===(var) } then;Fi[	@ôiI"˙        var.inherit_from!(configuration)
        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then
            var;Fi[@´@A	@⁄@¨@≠I"	else;Fi	[	[	@õiﬂI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@ûiÁI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@°iŒI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@§iπI"ˇ        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1)
      end;Fi[@'I"	self;FI"end;FI"end;FI"end;FI"end;Fi	[	[	@]i˚I"‰          var = "#{name.to_s.singularize}_ids="
          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	@`iSI"•            var.save
            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end
end;Fi[	@fiI"               field(var.inverse_type, :type => (String))
              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end
end;Fi[	@Ti£I"§            var = @var.instance_eval(&var)
            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end
end;Fi[@•@¶@ß@®@§I" ;Fi	[	[	@i6I"‚            target.destroy
          when :nullify then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private
      ;Fi[	@¯ioI"ˇ        problem("Use ENV.fortran during install instead of depends_on 'gfortran'")
      when "open-mpi", "mpich2" then
        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|;Fi[	@¯iÕI"8        end
      when /macports\/trunk/ then
        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then;Fi[	@iºI"¿        :zip
      when ".7z" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("r") { |arglist| var.read(1024) });Fi[@•I"
false;FI"end;FI"end;FI" ;FI"def function(arglist);Fi	[	[	I"Qdata//activerecord_proj/active_record/associations/collection_association.rb;TiI".            load_target if options[:finder_sql]
            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end
      end
      
      def function(arglist)
        @var = merge_target_lists(find_target, target) if find_target?
        loaded!;Fi[	@	ièI"‹      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super)
    end;Fi[	I"'data//diaspora_proj/models/user.rb;TiãI"    var = var.class.base_class.name
    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist)
    var = var.id.to_s
    var = var.class.base_class.to_s;Fi[	@§iÁI"›  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var;Fi[I"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;FI"var = 1;Fi	[	[	@õi±I"    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@ûi¨I"    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@°i†I"    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@§iâI"Ï    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[@'@3@4I"var;FI"end;FI" ;Fi	[	[	@@iI"«      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var));Fi[	@çi2I"Â      
      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true);Fi[	@ßi+I":          def function(arglist)
            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end
          
          alias :handle_snippet_text :handle_success
        end;Fi[	@ iI"ã    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var;Fi[I"&# @return [Array<Twitter::Tweet>];FI";# @param options [Hash] A customizable set of options.;FI"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;FI"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;FI"¥# @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi	[	[	I"0data//twitter_proj/twitter/api/timelines.rb;TiI"Ÿ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user
      #   Twitter.mentions;Fi[	@Mi]I"Z      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@MirI"…      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.;Fi[	@MiÑI"Z      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[@3I"#     end;FI"#   end;FI"#;FI"#   person = Person.new;FI"#   person.name = 'Bob';Fi	[	[	@MiRI"      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.name_short?   # => true;Fi[	@MiéI"       #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob"
      #   person.nickname        # => "Bob";Fi[	@Mi“I"      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob"
      #   person.name_short? # => true;Fi[	@MiıI"˜      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true
      #;Fi[@≈
I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;FI"#     end;Fi	[	[	@øiI".        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@øiWI".        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@øi{I".        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	I"<data//state_machine_proj/state_machine/macro_methods.rb;TiåI"D    #   class Vehicle
    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do;Fi[@2@3I"#     end;FI"#   end;FI"#;F@Yi	[	[	@MiQI"˙      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob";Fi[	@MiçI"¸      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob";Fi[	@Mi—I"¯      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob";Fi[	@MiÙI"˜      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true;Fi[@,I"S@var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) };FI"end;FI"end;FI"end;FI"end;Fi	[	[	I"0data//twitter_proj/twitter/action/follow.rb;TiI"Ô      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I";data//twitter_proj/twitter/action/list_member_added.rb;Ti!I"Ù      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/action/mention.rb;Ti(I"      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/action/retweet.rb;TiI"      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@'@3@4@@ÄI"end;Fi	[	[	@äioI"≠      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end
    end
    
    class RealTransaction < OpenTransaction;Fi[	@ª
iI"µ      class SurplusCell < Cell
        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end;Fi[	I"3data//diaspora_proj/models/account_deletion.rb;Ti+I"Ü  
  def function(arglist)
    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	@üiI"∏    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|;Fi[@,I"var = @var["cw"];F@-@.@/I"var = var.length;Fi	[	[	@õi¨I"ÿ    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@ûißI"ÿ    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@°iõI"ÿ    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@§iÑI"‡    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[@,@€I"var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@iiƒI"        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@ii…I"        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@iiŒI"        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@ii”I"Ê        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var;Fi[I"#     private;FI"#;F@2@3I"#     end;FI"#   end;Fi	[	[	@MiOI"      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@MiãI"Á      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@MiœI"      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@MiÚI"
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[I"#     end;FI"#   end;FI"#;FI"K#   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;FI".#   vehicle.state           # => "parked";FI"#;Fi	[	[	@ri€I"ù    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,
    # the default behavior of initializing the state machine attributes is used.;Fi[	@riˇI"Ü    #     def initialize(attributes = {})
    #       ...
    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling
    # <tt>super()</tt> will not only call the superclass's +initialize+, but;Fi[	@riI"¢    #     def initialize(attributes = {})
    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually
    # in cases where you want to change how static / dynamic initial states get;Fi[	@ri+I"ù    #       initialize_state_machines(:static => :force) do
    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid
    # initialization issues when +nil+ is a valid state.  Without passing in;Fi[@Z
@[
I"#   person.pets;TI"#   # => [;T@@i	[	[	@#i'I"\      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#i`I"\      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#i~I"\      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#ióI"\      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[I"%# @return [Array<Twitter::User>];FI"def function(arglist);F@ÇI"end;FI"end;FI"end;Fi	[	[	@âiI"ˆ      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@åi I"˚      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@èi'I"˜      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@íiI"˜      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[I"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;FI"&# @return [Array<Twitter::Tweet>];F@F@Gi	[	[	@MiI"(      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@MiZI"&      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@MioI"8      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@MiÅI"8      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[@'@Î@Ï@ÌI" ;FI"def function(arglist);Fi	[	[	@®iuI"ë          var = var.class.reflections[var]
          unless var then
            raise(ActiveRecord::ConfigurationError, "Association named '#{association}' was not found; perhaps you misspelled it?")
          end
          var
        end
      end
      
      def function(arglist)
        if (var.macro == :belongs_to) and var.options[:polymorphic] then
          var = var.send(var.foreign_type);Fi[	@=ibI"z            super(var, var)
            serialized_attributes.each do |arglist|
              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized);Fi[	@√iOI"|              var = custom_values.detect { |arglist| (var.custom_field == var) }
              var ||= custom_values.build(:customized => (self), :custom_field => (var), :value => (nil))
              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist)
          custom_field_values.select(&:visible?)
        end;Fi[	@qi±I"ü        end
      else
        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist)
    (@var << var)
    " :redsh##{@shelf.length}:";Fi[@,I"(self.class.to_s.sub("Backup::", "");FI"end;FI" ;FI"##;FI";# Logs a message to the console and log file to inform;Fi	[	[	I"0data//backup_proj/backup/compressor/base.rb;TiI"C      
      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor
      def function(arglist);Fi[	I".data//backup_proj/backup/database/base.rb;Ti'I"A      
      ##
      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database
      def function(arglist);Fi[	I"/data//backup_proj/backup/encryptor/base.rb;TiI"D      
      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive
      def function(arglist);Fi[	@ü
iFI"H      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process
      def function(arglist);Fi[@'@åI"# do nothing;FI"end;FI"end;FI" ;Fi	[	[	@EiPI"Ÿ              end
            end
            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      
      protected
      ;Fi[	@JiAI"˚            Associations::HasOneThroughAssociation
          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic);Fi[	@¥iI"            @var = "join"
            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|;Fi[	@îi=I"≠          SetLineWidth(0.1)
        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.;Fi[@,@-@.@»I"@var = var;FI"@var = var;Fi	[	[	@JidI"u      # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>{ class_name: "Money" }</tt>
      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s)
      end;Fi[	@ai
I"‚  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = []
      @var = Hash.new { |arglist| var[var] = Set.new };Fi[	@7i"I"…    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var.fetch(:via, :sftp);Fi[	@à
i*I"˙      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        ;Fi[@,@-@.@»@.I"end;Fi	[	[	@ƒiI"©    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function;Fi[	@~
iI"”    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick;Fi[	@ˇiI""    # base - The String path to the <source>.
    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.;Fi[	@iI"{      # The worker object who detected the failure
      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created;Fi[@'@3@t@u@ÈI"var = @var;Fi	[	[	@õiÎI"ÿ    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@ûiÙI"ÿ    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@°i⁄I"ÿ    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@§iI"Ì    else
      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "")) then
      1.upto(var) { |arglist| @var[var].gsub!(@var, var.to_s) };Fi[@'@3@t@u@ÈI"case var;Fi	[	[	@®iCI"Û      
      def function(arglist)
        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var
        when Hash then
          preload_hash(var);Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract/schema_dumper.rb;Ti(I"      # Lists the valid migration options
      def function(arglist)
        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var
        when BigDecimal then
          var.to_s;Fi[	@ãi˙I"          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	I">data//twitter_proj/twitter/request/multipart_with_file.rb;TiI"∑          end
        end
        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var
        when /\.jpe?g/i then
          "image/jpeg";Fi[@ı@ˆ@˜@F@G@Hi	[	[	@MiI"€      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@Mi[I"Ÿ      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@MipI"Î      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@MiÇI"Î      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[@ˆ@˜@F@G@H@Ii	[	[	@MiI"˙      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user;Fi[	@Mi\I"Ê      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@MiqI"¯      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@MiÉI"¯      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[@,I"0;FI"end;FI" ;F@I"0;Fi	[	[	@GiI"x      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@GiI"w      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@GiI"w      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@Gi3I"x      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[@,I"var = @var;T@;I"newobj;F@=I"out("endobj");Fi	[	[	@õiÔI"˘  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@ûi¯I"˘  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@°iﬁI"˘  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@îi$I"  	# putfonts
  	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each do |arglist|;Fi[I"%puts("The offending files are:");FI"puts(var);FI"@var = true;FI"end;FI"end;FI" ;Fi	[	[	@i6I"r      puts("For Java software, it is typically better for the formula to")
      puts("install to \"libexec\" and then symlink or wrap binaries into \"bin\".")
      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?;Fi[	@iFI")    unless var.empty? then
      opoo("Non-libraries were installed to \"lib\".")
      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?;Fi[	@iRI".    unless var.empty? then
      opoo("Non-executables were installed to \"bin\".")
      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?;Fi[	@i^I"    unless var.empty? then
      opoo("Non-executables were installed to \"sbin\".")
      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars;Fi[@,I"	true;FI"end;FI" ;F@„I"	true;Fi	[	[	@çiáI"Õ      end
      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@çiêI"Õ      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@ïiÜI"ö      end
      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@ïi™I"ô      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[@'@3@I"end;FI"end;FI"end;Fi	[	[	@¿iZI"»        
        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@√iÇI"°        def function(arglist)
          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@∆i=I"—          var = project.notified_users
          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@…iQI"⁄        # Returns an array of watchers' email addresses
        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[I";# @param options [Hash] A customizable set of options.;FI"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;FI"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;F@JI"S# @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi	[	[	@MiGI"∏      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik;Fi[	@Mi^I"ñ      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user;Fi[	@MisI"a      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@MiÖI"ƒ      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.;Fi[@,I"
false;FI"end;FI" ;F@≈I"
false;Fi	[	[	@äiI"ì        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@@i{I"]      # Does this adapter support DDL rollbacks in transactions? That is, would
      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@Gi#I"}      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@óiwI"¬  end
  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  ;Fi[@≈
@Â@Ê@ÇI"end;FI"end;Fi	[	[	@âiI"       end
      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@åiI"      end
      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@èi&I"      end
      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@íiI"      end
      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@,I"
super;FI"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@i$I"         replace(klass.find(var).index_by { |arglist| var.id }.values_at(*var))
      end
      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist)
        if block_given? then
          load_target.select.each { |arglist| yield(var) };Fi[	I"Ddata//rspec_proj/spec/runner/formatter/nested_text_formatter.rb;TiI"      class NestedTextFormatter < BaseTextFormatter
        INDENT = "  "
        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super
          var.nested_descriptions.each_with_index do |arglist|;Fi[	I"@data//rspec_proj/spec/runner/formatter/profile_formatter.rb;Ti
I"  module Runner
    module Formatter
      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          @var.puts("Profiling enabled.")
        end;Fi[@,@\@]@^@∏I"
false;Fi[[	@Gi;I"Ç      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end;Fi[	@OiI"å      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@öi5I"Ó      
      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      ;Fi[@,@∆@«I"end;FI"end;FI"end;Fi[[	@µi4I"g        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@BißI"õ      end
      
      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@1ieI"õ        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[@,@\@]@^@∏I"var;Fi[[	@@iI"†        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      ;Fi[	@iËI"…      
      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[	@¢iI"Ì    class PostgreSQLAdapter < AbstractAdapter
      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[@,@\@aI"end;FI" ;FI"L# Execute the cascading deletion for the relation if it already exists.;Fi[[	@iiI"≠        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@niI"≠        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@siI"≠        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[@,@ú@ùI"end;FI"end;FI"end;Fi[[	@ª
iÅI"|          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@Éi£I"Õ        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array);Fi[	@îi¿I"À        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash);Fi[@,@I"var = @var;FI"var = @var["cw"];FI"/var = ((@var - @var) - @var) if (var == 0);F@∞i[[	@õiXI"Î    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@ûiMI"Î    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@°iGI"Î    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[@,@-I"reconnect_ssl;FI"end;FI" ;FI"##;Fi[[	I"=data//bundler_proj/bundler/vendor/net/http/persistent.rb;Ti	I"Â  # For Net::HTTP parity
  ##
  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.;Fi[	@3iI",  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Finishes all connections on the given +thread+ that were created before
  # the given +generation+ in the threads +generation_key+ list.;Fi[	@3iÊI"A  # Setting this to VERIFY_NONE is a VERY BAD IDEA and should NEVER be used.
  # Securely transfer the correct certificate and update the default
  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # SSL verification callback.
  def function(arglist);Fi[@,@-@¯@˘I"private;FI" ;Fi[[	@ƒiBI"±      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "#{base_dir}/specifications/#{full_name}.gemspec";Fi[	@~
i'I"=    # Because Rubyforge cannot be trusted to provide valid specifications
    # once the remote gem is downloaded, the backend specification will
    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      @var ||= @var.fetch_spec([@var, @var, @var]);Fi[	@Øi!I"¿    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    
    # Gets the default Mongoid logger - stdout.
    #;Fi[@Z
@[
I"A# @param [ Array ] args The names of the fields to validate.;FI"#;FI"# @since 2.4.0;FI"def function(arglist);Fi[[	I"2data//mongoid_proj/lib/mongoid/validations.rb;TiéI"S      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::FormatValidator, _merge_attributes(var))
      end;Fi[	@JiüI"G      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::LengthValidator, _merge_attributes(var))
      end;Fi[	@Ji∞I"'      #     field :title
      #
      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end;Fi[@,I"3execute("SAVEPOINT #{current_savepoint_name}");FI"end;FI" ;FI"def function(arglist);FI"?execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[[	@çi"I"        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[	@´iµI"4          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        ;Fi[	@ïi4I"        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[@,@UI"end;FI" ;FI"def function(arglist);FI";execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[[	@çi&I"#        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[	@´iπI":          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end;Fi[	@ïi8I"#        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[@,I"var = 0;FI"var = @var["cw"];FI"var = var.length;FI"var = 0;FI"while (var < var) do;Fi[[	@õi>I"ﬁ    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@ûi.I"ﬁ    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@°i-I"ﬁ    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[@Z
@[
I"8# @return [ Object ] The return value of the block.;FI"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	I"9data//mongoid_proj/lib/mongoid/threaded/lifecycle.rb;Ti2I"       # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("bind");Fi[	@}iQI"$      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("build");Fi[	@}i™I":        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("create");Fi[@,I"var = case var;F@&I""Success";FI"when :warning then;FI""Warning";Fi[[	@≥	i/I"\      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[	@º	i-I"\      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[	@¬	i+I"\      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[@Z
@[
I"-# @return [ Enumerator ] The enumerator.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	I"<data//mongoid_proj/lib/mongoid/contextual/map_reduce.rb;Ti"I"4      # @example Iterate over the results.
      #   map_reduce.each do |doc|
      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        block_given? ? (documents.each { |arglist| yield(var) }) : (to_enum)
      end;Fi[	@¶iaI"^      # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          (documents[(skipping or 0), (limiting or documents.length)] or []).each do |arglist|;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/mongo.rb;TiqI"       # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          selecting do |arglist|;Fi[@,@C@@ @FI"broadcast(var, var);Fi[[	@Ii?I"Ú        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@IicI"Ï        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@IisI"Ú        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[@,I" self.author.diaspora_handle;FI"end;FI" ;FI"def function(arglist);FI"+self.author = Webfinger.new(var).fetch;Fi[[	I"*data//diaspora_proj/models/comment.rb;Ti7I"  after_destroy { |arglist| self.parent.update_comments_counter }
  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	@üi*I"Ω    (self.participants - [self.author])
  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	I"*data//diaspora_proj/models/message.rb;Ti/I"   
  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[@,I"$return image_url if (var == "");FI"4if (var.nil? or var.match(/^https?:\/\//)) then;FI"super(var);FI"	else;FI"%super(absolutify_local_url(var));Fi[[	@ailI"    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@aiuI"œ    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@ai~I"œ    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[I"#   class Person;FI"+#     include ActiveModel::Validations;FI"#;FI"#     attr_accessor :name;FI"&#     validates_presence_of :name;FI"#   end;Fi[[	I"7data//activemodel_proj/active_model/validations.rb;Ti∫I"     # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@ÀiÀI"*    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@ÀiÚI"+    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[@,I"%var = Node.new(:COMBINATOR, var);FI"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@ii(I"Ì      
      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@ii-I"œ        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@ii2I"œ        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[@,I"J"#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";FI"end;FI"end;FI"end;FI"end;Fi[[	@RiI"«      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@XiI"«      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@[iI"ª        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[@,I",AddCIDFont(var, "", var, var, var, var);FI"9AddCIDFont(var, "B", (var + ",Bold"), var, var, var);FI";AddCIDFont(var, "I", (var + ",Italic"), var, var, var);FI"@AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);FI"end;Fi[[	@õiI"µ    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[	@ûiI"µ    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[	@°iI"µ    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[@≈
I"K# @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline;FI"<# @note This method can only return up to 3,200 Tweets.;FI"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	@Mi'I"      (alias :mentions :mentions_timeline)
      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={});Fi[	@Mi?I"%      end
      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@MiWI",      (alias :retweeted_by :retweeted_by_user)
      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[@,I"out("/Subtype /Type0");FI"?out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));FI"'out(("/Encoding /" + var["CMap"]));F@–I"out(">>");Fi[[	@õi=I"    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[	@ûiFI"    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[	@°i,I"    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[@,I"Jif (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then;FI",@var = sprintf("%.3f g", (var / 255.0));FI"	else;FI"U@var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0));FI"end;Fi[[	@§iI"Q    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[	@§i"I";    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end;Fi[	@îi I"á  	# @since 1.3
  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[@,I"var = max_value;FI"var = min_value;FI"var = (var - var);FI"-var = (var == 0) ? (10) : ((var / 20.0));FI"var = ((var + var) - var);Fi[[	I"(data//redmine_proj/SVG/Graph/Bar.rb;TiI"M        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	I"2data//redmine_proj/SVG/Graph/BarHorizontal.rb;TiI"D      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	@iQI"Z        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[@,I"#if (action_hook == :save) then;FI"Iowner_class.set_callback(:save, :after, "value", :prepend => (true));FI"end;FI"
super;FI"end;Fi[[	@•igI"[        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@®iOI"S        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@3iI"w        def function(arglist)
          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
      ;Fi[@,@.I"Gowner_class.set_callback(:save, :around, self, :prepend => (true));FI"	else;FI"
super;FI"end;Fi[[	@gi;I"$      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@mi4I"$      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@pi8I"$      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[@,I"(action == :save);FI"end;FI" ;FI"6# Gets the db default for the machine's attribute;FI"def function(arglist);Fi[[	@giI"Ö      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default;Fi[	@miI"5      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value
      end;Fi[	@piI"3      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default
      end;Fi[@,I"Rvar.class.state_machines.transitions(var, action).perform { |arglist| yield };FI"end;FI" ;FI"G# Creates a scope for finding records *with* a particular state or;FI"# states for the attribute;Fi[[	@giDI"©      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] });Fi[	@mi=I"É      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|;Fi[	@piAI"´      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } });Fi[@≈
@Â@ÊI"S@var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) };FI"end;FI" ;Fi[[	@âiI"f      attr_reader(:max_position, :min_position, :target_objects)
      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection containing the followed user
      #;Fi[	@åiI"[      attr_reader(:max_position, :min_position)
      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection of lists that were added to
      #;Fi[	@èiI"J      attr_reader(:max_position, :min_position)
      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # The user who mentioned a user
      #;Fi[@,I"9@var = Array(@var[:target_objects]).map do |arglist|;FI"%Twitter::Tweet.fetch_or_new(var);FI"end;FI"end;FI" ;Fi[[	@èiI">      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user
      #;Fi[	I"/data//twitter_proj/twitter/action/reply.rb;TiI"E      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets
      #;Fi[	@íiI",      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user
      #;Fi[@,I"+var = Twitter::API::Arguments.new(var);FI"&merge_list!(var.options, var.pop);FI"Lunless (var.options[:owner_id] or var.options[:owner_screen_name]) then;FI"8merge_owner!(var.options, (var.pop or screen_name));FI"end;Fi[[	I",data//twitter_proj/twitter/api/lists.rb;TiHI"      #     Twitter.list_timeline('sferik', 8863586)
      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::Tweet, :get, "/1.1/lists/statuses.json", var.options)
      end;Fi[	@ÅiI"ª      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options)
      end;Fi[	@ÅiI"º        object_from_response(Twitter::List, var, var, var.options)
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var)
      end;Fi[@≈
@EI"def function(arglist);FI"9@var = Array(@var[:target_objects]).map do |arglist|;F@mI"end;Fi[[	@èiI"      end
      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@ui
I"=  module Action
    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@íi
I",  module Action
    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[@≈
I"#     property :id, Serial;FI"##     property :state, :String;FI"#;F@e@fi[[	@øiI"O        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@øiTI"O        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@øixI"O        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[@≈
I"#   class Vehicle;FI"7#     state_machine :state, :initial => :parked do;FI"#       ...;FI"#     end;FI"#;Fi[[	@riÂI"D    # the default behavior of initializing the state machine attributes is used.
    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize
    #     end;Fi[	@riˆI"b    # never get initialized.  In order to ensure that all initialization hooks
    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[	@riI"?    # 
    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[@≈
@ûI"'#     include DataMapper::Resource;FI"#;F@ì@îi[[	@øiI"T        # information about the various configuration options available.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@øiQI"E        # as the given requirements match the transition.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@øiuI"Y        # be performed so long as the given requirements match the transition.
        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[@≈
@û@ﬂI"!#       other_states :idling;FI"#     end;FI"#   end;Fi[[	I"?data//state_machine_proj/state_machine/state_collection.rb;TiI"Ï    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@∫i(I"    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@∫iCI"‰    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[@≈
@û@ﬂI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;Fi[[	I"9data//state_machine_proj/state_machine/extensions.rb;Ti?I"     # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@∆iqI".    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@Fi˚I"    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[@•I"	true;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@BiuI"          inverse_updates_counter_cache?(through_reflection).!
        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested
        var = load_target if (var == :all);Fi[	@≤i?I"6  def function(arglist)
    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist)
    var = StatusMessage.find_by_guid(self.status_message_guid)
    if self.status_message_guid and var then;Fi[	@çi4I"◊          else
            @var[:fog_public]
          end
        else
          true
        end
      end
      
      def function(arglist)
        for var, var in @var do
          (log("saving #{path(style)}");Fi[@≈
I"!# Valid requirement options:;FI"N# * <tt>:from</tt> - One or more states being transitioned from.  If none;FI"E#   are specified, then this will be the object's current state.;FI"N# * <tt>:to</tt> - One or more states being transitioned to.  If none are;FI"6#   specified, then this will match any to state.;Fi[[	I"4data//state_machine_proj/state_machine/event.rb;Ti|I"a    
    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.;Fi[	@›iI"    end
    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[	@›i1I"    end
    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[@≈
I"# == Example;FI"#;FI"#   class Vehicle;FI"/#     state_machine :initial => :parked do;F@¡i[[	@∆i=I"ä    # On the other hand, any <tt>:halt</tt> error that's thrown within an
    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@∆ioI"O    # a StateMachine::InvalidTransition exception will be raised.
    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@Fi˘I"F    
    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[@≈
@wI"#;FI"# @since 2.1.0;F@zI"
begin;Fi[[	@}i3I"      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("bind")
          yield);Fi[	@}iRI"
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("build")
          yield);Fi[	@}i´I"         #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("create")
            yield);Fi[@≈
I"#   class Game;FI"$#     include Mongoid::Document;FI"#     belongs_to :person;FI"#   end;FI"#;Fi[[	@ªi|I"         # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[	@ªiïI"L        #     include Mongoid::Document
        #     has_many :posts
        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.;Fi[	@ªi I"         # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[@≈
I"N# @option options [ true, false ] :continue Continue binding the inverse.;FI"E# @option options [ true, false ] :binding Are we in build mode?;FI"#;FI"# @since 2.0.0.rc.1;FI"def function(arglist);Fi[[	@%iI"÷          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata
            base.parentize(target);Fi[	@,iI"ª          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base)
            binding do |arglist|;Fi[	@,i&I"‘          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end;Fi[@•@¶@ßI"	else;FI""";FI"end;Fi[[	@viI"-            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[	@vi3I"-            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[	@vipI"Á            image_task(var, var, :label => (var))
          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[@•@¶@ßI"var;FI"end;FI" ;Fi[[	@§i/I"Ï          when :stderr then
            var = $stderr
            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        
        def self.wrap(arglist)
          validate_pipe(var);Fi[	@ÅiJI"        when Twitter::List then
          var[:list_id] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      
      # Take an owner and merge it into the hash with the correct key
      #;Fi[	I",data//twitter_proj/twitter/api/utils.rb;TiëI"J          var[[var, "screen_name"].compact.join("_").to_sym] = var
        when Twitter::User then
          var[[var, "user_id"].compact.join("_").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      
      # Take a multiple users and merge them into the hash with the correct keys
      #;Fi[@≈
I".# @param [ Class ] klass The model class.;FI"4# @param [ Hash ] spec The index specification.;FI"1# @param [ Hash ] options The index options.;FI"#;FI"<# @raise [ Errors::InvalidIndex ] If validation failed.;Fi[[	@‚iI"u        #
        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@‚i(I"z        #
        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@‚i>I"t        #
        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[@•@—@“@”@‘I":# Runs state events around the machine's :save action;Fi[[	@gi>I"w      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@mi7I"w      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@pi;I"w      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[@≈
I"5# @param [ String, Symbol ] name The config key.;FI"0# @param [ Hash ] config The configuration.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	I"@data//mongoid_proj/lib/mongoid/config/validators/session.rb;Ti&I"î        #
        # @example Validate the session has database.
        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionDatabase.new(var, var)) if no_database_or_uri?(var)
        end;Fi[	@Mi5I"à        #
        # @example Validate the session has hosts.
        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionHosts.new(var, var)) if no_hosts_or_uri?(var)
        end;Fi[	@MiEI"ö        #
        # @example Validate the uri and options.
        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          if both_uri_and_standard?(var) then
            raise(Errors::MixedSessionConfiguration.new(var, var));Fi[@•@—@“@”@<I" ;Fi[[	@´i0I"            if var then
              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist)
          super.insert;Fi[	@ki]I"’        else
          if lock_strategy_enabled?(:failed_attempts) and attempts_exceeded? then
            :locked
          else
            super
          end
        end
      end
      
      protected
      ;Fi[	I"/data//paperclip_proj/paperclip/tempfile.rb;TiI"        end
        var = Time.now.strftime("%y%m%d")
        var = "#{prefix}#{t}-#{$$}-#{rand(4294967296).to_s(36)}-#{n}#{suffix}"
      else
        super
      end
    end
  end
  
  module TempfileEncoding
    # This overrides Tempfile#binmode to make sure that the extenal encoding;Fi[@≈
I"# @since 2.2.0;FI"def function(arglist);FI"@var ||= {};FI"end;FI" ;Fi[[	I"7data//mongoid_proj/lib/mongoid/atomic/modifiers.rb;Ti’I"¸      #   modifiers.pull_fields
      #
      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be pushed.
      #;Fi[	@ei·I"˘      #   modifiers.push_fields
      #
      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be set.
      #;Fi[	@eiÌI"˙      #   modifiers.set_fields
      #
      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the $pullAll operations or intialize a new one.
      #;Fi[@≈
@%@&I"
false;FI"end;FI" ;Fi[[	@óiéI"∆      #   object.multi_arged?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Is the object a number?
      #;Fi[	@óiöI"Â      #   object.numeric?
      #
      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Remove the instance variable for the provided name.
      #;Fi[	@óiπI"ÿ      #   object.resizable?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Get the substitutable version of an object.
      #;Fi[@≈
@%@&I"@var.!.!;FI"end;FI" ;Fi[[	@õi!I"ˆ      #   context.cached?
      #
      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the number of documents matching the query.
      #;Fi[	@õiÒI"      #   context.cache_loaded?
      #
      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the documents for cached queries.
      #;Fi[	@,iqI"    #   criteria.embedded?
    #
    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    
    # Extract a single id from the provided criteria. Could be in an $and
    # query or a straight _id query.;Fi[@≈
@%@&I"@var ||= {};FI"end;FI" ;Fi[[	@]i"I"Ó    #   document.delayed_atomic_unsets
    #
    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Flag the document as destroyed and return the atomic path.
    #;Fi[	I"-data//mongoid_proj/lib/mongoid/config.rb;Ti’I"’    #   config.sessions
    #
    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Set the session configuration options.
    #;Fi[	I"9data//mongoid_proj/lib/mongoid/contextual/command.rb;TiI"“      #   command.command
      #
      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the database session.
      #;Fi[@•I"var = "";FI".var = "L" unless var.to_s.index("L").nil?;FI"6var = (var + "R") unless var.to_s.index("R").nil?;FI"6var = var.to_s.index("T") ? ((var + "T")) : (var);FI"end;Fi[[	@õigI"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[	@ûi\I"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[	@°iVI"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[@•I"&if list_of_color_stops?(var) then;FI"var = (var.value + var);FI"var = nil;FI"end;FI"end;Fi[[	@Xi˙I"      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then;Fi[	@XiI"5      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then;Fi[	@XiI"@      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first);Fi[@•I"clean_url(var);FI"end;FI"end;FI"end;FI" ;Fi[[	I"Adata//compass_proj/compass/sass_extensions/functions/urls.rb;Ti(I"Ì      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl
    def self.included(arglist);Fi[	@∞iAI"‚      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl
    def self.included(arglist);Fi[	@∞itI"      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl
    def self.included(arglist);Fi[@≈
I"=# base - The String path to the dir containing the file.;FI".# name - The String filename of the file.;FI"#;FI"# Returns nothing.;FI"def function(arglist);Fi[[	I",data//jekyll_proj/jekyll/convertible.rb;TiI"    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin
        (self.content = File.read(File.join(var, var));Fi[	I"%data//jekyll_proj/jekyll/page.rb;Ti!I"2    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["layout"] = "page" unless self.data.has_key?("layout");Fi[	I"%data//jekyll_proj/jekyll/post.rb;Ti?I"2    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["layout"] = "post" unless self.data.has_key?("layout");Fi[@•I"/render(:nothing => (true), :status => 404);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	I"8data//diaspora_proj/controllers/posts_controller.rb;Ti4I"R    if var.present? then
      var = OEmbedPresenter.new(var, params.slice(:format, :maxheight, :minheight))
      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).newer(@var)
    respond_to do |arglist|;Fi[	I":data//diaspora_proj/controllers/publics_controller.rb;Ti#I"8    @var = Person.find_by_guid_and_closed_account(params[:guid], false)
    if @var.present? and @var.local? then
      render("publics/hcard")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    render("host_meta", :content_type => "application/xrd+xml")
  end;Fi[	@≠iïI"]    var = User.find_by_username(var)
    if var.present? then
      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    if current_user.confirm_email(params[:token]) then
      flash[:notice] = I18n.t("users.confirm_email.email_confirmed", :email => (current_user.email));Fi[@•@∫I"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@aipI"    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@aiyI"    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@ai}I"4    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["month", "day"].all? { |arglist| var[var].present? } then
      var["year"] = "1000" if var["year"].blank?;Fi[@•I"return super(var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@õi9I"À  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[	@ûi)I"Õ  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[	@°i(I"À  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[@•I"-super(var, var, var, var, var, var, var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@õiSI"Ò  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@ûiHI"Û  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@°iBI"Ò  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[@•I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"6var = (var[var].chr == " ") ? ((var + 1)) : (var);FI"end;FI"var = -1;FI"var = var;Fi[[	@õiâI"ã        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@ûiÉI"}        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@°i}I"ã        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[@•@•I"@var = var;F@°I"	else;F@£i[[	@õiöI"Ú    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@ûiïI"Ú    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@°iâI"Ú    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[@≈
I"# @example;FI"#   class Person;FI"$#     include Mongoid::Document;FI"#     field :title;FI"#;Fi[[	@JiáI"ˇ      end
      
      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end;Fi[	@JiòI"Û      end
      
      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end;Fi[	@Ji©I"
      end
      
      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_presence_of :title
      #   end;Fi[@•I"super(var, var, var, var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@õißI"Á  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[	@ûi¢I"È  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[	@°iñI"Á  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[@•I">Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);FI"6var = (var[var].chr == " ") ? ((var + 1)) : (var);FI"end;FI"var = -1;FI"var = var;Fi[[	@õi◊I"r          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@ûiﬂI"d          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@°i∆I"r          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[@•I"var = var["name"];FI"out(("/BaseFont /" + var));FI"$if (var["type"] == "core") then;FI"out("/Subtype /Type1");FI"8if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[[	@õiI"b      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[	@ûiI"b      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[	@°i˝I"b      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[@•I"&out(("/Subtype /" + var["type"]));FI"out("/FirstChar 32");FI"out("/LastChar 255");FI".out((("/Widths " + (@var + 1)) + " 0 R"));FI"6out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[[	@õiI"§          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[	@ûiI"§          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[	@°iI"§          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[@•I"&out("/Encoding /WinAnsiEncoding");FI"end;FI"end;FI"end;FI"out(">>");Fi[[	@õiI"@          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[	@ûi(I"@          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[	@°iI"@          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[I"protected;FI" ;FI"B# Only runs validations on the action if using <tt>:save</tt>;FI"def function(arglist);F@GI"end;Fi[[	@giI"¯        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@miI"        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@piI"¯        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[@î@ï@ÈI"var = @var;F@;I"newobj;Fi[[	@õiÌI"ﬂ    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@ûiˆI"ﬂ    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@°i‹I"ﬂ    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[@≈
I"# == Examples;FI"#;FI"#   class Vehicle;F@ﬂ@µi[[	@∫iI"Q    # object's current value doesn't match the state, then this will return
    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@∫i&I"g    # Determines the current state of the given object as configured by this
    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@∫iAI"D    # Determines the current state of the given object as configured by this
    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[I"var = nil;FI"	else;F@ú@ùI"var = nil;FI"end;Fi[[	@Xi˘I"    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@XiI"      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@XiI"    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[@Ë@È@ÍI" ;FI"# :nodoc:;FI"def function(arglist);Fi[[	I"'data//rspec_proj/autotest/rspec.rb;Ti,I"˘  def function(arglist)
    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist)
    if File.exist?("spec/spec.opts") then
      "-O #{File.join("spec", "spec.opts")} ";Fi[	I"+data//rspec_proj/spec/rake/spectask.rb;TióI"…        when Proc then
          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["SPEC"] then
          FileList[ENV["SPEC"]];Fi[	@‚i*I"‹        when Symbol then
          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= mock_framework_path("rspec")
      end;Fi[@≈
I" #   person.pets.size # => 2;TI"#   person.pets;TI"#   # => [;TI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[[	@#iΩI"Y      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#iıI"Y      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#i-I"Z      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[@≈
I"#   person.pets.delete_all;TI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;TI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[[	@#iCI"†      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#idI"†      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@#i}I"†      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[@≈
I"def function(arglist);FI"var = case var;F@&I""Success";F@Üi[[	@≥	i.I"í      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[	@º	i,I"í      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[	@¬	i*I"í      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[@≈
@
@«I"#   end;FI"#;FI"#   person = Person.new;Fi[[	@ÀiºI"E    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false
    #   person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:["can't be blank"]}>;Fi[	@ÀiÕI"˜    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.valid? # => false;Fi[	@ÀiÙI"¯    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.invalid? # => true;Fi[@≈
@@ƒI"#;F@∆@«i[[	@ÀiπI"	    
    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@Ài I"    
    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@ÀiÒI"    
    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[@Ë@È@Ø@I" var = [var.first, var.last];FI"var;Fi[[	@ii’I"·      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@ii⁄I"¿      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@iiﬂI"¿      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[@Ë@È@Ø@I"%var = Node.new(:COMBINATOR, var);FI"var;Fi[[	@ii*I"›      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@ii/I"       
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@ii4I"       
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[@Ë@È@ØI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;Fi[[	@îikI"
          var = (var[var] or var[var.to_i])
          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@ói¯I"        #
        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11");Fi[	@⁄i3I"[          if Mongoid::Config.use_activesupport_time_zone? then
            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1");Fi[I"#extend(ActiveSupport::Concern);FI" ;FI"&def self.required_fields(arglist);FI"[];FI"end;FI" ;Fi[[	I"4data//devise_proj/devise/models/omniauthable.rb;Ti	I"¯module Devise
  module Models
    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        Devise::Models.config(self, :omniauth_providers);Fi[	I"4data//devise_proj/devise/models/registerable.rb;TiI"module Devise
  module Models
    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        # A convenience method that receives both parameters and session to;Fi[	I"3data//devise_proj/devise/models/timeoutable.rb;Ti	I"module Devise
  module Models
    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      # Checks whether the user session has expired based on configured time.
      def function(arglist);Fi[@é@è@êI" ;F@=I"def function(arglist);Fi[[	@gi?I"e        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@mi8I"e        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@pi<I"e        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[@≥I"%# @param request_method [Symbol];FI"# @param path [String];FI"# @param args [Array];FI"%# @return [Array<Twitter::User>];FI"def function(arglist);Fi[[	@Åi I"!      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop);Fi[	@-iI"5      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|;Fi[	@-iI"ç          object_from_response(Twitter::User, var, var, merge_user(var.options, var))
        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then;Fi[@¿I"	else;FI"
false;TI"end;TI"end;TI" ;Fi[[	@	iéI"Ó    def function(arglist)
      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super);Fi[	@#iMI"œ    end
    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  
  def self.build(arglist)
    var = User.new(var);Fi[	@§iÊI"œ  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then;Fi[@≥@=@ @TI"end;FI" ;Fi[[	@giBI"U          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@mi;I"U          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@pi?I"U          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[@≥I"H# Uses around callbacks to run state events if using the :save hook;FI"def function(arglist);FI"#if (action_hook == :save) then;F@;I"	else;Fi[[	@gi9I"Q      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@mi2I"a        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@pi6I"p        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[@≥@c@d@GI"end;FI" ;Fi[[	@giI"      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@miI"      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@piI"      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[@±@≤I"end;FI"end;TI"end;FI"end;Fi[[	@ÔiåI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@ÚiI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	I"5data//rspec_proj/spec/runner/drb_command_line.rb;TiI"†          true)
        rescue DRb::DRbConnError
          var.error_stream.puts("No server is running")
          false
        end
      end
    end
  end
end;Fi[@≥I"L# Describes the current validation errors on the given object.  If none;FI"F# are specific, then the default error is interpeted as a "halt".;FI"def function(arglist);FI"if var.errors.empty? then;FI""Transition halted";Fi[[	I"Hdata//state_machine_proj/state_machine/integrations/active_model.rb;Ti$I"z          var.errors.add(var, var, var.merge(var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ");Fi[	@jiI"x          var.errors.add(self.attribute(var), generate_message(var, var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          var = [];Fi[	@si!I"ü      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ");Fi[@≥I"Aattr_reader(:plugin_path, :plugin_name, :plugin_pretty_name);FI" ;FI"def function(arglist);FI"
super;FI" @var = file_name.underscore;Fi[[	I"Mdata//redmine_proj/generators/redmine_plugin/redmine_plugin_generator.rb;TiI"Bclass RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[	I"cdata//redmine_proj/generators/redmine_plugin_controller/redmine_plugin_controller_generator.rb;TiI"O  argument(:controller, :type => :string)
  
  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[	I"Ydata//redmine_proj/generators/redmine_plugin_model/redmine_plugin_model_generator.rb;TiI"™  class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[@≥@LI" ;F@NI" ;FI"def function(arglist);Fi[[	@RiI"*      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end;Fi[	@UiI"Ù      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys
      end;Fi[	@Xi	I"?  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end;Fi[@E@F@z@{@YI"#   person.pets;Ti[[	@#ièI"H      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#iI"s      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#iI"á      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[I"
begin;FI"!var = (var + var.iconv(var));FI""rescue Iconv::IllegalSequence;FI"var = (var + $!.success);FI"1var = ("?" + $!.failed[1, $!.failed.length]);FI"
retry;Fi[[	I"/data//redmine_proj/redmine/codeset_util.rb;TiI"R        else
          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@ê i>I"N        else
          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@ê i|I"N        else
          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[@≥@JI" ;F@LI" ;F@Ni[[	@RiI"˘      undef_method(:attributes)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@UiI"ı      undef_method(:values)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@[iI"      undef_method(:attribute_nodes)
      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist);Fi[@Ä@Å@Ç@∏I"var;FI"end;Fi[[	@@iI"ß      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist);Fi[	@iÈI"À      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[	@¢iI"»      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[@Ä@Å@Ç@∏I"
false;FI"end;Fi[[	@Gi<I"~    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@OiI"é    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI;Fi[	@öi6I"      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[@≥I"!# Read the YAML frontmatter.;FI"#;F@∑@∏I"#;Fi[[	@æiI"
    def function(arglist)
      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@¡iI"      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@ƒi=I".        self.categories = self.data.pluralized_array("category", "categories")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[@Ä@Å@Â@ÊI" ;FI"def function(arglist);Fi[[	@¯ipI"      when "open-mpi", "mpich2" then
        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|
      var = Formula.factory(var.formula) rescue problem("Can't find conflicting formula \"#{req.formula}\".");Fi[	@¯iŒI"q      when /macports\/trunk/ then
        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then
      problem("Use a space in class inheritance: class Foo < #{$1}");Fi[	@iΩI"π      when ".7z" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("r") { |arglist| var.read(1024) })
  end;Fi[@≥I"$attr_reader(:gherkin_statement);FI" ;FI"def function(arglist);FI"@var ||= var;FI"end;Fi[[	@`iI"ˆ      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@
iI"      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@iI"Î      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[@Ä@ÅI"	else;FI""";FI"end;FI"end;Fi[[	@viI"ı          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist);Fi[	@vi4I"ı          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist);Fi[	@viqI"‚          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      if Object.const_defined?(:Magick) then;Fi[@≥I"I# Returns the command that will sync the given revision to the given;FI"L# destination directory. The perforce client has a fixed destination so;FI"K# the files must be copied from there to their intended resting place.;FI"def function(arglist);FI"$p4_sync(var, var, p4sync_flags);Fi[[	@åiI"å        def function(arglist)
          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@åiI"•        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@åi!I"•        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[@≥I";# Increments the given revision number and returns it.;FI"def function(arglist);FI"(var.to_i + 1);FI"end;FI" ;Fi[[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/bzr.rb;TiAI"¸          var = scm("revno", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        ;Fi[	@åi8I"“          var = scm(authentication, :changes, "-s submitted", "-m 1", "//#{p4client}/...#{rev_no(revision)}")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[	@i?I"ò          end
          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[@≥I"attr_accessor(:source);FI" ;FI"def function(arglist);FI"@var = var;FI"@var = var;Fi[[	@ƒiI"›    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@…iI"‹    include(MatchPlatform)
    
    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = []
      @var = var;Fi[	@~
iI"Œ    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[@≥@`@@I" var = remote_path_for(@var);FI"connection do |arglist|;Fi[[	@Vi7I"7          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[	@ti+I"A          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("mkdir -p '#{remote_path}'")
          files_to_transfer_for(@var) do |arglist|;Fi[	@Yi)I"7          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[@≥@+@,@ @ @ i[[	@Åi˛I"=      def function(arglist)
        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[	I"-data//twitter_proj/twitter/api/tweets.rb;Ti¸I">          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>]
      def function(arglist);Fi[	@-iI"ˆ  module API
    module Utils
      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[@≥@+@,@–I" ;FI"def function(arglist);Fi[[	@ƒiOI"˛        var.concat(["--database", "#{configuration["database"]}"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("database" => (nil))
      end;Fi[	@©iEI"        set_psql_env
        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["encoding"] or DEFAULT_ENCODING)
      end;Fi[	@7iSI"    def function(arglist)
      to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("#{transport} #{operation} #{from} -> #{to}") if logger
      @var = sessions.map do |arglist|;Fi[@3I"svar = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));FI"end;FI"out((var + ">>"));FI"out("endobj");FI"end;Fi[[	@õi3I"Q            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[	@ûi<I"Q            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[	@°i"I"Q            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[I"var = [];FI"5var = ((var % var) == 0) ? (var) : ((var + var));FI"2var.step(var, var) { |arglist| (var << var) };FI"return var;FI"end;FI" ;Fi[[	@&i!I"c        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0);Fi[	@)iI"e        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields];Fi[	@iYI"r        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 };Fi[@≥@+@,@ÈI"var = @var;F@;i[[	@õiÏI"      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[	@ûiıI"      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[	@°i€I"      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[@≥@+@,@ÈI"# do nothing;FI"end;Fi[[	@ÔibI"À            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@…iDI"œ    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@™iI"‰            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[@˚I"3# Creates a new instance of the storage object;FI"def function(arglist);FI"super(var, var);FI"@var ||= 22;FI"@var ||= "backups";Fi[[	@iI"/      # Path to store backups to
      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@tiI"B      # Server IP Address and SCP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "");Fi[	@YiI"C      # Server IP Address and SFTP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "");Fi[@≥@¥I"var = max_value;FI"var = min_value;F@!@"i[[	@&iI"+      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@)iI"      end
      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@iPI"^        var = (((@var[:fields][0].length / 2) * font_size) * 0.6)
        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[I"+#     include ActiveModel::Validations;FI"#;F@∆@«I"#   end;FI"#;Fi[[	@ÀiªI"Ù    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false;Fi[	@ÀiÃI"ı    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[	@ÀiÛI"ˆ    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[I"#       end;FI"#;FI"#       event :park do;FI",#         transition :idling => :parked;FI"#       end;FI"#     end;Fi[[	@∆iDI"T    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do;Fi[	@∆ivI"X    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do;Fi[	@ri°I"    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end
    #   ;Fi[@\@aI"end;FI" ;F@I"I# This should be optimized in the future potentially not to load all;Fi[[	@iiI"w        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@niI"w        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@siI"w        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[I"nil;FI"end;FI"end;FI"end;FI"end;FI"end;Fi[[	@ii*I"˛          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion;Fi[	@UiI"á            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@Üi≤I"e            nil
          end
        else
          nil
        end
      end
    end
  end
end;Fi[I"O# * <tt>:if</tt> - Specifies a method, proc or string to call to determine;FI"M#   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;FI"O#   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;FI"O#   proc or string should return or evaluate to a +true+ or +false+ value.;FI"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;FI"^#   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[[	@Ài)I"m      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@ÀicI"m      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	I"Ddata//activerecord_proj/active_record/validations/associated.rb;Ti)I"P      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[@°!@¢!@£!@§!@•!I"L#   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[[	@Ài*I"-      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@ÀidI"-      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@¨!i*I"      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[@¢!@£!@§!@•!@Ø!I"P#   method, proc or string should return or evaluate to a +true+ or +false+;Fi[[	@Ài+I"      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@ÀieI"      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@¨!i+I"Ÿ      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[@£!@§!@•!@Ø!@∏!I"#   value.;Fi[[	@Ài,I"˛      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var);Fi[	@ÀifI"‹      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!;Fi[	@¨!i,I"˝      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var));Fi[I"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;F@•!@Ø!@∏!I"#   value.;FI"def function(arglist);Fi[[	@Ài-I"∑      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var)
      end;Fi[	@ÀigI"©      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!
        if var.key?(:on) then;Fi[	@¨!i-I"∂      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var))
      end;Fi[@≥@¥I"@var[:fields];FI"end;FI" ;FI"def function(arglist);Fi[[	@&iI"∂      end
      
      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value;Fi[	@)i#I"◊        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        (var / -2.0)
      end;Fi[	@iFI"ﬁ        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super
        var = (((@var[:fields][0].length / 2) * font_size) * 0.6);Fi[@@@@@I"def function(arglist);Ti[[	@#i‡I"u      #   person.pets.count # => 3
      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.create(var, &var)
      end;Ti[	@#i}I"e      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var)
      end;Ti[	@#i±I"£      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length
      end;Ti[@I";#   #       #<Pet id: 4, name: "Benny", person_id: 1>,;TI";#   #       #<Pet id: 5, name: "Brain", person_id: 1>,;TI":#   #       #<Pet id: 6, name: "Boss",  person_id: 1>;TI"#   #    ];TI"#;Ti[[	@#iEI"{      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4")
      #   # => #<Pet id: 4, name: "Benny", person_id: 1>;Ti[	@#i`I"F      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [;Ti[	@#igI"b      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')])
      #;Ti[I"#   #    ];FI"#;T@©I"#   # => [;T@´@¨i[[	@#iBI"€      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#icI"€      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#i|I"€      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[I"@var = nil;FI"@var = nil;FI"@var = nil;FI"@var = nil;FI"@var = nil;FI"@var = nil;Fi[[	I":data//activerecord_proj/active_record/model_schema.rb;TiI"*        connection.clear_cache!
        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@
"iI";        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var;Fi[	@
"iI"+        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var
        @var = nil;Fi[@"I"end;FI" ;FI"private;FI" ;FI"def function(arglist);Fi[[	I"4data//activerecord_proj/active_record/result.rb;Ti2I"˛    def function(arglist)
      @var = columns.dup
      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist)
      @var ||= (var = @var.map { |arglist| var.dup.freeze }
      @var.map { |arglist| Hash[var.zip(var)] });Fi[	@ÕimI"∫      def function(arglist)
        @var = var
        yield
        @var = nil
      end
      
      private
      
      def function(arglist)
        (@var.failed? or @var)
      end;Fi[	@iÉI"±      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist)
        if @var then
          @var = @var.call;Fi[I"@var = true;FI"end;FI" ;FI"def function(arglist);FI"@var = false;FI"end;Fi[[	@ti5I"Ø      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@tiWI"π      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@3	i:I"π      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[@:I"var = @var;FI"var = @var["cw"];F@$@∞@±i[[	@õiYI"!  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[	@ûiNI"!  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[	@°iHI"!  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[@:@-"I"if (var > 0) then;FI"@var = 0;FI"out("0 Tw");FI"end;Fi[[	@§iÓI"—  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("0 Tw")
      end
      self.AddPage(@var)
      @var = var;Fi[	@îiÃI"    var = @var
    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var;Fi[	@îiKI"    var = @var
    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var;Fi[@:I"var = @var["cw"];F@$@∞@±I"var = var.length;Fi[[	@õiZI"'  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@ûiOI"'  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@°iII"'  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[@≥@¥@@@@–i[[	@õi<I"      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[	@ûiEI"      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[	@°i+I"      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[@:I"if (var > 0) then;FI"@var = 0;FI"out("0 Tw");FI"end;FI"AddPage(@var);Fi[[	@îiÕI"    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[	@îiI"[      var = 1 if (var >= 1)
      if ((var + ((var["h"] * var) / (@var * @var))) > @var) and (@var.! and AcceptPageBreak) then
        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("0 Tw")
          end
          AddPage(@var)
          if (var > 0) then
            @var = var;Fi[	@îiLI"    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[@≥@¥@Ï@Ì@Ó@Ôi[[	@õiI"π    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[	@ûiI"π    var = (@var.length + 1)
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[	@°iI"π    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[@≥@¥@ﬂI"end;FI"end;FI"end;Fi[[	@RiI"Ú      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@XiI"Ú      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@[iI"◊      def self.new(arglist)
        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[@@@ü@†I"#   #    ];TI"#;Ti[[	@#iøI"~      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>;Ti[	@#i˜I"Ü      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=1;Ti[	@#i/I"p      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [;Ti[@≥@¥@ﬂI"var;FI"end;FI" ;Fi[[	@ii,I"Ï        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@ii1I"Ï        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@ii6I"€        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted
      # reduce 56 omitted;Fi[@F@Ù@ı@YI"#   person.pets;TI"#   # => [;Ti[[	@#iêI"=      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#iI"i      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#i I"y      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@@@I"#   #    ];TI"#;T@©i[[	@#i?I"ñ      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#i`I"ñ      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@#iyI"ñ      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[@@I"#   #    ];TI"#;T@©I"#   # => [;Ti[[	@#i@I"±      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#iaI"±      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@#izI"±      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@I"#   #    ];TI"#;T@©I"#   # => [;T@´i[[	@#iAI"€      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#ibI"€      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@#i{I"€      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@≥@¥@’I"var;FI"end;FI" ;Fi[[	@ii◊I"˛        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@ii‹I"›        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@ii·I"—        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted
      # reduce 42 omitted;Fi[@©I"#   # => [;T@´@¨@≠I"#   #    ];Ti[[	@#iDI"Ö      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0;Ti[	@#ieI"      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@#i~I"      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[I"?#   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];TI"#;T@úI"#   person.pets;TI"#   # => [;T@üi[[	@#iºI"b      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#iÙI"b      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@#i,I"c      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@úI"#   person.pets;TI"#   # => [;T@ü@†I"#   #    ];Ti[[	@#iæI"g      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@#iˆI"g      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@#i.I"ä      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3));Ti[@≥@¥@∂@∑I"super(var);FI"	else;Fi[[	@aikI"?    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@aitI"      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@ai}I"      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[@≥@¥@´I"end;FI" ;FI"def function(arglist);Fi[[	@Æi:I"˚  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then
      return Notifications::CommentOnPost;Fi[	@üi-I"¥  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end;Fi[	@≥i2I"≈  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid
  end;Fi[@≥@¥I""";FI"end;FI" ;FI"def function(arglist);Fi[[	@ói=I"~  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end;Fi[	@üi
I"î    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end;Fi[	@üiI"â    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end;Fi[@≥@¥I"broadcast(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@IiI"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@Ii%I"Ë      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@IijI"Ë      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[@I"while (var < var) do;FI"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);FI"if (var < 128) then;FI"/var = (var + var[var.chr]) if var[var.chr];FI"var = (var + 1);Fi[[	@õiBI"&    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[	@ûi2I"9    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then;Fi[	@°i1I"&    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[@I"var = @var["cw"];FI"var = var.length;FI"var = 0;F@n@#i[[	@õi?I"	  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@ûi/I"	  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@°i.I"	  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[@≥@¥I"var = @var;F@;I"newobj;F@=i[[	@õiÓI"ﬂ  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@ûi˜I"ﬂ  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@°i›I"ﬂ  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[@≥@¥@%#I"var = @var;FI"var = @var["cw"];F@$i[[	@õiWI"      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@ûiLI"      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@°iFI"      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[@≥@¥I"@var.accept_hook?(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@
iBI"Ó      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init
        var = @var.index(var);Fi[	@‡i I"≥        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags
      end;Fi[	@‡iÇI"…            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end;Fi[I"@var.each do |arglist|;FI"newobj;F@=I"out("endobj");FI"end;FI" @var.each_pair do |arglist|;Fi[[	@õiÒI"  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@ûi˙I"  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@°i‡I"  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[I"C# +binds+ as the bind substitutes. +name+ is logged along with;FI"$# the executed +sql+ statement.;FI"def function(arglist);FI"exec_query(var, var, var);FI"end;FI" ;Fi[[	@=iII"Ø      end
      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@=iPI"Ø      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@=iWI"f      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Returns the last auto-generated ID from the affected table.
      #;Fi[I"# == Examples;FI"#;FI"#   class Vehicle;F@ﬂ@µI"#     end;Fi[[	@∫iI"    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@∫i'I"#    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@∫iBI"     # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[@ÔI"end;FI"end;FI"var;FI"end;FI" ;Fi[[	@iiÚI"Í            var = ["2", "n", "+", "1"]
            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then;Fi[	@ê iI"ø          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8(arglist)
      return var if var.nil?;Fi[	@ê iGI"           rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8_by_setting(arglist)
      return var if var.nil?;Fi[@Ô@I"var = (var + 1);FI"$var = var if var and (var == 2);FI"	next;FI"end;Fi[[	@õizI"        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[	@ûioI"%        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@°iiI"        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[@≥@¥I"	name;FI"end;FI" ;FI"def function(arglist);Fi[[	I")data//diaspora_proj/models/aspect.rb;TiI"Ã  attr_accessible(:name, :contacts_visible, :order_id)
  
  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var
    when Post then;Fi[	I"Idata//redmine_proj/plugins/awesome_nested_set/spec/support/models.rb;Ti$I"Œ  def function(arglist)
    @@var
  end
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[	I"Ldata//redmine_proj/plugins/awesome_nested_set/test/fixtures/category.rb;TiI"ﬂclass Category < ActiveRecord::Base
  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[@Ô@I"var = 0;FI"var = (var + 1);F@ñI"	else;Fi[[	@§iTI"        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == " "[0]) then
          var = var;Fi[	@§iqI"Î            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1)
        end;Fi[	@îilI"’          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1)
      end;Fi[@≥@¥I"(@var or @var);FI"end;FI" ;FI"def function(arglist);Fi[[	I"-data//bundler_proj/bundler/source/git.rb;Ti∆I"∆        end
        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        options["revision"]
      end;Fi[	@‡iÜI"ﬁ        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end;Fi[	@|iI"ñ  module Parser
    class GherkinBuilder
      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("\n")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, [])
        @var.gherkin_statement(var);Fi[@¥I"	else;F@∫I"end;FI"end;FI" ;Fi[[	@aioI"˝  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "");Fi[	@aixI"˝  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "");Fi[	@ai|I"  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["month", "day"].all? { |arglist| var[var].present? } then;Fi[@≥@¥I"var = 0;FI"var = @var["cw"];FI"var = var.length;FI"var = 0;Fi[[	@õi=I"‹      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@ûi-I"‹      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@°i,I"‹      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[I"super(var, var, var, var);FI"end;FI"end;FI" ;FI"def function(arglist);FI"var = @var["cw"];Fi[[	@õi®I"˛    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@ûi£I"     if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@°ióI"˛    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[I"rescue;FI"var = (var + $!.success);FI"end;FI"var = var;FI"end;FI"end;Fi[[	@ê iI"Ô            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@ê iDI"Ô            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@ê iÇI"Î            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end
  end;Fi[@QI"end;FI" ;F@T@UI"end;Fi[[	@çi#I"       end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[	@´i∂I"        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist);Fi[	@ïi5I"       end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[@UI"end;FI" ;F@`@aI"end;Fi[[	@çi'I"@      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      
      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE;Fi[	@´i∫I"	        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end
    end;Fi[	@ïi9I"˚      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      
      #:nodoc:;Fi[@≥@¥@UI"end;FI" ;F@`i[[	@çi%I"8      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@´i∏I"N        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end;Fi[	@ïi7I"8      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end;Fi[I"rescue LoadError;FI"
false;FI"end;FI"end;FI"end;FI"end;Fi[[	@ÔiãI"î        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@Úi~I"î        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@ΩiVI"∫      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist)
  puts("#{exception.backtrace.first}");Fi[@≈I"	else;FI"var = (var + 1000);FI"var = (var + 2);FI"end;FI"end;Fi[[	@õiGI"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[	@ûi;I"Ò      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000);Fi[	@°i6I"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[@≈@∆@«@»I"var = (var + 1);F@z#i[[	@õixI"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@ûimI"      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@°igI"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[@≥@¥@QI"end;FI" ;F@Ti[[	@çi!I"           # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@´i¥I"Z          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end;Fi[	@ïi3I"      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end;Fi[I"var = "";F@ê@ë@íI"end;FI"end;Fi[[	@õihI"        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@ûi]I"        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@°iWI"        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[@.$I"
begin;F@â @ä @ã @å i[[	@ê iI"~          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@ê i=I"z          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@ê i{I"z          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[I"var = case var;F@&I""Success";F@ÜI""Warning";FI"when :failure then;Fi[[	@≥	i0I"!      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[	@º	i.I"!      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[	@¬	i,I"!      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[@≥@¥I"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@@iI"       def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var))
      end;Fi[	@çi3I"Ë      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true)
      end;Fi[	@ iI"é    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end;Fi[@≥@¥I"@var.clear;FI"end;FI" ;FI"def function(arglist);Fi[[	@∂i√I"»      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@∂i«I"∏      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@∂iÀI"¿      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var
          self;Fi[I"if @var.compressor then;FI"/@var.compressor.compress_with do |arglist|;FI"(var << var);FI"(var << var);FI"end;FI"end;Fi[[	@ë
iII"      var = "tar"
      var = Pipeline.new
      (var << ("#{utility(:tar)} #{tar_args} -cPf - " + "#{paths_to_exclude} #{paths_to_package}"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "cat > '#{File.join(archive_path, "#{name}.#{archive_ext}")}'")
      var.run;Fi[	@ó
i;I"I        var = Pipeline.new
        var = "sql"
        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, dump_filename)}.#{dump_ext}'")
        var.run;Fi[	I"4data//backup_proj/backup/database/postgresql.rb;Ti;I"=        var = Pipeline.new
        var = "sql"
        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, name)}.#{dump_ext}'")
        var.run;Fi[@≥@¥@¬@√I"end;FI"end;Fi[[	@µi3I"£          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@Gi>I"v    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@1idI"∑      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[@≥@¥@‡@·I"end;FI"end;Fi[[	@ª
iÄI"ö        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	I"%data//haml_proj/haml/template.rb;TiI"Ë  
  module Util
    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end
Haml::Template.options[:ugly] = Rails.env.development?.!
Haml::Template.options[:escape_html] = true;Fi[	@üiI"˜    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|
  (var.nil? or (Paperclip::Attachment.===(var) and var.present?.!));Fi[I""next if send(var).to_s.empty?;FI"$"--#{option}='#{send(option)}'";FI"end.compact.join(" ");FI"end;FI" ;FI"##;Fi[[	@î
iâI"Ç      # to perform the database dumping process
      def function(arglist)
        ["username", "password"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds the MongoDB connectivity options syntax to connect the user
      # to perform the database dumping process;Fi[	@î
iìI"R      # to perform the database dumping process
      def function(arglist)
        ["host", "port"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Returns the mongodump syntax for enabling ipv6
      def function(arglist);Fi[	@ó
igI"k      # to perform the database dumping process
      def function(arglist)
        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds a MySQL compatible string for the additional options
      # specified by the user;Fi[@≥@¥I"
super;F@h I" @var = plugin_name.titleize;FI"$@var = "plugins/#{plugin_name}";Fi[[	@k i	I"  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
  end
  ;Fi[	@n iI"G  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = controller.camelize
  end;Fi[	@q iI"{  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = model.camelize
    @var = @var.tableize;Fi[@≥@¥@ú@ùI"end;FI" ;Fi[[	@äi	I"„  module ConnectionAdapters
    class Transaction
      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    
    class ClosedTransaction < Transaction
      def function(arglist);Fi[	I"4data//activerecord_proj/active_record/errors.rb;TiaI"›  
  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  
  class UnknownPrimaryKey < ActiveRecordError
    attr_reader(:model);Fi[	I"9data//devise_proj/devise/controllers/rememberable.rb;TiI"        include(Devise::Controllers::Rememberable)
        
        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      
      # Remembers the given resource by setting up a cookie
      def function(arglist);Fi[@≥I"protected;FI" ;F@c@d@Gi[[	@giI"È        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@miI"ˇ      def self.matching_ancestors(arglist)
        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@piI"„        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[@≥@ŒI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;FI"$# @example Mongoize the object.;Fi[[	@:iI"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11")
        #;Fi[	@îi¶I"8        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ])
        #;Fi[	@?i+I"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #;Fi[@'@*!I"out("endobj");FI"end;FI"end;FI"end;Fi[[	@õi5I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[	@ûi>I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[	@°i$I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[@'I"var = var["file"];FI"if var then;F@(!I"end;F@*!i[[	@õi1I"™          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[	@ûi:I"™          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[	@°i I"™          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[@'I"out(">>");FI"out("endobj");FI"#if var["type"].!=("core") then;FI"newobj;FI"var = var["cw"];Fi[[	@õi#I"/              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[	@ûi,I"/              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[	@°iI"/              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[@'@‹$I"var = fopen(var, "rb");FI"putstream(fread(var, var));FI"fclose(var);FI"out("endobj");Fi[[	@õiI"3      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@ûi
I"3      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@°iI"1      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[@'I"if var.!=(var) then;FI"RCell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var);FI"end;FI"end;FI" ;Fi[[	@õiÁI"Œ      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[	@ûiI"◊        var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[	@°i÷I"Œ      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[@'I"<var = (var + "B") if var and var.to_s.index("B").nil?.!;FI"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;FI"@var = @var;FI"	else;Fi[[	@õiïI"      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@ûiêI"#        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@°iÑI"      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[@'@é@è@êI"var = (var + 1);FI"$var = var if var and (var == 2);Fi[[	@õiåI"<        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[	@ûiÜI".        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var);Fi[	@°i{I"<        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[@'I"!return ((var * @var) / 1000);FI"end;FI" ;FI"def function(arglist);FI"&if (@var["type"] == "Type0") then;Fi[[	@õiLI"Í        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@ûiAI"ﬂ          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@°i;I"Í        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[@'I"good_checksum(var);FI"end;FI" ;FI"def function(arglist);FI"var = TestBall.new;Fi[[	I"/data//homebrew_proj/test/test_checksums.rb;TiI"    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("61aa838a9e4050d1876a295a9e62cbe6");Fi[	@-%i(I"/    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e");Fi[	@-%i8I"c    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("dcbf5f44743b74add648c7e35e414076632fa3b24463d68d1f6afc5be77024f8");Fi[@'I" @var.each_pair do |arglist|;FI"newobj;FI"@var[var]["n"] = @var;FI"out("<</Type /Font");FI"%if (var["type"] == "Type0") then;Fi[[	@õiI"˙      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[	@ûiI"˙      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[	@°iˆI"˙      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[@&I""Success";F@ÜI""Warning";F@E$I""Failure";Fi[[	@≥	i1I"Î      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[	@º	i/I"Î      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[	@¬	i-I"Î      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[I""Success";F@ÜI""Warning";F@E$I""Failure";FI"	else;Fi[[	@≥	i2I"Ô      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[	@º	i0I"Ô      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[	@¬	i.I"Ô      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[@ÜI""Warning";F@E$I""Failure";FI"	else;FI"# do nothing;Fi[[	@≥	i3I"        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var);Fi[	@º	i1I"¯        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s]" % var);Fi[	@¬	i/I"/        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger}) (@ #{@model.time})" % var);Fi[I""Warning";F@E$I""Failure";FI"	else;FI"# do nothing;FI"end;Fi[[	@≥	i4I"        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var)
        send_message(var);Fi[	@º	i2I"˚        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s]" % var)
        send_message(var);Fi[	@¬	i0I"2        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger}) (@ #{@model.time})" % var)
        send_message(var);Fi[I"@var ||= "backups";FI"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;FI" ;Fi[[	@≈	iI"      def function(arglist)
        super(var, var)
        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage;Fi[	@À	iI""      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage;Fi[	@Œ	iI"      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage;Fi[@a@b@c@d@¸I"var = [];Fi[[	@»	i\I"ª      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from Dropbox."));Fi[	@mi%I"ß      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << "#{storage_name} started removing '#{local_file}'.");Fi[	@ti:I"ª      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from '#{ip}'."));Fi[@b@c@d@¸I"var = [];FI",transferred_files_for(var) do |arglist|;Fi[[	@»	i]I"Ω      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from Dropbox."))
        end;Fi[	@mi&I"©      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << "#{storage_name} started removing '#{local_file}'.")
        end;Fi[	@ti;I"Ω      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from '#{ip}'."))
        end;Fi[@'@4%@5%@6%I"<var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");FI"var = filesize(var);Fi[[	@õiıI"t      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[	@ûi˛I"t      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[	@°i‰I"t      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[I"if (var == 0) then;FI"@var = var;F@°I"	else;F@£I"end;Fi[[	@õiõI"º    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@ûiñI"º    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@°iäI"º    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[I"var = (var - var);F@"@#I",var = (scale_divisions or (var / 10.0));FI":var = (var < 1) ? (1) : (var.round) if scale_integers;FI"var = [];Fi[[	@&iI"¶      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@)iI"¶      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@iTI"¶      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[I"
true);FI"rescue LoadError;FI"
false;FI"end;FI"end;FI"end;Fi[[	@ÔiäI"π        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@Úi}I"π        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@ΩiUI"ù    begin
      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist);Fi[@´I"	else;F@•I"@var = var;F@°I"	else;Fi[[	@õiôI"&    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@ûiîI"&    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@°iàI"&    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[@'I"def function(arglist);F@.@/I"end;FI"
super;Fi[[	@•ifI"w      version("3.0.x") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[	@®iNI"o      version("0.9.x") do |arglist|
        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[	@3iI"|        end
        def function(arglist)
          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[@'I"	true;FI"end;FI"end;FI"end;FI"end;Fi[[	I",data//backup_proj/backup/cli/utility.rb;Ti‡I"Œ      def function(arglist)
        if File.exist?(var) then
          return yes?("A file already exists at '#{path}'. Do you want to overwrite? [y/n]")
        end
        true
      end
    end
  end
end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/and.rb;TiI"≤            var = var[var]
            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	@Œi%I"ô            else
              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end
end;Fi[@´I"@var = (@var + var);FI"!var = ((@var - @var) - @var);FI"/var = (((var - (2 * @var)) * 1000) / @var);FI"var = (var + 1);FI"var = (var + 1);Fi[[	@õiÕI"V      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@°iºI"V      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@§ißI"D      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[I"
retry;FI"rescue;F@”#I"end;FI"var = var;FI"end;Fi[[	@ê iI"          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@ê iCI"          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@ê iÅI"          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end;Fi[I"var.unshift(var);FI"var = nil;FI"	else;F@ú@ùI"var = nil;Fi[[	@Xi¯I"È    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@XiI"˝      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@XiI"È    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[@(I"var = 0;F@n@#@#@#i[[	@õiAI"#  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@ûi1I"#  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@°i0I"#  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[@(I">var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");FI"var = 0;FI"if var then;F@ÿI"var = "LTRB";Fi[[	@õi_I">    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@ûiTI">    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@°iNI">    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[@'I"	@var;FI"end;FI"end;FI"end;FI"end;Fi[[	@ø	iVI"⁄        @var = {}
        [:token, :user, :message, :title, :priority, :device].each do |arglist|
          @var.merge!(var => (self.instance_variable_get("@#{k}")))
        end
        @var
      end
    end
  end
end;Fi[	I"1data//capistrano_proj/capistrano/cli/help.rb;TiI"~          else
            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end
end;Fi[	@!iVI"p        var = (var + TimeEntryActivityCustomField.all)
        var.select { |arglist| ["list", "bool"].include?(var.field_format) }.each do |arglist|
          @var["cf_#{cf.id}"] = { :sql => ("#{cf.join_alias}.value"), :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[@„ @‰ @Â @Ê @Á I"end;Fi[[	@åiI"ª          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@åiI"‘          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@åi"I"◊          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.;Fi[@‰ @Â @Ê @Á I"end;FI" ;Fi[[	@åiI"˙        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@åiI"˙        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@åi#I"À        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.
        def function(arglist);Fi[I"@var = (@var + var);F@Ë%@È%@Í%@Î%I"	next;Fi[[	@õiŒI"v        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@°iΩI"v        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@§i®I"T        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var);Fi[I"if color_stop?(var) then;FI"var.unshift(var);FI"var = nil;FI"	else;F@ú@ùi[[	@Xi˜I"Á    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@XiI"ˇ        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@XiI"Á    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[@ú@ùI"var = nil;FI"end;FI"end;FI"'var = nil if var and var.to_bool.!;Fi[[	@Xi˚I"        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var);Fi[	@XiI"4        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then
        var = var.first.value;Fi[	@XiI"Y        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first)
      LinearGradient.new(var, send(:color_stops, *var));Fi[I"if var.to_bool then;FI".Sass::Script::String.new(clean_path(var));FI"	else;FI"clean_url(var);FI"end;FI"end;Fi[[	@∞i&I"”        end
      end
      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@∞i?I"È        Compass.configuration.http_fonts_path
      end
      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@∞irI"Î        end
      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[@f&I"	else;FI"clean_url(var);FI"end;FI"end;FI"end;Fi[[	@∞i'I"ÿ      end
      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl;Fi[	@∞i@I"Õ      end
      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl;Fi[	@∞isI"˙      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl;Fi[@  I" ;F@Ã I"@var ||= var;FI"end;FI" ;Fi[[	@`iI"        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@
iI"        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var;Fi[	@iI"›        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false;Fi[@4%I"newobj;F@6%@í%@ì%I"*Error("Font file not found") if var.!;Fi[[	@õiˆI"û      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[	@ûiˇI"û      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[	@°iÂI"û      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[@4%@å&@6%@7%@8%I"putType0(var);Fi[[	@õiI"Û      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[	@ûiI"Û      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[	@°i˜I"Û      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[@'@åI""";FI"end;FI"end;FI" ;Fi[[	@viI"ˆ            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format];Fi[	@vi5I"            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do;Fi[	@virI"Î            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end
      
      if Object.const_defined?(:Magick) then
        # Generates a gantt image;Fi[@C@i@j@F@ûI"end;Fi[[	@Ii@I"ÿ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@IidI"ÿ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@IitI"      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.;Fi[I"@var.text!(" ");FI"$@var.span(var, :class => "val");FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@„iàI"5        @var = true
        @var.h3(:id => ("background_#{@scenario_number}")) do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = (@var + 1)
        @var = false;Fi[	@„iûI":        @var = false
        @var.h3(:id => ("scenario_#{@scenario_number}")) do |arglist|
          @var.span((var + ":"), :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = 0
        (@var << "<table>");Fi[	@„i∏I"      def function(arglist)
        @var.h4 do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        (@var << "<ol>")
      end;Fi[I"if (var > var) then;FI"*if ((var == -1) or (var == var)) then;FI"if (@var > @var) then;FI"@var = @var;F@Á%@Ë%i[[	@õi I"ç      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[	@ûi“I"G          var = var
        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var);Fi[	@°iπI"ç      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[I"var.json do |arglist|;FI"8render(:json => (@var.stream_posts.map do |arglist|;FI"ILastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));FI"
end));FI"end;FI"end;Fi[[	@IigI"G    end
    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	I":data//diaspora_proj/controllers/streams_controller.rb;Ti?I"e    respond_with do |arglist|
      var.html { |arglist| render("layouts/main_stream") }
      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	@Ui'I"à    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[@œ&@–&I"
end));FI"end;FI"end;FI"end;Fi[[	@IihI"é    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display;Fi[	@ÿ&i@I"_      var.html { |arglist| render("layouts/main_stream") }
      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist);Fi[	@Ui(I"b    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private;Fi[@–&I"
end));FI"end;FI"end;FI"end;FI" ;Fi[[	@IiiI"†      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display
  # it next to the avatar image in a nice box;Fi[	@ÿ&iAI"d      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist)
    session[:a_ids] = params[:a_ids] if params[:a_ids].present?;Fi[	@Ui)I"˙    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  ;Fi[@ßI"end;FI" ;FI"def function(arglist);F@´I"end;Fi[[	@Æi8I"›  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@üi+I"≠  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@≥i0I"ﬂ  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[@∂@∑I"super(var);FI"	else;F@∫I"end;Fi[[	@aimI"   end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@aivI"   end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@aiI"   end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[@∑I"super(var);FI"	else;F@∫I"end;FI"end;Fi[[	@ainI"‹  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@aiwI"‹  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@ai{I"‹  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[I"(HOMEBREW_REPOSITORY.cd do |arglist|;FI"var = UpdaterMock.new;FI"1var.in_repo_expect("git checkout -q master");FI"Evar.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd");FI"9var.in_repo_expect("git config core.autocrlf false");FI"Zvar.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master");Fi[[	I"-data//homebrew_proj/test/test_updater.rb;Ti1I"  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef");Fi[	@!'iCI"K  
  def function(arglist)
    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var);Fi[	@!'iWI"H  
  def function(arglist)
    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var);Fi[@'@å@G@H@I@Ji[[	@õiI"û          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[	@ûiI"û          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[	@°iI"û          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[@'@å@ÏI"end;FI"end;FI" ;Fi[[	@@iI"         var.mobile do |arglist|
          render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id]);Fi[	@FiI"2        var.json do |arglist|
          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id);Fi[	@LiHI"ˆ        end
      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first;Fi[I"good_checksum(var);FI"end;FI" ;FI"def function(arglist);FI"var = TestBall.new;FI"*var.stable.instance_eval do |arglist|;Fi[[	@-%iI"    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("61aa838a9e4050d1876a295a9e62cbe6")
    end;Fi[	@-%i)I"     var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e")
    end;Fi[	@-%i9I"T    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("dcbf5f44743b74add648c7e35e414076632fa3b24463d68d1f6afc5be77024f8")
    end;Fi[I""assert_nil(var.head.checksum);FI"Bassert_equal("https://github.com/mxcl/homebrew.git", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);FI"3assert_instance_of(HeadSoftwareSpec, var.head);FI"end;Fi[[	I"-data//homebrew_proj/test/test_formula.rb;TiπI"§    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@Q'i»I"§    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@Q'i◊I"§    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[I",assert_equal(var.head, var.active_spec);FI".assert_version_equal("HEAD", var.version);FI""assert_nil(var.head.checksum);F@J'@K'@L'i[[	@Q'i∑I"ø    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@Q'i∆I"ø    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@Q'i’I"ø    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[@Y'@Z'@J'@K'@L'@M'i[[	@Q'i∏I"ß    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@Q'i«I"ß    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@Q'i÷I"ß    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[I"Bassert_equal("https://github.com/mxcl/homebrew.git", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);F@M'I"end;FI" ;Fi[[	@Q'i∫I"µ    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@Q'i…I"µ    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@Q'iÿI"µ    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new;Fi[@l'@m'@M'I"end;FI" ;FI"def function(arglist);Fi[[	@Q'iªI"¶    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@Q'i I"¶    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@Q'iŸI"®    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new
    assert_not_nil(var.stable);Fi[I"assert_nil(var.bottle);FI"assert_nil(var.devel);FI",assert_equal(var.head, var.active_spec);FI".assert_version_equal("HEAD", var.version);F@Z'@J'i[[	@Q'iµI"∆    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@Q'iƒI"Œ    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@Q'i”I"Œ    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[I"assert_not_nil(var.head);FI"assert_nil(var.stable);FI"assert_nil(var.bottle);F@Ñ'@Ö'@Ü'i[[	@Q'i≥I"h  
  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[	@Q'i¬I"p  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[	@Q'i—I"p  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[@ê'@ë'@Ñ'@Ö'@Ü'@Z'i[[	@Q'i¥I"¢  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@Q'i√I"™  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@Q'i“I"™  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[@Ñ'@Ö'@Ü'@Z'@J'@K'i[[	@Q'i∂I"÷    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@Q'i≈I"÷    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@Q'i‘I"÷    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[I")var.extend(StringInreplaceExtension);FI"(var.change_make_var!("FLAG", "def");FI"8assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var);FI"end;FI" ;FI"def function(arglist);Fi[[	I"/data//homebrew_proj/test/test_inreplace.rb;Ti
I"lclass InreplaceTest < Test::Unit::TestCase
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension);Fi[	@≤'iI"=  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "FLAG = \nmv file_a file_b"
    var.extend(StringInreplaceExtension);Fi[	@≤'i&I"G  
  def function(arglist)
    var = "OTHER=def\nFLAG=abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2 = def"
    var.extend(StringInreplaceExtension);Fi[@'@(I"out(">>");FI"out("endobj");F@ﬁ$I"newobj;Fi[[	@õi"I"¯            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[	@ûi+I"¯            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[	@°iI"¯            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[@'@(I"if var.!=(var) then;F@ˆ$I"end;FI"end;Fi[[	@õiÊI"„        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[	@ûiÔI"ﬂ      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[	@°i’I"„        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[@°@¢@£@§@}I"assert(var.mach_o_bundle?);Fi[[	@ßiGI"=    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var))
  end;Fi[	@ßiUI"3    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var))
  end;Fi[	@ßicI":    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var))
  end;Fi[@'@(@%@%I"if (var == 1) then;FI"@var = @var;Fi[[	@õiîI"/        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@ûièI"      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@°iÉI"/        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[@'@(@%I"end;FI" ;FI"def function(arglist);Fi[[	@õiKI"Ï      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[	@ûi@I"Û          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var);Fi[	@°i:I"Ï      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[@@I"end;FI"end;FI"end;FI" ;Fi[[	@"i$I"M    shutup do |arglist|
      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@"i.I"O    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@"i8I"K    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[@I"end;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@"i%I"r      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|;Fi[	@"i/I"p      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|;Fi[	@"i9I"l      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|;Fi[@'@'@'@'@'I"Evar.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[[	@!'i2I"  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef")
      var.pull!;Fi[	@!'iDI"X  def function(arglist)
    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!;Fi[	@!'iXI"U  def function(arglist)
    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!;Fi[@'@(I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@ûiI"ı              (var.width <=> var.width)
            else
              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist)
          send("#{style}_fit")
          @var;Fi[	I"9data//paperclip_proj/paperclip/storage/filesystem.rb;Ti6I"             # do nothing
          rescue SystemCallError => var
            log("There was an unexpected error while deleting directories: #{e.class}")
          end
        end
        @var = []
      end
      
      def function(arglist)
        FileUtils.cp(path(var), var)
      end;Fi[	@ãiÍI"-            s3_bucket.objects[var.sub(/^\//, "")].delete)
          rescue AWS::Errors::Base => var
            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist)
        begin
          (log("copying #{path(style)} to local file #{local_dest_path}");Fi[I"Esha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);FI">sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion);FI"Fsha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion);FI"end;FI" ;FI"def function(arglist);Fi[[	@bitI"(  end
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("spectestball")
  end;Fi[	@biI"b  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("allcatsbottlespectestball")
  end;Fi[	@biI">  
  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("revisedbottlespectestball")
  end;Fi[@µ I"#;F@∑@∏I"#;FI"# Returns nothing.;Fi[[	@æiI"¸      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin;Fi[	@¡i I"      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[	@ƒi>I"ı      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[I"if (@var > @var) then;FI"@var = @var;F@Á%@Ë%@È%@Í%i[[	@õiÃI"Å      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@°iªI"Å      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@§i¶I"a      var = (var + GetCharWidth(var, var))
      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[@'@(I"
super;FI"end;FI" ;FI"def function(arglist);Fi[[	@Bi!I"˚          var.flatten.each do |arglist|
            raise_on_type_mismatch(var)
            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested
        var = super;Fi[	@ÇiI"4          if respond_to?(var) and (respond_to?("#{column}=") and self.send(var).nil?) then
            write_attribute(var.to_s, var)
          end
        end
      end
      super
    end
    
    def function(arglist)
      if should_record_timestamps? then
        var = current_time_from_proper_timezone;Fi[	@Çi(I"?          var = var.to_s
          next if attribute_changed?(var)
          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist)
      self.record_timestamps and (partial_writes?.! or (changed? or attributes.keys.&(self.class.serialized_attributes.keys).present?))
    end;Fi[@'@(@)I"out(">>");FI"out("endobj");F@ﬁ$i[[	@õi!I"'              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[	@ûi*I"'              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[	@°iI"'              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[@'@(@)I"	self;FI"end;FI" ;Fi[[	@µi<I"ï        else
          Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.parent.author.diaspora_handle} payload_type=#{self.class} parent_id=#{self.parent.id}")
          return
        end
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.parent_author_signature, self.parent.author);Fi[	@]i‰I"}                set_relation(var, get_relation(var, var).substitute(var.substitutable))
              else
                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        
        # Defines the setter method that allows you to set documents
        # in this relation by their ids. The defined setter, finds;Fi[	I"-data//nokogiri_proj/nokogiri/css/node.rb;Ti9I"v              var = var.value[0].value.first
              var.value[0].value = ["*"]
              var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["#{match.value[1].value.first}("]), Node.new(:FUNCTION, ["self(", var])])
            end
          end
        end
        self
      end
      
      # Find a node by type using +types+
      def function(arglist);Fi[@'@(@)I"return var;FI"end;FI" ;Fi[[	@„iîI"W              next if var.nil?
              var = var.instance_variable_get("@cell_matrix")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "<span class=\"param\">#{param}</span>" });Fi[	@îiÓ
I"§          (var << 65533)
          var = []
          var = 1
        end
      end
    end
    return var
  end
  
  #
  	# Converts UTF-8 strings to UTF16-BE.<br>;Fi[	@îi/I"Ÿ          (var << var.&(255).chr)
          (var << (var >> 8).chr)
          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  
  # ====================================================
  	#;Fi[@I"end;FI"end;FI"end;FI"end;FI"end;Fi[[	@8iI"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@;i%I"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@DiI"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[@I"var.puts(var);FI"end;FI"end;FI"end;FI"end;Fi[[	@8iI"ª        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@;i$I"ª        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@DiI"ª        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[I"# @since 3.0.0;F@&I"	true;FI"end;FI" ;FI"module ClassMethods;Fi[[	@ÉixI"Î      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.
        #;Fi[	@:iI"¸      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@úi(I"Ó      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #;Fi[I"$#     include Mongoid::Document;FI"#     embedded_in :person;FI"#   end;FI"#;F@µ@∂i[[	@ªi-I"p        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@ªiKI"p        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@ªigI"m        #   end
        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[@'@(@)@*@≥I"private;Fi[[	@Oi7I"≠          redirect_to(getting_started_path)
        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@miI"ﬁ          exec("find", *(ARGV.kegs + ["-not", "-type", "d", "-print"]))
        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@øiI"º              end
            end
          end
        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/;Fi[@0@1@2I"#;F@4I"#;Fi[[	@‚iI"â        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@‚i)I"é        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@‚i?I"à        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[@'@(@)@@OI" ;Fi[[	@=iﬁI"           rescue Exception
            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?;Fi[	@JiI"            var
          else
            raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      
      # Returns whether or not the association should be validated as part of
      # the parent's validation.;Fi[	@æ
iËI"‹          if var =~ /^(\w+)=(.*)$/ then
            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then;Fi[@'@(@)@@ñ@i[[	@õi9I"Û          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[	@ûiBI"Û          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[	@°i(I"Û          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[@'@(@)@@ñI"&if (@var["type"] == "Type0") then;Fi[[	@õi†I"         @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else;Fi[	@ûiõI"Ã        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else;Fi[	@°ièI"         @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else;Fi[@1@2I"#;F@4I"#;FI"# @since 3.0.0;Fi[[	@‚iI"Ñ        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var);Fi[	@‚i*I"ä        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|;Fi[	@‚i@I"≤        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!;Fi[@2I"#;F@4I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@‚iI"Ç        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var)
          validate_options(var, var, var);Fi[	@‚i+I"ä        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|
            unless VALID_OPTIONS.include?(var) then;Fi[	@‚iAI"¶        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!
          var.each_pair do |arglist|;Fi[@'@(@)@@ñI"shutup do |arglist|;Fi[[	@"i&I"_        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[	@"i0I"[        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[	@"i:I"[        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[@'@(@Ê@=@ @Ti[[	@gi@I"E          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@mi9I"E          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@pi=I"E          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[@'@(@Ê@@I"#;Fi[[	@%i#I"k              else
                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true);Fi[	@/iI"à            target.parentize(base)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true);Fi[	@4i$I"7                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true);Fi[@'@(@ÊI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;Fi[[	@ÉiâI"W            var.blank? ? (var) : (var.convert(var))
          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ]);Fi[	@èiI"$        else
          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize;Fi[	@ói}I"          return instance_variable_get("@#{name}")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[@'@(@Ê@ñ@@i[[	@õi:I"          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[	@ûiCI"          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[	@°i)I"          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[@'@(@Ê@ñI"var = @var["cw"];F@-i[[	@õi©I"ı      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@ûi§I"˜      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@°iòI"ı      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[I"3# @param [ Hash ] options The binding options.;FI"#;F@@I"#;F@i[[	@%iI"Â          #   name.person.bind(:continue => true)
          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata;Fi[	@,iI"À          #   person.addresses.bind_one(address)
          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base);Fi[	@,i%I"          # @example Unbind the document.
          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) };Fi[@'@(@Ê@ñI"var = @var;FI"var = @var;Fi[[	@õiUI"˜      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@ûiJI"˘      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@°iDI"˜      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[@'@(@Ê@ñI"var = 0;FI"var = @var["cw"];Fi[[	@õi;I"Æ      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[	@ûi+I"∞      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[	@°i*I"Æ      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[@'@3@=@ @TI"end;Fi[[	@giAI"A        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@mi:I"A        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@pi>I"A        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[@'@3@3 @4 @5 @;i[[	@gi8I"h      # Initializes dynamic states
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@mi1I"q      def function(arglist)
        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@pi5I"Ä      def function(arglist)
        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[@'@3@V @W @X @Y i[[	@] i#I"ã          var = default_error_message_options(var, var, var)
          var.errors.add(var, var, var.merge(var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[	@jiI"ã        if supports_validations? then
          var.errors.add(self.attribute(var), generate_message(var, var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[	@si I"ß      # Adds a validation error to the given object
      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[@'@3@@â!I"# objects from the db.;FI"#;Fi[[	@iiI"ä        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[	@niI"ã        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.
        #   strategy.cascade;Fi[	@siI"ä        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[@'@3I"# Obtain destination path.;FI"#;FI"5# dest - The String path to the destination dir.;FI"#;Fi[[	@¡isI"b    # Returns the Hash representation of this Page.
    def function(arglist)
      self.data.deep_merge("url" => (File.join(@var, self.url)), "content" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.
    def function(arglist);Fi[	@ƒiøI"k    def function(arglist)
      var = { "site" => ({ "related_posts" => (related_posts(var["site"]["posts"])) }), "page" => (self.to_liquid) }.deep_merge(var)
      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.
    def function(arglist);Fi[	@ˇiI"    # Returns source file path.
    def function(arglist)
      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.
    def function(arglist);Fi[@aI"end;FI" ;F@@â!@Q)i[[	@iiI"û        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[	@niI"ü        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.;Fi[	@siI"û        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[@î(I"#   end;FI"#;F@µ@∂@∑i[[	@ªi.I"ö        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then;Fi[	@ªiLI"ù        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var);Fi[	@ªihI"ô        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var);Fi[I"#     relation.push(doc);FI"#   end;FI"#;F@wI"#;FI"# @since 2.1.0;Fi[[	@}i1I"¸      #
      # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@}iPI"ˇ      #
      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@}i©I"        #
        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin;Fi[@€I"var;FI"end;FI" ;F@∞I"Avar = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[[	@ii≈I"      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@ii I"      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@iiœI"      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[@“I"var;FI"end;FI" ;F@÷@ﬂi[[	@ii)I"      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@ii.I"Õ      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@ii3I"Õ      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[@'@3@µ I"#;F@∑@∏i[[	@æiI"    # Returns the contents as a String.
    def function(arglist)
      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@¡iI"      @var = var
      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@ƒi<I"9      if self.categories.empty? then
        self.categories = self.data.pluralized_array("category", "categories")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[I"while (var < var) do;F@#@#@#I"var = (var + 1);FI"	else;Fi[[	@õiCI"2    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[	@ûi3I"I    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500);Fi[	@°i2I"2    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[@d I" ;FI"def function(arglist);FI"
super;F@h @ô$i[[	@k iI"Hclass RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
  end;Fi[	@n iI"D  
  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = controller.camelize;Fi[	@q iI"e  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = model.camelize;Fi[I"0(categories(:child_2).should == var.parent);FI"6(categories(:child_2).id.should == var.parent_id);FI" var.left.should_not(be_nil);FI"!var.right.should_not(be_nil);FI"$Category.valid?.should(be_true);FI"end;Fi[[	I"Rdata//redmine_proj/plugins/awesome_nested_set/spec/awesome_nested_set_spec.rb;TiI"ﬂ  end
  it("assigning_parent_id_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)));Fi[	@∆)i	I"’  end
  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_id_to_nil_on_create") do |arglist|
    var = Category.create!(:name => "New Root", :parent_id => (nil));Fi[	@∆)i5I"Ê  end
  it("creating_child_from_parent") do |arglist|
    var = categories(:child_2).children.create!(:name => "Child")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  # create a new top-level node and move single-node top-level tree inside it.
  # create a new top-level node and move an entire top-level tree inside it.;Fi[I"%categories(:child_2).save(false);FI".assert(Category.left_and_rights_valid?.!);FI"end;FI" ;FI"def function(arglist);FI",assert(Category.left_and_rights_valid?);Fi[[	I"Rdata//redmine_proj/plugins/awesome_nested_set/test/awesome_nested_set_test.rb;TiﬁI"R  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false);Fi[	@’)iÂI"u  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false);Fi[	@’)iÛI"Ñ  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false);Fi[@^@=I"out("endobj");FI"end;F@I#I"newobj;Fi[[	@õiÚI"P  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[	@ûi˚I"P  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[	@°i·I"P  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[@^@6%@í%@ì%@ç&I"out(("<</Length " + var));Fi[[	@õi˜I"i      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[	@ûi I"i      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[	@°iÊI"i      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[@^@6%@7%@8%I"putType0(var);FI"	else;Fi[[	@õi	I"      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[	@ûiI"      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[	@°i¯I"      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[@^@‡$I"var = "[";FI"B32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };FI"out((var + "]"));FI"out("endobj");Fi[[	@õi'I"W        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[	@ûi0I"W        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[	@°iI"W        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[@^I"8var = ("<</Type /FontDescriptor /FontName /" + var);FI"'var["desc"].each_pair do |arglist|;FI"/var = (var + (((" /" + var) + " ") + var));FI"end;F@—$i[[	@õi-I"Ë          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[	@ûi6I"Ë          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[	@°iI"Ë          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[@^@™@´@¨I"öout((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));FI";out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[[	@ûiMI"‚    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 ["
    var["cw"].keys.sort.each do |arglist|;Fi[	@°i3I"Ó    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    if (var["CMap"] == "KSCms-UHC-HW-H") then
      var = "8094 8190 500";Fi[	@îiäI"‚    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 ["
    var["cw"].keys.sort.each do |arglist|;Fi[@'@3@  I" ;F@Ã I"@var ||= var;Fi[[	@`iI"·      
      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@
iI"˜      
      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@iI"÷      
      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[@nI"end;F@I#I"newobj;F@6%@í%i[[	@õiÙI"o    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[	@ûi˝I"o    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[	@°i„I"o    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[@n@&*@I#@'*@6%@7%i[[	@õiI"      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[	@ûiI"      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[	@°iıI"      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[@n@&*I"end;FI"end;FI"end;FI" ;Fi[[	@õi7I"            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@ûi@I"            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@°i&I"            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[@n@ﬁ$I"newobj;F@‡$I"var = "[";F@˚)i[[	@õi%I""          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[	@ûi.I""          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[	@°iI""          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[@n@o@*@*@*I"end;Fi[[	@õi,I"Å          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[	@ûi5I"Å          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[	@°iI"Å          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[@n@o@™@´@¨@*i[[	@ûiLI"ﬂ    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 [";Fi[	@°i2I"˘    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    if (var["CMap"] == "KSCms-UHC-HW-H") then;Fi[	@îiâI"ﬂ    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 [";Fi[@'@3@„ @‰ @Â @Ê i[[	@åiI"î        # depot.
        def function(arglist)
          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@åiI"Î        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@åi I"Î        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[@Ï@Ì@Ó@ÔI"end;FI" ;Fi[[	@õiI"7  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths;Fi[	@ûiI"D  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = "KozMinPro-Regular-Acro";Fi[	@°iI"6  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths;Fi[@Ì@Ó@ÔI"end;FI" ;FI"def function(arglist);Fi[[	@õiI"I  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths
    var = "ETenms-B5-H";Fi[	@ûiI"T  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = "KozMinPro-Regular-Acro"
    var = SJIS_widths;Fi[	@°iI"H  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths
    var = "KSCms-UHC-H";Fi[I"return super(var);FI"end;FI"end;FI" ;FI"def function(arglist);FI"var = 0;Fi[[	@õi:I"»    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[	@ûi*I"     if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[	@°i)I"»    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[@îI"var = var.length;FI"var = 0;F@n@#@#i[[	@õi@I"  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@ûi0I"  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@°i/I"  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[@î@$@∞@±I"var = var.length;F@&i[[	@õi[I"4  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[	@ûiPI"4  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[	@°iJI"4  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[@'@3@ @Ò @Ú I"end;Fi[[	@˜ i@I"          return var unless (:head == var)
          var = scm("revno", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private;Fi[	@åi7I"≤          return var if var.to_s =~ /^\d+$/
          var = scm(authentication, :changes, "-s submitted", "-m 1", "//#{p4client}/...#{rev_no(revision)}")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[	@i>I"ß            raise("tried to run `#{command}' and got unexpected result #{result.inspect}")
          end
          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[@ÔI"end;FI"end;FI" ;FI"def function(arglist);FI"var = @var;Fi[[	@õiTI"Ó    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[	@ûiII"    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[	@°iCI"Ó    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[@$@∞@±I"var = var.length;F@&I"var = 0;Fi[[	@õi\I"5    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[	@ûiQI"5    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[	@°iKI"5    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[@∞@±@≤@&I"var = 0;FI"if var then;Fi[[	@õi]I";    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[	@ûiRI";    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[	@°iLI";    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[@'@3@y@@@!i[[	@Vi6I"1          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[	@ti*I"j        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("mkdir -p '#{remote_path}'");Fi[	@Yi(I"a        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[@±@Î@&I"var = 0;FI"if var then;F@ÿi[[	@õi^I"@    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[	@ûiSI"@    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[	@°iMI"@    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[@'@3I"#:nodoc:;FI"def function(arglist);FI"@var.each do |arglist|;FI"
begin;Fi[[	@(i!I"˚        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}")
            FileUtils.rm(var) if File.exist?(var));Fi[	@ãiƒI"      
      def function(arglist)
        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("saving #{path(style)}")
            var = (@var[var] or @var[:default]);Fi[	@ãi‡I"        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}")
            s3_bucket.objects[var.sub(/^\//, "")].delete);Fi[@&I"var = 0;FI"if var then;F@ÿI"var = "LTRB";FI"var = "LRT";Fi[[	@õi`I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@ûiUI"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@°iOI"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[@'@3@4@@@i[[	@õi;I"        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[	@ûiDI"        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[	@°i*I"        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[@ÿ@ŸI"	else;F@•I"@var = var;F@°i[[	@õiòI"$    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@ûiìI"$    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@°iáI"$    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[@'@3@4@Ï@Ì@Ói[[	@õiI"“    var = (@var.length + 1)
    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[	@ûiI"˛    Error("CID font already added: family style") unless @var[var].nil?
    var = (@var.length + 1)
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[	@°iI"“    var = (@var.length + 1)
    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[I"var = "LTRB";FI"var = "LRT";FI"var = "LR";FI"	else;FI"var = "";F@êi[[	@õidI"2    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[	@ûiYI"2    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[	@°iSI"2    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[I"var = "LRT";FI"var = "LR";FI"	else;FI"var = "";F@ê@ëi[[	@õieI"0    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[	@ûiZI"0    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[	@°iTI"0    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[I"var = "LR";FI"	else;FI"var = "";F@ê@ë@íi[[	@õifI"(      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[	@ûi[I"(      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[	@°iUI"(      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[@ê@ë@íI"end;FI"end;FI"var = -1;Fi[[	@õiiI"        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@ûi^I"        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@°iXI"        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[@ë@íI"end;FI"end;FI"var = -1;FI"var = 0;Fi[[	@õijI"      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@ûi_I"      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@°iYI"      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[@íI"end;FI"end;FI"var = -1;FI"var = 0;FI"var = 0;Fi[[	@õikI"        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@ûi`I"        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@°iZI"        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[@'@3@4@ﬂI"var;FI"end;Fi[[	@ii+I"ﬂ      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@ii0I"ﬂ      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@ii5I"›      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted;Fi[@<	@=	@>	I"var = (var + 1);F@z#I"	next;Fi[[	@õiyI"      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[	@ûinI"      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then;Fi[	@°ihI"      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[@<	@=	@>	@]+@z#I"	else;Fi[[	@õiçI"9          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@ûiáI"C          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@°i|I"9          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[@'@3@4@’I"var;FI"end;Fi[[	@ii÷I"ˆ      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@ii€I"’      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@ii‡I"”      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted;Fi[@'@3@4@∂@∑I"super(var);Fi[[	@aijI"¶    var = { "description" => "bio", "image" => "image_url", "name" => "first_name", "location" => "location" }
    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@aisI"Ò    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@ai|I"Ò    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[@°I"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;FI"var = (var + 1);Fi[[	@õiwI"P      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@ûilI"B      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@°ifI"P      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[@°I"	else;F@¸@˝I"end;FI"var = -1;Fi[[	@õiàI"ç      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@ûiÇI"      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@°i|I"ç      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[@°@˝I"end;FI"var = -1;FI"var = var;FI"var = 0;Fi[[	@õiäI"Ö          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@ûiÑI"w          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@°i~I"Ö          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[@'@3@4@´I"end;FI" ;Fi[[	@Æi9I"  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then;Fi[	@üi,I"±  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false;Fi[	@≥i1I"›  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid;Fi[@√&@ƒ&I"@var = @var;F@Á%@Ë%@È%i[[	@õiÀI"ü      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[	@ûi”I"O        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var)
            var = (var + 1);Fi[	@°i∫I"ü      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[@˝I"end;FI"var = -1;FI"var = var;FI"var = 0;FI"var = (var + 1);Fi[[	@õiãI"V          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@ûiÖI"V          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@°iI"V          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[@˝@∫+@ª+@º+@Ω+@ëi[[	@õiŸI"g          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@ûi·I"g          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@°i»I"g          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[@%@%I"if (var == 1) then;FI"@var = @var;FI"	else;F@•i[[	@õiñI"*        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@ûiëI"$        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@°iÖI"*        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[@'@3@4I""";FI"end;FI" ;Fi[[	@ói<I"{  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    [];Fi[	@üi	I"±  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      "";Fi[	@üiI"Ü    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0;Fi[@£I"end;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@õiüI"‘        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var);Fi[	@ûiöI"÷        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var);Fi[	@°iéI"‘        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var);Fi[@'@3@4I"broadcast(var);FI"end;FI" ;Fi[[	@IiI"ˇ      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@Ii$I"Â      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@IiiI"Â      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[@'@3@4I"var = @var;FI"var = @var;FI"var = @var["cw"];Fi[[	@õiVI"Ò    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@ûiKI"Ò    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@°iEI"Ò    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[@-@.@Í%@Î%I"	next;FI"end;Fi[[	@õiœI"å          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@°iæI"å          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@§i©I"          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var)
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var);Fi[@'@3@4I"@var.language;FI"end;FI" ;Fi[[	@‡i>I"˜      
      def function(arglist)
        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      
      class ExampleRow < Cells
        class InvalidForHeaderRowError < NoMethodError;Fi[	@‡i¶I"›        
        def function(arglist)
          "| #{@cells.collect { |c| c.value }.join(" | ")} |"
        end
        
        def function(arglist)
          @var.language
        end
        
        private
        ;Fi[	@iVI"      
      def function(arglist)
        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      
      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "_").gsub(/\./, "_").gsub(/:/, "_");Fi[@ãI"	else;F@-@.I"end;FI"var = -1;Fi[[	@õi÷I"h            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@ûiﬁI"Z            next
          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@°i≈I"h            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[@ã@.I"end;FI"var = -1;FI"var = var;FI"var = 0;Fi[[	@õiÿI"z          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@ûi‡I"l          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@°i«I"z          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[I"if var.!=(var) then;F@ˆ$I"end;FI"end;FI" ;FI"private;Fi[[	@õiËI"€        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@ûiÒI"’        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@°i◊I"€        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[@ˆ$I"end;FI"end;FI" ;FI"private;FI" ;Fi[[	@õiÈI"¬      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@ûiÚI"¬      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@°iÿI"¬      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[@=I"out("endobj");FI"end;F@I#I"newobj;F@6%i[[	@õiÛI"R    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@ûi¸I"R    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@°i‚I"R    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[@6%@í%@ì%@ç&@Á)I"5out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[[	@õi¯I"{    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then;Fi[	@ûiI"{    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then;Fi[	@°iÁI"y    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then;Fi[@6%@7%@8%I"putType0(var);FI"	else;F@:i[[	@õi
I"    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[	@ûiI"    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[	@°i˘I"    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[@í%@ì%@ç&@Á)@Y,I"(out(("/Length1 " + var["length1"]));Fi[[	@õi˘I"±    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[	@ûiI"±    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[	@°iËI"Ø    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[I":out((("/Length2 " + var["length2"]) + " /Length3 0"));FI"end;FI"out(">>");F@È$@Í$I"fclose(var);Fi[[	@õi I"J      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[	@ûi	I"J      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[	@°iÔI"H      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[@ß@È$@Í$I"fclose(var);FI"out("endobj");FI"end;Fi[[	@õiI"      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@ûiI"      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@°iÒI"      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[@ß@®@ﬁ$I"newobj;F@‡$I"var = "[";Fi[[	@õi$I"            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[	@ûi-I"            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[	@°iI"            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[@'@3@4@9#I"end;FI" ;Fi[[	@
iAI"◊      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init;Fi[	@‡iI"˛          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags;Fi[	@‡iÅI"œ              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var);Fi[@È$@Í$I"fclose(var);FI"out("endobj");FI"end;FI" @var.each_pair do |arglist|;Fi[[	@õiI"        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@ûiI"        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@°iÚI"        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[@Í$I"fclose(var);FI"out("endobj");FI"end;F@£,I"newobj;Fi[[	@õiI"È      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[	@ûiI"È      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[	@°iÛI"È      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[I"fclose(var);FI"out("endobj");FI"end;F@£,I"newobj;FI"@var[var]["n"] = @var;Fi[[	@õiI"      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[	@ûiI"      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[	@°iÙI"      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[@7%@8%I"putType0(var);FI"	else;F@:@;i[[	@õiI"1    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[	@ûiI"1    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[	@°i˙I"1    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[@8%I"putType0(var);FI"	else;F@:@;@<i[[	@õiI"O      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[	@ûiI"O      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[	@°i˚I"O      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[I"putType0(var);FI"	else;F@:@;@<@=i[[	@õiI"p      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[	@ûiI"p      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[	@°i¸I"p      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[@:@;@<@=@>I"&out("/Encoding /WinAnsiEncoding");Fi[[	@õiI"T      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[	@ûiI"T      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[	@°i˛I"T      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[@;@<@=@>@„,I"end;Fi[[	@õiI"Y        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[	@ûiI"Y        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[	@°iˇI"Y        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[@<@=@>@„,I"end;FI"	else;Fi[[	@õiI"b      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[	@ûiI"b      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[	@°i I"b      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[@=@>@„,I"end;FI"	else;F@Gi[[	@õiI"v        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[	@ûiI"v        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[	@°iI"v        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[@>@„,I"end;FI"	else;F@G@Hi[[	@õiI"ê        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[	@ûiI"ê        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[	@°iI"ê        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[@„,I"end;FI"	else;F@G@H@Ii[[	@õiI"©        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[	@ûiI"©        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[	@°iI"©        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[@„,@-I"end;FI"end;FI"out(">>");FI"out("endobj");Fi[[	@õi I"4            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[	@ûi)I"4            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[	@°iI"4            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[@G@H@I@J@KI"if var["enc"] then;Fi[[	@õiI"©            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[	@ûi I"©            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[	@°iI"©            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[@H@I@J@K@)-I"if var["diff"].nil?.! then;Fi[[	@õiI"å          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[	@ûi!I"å          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[	@°iI"å          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[@I@J@K@)-@2-I"9out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[[	@õiI"Æ        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[	@ûi"I"Æ        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[	@°iI"Æ        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[@J@K@)-@2-@;-I"	else;Fi[[	@õiI"±          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[	@ûi#I"±          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[	@°i	I"±          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[@K@)-@2-@;-I"	else;F@Ti[[	@õiI"ì          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[	@ûi$I"ì          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[	@°i
I"ì          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[@)-@2-@;-I"	else;F@TI"end;Fi[[	@õiI"Ä          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[	@ûi%I"Ä          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[	@°iI"Ä          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[@2-@;-I"	else;F@TI"end;FI"end;Fi[[	@õiI"s          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[	@ûi&I"s          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[	@°iI"s          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[@;-I"	else;F@TI"end;FI"end;FI"end;Fi[[	@õiI"U          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[	@ûi'I"U          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[	@°iI"U          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[@ﬁ$I"newobj;F@‡$I"var = "[";F@˚)@¸)i[[	@õi&I"%        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[	@ûi/I"%        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[	@°iI"%        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[@‡$I"var = "[";F@˚)@¸)I"out("endobj");FI"newobj;Fi[[	@õi(I"r        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[	@ûi1I"r        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[	@°iI"r        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[I"var = "[";F@˚)@¸)I"out("endobj");FI"newobj;F@*i[[	@õi)I"ì        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[	@ûi2I"ì        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[	@°iI"ì        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[@˚)@¸)I"out("endobj");FI"newobj;F@*@*i[[	@õi*I"z          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[	@ûi3I"z          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[	@°iI"z          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[@¸)I"out("endobj");FI"newobj;F@*@*@*i[[	@õi+I"Ö          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[	@ûi4I"Ö          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[	@°iI"Ö          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[@*@*@*I"end;F@—$I"if var then;Fi[[	@õi.I"Æ          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[	@ûi7I"Æ          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[	@°iI"Æ          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[@*@*I"end;F@—$I"if var then;F@(!i[[	@õi/I"Ø          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[	@ûi8I"Ø          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[	@°iI"Ø          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[@*I"end;F@—$I"if var then;F@(!I"end;Fi[[	@õi0I"Ø          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[	@ûi9I"Ø          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[	@°iI"Ø          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[@—$I"if var then;F@(!I"end;F@*!I"out("endobj");Fi[[	@õi2I"v          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[	@ûi;I"v          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[	@°i!I"v          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[@(!I"end;F@*!I"out("endobj");FI"end;FI"end;Fi[[	@õi4I"           end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[	@ûi=I"           end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[	@°i#I"           end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[@*!I"out("endobj");FI"end;FI"end;FI"end;FI"end;Fi[[	@õi6I"          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[	@ûi?I"          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[	@°i%I"          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[@@@@–I"out(">>");FI"out("endobj");Fi[[	@õi>I"#  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[	@ûiGI"#  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[	@°i-I"#  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[@@@–I"out(">>");FI"out("endobj");FI"newobj;Fi[[	@õi?I"?  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[	@ûiHI"?  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[	@°i.I"?  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[@@–I"out(">>");FI"out("endobj");FI"newobj;F@™i[[	@õi@I"c  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@ûiII"c  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@°i/I"c  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[@'@3@4I"var = 0;FI"var = @var["cw"];FI"var = var.length;Fi[[	@õi<I"§    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@ûi,I"§    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@°i+I"§    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[@'@3@4I"	self;FI"end;FI" ;Fi[[	I"+data//bundler_proj/bundler/spec_set.rb;TiBI"ï      @var = nil
      @var = nil
      var
    end
    
    def function(arglist)
      self
    end
    
    def function(arglist)
      sorted.dup;Fi[	I"3data//cucumber_prok/cucumber/ast/doc_string.rb;TiI"—      def function(arglist)
        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@å	i%I"Æ      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end
      
      alias :arguments :argument
      ;Fi[@'@3@4@ΩI"@var = var;FI"@var = var;Fi[[	@Ö
i!I"8            var = File.expand_path(var)
            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["cleanup"] ||= Sass::Script::Bool.new(true);Fi[	@}iI"»        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil
      end;Fi[	@ã
i#I".      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("notifier.invited_you", :name => (@var.name))), :host => (AppConfig.pod_uri.host) };Fi[@'@3@4@Ω@&.I"end;Fi[[	@=i'I"      
      def self.matches_condition?(arglist)
        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@ÜirI"            var = var[1]
            var = (var[3] or "highest")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@Bi
I"⁄    class TemplateContext
      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[@@I"	else;F@I"end;FI"@var = @var.!=(@var);Fi[[	@§iI";  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
  end;Fi[	@§i#I""  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end
  ;Fi[	@îiÀI"ô  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
    @var = [var, var, var] if var;Fi[@'@3@4@UI"end;FI" ;Fi[[	@çi$I"5      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[	@´i∑I"K        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[	@ïi6I"5      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[@'@3@4@QI"end;FI" ;Fi[[	@çi I"        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[	@´i≥I"ﬁ          var = "#outside_transaction? is deprecated. This method was only really used internally, but you can use #transaction_open? instead."
          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[	@ïi2I"      
      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[I"# @since 1.1;FI"#;FI"def function(arglist);FI"@var = var;FI"end;FI" ;Fi[[	@îi9I"±  	#
   	# Set header font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_font, :SetHeaderFont)
  ;Fi[	@îiDI"∞  #
   	# Set footer font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_font, :SetFooterFont)
  ;Fi[	@îiOI"∏  #
   	# Set language array.
  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_language_array, :SetLanguageArray)
  ;Fi[@â @ä @ã @å I"
retry;FI"rescue;Fi[[	@ê iI"S          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@ê i?I"O          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@ê i}I"O          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[@ä @ã @å I"
retry;FI"rescue;F@”#i[[	@ê iI";          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@ê i@I";          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@ê i~I";          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[@ã @å I"
retry;FI"rescue;F@”#I"end;Fi[[	@ê iI"4          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@ê iAI"4          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@ê iI"4          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[@å I"
retry;FI"rescue;F@”#I"end;FI"var = var;Fi[[	@ê iI".            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@ê iBI".            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@ê iÄI".            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[I"var = max_value;FI"var = min_value;F@!@"@#@©%i[[	@&iI"H      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@)iI"N      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@iRI"H      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[I"var = min_value;F@!@"@#@©%@™%i[[	@&iI"w      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@)iI"w      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@iSI"w      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[@"@#@©%@™%I"var = [];F@6!i[[	@&iI"ù        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@)iI"ù        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@iUI"ù        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[@#@©%@™%I"var = [];F@6!@7!i[[	@&iI"è        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@)iI"è        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@iVI"è        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[@©%@™%I"var = [];F@6!@7!I"return var;Fi[[	@&iI"~        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@)iI"~        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@iWI"~        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[@™%I"var = [];F@6!@7!I"return var;FI"end;Fi[[	@&i I"Ä        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@)iI"Ä        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@iXI"Ä        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[@6!@7!I"return var;FI"end;FI" ;FI"def function(arglist);Fi[[	@&i"I"K        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0)
      end;Fi[	@)iI"M        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@iZI"n        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 }
        var[:x] = (var * var);Fi[I"# == Example;FI"#;FI"#   class Vehicle;F@Î@¡@¬i[[	@∆i>I"M    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@∆ipI"    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@Fi˙I"O    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[I"#   class Vehicle;F@ﬂ@µI"#     end;FI"#   end;FI"#;Fi[[	@∫iI"-    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@∫i)I"ﬂ    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[	@∫iDI"ﬂ    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[@‚.@´I"#;F@ì@îI"#;Fi[[	@øiI",        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@øiRI",        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@øivI"+        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[@'@3@4@8@9I"end;Fi[[	@iÍI"’        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@¢iI"’        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@ iI"p    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[@ﬂ@µI"#     end;FI"#   end;FI"#;FI".#   states = Vehicle.state_machine.states;Fi[[	@∫iI"/    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">
    #   ;Fi[	@∫i*I")    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@∫iEI")    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[@'@3@4I"@var.clear;FI"end;FI" ;Fi[[	@∂i¬I"≈      
      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@∂i∆I"µ      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@∂i I"∏      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var;Fi[@2@3@4I"#;F@{!@|!i[[	@∆iBI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@∆itI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@riüI"    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[@3I"#       end;FI"#     end;FI"#   end;FI"#;FI"#   class VehicleObserver;Fi[[	@øiI"1        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@øiZI"1        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@øi~I"L        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|
        #       # log failure;Fi[@3@!/I"#;F@{!@|!I"#       end;Fi[[	@∆iCI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@∆iuI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@ri†I"#    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end;Fi[I"#       event :disable do;FI"%#         transition all => :off;FI"#       end;FI"#     end;FI"#   end;FI"#;Fi[[	@∆iPI"v    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.state                                 # => "parked";Fi[	@∆i}I"r    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.fire_events(:ignite, :disable_alarm)  # => true;Fi[	@riîI"O    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly
    #   vehicle = Vehicle.create    # => #<Vehicle id=1 state="parked" alarm_state="active">;Fi[@V @W @X @Y @Z I"	else;Fi[[	@] i%I"S        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end;Fi[	@jiI"Z        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          var = []
          var.errors.each_pair do |arglist|;Fi[	@si"I"è        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end;Fi[@.@/I"end;FI"
super;FI"end;FI"end;Fi[[	@•ihI"?          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@®iPI"7          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@3iI"}          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
      
      version("2.0.x") do |arglist|;Fi[@.@;I"	else;FI"
super;FI"end;FI"end;Fi[[	@gi<I"V      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@mi5I"V      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@pi9I"V      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[@c@d@GI"end;FI" ;F@Ji[[	@giI"v      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then;Fi[	@miI"2      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value;Fi[	@piI"0      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default;Fi[@3 @4 @5 @;I"	else;FI"
super;Fi[[	@gi:I"?        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@mi3I"+        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@pi7I"+        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[@;I"	else;FI"
super;FI"end;FI"end;FI" ;Fi[[	@gi=I"k      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	@mi6I"k      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	@pi:I"k      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[@=@ @TI"end;FI" ;F@Wi[[	@giCI"a        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@mi<I"a        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@pi@I"a        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[@TI"end;FI" ;F@W@XI"def function(arglist);Fi[[	@giEI"©      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] })
      end;Fi[	@mi>I"æ      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "$in" => (var) }) }) };Fi[	@piBI"´      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } })
      end;Fi[@´I"#;F@ì@îI"#;F@ei[[	@øiI"Q        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@øiSI"Q        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@øiwI"P        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[@ì@îI"#;F@e@f@gi[[	@øiI"V        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@øiUI"V        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@øiyI"V        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[@îI"#;F@e@f@gI"#       end;Fi[[	@øiI"L        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@øiVI"L        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@øizI"L        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[@E@à@â@mI"end;FI"end;Fi[[	@èiI"=      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user;Fi[	@uiI"f    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets;Fi[	@íiI"O    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user;Fi[@'@3@4@Ç@ÉI"end;Fi[[	@µi2I"±          end
          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@Gi=I"{    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@1icI"æ      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[@'@3@t@u@ @ i[[	@Åi˝I"o      #     Twitter.list_remove_members(7505382, 8863586, [813286, 18755393])
      def function(arglist)
        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[	I"5data//twitter_proj/twitter/api/places_and_geo.rb;TipI"Õ      #   Twitter.place_create(:name => "@sferik's Apartment", :token => "22ff5b1f7159032cf69218c4d8bb78bc", :contained_within => "41bcb736f84a799e", :lat => "37.783699", :long => "-122.393581")
      def function(arglist)
        object_from_response(Twitter::Place, :post, "/1.1/geo/place.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash]
      # @return [Array];Fi[	@!i˚I"P        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>];Fi[@Ù@ı@ˆI" # @return [Twitter::Cursor];FI"'# @overload friend_ids(options={});FI"[#   Returns an array of numeric IDs for every user the authenticated user is following;Fi[[	I"<data//twitter_proj/twitter/api/friends_and_followers.rb;TiI"      include(Twitter::API::Utils)
      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@€/i I"J      # Returns a cursored collection of user objects for users following the specified user.
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@€/iI"y      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[@'@3@t@u@rI"4# Establishes a connection to the remote server;Fi[[	@Vi"I"‚        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #
      # Note:;Fi[	@tiI":        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.
      # Net::SCP will use this connection to transfer backups;Fi[	@YiI"I        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|;Fi[@Ù@ı@ˆI";# @param options [Hash] A customizable set of options.;FI"Í# @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;FI""# @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[[	@—/iI"˛      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).
      # @option options [String] :granularity ('neighborhood') This is the minimal granularity of place types to return and must be one of: 'poi', 'neighborhood', 'city', 'admin' or 'country'.;Fi[	@—/i2I"ø      # Search for places that can be attached to a {Twitter::API::Tweets#update}
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.
      # @option options [String] :ip An IP address. Used when attempting to fix geolocation based off of the user's IP address.;Fi[	@—/iLI"õ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.;Fi[@ı@ˆ@÷/@◊/@ÿ/I"#;Fi[[	@€/iI"      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@€/iI"       #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@€/i I""      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@'@3@t@u@ÈI"# do nothing;Fi[[	@ÔiaI"√            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@…iCI"∫    
    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@™iI"Î          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end;Fi[@ˆ@÷/@◊/@ÿ/I"#;FI"=#   @param options [Hash] A customizable set of options.;Fi[[	@€/iI"U      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs;Fi[	@€/iI"ö      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@€/i!I"ú      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@'@3@∞@±@c@di[[	@giI"      def self.extended(arglist)
        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@miI"ˇ      
      def self.matching_ancestors(arglist)
        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@piI"˝      def self.extended(arglist)
        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[@'@3@@π$I"# type.;FI"#;Fi[[	@:iI"      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11");Fi[	@îi•I"J      def function(arglist)
        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ]);Fi[	@?i*I""      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11");Fi[@∏@π@∫@J@ªI"´# @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[[	@MiHI"}      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik
      #   Twitter.retweeted_by_user('sferik');Fi[	@Mi_I"ä      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user
      #   Twitter.retweeted_by_me;Fi[	@MiÜI"˛      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.
      # @example Return the 20 most recent retweets posted by users followed by the authenticating user;Fi[@÷/@◊/@ÿ/I"#;F@	0I"-#   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@€/iI"2      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids;Fi[	@€/iI"ﬂ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@€/i"I"ﬂ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[I">#   @example Return the authenticated user's friends' IDs;FI"#     Twitter.friend_ids;FI"-# @overload friend_ids(user, options={});FI"W#   Returns an array of numeric IDs for every user the specified user is following;FI"#;FI"`#   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[[	@€/iI"ﬁ      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@€/iI"£      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@€/i*I"£      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@80@90@:0I"#;F@<0I"=#   @param options [Hash] A customizable set of options.;Fi[[	@€/iI"      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs;Fi[	@€/iI"Ò      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@€/i+I"Ò      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@90@:0I"#;F@<0@F0I"Õ#   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@€/iI"Ò      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs
      #     Twitter.friend_ids('sferik');Fi[	@€/iI"˘      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@€/i,I"˘      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[@ @ @ @ @ I"+var = Twitter::API::Arguments.new(var);Fi[[	@ÅiI"g      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then;Fi[	@-iI"q      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::User, var, var, merge_user(var.options, var));Fi[	@-iI"t        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name));Fi[@˘@˙@˚@¸@˝I"&# @return [Array<Twitter::Tweet>];Fi[[	@Mi(I"M      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@Mi@I"X      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.;Fi[	@MiXI"      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[I"/var[var] = Twitter::Size.fetch_or_new(var);FI"var;FI"end;FI"end;FI"end;FI"end;Fi[[	I"0data//twitter_proj/twitter/configuration.rb;TiI"⁄    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	@6iI"Í      # @return [Array<Twitter::Size>]
      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/profile_banner.rb;TiI"‘    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi
