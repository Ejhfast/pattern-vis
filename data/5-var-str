[{:lociüÕ:projects[I"activemodel_proj:ETI"activerecord_proj;TI"backup_proj;TI"bundler_proj;TI"cancan_proj;TI"capistrano_proj;TI"compass_proj;TI"cucumber_prok;TI"devise_proj;TI"diaspora_proj;TI"haml_proj;TI"homebrew_proj;TI"jekyll_proj;TI"mongoid_proj;TI"nokogiri_proj;TI"omni_proj;TI"paperclip_proj;TI"redmine_proj;TI"rescue_proj;TI"rspec_proj;TI"sinatra_proj;TI"SiriProxy_proj;TI"state_machine_proj;TI"twitter_proj;TI"whenever_proj;T:options[	I"
--var;TI"
--str;TI"
--fun;TI"--fargs;T[R[I"end;FI"end;FI"end;FI"end;FI"end;Fi4[4[	I";data//activemodel_proj/active_model/secure_password.rb;TigI"¨            BCrypt::Engine::DEFAULT_COST
          end
          self.password_digest = BCrypt::Password.create(var, :cost => (var))
        end
      end
    end
  end
end;Fi[	I"9data//activemodel_proj/active_model/serialization.rb;Ti^I"Ç      var.each do |arglist|
        if var = send(var) then
          yield(var, var, var)
        end
      end
    end
  end
end;Fi[	I"Adata//activemodel_proj/active_model/validations/validates.rb;TiüI"q          { :in => (var) }
        else
          { :with => (var) }
        end
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/aggregations.rb;TicI"Ø          else
            var.each { |arglist| self[var.first] = var.send(var.last) }
            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	@8idI"†            var.each { |arglist| self[var.first] = var.send(var.last) }
            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//activerecord_proj/active_record/associations/association.rb;Ti‘I"»          var = [reflection.foreign_key, reflection.type].compact
          var = create_scope.except(*(var.changed - var))
          var.assign_attributes(var)
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/associations/collection_association.rb;Ti„I"Ê        var = fetch_first_or_last_using_find?(var) ? (scope) : (load_target)
        var.send(var, *var).tap do |arglist|
          set_inverse_instance(var) if var.is_a?(ActiveRecord::Base)
        end
      end
    end
  end
end;Fi[	I"Vdata//activerecord_proj/active_record/associations/has_one_through_association.rb;TiI"ª              var.update(var)
            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	@CiI"ù            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	@Ci I"å              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	I"[data//activerecord_proj/active_record/associations/join_dependency/join_association.rb;TivI"Ä        
        def function(arglist)
          @var ||= reflection.scope_chain.reverse
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/associations/join_dependency/join_base.rb;TiI"v        
        def function(arglist)
          active_record.table_name
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/associations/join_dependency/join_part.rb;TiDI"ß        
        def function(arglist)
          @var[record_id(var)] ||= active_record.send(:instantiate, extract_record(var))
        end
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/associations/preloader/association.rb;TinI"§            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/associations/preloader/belongs_to.rb;TiI"t        
        def function(arglist)
          reflection.foreign_key
        end
      end
    end
  end
end;Fi[	I"[data//activerecord_proj/active_record/associations/preloader/collection_association.rb;TiI"±            var.loaded!
            var.target.concat(var)
            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	@YiI"ô            var.target.concat(var)
            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	I"\data//activerecord_proj/active_record/associations/preloader/has_and_belongs_to_many.rb;Ti:I"        def function(arglist)
          var = table[reflection.association_primary_key].eq(join_table[reflection.association_foreign_key])
          table.create_join(join_table, table.create_on(var))
        end
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/associations/preloader/has_many.rb;TiI"}        
        def function(arglist)
          reflection.active_record_primary_key
        end
      end
    end
  end
end;Fi[	I"Udata//activerecord_proj/active_record/associations/preloader/has_many_through.rb;TiI"ö        
        def function(arglist)
          super.each { |arglist| var.uniq! if reflection_scope.uniq_value }
        end
      end
    end
  end
end;Fi[	I"Ldata//activerecord_proj/active_record/associations/preloader/has_one.rb;TiI"ß        
        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]))
        end
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/associations/preloader/singular_association.rb;TiI"Ø            var = var.association(reflection.name)
            var.target = var
            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	@jiI"|            var.target = var
            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	I"Xdata//activerecord_proj/active_record/associations/preloader/through_association.rb;Ti4I"Ö            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/associations/preloader.rb;TiàI"d          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Ndata//activerecord_proj/active_record/associations/through_association.rb;TiFI"∫      def function(arglist)
        if reflection.nested? then
          raise(HasManyThroughNestedAssociationsAreReadonly.new(owner, reflection))
        end
      end
    end
  end
end;Fi[	I"Kdata//activerecord_proj/active_record/attribute_methods/primary_key.rb;TisI"~        def function(arglist)
          @var = (var and var.to_s)
          @var = nil
        end
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/attribute_methods/serialization.rb;TiÉI"}            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	@{iÑI"[          else
            super
          end
        end
      end
    end
  end
end;Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract/schema_dumper.rb;Ti2I"b          "STRING"
        else
          var.inspect
        end
      end
    end
  end
end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/connection_specification.rb;TiJI"d            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/mysql2_adapter.rb;Ti„I"±      def function(arglist)
        @var ||= @var.info[:version].scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/connection_adapters/mysql_adapter.rb;TiÿI"Æ      def function(arglist)
        @var ||= @var.server_info.scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/connection_adapters/postgresql/array_parser.rb;Ti]I"«        def function(arglist)
          unless (var.length == 0) then
            var.! and (var == "STRING") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	@ái^I"©          unless (var.length == 0) then
            var.! and (var == "STRING") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/postgresql/cast.rb;TiãI"n            var
          else
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@åiåI"^          else
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	I"`data//activerecord_proj/active_record/connection_adapters/postgresql/database_statements.rb;TiΩI"o        
        def function(arglist)
          execute("STRING")
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/connection_adapters/postgresql/quoting.rb;TiìI"…          var = "STRING" if var.acts_like?(:time) and var.respond_to?(:usec)
          var = (var.sub(/^-/, "STRING") + "STRING") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	I"bdata//activerecord_proj/active_record/connection_adapters/postgresql/referential_integrity.rb;TiI"#          ensure
            if supports_disable_referential_integrity? then
              execute(tables.collect { |arglist| "STRING" }.join("STRING")) rescue execute(tables.collect { |arglist| "STRING" }.join("STRING"))
            end
          end
        end
      end
    end
  end
end;Fi[	@óiI"            if supports_disable_referential_integrity? then
              execute(tables.collect { |arglist| "STRING" }.join("STRING")) rescue execute(tables.collect { |arglist| "STRING" }.join("STRING"))
            end
          end
        end
      end
    end
  end
end;Fi[	@óiI"÷              execute(tables.collect { |arglist| "STRING" }.join("STRING")) rescue execute(tables.collect { |arglist| "STRING" }.join("STRING"))
            end
          end
        end
      end
    end
  end
end;Fi[	I"^data//activerecord_proj/active_record/connection_adapters/postgresql/schema_statements.rb;TiZI"|            "STRING"
          end
          [super].concat(var).join("STRING")
        end
      end
    end
  end
end;Fi[	I"Ndata//activerecord_proj/active_record/connection_adapters/schema_cache.rb;TiXI"µ        end
        @var.default_proc = Proc.new do |arglist|
          var[var] = table_exists?(var) ? (connection.primary_key(var)) : (nil)
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/sqlite3_adapter.rb;TiI"q          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	I"@data//activerecord_proj/active_record/locking/optimistic.rb;TioI"o            var[locking_column] ||= 0
          end
          var)
        end
      end
    end
  end
end;Fi[	I"Adata//activerecord_proj/active_record/locking/pessimistic.rb;TiI"r        transaction do |arglist|
          lock!(var)
          yield
        end
      end
    end
  end
end;Fi[	I"Hdata//activerecord_proj/active_record/migration/command_recorder.rb;TiÑI"Æ          @var.send(var, *var, &var)
        rescue NoMethodError => var
          raise(var, var.message.sub(/ for #<.*$/, "STRING"))
        end
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/model_schema.rb;Ti8I"e          "STRING"
        else
          var.table_name
        end
      end
    end
  end
end;Fi[	I"?data//activerecord_proj/active_record/nested_attributes.rb;TiÅI"¯              send(var, var.except(*UNASSIGNABLE_KEYS))
            else
              raise(ArgumentError, "STRING")
            end
          end
        end
      end
    end
    
    # Assigns the given attributes to the collection association.;Fi[	I"5data//activerecord_proj/active_record/railtie.rb;TiEI"∑                self.connection.schema_cache = var
              else
                warn("STRING")
              end
            end
          end
        end
      end
    end
    ;Fi[	@∂iFI"´              else
                warn("STRING")
              end
            end
          end
        end
      end
    end
    
    initializer("STRING") do |arglist|;Fi[	I"Idata//activerecord_proj/active_record/railties/controller_runtime.rb;Ti-I"í          var, var = super, var[:db_runtime]
          (var << ("STRING" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	I"Adata//activerecord_proj/active_record/relation/delegation.rb;Ti<I"¶              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods;Fi[	@æimI"¢          to_a.send(var, *var, &var)
        else
          arel.respond_to?(var) ? (arel.send(var, *var, &var)) : (super)
        end
      end
    end
  end
end;Fi[	I"=data//activerecord_proj/active_record/relation/merger.rb;TiqI"g          var
        else
          relation.where_values
        end
      end
    end
  end
end;Fi[	I"=data//activerecord_proj/active_record/scoping/default.rb;TiqI"Á                    var.merge(unscoped { |arglist| var.call })
                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        ;Fi[	@∆irI"∆                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist);Fi[	@∆iÜI"á            yield)
          ensure
            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	@∆iáI"y          ensure
            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	I";data//activerecord_proj/active_record/scoping/named.rb;TiòI"‡            var = var.respond_to?(:call) ? (unscoped { |arglist| var.call(*var) }) : (var)
            var = all.merge(var)
            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	@œiôI"Ö            var = all.merge(var)
            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	I"3data//activerecord_proj/active_record/store.rb;TiSI"ë          var.with_indifferent_access
        else
          ActiveSupport::HashWithIndifferentAccess.new
        end
      end
    end
  end
end;Fi[	I"\data//activerecord_proj/rails/generators/active_record/migration/migration_generator.rb;Ti4I"≠      def function(arglist)
        unless file_name =~ /^[_a-z0-9]+$/ then
          raise(IllegalMigrationNameError.new(file_name))
        end
      end
    end
  end
end;Fi[	I"6data//backup_proj/backup/configuration/helpers.rb;TijI"~          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/notifier/campfire.rb;TiI"ö        # Returns the url for the specified room (in JSON format)
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/notifier/hipchat.rb;TiZI"“        var = HipChat::Client.new(token)
        [rooms_notified].flatten.each do |arglist|
          var[var].send(from, var, :color => (var), :notify => (notify_users))
        end
      end
    end
  end
end;Fi[	I"3data//backup_proj/backup/storage/cloudfiles.rb;TiBI"         transferred_files_for(var) do |arglist|
          Logger.message(("STRING" + "STRING"))
          connection.delete_object(container, File.join(var, var))
        end
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/storage/dropbox.rb;TiÜI"ü          var)
        rescue => var
          raise(Errors::Storage::Dropbox::AuthenticationError.wrap(var, "STRING"))
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/storage/ftp.rb;TidI"õ            var.mkdir(var.join("STRING"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ÈieI"v          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/storage/local.rb;Ti;I"î        else
          Logger.warn(Errors::Storage::Local::TransferError.new("STRING"))
          @var = :cp
        end
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/storage/ninefold.rb;TiUI"Œ          raise(Errors::Storage::Ninefold::NotFoundError, "STRING") unless var.empty?
        else
          raise(Errors::Storage::Ninefold::NotFoundError, "STRING")
        end
      end
    end
  end
end;Fi[	I"+data//backup_proj/backup/storage/s3.rb;TiFI"«        transferred_files_for(var) do |arglist|
          Logger.message(("STRING" + "STRING"))
          connection.delete_object(bucket, File.join(var, var))
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/storage/scp.rb;TiHI"£        end
        unless var.empty? then
          raise(Errors::Storage::SCP::SSHError, ("STRING" + var.join("STRING")))
        end
      end
    end
  end
end;Fi[	I"-data//backup_proj/backup/storage/sftp.rb;TiVI"•            var.mkdir!(var.join("STRING"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@˙iWI"          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/cloud/base.rb;TiïI"Ó                  var.destroy
                else
                  MUTEX.synchronize { |arglist| Logger.message("STRING") }
                end
              end
            end
          end
        end
        
        class LocalFile;Fi[	@ˇi¿I"§              var if var.unpack("STRING").!.! rescue @var = true
                "STRING"
            end.join
          end
        end
      end
    end
  end
end;Fi[	@ˇi¡I"h                "STRING"
            end.join
          end
        end
      end
    end
  end
end;Fi[	I"9data//backup_proj/backup/syncer/cloud/cloud_files.rb;TiBI"ô        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/syncer/cloud/s3.rb;Ti9I"ô        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/base.rb;Ti+I"ì        # Returns Rsync syntax for invoking "archive" mode
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"3data//backup_proj/backup/syncer/rsync/local.rb;Ti-I"«        # concatenated, ready for the CLI
        def function(arglist)
          ([archive_option, mirror_option] + additional_options).compact.join("STRING")
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/pull.rb;TiI"©        # Return expanded @path, since this path is local
        def function(arglist)
          @var ||= File.expand_path(@var)
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/push.rb;TijI"}        def function(arglist)
          @var.delete if @var
          @var = nil
        end
      end
    end
  end
end;Fi[	I"-data//bundler_proj/bundler/deployment.rb;Ti"I"â          (var << var.to_s)
          (var << "STRING") unless var.empty?
          run("STRING")
        end
      end
    end
  end
end;Fi[	I"(data//bundler_proj/bundler/graph.rb;TiåI"ï          rescue ArgumentError => var
            $stderr.puts("STRING")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	@içI"t            $stderr.puts("STRING")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	I"+data//bundler_proj/bundler/resolver.rb;Ti„I"ƒ            if var.include?(var) then
              debug { |arglist| "STRING" }
              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"/data//bundler_proj/bundler/ruby_version.rb;Ti+I"Ω            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion;Fi[	I"7data//bundler_proj/bundler/rubygems_integration.rb;Ti°I"∫            @var = RubygemsIntegration::Legacy.new
          else
            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  
  class << self;Fi[	I"*data//bundler_proj/bundler/runtime.rb;Ti>I"¨                raise(var)
              end
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"7data//bundler_proj/bundler/source/git/git_proxy.rb;Ti{I"ù        
        def function(arglist)
          allow? ? (in_path { |arglist| yield }) : (raise(GitError, "STRING"))
        end
      end
    end
  end
end;Fi[	I"-data//bundler_proj/bundler/source/git.rb;Ti÷I"Æ      def function(arglist)
        @var ||= GitProxy.new(cache_path, uri, ref, cached_revision) do |arglist|
          allow_git_ops?
        end
      end
    end
  end
end;Fi[	I"8data//bundler_proj/bundler/source/path/installer.rb;TiI"À          if Bundler.requires_sudo? then
            Bundler.mkdir_p("STRING")
            spec.executables.each { |arglist| Bundler.sudo("STRING") }
          end
        end
      end
    end
  end
end;Fi[	@2iI"¢            Bundler.mkdir_p("STRING")
            spec.executables.each { |arglist| Bundler.sudo("STRING") }
          end
        end
      end
    end
  end
end;Fi[	I".data//bundler_proj/bundler/source/path.rb;TiπI"≤            var = "STRING" if var.inspect =~ /@(.*:\d+)/
            var = "STRING"
            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	@7i∫I"~            var = "STRING"
            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	I"2data//bundler_proj/bundler/source/rubygems.rb;TiŒI"s          var)
        ensure
          Bundler.rubygems.sources = var
        end
      end
    end
  end
end;Fi[	I"@data//bundler_proj/bundler/vendor/thor/actions/directory.rb;Ti^I"¿            var = base.template(var, var[(0..-4)], config, &@var)
          else
            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	@?i_I"~          else
            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//bundler_proj/bundler/vendor/thor/actions/inject_into_file.rb;TiYI"÷          if (var or var.include?(replacement).!) then
            var.gsub!(var, var)
            File.open(destination, "STRING") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	@DiZI"ü            var.gsub!(var, var)
            File.open(destination, "STRING") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	I"Tdata//bundler_proj/bundler/vendor/thor/core_ext/hash_with_indifferent_access.rb;Ti=I"ä          var.empty? ? (self[$1].!.!) : ((self[$1] == var.first))
        else
          self[var]
        end
      end
    end
  end
end;Fi[	I"Ddata//bundler_proj/bundler/vendor/thor/core_ext/ordered_hash.rb;TiRI"i        
        def function(arglist)
          @var.empty?
        end
      end
    end
  end
end;Fi[	I"=data//bundler_proj/bundler/vendor/thor/parser/options.rb;Ti–I"¯                return var.lazy_default
              else
                raise(MalformattedArgumentError, "STRING")
              end
            end
          end
        end
      end
      @var.delete(var)
      send(:"parse_#{var.type}", var);Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/color.rb;TiçI"e          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	I"9data//bundler_proj/bundler/vendor/thor/shell/html.rb;Ti{I"e          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	I"3data//bundler_proj/bundler/vendor/thor/util.rb;TiZI"Î              ENV["STRING"]
            else
              File.expand_path("STRING") rescue File::ALT_SEPARATOR ? ("STRING") : ("STRING")
            end
          end
        end
      end
    end
    
    def self.thor_root(arglist);Fi[	I"?data//cancan_proj/cancan/model_adapters/mongoid_adapter.rb;Ti&I"⁄                var.or(var.conditions)
              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end;Fi[	@[i'I"∑              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@[i(I"À                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods;Fi[	@[i)I"Æ              end
            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods
  include(CanCan::ModelAdditions::ClassMethods);Fi[	I"%data//cancan_proj/cancan/rule.rb;Ti.I"√              matches_conditions_hash?(var)
            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	@di~I"…                end
              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    ;Fi[	@diI"œ              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"4data//capistrano_proj/capistrano/cli/execute.rb;TiQI"k          abort(var.message)
        else
          raise(var)
        end
      end
    end
  end
end;Fi[	I"4data//capistrano_proj/capistrano/cli/options.rb;TiµI"U          nil
        else
          var
        end
      end
    end
  end
end;Fi[	I"/data//capistrano_proj/capistrano/cli/ui.rb;Ti#I"ø            var.default = "STRING"
            var.validate = /(y(es)?)|(no?)|(a(bort)?|\n)/i
            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	@qi$I"ú            var.validate = /(y(es)?)|(no?)|(a(bort)?|\n)/i
            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	I"0data//capistrano_proj/capistrano/command.rb;TiI"¥        options[:env].inject("STRING") do |arglist|
          var = var.to_s.gsub(/[ "]/) { |arglist| "STRING" }
          (var << "STRING")
        end
      end
    end
  end
end;Fi[	I"Ldata//capistrano_proj/capistrano/configuration/actions/file_transfer.rb;Ti,I"Ò          execute_on_servers(var) do |arglist|
            var = var.map { |arglist| sessions[var] }
            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	@yi-I"¬            var = var.map { |arglist| sessions[var] }
            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//capistrano_proj/capistrano/configuration/actions/inspect.rb;Ti/I"X            end
          end
          var
        end
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/configuration/actions/invocation.rb;TiI"w            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ÅiI"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/configuration/callbacks.rb;TiâI"ê          (var << "STRING") if var
          logger.trace(var)
          var.each { |arglist| var.call }
        end
      end
    end
  end
end;Fi[	I"Bdata//capistrano_proj/capistrano/configuration/connections.rb;Ti–I"õ        rescue Exception => var
          raise unless var
          (var << { :server => (var), :error => (var) })
        end
      end
    end
  end
end;Fi[	I">data//capistrano_proj/capistrano/configuration/loading.rb;TifI"”                  instance_eval(&var[:proc])
                else
                  raise(ArgumentError, "STRING")
                end
              end
            end
          end
        end
      end
      ;Fi[	@åigI"ˆ                else
                  raise(ArgumentError, "STRING")
                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,;Fi[	@åi∏I"ª        if self.class.current_feature then
          var = self.class.recipes_per_feature[self.class.current_feature] ||= []
          (var << var)
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/configuration/variables.rb;TisI"Ñ          self[var]
        else
          method_missing_without_variables(var, *var, &var)
        end
      end
    end
  end
end;Fi[	I"7data//capistrano_proj/capistrano/ext/multistage.rb;Ti1I"ﬁ          File.open(var, "STRING") do |arglist|
            var.puts("STRING")
            var.puts("STRING")
          end
        end
      end
    end
  end
  on(:start, "STRING", :except => ((stages + ["STRING"])))
end;Fi[	I"Idata//capistrano_proj/capistrano/recipes/deploy/remote_dependency.rb;TimI"ó        rescue Capistrano::CommandError => var
          @var = false
          @var = var.hosts.join("STRING")
        end
      end
    end
  end
end;Fi[	I"Cdata//capistrano_proj/capistrano/recipes/deploy/scm/accurev.rb;Ti~I"Æ          
          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	@úiI"£          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/scm/base.rb;Ti≤I"ä          var = variable(:scm_arguments)
          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/bzr.rb;TiKI"ê        
        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("STRING".chomp)
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/cvs.rb;TiÅI"z          var = var.pop
          var = var.join("STRING")
          "STRING"
        end
      end
    end
  end
end;Fi[	I"Adata//capistrano_proj/capistrano/recipes/deploy/scm/darcs.rb;TiWI"n            nil
          else
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@™iXI"^          else
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/git.rb;TiîI"≠        # command-line switch for "quiet" ("-q").
        def function(arglist)
          variable(:scm_verbose) ? (nil) : ("STRING")
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/scm/mercurial.rb;TilI"¯        # honor Cap 2.1+'s :scm_prefer_prompt if present
        def function(arglist)
          @var ||= (variable(:scm_password) or Capistrano::CLI.password_prompt("STRING") if variable(:scm_prefer_prompt))
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/scm/none.rb;Ti I"ï        # log: There's no log, so it just echos from and to.
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"Ddata//capistrano_proj/capistrano/recipes/deploy/scm/perforce.rb;TiÇI"n            "STRING"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	@∏iÉI"Y          else
            var
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//capistrano_proj/capistrano/recipes/deploy/scm/subversion.rb;TirI"¡        
        def function(arglist)
          @var ||= (variable(:scm_password) or (variable(:password) or Capistrano::CLI.password_prompt("STRING")))
        end
      end
    end
  end
end;Fi[	I";data//capistrano_proj/capistrano/recipes/deploy/scm.rb;TiI"|          end)
        rescue LoadError
          raise(Capistrano::Error, "STRING")
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/strategy/base.rb;TiOI"å        # and not a pseudo-id.
        def function(arglist)
          configuration[:real_revision]
        end
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/recipes/deploy/strategy/checkout.rb;TiI"Ÿ        # Returns the SCM's checkout command for the revision to deploy.
        def function(arglist)
          @var ||= source.checkout(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/strategy/copy.rb;TiI"í        def function(arglist)
          upload(filename, remote_filename)
          decompress_remote_file
        end
      end
    end
  end
end;Fi[	I"Gdata//capistrano_proj/capistrano/recipes/deploy/strategy/export.rb;TiI"’        # Returns the SCM's export command for the revision to deploy.
        def function(arglist)
          @var ||= source.export(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	I"Gdata//capistrano_proj/capistrano/recipes/deploy/strategy/remote.rb;Ti+I"ù        # revision being deployed to the REVISION file on each host.
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"Mdata//capistrano_proj/capistrano/recipes/deploy/strategy/remote_cache.rb;Ti0I"è        
        def function(arglist)
          @var ||= Array(configuration.fetch(:copy_exclude, []))
        end
      end
    end
  end
end;Fi[	I"Vdata//capistrano_proj/capistrano/recipes/deploy/strategy/unshared_remote_cache.rb;TiI"~        
        def function(arglist)
          configuration[:repository_cache]
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/strategy.rb;TiI"|          end)
        rescue LoadError
          raise(Capistrano::Error, "STRING")
        end
      end
    end
  end
end;Fi[	I"7data//capistrano_proj/capistrano/recipes/deploy.rb;TiuI"¿                :perforce
              else
                File.exist?("STRING") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end;Fi[	@€ivI"™              else
                File.exist?("STRING") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@€iwI"„                File.exist?("STRING") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your;Fi[	@€ixI"∑              end
            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your
# own dependencies.;Fi[	I"Udata//compass_proj/compass/app_integration/stand_alone/configuration_defaults.rb;TiI"f        
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"Hdata//compass_proj/compass/app_integration/stand_alone/installer.rb;Ti?I"k        
        def function(arglist)
          @var.compile?
        end
      end
    end
  end
end;Fi[	I"9data//compass_proj/compass/configuration/comments.rb;TiI"_          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	I"5data//compass_proj/compass/configuration/data.rb;TiI"Ò            else
              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	@ÌiØI"à          raise(Error, "STRING")
        else
          raise(Error, "STRING") if (var.size > 0)
        end
      end
    end
  end
end;Fi[	I"8data//compass_proj/compass/configuration/helpers.rb;Ti1I"                    Compass::AppIntegration.lookup(var).configuration
                  else
                    raise("STRING")
                  end
                end
              end
            end
          end
        end
      end;Fi[	@Úi2I"±                  else
                    raise("STRING")
                  end
                end
              end
            end
          end
        end
      end
      ;Fi[	@Úi3I"∑                    raise("STRING")
                  end
                end
              end
            end
          end
        end
      end
      
      # Support for testing.;Fi[	I"<data//compass_proj/compass/configuration/inheritance.rb;TiÃI"c            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	I"Kdata//compass_proj/compass/sass_extensions/monkey_patches/traversal.rb;TiI"Ñ            var.visit_depth_first(var)
          end
          var.up(self) if children.any?
        end
      end
    end
  end
end;Fi[	I"Tdata//compass_proj/compass/sass_extensions/sprites/engines/chunky_png_engine.rb;TiI"¥        def function(arglist)
          construct_sprite if canvas.nil?
          canvas.save(var, Compass.configuration.chunky_png_options)
        end
      end
    end
  end
end;Fi[	I"Bdata//compass_proj/compass/sass_extensions/sprites/engines.rb;TiI"ø        
        def function(arglist)
          raise(::Compass::Error, "STRING")
        end
      end
    end
  end
end
require("compass/sass_extensions/sprites/engines/chunky_png_engine");Fi[	I"@data//compass_proj/compass/sass_extensions/sprites/image.rb;TiìI"Ø        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end
      end
    end
  end
end;Fi[	I"Hdata//compass_proj/compass/sass_extensions/sprites/image_methods.rb;Ti I"Õ        # Return and array of image names that make up this sprite
        def function(arglist)
          image_names.map { |arglist| File.basename(var, "STRING") }
        end
      end
    end
  end
end;Fi[	I"Ddata//compass_proj/compass/sass_extensions/sprites/image_row.rb;Ti/I"Å        
        def function(arglist)
          ((total_width + var.width) <= max_width)
        end
      end
    end
  end
end;Fi[	I"Idata//compass_proj/compass/sass_extensions/sprites/layout_methods.rb;Ti†I"å        
        def function(arglist)
          @var.map { |arglist| (var.width + var.offset) }.max
        end
      end
    end
  end
end;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/row_fitter.rb;TiPI"                        var = true
                        (var << var)
                        throw(:done)
                      end
                    end
                  end
                end
              end
            end
          end while var;Fi[	@iQI"Î                        (var << var)
                        throw(:done)
                      end
                    end
                  end
                end
              end
            end
          end while var
        end;Fi[	@iWI"f              end
            end
          end while var
        end
      end
    end
  end
end;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/sprite_map.rb;TiLI"µ          @var ||= Compass.configuration.sprite_engine.to_s.scan(/([^_.]+)/).flatten.map do |arglist|
            "STRING"
          end.join
        end
      end
    end
  end
end;Fi[	I"Idata//compass_proj/compass/sass_extensions/sprites/sprite_methods.rb;TiÄI"¯        def function(arglist)
          if options[:compass] and (options[:compass][:logger] and options[:quiet].!) then
            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	@iÅI"⁄          if options[:compass] and (options[:compass][:logger] and options[:quiet].!) then
            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/ast/outline_table.rb;Ti∞I"j        
        def function(arglist)
          (index == 0)
        end
      end
    end
  end
end;Fi[	I".data//cucumber_prok/cucumber/ast/table.rb;Ti}I"b        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	I"-data//cucumber_prok/cucumber/cli/main.rb;TiNI"ú          exit!(1) if Cucumber.wants_to_quit
          Cucumber.wants_to_quit = true
          STDERR.puts("STRING")
        end
      end
    end
  end
end;Fi[	I"3data//cucumber_prok/cucumber/formatter/html.rb;Ti+I"p            (var << var)
          end
          var.join("STRING")
        end
      end
    end
  end
end;Fi[	I":data//cucumber_prok/cucumber/formatter/interceptor.rb;Ti>I"}            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@,i?I"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"Adata//cucumber_prok/cucumber/formatter/ordered_xml_markup.rb;TiI"ó        var.each do |arglist|
          var = (var[var.to_sym] or var[var])
          (@var << "STRING") if var
        end
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/formatter/unicode.rb;TiDI"Ï              rescue Iconv::IllegalSequence => var
                STDERR.cucumber_puts("STRING")
                cucumber_puts(*var)
              end
            end
          end
        end
      end
      
      Kernel.extend(self);Fi[	I"4data//cucumber_prok/cucumber/formatter/usage.rb;TixI"¡        @var.unmatched_step_definitions.each do |arglist|
          var = StepDefKey.new(var.regexp_source, var.file_colon_line)
          @var[var] = []
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/js_support/js_language.rb;TißI"ä        else
          var = var[0][/(^.*\/?features)/, 0]
          var ? ("STRING") : ("STRING")
        end
      end
    end
  end
end;Fi[	I"Fdata//cucumber_prok/cucumber/language_support/language_methods.rb;TipI"ó          var.invoke(var, var, &var)
        rescue Exception => var
          var ? (var.fail!(var)) : (raise)
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/parser/gherkin_builder.rb;TiOI"f          end
          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/rb_support/rb_language.rb;Ti•I"U          end
        else
          var
        end
      end
    end
  end
end;Fi[	I"Gdata//cucumber_prok/cucumber/rb_support/regexp_argument_matcher.rb;TiI"U          end
        else
          nil
        end
      end
    end
  end
end;Fi[	I"@data//cucumber_prok/cucumber/rspec/disable_option_parser.rb;TiI"é          @var = true
          define_method(var) { |arglist| NEUTERED_RSPEC }
          @var = false
        end
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/runtime/results.rb;Ti1I"⁄          scenarios(:passed).any?
        else
          (scenarios(:failed).any? or (steps(:failed).any? or (@var.strict? and (steps(:undefined).any? or steps(:pending).any?))))
        end
      end
    end
  end
end;Fi[	I"9data//cucumber_prok/cucumber/runtime/support_code.rb;Ti≥I"U          end
        else
          nil
        end
      end
    end
  end
end;Fi[	I"<data//cucumber_prok/cucumber/wire_support/connection.rb;Ti8I"≥          @var ||= TCPSocket.new(@var.host, @var.port)
        rescue Errno::ECONNREFUSED => var
          raise(ConnectionError, "STRING")
        end
      end
    end
  end
end;Fi[	I"Hdata//cucumber_prok/cucumber/wire_support/wire_protocol/requests.rb;TipI"á          
          def function(arglist)
            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	@UiqI"|          def function(arglist)
            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	I"9data//devise_proj/devise/controllers/scoped_views.rb;TiI"h        
        def function(arglist)
          @var = var
        end
      end
    end
  end
end;Fi[	I"(data//devise_proj/devise/mapping.rb;TiÇI"á          @var = (self.routes - Array(var).map(&var))
        else
          @var = self.routes
        end
      end
    end
  end
end;Fi[	I"7data//devise_proj/devise/models/authenticatable.rb;Ti≈I"∫          loop do |arglist|
            var = Devise.friendly_token
            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	@`i∆I"û            var = Devise.friendly_token
            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	I"@data//devise_proj/devise/models/database_authenticatable.rb;TijI"â        # the proper fields.
        def function(arglist)
          find_for_authentication(var)
        end
      end
    end
  end
end;Fi[	I"4data//devise_proj/devise/models/registerable.rb;TiI"x        # new with params.
        def function(arglist)
          new(var)
        end
      end
    end
  end
end;Fi[	I"0data//devise_proj/devise/omniauth/config.rb;Ti,I"ã          ::OmniAuth::Strategies.const_get(var)
        else
          raise(StrategyNotFound, var)
        end
      end
    end
  end
end;Fi[	I"&data//devise_proj/devise/rails.rb;Ti,I"¿        # We can get rid of this once we support only Rails > 3.2
        def function(arglist)
          (super or routes.url_helpers.respond_to?(var))
        end
      end
    end
  end
end;Fi[	I"Ddata//devise_proj/devise/strategies/database_authenticatable.rb;TiI"        if validate(var) { |arglist| var.valid_password?(password) } then
          var.after_database_authentication
          success!(var)
        end
      end
    end
  end
end
Warden::Strategies.add(:database_authenticatable, Devise::Strategies::DatabaseAuthenticatable);Fi[	I">data//diaspora_proj/controllers/application_controller.rb;TigI"î          unless var.nil? then
            @var = var
            break
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"8data//diaspora_proj/controllers/likes_controller.rb;Ti7I"Í      Comment.find(params[:comment_id]).tap do |arglist|
        unless current_user.find_visible_shareable_by_id(Post, var.commentable_id) then
          raise(ActiveRecord::RecordNotFound.new)
        end
      end
    end
  end
end;Fi[	I"8data//diaspora_proj/controllers/users_controller.rb;TiKI"Ò                    flash[:notice] = I18n.t("STRING")
                  else
                    flash[:error] = I18n.t("STRING")
                  end
                end
              end
            end
          end
        end
      end;Fi[	@ziLI"ƒ                  else
                    flash[:error] = I18n.t("STRING")
                  end
                end
              end
            end
          end
        end
      end
    else;Fi[	@ziMI"⁄                    flash[:error] = I18n.t("STRING")
                  end
                end
              end
            end
          end
        end
      end
    else
      if var = params[:reorder_aspects] then;Fi[	I"0data//diaspora_proj/helpers/posts_helper.rb;TiI"Ù        else
          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("STRING", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"1data//diaspora_proj/helpers/stream_helper.rb;TiI"µ            stream_path(:max_time => (time_for_scroll(@var)))
          else
            raise("STRING")
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"2data//diaspora_proj/models/jobs/http_multi.rb;TiI"±          Resque.enqueue(Jobs::HttpMulti, var, var, var.failed_people, var, (var + 1))
        else
          Rails.logger.info("STRING")
        end
      end
    end
  end
end;Fi[	I";data//diaspora_proj/models/jobs/mail/also_commented.rb;TiI"ö      def self.perform(arglist)
        if var = Notifier.also_commented(var, var, var) then
          var.deliver
        end
      end
    end
  end
end;Fi[	I"%data//haml_proj/haml/compiler.rb;TiI"æ              "STRING"
            else
              "STRING"
            end
          end
        end
      end
    end
    
    # Evaluates `text` in the context of the scope object, but;Fi[	I"$data//haml_proj/haml/filters.rb;TiI"±      class << self
        def function(arglist)
          super.sub(/^#coding:.*?\n/, "STRING")
        end
      end
    end
  end
end
begin
  (require("haml/filters/maruku");Fi[	I"#data//homebrew_proj/cleaner.rb;Ti:I"»              var.unlink unless @var.skip_clean?(var)
            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end;Fi[	@ìi;I"°            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end
class Pathname;Fi[	@ìi<I"∂              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end
class Pathname
  alias_method(:orig_unlink, :unlink);Fi[	I"'data//homebrew_proj/cmd/cleanup.rb;TiJI"ä          else
            puts("STRING")
            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"&data//homebrew_proj/cmd/search.rb;Ti3I"‚          if ($found == 0) and blacklisted?(var).! then
            puts("STRING")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@ùiUI"ø        if var.include?(var) then
          var = ((HOMEBREW_REPOSITORY + "STRING") + var).readlink.basename("STRING").to_s
          var.include?(var)
        end
      end
    end
  end
end;Fi[	I"(data//homebrew_proj/cmd/versions.rb;TiI"†          print("STRING")
          print(Tty.reset.to_s)
          puts("STRING")
        end
      end
    end
  end
end
class Formula
  def function(arglist);Fi[	I",data//homebrew_proj/extend/fileutils.rb;TiCI"            end
          else
            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	@•iDI"o          else
            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	I"+data//homebrew_proj/extend/pathname.rb;TiI"°            raise("STRING".undent)
          else
            raise("STRING".undent)
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"data//homebrew_proj/keg.rb;TiÒI"ƒ            unless resolve_any_conflicts(var) then
              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end
end;Fi[	@≠iÚI"≤              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	@≠iÛI"              Find.prune
            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	I"1data//homebrew_proj/keg_fix_install_names.rb;TiI"·                  system(MacOS.locate("STRING"), "STRING", var, var, var)
                else
                  opoo("STRING")
                end
              end
            end
          end
        end
      end
    end;Fi[	@¥iI"ù                else
                  opoo("STRING")
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@¥iI"ã                  opoo("STRING")
                end
              end
            end
          end
        end
      end
    end
  end
  ;Fi[	@¥iI"y                end
              end
            end
          end
        end
      end
    end
  end
  
  private;Fi[	I"Jdata//homebrew_proj/vendor/multi_json/adapters/nsjsonserialization.rb;Ti I"•          NSMutableString.alloc.initWithData(var, :encoding => (NSUTF8StringEncoding))
        else
          super(var, var)
        end
      end
    end
  end
end;Fi[	I">data//homebrew_proj/vendor/multi_json/adapters/ok_json.rb;Ti)I"U          end
        else
          var
        end
      end
    end
  end
end;Fi[	I",data//jekyll_proj/jekyll/convertible.rb;TiYI"ú        end
        if var = var[var.data["STRING"]] then
          var.include?(var) ? (var = nil) : ((var << var))
        end
      end
    end
  end
end;Fi[	I"1data//jekyll_proj/jekyll/migrators/drupal.rb;Ti2I"®              var.puts("STRING")
              var.puts("STRING")
              var.puts("STRING")
            end
          end
        end
      end
    end
  end
end;Fi[	@∆i3I"á              var.puts("STRING")
              var.puts("STRING")
            end
          end
        end
      end
    end
  end
end;Fi[	@∆i4I"k              var.puts("STRING")
            end
          end
        end
      end
    end
  end
end;Fi[	I"/data//jekyll_proj/jekyll/migrators/enki.rb;TiI"ã          end.to_yaml)
          var.puts("STRING")
          var.puts(var[:body].delete("STRING"))
        end
      end
    end
  end
end;Fi[	I"1data//jekyll_proj/jekyll/migrators/joomla.rb;TiI"y          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"3data//jekyll_proj/jekyll/migrators/mephisto.rb;Ti&I"y          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"-data//jekyll_proj/jekyll/migrators/mt.rb;Ti,I"î          "STRING"
        else
          ((var == "STRING") or var.include?("STRING")) ? ("STRING") : (var)
        end
      end
    end
  end
end;Fi[	I".data//jekyll_proj/jekyll/migrators/rss.rb;TiI"à          var.puts(var.to_yaml)
          var.puts("STRING")
          var.puts(var.description)
        end
      end
    end
  end
end;Fi[	I"6data//jekyll_proj/jekyll/migrators/textpattern.rb;TiI"y          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"/data//jekyll_proj/jekyll/migrators/typo.rb;TiI"ã          end.to_yaml)
          var.puts("STRING")
          var.puts(var[:body].delete("STRING"))
        end
      end
    end
  end
end;Fi[	I"4data//jekyll_proj/jekyll/migrators/wordpress.rb;TiHI"ˇ                (var << clean_entities(var[:name]))
              else
                (var << var[:name])
              end
            end
          end
        end
      end
      var = []
      if var[:comments] and (var[:comment_count].to_i > 0) then;Fi[	I"%data//jekyll_proj/jekyll/site.rb;Ti~I"$              (pages << Page.new(self, self.source, var, var))
            else
              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    
    # Read all the files in <source>/<dir>/_posts and create a new Post;Fi[	I"-data//jekyll_proj/jekyll/tags/include.rb;TiI"µ          var.stack { |arglist| var.render(var) }
        else
          "STRING"
        end
      end
    end
  end
end
Liquid::Template.register_tag("STRING", Jekyll::IncludeTag);Fi[	I"Adata//mongoid_proj/lib/mongoid/atomic/paths/embedded/many.rb;Ti'I"¥            var = parent.atomic_position
            var = document.new_record? ? ("STRING") : ("STRING")
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@Îi(I"ã            var = document.new_record? ? ("STRING") : ("STRING")
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/atomic/paths/embedded/one.rb;Ti&I"ì          def function(arglist)
            var = parent.atomic_position
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@i'I"x            var = parent.atomic_position
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/atomic/paths/embedded.rb;TiBI"ñ        
        def function(arglist)
          document._root.updates_requested?.! and only_root_selector?.!
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/atomic/paths/root.rb;Ti/I"©        # @since 2.1.0
        def function(arglist)
          { "STRING" => (document._id) }.merge!(document.shard_key_selector)
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/attributes/processing.rb;TiºI"y          yield)
        ensure
          self.mass_assignment_options = nil
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/attributes/readonly.rb;Ti2I"ü        # @since 3.0.0
        def function(arglist)
          var.each { |arglist| (readonly_attributes << var.to_s) }
        end
      end
    end
  end
end;Fi[	I"1data//mongoid_proj/lib/mongoid/components.rb;Ti\I"Æ      def function(arglist)
        @var ||= MODULES.flat_map do |arglist|
          var.instance_methods.map { |arglist| var.to_sym }
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/config/validators/option.rb;TiI"À        def function(arglist)
          unless Config.settings.keys.include?(var.to_sym) then
            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	@iI"≠          unless Config.settings.keys.include?(var.to_sym) then
            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/config/validators/session.rb;Ti|I"∑        # @since 3.0.0
        def function(arglist)
          var.has_key?(:uri) and var.keys.any? { |arglist| STANDARD.include?(var.to_sym) }
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/contextual/aggregable/memory.rb;TijI"Æ        # @since 3.0.0
        def function(arglist)
          (count > 0) ? (send(var) { |arglist| var.send(var) }.send(var)) : (nil)
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/contextual/aggregable/mongo.rb;TiïI"t        # @since 3.0.0
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/eager.rb;TióI"´          var = Factory.from_db(klass, var, criteria.object_id)
          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/contextual/find_and_modify.rb;TiCI"        end
        if var = criteria.options[:fields] then
          query.select(var)
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/contextual/map_reduce.rb;Ti1I"{          session.with(:consistency => :strong)
        else
          session
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/criterion/scoping.rb;TiëI"ƒ        var.each do |arglist|
          send(var).reject! do |arglist|
            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	@iíI"¶          send(var).reject! do |arglist|
            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	I",data//mongoid_proj/lib/mongoid/dirty.rb;Ti]I"ø      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| reset_attribute!(var) }
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/document_not_found.rb;TiUI"_          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/array.rb;Ti•I"Ê        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array)
::Array.__send__(:extend, Mongoid::Extensions::Array::ClassMethods);Fi[	I"=data//mongoid_proj/lib/mongoid/extensions/big_decimal.rb;Ti=I"        # @since 3.0.7
        def function(arglist)
          var ? (var.to_s) : (var)
        end
      end
    end
  end
end
::BigDecimal.__send__(:include, Mongoid::Extensions::BigDecimal)
::BigDecimal.__send__(:extend, Mongoid::Extensions::BigDecimal::ClassMethods);Fi[	I"9data//mongoid_proj/lib/mongoid/extensions/boolean.rb;TiI"∫        # @since 3.0.0
        def function(arglist)
          evolve(var)
        end
      end
    end
  end
end
::Boolean.__send__(:extend, Mongoid::Extensions::Boolean::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/date.rb;Ti?I"Ë          unless var.blank? then
            var = var.__mongoize_time__
            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end
::Date.__send__(:include, Mongoid::Extensions::Date);Fi[	@/i@I"	            var = var.__mongoize_time__
            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end
::Date.__send__(:include, Mongoid::Extensions::Date)
::Date.__send__(:extend, Mongoid::Extensions::Date::ClassMethods);Fi[	I";data//mongoid_proj/lib/mongoid/extensions/date_time.rb;TiCI"        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::DateTime.__send__(:include, Mongoid::Extensions::DateTime)
::DateTime.__send__(:extend, Mongoid::Extensions::DateTime::ClassMethods);Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/float.rb;Ti.I"        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0)
        end
      end
    end
  end
end
::Float.__send__(:include, Mongoid::Extensions::Float)
::Float.__send__(:extend, Mongoid::Extensions::Float::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/hash.rb;Ti¬I"‚        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash)
::Hash.__send__(:extend, Mongoid::Extensions::Hash::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/object.rb;TiI"Ú        # @since 3.0.0
        def function(arglist)
          var.mongoize
        end
      end
    end
  end
end
::Object.__send__(:include, Mongoid::Extensions::Object)
::Object.__send__(:extend, Mongoid::Extensions::Object::ClassMethods);Fi[	I";data//mongoid_proj/lib/mongoid/extensions/object_id.rb;Ti1I"        # @since 3.0.0
        def function(arglist)
          var.__mongoize_object_id__
        end
      end
    end
  end
end
Moped::BSON::ObjectId.__send__(:include, Mongoid::Extensions::ObjectId)
Moped::BSON::ObjectId.__send__(:extend, Mongoid::Extensions::ObjectId::ClassMethods);Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/range.rb;TiII"*        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : ({ "STRING" => (var.first), "STRING" => (var.last) })
        end
      end
    end
  end
end
::Range.__send__(:include, Mongoid::Extensions::Range)
::Range.__send__(:extend, Mongoid::Extensions::Range::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/regexp.rb;TiI"æ        # @since 3.0.0
        def function(arglist)
          ::Regexp.new(var)
        end
      end
    end
  end
end
::Regexp.__send__(:extend, Mongoid::Extensions::Regexp::ClassMethods);Fi[	I"5data//mongoid_proj/lib/mongoid/extensions/set.rb;Ti1I"‚        # @since 3.0.0
        def function(arglist)
          var.to_a
        end
      end
    end
  end
end
::Set.__send__(:include, Mongoid::Extensions::Set)
::Set.__send__(:extend, Mongoid::Extensions::Set::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/string.rb;Ti¿I"ı        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::String.__send__(:include, Mongoid::Extensions::String)
::String.__send__(:extend, Mongoid::Extensions::String::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/symbol.rb;Ti0I"ı        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::Symbol.__send__(:include, Mongoid::Extensions::Symbol)
::Symbol.__send__(:extend, Mongoid::Extensions::Symbol::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/time.rb;TiII"„            ::Time.at(var.to_i, var).utc)
          rescue ArgumentError
            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end
::Time.__send__(:include, Mongoid::Extensions::Time);Fi[	@RiJI"˚          rescue ArgumentError
            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end
::Time.__send__(:include, Mongoid::Extensions::Time)
::Time.__send__(:extend, Mongoid::Extensions::Time::ClassMethods);Fi[	I"@data//mongoid_proj/lib/mongoid/extensions/time_with_zone.rb;Ti2I"0        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::ActiveSupport::TimeWithZone.__send__(:include, Mongoid::Extensions::TimeWithZone)
::ActiveSupport::TimeWithZone.__send__(:extend, Mongoid::Extensions::TimeWithZone::ClassMethods);Fi[	I"7data//mongoid_proj/lib/mongoid/fields/localized.rb;TiEI"ô          var[::I18n.fallbacks[var].map(&:to_s).find { |arglist| var[var] }]
        else
          var[var.to_s]
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/fields/validators/macro.rb;TiCI"          var.keys.each do |arglist|
            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	@]iDI"‡            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	@]iEI"ë              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/indexes/validators/options.rb;TiLI"⁄            next if (var == :options)
            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	@diMI"¥            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	@diNI"Ç              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/matchers/default.rb;TiGI"ß      def function(arglist)
        attribute.__array__.any? do |arglist|
          var ? (var.send(var, first(var))) : (false)
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/matchers/strategies.rb;TiRI"e          end
        else
          var.attributes[var]
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/nested_attributes.rb;Ti4I"Ê          re_define_method(var) do |arglist|
            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	@qi5I"π            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	@qi6I"ï              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/atomic/add_to_set.rb;Ti)I"∫        # @since 2.0.0
        def function(arglist)
          { var => ({ path => (value.is_a?(Array) ? ({ "STRING" => (value) }) : (value)) }) }
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/bit.rb;TiI"            end
            execute("STRING")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@{iI"t            execute("STRING")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/inc.rb;Ti*I"|        # @since 3.0.3
        def function(arglist)
          value.__to_inc__
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/persistence/atomic/operation.rb;TiâI"ù            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	@ÉiäI"c            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/pop.rb;TiI"´              (value > 0) ? (var.pop) : (var.shift)
              execute("STRING")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@àiI"|              execute("STRING")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@àiI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/pull.rb;TiI"ó              var.delete(value)
              execute("STRING")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@èiI"|              execute("STRING")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@èiI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/persistence/atomic/pull_all.rb;TiI"µ              var.delete_if { |arglist| value.include?(var) }
              execute("STRING")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@ñiI"|              execute("STRING")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@ñiI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/push.rb;TiI"|        # @since 2.0.0
        def function(arglist)
          append_with("STRING")
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/persistence/atomic/push_all.rb;TiI"|        # @since 2.1.0
        def function(arglist)
          append_with("STRING")
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/persistence/atomic/rename.rb;TiI"ô            execute("STRING")
            document.remove_change(value)
            document[value]
          end
        end
      end
    end
  end
end;Fi[	@£iI"{            document.remove_change(value)
            document[value]
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/sets.rb;TiI"ì            document[field] = value
            execute("STRING")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@®iI"t            execute("STRING")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/persistence/atomic/unset.rb;TiI"∏          prepare do |arglist|
            fields.each { |arglist| document.attributes.delete(var) }
            execute("STRING")
          end
        end
      end
    end
  end
end;Fi[	@≠iI"ô            fields.each { |arglist| document.attributes.delete(var) }
            execute("STRING")
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/insert.rb;TiI"Ã                parent.insert
              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end;Fi[	@≤iI"≤              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@≤iI"ü                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@≤iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/remove.rb;TiI"ˇ              parent.remove_child(var) if notifying_parent?
              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end;Fi[	@ªiI"«              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ªiI"ü                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ªiI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/insert.rb;TiI"§          prepare do |arglist|
            collection.insert(var.as_document)
            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	@ƒiI"Ö            collection.insert(var.as_document)
            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/remove.rb;TiI"π        # @return [ true ] Always true.
        def function(arglist)
          prepare { |arglist| collection.find(var.atomic_selector).remove }
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/update.rb;TiI"˘              collection.find(selector).update(updates)
              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end;Fi[	@ÃiI"≈              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÃiI"ñ                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÃiI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/upsert.rb;TiI"¿        def function(arglist)
          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	@’iI"¢          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/accessors.rb;Ti˝I"á            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/auto_save.rb;TiXI"£        # @since 3.0.0
        def function(arglist)
          autosaved_relations.include?(var.name).! and var.embedded?.!
        end
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/bindings/embedded/in.rb;Ti8I"˚                target.do_or_do_not(metadata.inverse(target)).delete(base)
              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end;Fi[	@‡i9I"¥              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@‡i:I"°                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@‡i;I"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/many.rb;Ti-I"Ã          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	@Èi.I"Æ          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/one.rb;Ti1I"Œ          def function(arglist)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ói2I"Æ            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ói3I"ç              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/in.rb;Ti!I"l                    target.__send__(var).push(base) unless Mongoid.using_identity_map?
                  else
                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the;Fi[	@ıi>I"€                  target.__send__(var).delete(base)
                else
                  target.__send__("STRING", nil)
                end
              end
            end
          end
        end
      end
    end;Fi[	@ıi?I"≠                else
                  target.__send__("STRING", nil)
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@ıi@I"ú                  target.__send__("STRING", nil)
                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ıiAI"p                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ıiBI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many.rb;Ti!I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	@i"I"ö          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many_to_many.rb;Ti/I"Ã              end
              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	@i0I"∫              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	@i1I"É              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/one.rb;Ti#I"ª          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	@i$I"ù          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/builders/embedded/in.rb;TiI"Æ              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"u              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/embedded/many.rb;Ti!I"l              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	@i"I"Z            end
            var
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/builders/embedded/one.rb;TiI"Æ              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"u              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Pdata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/many.rb;Ti®I"≤              var.assign_attributes(var, var)
            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	@&i©I"Ñ            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	@&i™I"x              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	I"Odata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/one.rb;Ti~I"´          # @since 2.0.0
          def function(arglist)
            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	@-iI"í          def function(arglist)
            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/referenced/in.rb;TiI"‘            return object unless query?
            var = var ? (var.constantize) : (metadata.klass)
            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@2iI"¨            var = var ? (var.constantize) : (metadata.klass)
            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/builders/referenced/many.rb;TiI"˘            return [] if object.is_a?(Array)
            var = metadata.criteria(Conversions.flag(object, metadata), base.class)
            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	@7iI"Ã            var = metadata.criteria(Conversions.flag(object, metadata), base.class)
            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/builders/referenced/many_to_many.rb;Ti%I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	@<i&I"ö          def function(arglist)
            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/builders/referenced/one.rb;TiI"Â            return object unless query?
            return nil if base.new_record?
            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@AiI"Ω            return nil if base.new_record?
            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/relations/builders.rb;TiUI"Y            var
          end
          self
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/relations/cascading/delete.rb;Ti(I"∂              relation.clear
            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	@Ii)I"ô            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	@Ii*I"à              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/destroy.rb;Ti'I"´              relation.each { |arglist| var.destroy }
            else
              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	@Pi(I"z            else
              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	@Pi)I"i              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/nullify.rb;Ti!I"â        #   strategy.cascade
        def function(arglist)
          relation.nullify if relation
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/cascading/restrict.rb;Ti#I"√        def function(arglist)
          unless relation.blank? then
            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	@Zi$I"•          unless relation.blank? then
            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/cascading.rb;Ti4I"ç        def function(arglist)
          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/relations/constraint.rb;Ti+I"ó            var.map! { |arglist| var.mongoize(var) }
          else
            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	@bi,I"g          else
            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/conversions.rb;TiI"Ç        else
          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/relations/cyclic.rb;Ti^I"Ã        # @since 2.0.0.rc.1
        def function(arglist)
          ("STRING" << self.name.demodulize.underscore.send((var ? (:pluralize) : (:singularize)))).to_sym
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/embedded/batchable.rb;TiBI"ë            var.freeze
            var.destroyed = true
            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	@miCI"            var.destroyed = true
            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/relations/macros.rb;TiMI"…        def function(arglist)
          self.relations = relations.merge(var.to_s => (var))
          getter(var, var).setter(var, var).existence_check(var, var)
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/options.rb;TiI"¬        var.keys.each do |arglist|
          if var.include?(var).! then
            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	@uiI"ü          if var.include?(var).! then
            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/polymorphic.rb;Ti!I"Y            end
          end
          self
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/reflections.rb;Ti9I"”        # @return [ Array<Metadata> ] The matching relation metadata.
        def function(arglist)
          relations.values.select { |arglist| var.include?(var.macro) }
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/relations/synchronization.rb;TiçI"®        def function(arglist)
          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/targets/enumerable.rb;Ti∑I"ü        
        def function(arglist)
          _unloaded.selector.values.any?(&:blank_criteria?) ? ([]) : (_unloaded)
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/touchable.rb;TiI"è        def function(arglist)
          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	I".data//mongoid_proj/lib/mongoid/scoping.rb;Ti2I"]          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/sessions/validators/storage.rb;Ti,I"û        # @since 3.0.0
        def function(arglist)
          var.keys.all? { |arglist| VALID_OPTIONS.include?(var) }
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/threaded/lifecycle.rb;Ti¬I"Ñ        # @since 2.3.4
        def function(arglist)
          Threaded.executing?("STRING")
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/timestamps/created/short.rb;TiI"†          include(Created)
          fields.delete("STRING")
          field(:c_at, :type => (Time), :as => :created_at)
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/timestamps/created.rb;TiI"∞          var = Time.now.utc
          self.updated_at = var if is_a?(Updated) and updated_at_changed?.!
          self.created_at = var
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/timestamps/timeless.rb;Ti/I"|        def function(arglist)
          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/timestamps/updated/short.rb;TiI"†          include(Updated)
          fields.delete("STRING")
          field(:u_at, :type => (Time), :as => :updated_at)
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/validations/localizable.rb;TiI"Å          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/validations/queryable.rb;TiI"ß        ensure
          (klass.clear_persistence_options unless var.errors.empty?
          Threaded.exit_execution("STRING"))
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/rack/mongoid/middleware/identity_map.rb;Ti!I"ö        # @since 2.1.0
        def function(arglist)
          ::Mongoid.unit_of_work { |arglist| @var.call(var) }
        end
      end
    end
  end
end;Fi[	I"6data//nokogiri_proj/nokogiri/css/xpath_visitor.rb;TiîI"Ç        else
          var = (var < 0) ? ("STRING") : ("STRING")
          return "STRING"
        end
      end
    end
  end
end;Fi[	I"2data//nokogiri_proj/nokogiri/html/document.rb;Ti«I"ƒ          var = @var.slice!(0, var)
          var = @var.read(var) and (var << var) if ((var = (var - var.length)) > 0)
          var.empty? ? (nil) : (var)
        end
      end
    end
  end
end;Fi[	I"4data//nokogiri_proj/nokogiri/html/sax/parser.rb;TiI"ò          var = ParserContext.file(var, var)
          yield(var) if block_given?
          var.parse_with(self)
        end
      end
    end
  end
end;Fi[	I"<data//nokogiri_proj/nokogiri/html/sax/parser_context.rb;TiI"x            super
          else
            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	@∞iI"f          else
            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"9data//nokogiri_proj/nokogiri/html/sax/push_parser.rb;TiI"õ          @var = var
          @var = HTML::SAX::Parser.new(var, @var)
          initialize_native(@var, var, @var)
        end
      end
    end
  end
end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/builder.rb;Ti•I"`            return var
          end
          self
        end
      end
    end
  end
end;Fi[	I":data//nokogiri_proj/nokogiri/xml/pp/character_data.rb;TiI"o        # :nodoc:
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/pp/node.rb;Ti1I"v              end
            end
            var.breakable
          end
        end
      end
    end
  end
end;Fi[	@æi2I"d            end
            var.breakable
          end
        end
      end
    end
  end
end;Fi[	I"/data//nokogiri_proj/nokogiri/xml/reader.rb;TieI"~      def function(arglist)
        while var = self.read do
          yield(var)
        end
      end
    end
  end
end;Fi[	I"5data//nokogiri_proj/nokogiri/xml/sax/document.rb;TinI"ê        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"3data//nokogiri_proj/nokogiri/xml/sax/parser.rb;Ti_I"û        def function(arglist)
          var.upcase!
          raise(ArgumentError.new("STRING")) unless ENCODINGS[var]
        end
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/xml/sax/parser_context.rb;TiI"à            io(var, Parser::ENCODINGS[var])
          else
            memory(var)
          end
        end
      end
    end
  end
end;Fi[	@ÃiI"a          else
            memory(var)
          end
        end
      end
    end
  end
end;Fi[	I"8data//nokogiri_proj/nokogiri/xml/sax/push_parser.rb;Ti%I"ß        # Nokogiri::XML::SAX::Document#end_document to be called.
        def function(arglist)
          write("STRING", true)
        end
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/xml/xpath/syntax_error.rb;TiI"•      class SyntaxError < XML::SyntaxError
        def function(arglist)
          [super.chomp, str1].compact.join("STRING")
        end
      end
    end
  end
end;Fi[	I"6data//nokogiri_proj/nokogiri/xml/xpath_context.rb;TiI"î        var.each do |arglist|
          var = var.to_s.gsub(/.*:/, "STRING")
          register_ns(var, var)
        end
      end
    end
  end
end;Fi[	I"5data//omni_proj/omniauth/strategies/developer.rb;TiI"í        options.fields.inject({}) do |arglist|
          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	I"5data//omni_proj/omniauth/test/strategy_macros.rb;TiI"∞      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
    end
  end
end;Fi[	I"Jdata//paperclip_proj/paperclip/matchers/have_attached_file_matcher.rb;Ti7I"å        
        def function(arglist)
          @var.ancestors.include?(Paperclip::InstanceMethods)
        end
      end
    end
  end
end;Fi[	I"Xdata//paperclip_proj/paperclip/matchers/validate_attachment_content_type_matcher.rb;Ti\I"ö        def function(arglist)
          @var ||= @var.select { |arglist| type_allowed?(var) }
          @var.none?
        end
      end
    end
  end
end;Fi[	I"Tdata//paperclip_proj/paperclip/matchers/validate_attachment_presence_matcher.rb;Ti6I"ç          @var.send(@var).assign(@var)
          @var.valid?
          @var.errors[:"#{@var}"].blank?
        end
      end
    end
  end
end;Fi[	I"Pdata//paperclip_proj/paperclip/matchers/validate_attachment_size_matcher.rb;TibI"∞        
        def function(arglist)
          (@var.nil? or ((@var == Float::INFINITY) or passes_validation_with_size((@var + 1)).!))
        end
      end
    end
  end
end;Fi[	I"1data//paperclip_proj/paperclip/storage/s3.rb;TiI"«            var[$1.downcase] = var
          else
            var[var.to_s.downcase.sub(/^x-amz-/, "STRING").tr("STRING", "STRING").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	@ÏiI"§          else
            var[var.to_s.downcase.sub(/^x-amz-/, "STRING").tr("STRING", "STRING").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	I"Zdata//redmine_proj/plugins/acts_as_activity_provider/lib/acts_as_activity_provider.rb;Ti:I"É              end
            end
            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	@Òi;I"v            end
            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	I"Ldata//redmine_proj/plugins/acts_as_attachable/lib/acts_as_attachable.rb;Ti]I"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Pdata//redmine_proj/plugins/acts_as_customizable/lib/acts_as_customizable.rb;TiáI"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Bdata//redmine_proj/plugins/acts_as_event/lib/acts_as_event.rb;Ti@I"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Kdata//redmine_proj/plugins/acts_as_list/lib/active_record/acts/list.rb;Ti÷I"™          remove_from_list
          increment_positions_on_lower_items(var)
          self.update_attribute(position_column, var)
        end
      end
    end
  end
end;Fi[	I"Ldata//redmine_proj/plugins/acts_as_searchable/lib/acts_as_searchable.rb;TiZI"™            var = var.where("STRING", var[:offset]) if var[:offset]
            var = var.all
            [var, var]
          end
        end
      end
    end
  end
end;Fi[	@i[I"k            var = var.all
            [var, var]
          end
        end
      end
    end
  end
end;Fi[	I"Kdata//redmine_proj/plugins/acts_as_tree/lib/active_record/acts/tree.rb;TiPI"√        #   subchild1.self_and_siblings # => [subchild1, subchild2]
        def function(arglist)
          parent ? (parent.children) : (self.class.roots)
        end
      end
    end
  end
end;Fi[	I"Jdata//redmine_proj/plugins/acts_as_watchable/lib/acts_as_watchable.rb;TiTI"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"_data//redmine_proj/plugins/awesome_nested_set/lib/awesome_nested_set/awesome_nested_set.rb;TiæI"£        
        def function(arglist)
          scope_column_names.collect { |arglist| connection.quote_column_name(var) }
        end
      end
    end
  end
end;Fi[	I"Sdata//redmine_proj/plugins/awesome_nested_set/lib/awesome_nested_set/helper.rb;Ti(I"a            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	I"Ydata//redmine_proj/plugins/awesome_nested_set/test/awesome_nested_set/helper_test.rb;TiI"Ô          var = [["STRING", 1], ["STRING", 2], ["STRING", 5], ["STRING", 6]]
          var = nested_set_options(Category, categories(:child_2)) { |arglist| "STRING" }
          assert_equal(var, var)
        end
      end
    end
  end
end;Fi[	I"2data//redmine_proj/plugins/rfpdf/lib/tcpdf.rb;TiÅI"ﬂ          else
            var = ("STRING" + var.downcase)
            self.respond_to?(var).! ? (Error(("STRING" + var))) : (self.send(var, var))
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@i”I"                var.gsub!(/[\t\r\n\f]/, "STRING")
                var.gsub!(/&nbsp;/, "STRING")
                Write(@var, unhtmlentities(var), "STRING", var)
              end
            end
          end
        end
      end
    end
    Ln(@var) if var;Fi[	@i‘I"’                var.gsub!(/&nbsp;/, "STRING")
                Write(@var, unhtmlentities(var), "STRING", var)
              end
            end
          end
        end
      end
    end
    Ln(@var) if var
  end;Fi[	I"/data//redmine_proj/redmine/codeset_util.rb;TiÜI"s            var = (var + $!.success)
          end
          var = var
        end
      end
    end
  end
end;Fi[	I"=data//redmine_proj/redmine/core_ext/date/calculations.rb;TiI"ƒ        # Returns difference with specified date in weeks
        def function(arglist)
          (((var.year - self.year) * 52) + (var.cweek - self.cweek))
        end
      end
    end
  end
end;Fi[	I">data//redmine_proj/redmine/core_ext/string/conversions.rb;TiI"ó          # Object#to_a removed in ruby1.9
          def function(arglist)
            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	@#iI"q          def function(arglist)
            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	I">data//redmine_proj/redmine/core_ext/string/inflections.rb;TiI"ï      module Inflections
        def function(arglist)
          starts_with?("STRING") ? (self) : ("STRING")
        end
      end
    end
  end
end;Fi[	I"-data//redmine_proj/redmine/export/pdf.rb;Ti/I"ƒ                  var[var] = var[var]
                  var[var] = 1
                  var = 0
                end
              end
            end
          end
        end
        var
      end;Fi[	@+i´I"w            return var
          else
            return nil
          end
        end
      end
    end
  end
end;Fi[	@+i¨I"`          else
            return nil
          end
        end
      end
    end
  end
end;Fi[	I"0data//redmine_proj/redmine/helpers/gantt.rb;TiRI"G                  var[:bar_late_end] = ((var - self.date_from) + 1)
                else
                  var[:bar_late_end] = ((self.date_to - self.date_from) + 1)
                end
              end
            end
          end
        end
        var.keys.each { |arglist| var[var] = (var[var] * var).floor }
        var;Fi[	@2i0I"’        if var[:label] then
          var[:image].fill("STRING")
          var[:image].text(((var[:subject_width] + (var[:bar_end] or 0)) + 5), (var[:top] + 1), var[:label])
        end
      end
    end
  end
end;Fi[	I"Bdata//redmine_proj/redmine/scm/adapters/filesystem_adapter.rb;TiUI"§        def function(arglist)
          return "STRING" if var and var.match(/(^|\/)\.\.(\/|$)/).!
          return self.url
        end
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/views/builders/json.rb;TiI"u            response.content_type = "STRING"
          end
          var
        end
      end
    end
  end
end;Fi[	I";data//redmine_proj/redmine/views/builders/structure.rb;Ti@I"m        
        def function(arglist)
          raise("STRING")
        end
      end
    end
  end
end;Fi[	I"5data//redmine_proj/redmine/views/builders/xml.rb;TiI"í        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "STRING"), &var)
        end
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/views/my_page/block.rb;TiI"∑            var = File.basename(var).split("STRING").first.gsub(/^_/, "STRING")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	@CiI"l            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//redmine_proj/redmine/wiki_formatting/textile/formatter.rb;TiqI"∆                var = ("STRING" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@HirI"n              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@HisI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//redmine_proj/redmine/wiki_formatting/textile/helper.rb;TiI"”              ((javascript_include_tag("STRING") + javascript_include_tag("STRING")) + stylesheet_link_tag("STRING"))
            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	@OiI"b            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	I"(data//redmine_proj/SVG/Graph/Bar.rb;TiBI"q            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	I"2data//redmine_proj/SVG/Graph/BarHorizontal.rb;TiBI"q            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	I"(data//rescue_proj/resque/helpers.rb;Ti>I"n            var
          end
          var.const_get(var, false)
        end
      end
    end
  end
end;Fi[	I"<data//rspec_proj/spec/adapters/mock_frameworks/rspec.rb;TiI"t        
        def function(arglist)
          $rspec_mocks.reset_all
        end
      end
    end
  end
end;Fi[	I"&data//rspec_proj/spec/dsl/main.rb;Ti_I"          Object.const_set(var, Spec::Example::ExampleGroupFactory.create_shared_example_group(*var, &var)))
        rescue NameError => var
          raise(NameError.new((var.message + "STRING")))
        end
      end
    end
  end
end
include(Spec::DSL::Main);Fi[	I"6data//rspec_proj/spec/example/args_and_options.rb;TiI"r      module WithOptions
        def function(arglist)
          last
        end
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/example/pending.rb;TiI"∏          raise(Spec::Example::PendingExampleFixedError.new("STRING"))
        else
          raise(Spec::Example::ExamplePendingError.new(var))
        end
      end
    end
  end
end;Fi[	I"8data//rspec_proj/spec/example/predicate_matchers.rb;Ti,I"Ø      def function(arglist)
        predicate_matchers.each_pair do |arglist|
          define_method(var) { |arglist| eval("STRING") }
        end
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/example/subject.rb;Ti{I"§            self.__should_not_for_example_group__(var)
          else
            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	@li|I"r          else
            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"2data//rspec_proj/spec/expectations/handler.rb;Ti2I"∞          ::Spec::Expectations.fail_with(var, var.expected.first, var.actual)
        else
          ::Spec::Expectations.fail_with(var)
        end
      end
    end
  end
end;Fi[	I"6data//rspec_proj/spec/extensions/instance_exec.rb;Ti"I"À            return send(:__instance_exec, *var)
          ensure
            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	@ti#I"õ          ensure
            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	I"Edata//rspec_proj/spec/interop/test/unit/ui/console/testrunner.rb;TiDI"Ñ          end
          
          alias_method(:setup_mediator, :setup_mediator_with_rspec)
        end
      end
    end
  end
end;Fi[	I".data//rspec_proj/spec/matchers/include.rb;Ti'I"Y            end
          end
          true
        end
      end
    end
  end
end;Fi[	I"+data//rspec_proj/spec/mocks/methods.rb;Ti`I"Ü          @var ||= Proxy.new(self, @var, @var)
        else
          @var ||= Proxy.new(self)
        end
      end
    end
  end
end;Fi[	I")data//rspec_proj/spec/mocks/proxy.rb;Ti|I"Ô                  @var.superclass.send(var, *var, &var)
                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      ;Fi[	@Çi}I"”                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"+data//rspec_proj/spec/rake/spectask.rb;Ti¶I"Ø          var = (var + spec_files.to_a) if spec_files
          var = (var + FileList[pattern].to_a) if pattern
          FileList[var]
        end
      end
    end
  end
end;Fi[	I"?data//rspec_proj/spec/runner/class_and_arguments_parser.rb;TiI"g          [$1, var]
        else
          raise("STRING")
        end
      end
    end
  end
end;Fi[	I"1data//rspec_proj/spec/runner/command_line.rb;TiI"w          var.run_examples)
        ensure
          Spec::Runner.use(var)
        end
      end
    end
  end
end;Fi[	I"4data//rspec_proj/spec/runner/differs/default.rb;TiKI"          
          def function(arglist)
            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	@êiLI"y          def function(arglist)
            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	I"5data//rspec_proj/spec/runner/drb_command_line.rb;TiI"Ç        rescue DRb::DRbConnError
          var.error_stream.puts("STRING")
          false
        end
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/runner/formatter/base_formatter.rb;TiëI"À        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/base_text_formatter.rb;TiçI"{        def function(arglist)
          Spec.deprecate("STRING")
          red(var)
        end
      end
    end
  end
end;Fi[	I"Odata//rspec_proj/spec/runner/formatter/failing_example_groups_formatter.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Idata//rspec_proj/spec/runner/formatter/failing_examples_formatter.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/runner/formatter/html_formatter.rb;TièI"f        
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"Ddata//rspec_proj/spec/runner/formatter/nested_text_formatter.rb;Ti.I"t        
        def function(arglist)
          (INDENT * @var.length)
        end
      end
    end
  end
end;Fi[	I"Cdata//rspec_proj/spec/runner/formatter/no_op_method_missing.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/profile_formatter.rb;Ti%I"o            @var.puts("STRING")
          end
          @var.flush
        end
      end
    end
  end
end;Fi[	I"Edata//rspec_proj/spec/runner/formatter/progress_bar_formatter.rb;Ti I"s        def function(arglist)
          @var.puts
          @var.flush
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/snippet_extractor.rb;Ti=I"p            (var << var)
          end
          var.join("STRING")
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/specdoc_formatter.rb;Ti I"{          super
          output.puts(yellow("STRING"))
          output.flush
        end
      end
    end
  end
end;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/text_mate_formatter.rb;TiI"≤      class TextMateFormatter < HtmlFormatter
        def function(arglist)
          var.gsub(/([^:]*\.rb):(\d*)/) { |arglist| "STRING" }
        end
      end
    end
  end
end;Fi[	I"2data//rspec_proj/spec/runner/heckle_runner.rb;TiEI"o        
        def function(arglist)
          @var.run_examples
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/active_model/observer.rb;TiI"Í        def function(arglist)
          var = var.method
          send(var, *var.args) if respond_to?(var)
        end
      end
    end
  end
end
if defined? ActiveModel::Observer then
  ActiveModel::Observer.class_eval do |arglist|;Fi[	I"Xdata//state_machine_proj/state_machine/integrations/active_model/observer_update.rb;Ti%I"ñ        # get access to the enabled / disabled observers.
        def function(arglist)
          object.class
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/active_model/versions.rb;TiI"´        def function(arglist)
          owner_class.set_callback(:validation, :after, "STRING", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	I"Rdata//state_machine_proj/state_machine/integrations/active_record/versions.rb;TilI"ó            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Pdata//state_machine_proj/state_machine/integrations/data_mapper/observer.rb;Ti¢I"¿                var.state_machines.values
              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end;Fi[	@Ài£I"—              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|;Fi[	@Ài§I"˚              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|
  include(StateMachine::Integrations::DataMapper::Observer);Fi[	I"Pdata//state_machine_proj/state_machine/integrations/data_mapper/versions.rb;Ti/I"          else
            ::Extlib::Inflection
          end).pluralize(var.to_s)
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/mongo_mapper/versions.rb;TiTI"ó            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Ldata//state_machine_proj/state_machine/integrations/mongoid/versions.rb;Ti$I"ô            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[	I"Kdata//state_machine_proj/state_machine/integrations/sequel/versions.rb;TiEI"i        end
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"3data//state_machine_proj/state_machine/path.rb;Ti{I"∑      else
        machine.events.transitions_for(object, :from => (to_name), :guard => (@var)).select do |arglist|
          can_walk_to?(var)
        end
      end
    end
  end
end;Fi[	I"Adata//state_machine_proj/state_machine/yard/handlers/base.rb;TiI"è          else
            var = extract_node_name(var)
            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	@·i I"Ä            var = extract_node_name(var)
            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/event.rb;TiI"‚            var.each do |arglist|
              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end;Fi[	@ÊiI"ƒ              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÊiI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÊiI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//state_machine_proj/state_machine/yard/handlers/machine.rb;Ti∆I"œ            end
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING"]
          end
        end
      end
    end
  end
end;Fi[	@Ôi«I"ø            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "STRING")))
            var.docstring = ["STRING", "STRING"]
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/state.rb;TiI"‚            var.each do |arglist|
              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end;Fi[	@ÙiI"ƒ              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÙiI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÙiI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//state_machine_proj/state_machine/yard/handlers/transition.rb;Ti+I"r            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@˝i,I"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/api/saved_searches.rb;Ti_I"◊        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "STRING", var.options)
        end
      end
    end
  end
end;Fi[	I"/data//twitter_proj/twitter/configurable.rb;TiGI"≤        next if var.nil?
        unless (var.is_a?(String) or var.is_a?(Symbol)) then
          raise(Error::ConfigurationError, "STRING")
        end
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/error/client_error.rb;TiI"€            if var[:errors] then
              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"∫              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	@iI"å              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	I".data//twitter_proj/twitter/media/photo.rb;TiI"ß        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	I">data//twitter_proj/twitter/request/multipart_with_file.rb;Ti"I"_          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	I"6data//twitter_proj/twitter/response/parse_json.rb;TiI"∆        if respond_to?(:parse) then
          unless [204, 301, 302, 304].include?(var[:status]) then
            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	@iI"¢          unless [204, 301, 302, 304].include?(var[:status]) then
            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	I"7data//whenever_proj/whenever/capistrano/support.rb;Ti I"≈            var = var.empty? ? ("STRING") : ("STRING")
            var = "STRING"
            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[	@i!I"é            var = "STRING"
            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[@(I" ;FI"private;FI" ;FI"def function(arglist);Fi[[	I"5data//activemodel_proj/active_model/callbacks.rb;Ti5I"Ÿ        define_callbacks(var, var)
        var.each { |arglist| send("STRING", self, var) }
      end
    end
    
    private
    
    def function(arglist)
      var.class_eval("STRING", "STRING", (126 + 1))
    end;Fi[	I"2data//activemodel_proj/active_model/errors.rb;TiaI"o      var = var.!=(:base) ? (@var.send(:read_attribute_for_validation, var)) : (nil)
      var = { :default => (var), :model => (@var.class.model_name.human), :attribute => (@var.class.human_attribute_name(var)), :value => (var) }.merge!(var)
      I18n.translate(var, var)
    end
    
    private
    
    def function(arglist)
      var ||= :invalid
      case var;Fi[	I"0data//activemodel_proj/active_model/lint.rb;TiWI"      def function(arglist)
        assert(model.respond_to?(:errors), "STRING")
        assert(model.errors[:hello].is_a?(Array), "STRING")
      end
      
      private
      
      def function(arglist)
        assert(@var.respond_to?(:to_model), "STRING")
        @var.to_model;Fi[	I"2data//activemodel_proj/active_model/naming.rb;Ti©I"-      (var << @var)
      var = { :scope => ([@var.i18n_scope, :models]), :count => 1, :default => (var) }.merge!(var.except(:default))
      I18n.translate(var.shift, var)
    end
    
    private
    
    def function(arglist)
      ActiveSupport::Inflector.underscore(var).tr("STRING", var)
    end;Fi[	I";data//activemodel_proj/active_model/serializers/xml.rb;TiaI"∫            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	I"Adata//activemodel_proj/active_model/validations/clusivity.rb;TiI"G        unless (delimiter.respond_to?(:include?) or (delimiter.respond_to?(:call) or delimiter.respond_to?(:to_sym))) then
          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist)
        var = if delimiter.respond_to?(:call) then
          delimiter.call(var);Fi[	I">data//activemodel_proj/active_model/validations/format.rb;TiI"        end
        check_options_validity(options, :with)
        check_options_validity(options, :without)
      end
      
      private
      
      def function(arglist)
        var = options[var]
        var.respond_to?(:call) ? (var.call(var)) : (var);Fi[	I">data//activemodel_proj/active_model/validations/length.rb;Ti2I"          var[:message] ||= var if var
          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist)
        (if options[:tokenizer] and var.kind_of?(String) then
          options[:tokenizer].call(var);Fi[	I"5data//activemodel_proj/active_model/validator.rb;TiPI"ï    def function(arglist)
      @var = var
      super
    end
    
    private
    
    def function(arglist)
      @var.call(var, var, var)
    end;Fi[	@8iDI"l        reader_method(var, var, var, var, var)
        writer_method(var, var, var, var, var)
        create_reflection(:composed_of, var, nil, var, self)
      end
      
      private
      
      def function(arglist)
        define_method(var) do |arglist|
          if @var[var].nil? and (var.! or var.any? { |arglist| read_attribute(var.first).nil?.! }) then;Fi[	I"Hdata//activerecord_proj/active_record/associations/alias_tracker.rb;Ti!I"          aliases[var] += 1
          (aliases[var] > 1) ? ("STRING") : (var)
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins)
        var = connection.quote_table_name(var).downcase;Fi[	@=içI"'        var, var = var
        var.each { |arglist| instance_variable_set(var, var) }
        @var = @var.class.reflect_on_association(var)
      end
      
      private
      
      def function(arglist)
        loaded?.! and ((owner.new_record?.! or foreign_key_present?) and klass)
      end;Fi[	I"Ldata//activerecord_proj/active_record/associations/association_scope.rb;TiI"        var = klass.unscoped
        var.merge!(eval_scope(klass, reflection.scope)) if reflection.scope
        add_constraints(var)
      end
      
      private
      
      def function(arglist)
        var = alias_tracker.connection.schema_cache.columns_hash[var]
        var[var];Fi[	I"]data//activerecord_proj/active_record/associations/belongs_to_polymorphic_association.rb;TiI"      def function(arglist)
        var = owner[reflection.foreign_type]
        var.presence and var.constantize
      end
      
      private
      
      def function(arglist)
        super
        owner[reflection.foreign_type] = (var and var.class.base_class.name);Fi[	@@i%I"Ï      
      def function(arglist)
        owner.new_record? and foreign_key_present?.!
      end
      
      private
      
      def function(arglist)
        if options[:counter_sql] then
          interpolate(options[:counter_sql]);Fi[	I"^data//activerecord_proj/active_record/associations/has_and_belongs_to_many_association.rb;TiI"£          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size
      end;Fi[	I"Wdata//activerecord_proj/active_record/associations/has_many_through_association.rb;Ti;I"Œ        save_through_record(var)
        update_counter(1)
        var
      end
      
      private
      
      def function(arglist)
        @var ||= owner.association(through_reflection.name)
      end;Fi[	@CiI"Ì      def function(arglist)
        create_through_record(var)
        self.target = var
      end
      
      private
      
      def function(arglist)
        ensure_not_nested
        var = owner.association(through_reflection.name);Fi[	I"Fdata//activerecord_proj/active_record/associations/join_helper.rb;Ti
I"º    module JoinHelper
      def function(arglist)
        Arel::InnerJoin
      end
      
      private
      
      def function(arglist)
        var = []
        chain.each do |arglist|;Fi[	@SiDI"Œ        
        def function(arglist)
          reflection.options
        end
        
        private
        
        def function(arglist)
          var = owners_by_key
          var = var.keys.compact;Fi[	@giI"        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        private
        
        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]))
        end;Fi[	@oiI"2            var.map! { |arglist| var.send(source_reflection.name) }.flatten!
            var.compact!
          end
        end
        
        private
        
        def function(arglist)
          Preloader.new(owners, through_reflection.name, through_scope).run
          Hash[owners.map do |arglist|;Fi[	@riCI"◊      
      def function(arglist)
        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var
        when Hash then;Fi[	I"Odata//activerecord_proj/active_record/associations/singular_association.rb;Ti#I"ﬁ        yield(var) if block_given?
        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist)
        scope.scope_for_create.stringify_keys.except(klass.primary_key)
      end;Fi[	I"Bdata//activerecord_proj/active_record/attribute_assignment.rb;TisI"        else
          (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist)
        if object.class.send(:create_time_zone_conversion_attribute?, name, column) then
          Time.zone.local(*var);Fi[	I"Ddata//activerecord_proj/active_record/attribute_methods/read.rb;Ti;I"v        def function(arglist)
          var = var.unpack("STRING").first
          generated_attribute_methods.module_eval("STRING", "STRING", (59 + 1))
        end
        
        private
        
        def function(arglist)
          if (attribute_types_cached_by_default == ATTRIBUTE_TYPES_CACHED_BY_DEFAULT) then
            serialized_attributes.include?(var.name).!;Fi[	@hi\I"°            var.type_cast(var)
          end
        end)
      end
      
      private
      
      def function(arglist)
        read_attribute(var)
      end;Fi[	I"Tdata//activerecord_proj/active_record/attribute_methods/time_zone_conversion.rb;Ti,I"%          else
            super
          end
        end
        
        private
        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end;Fi[	@mi3I":        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist)
        var.change(:usec => 0) if var
      end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/abstract/connection_pool.rb;TiFI"Ô          synchronize do |arglist|
            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist)
          @var.synchronize(&var)
        end;Fi[	@ri¡I"®          end
          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist)
        @var[Process.pid]
      end;Fi[	I"]data//activerecord_proj/active_record/connection_adapters/abstract/schema_definitions.rb;TiI"        var[:default] = default unless default.nil?
        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist)
        base.add_column_options!(var, var.merge(:column => (self)))
      end;Fi[	@wiI"      # to generate the final SQL to create the table.
      def function(arglist)
        (@var.map { |arglist| var.to_sql } * "STRING")
      end
      
      private
      
      def function(arglist)
        var = ColumnDefinition.new(var, var, var)
        (@var << var);Fi[	@{i&I"Ú      # Lists the valid migration options
      def function(arglist)
        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var
        when BigDecimal then;Fi[	I"\data//activerecord_proj/active_record/connection_adapters/abstract/schema_statements.rb;TiäI"        ActiveSupport::Deprecation.warn("STRING")
        raise(ArgumentError.new("STRING")) if var.blank?
        var.map { |arglist| quote_column_name(var) }
      end
      
      private
      
      def function(arglist)
        TableDefinition.new(self)
      end;Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract_mysql_adapter.rb;Ti.I"        
        def function(arglist)
          collation and collation.match(/_ci$/).!
        end
        
        private
        
        def function(arglist)
          if adapter.emulate_booleans and var.downcase.index("STRING") then
            return :boolean;Fi[	@ÅièI"€      
      def function(arglist)
        [remove_column_sql(var, :updated_at), remove_column_sql(var, :created_at)]
      end
      
      private
      
      def function(arglist)
        (version[0] >= 5)
      end;Fi[	@~i'I"          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) }
          raise(AdapterNotSpecified, "STRING") unless var;Fi[	@ÅimI"          (var << var)
          (var << build_footer(var.rows.length, var))
          (var.join("STRING") + "STRING")
        end
        
        private
        
        def function(arglist)
          [].tap do |arglist|
            var.columns.each_with_index do |arglist|;Fi[	@Åi“I"æ      
      def function(arglist)
        @var.last_id
      end
      
      private
      
      def function(arglist)
        @var = Mysql2::Client.new(@var)
        configure_connection;Fi[	@ÑirI"‚        def function(arglist)
          cache.values.each { |arglist| var[:stmt].close }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[Process.pid]
        end;Fi[	@ÑiíI"π        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {}
        log(var, var, var) do |arglist|;Fi[	@°iMI"-      def function(arglist)
        @var, @var, @var, @var, @var = var
        prepare_default_proc
      end
      
      private
      
      def function(arglist)
        @var.default_proc = Proc.new { |arglist| var[var] = connection.columns(var) }
        @var.default_proc = Proc.new do |arglist|;Fi[	@§iQI"‹        def function(arglist)
          cache.values.each { |arglist| dealloc(var[:stmt]) }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[$$]
        end;Fi[	I"6data//activerecord_proj/active_record/fixtures.rb;Ti√I"ò        var
      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key)
    end;Fi[	@îi©I"H    
    def function(arglist)
      ActiveRecord::Base.connection_handler.connection_pool_list.map(&:connection)
    end
    
    private
    
    def function(arglist)
      var = ActiveRecord::FixtureSet.create_fixtures(fixture_path, fixture_table_names, fixture_class_names)
      Hash[var.map { |arglist| [var.name, var] }];Fi[	@ßiI"Õ      
      def function(arglist)
        self.class.locking_enabled?
      end
      
      private
      
      def function(arglist)
        var = self.class.locking_column
        var = send(var).to_i;Fi[	I"9data//activerecord_proj/active_record/query_cache.rb;Ti'I"Ê        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    
    def function(arglist)
      ActiveRecord::Base.connection_id = var
      ActiveRecord::Base.connection.clear_query_cache;Fi[	I"8data//activerecord_proj/active_record/reflection.rb;Ti|I"H      # and +other_aggregation+ has an options hash assigned to it.
      def function(arglist)
        (super or (var.kind_of?(self.class) and ((name == var.name) and (var.options and (active_record == var.active_record)))))
      end
      
      private
      
      def function(arglist)
        name.to_s.camelize
      end;Fi[	@ûiII"’      
      def function(arglist)
        options.key?(:polymorphic)
      end
      
      private
      
      def function(arglist)
        var = name.to_s.camelize
        var = var.singularize if collection?;Fi[	@ûiËI")          raise(HasOneThroughCantAssociateThroughCollection.new(active_record.name, self, through_reflection))
        end
        check_validity_of_inverse!
      end
      
      private
      
      def function(arglist)
        (options[:source_type] or source_reflection.class_name)
      end;Fi[	I">data//activerecord_proj/active_record/relation/batches.rb;TiNI"~          raise("STRING")
        end
      end
    end
    
    private
    
    def function(arglist)
      "STRING"
    end;Fi[	I"Cdata//activerecord_proj/active_record/relation/calculations.rb;Ti¥I"P    #   Person.joins(:companies).ids # SELECT people.id FROM people INNER JOIN companies ON companies.person_id = people.id
    def function(arglist)
      pluck(primary_key)
    end
    
    private
    
    def function(arglist)
      (eager_loading? or (includes_values.present? and (var or references_eager_loaded_tables?)))
    end;Fi[	@√i@I"„        merge_multi_values
        merge_single_values
        relation
      end
      
      private
      
      def function(arglist)
        relation.where_values = merged_wheres
        relation.bind_values = merged_binds;Fi[	I"Ddata//activerecord_proj/active_record/relation/query_methods.rb;Ti≠I"·      var.from(build_from) if from_value
      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist)
      var = var.reject { |arglist| var.blank? }
      return [] if var.empty?;Fi[	I"Ddata//activerecord_proj/active_record/relation/spawn_methods.rb;Ti;I"    #   Post.order('id asc').only(:where, :order) # uses the specified order
    def function(arglist)
      relation_with(values.slice(*var))
    end
    
    private
    
    def function(arglist)
      var = Relation.new(klass, table, var)
      var.default_scoped = default_scoped;Fi[	I"6data//activerecord_proj/active_record/relation.rb;Ti˛I"ˆ      var = to_a.take([limit_value, 11].compact.min).map!(&:inspect)
      var[10] = "STRING" if (var.size == 11)
      "STRING"
    end
    
    private
    
    def function(arglist)
      var = with_default_scope
      if var.equal?(self) then;Ti[	I"4data//activerecord_proj/active_record/result.rb;Ti3I"‰      @var = columns.dup
      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist)
      @var ||= (var = @var.map { |arglist| var.dup.freeze }
      @var.map { |arglist| Hash[var.zip(var)] });Fi[	I";data//activerecord_proj/active_record/schema_dumper.rb;TiI"ü      tables(var)
      trailer(var)
      var
    end
    
    private
    
    def function(arglist)
      @var = var
      @var = @var.native_database_types;Fi[	@‘i-I"“        send(:"#{var}STRING")
        var[var] = var
      end
    end
    
    private
    
    def function(arglist)
      var = send(var)
      unless var.is_a?(ActiveSupport::HashWithIndifferentAccess) then;Fi[	I"Bdata//activerecord_proj/active_record/tasks/database_tasks.rb;TixI"B        var = var.first
        var = var.delete_at(1)
        class_for_adapter(var["STRING"]).new(*var).structure_load(var)
      end
      
      private
      
      def function(arglist)
        @var ||= ConnectionAdapters::ConnectionSpecification::Resolver.new(ENV["STRING"], {}).spec.config.stringify_keys
      end;Fi[	I"7data//activerecord_proj/active_record/timestamp.rb;TiI"”    def function(arglist)
      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist)
      if self.record_timestamps then
        var = current_time_from_proper_timezone;Fi[	I":data//activerecord_proj/active_record/transactions.rb;Ti3I"˝      def function(arglist)
        set_options_for_callbacks!(var)
        set_callback(:rollback, :after, *var, &var)
      end
      
      private
      
      def function(arglist)
        var = var.last
        if var.is_a?(Hash) and var[:on] then;Fi[	@◊i-I""      
      def function(arglist)
        (var.foreign_key? ? (var.name) : (var.name.singularize.foreign_key)).to_sym
      end
      
      private
      
      def function(arglist)
        unless file_name =~ /^[_a-z0-9]+$/ then
          raise(IllegalMigrationNameError.new(file_name));Fi[	I"1data//backup_proj/backup/compressor/bzip2.rb;TiI"¿        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      private
      
      def function(arglist)
        "STRING" if @var
      end;Fi[	I"0data//backup_proj/backup/compressor/gzip.rb;TiI"¿        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      private
      
      def function(arglist)
        "STRING" if @var
      end;Fi[	I"0data//backup_proj/backup/compressor/lzma.rb;Ti"I"Ò      def function(arglist)
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super
      end
      
      private
      
      def function(arglist)
        ("STRING" if @var or "STRING" if @var)
      end;Fi[	I"2data//backup_proj/backup/compressor/pbzip2.rb;Ti(I"      def function(arglist)
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super
      end
      
      private
      
      def function(arglist)
        var = ("STRING" if @var or "STRING" if @var)
        var = "STRING" if @var;Fi[	I".data//backup_proj/backup/configuration.rb;TiI"      var = eval(self.to_s.sub("STRING", "STRING"))
      Logger.warn(Errors::ConfigurationError.new("STRING"))
      var.defaults(&var)
    end
    
    private
    
    def function(arglist)
      const_set(var, Module.new { |arglist| extend(Configuration) })
    end;Fi[	I"'data//backup_proj/backup/errors.rb;Ti(I"
          (var << ("STRING" + (orig_err_msg ? ("STRING") : ("STRING")))) if @var
        end
        @var = var ? ((msg_prefix + var)) : (class_name)
      end
      
      private
      
      def function(arglist)
        @var ||= (class_name + "STRING")
      end;Fi[	I",data//backup_proj/backup/syncer/base.rb;Ti&I"€      # Adds a path to the @directories array
      def function(arglist)
        (@var << var)
      end
      
      private
      
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end;Fi[	I"&data//bundler_proj/bundler/cli.rb;Ti©I"=    
    def function(arglist)
      Env.new.write($stdout)
    end
    
    private
    
    def function(arglist)
      Bundler.settings[:cache_all] = options[:all] if options.key?("STRING")
      if Bundler.definition.sources.any? { |arglist| var.is_a?(Source::Rubygems).! } and Bundler.settings[:cache_all].! then;Fi[	I"-data//bundler_proj/bundler/definition.rb;TiI"º        end
        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist)
      @var.! and (@var.! and (@var.! and (@var.! and @var.!)))
    end;Fi[	I",data//bundler_proj/bundler/dep_proxy.rb;Ti%I"É    
    def function(arglist)
      "STRING"
    end
    
    private
    
    def function(arglist)
      @var.send(*var)
    end;Fi[	I"-data//bundler_proj/bundler/dependency.rb;Ti@I"©      var = super
      (var << "STRING") if source
      (var << "STRING")
    end
    
    private
    
    def function(arglist)
      RUBY_VERSION =~ /^1\.8/
    end;Fi[	I"&data//bundler_proj/bundler/dsl.rb;Ti§I"Û    def function(arglist)
      var = caller[0].split("STRING")[(0..1)].join("STRING")
      raise(GemfileError, "STRING")
    end
    
    private
    
    def function(arglist)
      var.keys.each do |arglist|
        next if String.===(var);Fi[	I"9data//bundler_proj/bundler/endpoint_specification.rb;TiDI"~    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "STRING"
    end;Fi[	I"&data//bundler_proj/bundler/env.rb;Ti$I"¡      ((var << "STRING") << "STRING")
      ((var << read_file("STRING")) << "STRING")
      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip;Fi[	@iI"∑    
    def function(arglist)
      GraphVizClient.new(self).run
    end
    
    private
    
    def function(arglist)
      var = _groups.values.to_set.flatten
      while true do;Fi[	I"(data//bundler_proj/bundler/index.rb;TiI"ã      else
        raise(ArgumentError, "STRING")
      end
    end
    
    private
    
    def function(arglist)
      @var[var]
    end;Fi[	I"+data//bundler_proj/bundler/injector.rb;Ti"I"ø      ensure
        Bundler.settings[:frozen] = "STRING" if var
      end
    end
    
    private
    
    def function(arglist)
      @var.map { |arglist| "STRING" }.join("STRING")
    end;Fi[	I",data//bundler_proj/bundler/installer.rb;TiïI"»        end
        Bundler.ui.warn("STRING")
      end
    end
    
    private
    
    def function(arglist)
      var = Bundler.bin_path
      var = File.read(File.expand_path("STRING", "STRING"));Fi[	I"5data//bundler_proj/bundler/lazy_specification.rb;TiCI"µ    
    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end;Fi[	I"7data//bundler_proj/bundler/remote_specification.rb;Ti)I"≥    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      @var ||= @var.fetch_spec([@var, @var, @var])
    end;Fi[	@ iUI"Æ      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        @var ||= (var = {}
        ALL.each do |arglist|;Fi[	I"/data//bundler_proj/bundler/rubygems_ext.rb;TiHI"≤    
    def function(arglist)
      (dependencies - development_dependencies)
    end
    
    private
    
    def function(arglist)
      var = "STRING"
      if var.any? then;Fi[	@)i¥I"˙        Bundler::WINDOWS ? (var.unshift("STRING")) : (var.unshift("STRING"))
        ENV["STRING"] = var.join("STRING")
      end
    end
    
    private
    
    def function(arglist)
      var = Dir["STRING"]
      var = var.delete_if do |arglist|;Fi[	I"+data//bundler_proj/bundler/settings.rb;TibI"≠    
    def function(arglist)
      ENV["STRING"]
    end
    
    private
    
    def function(arglist)
      var = var.to_s.sub("STRING", "STRING").upcase
      "STRING";Fi[	I"1data//bundler_proj/bundler/shared_helpers.rb;Ti!I"¨    
    def function(arglist)
      find_gemfile
    end
    
    private
    
    def function(arglist)
      var = ENV["STRING"]
      return var if var and var.empty?.!;Fi[	@/iöI"£      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        @var = true
        @var = @var = nil;Fi[	@7i_I"∂      
      def function(arglist)
        name
      end
      
      private
      
      def function(arglist)
        @var ||= Bundler.app_cache.join(app_cache_dirname)
      end;Fi[	@<i|I"         @var = []
        var.remotes.each { |arglist| add_remote(var.to_s) }
        true
      end
      
      private
      
      def function(arglist)
        var = @var.map { |arglist| "STRING" }
        var = var.find { |arglist| File.exist?(var) };Fi[	I"+data//bundler_proj/bundler/spec_set.rb;TijI"‘        (var << var)
      end
      SpecSet.new(var)
    end
    
    private
    
    def function(arglist)
      var = @var.find { |arglist| (var.name == "STRING") }
      @var ||= ([var] + tsort).compact.uniq;Fi[	I"(data//cancan_proj/cancan/ability.rb;TiﬂI"    def function(arglist)
      var.send(:rules).each { |arglist| (rules << var.dup) }
      self
    end
    
    private
    
    def function(arglist)
      unless var.kind_of?(Symbol) then
        var = ((var.class == Class) ? (var) : (var.class)).name.underscore;Fi[	I"4data//cancan_proj/cancan/controller_resource.rb;TiI"¿    
    def function(arglist)
      ([:new, :create] + [@var[:new]].flatten)
    end
    
    private
    
    def function(arglist)
      var.to_s.underscore.gsub("STRING", "STRING")
    end;Fi[	I"Edata//cancan_proj/cancan/model_adapters/active_record_adapter.rb;TiyI"@            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact
        if defined? ActiveRecord::Relation and var.any? { |arglist| var.kind_of?(ActiveRecord::Relation) } then;Fi[	@diTI"≈        end
      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class
      ((var == Class) or (var == Module));Fi[	@viπI"–    # associated with this command.
    def function(arglist)
      @var.each { |arglist| var.close unless var[:closed] }
    end
    
    private
    
    def function(arglist)
      options[:logger]
    end;Fi[	@ôi_I"≤        var = @var.dup
        (var << "STRING") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var;Fi[	@úiKI"E          var = "STRING"
          var = "STRING"
          [change_or_create_stream(var, var), change_or_create_stream(var, var), scm(:diff, "STRING", var, "STRING", var, "STRING")].join("STRING")
        end
        
        private
        
        def function(arglist)
          repository.split("STRING")[0]
        end;Fi[	@§iEI"        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        
        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("STRING".chomp)
        end;Fi[	@™iKI"Ω          else
            return var
          end
        end
        
        private
        
        def function(arglist)
          case variable(:scm_verbose)
          when nil then;Fi[	@√iCI"Ì          end
          logger.trace("STRING")
          var
        end
        
        private
        
        def function(arglist)
          @var ||= (configuration.logger or Capistrano::Logger.new(:output => (STDOUT)))
        end;Fi[	@…i5I"˙          else
            File.expand_path(configuration[:copy_cache], Dir.pwd)
          end rescue nil
        end
        
        private
        
        def function(arglist)
          copy_repository_to_local_cache
          build(copy_cache);Fi[	@“iI"'            var.remote.command("STRING") unless copy_exclude.empty?
            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist)
          File.join(shared_path, (configuration[:repository_cache] or "STRING"))
        end;Fi[	@’iI"      class UnsharedRemoteCache < RemoteCache
        def function(arglist)
          super.check { |arglist| var.remote.writable(repository_cache) }
        end
        
        private
        
        def function(arglist)
          configuration[:repository_cache]
        end;Fi[	I"8data//compass_proj/compass/commands/project_base.rb;TiGI"        else
          raise(Compass::Error.new("STRING")) if File.directory?(project_directory).!
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then
          File.basename(strip_trailing_separator(var[:project_name]));Fi[	@Ìi•I"¸      
      def function(arglist)
        (relative_assets or (http_images_path == :relative))
      end
      
      private
      
      def function(arglist)
        var = ((var.keys - ATTRIBUTES) - ARRAY_ATTRIBUTES)
        if (var.size == 1) then;Fi[	I"Cdata//compass_proj/compass/sass_extensions/functions/colors.rb;Ti;I"Ô    var = (var.alpha * 255).round
    var = var.to_s(16).rjust(2, "STRING")
    Sass::Script::String.new("STRING".upcase)
  end
  
  private
  
  def function(arglist)
    if (var > 0) then
      var = (var + ((100 - var) * (var / 100.0)));Fi[	I"Mdata//compass_proj/compass/sass_extensions/functions/gradient_support.rb;TiqI"V      var = color_stops_in_percentages(var)
      var = radial_svg(var, var, var, var)
      inline_image_string(var.gsub(/\s+/, "STRING"), "STRING")
    end
    
    private
    
    def function(arglist)
      (var.is_a?(ColorStop) or ((var.is_a?(Sass::Script::List) and ColorStop.new(*var.value)) or ColorStop.new(var))) rescue nil
    end;Fi[	I"Idata//compass_proj/compass/sass_extensions/functions/inline_image.rb;TiI"≈    var = [var].flatten.pack("STRING").gsub("STRING", "STRING")
    var = "STRING"
    Sass::Script::String.new(var)
  end
  
  private
  
  def function(arglist)
    return var if var
    case var;Fi[	@içI"            PARENT.match(name)
            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end;Fi[	@i*I"+        
        def function(arglist)
          (@var.inject(0) { |arglist| var = (var + var.efficiency) } ** @var.length)
        end
        
        private
        
        def function(arglist)
          var = Compass::SassExtensions::Sprites::ImageRow.new(width)
          var.add(var) if var;Fi[	@iDI"6        
        def function(arglist)
          @var.respond_to?(var) ? (@var.send(var, *var, &var)) : (super)
        end
        
        private
        
        def function(arglist)
          @var ||= Compass.configuration.sprite_engine.to_s.scan(/([^_.]+)/).flatten.map do |arglist|
            "STRING";Fi[	@ i™I"≠        
        def function(arglist)
          @var.language
        end
        
        private
        
        def function(arglist)
          (index == 0)
        end;Fi[	I"1data//cucumber_prok/cucumber/ast/scenario.rb;TinI"û        @var = var
        yield
        @var = nil
      end
      
      private
      
      def function(arglist)
        (@var.failed? or @var)
      end;Fi[	I"-data//cucumber_prok/cucumber/ast/step.rb;Ti^I"Û      
      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "STRING").gsub(/\./, "STRING").gsub(/:/, "STRING")
      end
      
      private
      
      def function(arglist)
        var = 0
        var.select do |arglist|;Fi[	@#iFI"¨        
        def function(arglist)
          "STRING"
        end
        
        private
        
        def function(arglist)
          @var.index(self)
        end;Fi[	I"4data//cucumber_prok/cucumber/ast/tree_walker.rb;TiI"       # For most formatters this is a no-op.
      def function(arglist)
        broadcast(var, var, var)
      end
      
      private
      
      def function(arglist)
        var = extract_method_name_from(caller)
        var.gsub!("STRING", "STRING");Fi[	I"6data//cucumber_prok/cucumber/cli/configuration.rb;TiûI"Ò      
      def function(arglist)
        @var[:paths].empty? ? (["STRING"]) : (@var[:paths])
      end
      
      private
      
      def function(arglist)
        if @var[:autoformat] then
          require("cucumber/formatter/pretty");Fi[	@&i;I"À        @var.parse!(@var)
        Cucumber.logger = @var.log
        @var
      end
      
      private
      
      def function(arglist)
        begin
          (return false unless configuration.drb?;Fi[	I"2data//cucumber_prok/cucumber/configuration.rb;Ti*I"∏    
    def function(arglist)
      @var[:autoload_code_paths]
    end
    
    private
    
    def function(arglist)
      { :autoload_code_paths => (["STRING", "STRING"]) }
    end;Fi[	I";data//cucumber_prok/cucumber/core_ext/instance_exec.rb;Ti2I"≤        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity
    Cucumber::RUBY_1_9 ? (var) : ((var == -1) ? (0) : (var));Fi[	I"1data//cucumber_prok/cucumber/feature_file.rb;TiQI"†          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING
      var.each_line do |arglist|;Fi[	I"6data//cucumber_prok/cucumber/formatter/console.rb;Ti´I"π      
      def function(arglist)
        @var = []
      end
      
      private
      
      def function(arglist)
        var = var.join("STRING").to_sym
        var = FORMATS[var];Fi[	I"4data//cucumber_prok/cucumber/formatter/debug.rb;TiI"ﬂ        @var = (@var - 2) if var.to_s =~ /^after/
        print(var)
        @var = (@var + 2) if var.to_s =~ /^before/
      end
      
      private
      
      def function(arglist)
        @var.puts("STRING")
      end;Fi[	I"4data//cucumber_prok/cucumber/formatter/junit.rb;TioI"◊          build_testcase(var, var.status, var.exception, var)
        end
        @var = false if @var
      end
      
      private
      
      def function(arglist)
        @var = (@var + var)
        var = @var;Fi[	I"5data//cucumber_prok/cucumber/formatter/pretty.rb;TiÃI"=        var = cell_prefix(var)
        @var.print((("STRING" + format_string("STRING", var)) + ::Cucumber::Term::ANSIColor.reset("STRING")))
        @var.flush
      end
      
      private
      
      def function(arglist)
        @var.puts if (@var == 6)
        var = var.empty? ? ([var]) : (var.split("STRING"));Fi[	I"7data//cucumber_prok/cucumber/formatter/progress.rb;TiAI"≥      
      def function(arglist)
        @var = true
      end
      
      private
      
      def function(arglist)
        print_steps(:pending)
        print_steps(:failed);Fi[	I"4data//cucumber_prok/cucumber/formatter/rerun.rb;TiGI"–      
      def function(arglist)
        @var = true if [:failed, :pending, :undefined].index(var)
      end
      
      private
      
      def function(arglist)
        yield if @var
        @var = true;Fi[	I"4data//cucumber_prok/cucumber/formatter/steps.rb;TiI"≥      
      def function(arglist)
        print_summary
      end
      
      private
      
      def function(arglist)
        var = 0
        @var.keys.sort.each do |arglist|;Fi[	I"6data//cucumber_prok/cucumber/formatter/summary.rb;TiI"P      def function(arglist)
        var = lambda { |arglist| var.steps(var) }
        (dump_count(var.steps.length, "STRING") + dump_status_counts(var, &var))
      end
      
      private
      
      def function(arglist)
        var = [:failed, :skipped, :undefined, :pending, :passed].map do |arglist|
          var = var.call(var);Fi[	@:iúI"À      
      def function(arglist)
        @var.invoke_steps(var, @var, var)
      end
      
      private
      
      def function(arglist)
        var = @var.features_paths
        if var.empty? then;Fi[	@=iEI"–      
      def function(arglist)
        invoked_step_definition_hash[StepDefinitionLight.new(var, var)] = nil
      end
      
      private
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@@iCI"∞      
      def function(arglist)
        # do nothing
      end
      
      private
      
      def function(arglist)
        var.map do |arglist|
          var = var.cells;Fi[	I";data//cucumber_prok/cucumber/py_support/py_language.rb;Ti*I"ÿ      
      def function(arglist)
        @var.step_matches(var, var)
      end
      
      private
      
      def function(arglist)
        var = File.basename(var)[(0...-File.extname(var).length)]
        begin;Fi[	@CiÇI"ß      
      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist)
        if @var then
          @var = @var.call;Fi[	I"<data//cucumber_prok/cucumber/rb_support/rb_transform.rb;Ti I"Õ      
      def function(arglist)
        convert_captures(strip_anchors(@var.source))
      end
      
      private
      
      def function(arglist)
        var.gsub(/(\()(?!\?:)/, "STRING")
      end;Fi[	I"<data//cucumber_prok/cucumber/runtime/features_loader.rb;TiI"¥      def function(arglist)
        load unless @var
        @var
      end
      
      private
      
      def function(arglist)
        var = Ast::Features.new
        var = {};Fi[	@Oi~I"        var = best_matches(var, var) if (var.size > 1) and guess_step_matches?
        raise(Ambiguous.new(var, var, guess_step_matches?)) if (var.size > 1)
        var[0]
      end
      
      private
      
      def function(arglist)
        @var.guess?
      end;Fi[	I";data//cucumber_prok/cucumber/runtime/user_interface.rb;Ti3I"Õ      #
      def function(arglist)
        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin
          Timeout.timeout(var) { |arglist| STDIN.gets };Fi[	@Ri"I"Ú      
      def function(arglist)
        WireException.new(var, @var.host, @var.port)
      end
      
      private
      
      def function(arglist)
        Timeout.timeout(@var.timeout("STRING")) { |arglist| socket.puts(var) }
      end;Fi[	I"Fdata//cucumber_prok/cucumber/wire_support/wire_step_definition.rb;TiI"˜      def function(arglist)
        var = var.map { |arglist| prepare(var) }
        @var.invoke(@var, var)
      end
      
      private
      
      def function(arglist)
        return var unless var.is_a?(Cucumber::Ast::Table)
        var.raw;Fi[	I"4data//devise_proj/devise/controllers/helpers.rb;Ti›I"˚      
      def function(arglist)
        Devise.navigational_formats.include?(request_format)
      end
      
      private
      
      def function(arglist)
        Devise.mappings.each { |arglist| instance_variable_set("STRING", nil) }
      end;Fi[	@]iNI"Â    
    def self.add_module(arglist)
      class_eval("STRING", "STRING", (113 + 1))
    end
    
    private
    
    def function(arglist)
      @var = (var[:failure_app] or Devise::FailureApp)
      if @var.is_a?(String) then;Fi[	I"3data//devise_proj/devise/models/timeoutable.rb;TiI"Ù      
      def function(arglist)
        self.class.timeout_in
      end
      
      private
      
      def function(arglist)
        return false unless respond_to?(:remember_created_at)
        remember_created_at and remember_expired?.!;Fi[	I"8data//devise_proj/devise/strategies/rememberable.rb;TiI"“          return pass
        end
        success!(var) if validate(var)
      end
      
      private
      
      def function(arglist)
        super
        if var.respond_to?(:extend_remember_period=) then;Fi[	I"9data//diaspora_proj/controllers/admins_controller.rb;TiHI"ª  
  def function(arglist)
    @var = Statistics.new.generate_correlations
  end
  
  private
  
  def function(arglist)
    sprintf("STRING", (((var - var) / var.to_f) * 100)).to_f
  end;Fi[	I":data//diaspora_proj/controllers/aspects_controller.rb;TilI"¥      @var.contacts_visible = true
    end
    @var.save
  end
  
  private
  
  def function(arglist)
    @var = Person.find(var)
    if @var = current_user.contact_for(@var) then;Fi[	I"9data//diaspora_proj/controllers/blocks_controller.rb;Ti"I"      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist)
    if var = current_user.contact_for(var) then
      current_user.disconnect(var, :force => (true));Fi[	I";data//diaspora_proj/controllers/comments_controller.rb;TiAI"‰      end
      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist)
    if user_signed_in? then
      @var = current_user.find_visible_shareable_by_id(Post, params[:post_id]);Fi[	I";data//diaspora_proj/controllers/contacts_controller.rb;TiI"Ø  def function(arglist)
    @var = true
    @var = Person.community_spotlight
  end
  
  private
  
  def function(arglist)
    @var = case params[:set]
    when "STRING" then;Fi[	I"Cdata//diaspora_proj/controllers/invitation_codes_controller.rb;TiI"˛  def function(arglist)
    sign_out(current_user) if user_signed_in?
    redirect_to(new_user_registration_path(:invite => ({ :token => (params[:id]) })))
  end
  
  private
  
  def function(arglist)
    InvitationCode.find_by_token!(params[:id])
  end;Fi[	I">data//diaspora_proj/controllers/invitations_controller.rb;TiII"•      flash[:error] = I18n.t("STRING")
      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist)
    User.email_regexp.match(var).present?
  end;Fi[	@wi,I"W      var.all { |arglist| render(:layout => (false)) }
      var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist)
    @var ||= if params[:post_id] then
      (current_user.find_visible_shareable_by_id(Post, params[:post_id]) or raise(ActiveRecord::RecordNotFound.new));Fi[	I"9data//diaspora_proj/controllers/people_controller.rb;Ti¶I"é        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id }
    var = {};Fi[	I"9data//diaspora_proj/controllers/photos_controller.rb;Ti|I"¿    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist)
    if request.params[:qqfile].is_a?(String).! then
      var[:qqfile];Fi[	I";data//diaspora_proj/controllers/profiles_controller.rb;Ti:I"Ÿ        end
      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("STRING"))) then
      @var[:tag_string].split("STRING").each do |arglist|;Fi[	I":data//diaspora_proj/controllers/publics_controller.rb;TiKI"&    FEDERATION_LOGGER.info("STRING")
    Resque.enqueue(Jobs::ReceiveEncryptedSalmon, @var.id, CGI.unescape(params[:xml]))
    render(:nothing => (true), :status => 202)
  end
  
  private
  
  def function(arglist)
    if params[:xml].nil? then
      render(:nothing => (true), :status => 422);Fi[	I"@data//diaspora_proj/controllers/registrations_controller.rb;TiI"¿  
  def function(arglist)
    super
  end
  
  private
  
  def function(arglist)
    return true if AppConfig.settings.enable_registrations?
    return true if invite and invite.can_be_used?;Fi[	I"Edata//diaspora_proj/controllers/share_visibilities_controller.rb;TiI"4    params[:shareable_type] ||= "STRING"
    var = current_user.toggle_hidden_shareable(accessible_post)
    render(:nothing => (true), :status => 200)
  end
  
  private
  
  def function(arglist)
    @var ||= params[:shareable_type].constantize.where(:id => (params[:post_id])).select("STRING").first
  end;Fi[	I"Bdata//diaspora_proj/controllers/status_messages_controller.rb;TiCI"        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "STRING")) then
      current_user.aspect_ids;Fi[	I":data//diaspora_proj/controllers/streams_controller.rb;Ti6I"ˆ  def function(arglist)
    gon.tagFollowings = tags
    stream_responder(Stream::FollowedTag)
  end
  
  private
  
  def function(arglist)
    @var ||= var.new(current_user, :max_time => (max_time)) if var.present?
    respond_with do |arglist|;Fi[	I"7data//diaspora_proj/controllers/tags_controller.rb;Ti-I"î        end))
      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name])
  end;Fi[	I"4data//diaspora_proj/helpers/analytics_helper.rb;TiI"     include_analytics("STRING") do |arglist|
      javascript_tag { |arglist| "STRING".html_safe }
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var)
    yield(var);Fi[	@ÑiI"§  
  def function(arglist)
    var.instance_of?(Reshare)
  end
  
  private
  
  def function(arglist)
    if var.stream_posts.empty? then
      (Time.now + 1).to_i;Fi[	I"=data//diaspora_proj/mailers/notification_mailers/base.rb;TiI"7      var = Mail::Address.new(var)
      var.display_name = var
      var.format
    end
    
    private
    
    def function(arglist)
      var = { :from => (AppConfig.mail.sender_address.get), :host => "STRING", :to => (name_and_address(@var.name, @var.email)) }
      var[:from] = "STRING" if @var.present?;Fi[	I",data//diaspora_proj/mailers/notifier.rb;TiQI"‡  
  def function(arglist)
    send_notification(:confirm_email, var)
  end
  
  private
  
  def function(arglist)
    @var = NotificationMailers.const_get(var.to_s.camelize).new(*var)
    with_recipient_locale do |arglist|;Fi[	I"*data//diaspora_proj/models/contact.rb;TiQI"‡        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist)
    (errors[:base] << "STRING") if person_id and person.closed_account?
  end;Fi[	I"*data//diaspora_proj/models/message.rb;TiZI"ı  
  def function(arglist)
    var[:plain_text] ? (self.text) : (ERB::Util.h(self.text))
  end
  
  private
  
  def function(arglist)
    if self.parent and self.parent.participants.include?(self.author).! then
      (errors[:base] << "STRING");Fi[	I")data//diaspora_proj/models/person.rb;Ti8I"      self.url = ("STRING" + self.url) unless self.url.match(/https?:\/\//)
      self.url = (self.url + "STRING") if self.url[-1, 1].!=("STRING")
    end
  end
  
  private
  
  def function(arglist)
    Webfinger.new(self.diaspora_handle).fetch
    self.reload;Fi[	I"*data//diaspora_proj/models/profile.rb;TiºI"       errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["STRING", "STRING", "STRING"])
  end;Fi[	I"*data//diaspora_proj/models/reshare.rb;TiPI"ö      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch
    var.save! unless var.persisted?;Fi[	I"3data//diaspora_proj/models/services/twitter.rb;TiI"˝  
  def function(arglist)
    client.user(nickname).profile_image_url_https("STRING")
  end
  
  private
  
  def function(arglist)
    @var ||= Twitter::Client.new(:oauth_token => (self.access_token), :oauth_token_secret => (self.access_secret))
  end;Fi[	I"3data//diaspora_proj/models/share_visibility.rb;Ti I"      var = var.map { |arglist| [var, var.id, var.class.base_class.to_s] }
      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist)
    (errors[:base] << "STRING") if shareable.public?
  end;Fi[	I"'data//diaspora_proj/models/user.rb;Ti¡I"     self.password = var
    self.password_confirmation = var
    self.save(:validate => (false))
  end
  
  private
  
  def function(arglist)
    (self.attributes.keys - ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"])
  end;Fi[	I"!data//haml_proj/haml/exec.rb;TiåI"⁄          return var
        end
        return "STRING"
      end
      
      private
      
      def function(arglist)
        return if var.nil?
        var = "STRING" if @var[:unix_newlines] and (var == "STRING");Fi[	I"$data//haml_proj/haml/options.rb;Ti‰I"å        var[var] = send(var)
        var
      end
    end
    
    private
    
    def function(arglist)
      self.class.defaults
    end;Fi[	I"#data//homebrew_proj/caveats.rb;TiI"«  
  def function(arglist)
    caveats.empty?
  end
  
  private
  
  def function(arglist)
    @var ||= [f.prefix, f.opt_prefix, f.linked_keg].map do |arglist|
      Keg.new(var.realpath) rescue nil;Fi[	I"%data//homebrew_proj/cmd/audit.rb;TiÙI"    audit_conflicts
    audit_patches
    audit_text
  end
  
  private
  
  def function(arglist)
    (@var << var)
  end;Fi[	I"$data//homebrew_proj/cmd/info.rb;TixI"π        raise("STRING")
      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "STRING") or ((var[(0..7)] == "STRING") or (var[(0..5)] == "STRING")))
  end;Fi[	I"$data//homebrew_proj/cmd/list.rb;TiI"ª        end
      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|
      var.basename.to_s;Fi[	I"#data//homebrew_proj/cmd/tap.rb;TiSI"∆      var = (var + link_tap_formula(var))
    end
    puts("STRING")
  end
  
  private
  
  def function(arglist)
    ARGV.first =~ /^(\S+)\/(homebrew-)?(\w+)$/
    raise("STRING") unless $1 and $3;Fi[	I"&data//homebrew_proj/cmd/update.rb;Ti,I"Ü      puts("STRING")
      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir["STRING"].empty? then;Fi[	@ibI"}      end
    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp
  end;Fi[	@¢i*I"  
  def function(arglist)
    (Pathname.pwd == HOMEBREW_REPOSITORY) ? ("STRING") : ("STRING")
  end
  
  private
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-list --abbrev-commit HEAD -- Library/Formula/#{name}STRING`.split;Fi[	I"-data//homebrew_proj/download_strategy.rb;TioI"ò    else
      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist)
    var = Dir["STRING"]
    case var.length;Fi[	@ixI"≤        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "STRING").split(/:/)
    var = var.pop;Fi[	I"'data//homebrew_proj/extend/ARGV.rb;Ti©I"≥    ensure
      replace(var)
    end
  end
  
  private
  
  def function(arglist)
    @var ||= named.map { |arglist| var.include?("STRING") ? (var) : (var.downcase) }.uniq
  end;Fi[	I")data//homebrew_proj/macos/xquartz.rb;Ti^I"°  
  def function(arglist)
    (prefix / "STRING")
  end
  
  private
  
  def function(arglist)
    ((prefix.to_s == "STRING") or MacOS::CLT.installed?).!
  end;Fi[	I"%data//homebrew_proj/metafiles.rb;TiI"∫  def function(arglist)
    return false if ["STRING", "STRING"].include?(var)
    include?(var).!
  end
  
  private
  
  def function(arglist)
    var = var.to_s
    var = var.downcase;Fi[	I"#data//homebrew_proj/patches.rb;Ti'I"‘    return unless external_patches?
    curl(*external_curl_args)
    external_patches.each { |arglist| var.stage! }
  end
  
  private
  
  def function(arglist)
    @var.select { |arglist| var.external? }
  end;Fi[	I"#data//homebrew_proj/version.rb;Ti§I"ú    else
      @var.is_a?(Symbol) ? (detect_from_symbol) : (raise("STRING"))
    end
  end
  
  private
  
  def function(arglist)
    raise("STRING")
  end;Fi[	I"6data//jekyll_proj/jekyll/generators/pagination.rb;Ti1I"™          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["STRING"]
      var.sub("STRING", var.to_s);Fi[	@ıi8I"        # @since 3.1.0
        def function(arglist)
          positionally_operable? ? (position.sub(/\.\d/, "STRING")) : (position)
        end
        
        private
        
        def function(arglist)
          document.persisted? and document._id_changed?
        end;Fi[	I"<data//mongoid_proj/lib/mongoid/criterion/marshalable.rb;Ti I"        @var, @var, @var, @var, @var, @var = var
        @var = load_hash(Origin::Selector, var)
        @var = load_hash(Origin::Options, var)
      end
      
      private
      
      def function(arglist)
        send(var).inject({}) do |arglist|
          var[var] = var;Fi[	@iâI"¬          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|
          send(var).reject! do |arglist|;Fi[	@Éi©I"À        # @since 2.1.0
        def function(arglist)
          entries.uniq
        end
        
        private
        
        def function(arglist)
          entries.send(var, *var, &var)
        end;Fi[	@ßiÜI"·      
      def function(arglist)
        var.accept(self)
      end
      
      private
      
      def function(arglist)
        raise(ArgumentError, "STRING") unless (var.value.size == 4)
        var = var.value[0].to_i;Fi[	I"1data//nokogiri_proj/nokogiri/xml/document.rb;Ti€I"≈      def function(arglist)
        raise("STRING") unless Nokogiri.jruby?
        return toJavaDocument
      end
      
      private
      
      def function(arglist)
        "STRING"
      end;Fi[	I"-data//nokogiri_proj/nokogiri/xml/node.rb;Ti,I"J          var = var.is_a?(XML::Node) ? (var) : (var)
          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist)
        var = (var == :next) ? (:add_next_sibling_node) : (:add_previous_sibling_node)
        var = (var == :next) ? (:reverse_each) : (:each);Fi[	@…iXI"          var = ParserContext.memory(var)
          yield(var) if block_given?
          var.parse_with(self)
        end
        
        private
        
        def function(arglist)
          var.upcase!
          raise(ArgumentError.new("STRING")) unless ENCODINGS[var];Fi[	I"1data//paperclip_proj/paperclip/attachment.rb;Ti/I"    def function(arglist)
      var = :"#{name}STRING#{var}"
      instance.send(var) if instance.respond_to?(var)
    end
    
    private
    
    def function(arglist)
      @var[:path].respond_to?(:call) ? (@var[:path].call(self)) : (@var[:path])
    end;Fi[	I"<data//paperclip_proj/paperclip/content_type_detector.rb;TiI"ù          end
        end
      end).to_s
    end
    
    private
    
    def function(arglist)
      File.exists?(@var) and (File.size(@var) == 0)
    end;Fi[	I"Idata//paperclip_proj/paperclip/file_command_content_type_detector.rb;TiI"¿    
    def function(arglist)
      type_from_file_command
    end
    
    private
    
    def function(arglist)
      var = begin
        Paperclip.run("STRING", "STRING", :file => (@var));Fi[	I"/data//paperclip_proj/paperclip/geometry.rb;Ti|I"Ω      else
        scale_to(var)
      end
    end
    
    private
    
    def function(arglist)
      if (var.horizontal? or var.square?) then
        [("STRING" % var.width), var.width];Fi[	I"@data//paperclip_proj/paperclip/geometry_detector_factory.rb;TiI"    def function(arglist)
      var = GeometryParser.new(geometry_string.strip).make
      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin
        silence_stream(STDERR) do |arglist|;Fi[	I">data//paperclip_proj/paperclip/geometry_parser_factory.rb;TiI"      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist)
      if var = (@var and @var.match(FORMAT)) then
        @var = var[1];Fi[	I"Cdata//paperclip_proj/paperclip/io_adapters/abstract_adapter.rb;TiI"◊    
    def function(arglist)
      @var = var.gsub(OS_RESTRICTED_CHARACTERS, "STRING")
    end
    
    private
    
    def function(arglist)
      @var ||= TempfileFactory.new.generate(original_filename)
    end;Fi[	I"Edata//paperclip_proj/paperclip/io_adapters/attachment_adapter.rb;TiI"¥        # do nothing
      end
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename
      @var = @var.content_type;Fi[	I"?data//paperclip_proj/paperclip/io_adapters/file_adapter.rb;Ti
I"Ò    def function(arglist)
      @var = var
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename if @var.respond_to?(:original_filename)
      @var ||= File.basename(@var.path);Fi[	I"Hdata//paperclip_proj/paperclip/io_adapters/uploaded_file_adapter.rb;TiI"¬    
    class << self
      attr_accessor(:content_type_detector)
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename
      @var = determine_content_type;Fi[	I"-data//paperclip_proj/paperclip/schema.rb;Ti6I"…    module CommandRecorder
      def function(arglist)
        record(:add_attachment, var)
      end
      
      private
      
      def function(arglist)
        [:remove_attachment, var]
      end;Fi[	I"2data//paperclip_proj/paperclip/storage/fog.rb;Ti}I"Œ          warn("STRING")
          false
        end
      end
      
      private
      
      def function(arglist)
        if @var[:fog_host].respond_to?(:call) then
          @var[:fog_host].call(self);Fi[	@ÏiÓI"û          warn("STRING")
          false
        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then;Fi[	I"Kdata//paperclip_proj/paperclip/validators/attachment_size_validator.rb;Ti#I"        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "STRING")
        end
      end
      
      private
      
      def function(arglist)
        if var = var[:in] then
          if var[:in].respond_to?(:call).! then;Fi[	@ˇiéI"Ú        # Test if this record is in a list
        def function(arglist)
          send(position_column).nil?.!
        end
        
        private
        
        def function(arglist)
          increment_positions_on_all_items
        end;Fi[	I"ddata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication/mem_cache_store.rb;Ti2I"˜      return false if ((var - Time.now.to_i).abs > OpenID::Nonce.skew)
      @var.write(nonce_key(var, var), var, :expires_in => (OpenID::Nonce.skew))
      return true
    end
    
    private
    
    def function(arglist)
      "STRING"
    end;Fi[	I"Tdata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication.rb;TikI"Ø    else
      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist)
    (params[:openid_identifier] or params[:openid_url])
  end;Fi[	I"Sdata//redmine_proj/plugins/open_id_authentication/test/mem_cache_store_test.rb;TiMI"˛      var = OpenID::Nonce.mk_nonce(3600)
      assert_nonce(var, false, var, "STRING")
    end
  end
  
  private
  
  def function(arglist)
    var = OpenID::CryptUtil.random_string(20, nil)
    var = OpenID::CryptUtil.random_string(128, ALLOWED_HANDLE);Fi[	I"9data//redmine_proj/plugins/rfpdf/lib/fpdf/chinese.rb;TiÎI"—    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I":data//redmine_proj/plugins/rfpdf/lib/fpdf/japanese.rb;TiÙI"—    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I"8data//redmine_proj/plugins/rfpdf/lib/fpdf/korean.rb;Ti⁄I"—    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	I"Ddata//redmine_proj/plugins/rfpdf/lib/rfpdf/action_controller.rb;TiI"÷      def function(arglist)
        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var)
      end
      
      private
      
      def function(arglist)
        var = var.dup
        var;Fi[	@|iI"    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!(var)
    end
    
    private
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!((self.class.read_inheritable_attribute(:rfpdf) or {})) do |arglist|;Fi[	I"7data//redmine_proj/plugins/rfpdf/lib/rfpdf/fpdf.rb;TiI"∑    else
      open(var, "STRING") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "STRING")) then;Fi[	I"3data//redmine_proj/redmine/activity/fetcher.rb;TiII"Ì        var.sort! { |arglist| (var.event_datetime <=> var.event_datetime) }
        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist)
        @@var[var]
      end;Fi[	I"9data//redmine_proj/redmine/core_ext/active_record.rb;Ti	I"”  module FinderMethods
    def function(arglist)
      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@2i.I"E        var = { :top => (var), :zoom => (var), :subject_width => (var), :g_width => (var), :indent => 0, :indent_increment => 5, :top_increment => 5, :format => :pdf, :pdf => (var) }
        render(var)
        var.Output
      end
      
      private
      
      def function(arglist)
        var ||= @var
        var = {};Fi[	I"6data//redmine_proj/redmine/helpers/time_report.rb;TiI"Á      
      def function(arglist)
        (@var or load_available_criteria)
      end
      
      private
      
      def function(arglist)
        unless @var.empty? then
          var = ["STRING", "STRING", "STRING", "STRING"];Fi[	I")data//redmine_proj/redmine/themes.rb;TiGI"ª      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        if var then
          Dir.glob("STRING").collect do |arglist|;Fi[	I"*data//redmine_proj/SVG/Graph/Graph.rb;Ti'I"Œ          end
          var.attributes["STRING"] = "STRING"
        end
      end
      
      private
      
      def function(arglist)
        if (var < var) then
          var = partition(var, var, var);Fi[	I"-data//redmine_proj/SVG/Graph/Schedule.rb;TiÑI"’      
      def function(arglist)
        return "STRING"
      end
      
      private
      
      def function(arglist)
        var = [@var[0][-1], @var[1].max].max
        var = [@var[0][0], @var[1].min].min;Fi[	I"/data//redmine_proj/SVG/Graph/TimeSeries.rb;TiWI"Ê      
      def function(arglist)
        get_x_values.collect { |arglist| Time.at(var).strftime(x_label_format) }
      end
      
      private
      
      def function(arglist)
        var = []
        var, var, var = x_range;Fi[	I":data//rspec_proj/spec/example/shared_example_group.rb;TiI"ª        
        def function(arglist)
          shared_example_groups.length
        end
        
        private
        
        def function(arglist)
          @var ||= []
        end;Fi[	I")data//rspec_proj/spec/matchers/be.rb;Ti)I"      
      [:==, :<, :<=, :>=, :>, :===].each do |arglist|
        define_method(var) { |arglist| BeComparedTo.new(var, var) }
      end
      
      private
      
      def function(arglist)
        @var.empty? ? ("STRING") : (parenthesize(inspected_args.join("STRING")))
      end;Fi[	@ûizI"ó      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        "STRING".to_sym
      end;Fi[	I"*data//rspec_proj/spec/matchers/has.rb;TiI"ó      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        "STRING".to_sym
      end;Fi[	I"+data//rspec_proj/spec/matchers/have.rb;TiCI"‹      
      def function(arglist)
        (@var.respond_to?(var) or super)
      end
      
      private
      
      def function(arglist)
        @var = var
        if (var = if defined? ActiveSupport::Inflector then;Fi[	I"2data//rspec_proj/spec/matchers/match_array.rb;Ti#I"…      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        var.all? { |arglist| var.respond_to?(:<=>) } ? (var.sort) : (var)
      end;Fi[	I"6data//rspec_proj/spec/matchers/raise_exception.rb;TiCI"ù      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        case @var
        when nil then;Fi[	I"3data//rspec_proj/spec/matchers/throw_symbol.rb;Ti0I"´      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end;Fi[	I"3data//rspec_proj/spec/mocks/error_generator.rb;Ti0I"¶      
      def function(arglist)
        __raise("STRING")
      end
      
      private
      
      def function(arglist)
        if @var then
          "STRING";Fi[	@iWI"’      #:nodoc:
      def function(arglist)
        __mock_proxy.reset
      end
      
      private
      
      def function(arglist)
        if Mock.===(self) then
          @var ||= Proxy.new(self, @var, @var);Fi[	I"(data//rspec_proj/spec/mocks/mock.rb;Ti'I"      
      def function(arglist)
        inspect.gsub("STRING", "STRING").gsub("STRING", "STRING")
      end
      
      private
      
      def function(arglist)
        __mock_proxy.record_message_received(var, var, var)
        begin;Fi[	@ÇiçI"ˆ      
      def function(arglist)
        @var.find { |arglist| var.matches(var, var) }
      end
      
      private
      
      def function(arglist)
        $rspec_mocks.add(@var) unless $rspec_mocks.nil?
        define_expected_method(var);Fi[	I")data//rspec_proj/spec/mocks/space.rb;TiI"¿      def function(arglist)
        mocks.each { |arglist| var.rspec_reset }
        mocks.clear
      end
      
      private
      
      def function(arglist)
        @var ||= []
      end;Fi[	I"2data//rspec_proj/spec/runner/configuration.rb;TißI"‰      
      def function(arglist)
        @var ||= false
      end
      
      private
      
      def function(arglist)
        var, var = args_and_options(*var)
        [get_type_from_options(var)].flatten.each do |arglist|;Fi[	@™iI"·          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	I"-data//rspec_proj/spec/runner/reporter.rb;TiiI"Œ        def function(arglist)
          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist)
        @var.formatters
      end;Fi[	I"1data//sinatra_proj/sinatra/showexceptions.rb;Ti&I"C        var["STRING"] = var
        [500, { "STRING" => (var), "STRING" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist)
      (Request.new(var).preferred_type("STRING", "STRING") == "STRING").! and [/curl/].index { |arglist| var.=~(var["STRING"]) }
    end;Fi[	I"3data//SiriProxy_proj/siriproxy/command_line.rb;TiwI"∑  
  def function(arglist)
    puts("STRING")
  end
  
  private
  
  def function(arglist)
    $APP_CONFIG = OpenStruct.new(YAML.load_file(File.expand_path("STRING")))
    @var = nil;Fi[	I"?data//state_machine_proj/state_machine/event_collection.rb;TiÄI"ù        end
      end)
      var
    end
    
    private
    
    def function(arglist)
      var and var[:on] ? ([fetch(var.delete(:on))]) : (self)
    end;Fi[	I")data//twitter_proj/twitter/client.rb;TiZI"ÿ    # Perform an HTTP PUT request
    def function(arglist)
      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin
        connection.send(var.to_sym, var, var) do |arglist|;Fi[	I",data//twitter_proj/twitter/creatable.rb;TiI"∆    # @return [Time]
    def function(arglist)
      @var ||= Time.parse(@var[:created_at]) if created?
    end
    
    private
    
    def function(arglist)
      @var[:created_at].nil?.!
    end;Fi[	@iI"†          end
        end
        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var
        when /\.jpe?g/i then;Fi[	I"'data//twitter_proj/twitter/user.rb;TieI"ú    
    def function(arglist)
      @var[:status].nil?.!
    end
    
    private
    
    def function(arglist)
      var.sub(/^https/i, "STRING")
    end;Fi[@(@)@*I" ;FI"def function(arglist);FiŒ[Œ[	@1iII"/              self.class::MethodAttribute.new(var, @var, var)
            else
              self.class::Attribute.new(var, @var, var)
            end
          end
        end
        
        def function(arglist)
          require("builder") unless defined? ::Builder
          options[:indent] ||= 2;Fi[	@7iI"P          if options[:without] then
            var = option_call(var, :without)
            record_error(var, var, :without, var) if var.to_s.=~(var)
          end
        end
      end
      
      def function(arglist)
        unless options.include?(:with).^(options.include?(:without)) then
          raise(ArgumentError, "STRING");Fi[	@:i I"L          var = options[var]
          unless ((var.is_a?(Integer) and (var >= 0)) or (var == Float::INFINITY)) then
            raise(ArgumentError, "STRING")
          end
        end
      end
      
      def function(arglist)
        var = tokenize(var)
        var = var.respond_to?(:length) ? (var.length) : (var.to_s.length);Fi[	I"Ddata//activemodel_proj/active_model/validations/numericality.rb;Ti>I"◊            Kernel.Float(var)
          rescue ArgumentError, TypeError
            nil
          end
        end
      end
      
      def function(arglist)
        var.to_i if var.to_s =~ /\A[+-]?\d+\Z/
      end;Fi[	I"Ydata//activerecord_proj/active_record/associations/builder/collection_association.rb;Ti2I"Ë          @var = proc { |arglist| instance_exec(var, &var).extending(var) }
        else
          @var = proc { |arglist| extending(var) }
        end
      end
    end
    
    def function(arglist)
      @var ||= "STRING"
    end;Fi[	@@i1I"ı            var = $2.to_s
            var = "STRING" if (var.blank? or (var =~ /,/ or var =~ /\.\*/))
            "STRING"
          end
        end
      end
      
      def function(arglist)
        interpolate(options[:finder_sql])
      end;Fi[	@@i©I"‡            var.call(owner, var)
          else
            var.send(var, owner, var)
          end
        end
      end
      
      def function(arglist)
        var = "STRING"
        (owner.class.send(var.to_sym) or []);Fi[	I"Odata//activerecord_proj/active_record/associations/has_many_association.rb;TipI"            update_counter(-var.delete_all)
          else
            update_counter(-var.update_all(reflection.foreign_key => (nil)))
          end
        end
      end
      
      def function(arglist)
        owner.attribute_present?(reflection.association_primary_key)
      end;Fi[	@rifI"[        grouped_records(var).each do |arglist|
          var.each do |arglist|
            preloader_for(var).new(var, var, var, preload_scope).run
          end
        end
      end
      
      def function(arglist)
        Hash[records_by_reflection(var).map do |arglist|
          [var, var.group_by { |arglist| association_klass(var, var) }];Fi[	@{iI"f          super.dup.tap do |arglist|
            self.class.serialized_attributes.each_key do |arglist|
              var[var] = var[var].unserialized_value if var.key?(var)
            end
          end
        end
        
        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value;Fi[	@ri”I"            establish_connection(var, var.spec)
          else
            owner_to_pool[var.name] = nil
          end
        end
      end
      
      def function(arglist)
        var = @var.values.find { |arglist| var[var.name] }
        var and var[var.name];Fi[	@~iI"              execute("STRING")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist)
        if var = native_database_types[var.to_sym] then
          var = (var.is_a?(Hash) ? (var[:name]) : (var)).dup;Fi[	I"Vdata//activerecord_proj/active_record/connection_adapters/abstract/transaction.rb;Ti_I"            var.rolledback!(parent.closed?)
          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        records.uniq.each do |arglist|
          begin;Fi[	@˙iiI"ﬁ            var.committed!
          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false
      end;Fi[	I"Rdata//activerecord_proj/active_record/connection_adapters/abstract_adapter.rb;TiWI"»          unless in_use then
            @var = true
            @var = Time.now
          end
        end
      end
      
      def function(arglist)
        var.connection = self
        @var = var;Fi[	@ÅiûI"U        execute_and_free(var, "STRING") do |arglist|
          each_hash(var).map do |arglist|
            new_column(var[:Field], var[:Default], var[:Type], (var[:Null] == "STRING"), var[:Collation])
          end
        end
      end
      
      def function(arglist)
        super(var, var.reverse_merge(:options => "STRING"))
      end;Fi[	@ÅivI"í            var.columns.each_with_index do |arglist|
              var = ([var] + var.rows.map { |arglist| var[var].nil? ? ("STRING") : (var[var].to_s) })
              (var << var.map(&:length).max)
            end
          end
        end
        
        def function(arglist)
          var = 1
          (("STRING" + var.map { |arglist| ("STRING" * (var + (var * 2))) }.join("STRING")) + "STRING");Fi[	@åi+I"÷              end]
            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var)
        end;Fi[	@åi`I"¥              else
                var
              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil;Fi[	@åiÅI"Ê              "STRING"
            else
              ("STRING" % var.to_s.gsub(/(["\\])/, "STRING"))
            end
          end
        end
        
        def function(arglist)
          case var
          when "STRING" then;Fi[	@ëi2I"Â              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist)
          super.insert
        end;Fi[	@§i†I"é            self.null = var[:null] if var.include?(:null)
            self.precision = var[:precision] if var.include?(:precision)
            self.scale = var[:scale] if var.include?(:scale)
          end
        end
      end
      
      def function(arglist)
        unless columns(var).detect { |arglist| (var.name == var.to_s) } then
          raise(ActiveRecord::ActiveRecordError, "STRING");Fi[	@§iÍI"Q            var = { :name => (var.gsub(/(^|_)(#{var}STRING/, "STRING")) }
            var[:unique] = true if var.unique
            add_index(var, var, var)
          end
        end
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, var] }]
        var.each { |arglist| var[var.last] = var.first };Fi[	@îi‚I"…          var.each do |arglist|
            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "STRING"
    end;Fi[	@îi√I""        raise(RuntimeError, "STRING") if @var.nil?
        @var.each_value do |arglist|
          ActiveRecord::FixtureSet.instantiate_fixtures(self, var, load_instances?)
        end
      end
    end
    
    def function(arglist)
      use_instantiated_fixtures.!=(:no_instances)
    end;Fi[	I"9data//activerecord_proj/active_record/inheritance.rb;Ti%I"5            superclass.descends_from_active_record?
          else
            ((superclass == Base) or columns_hash.include?(inheritance_column).!)
          end
        end
      end
      
      def function(arglist)
        (:true == (@var ||= descends_from_active_record? ? (:false) : (:true)))
      end;Fi[	@ûi‡I"        unless options[:polymorphic] then
          if has_inverse? and inverse_of.nil? then
            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@æi I"$              module_eval("STRING", "STRING", (39 + 1))
            else
              module_eval("STRING", "STRING", (46 + 1))
            end
          end
        end
        
        def function(arglist)
          @var.synchronize do |arglist|
            return if method_defined?(var);Fi[	@æi[I",          var.compute_if_absent(var) { |arglist| const_get("STRING", false) }
        else
          ActiveRecord::Relation
        end
      end
    end
    
    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))))
    end;Fi[	I"Edata//activerecord_proj/active_record/relation/finder_methods.rb;TiI"–          order(arel_table[primary_key].asc).limit(1).to_a.first
        else
          limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      if loaded? then
        @var.last;Fi[	@	i*I"ø          to_a.last
        else
          reverse_order.limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      var.none? { |arglist| var.collection? }
    end;Fi[	@≠iI"±          end
        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) }
    end;Fi[	@≥i+I"È          true
        else
          false
        end
      end
    end
    
    def function(arglist)
      return [] if var.blank?
      (var.scan(/([a-zA-Z_][.\w]+).?\./).flatten.map { |arglist| var.downcase }.uniq - ["STRING"]);Ti[	I":data//activerecord_proj/active_record/sanitization.rb;TiïI"            else
              raise(PreparedStatementInvalid, "STRING")
            end
          end
        end
      end
      
      def function(arglist)
        if var.respond_to?(:map) and var.acts_like?(:string).! then
          if var.respond_to?(:empty?) and var.empty? then;Fi[	@∆itI"ª                  end
                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["STRING"]
        end;Fi[	@æi%I"◊            database_url_config
          else
            ActiveRecord::Base.configurations[var[:env]]
          end
        end
      end
      
      def function(arglist)
        begin
          (var = var.first;Fi[	I"Hdata//activerecord_proj/active_record/tasks/mysql_database_tasks.rb;Ti)I"          else
            $stderr.puts("STRING")
            $stderr.puts("STRING") if configuration["STRING"]
          end
        end
      end
      
      def function(arglist)
        establish_connection(configuration)
        connection.drop_database(configuration["STRING"]);Fi[	@/	ijI"»            Mysql2::Error
          else
            defined? Mysql ? (Mysql::Error) : (StandardError)
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	I"Mdata//activerecord_proj/active_record/tasks/postgresql_database_tasks.rb;TiI"Ó            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist)
        establish_master_connection
        connection.drop_database(configuration["STRING"]);Fi[	@·iMI"      @var.each do |arglist|
        if var = @var.find { |arglist| (var.name == var.name) } then
          var.instance_variable_set(:@type, var.type)
        end
      end
    end
    
    def function(arglist)
      raise("STRING") if @var
      @var.each { |arglist| var.cached! };Fi[	@·iBI"&        next unless var.instance_of?(Source::Path)
        specs_changed?(var) do |arglist|
          (var.class == var.class) and (var.path == var.path)
        end
      end
    end
    
    def function(arglist)
      var = false
      var = @var.find { |arglist| Source::Rubygems.===(var) };Fi[	@i/I"            var.each { |arglist| @var["STRING"] = _make_label(var, :edge) }
          end
          var = var
        end
      end
    end
    
    def function(arglist)
      var = Hash.new { |arglist| var[var] = Set.new }
      @var.current_dependencies.each do |arglist|;Fi[	@˚i£I"[        var = var = Pathname(var.full_gem_path).join(var.bindir, var).relative_path_from(var)
        File.open("STRING", "STRING", 493) do |arglist|
          var.puts(ERB.new(var, nil, "STRING").result(binding))
        end
      end
    end
    
    def function(arglist)
      var = Bundler.settings[:path]
      var = File.join(var, "STRING");Fi[	I"2data//bundler_proj/bundler/lockfile_parser.rb;TimI"          var = var.split("STRING").map { |arglist| var.strip } if var
          var = Gem::Dependency.new(var, var)
          (@var.dependencies << var)
        end
      end
    end
    
    def function(arglist)
      (@var << Gem::Platform.new($1)) if var =~ /^  (.*)$/
    end;Fi[	@ iÂI"¡              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by)
      (var.required_by << var);Fi[	@)i@I"≠              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then
        dependencies;Fi[	@)i≈I"⁄        var.each do |arglist|
          Bundler.ui.info("STRING")
          File.delete(var)
        end
      end
    end
    
    def function(arglist)
      var = Dir["STRING"]
      var = var.delete_if do |arglist|;Fi[	@)iÿI"√          var = File.dirname(var)
          Bundler.ui.info("STRING")
          FileUtils.rm_rf(var)
        end
      end
    end
    
    def function(arglist)
      root.join("STRING")
    end;Fi[	@7i¨I"        ensure
          if var and var then
            Dir.chdir(var) { |arglist| FileUtils.rm_rf(var) if File.exist?(var) }
          end
        end
      end
      
      def function(arglist)
        var = "STRING"
        return unless Gem.respond_to?(var);Fi[	I"?data//bundler_proj/bundler/vendor/thor/parser/arguments.rb;Ti!I"—          @var[var.human_name] = var.default
        else
          (@var << var) if var.required?
        end
      end
    end
    
    def function(arglist)
      @var = var.dup
      @var.each do |arglist|;Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/basic.rb;TiBI"’            yield)
          ensure
            $KCODE = var
          end
        end
      end
      
      def function(arglist)
        say("STRING", var)
        stdin.gets.tap { |arglist| var.strip! if var };Fi[	@i%I"U          self.resource_instance ||= load_resource_instance
        else
          self.collection_instance ||= load_collection if load_collection?
        end
      end
    end
    
    def function(arglist)
      unless skip?(:authorize) then
        @var.authorize!(authorization_action, (resource_instance or resource_class_with_parent));Fi[	@i{I"“          end
        else
          adapter.find(resource_base, id_param)
        end
      end
    end
    
    def function(arglist)
      ModelAdapters::AbstractAdapter.adapter_class(resource_class)
    end;Fi[	I"3data//cancan_proj/cancan/inherited_resource.rb;TiI"º          assign_attributes(var)
        else
          @var.send(:resource)
        end
      end
    end
    
    def function(arglist)
      @var.send(:end_of_association_chain)
    end;Fi[	@ iQI"9        else
          @var.reverse.inject(false_sql) do |arglist|
            merge_conditions(var, tableized_conditions(var.conditions).dup, var.base_behavior)
          end
        end
      end
      
      def function(arglist)
        return var unless var.kind_of?(Hash)
        var.inject({}) do |arglist|;Fi[	@ iÄI"          else
            var = @var.detect { |arglist| var.conditions.kind_of?(ActiveRecord::Relation) }
            raise(Error, "STRING")
          end
        end
      end
      
      def function(arglist)
        if var.blank? then
          var ? (true_sql) : (false_sql);Fi[	@ iêI"›            var ? (var) : (false_sql)
          else
            var ? ("STRING") : ("STRING")
          end
        end
      end
      
      def function(arglist)
        sanitize_sql(["STRING", true, false])
      end;Fi[	@di0I"∂              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!
    end;Fi[	@diÅI"Ÿ              end
            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first
      matches_conditions_hash?(var, (@var[var.class.name.downcase.to_sym] or {}));Fi[	I"1data//capistrano_proj/capistrano/cli/help.rb;TiI"˝            explain_task(var, options[:explain])
          else
            execute_requested_actions_without_help(var)
          end
        end
      end
      
      def function(arglist)
        var = options[:tool]
        if var.is_a?(String) then;Fi[	@c	iFI"«            puts
            puts("STRING")
            puts("STRING")
          end
        end
      end
      
      def function(arglist)
        var = var.find_task(var)
        if var.nil? then;Fi[	@niüI"        [:pre_vars, :vars].each do |arglist|
          options[var].keys.each do |arglist|
            options[var][var] = coerce_variable(options[var][var])
          end
        end
      end
      
      def function(arglist)
        case var
        when /^"(.*)"$/ then;Fi[	@viSI"µ              else
                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var;Fi[	@âi9I"Ò            var = ServerDefinition.new("STRING", :user => (var.user), :port => (var.open(var.host, (var.port or 22))))
            SSH.connection_strategy(var, @var) do |arglist|
              Net::SSH::Gateway.new(var, var, var)
            end
          end
        end
        
        def function(arglist)
          @var[:logger].debug("STRING") if @var[:logger]
          var = ServerDefinition.new("STRING", :user => (var.user), :port => (gateway_for(var).open(var.host, (var.port or 22))));Fi[	I"@data//capistrano_proj/capistrano/configuration/execution.rb;TizI"             logger.info("STRING", var.task.fully_qualified_name)
          ensure
            pop_task_call_frame
          end
        end
      end
      
      def function(arglist)
        var = TaskCallFrame.new(var)
        task_call_frames.push(var);Fi[	I">data//capistrano_proj/capistrano/configuration/servers.rb;TiPI"6              var.is_a?(Array) ? (roles[var.to_sym]) : (roles[var.to_sym].servers)
            end.flatten
            var.select { |arglist| var.include?(var) }
          end
        end
      end
      
      def function(arglist)
        var = var.split(/,/) if String.===(var)
        var = build_list(var);Fi[	@…iI"I          if build_script then
            execute("STRING") do |arglist|
              Dir.chdir(var) { |arglist| system(build_script) }
            end
          end
        end
        
        def function(arglist)
          super.check do |arglist|
            var.local.command(source.local.command) if source.local.command;Fi[	@…i©I"g          execute("STRING") do |arglist|
            Dir.chdir(copy_dir) do |arglist|
              system(compress(File.basename(destination), File.basename(filename)).join("STRING"))
            end
          end
        end
        
        def function(arglist)
          FileUtils.rm(filename) rescue nil
          FileUtils.rm_rf(destination) rescue nil;Fi[	I"1data//capistrano_proj/capistrano/transfer.rb;TidI"          prepare_scp_transfer(var, var, var)
        else
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    def function(arglist)
      var = (callback or Proc.new { |arglist| logger.trace("STRING") if logger and (var == 0) })
      var = case direction;Fi[	@x	i†I"¯          var.download(var, var, var, &var)
        else
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    def function(arglist)
      if var.is_a?(String) then
        var.gsub(/\$CAPISTRANO:HOST\$/, var.xserver.host);Fi[	@x	iØI"Ω          var
        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("STRING")
      var = session_map[var.session];Fi[	I"*data//compass_proj/compass/actions.rb;TiOI"Ó        if File.exists?(var) then
          File.unlink(var)
          log_action(:remove, basename(var), options)
        end
      end
    end
    
    def function(arglist)
      relativize(var) { |arglist| File.basename(var) }
    end;Fi[	I"4data//compass_proj/compass/commands/registry.rb;Ti I"‡          else
            raise(Compass::Error, "STRING")
          end
        end
      end
    end
    
    def function(arglist)
      var = /^#{Regexp.escape(var)}/
      @var.keys.detect { |arglist| var.to_s.=~(var) };Fi[	I"9data//compass_proj/compass/configuration/adapters.rb;Ti,I"‚            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index("STRING") == 1))
      end;Fi[	@ÌiÅI"À                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= []
        (@var << [var, var]);Fi[	I"-data//compass_proj/compass/frameworks.rb;TinI"”          var
        else
          "STRING".gsub(/^ {8}/, "STRING")
        end
      end
    end
    
    def function(arglist)
      var = "STRING"
      var = Compass::Frameworks::ALL.inject(0) do |arglist|;Fi[	I"6data//compass_proj/compass/installers/manifest.rb;TiÄI"Î            open(var) { |arglist| eval(var.read, instance_binding, var) }
          else
            eval("STRING", instance_binding, var)
          end
        end
      end
      
      def function(arglist)
        binding
      end;Fi[	I">data//compass_proj/compass/installers/template_context.rb;TiI"
        unless instance_methods.include?(var.to_s) then
          define_method(var) do |arglist|
            (config.send(var) or config.default_for(var))
          end
        end
      end
      
      def function(arglist)
        Compass.configuration
      end;Fi[	I"Rdata//compass_proj/compass/sass_extensions/functions/cross_browser_support.rb;TiBI"É        else
          var
        end
      end
    end
  end
  
  def function(arglist)
    CSS2FallbackValue.new(var, var)
  end;Fi[	@iMI",              var.left = var.to_i
              (@var << var)
              var = (var + var.width)
            end
          end
        end
        
        def function(arglist)
          require("rational")
          var = @var.inject(1) { |arglist| var.repeat_x? ? (var.lcm(var.width)) : (var) };Fi[	@i(I"          for var in sprite_names do
            unless var =~ /\A#{Sass::SCSS::RX::IDENT}STRING/ then
              raise(Sass::SyntaxError, "STRING")
            end
          end
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	I"8data//cucumber_prok/cucumber/ast/feature_element.rb;Ti0I"ı            else
              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("STRING").length)
            end
          end
        end
      end
      
      def function(arglist)
        var.detect { |arglist| var.=~(name) }
      end;Fi[	@ iwI"3              end
              @var.each { |arglist| var.visit_table_cell(var) }
              var.visit_exception(@var, :failed) if @var
            end
          end
        end
        
        def function(arglist)
          unless header? then
            var.step_mother.with_hooks(self) do |arglist|;Fi[	@ iI"Í                @var ||= var.reported_exception
                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end;Fi[	@#i™I"          if var.value.!=(var.value) and (var.value.to_s == var.value.to_s) then
            var.inspect!
            var.inspect!
          end
        end
      end
      
      def function(arglist)
        @var = var.map do |arglist|
          var = var.line rescue -1;Fi[	@fiîI"            @var.puts
            var.each { |arglist| @var.puts(format_string(var, :tag)) }
            @var.flush
          end
        end
      end
      
      def function(arglist)
        @var.each { |arglist| print_message(var) }
        empty_messages;Fi[	@)iFI"Í              @var.p("STRING", :id => "STRING")
              @var.p("STRING", :id => "STRING")
            end
          end
        end
      end
      
      def function(arglist)
        print_stats(var)
        (@var << "STRING");Fi[	@)i{I"‘          var[(1..-1)].each do |arglist|
            @var.text!(var.strip)
            @var.br
          end
        end
      end
      
      def function(arglist)
        @var = true
        (@var << "STRING");Fi[	@7ipI"ù            var.status = Ast::StepInvocation.worst_status(var.map { |arglist| var[:status] })
            var = var.inject(0) { |arglist| (var[:duration] + var) }
            var.mean_duration = (var / var.length)
          end
        end
      end
      
      def function(arglist)
        @var.unmatched_step_definitions.each do |arglist|
          var = StepDefKey.new(var.regexp_source, var.file_colon_line);Fi[	@Ci?I"            @var = ::Spec::Matchers)
          rescue LoadError => var
            @var = Module.new { |arglist| }
          end
        end
      end
      
      def function(arglist)
        @var.map do |arglist|
          if var = var.arguments_from(var) then;Fi[	@OiñI"«            end
          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then
          log.debug("STRING");Fi[	I"@data//cucumber_prok/cucumber/wire_support/wire_exception.rb;TiI"ª            var["STRING"].split("STRING")
          else
            var["STRING"]
          end
        end
      end
      
      def function(arglist)
        (@var or super)
      end;Fi[	I",data//devise_proj/devise/failure_app.rb;TiÇI"È          { :error => (i18n_message) }.send(var)
        else
          i18n_message
        end
      end
    end
    
    def function(arglist)
      var, var = var.split("STRING")
      var = ActiveSupport::Inflector.camelize(var);Fi[	I"0data//devise_proj/devise/mailers/helpers.rb;Ti:I"            Devise.mailer_sender.call(var.name)
          else
            Devise.mailer_sender
          end
        end
      end
      
      def function(arglist)
        var = [self.class.mailer_name]
        var.unshift("STRING") if self.class.scoped_views?;Fi[	@]izI"          @var = []
        else
          @var = (self.routes - Array(var[:skip]).map(&var))
        end
      end
    end
    
    def function(arglist)
      var = lambda { |arglist| var.to_s.singularize.to_sym }
      if (var[:skip_helpers] == true) then;Fi[	I"4data//devise_proj/devise/models/rememberable.rb;Ti8I"≥            var
          else
            raise("STRING")
          end
        end
      end
      
      def function(arglist)
        self.class.rememberable_options
      end;Fi[	@tiEI")      headers["STRING"] = AppConfig.git_update if AppConfig.git_update.present?
      if AppConfig.git_revision.present? then
        headers["STRING"] = AppConfig.git_revision
      end
    end
  end
  
  def function(arglist)
    if user_signed_in? then
      I18n.locale = current_user.language;Fi[	@tiiI"{            break
          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil)
  end;Fi[	I"Edata//diaspora_proj/controllers/aspect_memberships_controller.rb;TiI":      respond_to do |arglist|
        var.js { |arglist| render(:text => (var), :status => 403) }
        var.html { |arglist| redirect_to(:back) }
      end
    end
  end
  
  def function(arglist)
    @var = Person.find(params[:person_id])
    @var = current_user.aspects.where(:id => (params[:aspect_id])).first;Fi[	@ßiI"∫          flash[:error] = I18n.t("STRING")
          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist)
    @var = Aspect.new
    @var = params[:person_id];Fi[	@≠i/I"˛      respond_to do |arglist|
        var.mobile { |arglist| redirect_to(:back) }
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    render(:layout => (false))
  end;Fi[	@∞iI"I        var = (params[:aspect_ids] or current_user.aspects.map(&:id))
        @var = Person.all_from_aspects(var, current_user).for_json
        render(:json => (@var.to_json))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.contacts.sharing.includes(:aspect_memberships)
    render(:layout => (false));Fi[	I"7data//diaspora_proj/controllers/home_controller.rb;TiI"æ        end
      else
        render(:show, :layout => "STRING")
      end
    end
  end
  
  def function(arglist)
    if session[:mobile_view].nil? then
      session[:mobile_view] = true;Fi[	@ªi2I"        end
        @var = @var.paginate(:page => (params[:page]), :per_page => 15)
        @var = hashes_for_people(@var, @var)
      end
    end
  end
  
  def function(arglist)
    @var = :search
    @var = Person.where(:diaspora_handle => (search_query.downcase));Fi[	@æi7I"Œ        end
      else
        legacy_create
      end
    end
  end
  
  def function(arglist)
    var = current_user.person_id
    @var = Photo.where(:id => (params[:photo_id]), :author_id => (var)).first;Fi[	I"8data//diaspora_proj/controllers/posts_controller.rb;Ti$I""      var.mobile { |arglist| render("STRING", :layout => "STRING") }
      var.json do |arglist|
        render(:json => (PostPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    render(:text => (post_iframe_url(params[:id])), :layout => (false))
  end;Fi[	@—	i=I"-      var.html { |arglist| redirect_to(post_path(var)) }
      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).older(@var)
    respond_to do |arglist|;Fi[	@—	iGI"      var.html { |arglist| redirect_to(post_path(var)) }
      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    respond_with(PostInteractionPresenter.new(@var, current_user))
  end;Fi[	@¡iI"‰    respond_to do |arglist|
      var.json do |arglist|
        render(:json => (PersonPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.person
    @var = :person_edit;Fi[	@–iCI"        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist)
    session[:a_ids] = params[:a_ids] if params[:a_ids].present?
  end;Fi[	I"Adata//diaspora_proj/controllers/tag_followings_controller.rb;Ti&I"    else
      respond_to do |arglist|
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    respond_to do |arglist|
      var.json { |arglist| render(:json => (tags.to_json), :status => 200) };Fi[	@”iI"t      respond_to do |arglist|
        var.json { |arglist| render(:nothing => (true), :status => 422) }
        var.html { |arglist| redirect_to(tag_path("STRING")) }
      end
    end
  end
  
  def function(arglist)
    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]));Fi[	@zi[I"Å      var.js { |arglist| render(:nothing => (true), :status => 204) }
      var.all do |arglist|
        redirect_to((var ? (new_user_session_path) : (edit_user_path)))
      end
    end
  end
  
  def function(arglist)
    if params[:user] and (params[:user][:current_password] and current_user.valid_password?(params[:user][:current_password])) then
      current_user.close_account!;Fi[	I"1data//diaspora_proj/helpers/mobile_helper.rb;TiI"Ú        var = Reshare.where(:author_id => (current_user.person_id), :root_guid => (var.guid)).first
        var = var.present? ? ("STRING") : ("STRING")
        link_to("STRING", reshares_path(:root_guid => (var.guid)), :title => (t("STRING", :author => (var.author_name))), :class => "STRING")
      end
    end
  end
  
  def function(arglist)
    if current_user and current_user.liked?(var) then
      link_to("STRING", post_like_path(var.id, current_user.like_for(var).id), :class => "STRING");Fi[	I"8data//diaspora_proj/helpers/notifications_helper.rb;TiI"Œ        end
      else
        translation(var, :actors => (var), :count => (var))
      end
    end
  end
  
  def function(arglist)
    { :post_author => (nil) }.merge!(var)
    t("STRING", var).html_safe;Fi[	I"1data//diaspora_proj/helpers/people_helper.rb;TiI"    else
      content_tag(:h2, :id => "STRING") do |arglist|
        ((t("STRING").html_safe + "STRING") + content_tag(:span, search_query, :class => "STRING"))
      end
    end
  end
  
  def function(arglist)
    if search_query then
      I18n.t("STRING", :params => (search_query));Fi[	@ÅiI"’            I18n.t("STRING", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516
    var[:height] ||= 315;Fi[	@ÑiI"å            raise("STRING")
          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare)
  end;Fi[	I"/data//diaspora_proj/helpers/tags_helper.rb;TiI"Ò    content_tag("STRING") do |arglist|
      content_tag("STRING") do |arglist|
        t("STRING", :tag_link => (tag_link)).html_safe
      end
    end
  end
  
  def function(arglist)
    ActsAsTaggableOn::Tag.normalize(search_query)
  end;Fi[	@ﬁi/I"˜      mail(var) do |arglist|
        var.text { |arglist| render(:layout => (nil)) }
        var.html { |arglist| render(:layout => (nil)) }
      end
    end
  end
  
  def function(arglist)
    send_notification(:started_sharing, var, var)
  end;Fi[	@ﬁi[I"¥      mail(@var.headers) do |arglist|
        var.text
        var.html
      end
    end
  end
  
  def function(arglist)
    I18n.with_locale(@var.recipient.language, &var)
  end;Fi[	I"*data//diaspora_proj/models/comment.rb;TiGI"ç        return Notifications::AlsoCommented
      else
        return false
      end
    end
  end
  
  def function(arglist)
    Post
  end;Fi[	I"/data//diaspora_proj/models/notification.rb;Ti&I"å        else
          nil
        end
      end
    end
  end
  
  def function(arglist)
    super(var.merge(:methods => :note_html))
  end;Fi[	@ÍiçI"Ù    else
      if ["STRING", "STRING", "STRING"].all? { |arglist| var[var].blank? } then
        self.birthday = nil
      end
    end
  end
  
  def function(arglist)
    birthday.to_s(:long).gsub("STRING", "STRING") if birthday.present?
  end;Fi[	@ˆi∂I"“      else
        var = self.user_preferences.where(:email_type => (var)).first
        var.destroy if var
      end
    end
  end
  
  def function(arglist)
    if username.present? then
      username.strip!;Fi[	@çixI"ﬂ            @var = @var.parent.value[:dont_indent_next_line]
            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	I"(data//homebrew_proj/cmd/--config.rb;Ti)I"·        @var = MacOS::Xcode.version
        @var = (@var + "STRING") unless MacOS::Xcode.default_prefix?
        @var
      end
    end
  end
  
  def function(arglist)
    if instance_variable_defined?(:@clt) then
      @var;Fi[	@
i3I"    else
      if MacOS::CLT.installed? and (MacOS::Xcode.version.to_f >= 4.3) then
        @var = MacOS::CLT.version
      end
    end
  end
  
  def function(arglist)
    var = HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-parse --verify -q HEAD 2>/dev/null`.chomp;Fi[	@iiI"◊        problem("STRING".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|
      var = Formula.factory(var.formula) rescue problem("STRING");Fi[	@i£I"o        problem("STRING") unless (var.hexdigest.length == var)
        problem("STRING") unless var.hexdigest =~ /^[a-fA-F0-9]+$/
        problem("STRING") unless (var.hexdigest == var.hexdigest.downcase)
      end
    end
  end
  
  def function(arglist)
    ENV.setup_build_environment
    Patches.new(f.patches).select { |arglist| var.external? }.each do |arglist|;Fi[	@i±I"‚        problem("STRING")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then
      problem("STRING");Fi[	@öiLI"{            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist)
    system("STRING")
  end;Fi[	@iI"        info_formula(Formula.factory(ARGV.shift))
      else
        ARGV.formulae.each { |arglist| info_formula(var) }
      end
    end
  end
  
  def function(arglist)
    require("vendor/multi_json")
    var = ARGV.include?("STRING") ? (Formula) : (ARGV.formulae);Fi[	@i2I"B    if which("STRING") and (HOMEBREW_REPOSITORY / "STRING").directory? then
      if `git remote -v` =~ /origin\s+(https?:\/\/|git(?:@|:\/\/))github.com[:\/](.+)\/homebrew/ then
        $2
      end
    end
  end
  
  def function(arglist)
    var = var.path.realpath
    if var.to_s =~ /#{HOMEBREW_REPOSITORY}STRING/ then;Fi[	@iKI"Ø        else
          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = []
    var = [];Fi[	I"'data//homebrew_proj/cmd/options.rb;Ti I"‘        puts(var.name) if (ff.length > 1)
        dump_options_for_formula(var)
        puts
      end
    end
  end
  
  def function(arglist)
    var.build.sort_by(&:flag).each do |arglist|
      puts(var.flag);Fi[	I"(data//homebrew_proj/cmd/outdated.rb;TiI"Œ        puts("STRING")
      else
        puts(var.name)
      end
    end
  end
  
  def function(arglist)
    Formula.installed.map do |arglist|
      var = var.rack.subdirs.map { |arglist| Keg.new(var) };Fi[	@ùi5I"‚            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist)
    (return [] if (HOMEBREW_LIBRARY / "STRING").directory?
    require("open-uri");Fi[	@i∆I"ı        get_externals { |arglist| fetch_repo((@var + var), var, @var[var], true) }
      else
        fetch_repo(@var, @var)
      end
    end
  end
  
  def function(arglist)
    quiet_safe_system(@@var, "STRING", "STRING", @var, Dir.pwd)
  end;Fi[	@ikI"*      Dir.chdir(HOMEBREW_CACHE) do |arglist|
        safe_system("STRING", "STRING", var, "STRING")
        safe_system("STRING", "STRING", var, "STRING", "STRING", @var, var)
      end
    end
  end
  
  def function(arglist)
    FileUtils.cp_r(Dir[(@var + "STRING")], Dir.pwd)
    require("find");Fi[	@™iºI"®        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("STRING") { |arglist| var.read(1024) })
  end;Fi[	@™iI"à            raise("STRING".undent)
          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s)
  end;Fi[	I"-data//homebrew_proj/formula_installer.rb;TiI"Ø          puts("STRING")
          @var = true
        end
      end
    end
  end
  
  def function(arglist)
    if (f.prefix + "STRING").directory? then
      opoo("STRING");Fi[	I"'data//homebrew_proj/macos/xcode.rb;TitI"à          "STRING"
        else
          "STRING"
        end
      end
  end
  
  def function(arglist)
    (version.to_f < 4.3)
  end;Fi[	I"!data//homebrew_proj/macos.rb;TiI"È        else
          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist)
    (@var ||= {}).fetch(var.to_s) do |arglist|
      @var[var.to_s] = if File.executable?("STRING") then;Fi[	@,
i)I"         end
        var = ["STRING", "STRING", "STRING"]
        var.map { |arglist| Pathname.new(var) }.find { |arglist| var.executable? }
      end
    end
  end
  
  def function(arglist)
    @var ||= if File.exist?("STRING") and File.exist?("STRING") then
      Pathname.new("STRING");Fi[	@,
i5I"˜        Pathname.new(`/usr/bin/xcrun -find make`.chomp).dirname
      else
        Pathname.new("STRING") if File.exist?("STRING")
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new("STRING")
    var if var.exist?);Fi[	@,
i\I"ﬂ        :clang
      else
        (Xcode.version >= "STRING") ? (:llvm) : (:gcc)
      end
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /build (\d{4,})/;Fi[	@#iI"ƒ      var.each do |arglist|
        (@var << Patch.new(var, ("STRING" % var), var))
        var = (var + 1)
      end
    end
  end
  
  def function(arglist)
    external_curl_args.empty?.!
  end;Fi[	I",data//homebrew_proj/test/test_bucket.rb;TiII"≈        var = TestBallWithRealPath.new
        Homebrew.info_formula(var)
        Homebrew.prune
      end
    end
  end
  
  def function(arglist)
    require("cmd/cleanup")
    var = TestBall.new;Fi[	@7
iÑI"“        assert(var.exist?)
        HOMEBREW_CACHE.chmod_R(511)
        var.unlink
      end
    end
  end
  
  def function(arglist)
    var = (HOMEBREW_CACHE / "STRING")
    assert_equal("STRING", var.extname);Fi[	I"-data//homebrew_proj/test/test_formula.rb;TiI"S      TestBall.new.brew do |arglist|
        assert_equal(File.expand_path(var.prefix), ((HOMEBREW_CELLAR + var.name) + "STRING").to_s)
        assert_kind_of(Pathname, var.prefix)
      end
    end
  end
  
  def function(arglist)
    assert_equal("STRING", Formula.class_s("STRING"))
    assert_equal("STRING", Formula.class_s("STRING"));Fi[	I".data//homebrew_proj/test/test_patching.rb;Ti&I"        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("STRING").brew do |arglist|;Fi[	@?
i0I"        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("STRING").brew do |arglist|;Fi[	@?
i:I"        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("STRING").brew do |arglist|;Fi[	@ßiuI"Æ            "STRING"
          else
            (var.value.first + "STRING")
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@?i;I"˛      ["STRING"].each do |arglist|
        unless @var.respond_to?("STRING") and @var.respond_to?("STRING") then
          raise(Paperclip::Error.new("STRING"))
        end
      end
    end
    
    def function(arglist)
      Paperclip.log(var)
    end;Fi[	@?ikI"p      instance.run_paperclip_callbacks(:post_process) do |arglist|
        instance.run_paperclip_callbacks(:"#{name}STRING") do |arglist|
          post_process_styles(*var)
        end
      end
    end
    
    def function(arglist)
      if styles.include?(:original) and process_style?(:original, var) then
        post_process_style(:original, styles[:original]);Fi[	@?i™I"5        var.close unless var.closed?
        if var.respond_to?(:unlink) and (var.path.present? and File.exist?(var.path)) then
          var.unlink
        end
      end
    end
    
    def function(arglist)
      if @var[:restricted_characters] then
        var.gsub(@var[:restricted_characters], "STRING");Fi[	I".data//paperclip_proj/paperclip/helpers.rb;Ti2I"◊          var.const_get(var, false)
        else
          var.const_missing(var)
        end
      end
    end
    
    def function(arglist)
      @var ||= {}
      var = (var or Attachment.default_options[:path]);Fi[	@„i>I"           if @var.present? then
            "STRING".tap do |arglist|
              @var.any? ? ((var << "STRING")) : ((var << "STRING"))
            end
          end
        end
        
        def function(arglist)
          if @var.present? then
            "STRING".tap do |arglist|;Fi[	@„iFI"˘          if @var.present? then
            "STRING".tap do |arglist|
              @var.any? ? ((var << "STRING")) : ((var << "STRING"))
            end
          end
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@`i\I""            "STRING"
          else
            directory.files.new(:key => (path(var))).public_url
          end
        end
      end
      
      def function(arglist)
        if directory.files.respond_to?(:get_http_url) then
          var = directory.files.get_http_url(path(var), var);Fi[	@`iÑI"            (@var[:fog_host] % (path(var).hash % 4))
          else
            @var[:fog_host]
          end
        end
      end
      
      def function(arglist)
        if @var[:fog_directory].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "STRING";Fi[	@`iùI"⁄            var.call(self)
          else
            raise(ArgumentError, "STRING")
          end
        end
      end
      
      def function(arglist)
        @var ||= ::Fog::Storage.new(fog_credentials)
      end;Fi[	I"4data//paperclip_proj/paperclip/url_generator.rb;TiI"‡          @var.instance.send(@var[:default_url])
        else
          @var[:default_url]
        end
      end
    end
    
    def function(arglist)
      @var.original_filename.nil? ? (default_url) : (@var[:url])
    end;Fi[	@eiI"¡              var = options[:in] ? (:in_between) : (var)
              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "STRING");Fi[	@ei/I"*          else
            var[:less_than_or_equal_to] = var
            var[:greater_than_or_equal_to] = var
          end
        end
      end
      
      def function(arglist)
        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min);Fi[	@si†I"ƒ        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var);Fi[	@si5I"À          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]));Fi[	@viõI"∆        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      SJISWrite(var, var, var, var);Fi[	@vi>I"À          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]));Fi[	@yièI"ƒ        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var);Fi[	@yi$I"À          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]));Fi[	@ÅiëI"‰          self.Error(("STRING" + var)) unless self.respond_to?(var)
          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist)
    var = @var ? ("STRING") : ("STRING")
    @var.each do |arglist|;Fi[	@Åi∏I"(        out((((("STRING" + var) + "STRING") + var.length.to_s) + "STRING"))
        putstream(var)
        out("STRING")
      end
    end
  end
  
  def function(arglist)
    @var.each_value do |arglist|
      out((((("STRING" + var["STRING"].to_s) + "STRING") + var["STRING"].to_s) + "STRING"));Fi[	@Åi˙I"†        out("STRING")
      else
        out("STRING") if (@var == "STRING")
      end
    end
  end
  
  def function(arglist)
    out(("STRING" + @var))
  end;Fi[	@ÅiI"Ã          (var = freadshort(var)
          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist)
    while true do
      while (var = freadbyte(var)).!=(255) do;Fi[	@iÉI"¡            self.respond_to?(var).! ? (Error(("STRING" + var))) : (self.send(var, var))
          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj
    out("STRING");Fi[	@+iÉI"]            var.Bookmark(var.title, var)
            write_wiki_page(var, var)
            write_page_hierarchy(var, var, var.id, (var + 1)) if var[var.id]
          end
        end
      end
      
      def function(arglist)
        var.RDMwriteHTMLCell(190, 5, 0, 0, var.content.text.to_s, var.attachments, 0)
        if var.attachments.any? then;Fi[	@åiOI"ç            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist)
        @var = { "STRING" => ({ :sql => "STRING", :klass => (Project), :label => :label_project }), "STRING" => ({ :sql => "STRING", :klass => (IssueStatus), :label => :field_status }), "STRING" => ({ :sql => "STRING", :klass => (Version), :label => :label_version }), "STRING" => ({ :sql => "STRING", :klass => (IssueCategory), :label => :field_category }), "STRING" => ({ :sql => "STRING", :klass => (User), :label => :label_user }), "STRING" => ({ :sql => "STRING", :klass => (Tracker), :label => :label_tracker }), "STRING" => ({ :sql => "STRING", :klass => (TimeEntryActivity), :label => :label_activity }), "STRING" => ({ :sql => "STRING", :klass => (Issue), :label => :label_issue }) }
        var = @var.nil? ? (IssueCustomField.for_all) : (@var.all_issue_custom_fields);Fi[	I"'data//redmine_proj/redmine/i18n.rb;TiYI"          [ll(var.to_s, :general_lang_name), var.to_s]
        end.sort do |arglist|
          (var.first <=> var.first)
        end
      end
    end
    
    def function(arglist)
      @@languages_lookup = valid_languages.inject({}) do |arglist|
        var[var.to_s.downcase] = var;Fi[	@=i:I"¿              else
                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist)
          raise("STRING")
        end;Fi[	@íi˝I"ı            var.attributes["STRING"] = "STRING"
          else
            var.attributes["STRING"] = "STRING"
          end
        end
      end
      
      def function(arglist)
        return @var.collect { |arglist| var[:title] }
      end;Fi[	@íiOI"            var = var[var]
            var = (var + var.attributes["STRING"]) if var.attributes["STRING"]
            var.attributes["STRING"] = var
          end
        end
      end
      
      def function(arglist)
        var = get_style
        var = {};Fi[	I"-data//rspec_proj/spec/matchers/change.rb;Ti+I"·            "STRING"
          else
            @var ? ("STRING") : (@var ? ("STRING") : (@var ? ("STRING") : ("STRING")))
          end
        end
      end
      
      def function(arglist)
        (@var - @var)
      end;Fi[	@¶i9I"ø            return "STRING"
          else
            return "STRING" if (@var == :at_least)
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	I"8data//rspec_proj/spec/mocks/argument_expectation.rb;TiI"C            @var = []
          else
            @var = var.collect { |arglist| matcher_for(var) }
          end
        end
      end
      
      def function(arglist)
        return ArgumentMatchers::MatcherMatcher.new(var) if is_matcher?(var)
        return ArgumentMatchers::RegexpMatcher.new(var) if var.is_a?(Regexp);Fi[	@≤i<I"#            @var
          else
            Class.===(@var) ? ("STRING") : (@var ? (@var) : ("STRING"))
          end
        end
      end
      
      def function(arglist)
        var = opts[:message] unless opts[:message].nil?
        Kernel.raise(Spec::Mocks::MockExpectationError, var);Fi[	@ÇiI"¬                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var)
      end;Fi[	@Çi∂I"€            "STRING"
          else
            target_metaclass.protected_method_defined?(var) ? ("STRING") : ("STRING")
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@ÇiﬂI"À          if method_defined?(var) then
            alias_method(var, var)
            remove_method(var)
          end
        end
      end
      
      def function(arglist)
        @var.nil?
      end;Fi[	@øi±I"G          var = var.to_sym if var
          var.each do |arglist|
            Spec::Example::ExampleGroupFactory[var].__send__(var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = scope_and_options(*var)
        var = Spec::Example::ExampleGroupFactory[get_type_from_options(var)];Fi[	@ºi4I"!            var.instance_methods(false).each do |arglist|
              var = @var.new(var.name, var, Spec::Runner.options)
              var.validate
            end
          end
        end
        
        def function(arglist)
          var.to_class rescue raise("STRING")
        end;Fi[	I"6data//rspec_proj/spec/runner/line_number_query.rb;Ti-I"Q          consider_example_group_for_best_match(var, var, var)
          var.examples.each do |arglist|
            consider_example_for_best_match(var, var, var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = parse_location(var.location)
        if is_best_match?(var, var, var, var) then;Fi[	I",data//rspec_proj/spec/runner/options.rb;TiwI"        ensure
          after_suite_parts.each do |arglist|
            (var.arity < 1) ? (var.call) : (var.call(var))
          end
        end
      end
      
      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.before_suite_parts
      end;Fi[	@ú
iìI"’          rescue LoadError
            warn("STRING")
            @var = false
          end
        end
      end
      
      def function(arglist)
        case var
        when :context, "STRING", "STRING" then;Fi[	@ú
i¸I"6        Spec::Runner.configuration.predicate_matchers.each_pair do |arglist|
          Spec::Example::ExampleMethods.__send__(:define_method, var) do |arglist|
            eval("STRING")
          end
        end
      end
      
      def function(arglist)
        case mock_framework
        when Module then;Fi[	@ƒi&I"'            example_pending(var, var.location, var.message)
          else
            example_failed(var, var)
          end
        end
      end
      
      def function(arglist)
        backtrace_tweaker.tweak_backtrace(var)
        var = Failure.new(@var.description, var.description, var);Fi[	@ƒièI"Û            var.example_pending(var, var, var.location)
          else
            var.example_pending(var, var)
          end
        end
      end
      
      def function(arglist)
        (var.method(:example_pending).arity == 3)
      end;Fi[	I"1data//SiriProxy_proj/siriproxy/connection.rb;TiTI"      if var.!=(nil) then
        var = prep_received_object(var)
        inject_object_to_output_stream(var) if var.!=(nil)
      end
    end
  end
  
  def function(arglist)
    return false if unzipped_input.empty?
    var = unzipped_input[(0...5)].unpack("STRING").first;Fi[	I")data//whenever_proj/whenever/cron.rb;Ti$I"#        enumerate(var).each do |arglist|
          enumerate(var.at, false).each do |arglist|
            yield(new(var, var.output, var).output)
          end
        end
      end
      
      def function(arglist)
        [time_in_cron_syntax, task].compact.join("STRING").strip
      end;Fi[	@™
i]I"∏            end
          else
            parse_as_string
          end
        end
      end
      
      def function(arglist)
        var = Array.new(5, "STRING")
        case @var;Fi[	I"(data//whenever_proj/whenever/job.rb;Ti2I"ú          else
            var
          end
        end
      end
    end
    
    def function(arglist)
      var.gsub(/'/) { |arglist| "STRING" }
    end;Fi[	I"-data//whenever_proj/whenever/job_list.rb;Ti2I"*          var[:output] = @var if defined? @var and var.has_key?(:output).!
          @var[@var] ||= []
          (@var[@var] << Whenever::Job.new(@var.merge(@var).merge(var)))
        end
      end
    end
    
    def function(arglist)
      [environment_variables, cron_jobs].compact.join
    end;Fi[	@≤
iKI"¿          var = var.strip.to_sym
          set(var, var.strip)
          @var[var] = var
        end
      end
    end
    
    def function(arglist)
      return if @var.empty?
      var = [];Fi[@(@I"def function(arglist);FI""STRING";FI"end;Fiì[ì[	@MiI"      class JoinBase < JoinPart
        def function(arglist)
          (var.class == self.class) and (var.active_record == active_record)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@^iI"Œ        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	I"^data//activerecord_proj/active_record/connection_adapters/abstract/database_statements.rb;Ti-I"π          quote(var, var[var])
        end
        execute("STRING", "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@¿
i1I"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@¿
i5I"—      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      # Sanitizes the given LIMIT parameter in order to prevent SQL injection.;Fi[	I"Rdata//activerecord_proj/active_record/connection_adapters/abstract/quoting.rb;TiiI"Â      # Quotes the table name. Defaults to column name quoting.
      def function(arglist)
        quote_column_name(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@«
imI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ˇiI"◊      
      def function(arglist)
        var[var].lower.eq(var.lower(var))
      end
      
      def function(arglist)
        "STRING"
      end
      
      # Check the connection back in to the connection pool;Fi[	@Åi8I"‰          var.table(var.source)
          var.wheres = var.constraints
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      # SCHEMA STATEMENTS ========================================;Fi[	@ÅiuI"≥        var = "STRING"
        add_column_options!(var, var)
        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@§iÀI"⁄      
      def function(arglist)
        @var.class.quote(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      # Quote date/time values for use in SQL input. Includes microseconds;Fi[	@îi‰I"o          end
        end
      end
    end
    
    def function(arglist)
      "STRING"
    end
  end
  ;Fi[	@/	ilI"¬            defined? Mysql ? (Mysql::Error) : (StandardError)
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	I"(data//backup_proj/backup/package.rb;Ti)I"é      else
        chunk_suffixes.map { |arglist| "STRING" }
      end
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ﬁi·I"û    
    def function(arglist)
      "STRING" if `which more` rescue "STRING".empty?.!
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@‰i!I"Ñ    
    def function(arglist)
      @var.requirement
    end
    
    def function(arglist)
      "STRING"
    end
    
    private;Fi[	@ıi I"’      @var = {}
      @var = Hash.new { |arglist| var[var] = [] }
      var.specs.each { |arglist| @var[var] = var.dup }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@ iQI"ë      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	@/iñI"¢        else
          Bundler.cache.join("STRING", var)
        end)
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	@7i1I"÷        (var << "STRING")
        (var << "STRING") unless (@var == DEFAULT_GLOB)
        (var << "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@vi_I"«        
        def function(arglist)
          Evaluator.new(configuration, condition, var).result
        end
        
        def function(arglist)
          "STRING"
        end
      end
      ;Fi[	@úi{I"–          
          def function(arglist)
            (@var == "STRING")
          end
          
          def function(arglist)
            "STRING"
          end
          
          def function(arglist);Fi[	@x	iFI"™    
    def function(arglist)
      transfers.any? { |arglist| var.active? }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@‰iI"–      module ConfigurationDefaults
        def function(arglist)
          :stand_alone
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@‰iI"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@‰iI"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@‰iI"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@‰iI"ù        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end
    end;Fi[	I"+data//compass_proj/compass/compiler.rb;Ti3I"√    
    def function(arglist)
      @var ||= sass_files.map { |arglist| corresponding_css_file(var) }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	I"9data//compass_proj/compass/configuration/defaults.rb;TiI"¢      
      def function(arglist)
        :stand_alone
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@˙
iI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@i*I"⁄              raise(Sass::SyntaxError, "STRING")
            end
          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        # The on-the-disk filename of the sprite;Fi[	I"0data//cucumber_prok/cucumber/ast/feature.rb;TiLI"√        var = @var.index(var)
        var = @var[(var + 1)]
        var.call(var) if var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@iWI"≤          var = var.gsub(/\//, "STRING")
        end
        @var = var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ i¢I"…        
        def function(arglist)
          @var.backtrace_line(name, line)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@PiqI"®          var[delimited(var)] = var
          var
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@#iBI"®        
        def function(arglist)
          @var[0].line
        end
        
        def function(arglist)
          "STRING"
        end
        
        private;Fi[	I"2data//cucumber_prok/cucumber/core_ext/proc.rb;TiI"ï  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  if Proc.new { |arglist| }.to_s.=~(PROC_PATTERN) then;Fi[	@)iºI"ƒ      
      def function(arglist)
        File.read((File.dirname("STRING") + "STRING"))
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@:i2I"“      def function(arglist)
        var = eval_js("STRING")
        var.to_a[(1..-1)].map { |arglist| JsArg.new(var) } if var
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	@ÑiI"¢      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	I"'data//devise_proj/devise/models.rb;Ti
I"Æ    class MissingAttribute < StandardError
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	I"Cdata//devise_proj/generators/active_record/devise_generator.rb;Ti$I""        var = (var.size - 1)
        var = (var.split("STRING").map { |arglist| (("STRING" * var) + var) }.join("STRING") << "STRING")
        inject_into_class(model_path, var.last, var) if model_exists?
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end;Fi[	I";data//devise_proj/generators/devise/views_generator.rb;TifI"•      
      def function(arglist)
        view_directory(:markerb, target_path)
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	I"=data//devise_proj/generators/mongoid/devise_generator.rb;TiI"         if model_exists? then
          inject_into_file(model_path, model_contents, :after => "STRING")
        end
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end;Fi[	I"6data//diaspora_proj/helpers/application_helper.rb;TiI"}  
  def function(arglist)
    raw_bookmarklet
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"?data//diaspora_proj/models/notifications/also_commented.rb;TiI"∂class Notifications::AlsoCommented < Notification
  def function(arglist)
    Jobs::Mail::AlsoCommented
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@$iI"{  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"@data//diaspora_proj/models/notifications/comment_on_post.rb;TiI"∂class Notifications::CommentOnPost < Notification
  def function(arglist)
    Jobs::Mail::CommentOnPost
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@)iI"{  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"6data//diaspora_proj/models/notifications/liked.rb;TiI"¶class Notifications::Liked < Notification
  def function(arglist)
    Jobs::Mail::Liked
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@.iI"{  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I":data//diaspora_proj/models/notifications/mentioned.rb;TiI"Æclass Notifications::Mentioned < Notification
  def function(arglist)
    Jobs::Mail::Mentioned
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@3iI"{  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"@data//diaspora_proj/models/notifications/private_message.rb;TiI"∆class Notifications::PrivateMessage < Notification
  def function(arglist)
    Jobs::Mail::PrivateMessage
  end
  
  def function(arglist)
    "STRING"
  end
  
  def self.make_notification(arglist);Fi[	I"Adata//diaspora_proj/models/notifications/request_accepted.rb;TiI"•class Notifications::RequestAccepted < Notification
  def function(arglist)
    Jobs::Mail::RequestAcceptance
  end
  
  def function(arglist)
    "STRING"
  end
end;Fi[	I"9data//diaspora_proj/models/notifications/reshared.rb;TiI"¨class Notifications::Reshared < Notification
  def function(arglist)
    Jobs::Mail::Reshared
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@>iI"{  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"@data//diaspora_proj/models/notifications/started_sharing.rb;TiI"∏class Notifications::StartedSharing < Notification
  def function(arglist)
    Jobs::Mail::StartedSharing
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@Ái¬I"~      var = @var["STRING"]
    end
    var
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"'data//diaspora_proj/models/post.rb;Ti<I"  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@Íi¬I"¥  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["STRING", "STRING", "STRING"])
  end
  
  def function(arglist)
    "STRING"
  end
end;Fi[	I"4data//diaspora_proj/models/services/facebook.rb;Ti%I"{  
  def function(arglist)
    super(var, MAX_CHARACTERS, var)
  end
  
  def function(arglist)
    "STRING"
  end
end;Fi[	@
iZI"å  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"0data//homebrew_proj/compat/compatibility.rb;TiII"†    var = FailsWithLLVM.new(var, var)
    @var ||= CompilerFailures.new
    (@var << var)
  end
  
  def function(arglist)
    "STRING"
  end
  
  class << self;Ti[	@i%I"Ø        MacOS.pkgutil_info(FORGE_PKG_ID) =~ /version: (\d\.\d\.\d).+$/ and $1
      end
    end)
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	I"4data//jekyll_proj/jekyll/converters/markdown.rb;TiVI"ˆ    def function(arglist)
      var = (("STRING" + @var["STRING"].gsub("STRING", "STRING")) + "STRING")
      var.=~(Regexp.new(var, Regexp::IGNORECASE))
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	I"3data//jekyll_proj/jekyll/converters/textile.rb;TiI"ˆ    def function(arglist)
      var = (("STRING" + @var["STRING"].gsub("STRING", "STRING")) + "STRING")
      var.=~(Regexp.new(var, Regexp::IGNORECASE))
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	I"/data//jekyll_proj/jekyll/tags/highlight.rb;Ti0I"Ã      var = (var["STRING"] + var) if var["STRING"]
      var = (var + var["STRING"]) if var["STRING"]
      var
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	I"Adata//mongoid_proj/lib/rails/generators/mongoid_generator.rb;Ti"I"µ      
      def self.build(arglist)
        var ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@`i&I"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@`i*I"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@`i.I"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@`i2I"â      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end;Fi[	@ßiwI"            (var.value.first + "STRING")
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      { "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING" }.each do |arglist|;Fi[	I"4data//nokogiri_proj/nokogiri/xml/entity_decl.rb;TiI"ù      
      def self.new(arglist)
        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end;Fi[	@:iiI"´          raise(ArgumentError, "STRING")
        end
        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	I")data//omni_proj/omniauth/strategy.rb;Ti{I"#      self.class.args.each { |arglist| options[var] = var.shift }
      raise(ArgumentError, "STRING") unless var.empty?
      yield(options) if block_given?
    end
    
    def function(arglist)
      "STRING"
    end
    
    # Direct access to the OmniAuth logger, automatically prefixed;Fi[	I"Edata//paperclip_proj/generators/paperclip/paperclip_generator.rb;TiI"{  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist);Fi[	@QiI"ï    
    def function(arglist)
      @var.read(var, var)
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	I">data//paperclip_proj/paperclip/io_adapters/nil_adapter.rb;Ti	I"Æ  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@ziI"ä    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@‡iI"Ù          @var = var
          @var = @var.class unless Class.===(@var)
          responds? and (has_column? and included?)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@‡i I"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@‡i$I"¶        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected;Fi[	@„i2I"Ï            (var << "STRING") if @var.present? and @var.present?
            (var << rejected_types_and_failures)
          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected;Fi[	@„iHI"⁄              @var.any? ? ((var << "STRING")) : ((var << "STRING"))
            end
          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@ÊiI"˜          @var = var
          @var = var.new if (var.class == Class)
          error_when_not_valid? and no_error_when_valid?
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@ÊiI"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@Êi#I"¶        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected;Fi[	@Èi.I"          @var = var
          @var = @var.new if (@var.class == Class)
          lower_than_low? and (higher_than_low? and (lower_than_high? and higher_than_high?))
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@Èi2I"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@Èi6I"¶        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected;Fi[	@ji8I"ä    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@ji<I"ä    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@èi;I"π      
      def function(arglist)
        @var ||= assets("STRING", "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@èi?I"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@èiCI"ê      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	@OiI"◊          heads_for_wiki_formatter
          var = "STRING"
          javascript_tag("STRING")
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	I")data//redmine_proj/SVG/Graph/Plot.rb;Ti∫I"ü          end
          var = (var + 1))
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	I"'data//rescue_proj/resque/worker.rb;TiÁI"Ï    # Is this worker the same as another worker?
    def function(arglist)
      (to_s == var.to_s)
    end
    
    def function(arglist)
      "STRING"
    end
    
    # The string representation is the same as the id for this worker;Fi[	I" data//rescue_proj/resque.rb;Ti∏I"≤  # Register an after_perform proc.
  def function(arglist)
    register_hook(:after_perform, var)
  end
  
  def function(arglist)
    "STRING"
  end
  
  attr_accessor(:inline);Fi[	@ûiI"™      def function(arglist)
        @var = var
        @var.!.!
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ûiI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ûi!I"∏      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      [:==, :<, :<=, :>=, :>, :===].each do |arglist|;Fi[	@ûiKI"ª      def function(arglist)
        @var = var
        @var.__send__(@var, @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ûiTI"÷      def function(arglist)
        var = "STRING"
        raise((var << ([:===, :==].include?(@var) ? ("STRING") : ("STRING"))))
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	@ûinI"§        rescue NameError
          raise(var)
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ûirI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ûivI"ê      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	@ûiôI"≥      def function(arglist)
        @var = var
        @var.equal?(@var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ûiùI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ûi°I"à      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	@Ö
i1I"£      
      def function(arglist)
        (@var - @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@Ö
iNI"ê      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	@£iI"¡      
      def function(arglist)
        var.__send__(predicate(@var), *@var, &@var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@£iI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@£iI"ê      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	@¶i'I"Ò        return (@var >= @var) if (@var == :at_least)
        return (@var <= @var) if (@var == :at_most)
        return (@var == @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@¶i+I"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@¶i;I"∑            return "STRING" if (@var == :at_least)
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@¶iSI"á        @var = var
        @var = var
        self
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	@©iI"⁄        var = (var + "STRING") unless @var.empty?
        var = (var + "STRING") unless @var.empty?
        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@©iI"ê      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	@¨i;I"∏      
      def function(arglist)
        @var ? (@var.message) : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@¨i?I"ê      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	I"1data//rspec_proj/spec/matchers/respond_to.rb;TiI"‚          (@var << var) unless var.respond_to?(var) and matches_arity?(var, var)
        end
        return @var.empty?
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@⁄iI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@⁄iI"û      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	I".data//rspec_proj/spec/matchers/satisfy.rb;TiI"Æ        @var = var if var
        @var = var
        @var.call(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@·iI"à      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	I"5data//rspec_proj/spec/matchers/simple_matcher.rb;Ti$I"∞      
      def function(arglist)
        (@var or @var.nil? ? (explanation) : ("STRING"))
      end
      
      def function(arglist)
        "STRING"
      end
    end
    ;Fi[	@Øi,I"¶      
      def function(arglist)
        @var ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      private;Fi[	I"5data//rspec_proj/spec/mocks/argument_matchers.rb;TiI"ò        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "STRING"
        end
      end
      ;Fi[	@ÎiEI"Ø          rescue NoMethodError => var
            return false
          end
        end
        
        def function(arglist)
          "STRING"
        end
      end
      ;Fi[	@ÎiZI"Ø          rescue NoMethodError => var
            return false
          end
        end
        
        def function(arglist)
          "STRING"
        end
      end
      ;Fi[	@∑iI"¥      # target.
      def function(arglist)
        (var == __mock_proxy)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@Çi∏I"⁄            target_metaclass.protected_method_defined?(var) ? ("STRING") : ("STRING")
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@øiΩI"∫      
      def function(arglist)
        (var[:type] or var[:behaviour_type])
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@§iI"…          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@§iÉI"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@§iáI"≤        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist);Fi[	@§iãI"ù        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end
    end;Fi[	I"1data//whenever_proj/whenever/command_line.rb;TikI"À    def function(arglist)
      var = var.split($/, -1)[(@var[:cut]..-1)].join($/)
      var.gsub!(/\s+$/, $/)
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@ ioI"ä    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[	@ isI"z    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	I"7data//whenever_proj/whenever/output_redirection.rb;Ti9I"Å        else
          "STRING"
        end
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end;Fi[I" ;FI"def function(arglist);FI""STRING";FI"end;FI" ;FiÇ[Ç[	@MiI"        def function(arglist)
          (var.class == self.class) and (var.active_record == active_record)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          Arel::Table.new(table_name, arel_engine);Fi[	@^iI"Ú        def function(arglist)
          reflection.active_record_primary_key
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          join_table[reflection.foreign_key];Fi[	@¿
i.I"´        end
        execute("STRING", "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@¿
i2I"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@¿
i6I"“      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      # Sanitizes the given LIMIT parameter in order to prevent SQL injection.
      #;Fi[	@«
ijI"∂      def function(arglist)
        quote_column_name(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@«
inI"Ω      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        if var.acts_like?(:time) then;Fi[	@ˇiI"Ï      def function(arglist)
        var[var].lower.eq(var.lower(var))
      end
      
      def function(arglist)
        "STRING"
      end
      
      # Check the connection back in to the connection pool
      def function(arglist);Fi[	@Åi9I"”          var.wheres = var.constraints
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      # SCHEMA STATEMENTS ========================================
      #:nodoc:;Fi[	@ÅivI"÷        add_column_options!(var, var)
        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var.map { |arglist| remove_column_sql(var, var) };Fi[	@§iÃI"      def function(arglist)
        @var.class.quote(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      # Quote date/time values for use in SQL input. Includes microseconds
      # if the value is a Time responding to usec.;Fi[	@/	imI"‰          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        configuration_without_database.merge("STRING" => "STRING", "STRING" => (root_password));Fi[	@‰i"I"Ñ    def function(arglist)
      @var.requirement
    end
    
    def function(arglist)
      "STRING"
    end
    
    private
    ;Fi[	@ıi!I"Î      @var = Hash.new { |arglist| var[var] = [] }
      var.specs.each { |arglist| @var[var] = var.dup }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      each { |arglist| return false };Fi[	@ iRI"ë      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@/ióI"ú          Bundler.cache.join("STRING", var)
        end)
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@7i2I"‘        (var << "STRING") unless (@var == DEFAULT_GLOB)
        (var << "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        self.class.hash;Fi[	@úi|I"          def function(arglist)
            (@var == "STRING")
          end
          
          def function(arglist)
            "STRING"
          end
          
          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id);Fi[	@x	iGI"⁄    def function(arglist)
      transfers.any? { |arglist| var.active? }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      from.responds_to?(:read) ? ("STRING") : (from);Fi[	@‰iI"¿        def function(arglist)
          :stand_alone
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@‰iI"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@‰iI"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@‰iI"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@˜
i4I"    def function(arglist)
      @var ||= sass_files.map { |arglist| corresponding_css_file(var) }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      css_files.map { |arglist| File.dirname(var) }.uniq.sort.sort_by do |arglist|;Fi[	@˙
iI"¨      def function(arglist)
        :stand_alone
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@˙
iI"∆      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        File.join(top_level.css_dir, "STRING");Fi[	@i+I"«            end
          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        # The on-the-disk filename of the sprite
        def function(arglist);Fi[	@iMI"Â        var = @var[(var + 1)]
        var.call(var) if var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        if Cucumber::WINDOWS and (var and ENV["STRING"].!) then;Fi[	@iXI"´        end
        @var = var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var = name.split(/\n/)[0];Fi[	@ i£I"ÿ        def function(arglist)
          @var.backtrace_line(name, line)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          @var.language;Fi[	@PirI"ó          var
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var = @var;Fi[	@#iCI"®        def function(arglist)
          @var[0].line
        end
        
        def function(arglist)
          "STRING"
        end
        
        private
        ;Fi[	@i	I"ë  PROC_PATTERN = /[\d\w]+@(.+):(\d+).*>/
  
  PWD = Dir.pwd
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING";Fi[	@iI"¨  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  if Proc.new { |arglist| }.to_s.=~(PROC_PATTERN) then
    def function(arglist);Fi[	@)iΩI"ÿ      def function(arglist)
        File.read((File.dirname("STRING") + "STRING"))
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        (@var << "STRING");Fi[	@ÑiI"≠      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = [];Fi[	@!iI"ä  def function(arglist)
    raw_bookmarklet
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    bookmarklet;Fi[	@$i	I"ë  def function(arglist)
    Jobs::Mail::AlsoCommented
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING";Fi[	@$iI"°  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Post.where(:id => (self.target_id)).first;Fi[	@)i	I"ë  def function(arglist)
    Jobs::Mail::CommentOnPost
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING";Fi[	@)iI"°  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Post.where(:id => (self.target_id)).first;Fi[	@.i	I"â  def function(arglist)
    Jobs::Mail::Liked
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING";Fi[	@.iI"â  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    var = self.target;Fi[	@3i	I"ç  def function(arglist)
    Jobs::Mail::Mentioned
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING";Fi[	@3iI"ô  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Mention.find(self.target_id).post;Fi[	@8i	I"“  def function(arglist)
    Jobs::Mail::PrivateMessage
  end
  
  def function(arglist)
    "STRING"
  end
  
  def self.make_notification(arglist)
    var = var.new(:target => (var), :recipient_id => (var.id));Fi[	@>i	I"å  def function(arglist)
    Jobs::Mail::Reshared
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING";Fi[	@>iI"É  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    self.target;Fi[	@Ci	I"†  def function(arglist)
    Jobs::Mail::StartedSharing
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    super(var.sender, var);Fi[	@Ái√I"z    end
    var
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    if self.owner then;Fi[	@Hi=I"~  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    [];Fi[	@MiI"˘  OVERRIDE_FIELDS_ON_FB_UPDATE = [:contact_id, :person_id, :request_id, :invitation_id, :photo_url, :name, :username]
  
  MAX_CHARACTERS = 420
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Rails.logger.debug("STRING");Fi[	I"2data//diaspora_proj/models/services/tumblr.rb;TiI"Ø  include(ActionView::Helpers::TagHelper)
  
  MAX_CHARACTERS = 1000
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    AppConfig.services.tumblr.key;Fi[	@i
I"ü  MAX_CHARACTERS = 140
  
  SHORTENED_URL_LENGTH = 21
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Rails.logger.debug("STRING");Fi[	I"5data//diaspora_proj/uploaders/processed_image.rb;TiI"’class ProcessedImage < CarrierWave::Uploader::Base
  include(CarrierWave::MiniMagick)
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    ["STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	I"7data//diaspora_proj/uploaders/unprocessed_image.rb;TiI"Õclass UnprocessedImage < CarrierWave::Uploader::Base
  include(CarrierWave::MiniMagick)
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    ["STRING", "STRING", "STRING", "STRING"];Fi[	@
i[I"û  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    `uname -m`.chomp;Fi[	@RiJI"î    @var ||= CompilerFailures.new
    (@var << var)
  end
  
  def function(arglist)
    "STRING"
  end
  
  class << self
    def function(arglist);Ti[	@i&I"õ      end
    end)
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    ([FORGE_BUNDLE_ID, APPLE_BUNDLE_ID].find do |arglist|;Fi[	@WiWI"Ë      var = (("STRING" + @var["STRING"].gsub("STRING", "STRING")) + "STRING")
      var.=~(Regexp.new(var, Regexp::IGNORECASE))
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      setup;Fi[	@ZiI"Ë      var = (("STRING" + @var["STRING"].gsub("STRING", "STRING")) + "STRING")
      var.=~(Regexp.new(var, Regexp::IGNORECASE))
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      setup;Fi[	@]i1I"’      var = (var + var["STRING"]) if var["STRING"]
      var
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      var = var.sub(/<pre>/, (("STRING" + var) + "STRING"));Fi[	@`i#I"ø      def self.build(arglist)
        var ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@`i'I"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@`i+I"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@`i/I"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@ßixI"          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      { "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING" }.each do |arglist|
        class_eval("STRING");Fi[	@7iﬁI"ö      end
      
      private
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        [:name, :children];Fi[	@:ijI"ª        end
        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        [:name, :namespace, :attribute_nodes, :children];Fi[	@ri|I"      raise(ArgumentError, "STRING") unless var.empty?
      yield(options) if block_given?
    end
    
    def function(arglist)
      "STRING"
    end
    
    # Direct access to the OmniAuth logger, automatically prefixed
    # with this strategy's name.;Fi[	I" data//omni_proj/omniauth.rb;TidI"é  
  module Utils
    module_function
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      var = var.dup;Fi[	@uiI"o  end
  
  protected
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING";Fi[	@uiI"è  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    migration_name.camelize;Fi[	@QiI"     def function(arglist)
      @var.read(var, var)
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      @var = var.gsub(OS_RESTRICTED_CHARACTERS, "STRING");Fi[	@zi
I"ò    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING";Fi[	@ziI"ç    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      0;Fi[	@‡iI"Ú          @var = @var.class unless Class.===(@var)
          responds? and (has_column? and included?)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@‡i!I"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@‡i%I"¶        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        ;Fi[	@„i3I"¥            (var << rejected_types_and_failures)
          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        ;Fi[	@„iII"π            end
          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          @var.send("STRING", var);Fi[	@ÊiI"ı          @var = var.new if (var.class == Class)
          error_when_not_valid? and no_error_when_valid?
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@Êi I"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@Êi$I"¶        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        ;Fi[	@Èi/I"          @var = @var.new if (@var.class == Class)
          lower_than_low? and (higher_than_low? and (lower_than_high? and higher_than_high?))
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@Èi3I"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@Èi7I"¶        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        ;Fi[	@ji5I"|    end
    
    private
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING";Fi[	@ji9I"î    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING";Fi[	@ji=I"ß    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      Digest::SHA1.hexdigest(var);Fi[	@èi<I"√      def function(arglist)
        @var ||= assets("STRING", "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@èi@I"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@èiDI"ê      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@OiI"œ          var = "STRING"
          javascript_tag("STRING")
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          unless @var then;Fi[	@°iªI"©          var = (var + 1))
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        return "STRING";Fi[	@§iËI"Î    def function(arglist)
      (to_s == var.to_s)
    end
    
    def function(arglist)
      "STRING"
    end
    
    # The string representation is the same as the id for this worker
    # instance. Can be used with `Worker.find`.;Fi[	@ßiπI"ë  def function(arglist)
    register_hook(:after_perform, var)
  end
  
  def function(arglist)
    "STRING"
  end
  
  attr_accessor(:inline)
  ;Fi[	@ûiI"ü        @var = var
        @var.!.!
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@ûiI"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@ûi"I"ı      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      [:==, :<, :<=, :>=, :>, :===].each do |arglist|
        define_method(var) { |arglist| BeComparedTo.new(var, var) };Fi[	@ûiLI"∂        @var = var
        @var.__send__(@var, @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var = "STRING";Fi[	@ûioI"ú          raise(var)
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@ûisI"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@ûiwI"ê      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@ûiöI"®        @var = var
        @var.equal?(@var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@ûiûI"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@Ö
i2I"Ø      def function(arglist)
        (@var - @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var;Fi[	@£iI"À      def function(arglist)
        var.__send__(predicate(@var), *@var, &@var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@£iI"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@£iI"ê      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@¶i(I"Õ        return (@var <= @var) if (@var == :at_most)
        return (@var == @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@¶i,I"∫      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        if (@var == :exactly) then;Fi[	@¶i<I"≠          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        (@var.respond_to?(var) or super);Fi[	@©iI"π        var = (var + "STRING") unless @var.empty?
        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@©i I"ê      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@¨i<I"¬      def function(arglist)
        @var ? (@var.message) : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@¨i@I"ê      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@⁄iI"¢        end
        return @var.empty?
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@⁄iI"®      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@⁄iI"™      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var;Fi[	@·iI"•        @var = var
        @var.call(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING";Fi[	@Øi-I"¶      def function(arglist)
        @var ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      ;Fi[	@∑i I"Ê      def function(arglist)
        (var == __mock_proxy)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        inspect.gsub("STRING", "STRING").gsub("STRING", "STRING");Fi[	@ÇiπI"ó          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var.clear;Fi[	@øiæI"›      def function(arglist)
        (var[:type] or var[:behaviour_type])
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var, var = args_and_options(*var);Fi[	@§iÄI"æ          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@§iÑI"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@§iàI"º        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING";Fi[	@ ilI"¿      var = var.split($/, -1)[(@var[:cut]..-1)].join($/)
      var.gsub!(/\s+$/, $/)
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING";Fi[	@ ipI"î    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING";Fi[@(@)I" ;FI"private;FI" ;Fi|[|[	@%i4I"Ì      var.each do |arglist|
        define_callbacks(var, var)
        var.each { |arglist| send("STRING", self, var) }
      end
    end
    
    private
    
    def function(arglist)
      var.class_eval("STRING", "STRING", (126 + 1));Fi[	@1i`I"Õ            add_extra_behavior
            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing;Fi[	@4iI"E      def function(arglist)
        unless (delimiter.respond_to?(:include?) or (delimiter.respond_to?(:call) or delimiter.respond_to?(:to_sym))) then
          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist)
        var = if delimiter.respond_to?(:call) then;Fi[	@:i1I"          var = options[MESSAGES[var]]
          var[:message] ||= var if var
          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist)
        (if options[:tokenizer] and var.kind_of?(String) then;Fi[	@Bi I"¸          var = connection.table_alias_for(var)
          aliases[var] += 1
          (aliases[var] > 1) ? ("STRING") : (var)
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins);Fi[	I"Ndata//activerecord_proj/active_record/associations/has_one_association.rb;Ti9I"          else
            # do nothing
          end
        end
      end
      
      private
      
      # The reason that the save param for replace is false, if for create (not just build),
      # is because the setting of the foreign keys is actually handled by the scoping when;Fi[	@oiI"+          var.each do |arglist|
            var.map! { |arglist| var.send(source_reflection.name) }.flatten!
            var.compact!
          end
        end
        
        private
        
        def function(arglist)
          Preloader.new(owners, through_reflection.name, through_scope).run;Fi[	@eirI"          read_time
        else
          (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist)
        if object.class.send(:create_time_zone_conversion_attribute?, name, column) then;Fi[	I"Edata//activerecord_proj/active_record/attribute_methods/dirty.rb;Ti3I"Ÿ        super.tap do |arglist|
          @var.clear
          @var.clear
        end
      end
      
      private
      
      # Wrap write_attribute to remember original attribute value.
      def function(arglist);Fi[	I"Edata//activerecord_proj/active_record/attribute_methods/query.rb;Ti!I"           else
            var.number? ? (var.zero?.!) : (var.blank?.!)
          end)
        end
      end
      
      private
      
      # Handle *? for method_missing.
      def function(arglist);Fi[	@mi+I"a            generated_attribute_methods.module_eval(var, "STRING", var)
          else
            super
          end
        end
        
        private
        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type));Fi[	@mi2I"9        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist)
        var.change(:usec => 0) if var;Fi[	@riEI"        def function(arglist)
          synchronize do |arglist|
            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist)
          @var.synchronize(&var);Fi[	@ri1I"E          connections.dup.each do |arglist|
            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      
      # Acquire a connection by one of 1) immediately removing one
      # from the queue of available connections, 2) creating a new;Fi[	@ri¿I"∆            break unless (var <= Base))
          end
          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist)
        @var[Process.pid];Fi[	@~i&I"            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) };Fi[	@ÑiëI"∞          exec_query("STRING")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {};Fi[	@åiuI"Á            else
              var
            end
          end
        end
        
        private
        
        HstorePair = (var = /"[^"\\]*(?:\\.[^"\\]*)*"/
        var = /(?:\\.|[^\s,])[^\s=,\\]*(?:\\.[^\s=,\\]*|=[^,>])*/;Fi[	I"2data//activerecord_proj/active_record/core.rb;TiVI"ô          self
        else
          superclass.arel_engine
        end
      end
      
      private
      
      #:nodoc:
      def function(arglist);Fi[	@	itI"            end
          end
          raise(NameError, "STRING")
        end
      end
      
      private
      
      # Called by +instantiate+ to decide which class to use for a new
      # record instance. For single-table inheritance, we check the record;Fi[	@	i†I"          raise(ActiveRecord::SubclassNotFound.new("STRING"))
        end
        var
      end
    end
    
    private
    
    # Sets the attribute used for single table inheritance to this class name if this is not the
    # ActiveRecord::Base descendant.;Fi[	I"9data//activerecord_proj/active_record/persistence.rb;TijI"	        @var.except!(*var.keys)
        var = self.class.primary_key
        (self.class.unscoped.where(var => (self[var])).update_all(var) == 1)
      end
    end
    
    private
    
    # A hook to be overridden by association modules.
    def function(arglist);Fi[	@õi&I"Œ      rescue Exception => var
        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    
    def function(arglist)
      ActiveRecord::Base.connection_id = var;Fi[	@•iMI"É        else
          raise("STRING")
        end
      end
    end
    
    private
    
    def function(arglist)
      "STRING";Fi[	@‘i,I"´      if var.!=(var[var]) then
        send(:"#{var}STRING")
        var[var] = var
      end
    end
    
    private
    
    def function(arglist)
      var = send(var);Fi[	I"(data//backup_proj/backup/archive.rb;TiUI"        Logger.message("STRING")
      else
        raise(Errors::Archive::PipelineError, ("STRING" + var.error_messages))
      end
    end
    
    private
    
    ##
    # Returns a "tar-ready" string of all the specified paths combined;Fi[	@⁄i>I"€        #
        def function(arglist)
          deprecations[var] = { :version => (nil), :message => (nil), :action => (nil) }.merge(var)
        end
      end
      
      private
      
      # ClassMethods
      ##;Fi[	I"1data//backup_proj/backup/database/mongodb.rb;TiKI"π        ensure
          (unlock_database if @var
          package! unless var)
        end
      end
      
      private
      
      ##
      # Builds and runs the mongodump command;Fi[	I"/data//backup_proj/backup/database/mysql.rb;TiGI"˝          Logger.message("STRING")
        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages))
        end
      end
      
      private
      
      ##
      # Builds the full mysqldump string based on all attributes;Fi[	I".data//backup_proj/backup/database/riak.rb;Ti/I"ƒ            run("STRING")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes;Fi[	I".data//backup_proj/backup/encryptor/gpg.rb;TidI"À          yield("STRING", "STRING"))
        ensure
          cleanup
        end
      end
      
      private
      
      ##
      # Remove any temporary directories and reset all instance variables.;Fi[	I".data//backup_proj/backup/notifier/base.rb;Ti?I"¥        if var then
          log!
          notify!(var)
        end
      end
      
      private
      
      ##
      # Return the notifier name, with Backup namespace removed;Fi[	@ˇiRI"8              Parallel.each(all_file_names, { :in_processes => (var) }, &var)
            else
              raise(Errors::Syncer::Cloud::ConfigurationError, "STRING")
            end
          end
          
          private
          
          ##
          # Gathers all the relative paths to the local files;Fi[	@iI"ƒ            end)
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return expanded @path, since this path is local;Fi[	@i5I"Ÿ            run(("STRING" + "STRING")))
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return @path with any preceeding "~/" removed;Fi[	@·iI"À          # do nothing
        end
        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist)
      @var.! and (@var.! and (@var.! and (@var.! and @var.!)));Fi[	@ıi~I"ñ        @var.uniq!
      else
        raise(ArgumentError, "STRING")
      end
    end
    
    private
    
    def function(arglist)
      @var[var];Fi[	@¯i!I"Ã        return @var)
      ensure
        Bundler.settings[:frozen] = "STRING" if var
      end
    end
    
    private
    
    def function(arglist)
      @var.map { |arglist| "STRING" }.join("STRING");Fi[	@˚iîI"±          Bundler.ui.warn("STRING"))
        end
        Bundler.ui.warn("STRING")
      end
    end
    
    private
    
    def function(arglist)
      var = Bundler.bin_path;Fi[	@)i≥I"Ò        var.unshift("STRING")
        Bundler::WINDOWS ? (var.unshift("STRING")) : (var.unshift("STRING"))
        ENV["STRING"] = var.join("STRING")
      end
    end
    
    private
    
    def function(arglist)
      var = Dir["STRING"];Fi[	@,i=I"˝            git("STRING")
            git("STRING")
            git("STRING") if var
          end
        end
        
        private
        
        # TODO: Do not rely on /dev/null.
        # Given that open3 is not cross platform until Ruby 1.9.3,;Fi[	@ ixI"ﬂ          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact;Fi[	@âiºI">            var.hosts.each { |arglist| failed!(var) }
          end
          teardown_connections_to(var) if var
        end
      end
      
      private
      
      # We establish the connection by creating a thread in a new method--this
      # prevents problems with the thread's scope seeing the wrong 'server';Fi[	@åiõI"        ensure
          (self.class.instance = var
          self.class.current_feature = var)
        end
      end
      
      private
      
      # Load a recipe from the named file. If +name+ is given, the file will
      # be reported using that name.;Fi[	@ßiMI"À            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option
        def function(arglist);Fi[	@™iJI"œ            return var[/hash='(.*?)'/, 1]
          else
            return var
          end
        end
        
        private
        
        def function(arglist)
          case variable(:scm_verbose);Fi[	@ØiãI"ı            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the
        # command-line switch for "quiet" ("-q").;Fi[	@≤iKI"¿            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands
        def function(arglist);Fi[	@∏iMI"ˇ            raise(Capistrano::Error, "STRING")
          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.
        def function(arglist);Fi[	@ΩiVI"            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line
        # switches for that. Note that we don't need to return the password;Fi[	@“iI">          super.check do |arglist|
            var.remote.command("STRING") unless copy_exclude.empty?
            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist)
          File.join(shared_path, (configuration[:repository_cache] or "STRING"));Fi[	@7iFI"          raise(Compass::FilesystemConflict.new("STRING"))
        else
          raise(Compass::Error.new("STRING")) if File.directory?(project_directory).!
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then;Fi[	I"Adata//compass_proj/compass/sass_extensions/functions/urls.rb;Ti†I"û      end
      var = "STRING" if var
      clean_url(var)
    end
  end
  
  private
  
  # Emits a path, taking off any leading "./"
  def function(arglist);Fi[	@iåI"*          if [hover?, target?, active?].any? then
            PARENT.match(name)
            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size;Fi[	@`i1I"Ä      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity;Fi[	@ciPI"ç          end
          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING;Fi[	I",data//cucumber_prok/cucumber/runtime.rb;TiéI"ÿ        File.open(File.join(@var.dotcucumber, "STRING"), "STRING") do |arglist|
          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    
    #:nodoc
    def function(arglist);Fi[	I"-data//devise_proj/devise/param_filter.rb;Ti I"8      return var unless var.is_a?(Hash)
      var.each do |arglist|
        var[var] = var.to_s if param_requires_string_conversion?(var)
      end
    end
    
    private
    
    # Determine which values should be transformed to string or passed as-is to the query builder underneath
    def function(arglist);Fi[	I"Adata//devise_proj/devise/strategies/token_authenticatable.rb;TiI"        if validate(var) then
          var.after_token_authentication
          success!(var)
        end
      end
      
      private
      
      # Token Authenticatable can be authenticated with params in any controller and any verb.
      def function(arglist);Fi[	@™i!I"     respond_with do |arglist|
      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist)
    if var = current_user.contact_for(var) then;Fi[	@≠i@I"Â        render(:json => (CommentPresenter.as_collection(@var)), :status => 200)
      end
      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist)
    if user_signed_in? then;Fi[	@∂iHI"‘    unless AppConfig.settings.invitations.open? then
      flash[:error] = I18n.t("STRING")
      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist)
    User.email_regexp.match(var).present?;Fi[	@wi+I"˛    respond_to do |arglist|
      var.all { |arglist| render(:layout => (false)) }
      var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist)
    @var ||= if params[:post_id] then;Fi[	@ªi•I"√        flash[:error] = I18n.t("STRING", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id };Fi[	@æi{I"∑      end
    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist)
    if request.params[:qqfile].is_a?(String).! then;Fi[	@¡i9I"»          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("STRING"))) then;Fi[	@ÕiBI".        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "STRING")) then;Fi[	@”i,I"›          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name]);Fi[	@÷iI"”  def function(arglist)
    include_analytics("STRING") do |arglist|
      javascript_tag { |arglist| "STRING".html_safe }
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var);Fi[	@·iPI"Â      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist)
    (errors[:base] << "STRING") if person_id and person.closed_account?;Fi[	@˙	i?I"¨      self.target.post
    else
      self.target
    end
  end
  
  private
  
  def self.concatenate_or_create(arglist)
    return nil if suppress_notification?(var, var);Fi[	@Ái7I"    if self.url then
      self.url = ("STRING" + self.url) unless self.url.match(/https?:\/\//)
      self.url = (self.url + "STRING") if self.url[-1, 1].!=("STRING")
    end
  end
  
  private
  
  def function(arglist)
    Webfinger.new(self.diaspora_handle).fetch;Fi[	@ÍiªI"’    if @var then
      errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["STRING", "STRING", "STRING"]);Fi[	@ÛiI"    else
      var = var.map { |arglist| [var, var.id, var.class.base_class.to_s] }
      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist)
    (errors[:base] << "STRING") if shareable.public?;Fi[	@¸i„I"¿      self.class.buffer_option_keys.inject({}) do |arglist|
        var[var] = send(var)
        var
      end
    end
    
    private
    
    def function(arglist)
      self.class.defaults;Fi[	I"#data//haml_proj/haml/parser.rb;Ti{I"Ì      rescue Haml::Error => var
        var.backtrace.unshift("STRING")
        raise
      end
    end
    
    private
    
    class Line < Struct.new(:text, :unstripped, :full, :index, :compiler, :eod)
      alias_method(:eod?, :eod);Fi[	@ìiI"±        puts("STRING") if ARGV.verbose?
        var.rmdir
      end
    end
  end
  
  private
  
  # Set permissions for executables and non-executables
  def function(arglist);Fi[	@iwI"æ      else
        raise("STRING")
      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "STRING") or ((var[(0..7)] == "STRING") or (var[(0..5)] == "STRING")));Fi[	I"$data//homebrew_proj/cmd/link.rb;Ti!I"Ò        end
      end
      print("STRING") { |arglist| puts("STRING") }
    end
  end
  
  private
  
  # Allows us to ensure a puts happens before the block exits so that if say,
  # an exception is thrown, its output starts on a new line.;Fi[	@iI"·          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|;Fi[	@i+I"q    else
      puts("STRING")
      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin;Fi[	@inI"∞      safe_system("STRING", "STRING", @var)
    else
      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist)
    var = Dir["STRING"];Fi[	@iwI"≥        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "STRING").split(/:/);Fi[	@iI"Æ      var
    else
      var.is_a?(Symbol) ? (detect_from_symbol(var)) : (detect_from_url(var))
    end
  end
  
  private
  
  def self.detect_from_url(arglist)
    case var;Fi[	@i®I"∫      yield)
    ensure
      replace(var)
    end
  end
  
  private
  
  def function(arglist)
    @var ||= named.map { |arglist| var.include?("STRING") ? (var) : (var.downcase) }.uniq;Fi[	@¥iI"ù          end
        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/
  ;Fi[	@&i£I"°      @var
    else
      @var.is_a?(Symbol) ? (detect_from_symbol) : (raise("STRING"))
    end
  end
  
  private
  
  def function(arglist)
    raise("STRING");Fi[	@)i0I"ï        else
          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["STRING"];Fi[	I"1data//jekyll_proj/jekyll/migrators/tumblr.rb;Ti'I"        File.open("STRING", "STRING") do |arglist|
          var.puts(((var[:header].to_yaml + "STRING") + var[:content]))
        end
      end
    end
    
    private
    
    def self.truncate_post_name(arglist)
      var = var.match(/^(.+)\.(.+)$/).captures;Fi[	I"-data//mongoid_proj/lib/mongoid/atomic.rb;TimI"º        yield(self) if block_given?)
      ensure
        self.updates_requested = false
      end
    end
    
    private
    
    # Get the atomic paths utility for this document.
    #;Fi[	@˚i!I"«          end
          yield(self) if block_given?
          process_pending
        end
      end
      
      private
      
      # Get the current mass assignment options for this model.
      #;Fi[	@	iI"            validate_session_database(var, var)
            validate_session_hosts(var, var)
            validate_session_uri(var, var)
          end
        end
        
        private
        
        # Validate that the session config has database.
        #;Fi[	@iVI"Â            super()
          else
            (count > 0) ? (super(0) { |arglist| var.send(var) }) : (0)
          end
        end
        
        private
        
        # Aggregate by the provided field and method.
        #;Fi[	@ni7I"Ÿ          else
            Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      
      # Extract the attribute from the key, being smarter about dot notation.
      #;Fi[	@ÄiI"‰            document[field] = (var + value)
            execute("STRING")
            document[field]
          end
        end
        
        private
        
        # In case we need to cast going to the database.
        #;Fi[	@miSI"ˇ            (target.clear and _unscoped.clear)
            var = execute_batch_insert(var, "STRING")
            add_atomic_sets(var)
          end
        end
        
        private
        
        # Add the atomic sets to the base document.
        #;Fi[	@ÄikI"˙          unless var.forced_nil_inverse? then
            synced_save(var)
            synced_destroy(var)
          end
        end
        
        private
        
        # Set up the sync of inverse keys that needs to happen on a save.
        #;Fi[	@âi I"Œ          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      private
      
      # Warns or raises exception if overriding another scope or method.
      #;Fi[	@åiI"        def function(arglist)
          if (var.is_a?(::Hash).! or valid_keys?(var).!) then
            raise(Errors::InvalidStorageOptions.new(var, var))
          end
        end
        
        private
        
        # Determine if all keys in the options hash are valid.
        #;Fi[	I";data//mongoid_proj/lib/mongoid/validations/presence.rb;Ti"I"Á          else
            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      
      # Returns true if the relation is blank or the foreign key is blank.
      #;Fi[	I"=data//mongoid_proj/lib/mongoid/validations/uniqueness.rb;Ti-I"¶          else
            validate_root(var, var, var)
          end
        end
      end
      
      private
      
      # Add the error to the document.
      #;Fi[	@∏irI"™            end
          end
          insert(var, &var)
        end
      end
      
      private
      
      ###
      # Insert +node+ as a child of the current Node;Fi[	I":data//nokogiri_proj/nokogiri/xml/document_fragment.rb;TiTI"Ô        # Create a Nokogiri::XML::DocumentFragment from +tags+
        def function(arglist)
          self.new(XML::Document.new, var)
        end
      end
      
      private
      
      # fix for issue 770
      def function(arglist);Fi[	@:i+I"K        document.canonicalize(var, var, var) do |arglist|
          var = var.is_a?(XML::Node) ? (var) : (var)
          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist)
        var = (var == :next) ? (:add_next_sibling_node) : (:add_previous_sibling_node);Fi[	@Hi{I"ù        end
      else
        scale_to(var)
      end
    end
    
    private
    
    def function(arglist)
      if (var.horizontal? or var.square?) then;Fi[	@NiI"    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist)
      if var = (@var and @var.match(FORMAT)) then;Fi[	@`i|I"‘        rescue ::Fog::Errors::Error => var
          warn("STRING")
          false
        end
      end
      
      private
      
      def function(arglist)
        if @var[:fog_host].respond_to?(:call) then;Fi[	@ÏiÌI"Ø        rescue AWS::Errors::Base => var
          warn("STRING")
          false
        end
      end
      
      private
      
      def function(arglist)
        case var;Fi[	@ei"I"	      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "STRING")
        end
      end
      
      private
      
      def function(arglist)
        if var = var[:in] then;Fi[	@mijI"’      complete_open_id_authentication(&var)
    else
      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist)
    (params[:openid_identifier] or params[:openid_url]);Fi[	@piLI"Ì      assert_nonce(var, false, var, "STRING")
      var = OpenID::Nonce.mk_nonce(3600)
      assert_nonce(var, false, var, "STRING")
    end
  end
  
  private
  
  def function(arglist)
    var = OpenID::CryptUtil.random_string(20, nil);Fi[	@siÍI"æ    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@viÛI"æ    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@yiŸI"æ    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@ÅiI"ó      return @var
    else
      open(var, "STRING") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@7iKI"+          rescue => var
            logger.error("STRING")
            raise(CommandFailed.new(var.message))
          end
        end
        
        private
        
        # AbstractAdapter::target is implicitly made to quote paths.
        # Here we do not shell-out, so we do not want quotes.;Fi[	@èiSI"€        else
          Dir.glob("STRING").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    
    def self.scan_themes(arglist)
      var = Dir.glob("STRING").select do |arglist|;Fi[	@íi&I"æ            # do nothing
          end
          var.attributes["STRING"] = "STRING"
        end
      end
      
      private
      
      def function(arglist)
        if (var < var) then;Fi[	I".data//rspec_proj/spec/matchers/matcher.rb;TiUI"≈            var.call(*var)
            self
          end
        end
      end
      
      private
      
      # :nodoc:
      # Our home-grown instance_exec in ruby 1.8.6 results in any methods;Fi[	@™iI"Ê            true
          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing;Fi[	@ƒihI"Õ        
        def function(arglist)
          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist)
        @var.formatters;Fi[	@«i%I"G        end
        var["STRING"] = var
        [500, { "STRING" => (var), "STRING" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist)
      (Request.new(var).preferred_type("STRING", "STRING") == "STRING").! and [/curl/].index { |arglist| var.=~(var["STRING"]) };Fi[	@˝iI"              var[extract_requirement(var[0])] = extract_requirement(var[1])
            end
            owner.transition(var)
          end
        end
        
        private
        
        # Extracts the statement requirement from the given node
        def function(arglist);Fi[	I"-data//twitter_proj/twitter/api/tweets.rb;Ti˙I"        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::OEmbed, :get, "STRING", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String];Fi[I"def function(arglist);FI""STRING";FI"end;FI" ;FI"def function(arglist);Fiq[q[	@MiI"          (var.class == self.class) and (var.active_record == active_record)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          Arel::Table.new(table_name, arel_engine)
        end;Fi[	@^iI"‡          reflection.active_record_primary_key
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          join_table[reflection.foreign_key]
        end;Fi[	@¿
i/I"©        execute("STRING", "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@¿
i3I"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@«
ikI"§        quote_column_name(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@«
ioI"˘        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        if var.acts_like?(:time) then
          var = (ActiveRecord::Base.default_timezone == :utc) ? (:getutc) : (:getlocal);Fi[	@ÅiwI"∫        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var.map { |arglist| remove_column_sql(var, var) }
      end;Fi[	@/	inI"‡        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        configuration_without_database.merge("STRING" => "STRING", "STRING" => (root_password))
      end;Fi[	@ıi"I"ƒ      var.specs.each { |arglist| @var[var] = var.dup }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      each { |arglist| return false }
      true;Fi[	@7i3I"¶        (var << "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        self.class.hash
      end;Fi[	@O	iI"       end
      
      #:nodoc:
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var = (ENV["STRING"] or (ENV["STRING"] or "STRING"))
        Tempfile.open(File.basename(var), File.dirname(var)) do |arglist|;Fi[	@úi}I"            (@var == "STRING")
          end
          
          def function(arglist)
            "STRING"
          end
          
          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end;Fi[	@x	iHI"»      transfers.any? { |arglist| var.active? }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      from.responds_to?(:read) ? ("STRING") : (from)
    end;Fi[	@‰iI"Æ          :stand_alone
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@‰iI"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@‰iI"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@‰iI"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@˜
i5I"
      @var ||= sass_files.map { |arglist| corresponding_css_file(var) }
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      css_files.map { |arglist| File.dirname(var) }.uniq.sort.sort_by do |arglist|
        var.length;Fi[	@˙
iI"≤module Compass
  module Configuration
    module Defaults
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        :stand_alone
      end;Fi[	@˙
iI"ö        :stand_alone
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@˙
iI"¥        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        File.join(top_level.css_dir, "STRING")
      end;Fi[	@iNI"        var.call(var) if var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        if Cucumber::WINDOWS and (var and ENV["STRING"].!) then
          var = var.gsub(/\//, "STRING");Fi[	@iYI"Í        @var = var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var = name.split(/\n/)[0]
        var =~ /#{language.keywords("STRING")}STRING/ ? ($1.strip) : (var);Fi[	@ i§I"∆          @var.backtrace_line(name, line)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          @var.language
        end;Fi[	@PisI"ß        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var = @var
        var.each do |arglist|;Fi[	@i
I"s  
  PWD = Dir.pwd
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@)iæI"∆        File.read((File.dirname("STRING") + "STRING"))
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        (@var << "STRING")
      end;Fi[	@ÑiI"ƒ        # do nothing
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = []
        add_to_python_path(File.dirname("STRING"));Fi[	I"7data//devise_proj/generators/devise/orm_helpers.rb;TiI"Ÿmodule Devise
  module Generators
    module OrmHelpers
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        File.exists?(File.join(destination_root, model_path))
      end;Fi[	@!iI"}    raw_bookmarklet
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    bookmarklet
  end;Fi[	@$i
I"    Jobs::Mail::AlsoCommented
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@$iI"è    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Post.where(:id => (self.target_id)).first
  end;Fi[	@)i
I"    Jobs::Mail::CommentOnPost
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@)iI"è    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Post.where(:id => (self.target_id)).first
  end;Fi[	@.i
I"|    Jobs::Mail::Liked
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@.iI"ô    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    var = self.target
    var = var.target if var.is_a?(Like);Fi[	@3i
I"{    Jobs::Mail::Mentioned
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@3iI"á    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Mention.find(self.target_id).post
  end;Fi[	@>i
I"    Jobs::Mail::Reshared
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@>iI"v    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    self.target
  end;Fi[	@Ci
I"é    Jobs::Mail::StartedSharing
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    super(var.sender, var)
  end;Fi[	@ÁiƒI"ç    var
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    if self.owner then
      var = self.owner.username;Fi[	@Hi>I"q    # do nothing
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    []
  end;Fi[	@MiI"ƒ  
  MAX_CHARACTERS = 420
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Rails.logger.debug("STRING")
    post_to_facebook("STRING", create_post_params(var).to_param);Fi[	@yiI"ã  
  MAX_CHARACTERS = 1000
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    AppConfig.services.tumblr.key
  end;Fi[	@iI"´  
  SHORTENED_URL_LENGTH = 21
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    Rails.logger.debug("STRING")
    var = public_message(var, var);Fi[	@~iI"€class ProcessedImage < CarrierWave::Uploader::Base
  include(CarrierWave::MiniMagick)
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    ["STRING", "STRING", "STRING", "STRING", "STRING"]
  end;Fi[	@ÅiI"”class UnprocessedImage < CarrierWave::Uploader::Base
  include(CarrierWave::MiniMagick)
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    ["STRING", "STRING", "STRING", "STRING"]
  end;Fi[	@çi@I"2    
    # Returns the string used as the return value of the precompiled method.
    # This method exists so it can be monkeypatched to return modified values.
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      var = var.keys if (Hash == var)
      (var.map do |arglist|;Fi[	@
i\I"å    describe_path(which("STRING"))
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    `uname -m`.chomp
  end;Fi[	@i'I"µ    end)
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    ([FORGE_BUNDLE_ID, APPLE_BUNDLE_ID].find do |arglist|
      MacOS.app_with_bundle_id(var);Fi[	@WiXI"¥      var.=~(Regexp.new(var, Regexp::IGNORECASE))
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      setup
      case @var["STRING"];Fi[	@ZiI"ÿ      var.=~(Regexp.new(var, Regexp::IGNORECASE))
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      setup
      return RedCloth.new(var).to_html if @var["STRING"].nil?;Fi[	I"%data//jekyll_proj/jekyll/post.rb;TiﬂI"˚    end
    
    # Returns the shorthand String identifier of this Post.
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      var = self.site.posts.index(self)
      if var and (var < (self.site.posts.length - 1)) then;Fi[	@]i2I"À      var
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      var = var.sub(/<pre>/, (("STRING" + var) + "STRING"))
      var = var.sub(/<\/pre>/, "STRING");Fi[	@`i$I"´        var ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@`i(I"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@`i,I"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@`i0I"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@7iﬂI"ö      
      private
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        [:name, :children]
      end;Fi[	@:ikI"π        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        [:name, :namespace, :attribute_nodes, :children]
      end;Fi[	@†ieI"¨  module Utils
    module_function
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      var = var.dup
      var.keys.each do |arglist|;Fi[	@uiI"o  
  protected
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@uiI"}    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    migration_name.camelize
  end;Fi[	@QiI"∏      @var.read(var, var)
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      @var = var.gsub(OS_RESTRICTED_CHARACTERS, "STRING")
    end;Fi[	@ziI"Ü      # do nothing
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end;Fi[	@ziI"{      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      0
    end;Fi[	@‡iI"À          responds? and (has_column? and included?)
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@‡i"I"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@„iJI"ø          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          @var.send("STRING", var)
          @var.valid?;Fi[	@ÊiI"–          error_when_not_valid? and no_error_when_valid?
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@Êi!I"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@Èi0I"ı          lower_than_low? and (higher_than_low? and (lower_than_high? and higher_than_high?))
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@Èi4I"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@ji6I"|    
    private
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end;Fi[	@ji:I"Ç      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end;Fi[	@ji>I"ï      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      Digest::SHA1.hexdigest(var)
    end;Fi[	@èi=I"±        @var ||= assets("STRING", "STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@èiAI"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@OiI"È          javascript_tag("STRING")
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          unless @var then
            content_for(:header_tags) do |arglist|;Fi[	@°iºI"ò        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        return "STRING"
      end;Fi[	@ûiI"ñ        @var.!.!
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@ûiI"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@ûiMI"Ú        @var.__send__(@var, @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var = "STRING"
        raise((var << ([:===, :==].include?(@var) ? ("STRING") : ("STRING"))));Fi[	@ûipI"ë        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@ûitI"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@ûiõI"ü        @var.equal?(@var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@ûiüI"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@Ö
i3I"†        (@var - @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@£iI"π        var.__send__(predicate(@var), *@var, &@var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@£iI"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@¶i)I"£        return (@var == @var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@¶i-I"∏        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        if (@var == :exactly) then
          return "STRING";Fi[	@¶i=I"©        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        (@var.respond_to?(var) or super)
      end;Fi[	@©iI"ë        var
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@¨i=I"∞        @var ? (@var.message) : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@⁄iI"†        return @var.empty?
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@⁄iI"ñ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@⁄iI"õ        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@·iI"ú        @var.call(var)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@∑i!I"‘        (var == __mock_proxy)
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        inspect.gsub("STRING", "STRING").gsub("STRING", "STRING")
      end;Fi[	@Çi∫I"ì        end
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@øiøI"Ë        (var[:type] or var[:behaviour_type])
      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        var, var = args_and_options(*var)
        return [scope_from(*var), var];Fi[	@§iÅI"¨          @var.flush
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@§iÖI"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@§iâI"™          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end;Fi[	@ imI"è      var.gsub!(/\s+$/, $/)
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end;Fi[	@ iqI"Ç      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end;Fi[@(@)@*@+I" ;Fi`[`[	@/i>I"8        if respond_to?(:attributes_protected_by_default) then
          def self.attributes_protected_by_default(arglist)
            (super + ["STRING"])
          end
        end
      end
    end
    
    module InstanceMethodsOnActivation
      # Returns +self+ if the password is correct, otherwise +false+.;Fi[	@1iòI"F          if var = options.delete(:procs) then
            Array(var).each do |arglist|
              (var.arity == 1) ? (var.call(options)) : (var.call(options, @var))
            end
          end
        end
      end
      
      # Returns XML representing the model. Configuration can be
      # passed through +options+.;Fi[	@7i2I"H        else
          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var[:multiline].!=(true))) then
            raise(ArgumentError, "STRING")
          end
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is of the correct;Fi[	@@i∆I"·              (var.size + count_records)
            else
              count_records
            end
          end
        end
      end
      
      # Returns the size of the collection calling +size+ on the target.
      #;Fi[	@@ifI"?            add_to_target(build_record(var)) do |arglist|
              yield(var) if block_given?
              insert_record(var, true, var)
            end
          end
        end
      end
      
      # Do the relevant stuff to insert the given record into the association collection.
      def function(arglist);Fi[	@riÜI"ß            while true do
              sleep(var)
              var.reap
            end
          end
        end
      end
      
      include(MonitorMixin)
      ;Fi[	@~iI"È            if (var < var) then
              execute("STRING")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist)
        if var = native_database_types[var.to_sym] then;Fi[	@åi_I"ø                (var..var)
              else
                var
              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then;Fi[	@ëiQI"$                var.gsub!(/[^-\d,]/, "STRING").sub!(/,/, "STRING")
              else
                # do nothing
              end
            end
          end
        end
        
        # Queries the database and returns the results in an Array-like object
        def function(arglist);Fi[	@Ei=I"ı              "STRING"
            else
              "STRING"
            end
          end
        end
      end
      
      # Overwrite the default class equality method to provide support for association proxies.
      def function(arglist);Fi[	@îiDI"            var.instance_variable_set("STRING", var.find)
          rescue FixtureClassNotFound
            nil
          end
        end
      end
    end
    
    def self.instantiate_all_loaded_fixtures(arglist)
      all_loaded_fixtures.each_value do |arglist|;Fi[	@îi·I"Ò        FixtureSet::File.open(var) do |arglist|
          var.each do |arglist|
            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "STRING";Fi[	@≥iTI"S            generated_feature_methods.module_eval("STRING", "STRING", (284 + 1))
          else
            raise(ArgumentError, "STRING")
          end
        end
      end
    end
    
    # Returns ActiveRecord::AutosaveAssociation::marked_for_destruction? It's
    # used in conjunction with fields_for to build a form element for the;Fi[	@≥iÇI"∆            else
              raise(ArgumentError, "STRING")
            end
          end
        end
      end
    end
    
    # Assigns the given attributes to the collection association.
    #;Fi[	@≥iÃI"*            end
          else
            raise_nested_attributes_record_not_found(var, var["STRING"])
          end
        end
      end
    end
    
    # Updates a record with the +attributes+ or marks it for destruction if
    # +allow_destroy+ is +true+ and has_destroy_flag? returns +true+.;Fi[	@∂iGI"—                warn("STRING")
              end
            end
          end
        end
      end
    end
    
    initializer("STRING") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|;Fi[	@∂i{I"          if ActiveRecord::Base.connected? then
            ActiveRecord::Base.clear_reloadable_connections!
            ActiveRecord::Base.clear_cache!
          end
        end
      end
    end
    
    initializer("STRING") do |arglist|
      var = var.paths["STRING"].first;Fi[	@æi=I"¿            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2);Fi[	@(	i}I"Ó              var
            else
              (var % var.collect { |arglist| connection.quote_string(var.to_s) })
            end
          end
        end
      end
      
      alias_method(:sanitize_conditions, :sanitize_sql)
      ;Fi[	@(	iîI"              quote_bound_value(var[var])
            else
              raise(PreparedStatementInvalid, "STRING")
            end
          end
        end
      end
      
      def function(arglist)
        if var.respond_to?(:map) and var.acts_like?(:string).! then;Fi[	@∆isI"“                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["STRING"];Fi[	I"Bdata//activerecord_proj/active_record/validations/presence.rb;TiI"A          var = Array(var.send(var))
          if var.present? and var.all? { |arglist| var.marked_for_destruction? } then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods
      # Validates that the specified attributes are not blank (as defined by;Fi[	@ˇiñI"                else
                  MUTEX.synchronize { |arglist| Logger.message("STRING") }
                end
              end
            end
          end
        end
        
        class LocalFile
          attr_reader(:path, :relative_path, :md5);Fi[	@ﬁiI"Ì          Bundler.ui.info("STRING")
          Bundler.load.specs.sort_by { |arglist| var.name }.each do |arglist|
            Bundler.ui.info("STRING")
          end
        end
      end
    end
    
    map(["STRING"] => "STRING")
    ;Fi[	@·iùI"            var = var.specs
            var = (var + var.unmet_dependency_names)
            var.add_source(var)
          end
        end
      end
    end
    
    # used when frozen is enabled so we can find the bundler
    # spec, even if (say) a git gem is not checked out.;Fi[	@ i‰I"Õ              debug { |arglist| "STRING" }
              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by);Fi[	@#i,I"ï          else
            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion
    def function(arglist);Fi[	@&i¢I"¢          else
            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  
  class << self
    attr_reader(:rubygems);Fi[	@)i?I"™              end
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then;Fi[	I"=data//bundler_proj/bundler/vendor/net/http/persistent.rb;Ti"I"º        var.each_value do |arglist|
          finish(var, var)
          var.delete(var.object_id) if var
        end
      end
    end
  end
  
  ##
  # Creates a new connection for +uri+;Fi[	@Xi[I"	            else
              File.expand_path("STRING") rescue File::ALT_SEPARATOR ? ("STRING") : ("STRING")
            end
          end
        end
      end
    end
    
    def self.thor_root(arglist)
      File.join(user_home, "STRING").gsub(/\\/, "STRING");Fi[	@iCI"´            true
          else
            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    ;Fi[	@di/I"ø            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!;Fi[	@diÄI"◊                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first;Fi[	I"1data//capistrano_proj/capistrano/callback.rb;TiI"¿          return except.include?(var.fully_qualified_name).!
        else
          return true
        end
      end
    end
  end
  
  class ProcCallback < Callback
    def function(arglist);Fi[	@viRI"‘                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var;Fi[	@ÜiqI"¢              var[:only] = filter_deprecated_tasks(var[:only])
              var[:except] = filter_deprecated_tasks(var[:except])
              callbacks[var].concat(var.map { |arglist| TaskCallback.new(self, var, var) })
            end
          end
        end
      end
      
      # Filters the given task name or names and attempts to replace deprecated tasks with their equivalents.
      def function(arglist);Fi[	@åihI"5                  raise(ArgumentError, "STRING")
                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,
      # with the exception that it sets the receiver as the "current" configuration;Fi[	@Ç	iI"÷            raise(Compass::Error, "STRING")
          else
            raise(Compass::Error, "STRING")
          end
        end
      end
    end
    
    def function(arglist)
      var = /^#{Regexp.escape(var)}/;Fi[	@ÌiÄI"Ù              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= [];Fi[	@Úi4I"Ø                  end
                end
              end
            end
          end
        end
      end
      
      # Support for testing.
      def function(arglist);Fi[	@˘iôI"K                inherited_data.send("STRING")
              else
                inherited_data.send(var) if inherited_data.respond_to?(var)
              end
            end
          end
        end
        
        # Reads the raw value that was set on this object.
        # you generally should call raw_<attribute>() instead.;Fi[	@ì	iAI"û          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  
  def function(arglist)
    CSS2FallbackValue.new(var, var);Fi[	@ö	i/I"`              (((Ast::Step::INDENT + @var.unpack("STRING").length) + "STRING".length) + var.unpack("STRING").length)
            else
              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("STRING").length)
            end
          end
        end
      end
      
      def function(arglist)
        var.detect { |arglist| var.=~(name) };Fi[	@ i~I"                var.invoke(var.step_mother, var.configuration)
                @var ||= var.reported_exception
                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var);Fi[	@)iEI"            @var.div(:id => "STRING") do |arglist|
              @var.p("STRING", :id => "STRING")
              @var.p("STRING", :id => "STRING")
            end
          end
        end
      end
      
      def function(arglist)
        print_stats(var);Fi[	@4iEI"¿                STDERR.cucumber_puts("STRING")
                cucumber_puts(*var)
              end
            end
          end
        end
      end
      
      Kernel.extend(self)
      ;Fi[	I"8data//devise_proj/devise/controllers/url_helpers.rb;TiI"Ù              var = var ? ("STRING") : ("STRING")
              var = "STRING"
              class_eval("STRING", "STRING", (53 + 1))
            end
          end
        end
      end
      
      generate_helpers!(Devise::URL_HELPERS)
      ;Fi[	I"-data//devise_proj/devise/rails/routes.rb;Ti÷I"T          end
          with_devise_exclusive_scope(var.fullpath, var.name, var) do |arglist|
            var.each { |arglist| send("STRING", var, var.controllers) }
          end
        end
      end
    end
    
    # Allow you to add authentication request from the router.
    # Takes an optional scope and block to provide constraints;Fi[	@tihI"á            @var = var
            break
          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil);Fi[	@ßiI"∫        var.html do |arglist|
          flash[:error] = I18n.t("STRING")
          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist)
    @var = Aspect.new;Fi[	@¡i7I"ï          redirect_to(getting_started_path)
        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  ;Fi[	@ÅiI"ˇ          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("STRING", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516;Fi[	@ÑiI"ï          else
            raise("STRING")
          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare);Fi[	@˙	i%I"î          var
        else
          nil
        end
      end
    end
  end
  
  def function(arglist)
    super(var.merge(:methods => :note_html));Fi[	@çiwI"          if Parser::MID_BLOCK_KEYWORDS.include?(var) then
            @var = @var.parent.value[:dont_indent_next_line]
            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing;Fi[	@çiI"…            else
              "STRING"
            end
          end
        end
      end
    end
    
    # Evaluates `text` in the context of the scope object, but
    # does not output the result.;Fi[	@êiÜI"¡            push_text(var.rstrip)
          else
            push_text(var.rstrip.gsub("STRING", "STRING"))
          end
        end
      end
    end
    
    module Plain
      include(Base);Fi[	@öiKI"ê            puts("STRING")
            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist)
    system("STRING");Fi[	@iI"–          exec("STRING", *(ARGV.kegs + ["STRING", "STRING", "STRING", "STRING"]))
        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  ;Fi[	@iJI"ﬂ          var.symlink? ? (puts("STRING")) : (print_dir(var))
        else
          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = [];Fi[	@ùi4I"Â            puts("STRING")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist)
    (return [] if (HOMEBREW_LIBRARY / "STRING").directory?;Fi[	@™iI"ë          else
            raise("STRING".undent)
          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s);Fi[	@&
iI"≥          opoo("STRING")
          puts("STRING")
          @var = true
        end
      end
    end
  end
  
  def function(arglist)
    if (f.prefix + "STRING").directory? then;Fi[	@≠iÀI"Ô        else
          var.delete if var.overwrite and var.exist?
          var.make_relative_symlink(var)
        end
      end
    end
  end
  
  # symlinks the contents of self+foo recursively into /usr/local/foo
  def function(arglist);Fi[	@¥iI"h              end
            end
          end
        end
      end
    end
  end
  
  private
  ;Fi[	@,
iI"∆          :snowleopard
        else
          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist)
    (@var ||= {}).fetch(var.to_s) do |arglist|;Fi[	@ÂiI"            else
              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    
    # Read all the files in <source>/<dir>/_posts and create a new Post
    # object with each one.;Fi[	I".data//mongoid_proj/lib/mongoid/railtie.rb;Ti^I"M          if ::Mongoid.running_with_passenger? then
            PhusionPassenger.on_event(:starting_worker_process) do |arglist|
              ::Mongoid.default_session.disconnect if var
            end
          end
        end
      end
      
      # Exposes Mongoid's configuration to the Rails application configuration.
      #;Fi[	@›iGI"                  (var.do_or_do_not(:in_memory) or Array.wrap(var)).each { |arglist| var.save }
                end
                exit_autosave
              end
            end
          end
        end
        
        # Can the autosave be added?
        #;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/binding.rb;TiöI"          if var = metadata.inverse_metadata(var) then
            if var = var.inverse_of_field_setter then
              var.you_must(var, var)
            end
          end
        end
      end
      
      # Bind the provided document with the base from the parent relation.
      #;Fi[	@ıi"I"3                  else
                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.;Fi[	@_i I"&            if var = relations[var] then
              var = var.cascade_strategy
              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods
        # Attempt to add the cascading information for the document to know how;Fi[	@ri'I"+                index({ var => 1, var.type => 1 }, :background => (true))
              else
                index({ var => 1 }, :background => (true))
              end
            end
          end
        end
        
        # Handle common behaviour for referenced 1-1 relation setup.
        #;Fi[	I"0data//mongoid_proj/lib/mongoid/relations.rb;TièI";        if instance_variable_defined?("STRING") then
          if (_parent.nil? or instance_variable_get("STRING").!=(_parent)) then
            remove_instance_variable("STRING")
          end
        end
      end
    end
    
    module ClassMethods
      # This is convenience for librarys still on the old API.;Fi[	I"Odata//paperclip_proj/paperclip/validators/attachment_presence_validator.rb;TiI"=        [attributes].flatten.map do |arglist|
          if var.send(:read_attribute_for_validation, "STRING").blank? then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the presence of a file.;Fi[	@eiI"À            unless var.send(CHECKS[var], var) then
              var = options[:in] ? (:in_between) : (var)
              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then;Fi[	@si4I"ñ          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING");Fi[	@vi=I"ñ          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING");Fi[	@yi#I"ñ          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING");Fi[	@ÅiêI"Û          var = ("STRING" + var.downcase)
          self.Error(("STRING" + var)) unless self.respond_to?(var)
          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist)
    var = @var ? ("STRING") : ("STRING");Fi[	@ÅiI"´        else
          (var = freadshort(var)
          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist)
    while true do;Fi[	@iÇI"€            var = ("STRING" + var.downcase)
            self.respond_to?(var).! ? (Error(("STRING" + var))) : (self.send(var, var))
          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj;Fi[	@i2I"ü        if (var == 2) then
          @var = var
          @var = var
        end
      end
    end
  end
  
  alias_method(:write_html_cell, :writeHTMLCell)
  ;Fi[	@åiNI"Y              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist)
        @var = { "STRING" => ({ :sql => "STRING", :klass => (Project), :label => :label_project }), "STRING" => ({ :sql => "STRING", :klass => (IssueStatus), :label => :field_status }), "STRING" => ({ :sql => "STRING", :klass => (Version), :label => :label_version }), "STRING" => ({ :sql => "STRING", :klass => (IssueCategory), :label => :field_category }), "STRING" => ({ :sql => "STRING", :klass => (User), :label => :label_user }), "STRING" => ({ :sql => "STRING", :klass => (Tracker), :label => :label_tracker }), "STRING" => ({ :sql => "STRING", :klass => (TimeEntryActivity), :label => :label_activity }), "STRING" => ({ :sql => "STRING", :klass => (Issue), :label => :label_issue }) };Fi[	@=i9I"ﬂ                @var.last[var].merge!(var)
              else
                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist)
          raise("STRING");Fi[	I"&data//rescue_proj/resque/queue.rb;Ti9I"        synchronize do |arglist|
          Array(@var.lrange(@var, var, ((var + var) - 1))).map do |arglist|
            decode(var)
          end
        end
      end
    end
    
    # Pop an item off the queue.  This method will block until an item is
    # available.;Fi[	I";data//rspec_proj/spec/example/example_group_factory.rb;TiPI"¬              self[(($2 == "STRING") ? (nil) : ($2.to_sym))]
            else
              self[nil]
            end
          end
        end
      end
      
      extend(ClassMethods)
      ;Fi[	@Çi~I"˙                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var);Fi[	@»iCI"l          unless (::ActiveRecord::Observer < StateMachine::Integrations::ActiveModel::Observer) then
            ::ActiveRecord::Observer.class_eval do |arglist|
              include(StateMachine::Integrations::ActiveModel::Observer)
            end
          end
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist);Fi[	@Ø
i1I"∫            escape_double_quotes(var)
          else
            var
          end
        end
      end
    end
    
    def function(arglist)
      var.gsub(/'/) { |arglist| "STRING" };Fi[@(@I"protected;FI" ;F@iU[U[	I"=data//activemodel_proj/active_model/attribute_methods.rb;TiI"Ï      #:nodoc:
      def function(arglist)
        @var ||= Module.new.tap { |arglist| include(var) }
      end
      
      protected
      
      def function(arglist)
        generated_attribute_methods.method_defined?(var)
      end;Fi[	@◊iI"Ÿ          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var)
    end;Fi[	@1i&I"6            var[:type] = (type == :string) ? (nil) : (type)
            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist)
            return if value.nil?
            var = ActiveSupport::XmlMini::TYPE_NAMES[value.class.name];Fi[	@Âi1I"õ            end)
          end
        end
      end
      
      protected
      
      def function(arglist)
        case var
        when /\A0[xX]/ then;Fi[	I"Jdata//activerecord_proj/active_record/associations/join_dependency.rb;TiTI"ù        else
          # do nothing
        end
      end
      
      protected
      
      def function(arglist)
        var = []
        var = var.parent;Fi[	@xi$I"      # Returns the primary key value before type cast.
      def function(arglist)
        read_attribute_before_type_cast(self.class.primary_key)
      end
      
      protected
      
      def function(arglist)
        ((var == "STRING") or super)
      end;Fi[	I"?data//activerecord_proj/active_record/attribute_methods.rb;TiI"Ú    #   person[:age] # => Fixnum
    def function(arglist)
      write_attribute(var, var)
    end
    
    protected
    
    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) }
      var;Fi[	@~iNI"¯      def function(arglist)
        remove_column(var, :updated_at)
        remove_column(var, :created_at)
      end
      
      protected
      
      def function(arglist)
        if var.is_a?(Hash) and var = var[:order] then
          case var;Fi[	@ˇiI"D      # Check the connection back in to the connection pool
      def function(arglist)
        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin
          @var.instrument("STRING", :sql => (var), :name => (var), :connection_id => (object_id), :binds => (var)) do |arglist|;Fi[	@§i©I"¯          raise(ActiveRecord::ActiveRecordError, "STRING")
        end
        alter_table(var, :rename => ({ var.to_s => (var.to_s) }))
      end
      
      protected
      
      def function(arglist)
        exec_query(var, var, var)
      end;Fi[	@æi*I"»            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then
          self.class.delegate_to_scoped_klass(var);Fi[	@æiaI"!    
    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))))
    end
    
    protected
    
    def function(arglist)
      if @var.respond_to?(var) then
        scoping { |arglist| @var.send(var, *var, &var) };Fi[	@	iØI"¥      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@‘iI"‘        self.stored_attributes[var] ||= []
        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist)
      var = initialize_store_attribute(var)
      var[var];Fi[	I"9data//activerecord_proj/active_record/validations.rb;Ti>I"      var ||= new_record? ? (:create) : (:update)
      var = super(var)
      errors.empty? and var
    end
    
    protected
    
    def function(arglist)
      var = var[:validate].!=(false)
      var ? (valid?(var[:context])) : (true);Fi[	@?iII"Â      
      def function(arglist)
        execute!
      end
      
      protected
      
      def function(arglist)
        var = Util.escape_globs(source)
        var = config[:recursive] ? (File.join(var, "STRING")) : (var);Fi[	@DiDI"'          /(#{Regexp.escape(replacement)}STRING#{flag}STRING/m
        end
        replace!(var, var, true)
      end
      
      protected
      
      def function(arglist)
        var = if (var == :invoke) then
          (flag == /\A/) ? (:prepend) : ((flag == /\z/) ? (:append) : (:insert));Fi[	@Ii)I"Î      # Convert to a Hash with String keys.
      def function(arglist)
        Hash.new(default).merge!(self)
      end
      
      protected
      
      def function(arglist)
        var.is_a?(Symbol) ? (var.to_s) : (var)
      end;Fi[	I">data//bundler_proj/bundler/vendor/thor/parser/argument.rb;Ti+I"∞      else
        default
      end
    end
    
    protected
    
    def function(arglist)
      if required? and default.nil?.! then
        raise(ArgumentError, "STRING");Fi[	@O	iÔI"Õ      #
      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist)
        return var unless var.is_a?(Symbol)
        self.class.const_get(var.to_s.upcase);Fi[	I"3data//bundler_proj/bundler/vendor/thor/task.rb;TiJI"π      end))
      (var << "STRING")
      var.strip
    end
    
    protected
    
    def function(arglist)
      (var.class.respond_to?(:debugging) and var.class.debugging).!
    end;Fi[	@iFI"ª          end
        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then
        build_resource;Fi[	@n	ikI"        var = execute_task(var)
        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist)
        return if Thread.current[:rollback_requests].nil?
        rollback_requests.reverse.each do |arglist|;Fi[	@q	i@I"P          var = var.reject { |arglist| var.any? { |arglist| (var.options[var] == var) } }
          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist)
        return var unless (ENV["STRING"] or ENV["STRING"])
        if ENV["STRING"] then;Fi[	I"0data//compass_proj/compass/commands/base.rb;Ti#I"Â      
      def function(arglist)
        @var = true
      end
      
      protected
      
      def function(arglist)
        unless Compass::Frameworks[options[:framework]] then
          raise(Compass::Error.new("STRING"));Fi[	@7iI"À      
      def function(arglist)
        super
      end
      
      protected
      
      def function(arglist)
        add_project_configuration
        Compass.add_configuration(options, "STRING");Fi[	I"6data//compass_proj/compass/exec/sub_command_ui.rb;TiI"ã        end
        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift;Fi[	I"1data//compass_proj/compass/exec/switch_ui.rb;Ti"I"π        return 1
      end
      return 0
    end
    
    protected
    
    def function(arglist)
      options[:command] ? (do_command(options[:command])) : (puts(self.opts))
    end;Fi[	@BiI"”      (var << "STRING")
    end
    Sass::Script::String.new(var.join("STRING"))
  end
  
  protected
  
  def function(arglist)
    var = [var].flatten.pack("STRING").gsub("STRING", "STRING")
    var = "STRING";Fi[	I"Bdata//compass_proj/compass/sass_extensions/functions/lists.rb;Ti^I"ü        var
      end
    end
  end
  
  protected
  
  def function(arglist)
    raise(ArgumentError.new("STRING")) unless var.is_a?(Sass::Script::List)
  end;Fi[	I"Ddata//compass_proj/compass/sass_extensions/functions/sprites.rb;Ti∂I"Á  
  def function(arglist)
    raise(Sass::SyntaxError, "STRING")
  end
  
  protected
  
  def function(arglist)
    if Sass::Script::Color.const_defined?(:HTML4_COLORS_REVERSE) then
      Sass::Script::Color::HTML4_COLORS_REVERSE;Fi[	I"*data//compass_proj/compass/version.rb;TiI"&    # This method swiped from Haml and then modified, some credit goes to Nathan Weizenbaum
    def function(arglist)
      defined? @var ? (@var) : (read_version)
    end
    
    protected
    
    def function(arglist)
      File.join(File.dirname("STRING"), "STRING", "STRING", var)
    end;Fi[	@)iGI"¬      
      def function(arglist)
        @var = []
      end
      
      protected
      
      def function(arglist)
        var = Array.new
        @var.div(:class => "STRING") do |arglist|;Fi[	@Ci}I"≥      
      def function(arglist)
        load(File.expand_path(var))
      end
      
      protected
      
      def function(arglist)
        begin_rb_scenario(var)
      end;Fi[	I"?data//cucumber_prok/cucumber/wire_support/wire_language.rb;Ti%I"Û      
      def function(arglist)
        @var.map { |arglist| var.step_matches(var, var) }.flatten
      end
      
      protected
      
      def function(arglist)
        @var.each { |arglist| var.begin_scenario(var) }
        @var = var;Fi[	I"9data//devise_proj/devise/controllers/rememberable.rb;Ti"I"6        var = Devise::Mapping.find_scope!(var)
        var.forget_me!
        cookies.delete(remember_key(var, var), forget_cookie_values(var))
      end
      
      protected
      
      def function(arglist)
        Devise::Controllers::Rememberable.cookie_values.merge!(var.rememberable_options)
      end;Fi[	@≤	i?I"‚        flash[:alert] = i18n_message
      end
      redirect_to(redirect_url)
    end
    
    protected
    
    def function(arglist)
      var = (warden_message or (var or :unauthenticated))
      if var.is_a?(Symbol) then;Fi[	@`i∏I"ﬁ            end
          end
          var
        end
        
        protected
        
        def function(arglist)
          @var ||= Devise::ParamFilter.new(case_insensitive_keys, strip_whitespace_keys)
        end;Fi[	I"0data//devise_proj/devise/models/lockable.rb;TiaI"∂            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts)
      end;Fi[	I"3data//devise_proj/devise/models/recoverable.rb;Ti6I"      #
      def function(arglist)
        reset_password_sent_at and (reset_password_sent_at.utc >= self.class.reset_password_within.ago)
      end
      
      protected
      
      def function(arglist)
        (reset_password_token.nil? or reset_password_period_valid?.!)
      end;Fi[	@∫	i>I"”      
      def function(arglist)
        self.class.rememberable_options
      end
      
      protected
      
      def function(arglist)
        respond_to?(:remember_token) and remember_expired?
      end;Fi[	@iI"Ê        view_directory(:registrations)
        view_directory(:sessions)
        view_directory(:unlocks)
      end
      
      protected
      
      def function(arglist)
        directory(var.to_s, (var or "STRING"))
      end;Fi[	@Ái/I"Õ  def function(arglist)
    self.profile.tombstone!
    self
  end
  
  protected
  
  def function(arglist)
    if self.url then
      self.url = ("STRING" + self.url) unless self.url.match(/https?:\/\//);Fi[	@Íi™I"Ì    clearable_fields.each { |arglist| self[var] = nil }
    self[:searchable] = false
    self.save
  end
  
  protected
  
  def function(arglist)
    self.first_name.strip! if self.first_name
    self.last_name.strip! if self.last_name;Fi[	I"1data//diaspora_proj/models/status_message.rb;TiõI"    require("uri")
    var = URI.extract(self.raw_message, ["STRING", "STRING"])
    self.oembed_url = var.find { |arglist| TRUSTED_OEMBED_PROVIDERS.find(var).nil?.! }
  end
  
  protected
  
  def function(arglist)
    (errors[:base] << "STRING") unless text_and_photos_blank?
  end;Fi[	I"7data//diaspora_proj/presenters/person_presenter.rb;TiI"ã  
  def function(arglist)
    (@var.try(:person) == @var)
  end
  
  protected
  
  def function(arglist)
    @var.shares_with(@var)
  end;Fi[	I"5data//diaspora_proj/presenters/post_presenter.rb;Ti7I"{  
  def function(arglist)
    @var.reshare_for(@var)
  end
  
  protected
  
  def function(arglist)
    @var.person
  end;Fi[	@≠i´I"”      var.directory? ? (var.rmdir) : (var.delete if var.exist?)
    end
    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin
      if var.symlink? and var.directory? then;Fi[	I"Bdata//homebrew_proj/vendor/multi_json/adapters/json_common.rb;TiI"¬      
      def function(arglist)
        var.to_json(process_options(var))
      end
      
      protected
      
      def function(arglist)
        return var if var.empty?
        var = {};Fi[	@&i^I"‚  def self.parse(arglist)
    var = _parse(var)
    Version.new(var, true) unless var.nil?
  end
  
  protected
  
  def function(arglist)
    @var ||= @var.scan(/\d+|[a-zA-Z]+/).map { |arglist| VersionElement.new(var) }
  end;Fi[	I"Adata//mongoid_proj/lib/mongoid/multi_parameter_attributes.rb;TiFI"Õ      else
        super
      end
    end
    
    protected
    
    def function(arglist)
      return nil if var.all? { |arglist| var.nil? }
      var = var.collect { |arglist| var.nil? ? (1) : (var) };Fi[	I"%data//omni_proj/omniauth/form.rb;TiVI"ù    def function(arglist)
      footer
      Rack::Response.new(@var).finish
    end
    
    protected
    
    def function(arglist)
      "STRING"
    end;Fi[	@ri¿I"°    end
    
    class Options < Hashie::Mash
    end
    
    protected
    
    def function(arglist)
      var.inject({}) do |arglist|
        var.merge!(var);Fi[	@uiI"à  
  def function(arglist)
    migration_template("STRING", "STRING")
  end
  
  protected
  
  def function(arglist)
    "STRING"
  end;Fi[	@‡i(I"        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          var = @var.instance_methods.map(&:to_s)
          var.include?("STRING") and (var.include?("STRING") and var.include?("STRING"));Fi[	@„i6I"Õ        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          if @var.present? then
            "STRING".tap do |arglist|;Fi[	@Êi'I"√        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          @var.send(@var).assign(nil)
          @var.valid?;Fi[	@Èi:I"Ø        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          class << var
            self;Fi[	@iI"Ô        
        def function(arglist)
          self_and_descendants.map { |arglist| "STRING" }.join("STRING")
        end
        
        protected
        
        def function(arglist)
          var.where(["STRING", self])
        end;Fi[	@|
iâI"¸          @var = nil
          @var = nil
          super
        end
        
        protected
        
        def function(arglist)
          var = var.to_s
          var = ::I18n.load_path.select { |arglist| (File.basename(var, "STRING") == var) };Fi[	@TiI"∏      def function(arglist)
        super
        self.top_align = self.top_font = 1
      end
      
      protected
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@WiI"        super
        init_with(:rotate_y_labels => (true), :show_x_guidelines => (true), :show_y_guidelines => (false))
        self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value;Fi[	I")data//redmine_proj/SVG/Graph/Line.rb;Ti'I"Y      def function(arglist)
        init_with(:show_data_points => (true), :show_data_values => (true), :stacked => (false), :area_fill => (false))
        self.top_align = self.top_font = self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = 0
        if (stacked == true) then;Fi[	@°iHI"…        sort(var, var)
        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var.collect { |arglist| var[:title] }
      end;Fi[	@ïiZI"‰        end
        sort(var, var, var)
        @var = [var, var, var]
      end
      
      protected
      
      def function(arglist)
        var = ParseDate.parsedate(var)
        @var = Time.local(*var[0, 6].compact).to_i;Fi[	@òiII"≈        sort(var, var)
        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var = DateTime.parse(var).to_time
      end;Fi[	@ iDI"¡        
        def function(arglist)
          @var[var]
        end
        
        protected
        
        def function(arglist)
          if var = var[:type] then
            self[var];Fi[	I"5data//rspec_proj/spec/example/example_matcher.rb;TiI"y        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist)
        var =~ /(^#{example_group_regex}STRING#{example_regexp}STRING#{example_group_regex}STRING#{example_group_with_before_all_regexp}STRING#{example_regexp}STRING/
      end;Fi[	I"7data//rspec_proj/spec/mocks/message_expectation.rb;TiçI"Ë      def function(arglist)
        (var << var) unless var.nil?
        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin
          @var.call(*var);Fi[	@wi'I"æ      
      def function(arglist)
        return false
      end
      
      protected
      
      def function(arglist)
        @var = (var == :at_least)
        @var = (var == :at_most);Fi[	@êiAI"˜            end
            (var << "STRING")
            (var or var) ? ((var << diff_as_object(var, var))) : (var)
          end
          
          protected
          
          def function(arglist)
            @var.diff_format
          end;Fi[	I"9data//rspec_proj/spec/runner/example_group_runner.rb;TiI"˘        example_groups.each { |arglist| var = var.&(var.run(@var)) }
        finish
        var
      end
      
      protected
      
      def function(arglist)
        reporter.start(number_of_examples)
        example_groups.reverse! if reverse;Fi[	@õiWI"˙        def function(arglist)
          return "STRING" if var.nil?
          var.map { |arglist| backtrace_line(var) }.join("STRING")
        end
        
        protected
        
        def function(arglist)
          @var.colour.!.!
        end;Fi[	@ô
i!I"›      def function(arglist)
        determine_best_match(var, var)
        best_match[:line]
      end
      
      protected
      
      def function(arglist)
        best_match.clear
        var = File.expand_path(var);Fi[	@ú
iÙI")      
      def function(arglist)
        @var.to_i if defined? @var
      end
      
      protected
      
      def function(arglist)
        Spec::Runner.configuration.predicate_matchers.each_pair do |arglist|
          Spec::Example::ExampleMethods.__send__(:define_method, var) do |arglist|;Fi[	I"9data//state_machine_proj/state_machine/extensions.rb;TiäI"E    def function(arglist)
      var = [true, false].include?(var.last) ? (var.pop) : (true)
      (fire_events(*(var + [var])) or raise(StateMachine::InvalidParallelTransition.new(self, var)))
    end
    
    protected
    
    def function(arglist)
      self.class.state_machines.initialize_states(self, var, &var)
    end;Fi[	@ i.I"ç          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file])
    end;Fi[	@™
i7I"G        else
          parse_time
        end
      end
      
      protected
      
      def function(arglist)
        var = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"]
        @var.is_a?(String) and var.any? { |arglist| @var.downcase.index(var) };Fi[	@Ø
i"I"—    
    def function(arglist)
      (roles.empty? or roles.include?(var))
    end
    
    protected
    
    def function(arglist)
      var.gsub(/:\w+/) do |arglist|
        var = [$`[(-1..-1)], $'[(0..0)]];Fi[	@iI"‹        else
          "STRING"
        end
      end
      
      protected
      
      def function(arglist)
        return unless @var.has_key?(:standard)
        @var[:standard].nil? ? ("STRING") : (@var[:standard]);Fi[@(I"var;FI"end;FI" ;FI"def function(arglist);FiJ[J[	@GiVI"‘            var.includes!(var.includes_values)
            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist)
        reflection.name
      end;Fi[	@Ri+I"ˇ        var = super
        if owner.new_record? and var then
          var.flatten.each { |arglist| build_through_record(var) }
        end
        var
      end
      
      def function(arglist)
        ensure_not_nested
        if var.new_record? then;Fi[	@RieI"'          else
            var.send("STRING", build_through_record(var)) if (var.macro == :has_one)
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!
      end;Fi[	@Ji[I"            end
            var.from(join(var, var))
            var, var = var, var.klass
          end
          var
        end
        
        def function(arglist)
          var = var[var].eq(var[var])
          if var.klass.finder_needs_type_condition? then;Fi[	@JicI"@          var = var[var].eq(var[var])
          if var.klass.finder_needs_type_condition? then
            var = var.create_and([var, var.klass.send(:type_condition, var)])
          end
          var
        end
        
        def function(arglist)
          self.join_type = Arel::OuterJoin
          var.joins(self);Fi[	@‡iµI"›          else
            raise(ConfigurationError, "STRING")
          end
        end
        var
      end
      
      def function(arglist)
        var = var.association(var.reflection.name)
        var.target = var;Fi[	@WiI"0          if (var.source_macro == :has_and_belongs_to_many) then
            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist)
        var.table_name
      end;Fi[	@SiUI"F          var.each do |arglist|
            var = var[association_key_name].to_s
            var[var].each { |arglist| (var[var] << var) }
          end
          var
        end
        
        def function(arglist)
          @var ||= if reflection.scope then
            klass.unscoped.instance_exec(nil, &reflection.scope);Fi[	@eiUI"         var[var] ||= {}
        var = var.empty? ? (nil) : (type_cast_attribute_value(var, var))
        var[var][find_parameter_position(var)] ||= var
      end
      var
    end
    
    def function(arglist)
      var =~ /\([0-9]*([if])\)/ ? (var.send(("STRING" + $1))) : (var)
    end;Fi[	@ÅiöI"      def function(arglist)
        unless var = columns(var).find { |arglist| (var.name == var.to_s) } then
          raise("STRING")
        end
        var
      end
      
      def function(arglist)
        var = (@var[:variables] or {})
        var[:sql_auto_is_null] = 0;Fi[	@ái%I"¡              # do nothing
            end
            var = (var + 1)
          end
          var
        end
        
        def function(arglist)
          var = false
          var = false;Fi[	@ßi3I"         var = super
        if locking_enabled? and var.!=(1) then
          raise(ActiveRecord::StaleObjectError.new(self, "STRING"))
        end
        var
      end
      
      def function(arglist)
        var = super
        if locking_enabled? then;Fi[	@	i˝I""        var = arel.where_sql
        var = "STRING" if var
        raise(RecordNotFound, "STRING")
      end
      var
    end
    
    def function(arglist)
      var = where(table[primary_key].in(var)).to_a
      var = limit_value and (var.size > limit_value) ? (limit_value) : (var.size);Fi[	@πipI"—        var.puts("STRING")
        var.puts("STRING")
        var.puts
      end
      var
    end
    
    def function(arglist)
      if (var = @var.indexes(var)).any? then
        var = var.map do |arglist|;Fi[	I"Ddata//activerecord_proj/active_record/validations/uniqueness.rb;TiII"	            var = var.read_attribute(var)
          end
          var = var.and(var[var].eq(var))
        end
        var
      end
      
      def function(arglist)
        var = var.class.serialized_attributes[var.to_s]
        var = var.dump(var) if var and var;Fi[	@ﬁi√I")      var = Bundler.load.dependencies.find { |arglist| (var.name == var) }
      unless var then
        raise(GemNotFound, not_found_message(var, Bundler.load.dependencies))
      end
      var
    end
    
    def function(arglist)
      var = "STRING"
      var = var.map { |arglist| var.name };Fi[	@·iŸI"ø        next if var.include?(var.name)
        (var << var.to_lock)
        (var << var.name)
      end
      var
    end
    
    def function(arglist)
      var = false
      var = "STRING";Fi[	@·iRI"Ê          var.unlock!
          var = true
        end
      end
      var
    end
    
    def function(arglist)
      (@var + @var).each do |arglist|
        var.source = @var.find { |arglist| (var.source == var) } if var.source;Fi[	@·iÑI"        unless var.any? { |arglist| (var.source == var) } then
          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist)
      var and (var.source == var.source)
    end;Fi[	@·iüI"‹            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|
        [var.is_a?(Source::Rubygems) ? (1) : (0), var.to_s];Fi[	@Ái$I"Ã        var = PLATFORM_MAP[var]
        next unless var.include?(var)
        var = var.|([var])
      end
      var
    end
    
    def function(arglist)
      current_env? and current_platform?
    end;Fi[	@ÍiÆI"C        var = var[var]
        var.delete(var)
        var[var.to_s] = var
      end
      var
    end
    
    def function(arglist)
      _normalize_hash(var)
      var = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@ıi5I"B          (var << var) unless var.include?([var.name, var.version, var.platform])
          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist)
      case var
      when Gem::Specification, RemoteSpecification, LazySpecification, EndpointSpecification then;Fi[	@˛i1I"      dependencies.sort_by { |arglist| var.to_s }.each do |arglist|
        next if (var.type == :development)
        (var << "STRING")
      end
      var
    end
    
    def function(arglist)
      @var = source.specs.search(Gem::Dependency.new(name, version)).last
    end;Fi[	@iBI"      unless development_dependencies.empty? then
        (var << "STRING")
        (var << dependencies_to_gemfile(development_dependencies, :development))
      end
      var
    end
    
    def function(arglist)
      (dependencies - development_dependencies)
    end;Fi[	@)i†I"j        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm_rf(var) if File.exists?(var) }
      end
      var
    end
    
    def function(arglist)
      begin
        ENV["STRING"] = Bundler.rubygems.bin_path("STRING", "STRING", VERSION);Fi[	@isI"5        FileUtils.mkdir_p(var.dirname)
        require("bundler/psyched_yaml")
        File.open(var, "STRING") { |arglist| var.puts(var.to_yaml) }
      end
      var
    end
    
    def function(arglist)
      var = (ENV["STRING"] or File.join(Bundler.rubygems.user_home, "STRING"))
      Pathname.new(var);Fi[	@7iàI"          else
            raise(PathError, "STRING")
          end
        end
        var
      end
      
      def function(arglist)
        if path.to_s.match(/^#{Regexp.escape(Bundler.root.to_s)}/) then
          return path.relative_path_from(Bundler.root);Fi[	@i¿I"      if cannot?(var, var, *var) then
        var ||= unauthorized_message(var, var)
        raise(AccessDenied.new(var, var, var))
      end
      var
    end
    
    def function(arglist)
      var = unauthorized_message_keys(var, var)
      var = { :action => (var.to_s) };Fi[	@i–I"¸      var = {}
      relevant_rules(var, var).map do |arglist|
        var.merge!(var.attributes_from_conditions) if var.base_behavior
      end
      var
    end
    
    def function(arglist)
      relevant_rules(var, var).any?(&:only_block?)
    end;Fi[	@iI"—      var = [var]
      aliased_actions.each do |arglist|
        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end;Fi[	@diHI"Ò      var = {}
      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {}
      if @var.kind_of?(Hash) then;Fi[	@˘iæI"˜          var = [self]
          while var.last.inherited_data do
            (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {}
          ATTRIBUTES.each do |arglist|;Fi[	I">data//compass_proj/compass/configuration/serialization.rb;Ti<I"          else
            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist)
        if var.respond_to?(:serialize_to_config) then
          (var.serialize_to_config(var) + "STRING");Fi[	@?i÷I"∂        else
          var
        end
      end
      var
    end
    
    def function(arglist)
      Sass::Script::List.new(var.map do |arglist|
        if ColorStop.===(var) then;Fi[	I"7data//cucumber_prok/cucumber/cli/profile_loader.rb;TiI"‹          raise(YmlLoadError, "STRING") if var.empty?
        else
          raise(YmlLoadError, "STRING")
        end
        var
      end
      
      def function(arglist)
        cucumber_yml.has_key?(var)
      end;Fi[	@ci]I"µ          var = $1
          break
        end
      end
      var
    end
    
    def function(arglist)
      if var.respond_to?(:encode) then
        var.encode(DEFAULT_ENCODING);Fi[	I"1data//cucumber_prok/cucumber/formatter/io.rb;TiI"›            var.flush
            var.close
          end
        end
        var
      end
      
      def function(arglist)
        raise("STRING") unless String.===(var)
        raise("STRING") if File.directory?(var);Fi[	@ﬁiI"±    var.each do |arglist|
      var = single_admin(var, var, var.dup)
      (var << var)
    end
    var
  end
  
  def function(arglist)
    @var = var
    @var = var.html_safe;Fi[	@Ái¿I"é      var = (var + "STRING"))
    rescue => var
      var = @var["STRING"]
    end
    var
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	I"7data//diaspora_proj/models/relayable_retraction.rb;TiI"    var = super
    if defined? var.parent and (var.person == var.parent.author) then
      var.parent_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    return nil unless self.target.present?
    self.target.parent;Fi[	I"4data//diaspora_proj/models/signed_retraction.rb;Ti6I"
    var.target = var
    if (var.person == var.author) then
      var.target_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    @var ||= self.target_type.constantize.where(:guid => (target_guid)).first
  end;Fi[	@?iWI"€      else
        var ? (person_link(var, :class => "STRING")) : (ERB::Util.h($~[1]))
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then
      create_mentions if self.mentions.empty?;Fi[	I"0data//diaspora_proj/models/user/querying.rb;TijI"¬      var = var.where(:owner_id => (nil))
    else
      var = var.where("STRING") if (var[:type] == "STRING")
    end
    var
  end
  
  def function(arglist)
    contact_for(var).aspects
  end;Fi[	@ˆiyI"Ï    if AppConfig.settings.follow_diasporahq? then
      var = Webfinger.new("STRING").fetch
      self.share_with(var, var) if var
    end
    var
  end
  
  def function(arglist)
    OpenSSL::PKey::RSA.new(serialized_private_key)
  end;Fi[	@BiI"W    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile))
    if (is_own_profile or person_is_following_current_user) then
      var.merge!(:location => (@var.location), :birthday => (@var.formatted_birthday), :bio => (@var.bio))
    end
    var
  end
  
  def function(arglist)
    (@var.try(:person) == @var)
  end;Fi[	@√i“I"ú        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var);Fi[	I"'data//homebrew_proj/cmd/missing.rb;TiI"    HOMEBREW_CELLAR.subdirs.each do |arglist|
      var = Formula.factory(var.basename.to_s) rescue nil
      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {}
    var.each do |arglist|;Fi[	@˝iI"Ó        yield(var.name, var) if block_given?
        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist)
    return unless HOMEBREW_CELLAR.exist?
    var = ARGV.named.empty? ? (installed_brews) : (ARGV.formulae);Fi[	I"/data//nokogiri_proj/nokogiri/css/parser.rb;TiaI"          var.first
        else
          Node.new(:CONDITIONAL_SELECTOR, [var.first, var[1]])
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [var.first, Node.new(:COMBINATOR, [var[1], var.last])])
        var;Fi[	@iÙI"∆          else
            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "STRING") then
          var = Node.new(:AN_PLUS_B, var);Fi[	@i˝I"Ï          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "STRING")
        end
        var
      end
      
      def function(arglist)
        if (var[0] == "STRING") then
          var.unshift("STRING");Fi[	@iI"–          else
            raise(Racc::ParseError, "STRING")
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "STRING") then
          (var << "STRING");Fi[	@iI"„          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "STRING")
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [var[1]])
        var;Fi[	I"2data//nokogiri_proj/nokogiri/css/tokenizer.rb;Ti1I"¯      def function(arglist)
        return if @var.eos?
        until (var = _next_token or @var.eos?) do
        end
        var
      end
      
      def function(arglist)
        var = @var.peek(1)
        @var = (@var + 1) if (var == "STRING");Fi[	I",data//nokogiri_proj/nokogiri/version.rb;Ti9I"œ          var["STRING"] = Nokogiri::XERCES_VERSION
          var["STRING"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin
        require("psych");Fi[	@:i?I"          var.unlink if text?
        else
          send(var, var)
        end
        var
      end
      
      def function(arglist)
        if Nokogiri.uses_libxml? and ["STRING", "STRING"].===(LIBXML_VERSION.split("STRING")[(0..1)]) then
          return dump_html;Fi[	@:igI"        return fragment(var).children if var.is_a?(String)
        if (var.is_a?(Document) or (var.is_a?(XML::Attr) or var.is_a?(XML::Node).!)) then
          raise(ArgumentError, "STRING")
        end
        var
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@†iqI"ﬁ          next
        end
        var[var] = var[var]
      end
      var
    end
    
    def function(arglist)
      if OmniAuth.config.camelizations[var.to_s] then
        return OmniAuth.config.camelizations[var.to_s];Fi[	I"$data//redmine_proj/redcloth3.rb;Ti I"ß        end
        var
      end
    end
    var
  end
  
  def function(arglist)
    var.gsub!(/<redpre#(\d+)>/) { |arglist| @var[$1.to_i] } unless @var.empty?
  end;Fi[	@+i3I"¬              end
            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("STRING", 8)
        var.SetFillColor(230, 230, 230);Fi[	@2i]I"7        unless var.leaf? then
          (@var << var)
          var[:indent] += var[:indent_increment]
        end
        var
      end
      
      def function(arglist)
        if var.is_a?(Issue) and var.due_before then
          var = coordinates(var.start_date, var.due_before, var.done_ratio, var[:zoom]);Fi[	@2iùI"
          relations[var.id].each do |arglist|
            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = "STRING"
        if var[:bar_start] and var[:bar_end] then;Fi[	@íi0I"Û          var = partition(var, var, var)
          sort_multiple(var, var, (var - 1))
          sort_multiple(var, (var + 1), var)
        end
        var
      end
      
      def function(arglist)
        var = var[0][var]
        var = var;Fi[	@íiCI"Ï        end
        var.each do |arglist|
          var[var], var[var], *s(:call, s(:lvar, :var), :[], s(:lvar, :var))
        end
        var
      end
      
      def function(arglist)
        if no_css then
          var = parse_css;Fi[	@wi°I"ˇ            @var.raise_wrong_arity_error(var, var.arity)
          end
          var = eval_block(*var, &var)
        end
        var
      end
      
      def function(arglist)
        @var ? (@var.instance_exec(*var, &var)) : (var.call(*var))
      end;Fi[	@§inI"Ô          var = 100.0
          if @var.!=(0) then
            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@ú
iÍI"√          else
            File.file?(var) ? ((var << var)) : (raise("STRING"))
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true)
      end;Fi[	I")data//SiriProxy_proj/siri_objects.rb;Ti*I"⁄      else
        var["STRING"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist)
    self.extend(SiriRootObject)
    self.ref_id = (var or random_ref_id);Fi[I"var;FI"end;FI"end;FI"end;FI"end;FiH[H[	I"Kdata//activemodel_proj/active_model/forbidden_attributes_protection.rb;TiI"ß      if var.respond_to?(:permitted?) and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	@SimI"√          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@oi3I"Ω            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@bi>I"ë        var = var.save
        set_new_record(var)
        raise(RecordInvalid.new(var)) if var.! and var
        var
      end
    end
  end
end;Fi[	@~iII"∆            var = Hash[var.query.split("STRING").map { |arglist| var.split("STRING") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	@åi^I"ı                var = ("STRING" == var[5]) ? ((var[4].to_i - 1)) : (var[4].to_i)
                (var..var)
              else
                var
              end
            end
          end
        end
        
        def function(arglist);Fi[	@îiíI"ﬂ          var = super
          var = "STRING" if var.acts_like?(:time) and var.respond_to?(:usec)
          var = (var.sub(/^-/, "STRING") + "STRING") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	@ªi,I"∞        def function(arglist)
          var, var = super, var[:db_runtime]
          (var << ("STRING" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	@/	i~I"¨        configuration.slice("STRING", "STRING", "STRING").each do |arglist|
          var.concat(["STRING", var]) if var
        end
        var
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/notifier/mail.rb;Ti∏I"s        var = ::Mail.new
        var.to = @var
        var.from = @var
        var
      end
    end
  end
end;Fi[	@ icI"V            end
          end
        end
        var
      end
    end
  end
end;Fi[	@O	iSI"â          var = var.map(&:inspect).join("STRING")
          say("STRING") unless var)
        end
        var
      end
    end
  end
end;Fi[	@ i±I"Á        var.each do |arglist|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end
ActiveRecord::Base.class_eval { |arglist| include(CanCan::ModelAdditions) };Fi[	I"Cdata//cancan_proj/cancan/model_adapters/data_mapper_adapter.rb;Ti#I"›        var.each do |arglist|
          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end
DataMapper::Model.append_extensions(CanCan::ModelAdditions::ClassMethods);Fi[	@ni¥I"p        when "STRING" then
          nil
        else
          var
        end
      end
    end
  end
end;Fi[	@~i.I"s              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	@°i±I"®        def function(arglist)
          var = variable(:scm_arguments)
          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	@∏iÅI"Ñ          when /^\d+/ then
            "STRING"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	@Ö	iLI"î          Sass::Importers::Filesystem.new(var.to_s)
        end
        (var << Compass::SpriteImporter.new)
        var
      end
    end
  end
end;Fi[	I":data//compass_proj/compass/configuration/file_data.rb;TiI"Æ      def self.new_from_string(arglist)
        var = new(var)
        var.with_defaults(var) { |arglist| var.parse_string(var, var) }
        var
      end
    end
  end
end;Fi[	@˘iÀI"s            end
            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	@ì	i@I"ö          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"1data//cucumber_prok/cucumber/ast/examples.rb;Ti/I"ä        var = @var.to_sexp
        var = (var + [var]) if var
        var = (var + [@var.to_sexp])
        var
      end
    end
  end
end;Fi[	@ikI"≥        var = (var + var) if var.any?
        var = (var + [@var.to_sexp]) if @var
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	I".data//cucumber_prok/cucumber/ast/names.rb;TiI"ä      def function(arglist)
        var = @var
        var = (var + "STRING") if @var.!=("STRING")
        var
      end
    end
  end
end;Fi[	I"9data//cucumber_prok/cucumber/ast/scenario_outline.rb;TigI"°        var = @var.to_sexp
        var = (var + var) if var.any?
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	@Pi}I"v          var ||= "STRING"
          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	@fi≥I"é        var = var.join("STRING").to_sym
        var = FORMATS[var]
        raise("STRING") if var.nil?
        var
      end
    end
  end
end;Fi[	@ÂiI"º        raise("STRING") unless String.===(var)
        raise("STRING") if File.file?(var)
        FileUtils.mkdir_p(var) unless File.directory?(var)
        var
      end
    end
  end
end;Fi[	@@iNI"Ç            attr_accessor(:line)
          end
          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	@Ci§I"l            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@ëiDI"ö        var = java.lang.Thread.new { |arglist| var = STDIN.gets }
        var.start
        var.join((var * 1000))
        var
      end
    end
  end
end;Fi[	@¿i(I"z            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@iñI"À          return nil unless var
          var = Factory.from_db(klass, var, criteria.object_id)
          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	@.i.I"ï      def function(arglist)
        var = var.new(klass.aliased_fields, klass.fields)
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/criterion/modifiable.rb;Ti∂I"ô      def function(arglist)
        var = (first or create_document(var, var))
        yield(var) if block_given?
        var
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/fields/foreign_key.rb;Ti™I"e      #
      # @since 3.0.0
      def function(arglist)
        var
      end
    end
  end
end;Fi[	@ÉiàI"’            document[field] = [] unless document[field]
            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	@àiI"–              var = document.send(field)
              (value > 0) ? (var.pop) : (var.shift)
              execute("STRING")
              var
            end
          end
        end
      end
    end
  end;Fi[	@èiI"º              var = document.send(field)
              var.delete(value)
              execute("STRING")
              var
            end
          end
        end
      end
    end
  end;Fi[	@ñiI"⁄              var = document.send(field)
              var.delete_if { |arglist| value.include?(var) }
              execute("STRING")
              var
            end
          end
        end
      end
    end
  end;Fi[	I"?data//mongoid_proj/lib/mongoid/persistence/modification.rb;Ti I"ò        end
        document.post_persist unless (var == false)
        document.errors.clear unless validating?
        var
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/persistence/upsertion.rb;TiI"{          true
        end
        document.post_persist unless (var == false)
        var
      end
    end
  end
end;Fi[	@i I"õ                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	@giI"ê          var
        else
          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	I"0data//mongoid_proj/lib/mongoid/reloading.rb;TiVI"∂    def function(arglist)
      atomic_position.split("STRING").inject(var) do |arglist|
        var = var[(var =~ /\d/ ? (var.to_i) : (var))]
        var
      end
    end
  end
end;Fi[	@âi1I"          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/sessions/factory.rb;Ti{I"∞      # @since 3.1.0
      def function(arglist)
        var["STRING"] = var["STRING"].map { |arglist| var =~ /:/ ? (var) : ("STRING") }
        var
      end
    end
  end
end;Fi[	@ivI"Å        else
          raise(ScanError, (("STRING" + state.to_s) + "STRING"))
        end
        var
      end
    end
  end
end;Fi[	I"*data//omni_proj/omniauth/auth_hash.rb;Ti2I"{      def function(arglist)
        var = super
        var["STRING"] ||= name
        var
      end
    end
  end
end;Fi[	@⁄iI"™      info do |arglist|
        options.fields.inject({}) do |arglist|
          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	@ri«I"{    def function(arglist)
      var.inject({}) do |arglist|
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	@i'I"s              end
            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	@:iI"ã            var = "STRING"
            response.content_type = "STRING"
          end
          var
        end
      end
    end
  end
end;Fi[	@CiI"          @@additional_blocks ||= Dir.glob("STRING").inject({}) do |arglist|
            var = File.basename(var).split("STRING").first.gsub(/^_/, "STRING")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	@HipI"              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("STRING" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end;Fi[	I"3data//rescue_proj/resque/failure/thoughtbot.rb;Ti I"•      def function(arglist)
        var = payload["STRING"].to_s
        var = var.underscore if var.respond_to?(:underscore)
        var
      end
    end
  end
end;Fi[	I"$data//rescue_proj/resque/job.rb;TiXI"                var.send(var, *var) do |arglist|
                  var = var.perform(*var)
                  var = true
                  var
                end
              end
            end
          end
          var.call
        end;Fi[	I"-data//rspec_proj/spec/matchers/pretty.rb;Ti#I"í            (var < (var.length - 1)) ? ((var << "STRING")) : ((var << "STRING"))
          end
        end
        var
      end
    end
  end
end;Fi[	@ÎiÊI"∫      def function(arglist)
        var = (var.last.class == Hash) ? (var.delete_at(-1)) : ({})
        var.each { |arglist| var[var] = anything }
        var
      end
    end
  end
end;Fi[	@ÿi#I"Ω            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[	I",data//twitter_proj/twitter/api/lists.rb;TiXI"ø      def function(arglist)
        merge_user!(var, var, "STRING")
        var[:owner_id] = var.delete(:owner_user_id) unless var[:owner_user_id].nil?
        var
      end
    end
  end
end;Fi[	I",data//twitter_proj/twitter/api/utils.rb;TiµI"±        end
        var[:user_id] = var.join("STRING") unless var.empty?
        var[:screen_name] = var.join("STRING") unless var.empty?
        var
      end
    end
  end
end;Fi[	I"0data//twitter_proj/twitter/configuration.rb;TiI"µ    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	@iI"√      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/profile_banner.rb;TiI"Ø    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	@Ø
i0I"           if var.all? { |arglist| (var == "STRING") } then
            escape_double_quotes(var)
          else
            var
          end
        end
      end
    end
    
    def function(arglist);Fi[@.I"# do nothing;FI"end;FI" ;FI"def function(arglist);FiB[B[	@1ieI"        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          serializable_collection.each do |arglist|
            var = ActiveSupport::XmlMini.rename_key(var.name, options);Fi[	@=iÀI"Z      # the target is stale.
      #
      # This is only relevant to certain associations, which is why it returns nil by default.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        reflection.build_association(var) do |arglist|
          var = [reflection.foreign_key, reflection.type].compact;Fi[	@JiI"˜        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super
        var and [var.to_s, owner[reflection.foreign_type].to_s];Fi[	@¿
i I"8      end
      
      # Begins the transaction (and turns off auto-committing).
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        { :read_uncommitted => "STRING", :read_committed => "STRING", :repeatable_read => "STRING", :serializable => "STRING" }
      end;Fi[	@¿
iI"      
      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ˇi¸I"©        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ˇi I"¢        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ˇiI"ô        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end;Fi[	@ÑiËI"Ω      
      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/postgresql/oid.rb;TiI"·    class PostgreSQLAdapter < AbstractAdapter
      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end;Fi[	@EiI"    #
    # See also http://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
    # :nodoc:
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = self.class.primary_key
      @var[var] = nil unless @var.key?(var);Fi[	I"@data//activerecord_proj/active_record/explain_subscriber.rb;TiI"5require("active_support/notifications")
module ActiveRecord
  class ExplainSubscriber
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      if var = Thread.current[:available_queries_for_explain] then
        (var << var.values_at(:sql, :binds)) unless ignore_payload?(var);Fi[	I";data//activerecord_proj/active_record/null_relation.rb;Ti;I"|      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@LipI"»    private
    
    # A hook to be overridden by association modules.
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      relation_for_destroy.delete_all
    end;Fi[	@ûi‰I"ô        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@˛iGI"∂    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      raise("STRING") unless @var
      return super unless respond_to?(var);Fi[	@#i2I"ü  end
  
  class SystemRubyVersion < RubyVersion
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      RUBY_VERSION
    end;Fi[	I"%data//bundler_proj/bundler/ui.rb;TiI"≠require("rubygems/user_interaction")
module Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@¸iI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@¸iI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@¸iI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@¸iI"é      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@¸iI"á      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@Ái.I"ı          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then
            puts("STRING");Fi[	I"=data//compass_proj/compass/exec/command_option_parser.rb;TiI"≥      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s
    end;Fi[	I"<data//compass_proj/compass/installers/bare_installer.rb;TiI"module Compass
  module Installers
    class BareInstaller < Base
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        directory(targetize("STRING"))
        directory(targetize(Compass.configuration.sass_dir));Fi[	@iI"¯        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("STRING")
        write_file(var, config_contents);Fi[	I"2data//compass_proj/compass/installers/base.rb;Ti3I"Á      
      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end;Fi[	I")data//compass_proj/compass/logger.rb;TiRI"ä  end
  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@iVI"á      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end;Fi[	I"2data//compass_proj/compass/sprite_importer.rb;Ti"I"à      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name
    end;Fi[	I"(data//compass_proj/compass/stats.rb;TiI"œ        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@i"I"∏        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false
        var = var.send(:import);Fi[	@niCI"         var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
        @var.next_feature_element(self) { |arglist| var.skip_invoke! };Fi[	@liGI"«        @var = "STRING"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var)
        var = (Time.now - @var);Fi[	I"7data//cucumber_prok/cucumber/formatter/stepdefs.rb;Ti	I"Ømodule Cucumber
  module Formatter
    class Stepdefs < Usage
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0
      end;Fi[	@:ivI"Ã        var.each { |arglist| load_code_file("STRING") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language
      end;Fi[	@:i~I"ÿ        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|
          if var = var.arguments_from(var) then;Fi[	@@i=I"®        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ÑiI"ü        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@Ñi$I"»        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var)
      end;Fi[	@OiI"¯          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end;Fi[	@'iI"À        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var)
        (@var << Connection.new(var));Fi[	I"=data//devise_proj/devise/models/token_authenticatable.rb;Ti%I"ÿ      end
      
      # Hook called after token authentication.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        self.class.expire_auth_token_on_timeout
      end;Fi[	@Hi:I"~    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "STRING"
  end;Fi[	@çi|I"µ      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value
      rstrip_buffer! if var[:nuke_outer_whitespace];Fi[	I"9data//haml_proj/haml/helpers/safe_erubis_template.rb;TiI"Ímodule Haml
  class SafeErubisTemplate < Tilt::ErubisTemplate
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      @var.merge!(:engine_class => (ActionView::Template::Handlers::Erubis))
      super;Fi[	I"8data//omni_proj/omniauth/test/strategy_test_case.rb;TiI"Æ        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["STRING"]
      end;Fi[	@ziI"†module Paperclip
  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      "STRING"
    end;Fi[	@ziI"~      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end;Fi[	@Åi˝I"ä  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end;Fi[	@iI"°  end
  
  # XXX TODO XXX
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    QTAGS.each do |arglist|
      var.gsub!(var) do |arglist|;Fi[	@íilI"Ÿ      end
      
      # Override and place code to add defs here
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = Document.new
        (@var << XMLDecl.new);Fi[	I"(data//redmine_proj/SVG/Graph/Pie.rb;Ti_I"´      end
      
      # We don't need the graph
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        ["STRING"]
      end;Fi[	I"?data//rspec_proj/spec/adapters/mock_frameworks/flexmock.rb;TiI"∆    module MockFramework
      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        flexmock_verify
      end;Fi[	@ÎiI"≠      end
      
      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end;Fi[	@Îi.I"’      end
      
      class BooleanMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          (TrueClass.===(var) or FalseClass.===(var))
        end;Fi[	I"6data//rspec_proj/spec/runner/backtrace_tweaker.rb;TiI"©        var.gsub!("STRING", "STRING")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end;Fi[	@ûiI"≠          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@°iI"¥          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@§irI"¿          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then
            var = "STRING";Fi[@.I"@var = var;FI"end;FI" ;FI"def function(arglist);FiA[A[	@{i4I"¥      end
      
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.unserialized_value
        end;Fi[	@mi	I"  module AttributeMethods
    module TimeZoneConversion
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var = @var.type_cast(var)
          var.acts_like?(:time) ? (var.in_time_zone) : (var);Fi[	@riﬁI"∆    end
    
    class ConnectionManagement
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (var = var.key?("STRING")
        var = @var.call(var);Fi[	@ÈiEI"'        class Array < Type
          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var);Fi[	@õiI"µ      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled;Fi[	@/	iI"      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database);Fi[	@4	iI"      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var;Fi[	@¥iI"˙      end
      
      # Unfortunately, we have to tie Uniqueness validators to a class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = find_finder_class_for(var)
        var = var.arel_table;Fi[	@¯iI"Ÿ      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then;Fi[	@âiI"»      end
      
      class DefaultConnectionFactory
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          SSH.connect(var, @var)
        end;Fi[	@°iI"Ú        end
        
        class LocalProxy
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            @var.local { |arglist| return @var.send(var, *var, &var) }
          end;Fi[	I"0data//cucumber_prok/cucumber/ast/comment.rb;TiI"æmodule Cucumber
  module Ast
    class Comment
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (@var.nil? or (@var == "STRING"))
      end;Fi[	I"0data//cucumber_prok/cucumber/broadcaster.rb;TiI"≤module Cucumber
  class Broadcaster
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      @var.map { |arglist| var.__send__(var, *var) }
    end;Fi[	@oisI"°        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
        @var = 4;Fi[	@ri1I"ú        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end;Fi[	@OiI"       class StepInvoker
        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@RiI"∫      
      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = WirePacket.new(var, var)
        begin;Fi[	@iI"ømodule Devise
  module Models
    class MissingAttribute < StandardError
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	I" data//devise_proj/devise.rb;Ti˛I"•  end
  
  class Getter
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      ActiveSupport::Dependencies.constantize(@var)
    end;Fi[	I"7data//diaspora_proj/presenters/aspect_presenter.rb;TiI"¢class AspectPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :name => (@var.name) }
  end;Fi[	I"8data//diaspora_proj/presenters/comment_presenter.rb;TiI"class CommentPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :guid => (@var.guid), :text => (@var.text), :author => (@var.author.as_api_response(:backbone)), :created_at => (@var.created_at) }
  end;Fi[	I"Ddata//diaspora_proj/presenters/last_three_comments_decorator.rb;TiI"¯class LastThreeCommentsDecorator
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var.as_json.tap do |arglist|
      var[:interactions].merge!(:comments => (CommentPresenter.as_collection(@var.post.last_three_comments)));Fi[	I"8data//diaspora_proj/presenters/service_presenter.rb;TiI"ôclass ServicePresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :provider => (@var.provider) }
  end;Fi[	@ˇiI"éclass Caveats
  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = []
    (var << f.caveats);Fi[	@&iöI"ª  end
end
class VersionSchemeDetector
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    if @var.is_a?(Class) and @var.ancestors.include?(Version) then
      @var;Fi[	I"1data//omni_proj/omniauth/failure_endpoint.rb;TiI"¡      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["STRING"].to_s == "STRING")
      redirect_to_failure;Fi[	I"3data//omni_proj/omniauth/test/phony_session.rb;TiI"¶class OmniAuth::Test::PhonySession
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var ||= (var["STRING"] or {})
    var["STRING"] = @var;Fi[	@BiI"™    
    SENSIBLE_DEFAULT = "STRING"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      (if blank? then
        SENSIBLE_DEFAULT;Fi[	@Ei	I"¬  class FileCommandContentTypeDetector
    SENSIBLE_DEFAULT = "STRING"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      type_from_file_command
    end;Fi[	@Ni	I"%  class GeometryParser
    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var));Fi[	I"-data//paperclip_proj/paperclip/logger.rb;TiI"¥      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log]
    end;Fi[	@‡iI"‚      end
      
      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = @var.class unless Class.===(@var);Fi[	@ÊiI"Í      end
      
      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = var.new if (var.class == Class);Fi[	@ÈiI"ƒ      end
      
      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self;Fi[	@ÅiÖI"ì    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@ÅiâI"}    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var;Fi[	@Åi†I"r    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Åi§I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Åi®I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Åi¨I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Åi∞I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Åi¥I"y    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Åi∏I"Å    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("STRING" + var))
  end;Fi[	I">data//redmine_proj/redmine/views/other_formats_builder.rb;TiI"%module Redmine
  module Views
    class OtherFormatsBuilder
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = { :format => (var.to_s.downcase) }.merge((var.delete(:url) or {})).except("STRING")
        var = (var.delete(:caption) or var);Fi[	@ûiI"π    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!;Fi[	@©i
I"Â    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var);Fi[	@·iI"∏module Spec
  module Matchers
    class Satisfy
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var if var
        @var = var;Fi[	@Îi#I"ﬂ      end
      
      class RegexpMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          return var.=~(@var) unless var.is_a?(Regexp)
          (var == @var);Fi[	@Îi8I"À      end
      
      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|;Fi[	@ÎiMI"Œ      end
      
      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|;Fi[	@ÎibI"’      end
      
      class DuckTypeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.all? { |arglist| var.respond_to?(var) }
        end;Fi[	@ÎilI"∫      end
      
      class MatcherMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.matches?(var)
        end;Fi[	@ÎivI"¥      end
      
      class EqualityProxy
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var == var)
        end;Fi[	@Îi{I"∫      end
      
      class InstanceOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.instance_of?(@var)
        end;Fi[	@ÎiÖI"≤      end
      
      class KindOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.kind_of?(@var)
        end;Fi[	@wiSI"-      # raise an instance of it, creating it with +new+. If the exception
      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end;Fi[	@wiWI"©        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then
          @var.clear;Fi[	@~iI"Ùmodule Spec
  module Runner
    class ExampleGroupRunner
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        $KCODE = "STRING" if (RUBY_VERSION.to_f < 1.9)
        var.each { |arglist| load(var) };Fi[	@õiI"Ã          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["STRING", var, var.location])
        end;Fi[	@iI"–module Whenever
  module Output
    class Redirection
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        return "STRING" unless defined? @var
        case @var;Fi[@(@@∑
I"# do nothing;FI"end;Fi9[9[	@JiI"∆      
      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@¿
iI"      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.;Fi[	@ˇi˙I"Œ        var = "STRING"
        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ˇi˛I"¶      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ˇiI"¶      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@Òi9I"á    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@ûi‚I"«            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ûiÊI"Í      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in;Fi[	I".data//bundler_proj/bundler/environment.rb;Ti&I"î    
    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@¸i
I"ò  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@¸iI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@¸iI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@¸iI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@¸iI"í    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@Ái,I"˜          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@iI"∫    
    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@iI"Ó      def function(arglist)
        directory(targetize("STRING"))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@iTI"†  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@i I"«        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@iI"        end
        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@i I"¶      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@MiI"Ø        
        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	@niAI"Ù        var.visit_steps(@var)
        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@#iI"•        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	@fiÑI"Á        else
          @var.puts(format_string("STRING", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to;Fi[	@liEI"˘      def function(arglist)
        @var = (var.nil? or (var == "STRING")) ? ("STRING") : (var.split("STRING")[0])
        @var = "STRING"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@:itI"…      
      def function(arglist)
        var.each { |arglist| load_code_file("STRING") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@:i|I"≠      
      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@@i;I"$        var = Ast::Step.new(var.line, var.keyword, var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@@i?I"ò      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private;Fi[	@ÑiI"ß      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@Ñi"I"Ó        RubyPython.start
        @var = import((File.dirname("STRING") + "STRING"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@OiI"∏        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@OiI"Ë        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	I"Adata//cucumber_prok/cucumber/wire_support/request_handler.rb;TiI"¶      
      def function(arglist)
        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      
      private;Fi[	@'iI"£      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@`i,I"û      
      def function(arglist)
        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      
      var = ["STRING"];Fi[	@eiOI"        var = update_attributes(var, *var)
        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A reliable way to expose the salt regardless of the implementation.;Fi[	@4iOI"⁄      def function(arglist)
        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods;Fi[	@Hi8I"Å  
  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist);Fi[	I"*data//diaspora_proj/models/service.rb;Ti%I"—    var = truncate(var, :length => ((var - var)))
    var = "STRING"
    return var
  end
  
  def function(arglist)
    # do nothing
  end
end
require(Rails.root.join("app", "models", "services", "facebook"));Fi[	@çizI"Ñ          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@BiI"‡            [404, { "STRING" => "STRING" }, [(var or var.key?("STRING").to_s)]]
          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ziI"ä    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	I"0data//paperclip_proj/paperclip/processor.rb;TiI"î      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    
    def self.make(arglist);Fi[	@ÅiˇI"~  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function;Fi[	@YiI"∑      
      def function(arglist)
        var.gsub!("STRING", "STRING")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ûiI"∏            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@ûiI"•        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[	@°iI"Õ        def function(arglist)
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@°iI"•        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[	@§ipI"„            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[@
@I"# do nothing;FI"end;FI" ;Fi6[6[	@1idI"…        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          serializable_collection.each do |arglist|;Fi[	@JiI"”      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super;Fi[	@¿
iI"‡      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.
      def function(arglist);Fi[	@ˇi˚I"Ã        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@ˇiˇI"¥      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@ˇiI"´      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var;Fi[	@Òi:I"é    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	@ûi„I"ù          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@ûiÁI"˛      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in
      # ThroughReflection.;Fi[	@˛iFI"ì    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      raise("STRING") unless @var;Fi[	@¸iI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@¸iI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@¸iI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@¸iI"†    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@¸iI"ô    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	@Ái-I"             write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then;Fi[	@iI"≈    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s;Fi[	@iI"ˆ        directory(targetize("STRING"))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("STRING");Fi[	@iUI"ô    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield;Fi[	@i!I"ä      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name;Fi[	@iI"        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@i!I"¥      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false;Fi[	@niBI"        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! };Fi[	@fiÖI"˜          @var.puts(format_string("STRING", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to
      #activate this feature;Fi[	@liFI"˛        @var = (var.nil? or (var == "STRING")) ? ("STRING") : (var.split("STRING")[0])
        @var = "STRING"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var);Fi[	@:iuI"ﬁ      def function(arglist)
        var.each { |arglist| load_code_file("STRING") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language;Fi[	@:i}I"ƒ      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|;Fi[	@@i<I"¡        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@@i@I"ò      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	@ÑiI"±      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "STRING";Fi[	@Ñi#I"˘        @var = import((File.dirname("STRING") + "STRING"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var);Fi[	@OiI"
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)));Fi[	@4iI"¶      def function(arglist)
        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	@'iI"¡      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var);Fi[	@`i-I"û      def function(arglist)
        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      
      var = ["STRING"]
      ;Fi[	@eiPI"·        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A reliable way to expose the salt regardless of the implementation.
      def function(arglist);Fi[	@4iPI"        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new;Fi[	@Hi9I"ã  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "STRING";Fi[	@çi{I"ç        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value;Fi[	@BiI"≥          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["STRING"];Fi[	@ziI"ê    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true;Fi[	@JiI"°      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    
    def self.make(arglist)
      new(var, var, var).make;Fi[	@Åi¸I"ä  end
  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing;Fi[	@Åi I"~  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  ;Fi[	@RiI"Œ  module Adapters
    module MockFramework
      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        flexmock_verify;Fi[	@YiI"ª      def function(arglist)
        var.gsub!("STRING", "STRING")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        [];Fi[	@ûiI"∏            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	@°iI"∆          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	@§iqI"≥          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then;Fi[I""STRING";FI"end;FI" ;F@2I""STRING";Fi6[6[	@¿
i0I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@¿
i4I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@«
ilI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@‰iI"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@‰iI"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@‰iI"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@‰iI"°        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end;Fi[	@˙
iI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@iI"s  PWD = Dir.pwd
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@$iI"i  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@)iI"i  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@.iI"i  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@3iI"i  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@>iI"i  end
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@`i%I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@`i)I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@`i-I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@`i1I"ç      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end;Fi[	@uiI"o  protected
  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@ziI"}    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    ;Fi[	@‡iI"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@‡i#I"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@ÊiI"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@Êi"I"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@Èi1I"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@Èi5I"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@ji7I"|    private
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    ;Fi[	@ji;I"}    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    ;Fi[	@èi>I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@èiBI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ûiI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ûi I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ûiqI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ûiuI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ûiúI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ûi†I"ç      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end;Fi[	@£iI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@£iI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@¶i*I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@©iI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@¨i>I"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@⁄iI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@⁄iI"å      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@·iI"ç      end
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end;Fi[	@§iÇI"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@§iÜI"†        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@§iäI"°        end
        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end;Fi[	@ inI"}    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
    ;Fi[	@ irI"~    end
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
  end;Fi[@(@)I"var;FI"end;FI" ;Fi3[3[	@2i5I"±          var.to_ary.map { |arglist| var.serializable_hash(var) }
        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    ;Fi[	@=iõI"E          var[reflection.foreign_key] = owner[reflection.active_record_primary_key]
          if reflection.options[:as] then
            var[reflection.type] = owner.class.base_class.name
          end
        end
        var
      end
      
      # Sets the owner attributes on the given record
      def function(arglist);Fi[	@GiUI"˜            var = eval_scope(var.klass, var)
            var.includes!(var.includes_values)
            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist)
        reflection.name;Fi[	@RidI"[            (var.send(var.name) << build_through_record(var))
          else
            var.send("STRING", build_through_record(var)) if (var.macro == :has_one)
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!;Fi[	@‡i¥I"ˆ            set_target_and_inverse(var, var, var)
          else
            raise(ConfigurationError, "STRING")
          end
        end
        var
      end
      
      def function(arglist)
        var = var.association(var.reflection.name);Fi[	@WiI"ù          (var << alias_tracker.aliased_table_for(table_name_for(var), table_alias_for(var, var.!=(self.reflection))))
          if (var.source_macro == :has_and_belongs_to_many) then
            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist)
        var.table_name;Fi[	@ÅiìI"            end
            (var.last.columns << var[:Column_name])
            (var.last.lengths << var[:Sub_part])
          end
        end
        var
      end
      
      # Returns an array of +Column+ objects for the table specified by +table_name+.
      def function(arglist);Fi[	@∞iÕI"d          end
          if create_time_zone_conversion_attribute?(var, var) then
            var[var] = AttributeMethods::TimeZoneConversion::Type.new(var)
          end
        end
        var
      end
      
      # Returns a hash where the keys are column names and the values are
      # default values when instantiating the AR object for this table.;Fi[	I"Hdata//activerecord_proj/active_record/relation/predicate_builder.rb;TiI"             var = Arel::Table.new(var, var.engine)
          end
          var.concat(expand(var, var, var, var))
        end
      end
      var
    end
    
    def self.expand(arglist)
      var = [];Fi[	@(	iOI"ı            end
          else
            var[var] = var
          end
        end
        var
      end
      
      # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.
      #   { name: "foo'bar", group_id: 4 };Fi[	@ÊiJI"            Logger.message("STRING"))
          rescue => var
            Logger.warn(Errors::Storage::Dropbox::CacheError.wrap(var, "STRING"))
          end
        end
        var
      end
      
      ##
      # Transfers the archived file to the specified Dropbox folder;Fi[	@·iQI"Á        if var.respond_to?(:unlock!) and @var[:sources].include?(var.name) then
          var.unlock!
          var = true
        end
      end
      var
    end
    
    def function(arglist)
      (@var + @var).each do |arglist|;Fi[	@·iÉI"1        next unless var.respond_to?(:unlock!)
        unless var.any? { |arglist| (var.source == var) } then
          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist)
      var and (var.source == var.source);Fi[	@·iûI"·          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|;Fi[	@ıi4I"        var.search(var, var).each do |arglist|
          (var << var) unless var.include?([var.name, var.version, var.platform])
          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist)
      case var;Fi[	@7iáI"˜            raise(PathError, "STRING")
          else
            raise(PathError, "STRING")
          end
        end
        var
      end
      
      def function(arglist)
        if path.to_s.match(/^#{Regexp.escape(Bundler.root.to_s)}/) then;Fi[	@diQI"«      if @var.kind_of?(Hash) then
        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    ;Fi[	@c	ipI"«            (var << "STRING")
          else
            (var << var.map { |arglist| "STRING" }.join)
          end
        end
        var
      end
      
      #:nodoc:
      def function(arglist);Fi[	@Üi{I"]          if var.is_a?(Array) and var.include?("STRING") then
            warn(var)
            var = var.map { |arglist| (var == "STRING") ? ("STRING") : (var) }
          end
        end
        var
      end
      
      # Trigger the named event for the named task. All associated callbacks
      # will be fired, in the order they were defined.;Fi[	@€i;I"Ú            (var << var)
          else
            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist)
        if var.respond_to?(:serialize_to_config) then;Fi[	@?i’I"∆          Sass::Script::Number.new(50, ["STRING"])
        else
          var
        end
      end
      var
    end
    
    def function(arglist)
      Sass::Script::List.new(var.map do |arglist|;Fi[	@?i?I",          if (var.value.last == var.value.last) and (var.value.first.value == 0) then
            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    
    # returns the end position of the gradient from the color stop
    def function(arglist);Fi[	@ci\I"π        if ENCODING_PATTERN.=~(var) then
          var = $1
          break
        end
      end
      var
    end
    
    def function(arglist)
      if var.respond_to?(:encode) then;Fi[	@ÂiI"œ          unless var.closed? then
            var.flush
            var.close
          end
        end
        var
      end
      
      def function(arglist)
        raise("STRING") unless String.===(var);Fi[	@`iµI"„              var = var[var]
              var.send("STRING", var)
              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected
        ;Fi[	@4iqI":              var.reset_password!(var[:password], var[:password_confirmation])
            else
              var.errors.add(:reset_password_token, :expired)
            end
          end
          var
        end
        
        Devise::Models.config(self, :reset_password_keys, :reset_password_within)
      end;Fi[	@?iVI"Í        var ? (ERB::Util.h(var.name)) : (ERB::Util.h($~[1]))
      else
        var ? (person_link(var, :class => "STRING")) : (ERB::Util.h($~[1]))
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then;Fi[	@√i—I"ó          var["STRING"] = var
        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {};Fi[	@˝iI"…      unless var.empty? then
        yield(var.name, var) if block_given?
        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist)
    return unless HOMEBREW_CELLAR.exist?;Fi[	@i_I"ß        end
        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  ;Fi[	@ iëI"ò          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    ;Fi[	@:i0I"            (var[var] ||= {}).merge!(var)
          else
            (var["STRING"] ||= {}).merge!(var => (mongoize_for(var, var, var)))
          end
        end
        var
      end
      
      # Check if the hash is part of a blank relation criteria.
      #;Fi[	I"0data//mongoid_proj/lib/mongoid/hierarchy.rb;Ti-I"ª              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end
    
    # Marks all children as being persisted.
    #;Fi[	@iÛI"»            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "STRING") then;Fi[	@iI"‡            var = Node.new(:AN_PLUS_B, var)
          else
            raise(Racc::ParseError, "STRING")
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "STRING") then;Fi[	@i8I"Õ        if jruby? then
          var["STRING"] = Nokogiri::XERCES_VERSION
          var["STRING"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin;Fi[	@7i=I"∏            end
          else
            var.content = var
          end
        end
        var
      end
      
      # Create a Text Node with +string+
      def function(arglist);Fi[	@iI"Ø          end
        end
        var
      end
    end
    var
  end
  
  def function(arglist)
    var.gsub!(/<redpre#(\d+)>/) { |arglist| @var[$1.to_i] } unless @var.empty?;Fi[	@i I"Æ            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8(arglist)
      return var if var.nil?;Fi[	@iHI"π            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8_by_setting(arglist)
      return var if var.nil?;Fi[	@+i2I"Æ                end
              end
            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("STRING", 8);Fi[	@2iúI"˙        if relations[var.id] then
          relations[var.id].each do |arglist|
            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = "STRING";Fi[	I",data//redmine_proj/redmine/thumbnail.rb;TiI"Œ        unless system(var) then
          logger.error("STRING")
          return nil
        end
      end
      var
    end
    
    def self.convert_available?(arglist)
      return @var if defined? @var;Fi[	@ú
iÈI"…            end
          else
            File.file?(var) ? ((var << var)) : (raise("STRING"))
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true);Fi[	@,i)I"Ω        end
      else
        var["STRING"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist)
    self.extend(SiriRootObject);Fi[	I"Adata//state_machine_proj/state_machine/machine_collection.rb;Ti,I"Q          if var.dynamic_initial_state? then
            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    
    # Runs one or more events in parallel on the given object.  See
    # StateMachine::InstanceMethods#fire_events for more information.;Fi[@¬@√I"end;FI"end;FI"end;Fi0[0[	@åiäI"Ü          when "STRING" then
            var
          else
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@Ei<I"              var = (columns.map { |arglist| "STRING" } * "STRING")
              "STRING"
            else
              "STRING"
            end
          end
        end
      end
      
      # Overwrite the default class equality method to provide support for association proxies.;Fi[	I"9data//activerecord_proj/active_record/integration.rb;Ti9I"{        var = var.utc.to_s(cache_timestamp_format)
        "STRING"
      else
        "STRING"
      end
    end
  end
end;Fi[	@“i/I"ú      def function(arglist)
        var = ("STRING" if @var or "STRING" if @var)
        var = "STRING" if @var
        "STRING"
      end
    end
  end
end;Fi[	@`i7I"ì      ##
      # Builds the full riak-admin string based on all attributes
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@›i~I"•        ##
        # Returns the url for the specified room (in JSON format)
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/storage/rsync.rb;Ti|I"≥      # RSync options
      # -z = Compresses the bytes that will be transferred to reduce bandwidth usage
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@iAI"§        ##
        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@	i8I"§        ##
        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@i*I"û        ##
        # Returns Rsync syntax for invoking "archive" mode
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@i.I"q      rescue Errno::ENOENT
        "STRING"
      rescue => var
        "STRING"
      end
    end
  end
end;Fi[	@ßiÄI"ï          var = var.split(/\//)
          var = var.pop
          var = var.join("STRING")
          "STRING"
        end
      end
    end
  end
end;Fi[	@™iVI"É          when false then
            nil
          else
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@µiI"û        
        # log: There's no log, so it just echos from and to.
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@œi*I"‚        # Returns the command which will write the identifier of the
        # revision being deployed to the REVISION file on each host.
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@‰iI"r        end
        
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@ÍiI"ß        if (top_level.preferred_syntax == :scss) and top_level.sass_dir then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	@i•I"ˇ      
      # Emits an HTML fragment that can be used to link to the compiled css files
      def function(arglist)
        "STRING"
      end
    end
  end
end
require("compass/installers/bare_installer")
require("compass/installers/manifest_installer");Fi[	I"7data//cucumber_prok/cucumber/formatter/duration.rb;TiI"à      # <tt>time</tt> format.
      def function(arglist)
        var, var = var.divmod(60)
        "STRING"
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/js_support/js_snippets.rb;TiI"§        var = var.empty? ? ("STRING") : ("STRING")
        var = "STRING"
        var = "STRING" if (var == Ast::Table)
        "STRING"
      end
    end
  end
end;Fi[	@i'I"^      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@iI"^      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@çiI"û            when "STRING" then
              "STRING"
            else
              "STRING"
            end
          end
        end
      end
    end
    ;Fi[	I"(data//jekyll_proj/jekyll/filters.rb;Ti~I"_      when 2 then
        "STRING"
      else
        "STRING"
      end
    end
  end
end;Fi[	@ËiI"·          var = Liquid::Template.parse(var)
          var.stack { |arglist| var.render(var) }
        else
          "STRING"
        end
      end
    end
  end
end
Liquid::Template.register_tag("STRING", Jekyll::IncludeTag);Fi[	@Îi&I"‘          def function(arglist)
            var = parent.atomic_position
            var = document.new_record? ? ("STRING") : ("STRING")
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@i%I"¨          # @since 2.1.0
          def function(arglist)
            var = parent.atomic_position
            "STRING"
          end
        end
      end
    end
  end
end;Fi[	@iîI"~        #
        # @since 3.0.0
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/criterion/inspection.rb;TiI"j      #
      # @since 1.0.0
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@#iTI"v        when Hash then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	@`i5I"      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end
module Rails
  module Generators;Fi[	I"=data//nokogiri_proj/nokogiri/html/element_description.rb;TiI"v      ###
      # Inspection information
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	I"7data//nokogiri_proj/nokogiri/xml/attribute_decl.rb;TiI"É      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	I".data//nokogiri_proj/nokogiri/xml/cdata.rb;TiI"      ###
      # Get the name of this CDATA node
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	I"5data//nokogiri_proj/nokogiri/xml/element_decl.rb;TiI"É      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@miI"^      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@ªiI"x        
        # :nodoc:
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"=data//redmine_proj/redmine/views/api_template_handler.rb;Ti	I"z  module Views
    class ApiTemplateHandler
      def self.call(arglist)
        "STRING"
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/matchers/generated_descriptions.rb;TiI"ç      if last_matcher.respond_to?(:description) then
        last_matcher.description
      else
        "STRING"
      end
    end
  end
end;Fi[	@§iéI"r        end
        
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@€iDI"|          "STRING"
        end
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@i!I"{        when /\.png$/i then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	@i<I"^      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[@
@I"0assert_version_detected("STRING", "STRING");FI"end;FI" ;Fi/[/[	I".data//homebrew_proj/test/test_versions.rb;TiOI"   def function(arglist)
    assert_raises(RuntimeError) { |arglist| var = TestBadVersion.new }
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iSI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iWI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i[I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i_I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚icI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚igI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚ikI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚ioI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚isI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iwI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i{I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i~I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iÇI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iÜI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iäI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iìI"    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚ióI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iõI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iüI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i£I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚ißI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i´I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iØI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i≥I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i∑I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iªI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iøI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i√I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i«I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iÀI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iœI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i”I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i◊I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i€I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iﬂI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚i„I"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iÁI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iÎI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iÔI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING");Fi[	@˚iÛI"5  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  # def test_version_ghc_style
  #   assert_version_detected '7.0.4', 'http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-x86_64-apple-darwin.tar.bz2';Fi[@(@@∑
@ˆI"end;Fi/[/[	@˚iNI"”  
  def function(arglist)
    assert_raises(RuntimeError) { |arglist| var = TestBadVersion.new }
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iRI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iVI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iZI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i^I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚ibI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚ifI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚ijI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚inI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚irI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚ivI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚izI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i~I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i}I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iÅI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iÖI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iâI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iíI"È  def function(arglist)
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iñI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iöI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iûI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i¢I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i¶I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i™I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iÆI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i≤I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i∂I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i∫I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iæI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i¬I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i∆I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iŒI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i“I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i÷I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i⁄I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iﬁI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚i‚I"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iÊI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iÍI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iÓI"º  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist);Fi[	@˚iÚI"√  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  # def test_version_ghc_style;Fi[@ˆI"end;FI" ;FI"def function(arglist);FI"0assert_version_detected("STRING", "STRING");Fi/[/[	@˚iQI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iUI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iYI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i]I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iaI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚ieI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iiI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚imI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iqI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iuI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iyI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i}I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i|I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iÄI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iÑI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iàI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iåI"◊  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iëI"‘  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iïI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iôI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iùI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i°I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i•I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i©I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i≠I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i±I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iµI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iπI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iΩI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i¡I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i≈I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i…I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iÕI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i—I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i’I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iŸI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i›I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚i·I"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iÂI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iÈI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iÌI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[	@˚iÒI"™  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  ;Fi[@.@ˆI"end;FI" ;FI"def function(arglist);Fi.[.[	@˚iPI"Ó    assert_raises(RuntimeError) { |arglist| var = TestBadVersion.new }
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iTI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iXI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i\I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i`I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚idI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚ihI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚ilI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚ipI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚itI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚ixI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i|I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i{I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iÉI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iáI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iãI"    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@˚iîI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iòI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iúI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i†I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i§I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i®I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i¨I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i∞I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i¥I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i∏I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iºI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i¿I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iƒI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i»I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iÃI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i–I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i‘I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iÿI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i‹I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i‡I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚i‰I"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iËI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iÏI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iI"◊    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end
  
  def function(arglist)
    assert_version_detected("STRING", "STRING")
  end;Fi[I"out("STRING");FI"out("STRING");FI"out("STRING");FI"out("STRING");FI"out("STRING");Fi.[.[	@siXI"æ    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@siYI"≈    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@siZI"≈    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@si[I"ß    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end;Fi[	@si\I"ô    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@viYI"æ    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@viZI"≈    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@vi[I"≈    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@vi\I"ß    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end;Fi[	@vi]I"ô    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@yiCI"æ    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@yiDI"≈    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@yiEI"≈    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@yiFI"ß    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end;Fi[	@yiGI"ô    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@i†I"æ    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@i°I"≈    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@i¢I"≈    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@i£I"ß    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end;Fi[	@i§I"ò    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
  ;Fi[	@ia
I"¨    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ib
I"¨    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ic
I"¨    newobj
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@id
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ie
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@if
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ig
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ih
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ii
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ij
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ik
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@il
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@im
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@in
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@io
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ip
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@iq
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@ir
I"≥    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@is
I"¨    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    newobj;Fi[	@it
I"¨    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    newobj
    out("STRING");Fi[	@iz
I"•    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    newobj
    out("STRING");Fi[@(@@ @!I"##;Fi-[-[	@UiVI"È      else
        raise(Errors::Archive::PipelineError, ("STRING" + var.error_messages))
      end
    end
    
    private
    
    ##
    # Returns a "tar-ready" string of all the specified paths combined
    def function(arglist);Fi[	I",data//backup_proj/backup/cli/utility.rb;Ti”I"      # Returns the current version of the Backup gem
      def function(arglist)
        puts("STRING")
      end
      
      private
      
      ##
      # Helper method for asking the user if he/she wants to overwrite the file
      def function(arglist);Fi[	I"0data//backup_proj/backup/compressor/base.rb;TiI"œ      def function(arglist)
        log!
        yield(@var, @var)
      end
      
      private
      
      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist);Fi[	I"2data//backup_proj/backup/compressor/custom.rb;TiI"Û        instance_eval(&var) if block_given?
        @var = set_cmd
        @var = set_ext
      end
      
      private
      
      ##
      # Return the command line using the full path.
      # Ensures the command exists and is executable.;Fi[	I".data//backup_proj/backup/database/base.rb;TiI"»      def function(arglist)
        prepare!
        log!
      end
      
      private
      
      ##
      # Defines the @dump_path and ensures it exists by creating it
      def function(arglist);Fi[	@ZiLI"∆          (unlock_database if @var
          package! unless var)
        end
      end
      
      private
      
      ##
      # Builds and runs the mongodump command
      def function(arglist);Fi[	@]iHI"ˆ        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages))
        end
      end
      
      private
      
      ##
      # Builds the full mysqldump string based on all attributes
      def function(arglist);Fi[	I"/data//backup_proj/backup/database/redis.rb;Ti8I"‹        super
        invoke_save! if invoke_save
        copy!
      end
      
      private
      
      ##
      # Tells Redis to persist the current state of the
      # in-memory database to the persisted dump file;Fi[	@`i0I"∆            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes
      def function(arglist);Fi[	I"/data//backup_proj/backup/encryptor/base.rb;TiI"≈      
      def function(arglist)
        load_defaults!
      end
      
      private
      
      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist);Fi[	@cieI"Æ        ensure
          cleanup
        end
      end
      
      private
      
      ##
      # Remove any temporary directories and reset all instance variables.
      #;Fi[	I"3data//backup_proj/backup/encryptor/open_ssl.rb;Ti-I"      def function(arglist)
        log!
        yield("STRING", "STRING")
      end
      
      private
      
      ##
      # Uses the 256bit AES encryption cipher, which is what the
      # US Government uses to encrypt information at the "Top Secret" level.;Fi[	@fi@I"º          log!
          notify!(var)
        end
      end
      
      private
      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist);Fi[	@›iI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@›ikI"f        # Wrapper method for the #send_message (private) method
        def function(arglist)
          send_message(var)
        end
        
        private
        
        ##
        # Takes a "message" as argument, the "type" defaults to "Textmessage".
        # This method builds up a POST request with the necessary params (serialized to JSON format);Fi[	@‡i0I"¯        @var ||= "STRING"
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@IioI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"/data//backup_proj/backup/notifier/prowl.rb;TiI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"2data//backup_proj/backup/notifier/pushover.rb;Ti I"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I"1data//backup_proj/backup/notifier/twitter.rb;TiI"Û      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	I")data//backup_proj/backup/pipeline.rb;TiFI"¶    # Each error is wrapped by Backup::Errors to provide formatting.
    def function(arglist)
      @var ||= (((stderr_messages or "STRING") + "STRING") + @var.map { |arglist| Errors::Error.wrap(var).message }.join("STRING"))
    end
    
    private
    
    ##
    # Each command is added as part of the pipeline, grouped with an `echo`
    # command to pass along the command's index in @commands and it's exit status.;Fi[	I")data//backup_proj/backup/splitter.rb;TiI"Ô      before_packaging
      yield(@var)
      after_packaging
    end
    
    private
    
    ##
    # The `split` command reads from $stdin and will store it's output in
    # multiple files, based on the @chunk_size. The files will be;Fi[	I"-data//backup_proj/backup/storage/base.rb;Ti%I"˘        @var = @var.package
        transfer!
        cycle!
      end
      
      private
      
      ##
      # Provider defaults to false. Overridden when using a service-based
      # storage such as Amazon S3, Rackspace Cloud Files or Dropbox;Fi[	@„iI"Ó        @var ||= false
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage
      def function(arglist);Fi[	@Êi%I"%        @var ||= "STRING"
        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # The initial connection to Dropbox will provide the user with an
      # authorization url. The user must open this URL and confirm that the;Fi[	@Èi"I"⁄        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #;Fi[	@ÓiI"*        @var ||= File.join(File.expand_path((ENV["STRING"] or "STRING")), "STRING")
        instance_eval(&var) if block_given?
        @var = File.expand_path(@var)
      end
      
      private
      
      ##
      # Transfers the archived file to the specified path
      def function(arglist);Fi[	@ÒiI"Ï        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage
      def function(arglist);Fi[	@°i$I"Ì        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored
      #;Fi[	@ÙiI"Ê        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage
      def function(arglist);Fi[	@˜iI"        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.;Fi[	@˙iI"Ò        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist);Fi[	@ˇiSI"            else
              raise(Errors::Syncer::Cloud::ConfigurationError, "STRING")
            end
          end
          
          private
          
          ##
          # Gathers all the relative paths to the local files
          # and merges them with the , removing;Fi[	@i,I"
          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "STRING")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for CloudFiles.
        def function(arglist);Fi[	@	i#I"          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "STRING")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for S3.
        def function(arglist);Fi[	@iI"	        def function(arglist)
          super
          @var ||= Array.new
        end
        
        private
        
        ##
        # Returns the @directories as a space-delimited string of
        # single-quoted values for use in the `rsync` command line.;Fi[	@iI"Ù        def function(arglist)
          Logger.message(("STRING" + @var.join("STRING")))
          run(("STRING" + "STRING"))
        end
        
        private
        
        ##
        # Return expanded @path
        def function(arglist);Fi[	@iI"—          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return expanded @path, since this path is local
        def function(arglist);Fi[	@i6I"œ          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return @path with any preceeding "~/" removed
        def function(arglist);Fi[	I")data//backup_proj/backup/template.rb;Ti$I"V    # Returns a String object containing the contents of the file (in the context of the binding if any)
    def function(arglist)
      ERB.new(file_contents(var), nil, "STRING").result(binding)
    end
    
    private
    
    ##
    # Reads and returns the contents of the provided file path,
    # relative from the Backup::TEMPLATE_PATH;Fi[@
@@@I"end;Fi%[%[	@îiÂI"µ        end
      end
    end
    
    def function(arglist)
      "STRING"
    end
  end
  
  Fixtures = ActiveSupport::Deprecation::DeprecatedConstantProxy.new("STRING", "STRING");Fi[	@•iQI"]    end
    
    private
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ÿ
i*I"É        chunk_suffixes.map { |arglist| "STRING" }
      end
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ﬁi‚I"ô    def function(arglist)
      "STRING" if `which more` rescue "STRING".empty?.!
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ÌiGI"]    end
    
    private
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@vi`I"⁄        def function(arglist)
          Evaluator.new(configuration, condition, var).result
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist);Fi[	@‰iI"ö        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end
    end
  end;Fi[	@:i3I"«        var = eval_js("STRING")
        var.to_a[(1..-1)].map { |arglist| JsArg.new(var) } if var
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    class JsHook;Fi[	@iI"†      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    def self.config(arglist);Fi[	@i%I"	        var = (var.split("STRING").map { |arglist| (("STRING" * var) + var) }.join("STRING") << "STRING")
        inject_into_class(model_path, var.last, var) if model_exists?
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@igI"—      def function(arglist)
        view_directory(:markerb, target_path)
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    class ViewsGenerator < Rails::Generators::Base;Fi[	@iI"∞          inject_into_file(model_path, model_contents, :after => "STRING")
        end
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@;i	I"v  def function(arglist)
    Jobs::Mail::RequestAcceptance
  end
  
  def function(arglist)
    "STRING"
  end
end;Fi[	@Íi√I"±  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["STRING", "STRING", "STRING"])
  end
  
  def function(arglist)
    "STRING"
  end
end;Fi[	@Mi&I"x  def function(arglist)
    super(var, MAX_CHARACTERS, var)
  end
  
  def function(arglist)
    "STRING"
  end
end;Fi[	@`i3I"Ü      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@€iI"µ      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@·iI"µ      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@miI"ö      def self.new(arglist)
        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@RiYI"_    end
    
    protected
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ûiUI"’        var = "STRING"
        raise((var << ([:===, :==].include?(@var) ? ("STRING") : ("STRING"))))
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    class BePredicate < Be;Fi[	@ûi¢I"í      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:;Fi[	@Ö
iOI"Ö        @var = var
        self
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:;Fi[	@¶iTI"Ö        @var = var
        self
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:;Fi[	@·iI"í      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:;Fi[	@Êi%I"˜      def function(arglist)
        (@var or @var.nil? ? (explanation) : ("STRING"))
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # simple_matcher makes it easy for you to create your own custom matchers;Fi[	@ÎiI"©        def function(arglist)
          true
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      class RegexpMatcher;Fi[	@ÎiFI"≠            return false
          end
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      class HashNotIncludingMatcher;Fi[	@Îi[I"•            return false
          end
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      class DuckTypeMatcher;Fi[	@§iåI"ö        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end
    end
  end;Fi[	@ itI"u    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@i:I"}          "STRING"
        end
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[@.@/@0I"end;FI"end;Fi%[%[	@•iRI"U    
    private
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@`i6I"ö      
      ##
      # Builds the full riak-admin string based on all attributes
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@›i}I"Æ        
        ##
        # Returns the url for the specified room (in JSON format)
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@ÿ
i+I"V      end
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@°i{I"º      ##
      # RSync options
      # -z = Compresses the bytes that will be transferred to reduce bandwidth usage
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@i@I"≠        
        ##
        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@	i7I"≠        
        ##
        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@i)I"ß        
        ##
        # Returns Rsync syntax for invoking "archive" mode
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@ﬁi„I"      "STRING" if `which more` rescue "STRING".empty?.!
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ÌiHI"U    
    private
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@µiI"™        end
        
        # log: There's no log, so it just echos from and to.
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@œi)I"Î        
        # Returns the command which will write the identifier of the
        # revision being deployed to the REVISION file on each host.
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@‰iI"Ä          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@i§I"ÿ      end
      
      # Emits an HTML fragment that can be used to link to the compiled css files
      def function(arglist)
        "STRING"
      end
    end
  end
end
require("compass/installers/bare_installer");Fi[	@i!I"†  else
    STDERR.puts("STRING")
    # This Ruby implementation doesn't implement Proc#to_s correctly
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@i&I"ü        inject_into_class(model_path, var.last, var) if model_exists?
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@iI"j        end
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@iìI"Æ        # @return [ String ] The reduce JS function.
        #
        # @since 3.0.0
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@—iI"ó      # @return [ String ] The inspection string.
      #
      # @since 1.0.0
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@`i4I"|        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end
module Rails;Fi[	@ÿiI"}      
      ###
      # Inspection information
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@€iI"ä      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@ﬁi
I"†    class CDATA < Nokogiri::XML::Text
      ###
      # Get the name of this CDATA node
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@·iI"ä      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@miI"~        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[	@ªiI"        end
        
        # :nodoc:
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@RiZI"W    
    protected
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@§içI"Ä          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	@€iCI"ï        def function(arglist)
          "STRING"
        end
        def function(arglist)
          "STRING"
        end
      end
    end
  end
end;Fi[	I"6data//state_machine_proj/state_machine/matcher.rb;TiqI"ã    end
    
    # A human-readable description of this matcher.  Always "same".
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ iuI"[      "STRING"
    end
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@i;I"j        end
      end
      
      def function(arglist)
        "STRING"
      end
    end
  end
end;Fi[@(@I"attr_reader :function;FI" ;FI"def function(arglist);Fi%[%[	@¿
iﬁI"ò            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?
      end;Fi[	@˙i5I"»        @var = []
        @var = false
        @var = var.fetch(:joinable, true)
      end
      
      attr_reader :function
      
      def function(arglist)
        @var and finishing?.!
      end;Fi[	@ˇiÊI"˘      # is no longer active, then this method will reconnect to the database.
      def function(arglist)
        reconnect! unless active?
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.number
      end;Fi[	@·inI"ø    
    def function(arglist)
      (@var - specs)
    end
    
    attr_reader :function
    
    def function(arglist)
      var = []
      resolve.materialize(requested_dependencies, var);Fi[	@/i¶I"¬      
      def function(arglist)
        cached_revision and super
      end
      
      attr_reader :function
      
      def function(arglist)
        allow_git_ops? and local?.!
      end;Fi[	@¸iAI"¨      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.!.! and @var.!
      end;Fi[	@Oi5I"Ó        @var[var.switch_name] = var
        var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist)
      return super unless @var
      var = super;Fi[	@vi#I"ª        
        def function(arglist)
          options[:last]
        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end;Fi[	@ôiWI"ƒ      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      
      def function(arglist)
        var = @var.dup
        (var << "STRING") if @var;Fi[	I"2data//compass_proj/compass/app_integration.rb;TiI"ˆ      #attr_accessor :project_types
      def function(arglist)
        @var ||= DEAFULT_PROJECT_TYPES.dup
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.keys.===(DEAFULT_PROJECT_TYPES.keys)
      end;Fi[	I"3data//cucumber_prok/cucumber/ast/background.rb;TiII"       
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
      end
      
      attr_reader :function
      
      def function(arglist)
        (@var.first or self)
      end;Fi[	@#i}I"Ω      
      def function(arglist)
        cells_rows[0][var]
      end
      
      attr_reader :function
      
      def function(arglist)
        columns[var].__send__(:width)
      end;Fi[	I"0data//cucumber_prok/cucumber/cli/options.rb;Ti“I"≠            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then
          @var.puts("STRING");Fi[	@:i<I"ÿ    class JsHook
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.current_world.execute(@var)
      end;Fi[	@:iXI"≠    class JsArg
      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end;Fi[	@:iñI"›      
      def function(arglist)
        add_transform(JsTransform.new(self, var, var))
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.invoke_steps(var, @var, var)
      end;Fi[	I"%data//homebrew_proj/checksums.rb;TiI"§  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == var.hash_type) and (@var == var.hexdigest)
  end;Fi[	@i∂I"*    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (@var + "STRING") if ARGV.include?("STRING")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.sub!(/^svn\+/, "STRING") if @var =~ /^svn\+http:\/\//
    ohai("STRING");Fi[	@iI"Ì    @@git ||= "STRING"
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.!=(:revision) and host_supports_depth?
  end;Fi[	@i]I"‹    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    ohai("STRING")
    var, var = split_url(@var);Fi[	@iàI"    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["STRING", "STRING", "STRING"].find { |arglist| File.executable?(var) }
  end;Fi[	@i∞I"˚    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["STRING", "STRING"].find { |arglist| File.executable?(var) }
  end;Fi[	@iŒI"˚    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["STRING", "STRING"].find { |arglist| File.executable?(var) }
  end;Fi[	I"+data//homebrew_proj/formula_support.rb;TiqI"Ñ    else
      true
    end
  end
  
  attr_reader :function
  
  def function(arglist)
    case @var
    when :provided_by_osx then;Fi[	@&i3I"ì  def function(arglist)
    @var = var.to_s
    @var = var
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == "STRING")
  end;Fi[	@ÅiI"ﬂ  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0));Fi[	@Åi‚I"È    end
    var = (((("STRING" + @var) + "STRING") + var) + "STRING") if @var
    out(var)
  end
  
  attr_reader :function
  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true;Fi[	@ÅiÏI"È  def function(arglist)
    @var = @var
    var.kind_of?(String) ? (@var = (@var + @var)) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var))
  end;Fi[	@ÅiÚI"“  
  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    @var = @var
    (var >= 0) ? (@var = var) : (@var = (@var + var));Fi[	@7iI"o        def function(arglist)
          @var = with_trailling_slash(var)
          @var = var.blank? ? ("STRING") : (var)
        end
        
        attr_reader :function
        
        def function(arglist)
          var = var ? (with_leading_slash(var)) : (without_leading_slash(var))
          var ? (with_trailling_slash(var)) : (without_trailling_slash(var));Fi[	@«ijI"®      @var.del(@var)
      @var.srem(:queues, @var)
      @var = true
    end
    
    attr_reader :function
    
    def function(arglist)
      @var.dump(var)
    end;Fi[	@ú
i|I"Œ      
      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.after_suite_parts
      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end;Fi[@
@I"@var = var;FI"end;FI" ;Fi$[$[	@ÈiDI"‚        
        class Array < Type
          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            if String.===(var) then;Fi[	@õiI"¬        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	@/	iI"Ë      ACCESS_DENIED_ERROR = 1045
      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin;Fi[	@4	iI"      DEFAULT_ENCODING = (ENV["STRING"] or "STRING")
      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin;Fi[	@ÌiAI"ë        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@¯iI"√      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	@ iäI"‰        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        
        # Returns true if one or more steps failed
        def function(arglist);Fi[	@oirI"°        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@ri0I"®        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@OiI"≈      
      class StepInvoker
        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing;Fi[	@RiI"∂      end
      
      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = WirePacket.new(var, var);Fi[	@ˇiI"|class Caveats
  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = [];Fi[	@°iI"¬    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["STRING"].to_s == "STRING");Fi[	@Bi
I"´    EMPTY_TYPE = "STRING"
    
    SENSIBLE_DEFAULT = "STRING"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      (if blank? then;Fi[	@EiI"Àmodule Paperclip
  class FileCommandContentTypeDetector
    SENSIBLE_DEFAULT = "STRING"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      type_from_file_command;Fi[	@NiI"œmodule Paperclip
  class GeometryParser
    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      if match then;Fi[	@≠iI"∆    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log];Fi[	@mi0I"ã    def self.[](arglist)
      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@ÅiÑI"ú    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@ÅiàI"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@ÅiüI"ô      raise(("STRING" + var)) if var.!=("STRING")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Åi£I"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@ÅißI"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Åi´I"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@ÅiØI"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Åi≥I"Ü  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Åi∑I"ì  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("STRING" + var));Fi[	@ûiI"∫  module Matchers
    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@©i	I"¬  module Matchers
    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@wiVI"∞      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then;Fi[	@õiI"Œ          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["STRING", var, var.location]);Fi[I"	else;FI"# do nothing;FI"end;FI"end;FI" ;Fi#[#[	@‡iQI"«            end
            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      
      protected
      ;Fi[	@~i$I"€            resolve_string_connection(config.to_s)
          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@≥iÎI"„        (method(var).arity == 0) ? (send(var)) : (send(var, var))
      when Proc then
        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      raise(RecordNotFound, "STRING");Fi[	@ûiBI"»          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic);Fi[	@≥i›I"≥        (var.to_sql == to_sql)
      when Array then
        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      var.pp(self.to_a);Ti[	@◊i I"Á            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|;Fi[	@MiüI"    case var
    when Net::HTTP::Delete, Net::HTTP::Get, Net::HTTP::Head, Net::HTTP::Options, Net::HTTP::Put, Net::HTTP::Trace then
      true
    else
      # do nothing
    end
  end
  
  ##
  # Is the request idempotent or is retry_change_requests allowed;Fi[	@ßiKI"Ø            "STRING"
          when /\(yes\/no\)/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@ØiâI"∫            "STRING"
          when /accept \(t\)emporarily/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@≤iII"¨            "STRING"
          when /yes\/no/i then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@∏iKI"˘            raise(Capistrano::Error, "STRING")
          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "STRING")
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@ΩiTI"‘            raise(Capistrano::Error, "STRING")
          when /accept \(t\)emporarily/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@…i’I"'            source.checkout(revision, destination)
          when :export then
            source.export(revision, destination)
          else
            # do nothing
          end
        end
        
        # Returns the name of the file that the source code will be
        # compressed to.;Fi[	@)i%I"”        case var
        when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "STRING";Fi[	I"-data//diaspora_proj/models/invitation.rb;Ti_I"ù      self.identifier
    when "STRING" then
      I18n.t("STRING")
    else
      # do nothing
    end
  end
  
  # @return [String]
  def function(arglist);Fi[	@JikI"ì      self.identifier
    when "STRING" then
      false
    else
      # do nothing
    end
  end
  
  # @note before_save
  def function(arglist);Fi[	I"'data//homebrew_proj/cmd/install.rb;Ti I"ﬂ    case Hardware.cpu_type
    when :ppc, :dunno then
      abort("STRING".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    if HOMEBREW_CELLAR.exist? and HOMEBREW_CELLAR.writable_real?.! then;Fi[	I"%data//homebrew_proj/compilers.rb;Ti;I"¡      MacOS.llvm_build_version.to_i
    when :gcc then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist)
    (@var.to_sym == var.to_sym);Fi[	@iI"∏    when Hash then
      @var = @var.keys.first
      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var.each_with_index do |arglist|;Fi[	@izI"–      raise("STRING")
    when 1 then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var = /https?:\/\/(www\.)?github\.com\/.*\/(zip|tar)ball\//;Fi[	@#iYI"ß    when :bzip2 then
      @var = (@var + "STRING")
      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    @var.nil?.!;Fi[	I"(data//homebrew_proj/requirements.rb;Ti(I"◊      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    when :rbx then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var;Fi[	@i¢I"ã        var = (var + var)
      end
      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #
  	# Calculate closing tags.;Fi[	@i≤I"∞      @var[@var] = @var if (@var[@var] < @var)
      @var = (@var + 1)
      @var.push([])
    else
      # do nothing
    end
  end
  
  #
  	# Convert to accessible file path;Fi[	@içI"¶      SetFontSize((@var + var))
      SetStyle("STRING", true)
      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #
  	# Process closing tags.;Fi[	@i:I"ë        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.;Fi[	@2i‹I"Î        case var[:format]
        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format];Fi[	@2iÔI"˛        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Project) and (var.start_date and var.due_date) then;Fi[	@2iI"        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Version) and (var.due_date and var.start_date) then;Fi[	@wi5I"û          1
        when :twice then
          2
        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0;Fi[@/@0I" ;FI"private;FI" ;Fi![![	@2i7I"õ          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send)
    ;Fi[	@OiI"1          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size;Fi[	@Ri:I"–        end
        save_through_record(var)
        update_counter(1)
        var
      end
      
      private
      
      def function(arglist)
        @var ||= owner.association(through_reflection.name);Fi[	@bi"I"Ù        var = build_record(var)
        yield(var) if block_given?
        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist)
        scope.scope_for_create.stringify_keys.except(klass.primary_key);Fi[	@uiI"ç        chain[(1..-1)].each do |arglist|
          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      
      # Construct attributes for :through pointing to owner and associate. This is used by the
      # methods which create and delete records on the association.;Fi[	I":data//activerecord_proj/active_record/associations.rb;Ti™I"        var = var.association_class.new(self, var)
        association_instance_set(var, var)
      end
      var
    end
    
    private
    
    # Returns the specified association instance if it responds to :loaded?, nil otherwise.
    def function(arglist);Fi[	@wiI";        var[:null] = null unless null.nil?
        var[:default] = default unless default.nil?
        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist)
        base.add_column_options!(var, var.merge(:column => (self)));Fi[	@îi¬I"ú        end
        var
      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key);Fi[	@∞i!I"      # attributes when they are initialized. (e.g. attribute
      # serialization)
      def function(arglist)
        var
      end
      
      private
      
      # Guesses the table name, but does not decorate it with prefix and suffix information.
      def function(arglist);Fi[	@≠i¨I"‚      var.distinct(uniq_value)
      var.from(build_from) if from_value
      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist)
      var = var.reject { |arglist| var.blank? };Fi[	@πiI"â      header(var)
      tables(var)
      trailer(var)
      var
    end
    
    private
    
    def function(arglist)
      @var = var;Fi[	@i#I"’      ((var << read_file("STRING")) << "STRING")
      ((var << "STRING") << "STRING")
      ((var << read_file("STRING")) << "STRING")
      var
    end
    
    private
    
    def function(arglist)
      begin;Fi[	@diSI"‰          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class;Fi[	@ôi^I"∞      def function(arglist)
        var = @var.dup
        (var << "STRING") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin;Fi[	@√iBI"             var = Benchmark.realtime { |arglist| var = super }
          end
          logger.trace("STRING")
          var
        end
        
        private
        
        def function(arglist)
          @var ||= (configuration.logger or Capistrano::Logger.new(:output => (STDOUT)));Fi[	@#iëI"Ì        Cucumber::Term::ANSIColor.coloring = var
        var.rewind
        var = (("STRING" + var.read) + ("STRING" * (var[:indent] - 2)))
        var
      end
      
      private
      
      TO_S_PREFIXES = Hash.new("STRING")
      ;Fi[	@ÌiOI"ñ    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch;Fi[	@iaI"ë        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp;Fi[	@iàI"·        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|;Fi[	@ iìI"ç          end
        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.
    #;Fi[	@:ièI"      def function(arglist)
        var = Criteria.new((delete(:klass) or delete("STRING")))
        each_pair { |arglist| var = var.__send__(var, var) }
        var
      end
      
      private
      
      # Mongoize for the klass, key and value.
      #;Fi[	@ÉiUI"ﬁ        def function(arglist)
          var = yield(document)
          Threaded.clear_options!
          var
        end
        
        private
        
        # In case we need to cast going to the database.
        #;Fi[	I"4data//mongoid_proj/lib/mongoid/serialization.rb;Ti%I"˜        without_autobuild { |arglist| serialize_attribute(var, var, var, var) }
      end
      serialize_relations(var, var) if var[:include]
      var
    end
    
    private
    
    # Get the names of all fields that will be serialized.
    #;Fi[	@iáI"P    var.gsub!(/x%x%/, "STRING")
    clean_html(var) if filter_html
    var.strip!
    var
  end
  
  private
  
  TEXTILE_TAGS = [[128, 8364], [129, 0], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [141, 0], [142, 0], [143, 0], [144, 0], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [157, 0], [158, 0], [159, 376]].collect! do |arglist|
    [var.chr, ((var.zero? and "STRING") or "STRING")];Fi[	@ÑiHI"Ô        end
        var.sort! { |arglist| (var.event_datetime <=> var.event_datetime) }
        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist)
        @@var[var];Fi[	@Hi[I"©          end
          var = [var.strip, var.strip, var.strip]
          var.each { |arglist| smooth_offtags_without_code_highlighting(var) }
          var
        end
        
        private
        
        # Patch for RedCloth.  Fixed in RedCloth r128 but _why hasn't released it yet.
        # <a href="http://code.whytheluckystiff.net/redcloth/changeset/128">http://code.whytheluckystiff.net/redcloth/changeset/128</a>;Fi[	@ÕiI"•          false
        end
      end)
      var
    end
    
    private
    
    def function(arglist)
      var and var[:on] ? ([fetch(var.delete(:on))]) : (self);Fi[	I"?data//state_machine_proj/state_machine/state_collection.rb;TigI"—      var = (var + keys(:name))
      var.uniq!
      var.map! { |arglist| self[var] }
      var
    end
    
    private
    
    # Gets the value for the given attribute on the node
    def function(arglist);Fi[@'I"
super;FI"end;FI"end;FI" ;Fi [ [	@{ijI"P        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist)
          self.class.serialized_attributes.include?(var) ? (var.!=(var)) : (super);Fi[	@{ivI"
        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist)
          super.dup.tap do |arglist|;Fi[	@mi)I"          if create_time_zone_conversion_attribute?(var, columns_hash[var]) then
            var, var = "STRING", (52 + 1)
            generated_attribute_methods.module_eval(var, "STRING", var)
          else
            super
          end
        end
        
        private
        ;Fi[	@Åi=I"∏            :integer
          when /bit/i then
            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var;Fi[	@Åi[I"S            1
          when /^enum\((.+)\)/i then
            $1.split("STRING").map { |arglist| (var.strip.length - 2) }.max
          else
            super
          end
        end
        
        # MySQL misreports NOT NULL column default when none is given.
        # We can't detect this for columns which may have a legitimate '';Fi[	@Åi¯I"          else
            raise(ActiveRecordError, "STRING")
          end
        else
          super
        end
      end
      
      def function(arglist)
        var[:first] ? ((var << "STRING")) : ((var << "STRING") if var[:after]);Fi[	@ÅiSI"’          RecordNotUnique.new(var, var)
        when 1452 then
          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "STRING";Fi[	@åiI"!            (-1.0 / 0.0)
          when / BC$/ then
            super(("STRING" + var.sub(/ BC$/, "STRING")))
          else
            super
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (var.map { |arglist| "STRING" }.join("STRING")) : (var);Fi[	@îiMI"¬            else
              super
            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var;Fi[	@ûiFI"            else
              raise(ActiveRecordError, "STRING")
            end
          else
            super
          end
        end
        
        # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.
        #;Fi[	@§iƒI"B        if var.kind_of?(String) and (var and ((var.type == :binary) and var.class.respond_to?(:string_to_binary))) then
          var = var.class.string_to_binary(var).unpack("STRING")[0]
          "STRING"
        else
          super
        end
      end
      
      def function(arglist)
        @var.class.quote(var);Fi[	@	iI"/      def function(arglist)
        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column);Fi[	@ªiI"€          var = ActiveRecord::LogSubscriber.reset_runtime
          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super;Fi[	@ﬁi6I"é        else
          puts(File.read("STRING"))
        end
      else
        super
      end
    end
    
    desc("STRING", "STRING")
    ;Fi[	I"5data//bundler_proj/bundler/vendor/thor/runner.rb;TiI"z      var, var = Thor::Util.find_class_and_task_by_namespace(var)
      self.class.handle_no_task_error(var, false) if var.nil?
      var.start(["STRING", var].compact, :shell => (self.shell))
    else
      super
    end
  end
  
  # If a task is not found on Thor::Runner, method missing is invoked and
  # Thor::Runner is then responsible for finding the task in all classes.;Fi[	@RitI"          var = File.binread(var).to_s.split("STRING")
          var = var.to_s.split("STRING")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action;Fi[	@UibI"          var = File.binread(var).to_s.split("STRING")
          var = var.to_s.split("STRING")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action;Fi[	@√i,I",        def function(arglist)
          if configuration.respond_to?(var) then
            configuration.send(var, *var, &var)
          else
            super
          end
        end
        
        # A wrapper for Kernel#system that logs the command being executed.
        def function(arglist);Fi[	@?iòI"@    def function(arglist)
      if ["STRING", "STRING"].include?(var) and (position_or_angle.is_a?(Sass::Script::Number) and position_or_angle.numerator_units.include?("STRING")) then
        false
      else
        super
      end
    end
    
    # Output the original webkit gradient syntax
    def function(arglist);Fi[	@OiCI"∂          raise(Errors::MultiparameterAssignmentErrors.new(var), "STRING")
        end
        super(var, var, var)
      else
        super
      end
    end
    
    protected
    ;Fi[	@7i…I"         if var.is_a?(XML::NodeSet) then
          raise("STRING") if (var.size > 1)
          super(var.first)
        else
          super
        end
      end
      
      alias :<< :add_child
      ;Fi[	@@iI"6        def function(arglist)
          if (var.size == 1) and var.first.is_a?(::Time) then
            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "STRING"), &var);Fi[	I"Hdata//state_machine_proj/state_machine/integrations/active_model.rb;Ti±I"2          @var[((var == :around) ? (:before) : (var))].insert(-2, (var = Callback.new(var, var, &var)))
          add_states(var.known_states)
          var
        else
          super
        end
      end
      
      # Configures new states with the built-in humanize scheme
      def function(arglist);Fi[	I"Idata//state_machine_proj/state_machine/integrations/active_record.rb;Ti>I"!      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	I"Hdata//state_machine_proj/state_machine/integrations/mongo_mapper.rb;Ti7I"!      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	I"Cdata//state_machine_proj/state_machine/integrations/mongoid.rb;Ti;I"!      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	I"Ddata//state_machine_proj/state_machine/transition_collection.rb;Ti…I"        if skip_after and success? then
          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    
    # Tracks that before callbacks have now completed
    def function(arglist);Fi[I"@var = var;FI"@var = var;FI"end;FI" ;FI"def function(arglist);Fi[[	@BiI"î      # table_joins is an array of arel joins which might conflict with the aliases we assign here
      def function(arglist)
        @var = Hash.new { |arglist| var[var] = initial_count_for(var) }
        @var = var
        @var = var
      end
      
      def function(arglist)
        var = aliased_name_for(var, var)
        (var == var) ? (Arel::Table.new(var)) : (Arel::Table.new(var).alias(var));Fi[	@eifI"      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?
        @var = (object.class.reflect_on_aggregation(name.to_sym) or object.column_for_attribute(name));Fi[	@ri|I"ˇ        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency
          Thread.new(frequency, pool) do |arglist|;Fi[	@~iI"Á        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config
          when nil then;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/statement_pool.rb;TiI"º      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@îi˘I"Ω    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class
    end;Fi[	@√iI"·      
      def function(arglist)
        var.assert_valid_keys(*Relation::VALUE_METHODS)
        @var = var
        @var = var
      end
      
      def function(arglist)
        Merger.new(relation, other).merge
      end;Fi[	I"@data//cancan_proj/cancan/model_adapters/abstract_adapter.rb;Ti*I"±      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "STRING")
      end;Fi[	@vi>I"Ï          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server)
          end;Fi[	@úiuI"Ã          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "STRING")
          end;Fi[	@ê	iI"      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)))
      end;Fi[	@#iCI"∑        var = var.transpose
        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        dup
      end;Fi[	I"Hdata//cucumber_prok/cucumber/formatter/gherkin_formatter_adapter.rb;TiI"Í  module Formatter
    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.uri(var.file)
        @var.feature(var.gherkin_statement);Fi[	I".data//cucumber_prok/cucumber/rake/task.rb;Ti,I"‡          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("STRING" % @var.join(File::PATH_SEPARATOR))]
        end;Fi[	I"7data//cucumber_prok/cucumber/rb_support/rb_hook.rb;TiI"Ï      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var)
      end;Fi[	I"=data//diaspora_proj/presenters/extreme_post_presenter.rb;TiI"Ãclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = PostPresenter.new(@var, @var)
    var = PostInteractionPresenter.new(@var, @var);Fi[	I"8data//diaspora_proj/presenters/o_embed_presenter.rb;TiI"£  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json
  end;Fi[	@BiI"class PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile))
    if (is_own_profile or person_is_following_current_user) then;Fi[	@EiEI"Yend
class PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    { :likes => (as_api(@var.likes)), :reshares => (PostPresenter.collection_json(@var.reshares, @var)), :comments => (CommentPresenter.as_collection(@var.comments)), :participations => (as_api(@var.participations)) }
  end;Fi[	@[iöI"Ï  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "STRING"
    (var << "STRING") if @var[:because];Fi[	@∏iÇI"ø      
      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end;Fi[	@JiI"ì    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@[
i	I"module Paperclip
  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var)
    end;Fi[	@ti	I"  module Example
    class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var));Fi[	@ûi^I"”    class BePredicate < Be
      def function(arglist)
        @var = parse_expected(var.shift)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var = var
        begin;Fi[	@≤iI"ƒ      
      def function(arglist)
        @var = (var[:__declared_as] or "STRING")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end;Fi[@(@)@I"protected;FI" ;Fi[[	@◊i~I"ﬁ        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var);Fi[	I"Adata//activemodel_proj/active_model/validations/callbacks.rb;TiVI"˝            var[:if].unshift("STRING")
          end
          set_callback(:validation, :after, *(var << var), &var)
        end
      end
      
      protected
      
      # Overwrite run validations to include callbacks.
      def function(arglist);Fi[	@Âi0I"‘              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      
      def function(arglist)
        case var;Fi[	@‡iSI"í          end
        else
          # do nothing
        end
      end
      
      protected
      
      def function(arglist)
        var = [];Fi[	@æi)I"¿            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then;Fi[	@	iÆI"∑        connection.select_value(var, "STRING", var.bind_values))
      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist)
      begin;Fi[	@‘iI"—        end
        self.stored_attributes[var] ||= []
        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist)
      var = initialize_store_attribute(var);Fi[	@¥iI"N          var = options.except(:case_sensitive, :scope, :conditions)
          var[:value] = var
          var.errors.add(var, :taken, var)
        end
      end
      
      protected
      
      # The check for an existing value should be run from a class that
      # isn't abstract. This means working down from the current class;Fi[	I"6data//bundler_proj/bundler/similarity_detector.rb;TiI"ˆ        var[0]
      else
        [var[(0..-2)].join("STRING"), var[-1]].join("STRING") if (var.length > 1)
      end
    end
    
    protected
    
    # http://www.informit.com/articles/article.aspx?p=683059&seqNum=36
    def function(arglist);Fi[	@ˇi*I"¢        default.empty?.!
      else
        default
      end
    end
    
    protected
    
    def function(arglist)
      if required? and default.nil?.! then;Fi[	@RigI"          var = self.class.const_get(var.to_s.upcase) if var.is_a?(Symbol)
          var = var ? (BOLD) : ("STRING")
          "STRING"
        end
      end
      
      protected
      
      # Overwrite show_diff to show diff with colors if Diff::LCS is
      # available.;Fi[	I"4data//bundler_proj/bundler/vendor/thor/shell.rb;TiLI"ö        yield)
      ensure
        shell.padding -= 1
      end
    end
    
    protected
    
    # Allow shell to be shared between invocations.
    #;Fi[	@iEI"Ï            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then;Fi[	@q	i?I"å          var = var.select { |arglist| var.all? { |arglist| (var.options[var] == var) } }
          var = var.reject { |arglist| var.any? { |arglist| (var.options[var] == var) } }
          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist)
        return var unless (ENV["STRING"] or ENV["STRING"]);Fi[	@√i"I"°            var.remote.directory(configuration[:releases_path]).or("STRING")
            var.remote.writable(configuration[:deploy_to]).or("STRING")
            var.remote.writable(configuration[:releases_path]).or("STRING")
          end
        end
        
        protected
        
        # This is to allow helper methods like "run" and "put" to be more
        # easily accessible to strategy implementations.;Fi[	@iI"Ø          ::Compass::Exec::Helpers.report_error(var, (@var or {}))
        end
        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin;Fi[	@i]I"§      else
        var
      end
    end
  end
  
  protected
  
  def function(arglist)
    raise(ArgumentError.new("STRING")) unless var.is_a?(Sass::Script::List);Fi[	@1i`I"ª          else
            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts);Fi[	@ki&I"€          attribute.any? { |arglist| var.===(var) }
        else
          var.===(attribute)
        end
      end
      
      protected
      
      # Convenience method for getting the first value in a hash.
      #;Fi[	@OiEI"≠        super(var, var, var)
      else
        super
      end
    end
    
    protected
    
    def function(arglist)
      return nil if var.all? { |arglist| var.nil? };Fi[	@tiI"ã      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist)
        var =~ /(^#{example_group_regex}STRING#{example_regexp}STRING#{example_group_regex}STRING#{example_group_with_before_all_regexp}STRING#{example_regexp}STRING/;Fi[	I"5data//state_machine_proj/state_machine/branch.rb;TiçI"*          (var << var.add_edge(var, (var ? (var) : (var)), :label => (var.to_s)))
        end
        var
      end
    end
    
    protected
    
    # Builds a matcher strategy to use for the given options.  If neither a
    # whitelist nor a blacklist option is specified, then an AllMatcher is;Fi[	@ÌiEI"É        results[actions.first]
      else
        success?
      end
    end
    
    protected
    
    attr_reader(:results)
    ;Fi[	@ i-I"û          puts("STRING")
          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file]);Fi[	@™
i6I"          parse_as_string
        else
          parse_time
        end
      end
      
      protected
      
      def function(arglist)
        var = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@iI"±          "STRING"
        else
          "STRING"
        end
      end
      
      protected
      
      def function(arglist)
        return unless @var.has_key?(:standard);Fi[@(@@∑
I"	true;FI"end;Fi[[	@ËiI"¨      var = super
      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	I"Wdata//activerecord_proj/active_record/associations/builder/singular_association.rb;Ti	I"Ì  class SingularAssociation < Association
    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@˙iI"º      
      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@˙ioI"Å      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end
    end
    ;Fi[	@ÅiâI"      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.;Fi[	@ÅiíI"
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax;Fi[	@Åi$I"‚        super
        @var = BindSubstitution.new(self)
        configure_connection
      end
      
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================;Fi[	@§iÜI"û      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@§i™I"ó      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:;Fi[	@ÒiI"    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@vi)I"±        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist);Fi[	@˙
i&I"π      
      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@˙
iãI"ƒ      
      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@ì	iI"è    
    def function(arglist)
      (var == "STRING")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@?i@I"ú    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@#iyI"Ø      class SurplusCell < Cell
        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end;Fi[	@iiI"¶      def function(arglist)
        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@`i$I"ö      
      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	I"3data//devise_proj/devise/models/validatable.rb;Ti'I"˝      # or confirmation are being set somewhere.
      def function(arglist)
        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@°i"I"ı        if var.respond_to?(:extend_remember_period=) then
          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	I"3data//diaspora_proj/models/account_deletion.rb;Ti+I"Ü  
  def function(arglist)
    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	I"(data//diaspora_proj/models/photo.rb;Ti~I"Œ  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  
  scope(:on_statuses, lambda { |arglist| where(:status_message_guid => (var)) });Fi[	@ÏiI"|  
  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist);Fi[	@ziI"    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@ziI"z    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end;Fi[	@ÎiI"√      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist);Fi[@(@)@*@€I"private;Fi[[	@(i8I"            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private
      
      # The reason that the save param for replace is false, if for create (not just build),;Fi[	@ri0I"$          var = (Time.now - @var)
          connections.dup.each do |arglist|
            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      
      # Acquire a connection by one of 1) immediately removing one;Fi[	@åitI"∑              end
            else
              var
            end
          end
        end
        
        private
        
        HstorePair = (var = /"[^"\\]*(?:\\.[^"\\]*)*"/;Fi[	@•iLI"Ø          var = var.where(table[primary_key].gt(var)).to_a
        else
          raise("STRING")
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@`i.I"∑          @var.compressor.compress_with do |arglist|
            run("STRING")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##;Fi[	@ iwI"¬            end
          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist);Fi[	@`i0I"}        end
      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ciOI"Ñ            exit(1)
          end
          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@öiçI"        FileUtils.mkdir_p(@var.dotcucumber) if File.directory?(@var.dotcucumber).!
        File.open(File.join(@var.dotcucumber, "STRING"), "STRING") do |arglist|
          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    
    #:nodoc;Fi[	@ªi§I"ß      else
        flash[:error] = I18n.t("STRING", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@¡i8I"Å        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ÕiAI"ı        var.html { |arglist| redirect_to(:back) }
        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@”i+I"ÿ        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@·iOI"’        aspects.detect { |arglist| (var.id == var.id) }
      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ìiI"÷      if var.children.empty? and var.skip_clean?(var).! then
        puts("STRING") if ARGV.verbose?
        var.rmdir
      end
    end
  end
  
  private
  
  # Set permissions for executables and non-executables;Fi[	@ivI"ô        var.children.each { |arglist| puts("STRING") }
      else
        raise("STRING")
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@iI"ñ        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ivI"À      if FileTest.directory?(var) and (File.basename(var) == "STRING") then
        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@¥iI"™            end
          end
        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/;Fi[	@)i/I"ë          (var.pages << var)
        else
          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@ﬂi&I"&        var[:name] = truncate_post_name(var[:name]) if (var[:name].size > 255)
        File.open("STRING", "STRING") do |arglist|
          var.puts(((var[:header].to_yaml + "STRING") + var[:content]))
        end
      end
    end
    
    private
    
    def self.truncate_post_name(arglist);Fi[	@ni6I"˘            Matchers::And.new(var, var)
          else
            Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      
      # Extract the attribute from the key, being smarter about dot notation.;Fi[	@˜i!I"Ô            end
          else
            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      
      # Returns true if the relation is blank or the foreign key is blank.;Fi[	@˙i,I"À            validate_embedded(var, var, var)
          else
            validate_root(var, var, var)
          end
        end
      end
      
      private
      
      # Add the error to the document.;Fi[	@èiRI"∂          end
        else
          Dir.glob("STRING").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    
    def self.scan_themes(arglist);Fi[	@ iTI"•          define_method(var) do |arglist|
            var.call(*var)
            self
          end
        end
      end
      
      private
      
      # :nodoc:;Fi[@(@í@ìI"end;FI"end;Fi[[	@SilI"ˇ          var.includes!((var[:includes] or var[:includes]))
          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@oi2I"Õ            end
            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@~iHI"‚          if var.query then
            var = Hash[var.query.split("STRING").map { |arglist| var.split("STRING") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	@§iI"˙        def function(arglist)
          if var.encoding.!=(Encoding::ASCII_8BIT) then
            var = var.force_encoding(Encoding::ASCII_8BIT)
          end
          var
        end
      end
    end
    
    class SQLite3Adapter < AbstractAdapter;Fi[	@/	i}I"ˇ        var.concat(["STRING", configuration["STRING"]]) if configuration["STRING"]
        configuration.slice("STRING", "STRING", "STRING").each do |arglist|
          var.concat(["STRING", var]) if var
        end
        var
      end
    end
  end
end;Fi[	@ ibI"v              (var << "STRING")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@O	iRI"ª          var = var.include?(var) ? (var) : (nil)
          var = var.map(&:inspect).join("STRING")
          say("STRING") unless var)
        end
        var
      end
    end
  end
end;Fi[	@ i∞I"¯        var = []
        var.each do |arglist|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end
ActiveRecord::Base.class_eval { |arglist| include(CanCan::ModelAdditions) };Fi[	@Ri"I"È        end
        var.each do |arglist|
          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end
DataMapper::Model.append_extensions(CanCan::ModelAdditions::ClassMethods);Fi[	@~i-I"            else
              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	@˘i I"'              (var << { :raw => (var.send("STRING") rescue nil), :value => (var.send("STRING") rescue nil), :default => (var.send("STRING") rescue nil), :resolved => (var.send(var)) })
            end
            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	@ä	iÅI"Ö            (var << "STRING")
          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	@Pi|I"è        var.each do |arglist|
          var ||= "STRING"
          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	I"-data//devise_proj/devise/test_helpers.rb;TikI"Ö        @var.status = var.first
        @var.headers = var.second
        @var.body = var.third
      end
      var
    end
  end
end;Fi[	@ﬂiúI"±        FileUtils.mkdir_p("STRING")
        File.open(var, "STRING") { |arglist| var.write(open(var).read) }
        var = ("STRING" + var)
      end
      var
    end
  end
end;Fi[	@iI"™              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end;Fi[	@iuI"è          end
        else
          raise(ScanError, (("STRING" + state.to_s) + "STRING"))
        end
        var
      end
    end
  end
end;Fi[	@NiI"l        @var = var[2]
        @var = var[3]
        @var = var[4]
      end
      var
    end
  end
end;Fi[	@i&I"ì                [yield(var), var.id]
              end
            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	@|
i¶I"            var = var[var]
            if var.is_a?(Symbol) then
              var = resolve(var, var, var, var.merge(:scope => (nil)))
            end
            var
          end
        end
      end
      
      include(Implementation);Fi[	@:iI"¨          if jsonp.present? then
            var = "STRING"
            response.content_type = "STRING"
          end
          var
        end
      end
    end
  end
end;Fi[	@HioI"               var = @var[$1.to_i]
              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("STRING" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end;Fi[	@∫i"I"°          else
            (var < (var.length - 1)) ? ((var << "STRING")) : ((var << "STRING"))
          end
        end
        var
      end
    end
  end
end;Fi[	@ÿi"I"          if ((var == :state) or ((var == :event) and var)) and var.send("STRING").! then
            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[@/@0@1I" ;FI"def function(arglist);Fi[[	@ritI"R        records.group_by do |arglist|
          var = var.class.reflections[var]
          raise(ActiveRecord::ConfigurationError, "STRING") unless var
          var
        end
      end
      
      def function(arglist)
        if (var.macro == :belongs_to) and var.options[:polymorphic] then
          var = var.send(var.foreign_type);Fi[	@{icI"^            serialized_attributes.each do |arglist|
              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized);Fi[	@Âi*I"ı        (var = send(var, var)
        var.duplicable? ? (var.clone) : (var))
      rescue TypeError, NoMethodError
        var
      end
    end
    
    def function(arglist)
      arel_attributes_with_values(attributes_for_create(var))
    end;Fi[	@~i/I"›          end
          var
        else
          var
        end
      end
      
      def function(arglist)
        (var << "STRING") if options_include_default?(var)
        (var << "STRING") if (var[:null] == false);Fi[	@≠iﬁI"µ        var ||= "STRING"
        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist)
      var = var.group_by do |arglist|
        case var;Fi[	@&i¿I"'        var = Gem::SourceIndex.new
        var.spec_dirs = *var
        var.add_specs(*var)
        var
      end
    end
    
    def function(arglist)
      Gem::SourceIndex.send(:alias_method, :old_initialize, :initialize)
      Gem::SourceIndex.send(:define_method, :initialize) do |arglist|;Fi[	@OiAI"ë        @var = false
        super
      else
        var
      end
    end
    
    def function(arglist)
      @var = var.dup
      @var = true;Fi[	@q	iaI"!        var = build_list(var)
        var.map do |arglist|
          var = String.===(var) ? (var.strip.to_sym) : (var)
          var
        end
      end
      
      def function(arglist)
        Array(var).map { |arglist| var.respond_to?(:call) ? (var.call) : (var) }.flatten
      end;Fi[	@7i[I"‰            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index("STRING") == 1))
      end;Fi[	@i…I"Á    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then
      missing_sprite!(var);Fi[	@PioI"≈      def function(arglist)
        var.inject({}) do |arglist|
          var[delimited(var)] = var
          var
        end
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@Xi∂I"ﬁ      
      class LogFormatter < ::Logger::Formatter
        def function(arglist)
          var
        end
      end
      
      def function(arglist)
        @var[:env_vars].each { |arglist| ENV[var] = var }
      end;Fi[	@xi)I"        var.step_definitions.inject({}) do |arglist|
          var[var.file] ||= []
          (var[var.file] << [var.file_colon_line, var.regexp_source])
          var
        end
      end
      
      def function(arglist)
        (var.map { |arglist| var.size }.max + 1)
      end;Fi[	@ˇiOI"…      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist)
      var[:action] ||= :unauthenticated
      var = var["STRING"];Fi[	@æiêI"V      end
      Tempfile.send(:define_method, "STRING") { |arglist| return var }
      Tempfile.send(:define_method, "STRING") { |arglist| return var }
      var
    end
  end
  
  def function(arglist)
    if (params[:photo][:aspect_ids] == "STRING") then
      params[:photo][:aspect_ids] = current_user.aspects.collect { |arglist| var.id };Fi[	@Ái∞I"—      var = profile.first_name.to_s.split(/\s/)
      var = var[(0...-1)].join("STRING")
      var = var[0] if var.blank?
      var
    end
  end
  
  def function(arglist)
    (self.id == var.author_id)
  end;Fi[	@&iI"¥    when /\d+/ then
      var.to_i
    else
      var
    end
  end
  
  def function(arglist)
    return unless var.is_a?(VersionElement)
    return -1 if string? and var.numeric?;Fi[	@.i'I"˜      def function(arglist)
        send(var).inject({}) do |arglist|
          var[var] = var
          var
        end
      end
      
      def function(arglist)
        var = var.new(klass.aliased_fields, klass.fields)
        var.merge!(var);Fi[	@[
i)I"‹        var = var.match(/\?.+=/) ? ("STRING") : ("STRING")
        "STRING"
      else
        var
      end
    end
    
    def function(arglist)
      @var.respond_to?(:updated_at) and @var.updated_at.present?
    end;Fi[	@ei7I"À        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist)
        var = I18n.translate(:"number.human.storage_units.format", :locale => (options[:locale]), :raise => (true))
        var = I18n.translate(:"number.human.storage_units.units.byte", :locale => (options[:locale]), :count => (var.to_i), :raise => (true));Fi[	@˘iRI"+              var ||= custom_values.build(:customized => (self), :custom_field => (var), :value => (nil))
              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist)
          custom_field_values.select(&:visible?)
        end;Fi[	@|iI"µ      
      def function(arglist)
        var = var.dup
        var
      end
    end
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!(var);Fi[	@i®I"Ä      else
        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist)
    (@var << var)
    "STRING";Fi[	I"5data//rspec_proj/spec/example/example_methods.rb;TiaI"+      def function(arglist)
        instance_variables.inject({}) do |arglist|
          var[var] = instance_variable_get(var)
          var
        end
      end
      
      def function(arglist)
        var.each do |arglist|
          unless ["STRING", "STRING", "STRING"].include?(var.to_s) then;Fi[@'I""STRING";FI"end;FI"end;FI" ;Fi[[	@«
i-I"          "STRING"
        when Class then
          "STRING"
        else
          "STRING"
        end
      end
      
      # Cast a +value+ to a type that the database understands. For example,
      # SQLite does not understand dates, so this method will convert a Date;Fi[	@˛iI"ﬂ    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "STRING"
      else
        "STRING"
      end
    end
    
    def function(arglist)
      (identifier == var.identifier);Fi[	@iI"2    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "STRING"
      else
        "STRING"
      end
    end
    
    # Because Rubyforge cannot be trusted to provide valid specifications
    # once the remote gem is downloaded, the backend specification will;Fi[	@≤idI"‹            nil
          when false then
            "STRING"
          else
            "STRING"
          end
        end
        
        # honor Cap 2.1+'s :scm_prefer_prompt if present
        def function(arglist);Fi[	@˙
i|I"Ò      def function(arglist)
        if var = top_level.fonts_dir_without_default then
          var
        else
          "STRING"
        end
      end
      
      def function(arglist)
        http_root_relative(top_level.http_fonts_dir);Fi[	@€iCI"       def function(arglist)
        if var.respond_to?(:serialize_to_config) then
          (var.serialize_to_config(var) + "STRING")
        else
          "STRING"
        end
      end
      
      def function(arglist)
        $stderr.puts("STRING") if (http_images_path == :relative);Fi[	@i8I"    def function(arglist)
      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("STRING") : ("STRING")
      else
        "STRING"
      end
    end
    
    def function(arglist)
      print(var);Fi[	@)iI"÷            var = []
            var.join("STRING")
            var[(var..var)].join("STRING")
          else
            "STRING"
          end
        end
        
        def function(arglist)
          var = [];Fi[	@!i	I"˚  def function(arglist)
    if AppConfig.settings.pod_name.present? then
      AppConfig.settings.pod_name
    else
      "STRING"
    end
  end
  
  def function(arglist)
    AppConfig.version.number.present? ? (AppConfig.version.number) : ("STRING");Fi[	I"%data//jekyll_proj/jekyll/page.rb;TiCI"Ú    def function(arglist)
      if (self.site.permalink_style == :pretty) and (index?.! and html?) then
        "STRING"
      else
        "STRING"
      end
    end
    
    # The generated relative url of this page. e.g. /about.html.
    #;Fi[	@rihI"Ï    def function(arglist)
      if options[:request_path].is_a?(String) then
        options[:request_path]
      else
        "STRING"
      end
    end
    
    def function(arglist)
      if options[:callback_path].is_a?(String) then;Fi[	@`iãI"Ò      def function(arglist)
        if @var[:fog_directory].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        case var;Fi[	@2iI"®          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      
      def function(arglist)
        case var[:format];Fi[	@2i4I"–          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do;Fi[	@2ioI"¡          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      
      if Object.const_defined?(:Magick) then
        # Generates a gantt image;Fi[	@∫iI"©          "STRING"
        when 2 then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        var = "STRING";Fi[	@¨iMI"ø          @var
        when Regexp then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING");Fi[	@áiâI"›      def function(arglist)
        if rcov then
          (ENV["STRING"] or (rcov_opts.join("STRING") or "STRING"))
        else
          "STRING"
        end
      end
      
      # :nodoc:
      def function(arglist);Fi[	@≥i0I"÷            var = []
            var.join("STRING")
            var[(var..var)].join("STRING")
          else
            "STRING"
          end
        end
        
        def function(arglist)
          var = [];Fi[	@ú
i–I"      def function(arglist)
        if ([/mswin/, /java/].detect { |arglist| var.=~(RUBY_PLATFORM) } or (Spec::Ruby.version.to_f == 1.9)) then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        @var ||= [["STRING", @var]];Fi[	@ÔirI"Q        def function(arglist)
          @var ||= if machine.states.any? then
            machine.states.map { |arglist| var.name }.compact.first.class.to_s
          else
            "STRING"
          end
        end
        
        # Gets the class type being used to define events.  Default is "Symbol".
        def function(arglist);Fi[	@iI"û          redirect_from_hash
        when NilClass then
          "STRING"
        else
          "STRING"
        end
      end
      
      protected
      ;Fi[	@i6I"®          "STRING"
        when stdout then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        "STRING";Fi[@.@bI"@var = var;FI"end;FI" ;Fi[[	@ri{I"ﬂ      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency;Fi[	@wiI"Ë    end
    
    class Table
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.;Fi[	@~iI"‰      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config;Fi[	@Èi5I"´          # +delim+ corresponds to the `typdelim` column in the pg_types
          # table.  +subtype+ is derived from the `typelem` column in the
          # pg_types table.
          def function(arglist)
            @var = var
            @var = var
          end
          
          # FIXME: this should probably split on +delim+ and use +subtype+
          # to cast the values.  Unfortunately, the current Rails behavior;Fi[	@ˇi
I"     class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@îi¯I"∫    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class;Fi[	@Èi	I"Õ  class Splitter
    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##
    # This is called as part of the procedure used to build the final;Fi[	@i)I"œ        raise(NotImplemented, "STRING")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "STRING");Fi[	@úitI"È            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "STRING");Fi[	@ê	iI"(        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)));Fi[	@#i÷I"      #   table.hashes.keys
      #   # => ['phone number', 'ADDRESS']
      #
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Returns a new Table where the headers are redefined. See #map_headers!
      def function(arglist);Fi[	@i
I"Œmodule Cucumber
  module Formatter
    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.uri(var.file);Fi[	@iI"ôclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = PostPresenter.new(@var, @var);Fi[	@iI"†  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json;Fi[	@BiI"¡class PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile));Fi[	@Ei	I"’class PostPresenter
  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def self.collection_json(arglist)
    var.map { |arglist| PostPresenter.new(var, var) };Fi[	@EiDI"Y  end
end
class PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    { :likes => (as_api(@var.likes)), :reshares => (PostPresenter.collection_json(@var.reshares, @var)), :comments => (CommentPresenter.as_collection(@var.comments)), :participations => (as_api(@var.participations)) };Fi[	I"-data//nokogiri_proj/nokogiri/css/node.rb;TiI"˛      # Get the type of this node
      # Get the value of this node
      # Create a new Node with +type+ and +value+
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Accept +visitor+
      def function(arglist);Fi[	@∏iÅI"Ω      end
      
      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var;Fi[	@[
iI"require("uri")
module Paperclip
  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var);Fi[	@tiI"¬module Spec
  module Example
    class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        var.any? do |arglist|;Fi[	@ºiI"  module Spec
    module Runner
      class HeckleRunner
        def function(arglist)
          @var = var
          @var = var
        end
        
        # Runs all the example groups held by +rspec_options+ once for each of the
        # methods in the matched classes.;Fi[	I"<data//state_machine_proj/state_machine/helper_module.rb;TiI"Œmodule StateMachine
  class HelperModule < Module
    def function(arglist)
      @var = var
      @var = var
    end
    
    # Provides a human-readable description of the module
    def function(arglist);Fi[@
@I"	true;FI"end;FI" ;Fi[[	@ËiI"Œ      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|;Fi[	@ti
I"œ    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super;Fi[	@˙iI"√      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false;Fi[	@ÅiäI"ÿ      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist);Fi[	@ÅiìI"ˇ      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax
      # but at the moment (5.5) it doesn't yet implement them;Fi[	@Åi%I"        @var = BindSubstitution.new(self)
        configure_connection
      end
      
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================
      def function(arglist);Fi[	@§iáI"§      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@§i´I"û      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:
      def function(arglist);Fi[	@ÒiI"Ü    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false;Fi[	@vi*I"¬        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect;Fi[	@˙
i'I"¸      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then;Fi[	@˙
iåI"À      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss;Fi[	@ì	iI"õ    def function(arglist)
      (var == "STRING")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value;Fi[	@?iAI"2    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "STRING") and var.denominator_units.empty?));Fi[	@iiI"º        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/;Fi[	@`i%I"•      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive;Fi[	@ói(I"      def function(arglist)
        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length);Fi[	@°i#I"˘          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "STRING");Fi[	@üiI"œ  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  
  scope(:on_statuses, lambda { |arglist| where(:status_message_guid => (var)) })
end;Fi[	@Ïi I"ö  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("STRING");Fi[	I"4data//jekyll_proj/jekyll/converters/identity.rb;Ti
I"Ñ    safe(true)
    
    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var;Fi[	@ziI"ç    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing;Fi[	@ÎiI"º        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "STRING";Fi[@¬I"	else;FI""STRING";FI"end;FI"end;Fi[[	@«
i,I"‡        when Symbol then
          "STRING"
        when Class then
          "STRING"
        else
          "STRING"
        end
      end
      
      # Cast a +value+ to a type that the database understands. For example,;Fi[	@ûi)I"Â            when :tablespace then
              "STRING"
            when :connection_limit then
              "STRING"
            else
              "STRING"
            end
          end
          execute("STRING")
        end;Fi[	@Ei:I"Á          else
            if table_exists? then
              var = (columns.map { |arglist| "STRING" } * "STRING")
              "STRING"
            else
              "STRING"
            end
          end
        end
      end;Fi[	@òi7I"¥        "STRING"
      when var = self[:updated_at] then
        var = var.utc.to_s(cache_timestamp_format)
        "STRING"
      else
        "STRING"
      end
    end
  end
end;Fi[	@˛iI"ø    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "STRING"
      else
        "STRING"
      end
    end
    
    def function(arglist);Fi[	@iI"Ô    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "STRING"
      else
        "STRING"
      end
    end
    
    # Because Rubyforge cannot be trusted to provide valid specifications;Fi[	@≤icI"÷          when nil then
            nil
          when false then
            "STRING"
          else
            "STRING"
          end
        end
        
        # honor Cap 2.1+'s :scm_prefer_prompt if present;Fi[	@ÍiI"∆      
      def function(arglist)
        if (top_level.preferred_syntax == :scss) and top_level.sass_dir then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end;Fi[	@çi I"‹              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              else
                "STRING"
              end
            end
          end
        else;Fi[	@çiI"«            when "STRING" then
              "STRING"
            when "STRING" then
              "STRING"
            else
              "STRING"
            end
          end
        end
      end;Fi[	@)
iqI"é        when 40 then
          "STRING"
        when 41 then
          "STRING"
        else
          "STRING"
        end
      end
  end
  ;Fi[	@∆i|I"Ä      when 1 then
        var[0].to_s
      when 2 then
        "STRING"
      else
        "STRING"
      end
    end
  end
end;Fi[	@ciBI"    # Returns the template String.
    def function(arglist)
      if (self.site.permalink_style == :pretty) and (index?.! and html?) then
        "STRING"
      else
        "STRING"
      end
    end
    
    # The generated relative url of this page. e.g. /about.html.;Fi[	@#iRI"ö      def function(arglist)
        case var
        when Hash then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end;Fi[	@`iäI"Á      
      def function(arglist)
        if @var[:fog_directory].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist);Fi[	@iQI"v            end
          end
        end
        "STRING"
      else
        "STRING"
      end
    end
  end
  ;Fi[	@∫iI"¶        when 1 then
          "STRING"
        when 2 then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist);Fi[	@¨iLI"©        when nil then
          @var
        when Regexp then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist);Fi[	@ú
iœI"      
      def function(arglist)
        if ([/mswin/, /java/].detect { |arglist| var.=~(RUBY_PLATFORM) } or (Spec::Ruby.version.to_f == 1.9)) then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist);Fi[	@«i3I"ÿ        "STRING"
      else
        if ((defined? Gem and var.filename.include?(Gem.dir)) or var.filename =~ /\/bin\/(\w+)$/) then
          "STRING"
        else
          "STRING"
        end
      end
    end
    ;Fi[	@iI"°        when /\.gif$/i then
          "STRING"
        when /\.png$/i then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end;Fi[	@iI"Æ        when Hash then
          redirect_from_hash
        when NilClass then
          "STRING"
        else
          "STRING"
        end
      end
      
      protected;Fi[	@i5I"æ        when (stdout == "STRING") then
          "STRING"
        when stdout then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist);Fi[I"# do nothing;FI"end;FI"end;FI"end;FI"end;Fi[[	@riáI"}        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	@ëiPI"4              when /^-?\D+[\d.]+,\d{2}$/ then
                var.gsub!(/[^-\d,]/, "STRING").sub!(/,/, "STRING")
              else
                # do nothing
              end
            end
          end
        end
        
        # Queries the database and returns the results in an Array-like object;Fi[	@ƒi…I"ì      when :update then
        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	@ÈicI"´          begin
            var.mkdir(var.join("STRING"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@˙iUI"µ          begin
            var.mkdir!(var.join("STRING"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"6data//bundler_proj/bundler/vendor/thor/actions.rb;TiI"¨        [:force, :skip, "STRING", "STRING"].each { |arglist| var.delete(var) }
        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	@ˇiHI"h      when :array then
        "STRING"
      else
        # do nothing
      end
    end
  end
end;Fi[	@ÅiI"è          when "STRING" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@x	iæI"g      when :scp then
        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	@,i=I"†            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"@data//diaspora_proj/controllers/conversations_controller.rb;TiTI"Ç      render(:layout => (true))
    else
      if render(:layout => (false)) then
        # do nothing
      end
    end
  end
end;Fi[	I"$data//homebrew_proj/cmd/edit.rb;Ti,I"p      when "STRING", "STRING" then
        true
      else
        # do nothing
      end
    end
  end
end;Fi[	@WitI"y      when "STRING" then
        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	I"?data//nokogiri_proj/nokogiri/xml/processing_instruction.rb;Ti	I"Ä  module XML
    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@∆imI"¬        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@åiMI"≈              (@var << "STRING")
              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"-data//rescue_proj/resque/failure/base.rb;Ti8I"e      end
      
      def self.remove(arglist)
        # do nothing
      end
    end
  end
end;Fi[	I",data//rescue_proj/resque/multi_queue.rb;TiMI"f        end
      else
        Kernel.sleep(var)
        # do nothing
      end
    end
  end
end;Fi[	@òiêI"‘        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@ûiI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@°iI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@™iI"z        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@˝i*I"è              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[@.@/@0@UI" ;Fi[[	@îiÊI"¨      end
    end
    
    def function(arglist)
      "STRING"
    end
  end
  
  Fixtures = ActiveSupport::Deprecation::DeprecatedConstantProxy.new("STRING", "STRING")
  ;Fi[	@viaI"œ          Evaluator.new(configuration, condition, var).result
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist)
        @var = var;Fi[	@:i4I"√        var.to_a[(1..-1)].map { |arglist| JsArg.new(var) } if var
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    class JsHook
      def function(arglist);Fi[	@âi	I"ˆ  module RbSupport
    class RbTransform
      class MissingProc < StandardError
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist)
        raise(MissingProc) if (var.nil? or (var.arity < 1));Fi[	@iI"ó        @var = var
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    def self.config(arglist)
      class << var;Fi[	@ihI"         view_directory(:markerb, target_path)
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    class ViewsGenerator < Rails::Generators::Base
      desc("STRING");Fi[	@êi∏I"û      include(Base)
      
      # @see Base#render
      def function(arglist)
        "STRING"
      end
    end
    
    module Escaped
      include(Base);Fi[	I"$data//haml_proj/haml/helpers.rb;TiI"Ø      end
      
      # @return [String] A human-readable string representation
      def function(arglist)
        "STRING"
      end
    end
    
    self.extend(self)
    ;Fi[	I",data//rspec_proj/spec/example/errors.rb;TiI"€    
    class NoDescriptionError < ArgumentError
      class << self
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist)
        super(self.class.message(var, var));Fi[	@ûiVI"⁄        raise((var << ([:===, :==].include?(@var) ? ("STRING") : ("STRING"))))
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    class BePredicate < Be
      def function(arglist);Fi[	@ûi£I"ç        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should be_true;Fi[	@Ö
iPI"£        self
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should change(receiver, message, &block);Fi[	@¶iUI"™        self
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should have(number).named_collection__or__sugar;Fi[	@·iI"ê        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should satisfy {};Fi[	@Êi&I"$        (@var or @var.nil? ? (explanation) : ("STRING"))
      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # simple_matcher makes it easy for you to create your own custom matchers
    # in just a few lines of code when you don't need all the power of a;Fi[	@Îi	I"À  module Mocks
    module ArgumentMatchers
      class AnyArgsMatcher
        def function(arglist)
          "STRING"
        end
      end
      
      class NoArgsMatcher
        def function(arglist);Fi[	@ÎiI"∞      end
      
      class NoArgsMatcher
        def function(arglist)
          "STRING"
        end
      end
      
      class AnyArgMatcher
        def function(arglist);Fi[	@ÎiI"©          true
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      class RegexpMatcher
        def function(arglist);Fi[	@ÎiGI"≤          end
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      class HashNotIncludingMatcher
        def function(arglist);Fi[	@Îi\I"™          end
        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      class DuckTypeMatcher
        def function(arglist);Fi[	@€i7I"—        def function(arglist)
          "STRING"
        end
        def function(arglist)
          "STRING"
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist);Fi[	@ìi0I"¯    end
    
    # A human-readable description of this matcher.  Always "all".
    def function(arglist)
      "STRING"
    end
  end
  
  class WhitelistMatcher < Matcher
    # Checks whether the given value exists within the whitelist configured;Fi[	@ìi\I"≤    end
    
    # A human-readable description of this matcher
    def function(arglist)
      "STRING"
    end
  end
  
  class LoopbackMatcher < Matcher
    include(Singleton);Fi[@.I"	true;FI"end;FI" ;FI"def function(arglist);Fi[[	@ËiI"·      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|
        ActiveSupport::Deprecation.warn("STRING") if options.include?(var);Fi[	@tiI"·      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super
      define_constructors if constructable?;Fi[	@˙iI"±        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end;Fi[	@ÅiáI"∆      end
      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@ÅiêI"∆      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@§iÑI"ì      end
      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@§içI"ú      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var.!=(false)
      end;Fi[	@§i®I"í      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@ÒiI"y      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end;Fi[	@vi+I"∞          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect
        end;Fi[	@˙
i(I"        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var);Fi[	@˙
içI"π        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss
      end;Fi[	@ì	iI"â      (var == "STRING")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value
    end;Fi[	@?iBI"       GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "STRING") and var.denominator_units.empty?))
    end;Fi[	@iiI"º        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/
        print(var);Fi[	@`i&I"ì        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive
      end;Fi[	@°i$I"∫        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "STRING")
      end;Fi[	I"9data//diaspora_proj/models/activity_streams/photo.rb;TiI"  # A hack used in the stream_element partial to display cubbi.es posts correctly.
  # A better solution is needed.
  # @return [Boolean] true
  def function(arglist)
    true
  end
  
  def function(arglist)
    I18n.t("STRING", :name => (author.name))
  end;Fi[	@Ïi!I"“    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("STRING")
    if (self.parent_author_signature.nil?.! or self.parent.author.remote?) then;Fi[	I",data//haml_proj/haml/template/plugin.rb;TiI"c    # do. To avoid messy logic figuring this out, we just inherit from whatever
    # the ERB handler does.
    # In Rails 3.1+, we don't need to include Compilable.
    def function(arglist)
      true
    end
    
    def function(arglist)
      var = Haml::Template.options.dup
      if (ActionPack::VERSION::MAJOR >= 4) and var.respond_to?(:type) then;Fi[	@‚iI"}    
    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end;Fi[	@ziI"{      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@ÎiI"™          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "STRING"
        end;Fi[@(@@∑
I"@var = var;FI"end;Fi[[	@õiI"“      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@Ìi@I"       if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private;Fi[	@¯i
I"‘    def self.inject(arglist)
      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@ iâI"œ        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        
        # Returns true if one or more steps failed;Fi[	@oiqI"°        @var.flush
        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@ri/I"±      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@ZiI"÷      module ClassMethods
        def function(arglist)
          defined? @var ? (@var) : (Devise.scoped_views)
        end
        
        def function(arglist)
          @var = var
        end
      end
    end;Fi[	I"&data//homebrew_proj/exceptions.rb;Ti(I"™  
  def function(arglist)
    name =~ /(\w+)\/(\w+)\/([^\/]+)/ ? ("STRING".undent) : ("STRING")
  end
  
  def function(arglist)
    @var = var
  end
end
module Homebrew;Fi[	@°iI"í    
    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@≠iI"ø    #:nodoc:
    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@mi/I"ã    
    def self.[](arglist)
      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function;Fi[	@ÅiÉI"•  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@ÅiáI"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@ÅiûI"ì    else
      raise(("STRING" + var)) if var.!=("STRING")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Åi¢I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Åi¶I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Åi™I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@ÅiÆI"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Åi≤I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Åi∂I"  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@wiUI"ø      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@õiI"≥            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist);Fi[I"def self.included(arglist);FI"var.extend(ClassMethods);FI"end;FI" ;FI"module ClassMethods;Fi[[	@⁄iI"‰module Backup
  module Configuration
    module Helpers
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        ##
        # Returns or yields the Configuration::Store;Fi[	@.iI"0  module Actions
    attr_accessor(:behavior)
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Hold source paths for one Thor instance. source_paths_for_search is the
      # method responsible to gather source_paths from this current class,;Fi[	I"9data//bundler_proj/bundler/vendor/thor/invocation.rb;TiI"class Thor
  module Invocation
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # This method is responsible for receiving a name and find the proper
      # class and task for it. The key is an optional parameter which is;Ti[	@ki	I")module Capistrano
  class CLI
    module Execute
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Invoke capistrano using the ARGV array as the option parameters. This
        # is what the command-line capistrano utility does.;Fi[	@ni	I"module Capistrano
  class CLI
    module Options
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return a new CLI instance with the given arguments pre-parsed and
        # ready for execution.;Fi[	@qi
I"˚module Capistrano
  class CLI
    module UI
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return the object that provides UI-specific methods, such as prompts
        # and more.;Fi[	@?i0I"∂  end
  
  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        class_eval("STRING");Fi[	@ÒiI"*module Redmine
  module Acts
    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          unless self.included_modules.include?(Redmine::Acts::ActivityProvider::InstanceMethods) then;Fi[	@ÒiI"#      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Returns events of type event_type visible by user that occured between from and to
          def function(arglist);Fi[	@ˆiI"Îmodule Redmine
  module Acts
    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          cattr_accessor(:attachable_options);Fi[	@˘iI"module Redmine
  module Acts
    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Customizable::InstanceMethods) then;Fi[	@¸iI"module Redmine
  module Acts
    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Event::InstanceMethods) then;Fi[	@ˇiI"Õmodule ActiveRecord
  module Acts
    module List
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:
        #;Fi[	@iI"Ûmodule Redmine
  module Acts
    module Searchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Options:
        # * :columns - a column or an array of columns to search;Fi[	@i)I"F      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Searches the model for the given tokens
          # projects argument can be either nil (will search all projects), a project or an array of projects;Fi[	@iI"Õmodule ActiveRecord
  module Acts
    module Tree
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:
        #;Fi[	@
iI"module Redmine
  module Acts
    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Watchable::InstanceMethods) then;Fi[	@|i	I"˙  module ActionController
    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = breakdown_rfpdf_options(var);Fi[	I"2data//redmine_proj/redmine/safe_attributes.rb;TiI"Ímodule Redmine
  module SafeAttributes
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Declares safe attributes
      # An optional Proc can be given for conditional inclusion;Fi[	I"3data//redmine_proj/redmine/subclass_factory.rb;TiI"∏module Redmine
  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = nil;Fi[	@¥iI"»module Resque
  module Failure
    module Thoughtbot
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        attr_accessor(:klass)
        ;Fi[I"#   # => [;FI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;TI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];Ti[[	I"Kdata//activerecord_proj/active_record/associations/collection_proxy.rb;Ti*I"9      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name);Ti[	@-icI"h      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@-i|I"f      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@-iöI"c      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i‡I"k      #   person.pets.count # => 3
      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.create(var, &var);Ti[	@-i	I"q      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')]);Ti[	@-i>I"J      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@-iEI"E      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0;Ti[	@-i_I"J      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@-ifI"?      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@-ixI"J      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@-iI"?      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@-iïI"K      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all;Ti[	@-iµI"S      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@-i—I"`      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3));Ti[	@-iÌI"S      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@-i	I"K      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1");Ti[	@-i%I"T      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1));Ti[	@-i}I"[      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var);Ti[	@-iïI"∞      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3;Ti[	@-i±I"ô      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length;Ti[@@@I" ;FI"def function(arglist);Fi[[	@¿
iÀI"ˆ            within_new_transaction(var) { |arglist| yield }
          end)
        rescue ActiveRecord::Rollback
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (var = begin_transaction(var);Fi[	@ÅiI"≥        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (execute("STRING");Fi[	@ÅiI"¨        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("STRING")
      end;Fi[	@≥iÏI"©      when Proc then
        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      raise(RecordNotFound, "STRING")
    end;Fi[	@ûiCI"√            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic)
      end;Fi[	@≥iﬁI"ú      when Array then
        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      var.pp(self.to_a)
    end;Ti[	@◊i!I"            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|
          var.index_name = [var, attributes[(var - 1)]].map { |arglist| index_name_for(var) };Fi[	@MiI"        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist)
        @var = (var or EmptyBackground.new)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var;Fi[	@)i&I"‹        when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "STRING"
        @var = (@var + 1);Fi[	@Oi!I"⁄    when :ppc, :dunno then
      abort("STRING".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    if HOMEBREW_CELLAR.exist? and HOMEBREW_CELLAR.writable_real?.! then
      raise("STRING");Fi[	@Ri<I"£    when :gcc then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist)
    (@var.to_sym == var.to_sym)
  end;Fi[	@iI"√      @var = @var.keys.first
      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var.each_with_index do |arglist|
      if var.is_a?(Hash) then;Fi[	@i{I"÷    when 1 then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var = /https?:\/\/(www\.)?github\.com\/.*\/(zip|tar)ball\//
    if var.match(@var) then;Fi[	@#iZI"ò      @var = (@var + "STRING")
      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    @var.nil?.!
  end;Fi[	@[i)I"µ    when :rbx then
      ["STRING", "STRING", "STRING", "STRING", "STRING"]
    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var
    when :chicken then;Fi[	@iÄI"Ú    var.gsub!(TEXTILE_REFS_RE) do |arglist|
      var, var = $~[(2..3)]
      @var[var.downcase] = [var, nil]
      # do nothing
    end
  end
  
  def function(arglist)
    var.gsub!(MARKDOWN_REFS_RE) do |arglist|
      var, var = $~[(2..3)];Fi[	@iâI"À      var, var = $~[(2..3)]
      var = $~[6]
      @var[var.downcase] = [var, var]
      # do nothing
    end
  end
  
  def function(arglist)
    var = @var[var.downcase] if var
    (var or [var, nil]);Fi[	@2i›I"È        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@2iI"          pdf_new_page?(var)
          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Project) and (var.start_date and var.due_date) then
          var[:zoom] ||= 1;Fi[	@2iI"          pdf_new_page?(var)
          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Version) and (var.due_date and var.start_date) then
          var[:zoom] ||= 1;Fi[	@wi6I"ú        when :twice then
          2
        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0
      end;Fi[@'I"var;FI"end;FI"end;FI" ;Fi[[	@¿
iI",        if var.respond_to?(:ast) then
          var = var.dup
          visitor.accept(var.ast) { |arglist| quote(*var.shift.reverse) }
        else
          var
        end
      end
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.;Fi[	@~i.I"∫            end
          end
          var
        else
          var
        end
      end
      
      def function(arglist)
        (var << "STRING") if options_include_default?(var);Fi[	@ëièI"              return var unless var
            end
            last_insert_id_result(var)
          else
            var
          end
        end
        
        # Executes an UPDATE query and returns the number of affected tuples.
        def function(arglist);Fi[	@≠i›I"Ω      when Relation then
        var ||= "STRING"
        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist)
      var = var.group_by do |arglist|;Fi[	@(	i!I"Ï          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_conditions(var, var)
        else
          var
        end
      end
      
      alias_method(:sanitize_sql, :sanitize_sql_for_conditions)
      ;Fi[	@(	i1I"3          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_assignment(var)
        else
          var
        end
      end
      
      # Accepts a hash of SQL conditions and replaces those attributes
      # that correspond to a +composed_of+ relationship with their expanded;Fi[	@.ioI"Ê      var = var.dup
      if var.gsub!(@var[0], "STRING") then
        var ? ((var[(2..-1)] or "STRING")) : (var)
      else
        var
      end
    end
    
    # Holds source paths in instance so they can be manipulated.
    #;Fi[	@Oi@I"ç        shift
        @var = false
        super
      else
        var
      end
    end
    
    def function(arglist)
      @var = var.dup;Fi[	@7iZI"È          else
            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index("STRING") == 1));Fi[	@i»I"
      Sass::Script::String.new(reversed_color_names[var.rgb])
    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then;Fi[	@ˇiNI"ª        end
      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist)
      var[:action] ||= :unauthenticated;Fi[	I"-data//haml_proj/haml/helpers/xss_mods.rb;TirI"          var.map { |arglist| Haml::Util.html_safe(var) }
        when String then
          Haml::Util.html_safe(var)
        else
          var
        end
      end
      
      alias_method(:with_output_buffer_without_haml_xss, :with_output_buffer)
      ;Fi[	@&iI"ô      "STRING"
    when /\d+/ then
      var.to_i
    else
      var
    end
  end
  
  def function(arglist)
    return unless var.is_a?(VersionElement);Fi[	@⁄ixI"ı        end
        if var.nil? and (var.autobuilding? and without_autobuild?.!) then
          send("STRING")
        else
          var
        end
      end
      
      # Is the current code executing without autobuild functionality?
      #;Fi[	@mi±I"Â              var.merge!(var)
              Factory.build(klass, var, base.send(:mass_assignment_options))
            end
          else
            var
          end
        end
        
        # Get the atomic path.
        #;Fi[	@?i±I"    def function(arglist)
      if @var[:restricted_characters] then
        var.gsub(@var[:restricted_characters], "STRING")
      else
        var
      end
    end
    
    # Check if attachment database table has a created_at field
    def function(arglist);Fi[	@[
i(I"
      if var[:timestamp] and timestamp_possible? then
        var = var.match(/\?.+=/) ? ("STRING") : ("STRING")
        "STRING"
      else
        var
      end
    end
    
    def function(arglist)
      @var.respond_to?(:updated_at) and @var.updated_at.present?;Fi[	@ei6I"Y      def function(arglist)
        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist)
        var = I18n.translate(:"number.human.storage_units.format", :locale => (options[:locale]), :raise => (true));Fi[	@mi I"Ø      require("memcache")
      require("openid/store/memcache")
      OpenID::Store::Memcache.new(MemCache.new(var))
    else
      var
    end
  end
  
  self.store = nil
  ;Fi[	@áiòI"û        case var
        when Proc then
          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist);Fi[	@øi)I"º        @var = case var
        when Symbol then
          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist);Fi[@¬@√@èI" ;FI"def function(arglist);Fi[[	@ûi±I"            return nil unless var
            var.split("STRING").last)
          rescue ActiveRecord::StatementInvalid
            "STRING"
          end
        end
        
        def function(arglist)
          var = exec_query("STRING", "STRING")
          var.rows.first.first;Fi[	@˛iI"Õ      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "STRING"
      else
        "STRING"
      end
    end
    
    def function(arglist)
      (identifier == var.identifier)
    end;Fi[	@i8I"K    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, "STRING")) then
        var = Dir.chdir(full_gem_path) { |arglist| `git rev-parse HEAD`.strip }
        "STRING"
      end
    end
    
    def function(arglist)
      var = "STRING"
      (var << dependencies_to_gemfile(nondevelopment_dependencies));Fi[	@vibI"£        end
        
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist)
        @var = var
        @var = [];Fi[	@˙
i}I"ﬂ        if var = top_level.fonts_dir_without_default then
          var
        else
          "STRING"
        end
      end
      
      def function(arglist)
        http_root_relative(top_level.http_fonts_dir)
      end;Fi[	@€iDI"        if var.respond_to?(:serialize_to_config) then
          (var.serialize_to_config(var) + "STRING")
        else
          "STRING"
        end
      end
      
      def function(arglist)
        $stderr.puts("STRING") if (http_images_path == :relative)
      end;Fi[	@i9I"ˇ      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("STRING") : ("STRING")
      else
        "STRING"
      end
    end
    
    def function(arglist)
      print(var)
    end;Fi[	@)iI"¸            var.join("STRING")
            var[(var..var)].join("STRING")
          else
            "STRING"
          end
        end
        
        def function(arglist)
          var = []
          var.split("STRING").each_with_index do |arglist|;Fi[	@âi
I"    class RbTransform
      class MissingProc < StandardError
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist)
        raise(MissingProc) if (var.nil? or (var.arity < 1))
        @var, @var, @var = var, Regexp.new(var), var;Fi[	@!i
I"È    if AppConfig.settings.pod_name.present? then
      AppConfig.settings.pod_name
    else
      "STRING"
    end
  end
  
  def function(arglist)
    AppConfig.version.number.present? ? (AppConfig.version.number) : ("STRING")
  end;Fi[	@riiI"Ú      if options[:request_path].is_a?(String) then
        options[:request_path]
      else
        "STRING"
      end
    end
    
    def function(arglist)
      if options[:callback_path].is_a?(String) then
        options[:callback_path];Fi[	@`iåI"Ï        if @var[:fog_directory].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        case var
        when File then;Fi[	@2iI"±            # do nothing
          end
        else
          "STRING"
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@2i5I"‘            # do nothing
          end
        else
          "STRING"
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do
          @var.pop;Fi[	I"'data//rescue_proj/resque/server.rb;TipI"       end
      def function(arglist)
        @var ? (var = "STRING") : (var = "STRING")
        "STRING"
      end
    end
    
    def function(arglist)
      response["STRING"] = "STRING"
      begin;Fi[	@liI"‡    class NoDescriptionError < ArgumentError
      class << self
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist)
        super(self.class.message(var, var))
      end;Fi[	@∫iI"ø        when 2 then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        var = "STRING"
        var.each_with_index do |arglist|;Fi[	@¨iNI"∫        when Regexp then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end;Fi[	@≥i1I"¸            var.join("STRING")
            var[(var..var)].join("STRING")
          else
            "STRING"
          end
        end
        
        def function(arglist)
          var = []
          var.split("STRING").each_with_index do |arglist|;Fi[	@ú
i—I"'        if ([/mswin/, /java/].detect { |arglist| var.=~(RUBY_PLATFORM) } or (Spec::Ruby.version.to_f == 1.9)) then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        @var ||= [["STRING", @var]]
        require(which_heckle_runner);Fi[	@i7I"ü        when stdout then
          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        "STRING"
      end;Fi[@'@(@)@*I"end;Fi[[	@(i6I"€            target.destroy
          when :nullify then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private;Fi[	@riÜI"õ          HasAndBelongsToMany
        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	@ëiOI"                var.gsub!(/[^-\d.]/, "STRING")
              when /^-?\D+[\d.]+,\d{2}$/ then
                var.gsub!(/[^-\d,]/, "STRING").sub!(/,/, "STRING")
              else
                # do nothing
              end
            end
          end
        end
        ;Fi[	@îiªI"                  { var.foreign_key => (var[primary_key_name]), var.association_foreign_key => (ActiveRecord::FixtureSet.identify(var)) }
                end)
              end
            else
              # do nothing
            end
          end
        end
        var
      end;Fi[	@ƒi»I"¶        destroyed?
      when :update then
        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	@.iI"¡      when Hash then
        [:force, :skip, "STRING", "STRING"].each { |arglist| var.delete(var) }
        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	@ˇiGI"y        "STRING"
      when :array then
        "STRING"
      else
        # do nothing
      end
    end
  end
end;Fi[	@ÅiI"ù            false
          when "STRING" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[	@x	iΩI"z        var.abort!
      when :scp then
        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	@,i<I"∏          when :stdout then
            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[	@igI"∞        problem("STRING")
      when "STRING", "STRING" then
        problem("STRING".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@iØI"Ã        problem("STRING") unless var.url =~ /[a-fA-F0-9]{40}/
      when /macports\/trunk/ then
        problem("STRING")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@<i+I"â      case File.basename(var)
      when "STRING", "STRING" then
        true
      else
        # do nothing
      end
    end
  end
end;Fi[	@™i∫I"á        :zip
      when "STRING" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@[iAI"ó      "STRING"
    when :ruby then
      "STRING"
    else
      # do nothing
    end
  end
end
class X11Dependency < Requirement
  include(Comparable);Fi[	@WisI"Ä        var
      when "STRING" then
        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	I")data//jekyll_proj/jekyll/core_ext.rb;Ti*I"Ø          var = var[var].split
        when Array then
          var = var[var].compact
        else
          # do nothing
        end
      end
    end
    (var or [])
  end;Fi[	@miÖI"∏      yield(Result[:failed], var, nil)
    when OpenID::Consumer::SETUP_NEEDED then
      yield(Result[:setup_needed], var.setup_url, nil)
    else
      # do nothing
    end
  end
end;Fi[	@åiLI"»            when "STRING" then
              (@var << "STRING")
              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      ;Fi[	@˝i)I"ú            else
              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[I"#;FI"*#   class Person < ActiveRecord::Base;FI"#     has_many :pets;TI"#   end;TI"#;Ti[[	@-i$I"˛      # Works in two ways.
      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@-i]I"j      # Finds an object in the collection responding to the +id+. Uses the same
      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@-i{I"R      # Returns the first record, or the first +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@-iîI"P      # Returns the last record, or the last +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@-iI"O      
      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>];Ti[	@-iéI">      # Deletes the records of the collection directly from the database.
      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@-iI"'      #
      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@-iI"Å      # Destroys the +records+ supplied and removes them from the collection.
      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@-idI"È      end
      
      # Specifies whether the records should be unique or not.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@-ivI"”      end
      
      # Count all records using SQL.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 3
      #   person.pets;Ti[	@-iåI"ƒ      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1;Ti[	@-i¶I"       # If the collection has been already loaded, +length+ and +size+ are
      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.length # => 3
      #   # executes something like SELECT "pets".* FROM "pets" WHERE "pets"."person_id" = 1;Ti[	@-i¿I"ç      # it is equivalent to <tt>collection.exists?</tt>. If the collection has
      # not already been loaded and you are going to fetch the records anyway it
      # is better to check <tt>collection.length.zero?</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count  # => 1
      #   person.pets.empty? # => false;Ti[	@-i—I"ˆ      end
      
      # Returns +true+ if the collection is not empty.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 0
      #   person.pets.any?  # => false;Ti[	@-iÛI"(      
      # Returns true if the collection has more than one record.
      # Equivalent to <tt>collection.size > 1</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count #=> 1
      #   person.pets.many? #=> false;Ti[	@-iI"       end
      
      # Returns +true+ if the given object is present in the collection.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # => [#<Pet id: 20, name: "Snoop">]
      #;Ti[	@-i@I"0      # contain the same number of elements and if each element is equal
      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@-iZI"&      
      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@-iÇI"Ç      # Adds one or more +records+ to the collection by setting their foreign keys
      # to the association√¢¬Ä¬òs primary key. Returns +self+, so several appends may be
      # chained together.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 0
      #   person.pets << Pet.new(name: 'Fancy-Fancy');Ti[	@-i£I"_      
      # Reloads the collection from the database. Returns +self+.
      # Equivalent to <tt>collection(true)</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # fetches pets from the database
      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>];Ti[@'@Ü@á@àI"end;Fi[[	@(ilI"…        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end
  end
  
  class StrictValidationFailed < StandardError;Fi[	@6iI"¡    def function(arglist)
      if var.respond_to?(:permitted?) and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	@åi)I"Ó                var = var.gsub(/^"(.*)"$/, "STRING").gsub(/\\(.)/, "STRING")
                [var, var]
              end]
            else
              var
            end
          end
        end
        
        def function(arglist);Fi[	@åi]I"(                var = ("STRING" == var[1]) ? ((var[2].to_i + 1)) : (var[2].to_i)
                var = ("STRING" == var[5]) ? ((var[4].to_i - 1)) : (var[4].to_i)
                (var..var)
              else
                var
              end
            end
          end
        end
        ;Fi[	@åirI"°                  nil
                end
              end
            else
              var
            end
          end
        end
        
        private;Fi[	@ÈiLI"          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        
        class Integer < Type;Fi[	@Ei`I"W        var = Relation.new(self, arel_table)
        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with;Fi[	@≠iI"Õ          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist);Fi[	@˝iI"ˇ        case var
        when Symbol, String then
          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    
    # Make initializer aware of invocations and the initialization args.;Ti[	@ni≥I"{          false
        when "STRING" then
          nil
        else
          var
        end
      end
    end
  end
end;Fi[	@∏iÄI"ï            "STRING"
          when /^\d+/ then
            "STRING"
          else
            var
          end
        end
      end
    end
  end;Fi[	@x	i≠I"Æ          var = StringIO.new(var.read)
          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    
    def function(arglist);Fi[	@Ö	i*I"        (additional_import_paths or []).map do |arglist|
          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@ì	i?I"È        if var.respond_to?(:supports?) and (var.supports?(var) and var.respond_to?(:"to_#{var}")) then
          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  ;Fi[	@iZI"™    else
      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end
    end
  end
  
  protected;Fi[	@Ci£I"§            var.backtrace.push(var.backtrace_line("STRING"))
            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@OiîI"È            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@¿i'I"û            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@âi0I"•          var = default_scoping.try(:call)
          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	@Ø
i/I"Ω        else
          if var.all? { |arglist| (var == "STRING") } then
            escape_double_quotes(var)
          else
            var
          end
        end
      end
    end
    ;Fi[@I"end;FI" ;F@ÙI"@var = var;Fi[[	@liI"ˆ      
      def function(arglist)
        @var = ensure_dir(var, "STRING")
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = @var = @var = @var = 0
        @var = OrderedXmlMarkup.new(:indent => 2);Fi[	@ri.I"ú      
      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[	@‡iI"      
      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = @var.class unless Class.===(@var)
          responds? and (has_column? and included?);Fi[	@ÊiI"      
      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = var.new if (var.class == Class)
          error_when_not_valid? and no_error_when_valid?;Fi[	@ÈiI"∆      
      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@Åi}I"≠    @var = var
    @var = var
    var = var if (var == -1)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var)
  end;Fi[	@ÅiÜI"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@ÅiäI"Ü  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var);Fi[	@Åi°I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Åi•I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Åi©I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Åi≠I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Åi±I"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@ÅiµI"m  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@ûiI"∂      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!
      end;Fi[	@ûi_I"ˆ      def function(arglist)
        @var = parse_expected(var.shift)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var = var
        begin
          return @var = var.__send__(predicate, *@var, &@var);Fi[	@ûiìI"√    class BeSameAs < Be
      def function(arglist)
        @var = var.shift
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.equal?(@var)
      end;Fi[	@©iI"      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var)
        @var = difference_between_arrays(@var, @var);Fi[	@wiTI"Í      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[@/@0@1@2I" ;Fi[[	@(imI"å      when Proc then
        var.call
      else
        var
      end
    end
  end
  
  class StrictValidationFailed < StandardError
  end;Fi[	@åi*I"Â                [var, var]
              end]
            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var);Fi[	@åisI"î                end
              end
            else
              var
            end
          end
        end
        
        private
        ;Fi[	@ÈiMI"            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        
        class Integer < Type
          def function(arglist);Fi[	@§iI"          if var.encoding.!=(Encoding::ASCII_8BIT) then
            var = var.force_encoding(Encoding::ASCII_8BIT)
          end
          var
        end
      end
    end
    
    class SQLite3Adapter < AbstractAdapter
      class Version;Fi[	@EiaI"ñ        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
    # attributes but not yet saved (pass a hash with key names matching the associated table column names).;Fi[	@≠iI"·            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) };Fi[	@ˆi I")          var = new(var)
          yield(var) if block_given?
          var.save!
          var
        end
      end
    end
    
    # The validation process on save can be skipped by passing <tt>validate: false</tt>.
    # The regular Base#save method is replaced with this when the validations;Fi[	@˝iI"        when Symbol, String then
          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    
    # Make initializer aware of invocations and the initialization args.
    def function(arglist);Ti[	@x	iÆI"∫          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("STRING");Fi[	@Ö	i+I")          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index("STRING") == 1));Fi[	@i[I"§      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end
    end
  end
  
  protected
  ;Fi[	@OiïI"˘              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then;Fi[	I"1data//mongoid_proj/lib/mongoid/attributes.rb;Ti~I"ﬁ            attribute_will_change!(var)
          end
          var ? ((attributes[var] ||= {}).merge!(var)) : (attributes[var] = var)
          var
        end
      end
    end
    
    (alias :[]= :write_attribute)
    ;Fi[	I"2data//mongoid_proj/lib/mongoid/persistence.rb;Ti—I"          else
            var = new(var, var, &var)
            var.save
            var
          end
        end
      end
      
      # Create a new document. This will instantiate a new document and
      # insert it in a single call. Will always return the document;Fi[	@∑iÒI"t            var = new(var, var, &var)
            fail_validate!(var) unless var.insert.errors.empty?
            fail_callback!(var, :create!) if var.new_record?
            var
          end
        end
      end
      
      # Delete all documents given the supplied conditions. If no conditions
      # are passed, the entire collection will be dropped for performance;Fi[	@Éi’I"¯            @var, @var = {}, true
            @var = var.inject({}) do |arglist|
              var[var.id] = var
              var
            end
          end
        end
        
        # Does the target include the provided document?
        #;Fi[	@|
ißI"‹            if var.is_a?(Symbol) then
              var = resolve(var, var, var, var.merge(:scope => (nil)))
            end
            var
          end
        end
      end
      
      include(Implementation)
      ;Fi[@
@@‰I"@var = var;FI"@var = var;Fi[[	@Si
I"!    class Preloader
      class Association
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class);Fi[	@eicI"«    
    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	@≥iI"¿    alias :loaded? :loaded
    
    alias :default_scoped? :default_scoped
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = nil
      @var = false;Ti[	@ÌiI"≈    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	@i	I"™module Bundler
  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@iI"∂    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	@,iI"        attr_accessor(:path, :uri, :ref)
        
        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var or Proc.new { |arglist| true });Fi[	I"+data//cancan_proj/cancan/exceptions.rb;TiI"Ê    attr_reader(:action, :subject)
    
    attr_writer(:default_message)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "STRING")
    end;Fi[	@vi;I"‰        
        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          ;Fi[	@x	i!I"≠    attr_reader(:logger)
    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@i"I"            return var.gsub("STRING", "STRING") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["STRING"] ||= Sass::Script::Bool.new(true);Fi[	@&iI"™          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil
      end;Fi[	@i'I"Ï      
      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@i	I"¥  module RbSupport
    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	@ﬁi$I"      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("STRING", :name => (@var.name))), :host => (AppConfig.pod_uri.host) };Fi[	@Oi
I"˛    module Errors
      class AttributeAssignmentError < Mongoid::Errors::MongoidError
        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end;Fi[	@JiI"±module Paperclip
  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@™
iI"      REGEX = /^(@(#{KEYWORDS.join("STRING")}STRING/
      
      attr_accessor(:time, :task)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var.is_a?(String) ? ((Chronic.parse(var) or 0)) : ((var or 0))
      end;Fi[@(@)@@‹I"
begin;Fi[[	@RiPI"⁄          var = through_association.build
          var.send("STRING", var)
          var)
        end
      end
      
      def function(arglist)
        begin
          build_through_record(var).save!
        ensure;Fi[	@¿
iÃI"À          end)
        rescue ActiveRecord::Rollback
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (var = begin_transaction(var)
          yield);Fi[	@ÅiI"≈          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (execute("STRING")
          begin_db_transaction);Fi[	@æi&I"Ù          else
            ActiveRecord::Base.configurations[var[:env]]
          end
        end
      end
      
      def function(arglist)
        begin
          (var = var.first
          class_for_adapter(var["STRING"]).new(*var).create);Fi[	@ÍiäI"©        yield)
      ensure
        var.each { |arglist| @var.pop }
      end
    end
    
    def function(arglist)
      begin
        (@var.concat(var)
        yield);Fi[	@&iwI"À        yield)
      ensure
        self.build_args = var
      end
    end
    
    def function(arglist)
      begin
        (require("rubygems/format")
        Gem::Format.from_file_by_path(var).spec);Fi[	@,iZI"Â            var
          else
            raise(GitError, "STRING")
          end
        end
        
        def function(arglist)
          begin
            (return unless @var
            in_path { |arglist| git("STRING") };Fi[	@ä	i/I"‡      def function(arglist)
        var[:pattern_name] ||= var
        Compass::Installers::Manifest.new(manifest_file(var), var)
      end
    end
    
    def function(arglist)
      begin
        (@var = nil
        yield;Fi[	@i'I"‚      ensure
        ($stderr.write(color(:clear))
        $stdout.write(color(:clear)))
      end
    end
    
    def function(arglist)
      begin
        ($stderr.write(color(:yellow))
        $stdout.write(color(:yellow));Fi[	@=ihI"      def function(arglist)
        hooks_for(:after, var).reverse_each do |arglist|
          invoke(var, "STRING", var, true)
        end
      end
      
      def function(arglist)
        begin
          var.invoke(var, var, &var)
        rescue Exception => var;Fi[	@æi≤I"∞      end
    else
      respond_with(@var, :location => (photos_path), :error => (message))
    end
  end
  
  def function(arglist)
    begin
      yield
    rescue TypeError;Fi[	@OiPI"ÿ    unless var.empty? then
      perform_preinstall_checks
      var.each { |arglist| install_formula(var) }
    end
  end
  
  def function(arglist)
    begin
      (var = FormulaInstaller.new(var)
      var.install;Fi[	@&
iúI"È  def function(arglist)
    unless (install_bottle or (ARGV.interactive? or @var.nil?)) then
      @var ||= (Time.now - @var)
    end
  end
  
  def function(arglist)
    begin
      (FileUtils.rm(Dir["STRING"])
      @var = Time.now;Fi[	@&
iÈI"‘      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    begin
      (ohai("STRING") if ARGV.verbose?
      if f.class.skip_clean_all? then;Fi[	@?iuI"Z      end
      styles.reject { |arglist| (var == :original) }.each do |arglist|
        post_process_style(var, var) if process_style?(var, var)
      end
    end
    
    def function(arglist)
      begin
        (raise(RuntimeError.new("STRING")) if var.processors.blank?
        @var[var] = var.processors.inject(@var[:original]) do |arglist|;Fi[	@ÈiCI"            self
          end.class_eval do |arglist|
            define_method(var, &var)
          end
        end
        
        def function(arglist)
          begin
            (var = StringIO.new("STRING")
            override_method(var, :size) { |arglist| var };Fi[	@7i#I"‘            var)
          rescue CommandFailed
            return nil
          end
        end
        
        def function(arglist)
          begin
            (var = Entries.new
            var = target(var);Fi[	@7iAI"!          rescue => var
            logger.error("STRING")
            raise(CommandFailed.new(var.message))
          end
        end
        
        def function(arglist)
          begin
            (var = scm_iconv(@var, "STRING", target(var))
            File.new(var, "STRING").read);Fi[@'@(@)I"#   #    ];TI"#;Ti[[	@-i+I"<      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@-idI"∑      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #   person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=4;Ti[	@-i}I"`      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #;Ti[	@-iõI"]      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #;Ti[	@-i
I"ã      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')])
      #   person.pets.size # => 5;Ti[	@-i?I"S      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@-iFI"W      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0
      #   person.pets      # => [];Ti[	@-i`I"S      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@-igI"Z      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@-iyI"S      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@-iÄI"Z      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@-iñI"K      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all
      #;Ti[	@-i∂I"å      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@-i“I"i      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3))
      #   # => [;Ti[	@-iÓI"å      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@-i
I"Ñ      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1")
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@-i&I"ç      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@-iñI"ü      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3
      #   # Because the collection is already loaded, this will behave like;Ti[@(@)@@‹I""STRING";Fi[[	@Åi7I"Æ        else
          var.table(var.source)
          var.wheres = var.constraints
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@îi„I"Ø            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "STRING"
    end
  end;Fi[	@/	ikI"µ          else
            defined? Mysql ? (Mysql::Error) : (StandardError)
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ÿ
i(I"ù        [basename]
      else
        chunk_suffixes.map { |arglist| "STRING" }
      end
    end
    
    def function(arglist)
      "STRING"
    end
  end;Fi[	@i)I"Î            unless var =~ /\A#{Sass::SCSS::RX::IDENT}STRING/ then
              raise(Sass::SyntaxError, "STRING")
            end
          end
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@PipI"∞        var.inject({}) do |arglist|
          var[delimited(var)] = var
          var
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@iI"‡      def function(arglist)
        if model_exists? then
          inject_into_file(model_path, model_contents, :after => "STRING")
        end
      end
      
      def function(arglist)
        "STRING"
      end
    end;Fi[	@ßivI"†          else
            (var.value.first + "STRING")
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@„i1I"            (var << accepted_types_and_failures)
            (var << "STRING") if @var.present? and @var.present?
            (var << rejected_types_and_failures)
          end
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@„iGI"‚            "STRING".tap do |arglist|
              @var.any? ? ((var << "STRING")) : ((var << "STRING"))
            end
          end
        end
        
        def function(arglist)
          "STRING"
        end
        ;Fi[	@°iπI"ì            end
          end
          var = (var + 1))
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ûimI"‘          return @var = var.__send__(present_tense_predicate, *@var, &@var)
        rescue NameError
          raise(var)
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@¶i:I"™          else
            return "STRING" if (@var == :at_least)
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ÎiDI"∫            true)
          rescue NoMethodError => var
            return false
          end
        end
        
        def function(arglist)
          "STRING"
        end
      end;Fi[	@ÎiYI"∫            true)
          rescue NoMethodError => var
            return false
          end
        end
        
        def function(arglist)
          "STRING"
        end
      end;Fi[	@Çi∑I"Õ          else
            target_metaclass.protected_method_defined?(var) ? ("STRING") : ("STRING")
          end
        end
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@i8I"é          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        "STRING"
      end
    end;Fi[@'@K@L@MI"end;Fi[[	@xi[I"          else
            if ActiveRecord::Base.!=(self) and table_exists? then
              connection.schema_cache.primary_keys[table_name]
            else
              "STRING"
            end
          end
        end
        
        # Sets the name of the primary key column.;Fi[	@åiâI"ï          case var
          when "STRING" then
            var
          else
            "STRING"
          end
        end
      end
    end
  end;Fi[	@Ei;I"ﬂ            if table_exists? then
              var = (columns.map { |arglist| "STRING" } * "STRING")
              "STRING"
            else
              "STRING"
            end
          end
        end
      end
      ;Fi[	@òi8I"£      when var = self[:updated_at] then
        var = var.utc.to_s(cache_timestamp_format)
        "STRING"
      else
        "STRING"
      end
    end
  end
end;Fi[	@™iUI"î            "STRING"
          when false then
            nil
          else
            "STRING"
          end
        end
      end
    end
  end;Fi[	@ÍiI"√      def function(arglist)
        if (top_level.preferred_syntax == :scss) and top_level.sass_dir then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	I"5data//diaspora_proj/helpers/open_graph_helper.rb;Ti=I"ê  def function(arglist)
    if image_path("STRING").include?("STRING") then
      image_path("STRING")
    else
      "STRING"
    end
  end
end;Fi[	@çiI"Ÿ                "STRING"
              when "STRING" then
                "STRING"
              else
                "STRING"
              end
            end
          end
        else
          if @var.html4? then;Fi[	@çiI"∞              "STRING"
            when "STRING" then
              "STRING"
            else
              "STRING"
            end
          end
        end
      end
    end;Fi[	@)
irI"ë          "STRING"
        when 41 then
          "STRING"
        else
          "STRING"
        end
      end
  end
  
  def function(arglist);Fi[	@∆i}I"s        var[0].to_s
      when 2 then
        "STRING"
      else
        "STRING"
      end
    end
  end
end;Fi[	@ËiI"≈          var = File.read(@var)
          var = Liquid::Template.parse(var)
          var.stack { |arglist| var.render(var) }
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	@#iSI"Ç        case var
        when Hash then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[	@iRI"õ          end
        end
        "STRING"
      else
        "STRING"
      end
    end
  end
  
  ALLOWED_TAGS = ["STRING", "STRING", "STRING", "STRING"];Fi[	@ÎiI"¥    def self.last_description(arglist)
      if last_matcher.respond_to?(:description) then
        last_matcher.description
      else
        "STRING"
      end
    end
  end
end;Fi[	@«i4I"ﬂ      else
        if ((defined? Gem and var.filename.include?(Gem.dir)) or var.filename =~ /\/bin\/(\w+)$/) then
          "STRING"
        else
          "STRING"
        end
      end
    end
    
    TEMPLATE = "STRING";Fi[	@i I"â          "STRING"
        when /\.png$/i then
          "STRING"
        else
          "STRING"
        end
      end
    end
  end
end;Fi[@(@I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;Fi[[	@&iPI"      # @since 3.0.0
      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@&iäI"#          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ]);Fi[	@)iI"      # @since 3.0.3
      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@/iI"      # @since 3.0.0
      def function(arglist)
        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date.mongoize;Fi[	@/i.I"9        # @since 3.0.0
        def function(arglist)
          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Date.mongoize("2012-1-1");Fi[	@4iI"          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize;Fi[	@4i4I"6        # @since 3.0.0
        def function(arglist)
          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   DateTime.mongoize("2012-1-1");Fi[	@:ilI"ﬁ          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@=i~I"€        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@=i˘I"        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11");Fi[	@CiI"Ô      # @since 3.0.0
      def function(arglist)
        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   range.mongoize;Fi[	@Ci:I"C        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : (::Range.new(var["STRING"], var["STRING"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Range.mongoize(1..3);Fi[	@Ii"I"        # @since 3.0.0
        def function(arglist)
          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Set.mongoize(1..3);Fi[	@Li±I"        # @since 3.0.0
        def function(arglist)
          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   String.mongoize("123.11");Fi[	@Oi!I"        # @since 3.0.0
        def function(arglist)
          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Symbol.mongoize("123.11");Fi[	@Ri4I"            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1");Fi[	@Wi#I"A        def function(arglist)
          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   TimeWithZone.mongoize("2012-1-1");Fi[@(@)@I"#version("STRING") do |arglist|;FI"def self.active?(arglist);Fi[[	@≈iI"X        end
        def function(arglist)
          define_helper(:instance, "STRING", "STRING", (15 + 1))
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          defined? ::ActiveModel::VERSION and ((::ActiveModel::VERSION::MAJOR == 3) and (::ActiveModel::VERSION::MINOR == 0))
        end;Fi[	@»iI"
        end
        def function(arglist)
          define_helper(:instance, "STRING", "STRING", (17 + 1))
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 2)
        end;Fi[	@»iEI"/              include(StateMachine::Integrations::ActiveModel::Observer)
            end
          end
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 2) and (::ActiveRecord::VERSION::MINOR < 3)
        end;Fi[	@»iNI"A        end
        def function(arglist)
          { :default => (@var[var]) }
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 2) and ((::ActiveRecord::VERSION::MINOR < 3) or (::ActiveRecord::VERSION::TINY < 2))
        end;Fi[	@»iWI"T        end
        def function(arglist)
          var.self_and_descendents_from_active_record
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 2) and ((::ActiveRecord::VERSION::MINOR == 3) and (::ActiveRecord::VERSION::TINY >= 2))
        end;Fi[	@»i`I")        end
        def function(arglist)
          var.self_and_descendants_from_active_record
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end;Fi[	@“iI"        end
        def function(arglist)
          action
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (::DataMapper::VERSION =~ /^0\.\d\./ or ::DataMapper::VERSION =~ /^0\.10\./)
        end;Fi[	@“iI"˛        end
        def function(arglist)
          ::Extlib::Inflection.pluralize(var.to_s)
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          ::DataMapper::VERSION =~ /^0\.9\.[4-6]/
        end;Fi[	@“i"I";        # enabled because of the way dm-validations integrates
        def function(arglist)
          super if (action.!=(:save) or supports_validations?.!)
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (::DataMapper::VERSION == "STRING")
        end;Fi[	@’iI"3        end
        def function(arglist)
          define_helper(:instance, "STRING", "STRING", (20 + 1))
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (defined? ::MongoMapper::Version.! or ::MongoMapper::Version =~ /^0\.[5-7]\./)
        end;Fi[	@’iI"(        end
        def function(arglist)
          lambda { |arglist| var.all(var.call(var)) }
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (defined? ::MongoMapper::Version.! or ::MongoMapper::Version =~ /^0\.[5-8]\./)
        end;Fi[	@’i?I"B        end
        def function(arglist)
          var.to_s.humanize.downcase
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          defined? ::MongoMapper::Plugins and (defined? ::MongoMapper::Version.! or ::MongoMapper::Version =~ /^0\.(7|8\.[0-3])\./)
        end;Fi[	@’iHI",        end
        def function(arglist)
          define_helper(:instance, "STRING", "STRING", (90 + 1))
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end;Fi[	@ÿiI"	            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          ::Mongoid::VERSION =~ /^2\.0\./
        end;Fi[	@€iI")        end
        def function(arglist)
          (action == :save) ? (:_save) : (super)
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == 2) and (::Sequel::MINOR <= 11)))
        end;Fi[	@€i-I"5        end
        def function(arglist)
          var.model_classes[nil]
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == 2) or ((::Sequel::MAJOR == 3) and (::Sequel::MINOR <= 13))))
        end;Fi[	@€i9I"&        end
        def function(arglist)
          "STRING"
        end
      end
      
      version("STRING") do |arglist|
        def self.active?(arglist)
          defined? ::Sequel::MAJOR and ((::Sequel::MAJOR == 3) and ((::Sequel::MINOR >= 14) and (::Sequel::MINOR <= 23)))
        end;Fi[@
@ÉI"# type.;FI"#;FI"$# @example Mongoize the object.;Fi[[	@&iQI"ˇ      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@&iãI"            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ])
        #;Fi[	@)iI"„      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@/iI"      def function(arglist)
        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date.mongoize
      #;Fi[	@/i/I",        def function(arglist)
          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Date.mongoize("2012-1-1")
        #;Fi[	@4iI"          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #;Fi[	@4i5I")        def function(arglist)
          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   DateTime.mongoize("2012-1-1")
        #;Fi[	@:imI"“        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@=iI"÷          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@=i˙I"         def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11")
        #;Fi[	@CiI"‚      def function(arglist)
        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   range.mongoize
      #;Fi[	@Ci;I"6        def function(arglist)
          var.nil? ? (nil) : (::Range.new(var["STRING"], var["STRING"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Range.mongoize(1..3)
        #;Fi[	@Ii#I"        def function(arglist)
          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Set.mongoize(1..3)
        #;Fi[	@Li≤I"        def function(arglist)
          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   String.mongoize("123.11")
        #;Fi[	@Oi"I"        def function(arglist)
          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Symbol.mongoize("123.11")
        #;Fi[	@Ri5I"          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1")
        #;Fi[	@Wi$I"-          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   TimeWithZone.mongoize("2012-1-1")
        #;Fi[@.I"super("STRING");FI"end;FI"end;FI" ;Fi[[	@}iI"require("active_record/errors")
module ActiveRecord
  class InverseOfAssociationNotFoundError < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughAssociationNotFoundError < ActiveRecordError
    def function(arglist);Fi[	@}iI"Ú  end
  
  class HasManyThroughAssociationNotFoundError < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughAssociationPolymorphicSourceError < ActiveRecordError
    def function(arglist);Fi[	@}iI"¸  end
  
  class HasManyThroughAssociationPolymorphicSourceError < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughAssociationPolymorphicThroughError < ActiveRecordError
    def function(arglist);Fi[	@}iI"˛  end
  
  class HasManyThroughAssociationPolymorphicThroughError < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughAssociationPointlessSourceTypeError < ActiveRecordError
    def function(arglist);Fi[	@}i#I"˘  end
  
  class HasManyThroughAssociationPointlessSourceTypeError < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasOneThroughCantAssociateThroughCollection < ActiveRecordError
    def function(arglist);Fi[	@}i)I"Ù  end
  
  class HasOneThroughCantAssociateThroughCollection < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughSourceAssociationNotFoundError < ActiveRecordError
    def function(arglist);Fi[	@}i:I"˙  end
  
  class HasManyThroughCantAssociateThroughHasOneOrManyReflection < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughCantAssociateNewRecords < ActiveRecordError
    def function(arglist);Fi[	@}i@I"Ë  end
  
  class HasManyThroughCantAssociateNewRecords < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughCantDissociateNewRecords < ActiveRecordError
    def function(arglist);Fi[	@}iFI"Ó  end
  
  class HasManyThroughCantDissociateNewRecords < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasManyThroughNestedAssociationsAreReadonly < ActiveRecordError
    def function(arglist);Fi[	@}iLI"ˆ  end
  
  class HasManyThroughNestedAssociationsAreReadonly < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class HasAndBelongsToManyAssociationForeignKeyNeeded < ActiveRecordError
    def function(arglist);Fi[	@}iRI"‰  end
  
  class HasAndBelongsToManyAssociationForeignKeyNeeded < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class EagerLoadPolymorphicError < ActiveRecordError
    def function(arglist);Fi[	@}iXI"…  end
  
  class EagerLoadPolymorphicError < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class ReadOnlyAssociation < ActiveRecordError
    def function(arglist);Fi[	@}i^I"∆  end
  
  class ReadOnlyAssociation < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  class DeleteRestrictionError < ActiveRecordError
    def function(arglist);Fi[	@}idI"∂  end
  
  class DeleteRestrictionError < ActiveRecordError
    def function(arglist)
      super("STRING")
    end
  end
  
  module Associations
    extend(ActiveSupport::Autoload);Fi[	@ iFI"Î      
      class ExampleRow < Cells
        class InvalidForHeaderRowError < NoMethodError
          def function(arglist)
            super("STRING")
          end
        end
        
        attr_reader(:scenario_outline)
        ;Fi[	@liI"‚      include(Io)
      
      class UnNamedFeatureError < StandardError
        def function(arglist)
          super("STRING")
        end
      end
      
      def function(arglist)
        @var = ensure_dir(var, "STRING");Fi[	@CiI"‘module Cucumber
  module RbSupport
    class NilWorld < StandardError
      def function(arglist)
        super("STRING")
      end
    end
    
    class MultipleWorld < StandardError
      def function(arglist);Fi[@¬@√@ƒI"private;TI" ;Ti[[	@≥i˝I"Ò    def function(arglist)
      var = to_a.take([limit_value, 11].compact.min).map!(&:inspect)
      var[10] = "STRING" if (var.size == 11)
      "STRING"
    end
    
    private
    
    def function(arglist)
      var = with_default_scope;Ti[	@‰i$I"É    end
    
    def function(arglist)
      "STRING"
    end
    
    private
    
    def function(arglist)
      @var.send(*var);Fi[	@ iTI"ö      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        @var ||= (var = {};Fi[	@/iôI"ì      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        @var = true;Fi[	@#iEI"¨        end
        
        def function(arglist)
          "STRING"
        end
        
        private
        
        def function(arglist)
          @var.index(self);Fi[	@iŸI"µ      #
      # @since 3.1.0
      def function(arglist)
        "STRING"
      end
      
      private
      
      # Apply criteria specific options - query, sort, limit.
      #;Fi[	I"/data//mongoid_proj/lib/mongoid/document.rb;TiI"æ    def function(arglist)
      return "STRING" if new_record?
      return "STRING" unless self[:updated_at].nil?
      "STRING"
    end
    
    private
    
    # Returns the logger
    #;Fi[	I"1data//mongoid_proj/lib/mongoid/inspection.rb;TiI"‘    def function(arglist)
      var = []
      var.concat(inspect_fields).concat(inspect_dynamic_fields)
      "STRING"
    end
    
    private
    
    # Get an array of inspected fields for the document.
    #;Fi[	@èiFI"ì      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        if var then;Fi[	@ûiyI"ó      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        "STRING".to_sym;Fi[	@ÎiI"ﬁ    
    def self.generated_description(arglist)
      return nil if last_should.nil?
      "STRING"
    end
    
    private
    
    def self.last_description(arglist)
      if last_matcher.respond_to?(:description) then;Fi[	@£iI"ó      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        "STRING".to_sym;Fi[	@©i"I"…      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        var.all? { |arglist| var.respond_to?(:<=>) } ? (var.sort) : (var);Fi[	@¨iBI"ë      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        case @var;Fi[	@Øi/I"´      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING");Fi[	I"4data//state_machine_proj/state_machine/state.rb;Ti‡I"    #   state   # => #<StateMachine::State name=:parked value=1 initial=true context=[]>
    def function(arglist)
      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "STRING"
    end
    
    private
    
    attr_reader :function
    ;Fi[	I"9data//state_machine_proj/state_machine/transition.rb;Ti(I"À    #   transition = StateMachine::Transition.new(object, machine, :ignite, :parked, :idling)
    #   transition   # => #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>
    def function(arglist)
      "STRING"
    end
    
    private
    
    # Runs a block that may get paused.  If the block doesn't pause, then
    # execution will continue as normal.  If the block gets paused, then it;Fi[@(@)@I"desc("STRING", "STRING");FI" ;Fi[[	@∂i_I"Ù            var.write(Backup::Template.new.result("STRING"))
          end
          puts("STRING")
        end
      end
      
      desc("STRING", "STRING")
      
      method_option(:config_path, :type => :string, :desc => "STRING")
      ;Fi[	@∂isI"Ù            var.write(Backup::Template.new.result("STRING"))
          end
          puts("STRING")
        end
      end
      
      desc("STRING", "STRING")
      
      method_option(:encryptor, :type => :string, :required => (true))
      ;Fi[	@∂iòI"∫        else
          (puts("STRING")
          puts("STRING"))
        end
      end
      
      desc("STRING", "STRING")
      
      method_option(:install, :type => :string)
      ;Fi[	@ﬁi8I"        end
      else
        super
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    ;Fi[	@ﬁiVI"º      else
        puts("STRING")
        FileUtils.cp(File.expand_path("STRING", "STRING"), "STRING")
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    ;Fi[	@ﬁi~I"º          Bundler.load.lock unless options[:"dry-run"]
          Bundler.ui.info("STRING")
        end
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    ;Fi[	@ﬁi⁄I"˙        Bundler.ui.warn("STRING") if var[:local] and Bundler.app_cache.exist?
        Bundler.ui.warn("STRING") if Bundler.definition.no_sources?
        raise(var)
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    ;Fi[	@ﬁi.I"Î        Bundler.ui.warn("STRING")
      else
        var.generate_bundler_executable_stubs(var, :force => (options[:force]), :binstubs_cmd => (true))
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    ;Fi[	@ﬁiwI"Ÿ        Bundler.ui.error(var.message)
        Bundler.ui.warn("STRING")
        exit(1)
      end
    end
    
    desc("STRING", "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    ;Fi[	@ﬁiùI"•      rescue ArgumentError
        Bundler.ui.error("STRING")
        exit(128)
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    ;Fi[	@ﬁi€I"ﬁ      else
        (Bundler.ui.error("STRING")
        exit(1))
      end
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      var = [ENV["STRING"], ENV["STRING"], ENV["STRING"]].find do |arglist|;Fi[	@ﬁiÌI"ù        end
      else
        Bundler.ui.info("STRING")
      end
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      if var then;Fi[	@ﬁiI"Á        var = var.name
        var = (var.license or var.licenses)
        var.empty? ? (Bundler.ui.warn("STRING")) : (Bundler.ui.info("STRING"))
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    ;Fi[	@ﬁi+I"—        else
          raise
        end
      end
    end
    
    desc("STRING", "STRING")
    
    method_option(:bin, :type => :boolean, :default => (false), :aliases => "STRING", :banner => "STRING")
    ;Fi[	@ﬁiwI"‘      else
        Bundler.ui.error("STRING")
        exit(1)
      end
    end
    
    desc("STRING", "STRING")
    
    method_option("STRING", :type => :boolean, :default => (false), :banner => "STRING")
    ;Fi[	@ﬁi¢I"È        Bundler.ui.confirm(var.map { |arglist| "STRING" }.join("STRING"))
      else
        Bundler.ui.confirm("STRING")
      end
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      Env.new.write($stdout);Fi[@I"def function(arglist);FI"@var = var;FI"end;FI" ;Fi[[	@iîI"∫  	# @param float :scale image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_image_scale, :SetImageScale)
  ;Fi[	@i˙I"Í  	# @param float :margin The margin.
  	# @since 1.5
  	# @see SetLeftMargin(), SetRightMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_top_margin, :SetTopMargin)
  ;Fi[	@iI"Ï  	# @param float :margin The margin.
  	# @since 1.5
  	# @see SetLeftMargin(), SetTopMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_right_margin, :SetRightMargin)
  ;Fi[	@iBI"”  	# @param string :title The title.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetSubject()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_title, :SetTitle)
  ;Fi[	@iNI"Ÿ  	# @param string :subject The subject.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_subject, :SetSubject)
  ;Fi[	@iZI"‚  	# @param string :author The name of the author.
  	# @since 1.2
  	# @see SetCreator(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_author, :SetAuthor)
  ;Fi[	@ifI"‰  	# @param string :keywords The list of keywords.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_keywords, :SetKeywords)
  ;Fi[	@irI"Â  	# @param string :creator The name of the creator.
  	# @since 1.2
  	# @see SetAuthor(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_creator, :SetCreator)
  ;Fi[	@iBI"Ï   	# Set header margin.
  	# (minimum distance between header and top page margin)
  	# @param int :hm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_margin, :SetHeaderMargin)
  ;Fi[	@iMI"Ô   	# Set footer margin.
  	# (minimum distance between footer and bottom page margin)
  	# @param int :fm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_margin, :SetFooterMargin)
  ;Fi[	@iWI"  #
   	# Set a flag to print page header.
  	# @param boolean :val set to true to print the page header (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_header, :SetPrintHeader)
  ;Fi[	@iaI"Ú  #
   	# Set a flag to print page footer.
  	# @param boolean :value set to true to print the page footer (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_footer, :SetPrintFooter)
  ;Fi[	@i6I"¨   	# Set header font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_font, :SetHeaderFont)
  ;Fi[	@iAI"¨   	# Set footer font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_font, :SetFooterFont)
  ;Fi[	@iLI"¥   	# Set language array.
  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_language_array, :SetLanguageArray)
  ;Fi[	@iVI"å  #
   	# Set document barcode.
  	# @param string :bc barcode
  	#
  def function(arglist)
    @var = var
  end
  
  #
   	# Print Barcode.;Fi[I"#   person.pets;TI"#   # => [;T@'@(@)i[[	@-i)I"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-ibI"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i{I"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-iôI"0      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-iI"D      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i=I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i^I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-iwI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-iîI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i¥I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i–I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-iÏI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-iI"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i$I"7      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i|I"L      #   end
      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist);Ti[	@-i∞I"ç      #
      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist);Ti[@(@@∑
I"
false;FI"end;Fi[[	@Oi2I"≠          end
          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end
  end;Fi[	@˙iI"ó      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@˙iI"∑      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions;Fi[	@˙ikI"Œ            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@ˇi}I"      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,;Fi[	@Òi!I"É    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist);Fi[	@Òi%I"Ñ    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist);Fi[	@Òi=I"{    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@ûiI"Ú      # ThroughReflection.
      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false
      end
      
      # An array of arrays of scopes. Each item in the outside array corresponds to a reflection;Fi[	@¸iI"Ü    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI;Fi[	@iI"Ô    def function(arglist)
      super(var)
      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    
    # By default, a task invokes a method in the thor class. You can change this;Fi[	@7iaI"ø      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index("STRING") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end;Fi[	@i5I"Õ      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@PiI"ü      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	I"/data//diaspora_proj/models/conversation.rb;Ti.I"ë  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist);Fi[	@HiyI"—  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist);Fi[@@I" ;F@‘I"# do nothing;Fi[[	@¿
iI"      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ˇi˝I"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ˇiI"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ûiÂI"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@¸i	I"çmodule Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@¸iI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@¸iI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@¸iI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@¸iI"Ä    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@iSI"â  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@iI"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@@i>I"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Åi˛I"ä  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  ;Fi[	@ûiI"©        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@°iI"©        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[@I"# @return [ nil ] Nil.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	I"8data//mongoid_proj/lib/mongoid/contextual/atomic.rb;TiI"?      #
      # @param [ String, Symbol ] field The name of the field to add to.
      # @param [ Object ] value The single value to add.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ iI"Ö      # @param [ String, Symbol ] field The name of the field to operate on.
      # @param [ Hash ] value The bitwise operations to perform. Keys may be
      #   "and" or "or" and must have numeric values.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ i.I":      #
      # @param [ String, Symbol ] field The field to increment.
      # @param [ Integer ] value The amount to increment by.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ iBI"!      #   from.
      # @param [ Integer ] value 1 to pop from the end, -1 to pop from the
      #   front.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ iSI"7      #
      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Object ] value The single value to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ ibI"9      #
      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Array<Object> ] values The values to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ iqI".      #
      # @param [ String, Symbol ] field The field to push to.
      # @param [ Object ] value The value to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ i{I"7      #
      # @param [ String, Symbol ] field The field to push to.
      # @param [ Array<Object> ] values The values to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ iäI"@      #
      # @param [ String, Symbol ] old_name The old field name.
      # @param [ String, Symbol ] new_name The new field name.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var.to_s) }))
      end;Fi[	@ iôI".      #
      # @param [ String, Symbol ] field The name of the field.
      # @param [ Object ] value The value to set.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end;Fi[	@ ißI"U      #   context.unset(:name)
      #
      # @param [ String, Symbol, Array ] fields The name of the fields.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = var.__find_args__.collect { |arglist| [database_field_name(var), true] }
        query.update_all("STRING" => (Hash[var]));Fi[	I"8data//mongoid_proj/lib/mongoid/contextual/memory.rb;Ti(I"‹      #
      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count
        var = map do |arglist|;Fi[	@ i>I"Ÿ      #
      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count
        each do |arglist|;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/mongo.rb;TiCI"È      #
      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        self.count.tap { |arglist| query.remove_all }
      end;Fi[	@  iQI"Î      #
      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = self.count
        each { |arglist| var.destroy };Fi[@(@@∑
I"execute("STRING");FI"end;Fi[[	@~i§I"      #   remove_index :accounts, name: :by_branch_party
      def function(arglist)
        remove_index!(var, index_name_for_remove(var, var))
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      # Rename an index.;Fi[	@Åi I"•        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist);Fi[	@Åi$I"∞      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist);Fi[	@Åi(I"Ë      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE;Fi[	@ÅiµI"◊      #   rename_table('octopuses', 'octopi')
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist);Fi[	@ÅiƒI"        var = column_for(var, var)
        execute("STRING") unless (var or var.nil?)
        change_column(var, var, var.sql_type, :null => (var))
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist);Fi[	@Åi»I"”      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      # Maps logical Rails types to MySQL-specific data types.;Fi[	@ëi±I"          var = "STRING"
          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist);Fi[	@ëiµI"ƒ        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist);Fi[	@ëiπI"Ø        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
      end
    end;Fi[	@ûi	I"“        def function(arglist)
          clear_cache!
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist);Fi[	@ûiI"ƒ        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist);Fi[	@§i*I"∏      
      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist);Fi[	@§i.I"∞      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist);Fi[	@§i2I"£      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      #:nodoc:;Fi[@(@í@ì@·I" ;Fi[[	@{ibI"G            super(var, var)
            serialized_attributes.each do |arglist|
              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then;Fi[	@	iûI"        return nil if (var.blank? or (var == self.name))
        unless var = subclasses.detect { |arglist| (var.name == var) } then
          raise(ActiveRecord::SubclassNotFound.new("STRING"))
        end
        var
      end
    end
    
    private
    ;Fi[	@√i!I"¶          else
            var.send("STRING", var)
          end
        end
        var
      end
    end
    
    class Merger
      attr_reader(:relation, :values);Fi[	@iXI"§          (var << "STRING")
        end
        (var << "STRING") if var
      end
      var
    end
  end
  
  class Dependency
    attr_accessor(:source, :groups);Fi[	@L	iÖI"ı          if var.enum and var.enum.include?(var).! then
            raise(MalformattedArgumentError, "STRING")
          end
        end
        var
      end
    end
    
    # Raises an error if @non_assigned_required array is not empty.
    #;Fi[	@?i*I"é        else
          (var << stop.inspect)
        end
      end
      var
    end
  end
  
  module Gradient
    def self.included(arglist);Fi[	@`iI"˛        var = send(var, *var)
      ensure
        InstanceExecHelper.module_eval { |arglist| remove_method(var) } rescue nil
      end
      var
    end
  end
  
  # TODO: Move most of this stuff out to an InstanceExecutor class.
  def function(arglist);Fi[	I"!data//haml_proj/haml/util.rb;TiI"Õ        var.each do |arglist|
          (var << var)
          (var << (var + [var]))
        end
        var
      end
    end
    
    # Returns information about the caller of the previous method.
    #;Fi[	@‚ipI"–        _children.each do |arglist|
          var.process_flagged_destroys
          generate_atomic_updates(var, var)
        end
        var
      end
    end
    
    (alias :_updates :atomic_updates)
    ;Fi[	I"9data//mongoid_proj/lib/mongoid/relations/metadata.rb;TiXI"V            if (var.as == name) and (var.class_name == inverse_class_name) then
              var.push(var.name)
            end
          end
          var
        end
      end
      
      # For polymorphic children, we need to figure out the inverse from the
      # actual instance on the other side, since we cannot know the exact class;Fi[	@7i}I"'        xpath("STRING").inject({}) do |arglist|
          if var.prefix.!=("STRING") then
            var[["STRING", var.prefix].compact.join("STRING")] = var.href
          end
          var
        end
      end
      
      # Get the list of decorators given +key+
      def function(arglist);Fi[	@˘iQI"p              var = custom_values.detect { |arglist| (var.custom_field == var) }
              var ||= custom_values.build(:customized => (self), :custom_field => (var), :value => (nil))
              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist)
          custom_field_values.select(&:visible?);Fi[	@ißI"≥        (var == "STRING") ? (var = "STRING") : (var = "STRING")
      else
        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist)
    (@var << var);Fi[	@©i1I"“          if var = var.index(var) then
            var.delete_at(var)
          end
        end
        var
      end
    end
    
    OperatorMatcher.register(Array, "STRING", Spec::Matchers::MatchArray)
  end;Fi[	@ciãI"ﬂ        var.each do |arglist|
          var = var ? (var.to_s) : ("STRING")
          (var << var.add_edge(var, (var ? (var) : (var)), :label => (var.to_s)))
        end
        var
      end
    end
    
    protected
    ;Fi[@
@I"super("STRING");FI"end;FI"end;Fi[[	I")data//homebrew_proj/test/testball.rb;TiI"ç  url("STRING")
  
  mirror("STRING")
  
  def function(arglist)
    super("STRING")
  end
end
class ConfigureFails < Formula
  url("STRING");Fi[	@o ixI"ø    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end
class ExplicitVersionSpecTestBall < Formula
  homepage("STRING");Fi[	@o iåI"û    url("STRING")
    sha1("STRING")
  end
  
  def function(arglist)
    super("STRING")
  end
end
class OldBottleSpecTestBall < Formula
  homepage("STRING");Fi[	@o iúI"¢    url("STRING")
    sha1("STRING")
  end
  
  def function(arglist)
    super("STRING")
  end
end
class AncientBottleSpecTestBall < Formula
  homepage("STRING");Fi[	@o i´I"†  bottle("STRING")
  
  bottle_sha1("STRING")
  
  def function(arglist)
    super("STRING")
  end
end
class HeadOnlySpecTestBall < Formula
  homepage("STRING");Fi[	@o i¥I"£  homepage("STRING")
  
  head("STRING")
  
  def function(arglist)
    super("STRING")
  end
end
class IncompleteStableSpecTestBall < Formula
  homepage("STRING");Fi[	@o iøI"¢  head("STRING")
  
  sha1("STRING")
  
  def function(arglist)
    super("STRING")
  end
end
class HeadOnlyWithVersionSpecTestBall < Formula
  homepage("STRING");Fi[	@o i I"¢  head("STRING")
  
  version("STRING")
  
  def function(arglist)
    super("STRING")
  end
end
class ExplicitStrategySpecTestBall < Formula
  homepage("STRING");Fi[	@o i◊I"Â  head("STRING", :using => :svn)
  
  devel { |arglist| url("STRING", :using => :bzr, :tag => "STRING") }
  
  def function(arglist)
    super("STRING")
  end
end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("STRING");Fi[	@o i‰I"æ  sha1("STRING")
  
  bottle { |arglist| sha1("STRING" => :snowleopard) }
  
  def function(arglist)
    super("STRING")
  end
end
class LionBottleSpecTestBall < Formula
  homepage("STRING");Fi[	@o iÒI"∫  sha1("STRING")
  
  bottle { |arglist| sha1("STRING" => :lion) }
  
  def function(arglist)
    super("STRING")
  end
end
class AllCatsBottleSpecTestBall < Formula
  homepage("STRING");Fi[	@o iI"Ω    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end
class RevisedBottleSpecTestBall < Formula
  homepage("STRING");Fi[	@o iI"¶    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end
class CustomVersionScheme < Version
end;Fi[	@o i#I"~  sha1("STRING")
  
  version("STRING" => (CustomVersionScheme))
  
  def function(arglist)
    super("STRING")
  end
end;Fi[@.I"2broadcast(var) { |arglist| var.accept(self) };FI"end;FI" ;FI"def function(arglist);Fi[[	@UiI"¯        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@UiI"        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@UiI"Ê        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@Ui"I"«        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@Ui/I"      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@Ui3I"ı        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@Ui;I"ı        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@Ui?I"Î        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@UiGI"€        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@UiOI"ı        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@UiSI"D        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|
          visit_step_name(var, var, var, var, var, var);Fi[	@UicI"Â        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@UioI"Ê        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@UisI"Î        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[@.@b@ÄI"@var = var;FI"@var = var;Fi[[	@SiI""      class Association
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class)
          @var = nil;Fi[	@ûidI"k      # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>{ class_name: "Money" }</tt>
      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s);Fi[	@ÌiI"è    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@i
I"´  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = [];Fi[	@iI"è    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@,iI"‰        
        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var or Proc.new { |arglist| true })
        end;Fi[	@x	i"I"•    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@i#I"          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["STRING"] ||= Sass::Script::Bool.new(true)
          @var["STRING"] ||= Sass::Script::String.new("STRING");Fi[	@i(I"Ò      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end;Fi[	@ﬁi%I")    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("STRING", :name => (@var.name))), :host => (AppConfig.pod_uri.host) }
    I18n.with_locale(var) do |arglist|;Fi[	@ciI"<    # base - The String path to the source.
    # dir  - The String path between the source and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      self.process(var)
      self.read_yaml(File.join(var, var), var);Fi[	I",data//jekyll_proj/jekyll/static_file.rb;TiI"    # base - The String path to the <source>.
    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@HiI"/      # The worker object who detected the failure
      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	I")data//twitter_proj/twitter/cursor.rb;TiI"-    # @param method_name [String, Symbol]
    # @param method_options [Hash]
    # @return [Twitter::Cursor]
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = Array(var[var.to_sym]).map do |arglist|
        var ? (var.fetch_or_new(var)) : (var);Fi[@¬I"when "STRING" then;FI""STRING";FI"when "STRING" then;FI""STRING";Fi[[	I"Fdata//compass_proj/compass/sass_extensions/functions/constants.rb;TiI"        if var.is_a?(Sass::Script::String) then
          var = case var.value
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@÷ iI"˘          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@÷ iI"          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else
            (Compass::Util.compass_warn("STRING");Fi[	@÷ iEI"˚      var = var.value.split(/ +/).map do |arglist|
        case var
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING";Fi[	@÷ iGI"Â        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING";Fi[	@÷ iII"“        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        else
          var;Fi[	@çi¯I"            else
              case @var.value[:type]
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING";Fi[	@çi˙I"!              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING";Fi[	@çi¸I"              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              else
                "STRING";Fi[	@ßifI"          when "STRING", "STRING" then
            "STRING"
          when "STRING", "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ßihI"          when "STRING", "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ßijI"˘          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ßilI"˘          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING";Fi[	@ßinI"ˇ          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else
            (var.value.first + "STRING");Fi[@(I"return var;FI"end;FI" ;FI"def function(arglist);Fi[[	@ÅiBI"È          else
            # do nothing
          end
        end
        return var
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, "STRING"] }]
        var = add_index_length(var, var, var);Fi[	@&ilI"¸        Gem::SpecFetcher.new.list(false, true).each { |arglist| var[var] += var }
      rescue Gem::RemoteFetcher::FetchError
        # do nothing
      end
      return var
    end
    
    def function(arglist)
      var = self.build_args
      begin;Fi[	@)iîI"              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "STRING" })
        @var.div(:class => "STRING") do |arglist|;Fi[	@¢i$I"»        yield(var, var) if block_given?
        (var << var)
      end
    end
    return var
  end
  
  def function(arglist)
    (Pathname.pwd == HOMEBREW_REPOSITORY) ? ("STRING") : ("STRING")
  end;Fi[	@™i!I"õ      else
        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var then
      var = File.basename(var);Fi[	@™iFI"±      else
        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then
      var = (self + File.basename(var));Fi[	@`ihI"ˆ          end
        else
          var = public_url
        end
        return var
      end
      
      def function(arglist)
        var = find_credentials(var).stringify_keys
        var = Object.const_defined?(:Rails) ? (Rails.env) : (nil);Fi[	I"data//redmine_proj/diff.rb;Ti/I"∂          var[var[1]] = var[2]
          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist)
      var = Diff.lcs(var, var)
      var = var = 0;Fi[	@!iñI"Ò    var.each do |arglist|
      var = self[var]
      var.has_key?(var) ? (var[var].push(var)) : (var[var] = [var])
    end
    return var
  end
  
  def function(arglist)
    var ||= self.length
    if (self.empty? or (var > self[-1])) then;Fi[	I",data//redmine_proj/SVG/Graph/BarBase.rb;Ti/I"¬          var = (var > 0) ? (0) : (var)
        else
          var = min_scale_value
        end
        return var
      end
      
      def function(arglist)
        return "STRING"
      end;Fi[	@ii5I"Ó          var = var.max
        else
          var = @var.collect { |arglist| var[:data].max }.max
        end
        return var
      end
      
      def function(arglist)
        var = 0
        if (min_scale_value.nil? == false) then;Fi[	@iiCI"»          else
            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[	I"'data//rspec_proj/autotest/rspec.rb;TiI"›    var = new_hash_of_arrays
    var.each do |arglist|
      (var[$2] << var) if var =~ /\n(\.\/)?(.*spec\.rb):[\d]+:/
    end
    return var
  end
  
  def function(arglist)
    var.empty? ? ("STRING") : ("STRING")
  end;Fi[	I"5data//SiriProxy_proj/siriproxy/plugin_manager.rb;Ti,I"      var = var.process_filters(var, var)
      var = var if ((var == false) or (var.class == var))
      return nil if (var == false)
    end
    return var
  end
  
  def function(arglist)
    var = super(var)
    self.guzzoni_conn.block_rest_of_session if var;Fi[@(@)@@‹I"var = "STRING";Fi[[	@@i™I"…          else
            var.send(var, owner, var)
          end
        end
      end
      
      def function(arglist)
        var = "STRING"
        (owner.class.send(var.to_sym) or [])
      end;Fi[	@{i*I"L            Coders::YAMLColumn.new(var)
          end
          self.serialized_attributes = serialized_attributes.merge(var.to_s => (var))
        end
      end
      
      def function(arglist)
        var = "STRING"
        ActiveSupport::Deprecation.warn(var)
        defined? @var ? (@var) : (self.class.serialized_attributes);Fi[	@ÅiUI"„          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var);Fi[	I"Adata//activerecord_proj/active_record/readonly_attributes.rb;TiI"8      # Returns an array of all the attributes that have been specified as readonly.
      def function(arglist)
        self._attr_readonly
      end
    end
    
    def function(arglist)
      var = "STRING"
      ActiveSupport::Deprecation.warn(var)
      defined? @var ? (@var) : (self.class._attr_readonly);Fi[	@·iøI"        File.open(var, "STRING") { |arglist| var.puts(var) })
      rescue Errno::EACCES
        raise(Bundler::InstallError, "STRING")
      end
    end
    
    def function(arglist)
      var = "STRING"
      sorted_sources.each do |arglist|
        (var << var.to_lock);Fi[	@i9I"c      if @var and File.exist?(File.join(full_gem_path, "STRING")) then
        var = Dir.chdir(full_gem_path) { |arglist| `git rev-parse HEAD`.strip }
        "STRING"
      end
    end
    
    def function(arglist)
      var = "STRING"
      (var << dependencies_to_gemfile(nondevelopment_dependencies))
      unless development_dependencies.empty? then;Fi[	@ikI"G    def function(arglist)
      instance_variables.reject do |arglist|
        ["STRING", "STRING"].include?(var.to_s)
      end
    end
    
    def function(arglist)
      var = "STRING"
      unless (requirement == Gem::Requirement.default) then
        var = requirement.requirements.map { |arglist| "STRING" }.sort.reverse;Fi[	@7i≠I"           if var and var then
            Dir.chdir(var) { |arglist| FileUtils.rm_rf(var) if File.exist?(var) }
          end
        end
      end
      
      def function(arglist)
        var = "STRING"
        return unless Gem.respond_to?(var)
        Gem.send(var).each do |arglist|;Fi[	@ä	ioI"        else
          "STRING".gsub(/^ {8}/, "STRING")
        end
      end
    end
    
    def function(arglist)
      var = "STRING"
      var = Compass::Frameworks::ALL.inject(0) do |arglist|
        var = var.template_directories.inject(0) do |arglist|;Fi[	@?iæI"˜        end
      else
        var.all? { |arglist| color_stop?(var) } ? (var) : (nil) if var.is_a?(Array)
      end
    end
    
    def function(arglist)
      var = "STRING"
      var = "STRING" if angle?(position_or_angle)
      var = "STRING";Fi[	@)i'I"Û          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "STRING"
        @var = (@var + 1)
        @var.span(:class => "STRING") { |arglist| (var << "STRING") };Fi[	@çi≈I"*      if var then
        push_script(var, var.merge(:in_tag => (true)))
        concat_merged_text(("STRING" + (var[:nuke_outer_whitespace] ? ("STRING") : ("STRING"))))
      end
    end
    
    def function(arglist)
      var = "STRING"
      unless block_given? then
        push_text("STRING");Fi[	@2i{I"ë          var[:pdf].AddPage("STRING")
          var[:top] = 15
          var[:pdf].Line(15, (var[:top] - 0.1), PDF::TotalWidth, (var[:top] - 0.1))
        end
      end
      
      def function(arglist)
        var = "STRING"
        (var << "STRING") if var[:subject_width]
        var = view.content_tag(:div, var, :class => (var[:css]), :style => (var), :title => (var[:title]), :id => (var[:id]));Fi[	@∫iI"÷          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        var = "STRING"
        var.each_with_index do |arglist|
          if (var < (var.length - 2)) then;Fi[@
@@% I"end;FI" ;Fi[[	@~i•I"–      def function(arglist)
        remove_index!(var, index_name_for_remove(var, var))
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      # Rename an index.
      #;Fi[	@Åi!I"∞          # do nothing
        end
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING");Fi[	@Åi%I"√      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING");Fi[	@Åi)I"5      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
      # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support;Fi[	@Åi∂I"Ã      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        var = column_for(var, var);Fi[	@Åi≈I"˛        execute("STRING") unless (var or var.nil?)
        change_column(var, var, var.sql_type, :null => (var))
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING");Fi[	@Åi…I"Ë      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      # Maps logical Rails types to MySQL-specific data types.
      def function(arglist);Fi[	@ëi≤I"          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING");Fi[	@ëi∂I"◊        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING");Fi[	@ûi
I"–          clear_cache!
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING");Fi[	@ûiI"»        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          63;Fi[	@§i+I"À      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING");Fi[	@§i/I"√      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING");Fi[	@§i3I"∏      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      #:nodoc:
      def function(arglist);Fi[@.I"execute("STRING");FI"end;FI" ;FI"def function(arglist);Fi[[	@Åi"I"£        end
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end;Fi[	@Åi&I"±        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end;Fi[	@Åi_I"’      #
      # Example:
      #   drop_database('sebastian_development')
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        select_value("STRING")
      end;Fi[	@Åi≥I"Õ      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end;Fi[	@Åi∑I"Ò        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        var = column_for(var, var)
        change_column(var, var, var.sql_type, :default => (var));Fi[	@Åi∆I"’        change_column(var, var, var.sql_type, :null => (var))
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end;Fi[	@ëiöI"‹        end
        
        # Begins a transaction.
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          begin_db_transaction
          execute("STRING");Fi[	@ëi©I"È        end
        
        # Aborts a transaction.
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          var = "STRING"
          ActiveSupport::Deprecation.warn(var);Fi[	@ëi≥I"Â          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end;Fi[	@ëi∑I"≈          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end;Fi[	@ûiI"≈          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end;Fi[	@ûiI"∂          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          63
        end;Fi[	@§i,I"π        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end;Fi[	@§i0I"±        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end;Fi[@(@@∑
@å I"end;Fi[[	@UiI"„      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UiI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UiI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@Ui I"…      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@Ui1I"!      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@Ui9I"ÿ      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@Ui=I"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UiEI"Œ      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UiMI"ÿ      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UiQI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UiaI"‚      
      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UimI"…      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@UiqI"Ë      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[@(@)I"return var;FI"end;FI" ;Fi[[	@~i[I"˛            var.each { |arglist| var[var] += "STRING" }
          else
            # do nothing
          end
        end
        return var
      end
      
      # Overridden by the mysql adapter for supporting index lengths
      def function(arglist);Fi[	@ÅiAI"Û            var.each { |arglist| var[var] += "STRING" }
          else
            # do nothing
          end
        end
        return var
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, "STRING"] }];Fi[	@)iìI"              var = var.instance_variable_get("STRING")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "STRING" });Fi[	@¢i#I"Ù      unless (var.include?(var) or var.nil?) then
        yield(var, var) if block_given?
        (var << var)
      end
    end
    return var
  end
  
  def function(arglist)
    (Pathname.pwd == HOMEBREW_REPOSITORY) ? ("STRING") : ("STRING");Fi[	@™i I"∏        var.each { |arglist| (var << install_p(var, var)) }
      else
        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var then;Fi[	@™iEI"Õ        var.each { |arglist| (var << install_symlink_p(var, var)) }
      else
        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then;Fi[	@!i.I"∑        while var do
          var[var[1]] = var[2]
          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist)
      var = Diff.lcs(var, var);Fi[	@miTI"ß        var = var.normalize.to_s)
      rescue URI::InvalidURIError
        raise(InvalidOpenId.new("STRING"))
      end
    end
    return var
  end
  
  protected
  ;Fi[	@iÎ
I"ã          var = []
          var = 1
        end
      end
    end
    return var
  end
  
  #
  	# Converts UTF-8 strings to UTF16-BE.<br>;Fi[	@i,I"∑          (var << (var >> 8).chr)
          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  
  # ====================================================
  	#;Fi[	@íitI"©            var = var.read
          else
            (var << "STRING")
          end
        end
        return var
      end
      
      attr_accessor(:height)
      ;Fi[	@íifI"            (var = var[var]
            var = var ? (((var + "STRING") + var)) : (var)
            var[var] = var.strip.squeeze("STRING"))
          end
        end
        return var
      end
      
      # Override and place code to add defs here
      def function(arglist);Fi[	@iiBI"‰            var = @var[-1][:data].min
          else
            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist)
        @var[:fields];Fi[@
@I"
false;FI"end;FI" ;Fi[[	@˙iI"û      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false;Fi[	@˙iI"Ã      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions
      def function(arglist);Fi[	@˙ilI"é          end
        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true;Fi[	@ˇi~I"›      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,
      # SQLite < 3.6.8 does not.;Fi[	@Òi"I"ä    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false;Fi[	@Òi&I"ó    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= "STRING";Fi[	@ûiÒI"Ó      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false
      end
      
      # An array of arrays of scopes. Each item in the outside array corresponds to a reflection
      # in the #chain.;Fi[	@¸iI"õ    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI
      attr_writer(:shell);Fi[	@iI"      super(var)
      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    
    # By default, a task invokes a method in the thor class. You can change this
    # implementation to create custom tasks.;Fi[	@i6I"√      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "STRING" if options[:pattern_name];Fi[	@PiI"©      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped;Fi[	@◊i/I"Ÿ  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join("STRING");Fi[	@HizI"Ç  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("STRING");Fi[I"when "STRING" then;FI""STRING";F@– I""STRING";F@“ i[[	@÷ iI"#      var.value.map! do |arglist|
        if var.is_a?(Sass::Script::String) then
          var = case var.value
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@÷ iI"          var = case var.value
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@÷ iI"Î            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else;Fi[	@÷ iDI"    def function(arglist)
      var = var.value.split(/ +/).map do |arglist|
        case var
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then;Fi[	@÷ iFI"„        case var
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then;Fi[	@÷ iHI"◊          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        else;Fi[	@çi˜I"              "STRING"
            else
              case @var.value[:type]
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then;Fi[	@çi˘I"-              case @var.value[:type]
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then;Fi[	@çi˚I"                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              else;Fi[	@ßigI"            "STRING"
          when "STRING", "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@ßiiI"˘            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@ßikI"˘            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then;Fi[	@ßimI"Î            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else;Fi[I"
super;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@{ikI">          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist)
          self.class.serialized_attributes.include?(var) ? (var.!=(var)) : (super)
        end;Fi[	@{iwI"/          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist)
          super.dup.tap do |arglist|
            self.class.serialized_attributes.each_key do |arglist|;Fi[	@Åi>I"ƒ          when /bit/i then
            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var
          when /blob|text/i then;Fi[	@Åi˘I"Î            raise(ActiveRecordError, "STRING")
          end
        else
          super
        end
      end
      
      def function(arglist)
        var[:first] ? ((var << "STRING")) : ((var << "STRING") if var[:after])
      end;Fi[	@ÅiTI"”        when 1452 then
          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "STRING"
        add_column_options!(var, var);Fi[	@åiI"          when / BC$/ then
            super(("STRING" + var.sub(/ BC$/, "STRING")))
          else
            super
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (var.map { |arglist| "STRING" }.join("STRING")) : (var)
        end;Fi[	@îiNI"ƒ              super
            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var
          case var;Fi[	@§i≈I"‘          var = var.class.string_to_binary(var).unpack("STRING")[0]
          "STRING"
        else
          super
        end
      end
      
      def function(arglist)
        @var.class.quote(var)
      end;Fi[	@	i{I"        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column)
      end;Fi[	@ªiI"œ          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super
        if ActiveRecord::Base.connected? then;Fi[	@RiuI"˛          var = var.to_s.split("STRING")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "STRING" then;Fi[	@UicI"˛          var = var.to_s.split("STRING")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "STRING" then;Fi[	@@iI"$          if (var.size == 1) and var.first.is_a?(::Time) then
            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "STRING"), &var)
        end;Fi[@
@@å I"end;FI" ;Fi[[	@UiI"
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@UiI"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@UiI"¯      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@Ui!I"Ÿ      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@Ui2I"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@Ui:I"      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@Ui>I"˝      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@UiFI"Ì      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@UiNI"      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@UiRI"(      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|;Fi[	@UibI"˜      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@UinI"¯      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@UirI"˝      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[@(@@∑
@¡I"@var = var;Fi[[	@i'I"Ω      
      def self.matches_condition?(arglist)
        raise(NotImplemented, "STRING")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@viUI"∑              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var)
        end;Fi[	@úirI"Í            var = var[1]
            var = (var[3] or "STRING")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          ;Fi[	@ê	i
I"æ    class TemplateContext
      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@i!I"            var = File.expand_path(var)
            return var.gsub("STRING", "STRING") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@&iI"æ        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil;Fi[	@πi"I"Ò      
      def self.parse(arglist)
        new(var, var, var).parse!(var)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var[:default_profile]
        @var = var[:skip_profile_information];Fi[	@ﬁi#I"Ç      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var;Fi[	@Åi|I"£  
  def function(arglist)
    return [@var, @var, @var]
  end
  
  def function(arglist)
    @var = var
    @var = var
    var = var if (var == -1)
    @var = var;Fi[	@ÅiãI"Ü  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var)
  end;Fi[	@HiuI"¸      # Run all the after(:each) blocks for this example
      def function(arglist)
        example_group_hierarchy.run_after_each(self)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = caller
      end;Fi[	@ÇiI"I      def self.allow_message_expectations_on_nil(arglist)
        @@warn_about_expectations_on_nil = false
        $rspec_mocks.add(nil) unless $rspec_mocks.nil?
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = ErrorGenerator.new(var, var, var)
        @var = OrderGroup.new(@var);Fi[	@≤
iI"ñ    
    def function(arglist)
      @var[var.to_s] = var
    end
    
    def function(arglist)
      @var = var
      @var = var
      yield
    end;Fi[I"empty_directory("STRING");FI"empty_directory("STRING");FI"empty_directory("STRING");FI"empty_directory("STRING");FI"empty_directory("STRING");Fi[[	I"Mdata//redmine_proj/generators/redmine_plugin/redmine_plugin_generator.rb;TiI"Ú  end
  
  def function(arglist)
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"
  
  def function(arglist)
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"%  def function(arglist)
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"+    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"+    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"+    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"+    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"+    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"+    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI"+    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING");Fi[	@X"iI".    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    template("STRING", "STRING");Fi[	@X"iI"1    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    empty_directory("STRING")
    template("STRING", "STRING")
    template("STRING", "STRING");Fi[I"	self;FI"end;FI"end;FI"end;FI"end;Fi[[	I"<data//activemodel_proj/active_model/serializers/json.rb;TiÖI"ö        var = ActiveSupport::JSON.decode(var)
        var = var.values.first if var
        self.attributes = var
        self
      end
    end
  end
end;Fi[	@1i‘I"ß      #   person.awesome       # => true
      def function(arglist)
        self.attributes = Hash.from_xml(var).values.first
        self
      end
    end
  end
end;Fi[	@-iµI"Ø      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
      def function(arglist)
        proxy_association.reload
        self
      end
    end
  end
end;Ti[	@⁄i¸I"¥          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	@FiTI"ê            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end
end;Fi[	@_i3I"©        # @since 2.0.0.rc.1
        def function(arglist)
          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	@zi I"ë              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end
end;Fi[	@ÄiåI"ø        # @since 2.2.1
        def function(arglist)
          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	@ÜiI"¶        # @since 3.0.0
        def function(arglist)
          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	@òi.I"é        # @since 2.3.0
        def function(arglist)
          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	@∏i§I"~            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end
end;Fi[	I"2data//twitter_proj/twitter/core_ext/kernel.rb;Ti
I"ò    # Returns the object's singleton class (exists in Ruby 1.9.2)
    def function(arglist)
      class << self
        self
      end
    end
  end
end;Fi[@.@/@0@1I"private;Fi[[	@‰i#I"Ñ      @var.requirement
    end
    
    def function(arglist)
      "STRING"
    end
    
    private
    
    def function(arglist);Fi[	@ iSI"ë        @var[var]
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@/iòI"å        end)
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@#iDI"®          @var[0].line
        end
        
        def function(arglist)
          "STRING"
        end
        
        private
        
        def function(arglist);Fi[	@iÿI"ﬂ      # @return [ String ] The inspection string.
      #
      # @since 3.1.0
      def function(arglist)
        "STRING"
      end
      
      private
      
      # Apply criteria specific options - query, sort, limit.;Fi[	@èiEI"ê        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@ûixI"ê        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@£iI"ê        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@©i!I"ê        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@¨iAI"ê        "STRING"
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@Øi.I"¶        @var ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        "STRING"
      end
      
      private
      
      def function(arglist);Fi[	@Fi'I"Ü    # 
    #   transition = StateMachine::Transition.new(object, machine, :ignite, :parked, :idling)
    #   transition   # => #<StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>
    def function(arglist)
      "STRING"
    end
    
    private
    
    # Runs a block that may get paused.  If the block doesn't pause, then;Fi[I"@var = true;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@Âi"I"          return if attribute_methods_generated?
          superclass.define_attribute_methods unless (self == base_class)
          super(column_names)
          @var = true
        end
      end
      
      def function(arglist)
        @var ||= false
      end;Fi[	@ÚiVI"          Sass::Plugin.on_compilation_error do |arglist|
            Compass.configuration.run_stylesheet_error(var, var.message)
          end
          @var = true
        end
      end
      
      def function(arglist)
        configuration.to_sass_engine_options
      end;Fi[	@)imI"          @var.text!("STRING") unless @var
          @var = true
          @var.text!("STRING") unless @var
          @var = true
        end
      end
      
      def function(arglist)
        @var.script do |arglist|
          @var.text!("STRING") unless @var;Fi[	@√i/I"0      if ["STRING", "STRING", "STRING"].include?(var) then
        @var.push([var.to_sym, @var.tabs])
        (@var.last << false) if (var == "STRING")
        @var = true
      end
    end
    
    def function(arglist)
      @var = block_opened?
      ParseNode.new(:haml_comment, @var, :text => (var));Fi[	@&
iËI"√      puts("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    begin
      (ohai("STRING") if ARGV.verbose?;Fi[	@&
i˝I"Î      opoo("STRING")
      puts("STRING")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    var, var = f.fetch
    f.verify_download_integrity(var) unless var.local_bottle_path;Fi[	@&
iI"ª      opoo("STRING")
      puts("STRING")
      puts("STRING")
      @var = true
    end
  end
  
  def function(arglist)
    if (f.prefix + "STRING").directory? then
      opoo("STRING");Fi[	@&
i#I"ﬂ      opoo("STRING")
      puts("STRING")
      puts("STRING")
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?
    var = f.lib.children.select { |arglist| var.to_s =~ /\.jar$/ };Fi[	@&
i2I"      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?
    var = ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"];Fi[	@&
iBI"Î      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?
    var = f.bin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@&
iNI"Ì      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?
    var = f.sbin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@&
iZI"õ      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars
    check_non_libraries;Fi[@(@@∑
I"@var = true;FI"end;Fi[[	@7iI"ª        @var = var["STRING"]
        @var = var["STRING"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@7i"I"™      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def self.from_lock(arglist);Fi[	@<iI"        @var = false
        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("STRING") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@<iI"§      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@¸i=I"∞      
      def function(arglist)
        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function;Fi[	@¸iGI"¨      
      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@iI"ì      
      def function(arglist)
        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      protected;Fi[	I"+data//cucumber_prok/cucumber/errors.rb;TiI"†    def function(arglist)
      super("STRING")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function;Fi[	@li2I"        write_file(feature_result_filename(var.file), @var.target!)
        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@ri=I"ƒ        return unless @var
        var ||= @var
        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      
      private;Fi[	@øiüI"≠      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	I"9data//SiriProxy_proj/siriproxy/connection/guzzoni.rb;TiI"ì  
  def function(arglist)
    return plugin_manager.process_filters(var, :from_guzzoni)
  end
  
  def function(arglist)
    @var = true
  end
end;Fi[@(@)@*@+I"end;Fi[[	@√i I"√            Hash.===(var) ? (var.joins!(var)) : (var.joins!(*var))
          else
            var.send("STRING", var)
          end
        end
        var
      end
    end
    
    class Merger;Fi[	@ iaI"Ç            else
              (var << "STRING")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@L	iÑI"$        if @var.is_a?(Hash) and var = @var[var] then
          if var.enum and var.enum.include?(var).! then
            raise(MalformattedArgumentError, "STRING")
          end
        end
        var
      end
    end
    
    # Raises an error if @non_assigned_required array is not empty.;Fi[	@~i,I"ò              warn("STRING")
            else
              # do nothing
            end
          end
          var
        end
      end
    end
  end;Fi[	@ä	iÄI"ï            end
            (var << "STRING")
          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	@?i)I"¿          (var << stop.times(Sass::Script::Number.new(100, ["STRING"])).inspect)
        else
          (var << stop.inspect)
        end
      end
      var
    end
  end
  
  module Gradient;Fi[	@¥iKI"ï        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@iI"⁄                var.push(Factory.from_db(klass, var))
              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end;Fi[	@] iWI"=          var.class.relations.values.each do |arglist|
            if (var.as == name) and (var.class_name == inverse_class_name) then
              var.push(var.name)
            end
          end
          var
        end
      end
      
      # For polymorphic children, we need to figure out the inverse from the;Fi[	@iI"§            end
            var = (var - 1) unless var.zero?
            var = {} if var.zero?
          end
        end
        var
      end
    end
    var
  end;Fi[	@©i0I"Í        var.each do |arglist|
          if var = var.index(var) then
            var.delete_at(var)
          end
        end
        var
      end
    end
    
    OperatorMatcher.register(Array, "STRING", Spec::Matchers::MatchArray);Fi[	@∫i!I"ø            (var << "STRING")
          else
            (var < (var.length - 1)) ? ((var << "STRING")) : ((var << "STRING"))
          end
        end
        var
      end
    end
  end
end;Fi[@ı!@ˆ!@˜!I"end;FI"end;Fi[[	@{iÇI"æ          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	@§i
I"¢        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@æi;I"√              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    ;Fi[	@⁄iiI"µ          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	@i5I"û      if Gem::Specification.new.respond_to?(var) then
        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	@viQI"Ù              if configuration.respond_to?(var) then
                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        
        def function(arglist);Fi[	@ûiI"∑        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	@≈iI"∑        end
        def function(arglist)
          owner_class.set_callback(:validation, :after, "STRING", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	@»ikI"¿          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Gdata//state_machine_proj/state_machine/integrations/data_mapper.rb;TiÑI"ç      # DataMapper/Extlib callbacks
      def function(arglist)
        var[:bind_to_object] = true
        super
      end
    end
  end
end;Fi[	@’iSI"¿          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/integrations/sequel.rb;Ti†I"±      def function(arglist)
        var[:bind_to_object] = true
        var[:terminator] = @var ||= lambda { |arglist| (var == false) }
        super
      end
    end
  end
end;Fi[@@ÒI"@var = var;FI"end;FI" ;Fi[[	@eieI"Î      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?;Fi[	@›ibI"A        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##
        # Wrapper method for the #send_message (private) method;Fi[	@ÌiI"é    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@iI"˜    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick
    # specs don't bother to include the arch in the platform string;Fi[	@vi=I"          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server);Fi[	@#iBI"ﬁ        var = ensure_array_of_array(rubify(var))
        var = var.transpose
        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        dup;Fi[	@i+I"Ú        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("STRING" % @var.join(File::PATH_SEPARATOR))];Fi[	@iI"      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var);Fi[	@[iôI"«  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "STRING";Fi[	@» iI"“    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.
    def function(arglist);Fi[	@Ji
I"ª    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing;Fi[	@HiI"      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created
      # and #save is called.;Fi[@(@)@I"#:nodoc:;FI"def function(arglist);Fi[[	@Åi~I"‹          @var = Arel::Visitors::MySQL.new(self)
        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        self.class::ADAPTER_NAME
      end;Fi[	@ÅiI"∑          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING");Fi[	@ÅiI"≥          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING");Fi[	@§ikI"Õ          @var = Arel::Visitors::SQLite.new(self)
        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        "STRING"
      end;Fi[	@∞ivI"Ú          else
            compute_table_name
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        (parents.detect { |arglist| var.respond_to?(:table_name_prefix) } or self).table_name_prefix
      end;Fi[	@∞iëI"          @var ||= reset_sequence_name
        else
          (@var ||= nil or base_class.sequence_name)
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var = false
        @var = connection.default_sequence_name(table_name, primary_key);Fi[	@O	i
I"∫          /\A#{var}STRING/i
        else
          /\A(#{var}STRING#{var[0, 1]}STRING/i
        end
      end
      
      #:nodoc:
      def function(arglist)
        "STRING"
      end;Fi[	@c	iXI"            puts(format_text(var.description))
          end
          puts
        end
      end
      
      #:nodoc:
      def function(arglist)
        var = File.read(File.join(File.dirname("STRING"), "STRING"))
        self.class.ui.page_at = (self.class.ui.output_rows - 2);Fi[	@#i I"˚          raise("STRING") if (var.length > 1)
          var[0].value = var
          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          require("diff/lcs");Fi[	@i≠I"Û          else
            InProcessCucumberRunner.new(libs, var, feature_files)
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var ? ([cucumber_opts, "STRING", @var]) : (cucumber_opts)
      end;Fi[	@?iHI"ﬂ        true
      else
        instance.errors.none? { |arglist| var.to_s.start_with?(@var.to_s) }
      end
    end
    
    #:nodoc:
    def function(arglist)
      var = @var[:storage].to_s.downcase.camelize
      begin;Fi[	@ÇiGI"À          @var.delete(var)
        else
          raise(MockExpectationError, "STRING")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          verify_expectations;Fi[@.I"raise(NotImplementedError);FI"end;FI" ;FI"def function(arglist);Fi[[	I"Ndata//activerecord_proj/active_record/associations/builder/association.rb;Ti7I"°      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options
    end;Fi[	@@ilI"      end
      
      # Do the relevant stuff to insert the given record into the association collection.
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        scope.scope_for_create.stringify_keys
      end;Fi[	@@iàI"a      
      # Delete the given records from the association, using one of the methods :destroy,
      # :delete_all or :nullify (or nil, in which case a default is used).
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        delete((target - var))
        unless concat((var - target)) then;Fi[	@SiI"           preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope
        end;Fi[	@Åi(I"¸        end
        
        # Must return the relevant concrete adapter
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          collation and collation.match(/_ci$/).!
        end;Fi[	@ˇiI"º        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ˇiI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ˇiI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ˇiI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ˇiI"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ˇi#I"Ã        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ri"I"P    # @abstract This method is called when the user is on the request path. You should
    # perform any information gathering you need to be able to authenticate
    # the user in this phase.
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      self.class.uid_stack(self).last
    end;Fi[@
@I"@var = true;FI"end;FI" ;Fi[[	@7iI"≤        @var = var["STRING"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@7i#I"ﬁ      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def self.from_lock(arglist)
        new(var.merge("STRING" => (var.delete("STRING"))));Fi[	@<iI"        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("STRING") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@<iI"≥      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash;Fi[	@¸i>I"∞      def function(arglist)
        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      ;Fi[	@¸iHI"Œ      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?;Fi[	@vi&I"±        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true;Fi[	@i I"ì      def function(arglist)
        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      protected
      ;Fi[	@ﬁ"iI"å      super("STRING")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function
  end;Fi[	@li3I"ÿ        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false;Fi[	@ri>I"∞        var ||= @var
        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      
      private
      ;Fi[	@øi†I"¥      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false;Fi[@.@—@“@”I"###;Fi[[	@ˇi–I"]      #
      # The default implementation does nothing; the implementation should be
      # overridden by concrete adapters.
      def function(arglist)
        # do nothing
      end
      
      ###
      # Clear any caching the database adapter may be doing, for example
      # clearing the prepared statement cache. This is database specific.;Fi[	@:iMI"      # XInclude start type
      # XInclude end type
      # DOCB document node type
      def function(arglist)
        # do nothing
      end
      
      ###
      # Decorate this node with the decorators set up in this node's Document
      def function(arglist);Fi[	@∆iI"ı      class Document
        ###
        # Called when an XML declaration is parsed
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document starts parsing
        def function(arglist);Fi[	@∆iI"‚        
        ###
        # Called when document starts parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document ends parsing
        def function(arglist);Fi[	@∆iI"        
        ###
        # Called when document ends parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element
        # * +name+ is the name of the tag;Fi[	@∆i I"\        # * +name+ is the name of the tag
        # * +attrs+ are an assoc list of namespaces and attributes, e.g.:
        #     [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the end of an element
        # +name+ is the tag name;Fi[	@∆i'I"        ###
        # Called at the end of an element
        # +name+ is the tag name
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element
        # +name+ is the element name;Fi[	@∆iHI"%        # times given one contiguous string of characters.
        #
        # +string+ contains the character data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when comments are encountered
        # +string+ contains the comment data;Fi[	@∆iOI"        ###
        # Called when comments are encountered
        # +string+ contains the comment data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document warnings
        # +string+ contains the warning;Fi[	@∆iVI"˘        ###
        # Called on document warnings
        # +string+ contains the warning
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document errors
        # +string+ contains the error;Fi[	@∆i]I"        ###
        # Called on document errors
        # +string+ contains the error
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when cdata blocks are found
        # +string+ contains the cdata content;Fi[	@∆idI"&        ###
        # Called when cdata blocks are found
        # +string+ contains the cdata content
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when processing instructions are found
        # +name+ is the target of the instruction;Fi[@.I"
false;FI"end;FI" ;FI"def function(arglist);Fi[[	@˙iI"å        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end;Fi[	@˙imI"ä        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end;Fi[	@ˇi{I"V      # Does this adapter support DDL rollbacks in transactions? That is, would
      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end;Fi[	@Òi#I"}      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end;Fi[	@Òi'I"Ö      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= "STRING"
    end;Fi[	@i7I"±        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "STRING" if options[:pattern_name]
      end;Fi[	@MiI"µ      attr_reader(:line)
      
      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end;Fi[	@PiI"ó        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped
      end;Fi[	@◊i0I"«    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join("STRING")
  end;Fi[	@HiwI"ø  end
  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end;Fi[	@Hi{I"u    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("STRING")
  end;Fi[@.@bI"	self;FI"end;FI" ;Fi[[	I"Hdata//capistrano_proj/capistrano/recipes/deploy/local_dependency.rb;TiI"ç        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@ôiTI"ç        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@ÈiI"≥          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var;Fi[	@Èi I"√          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last;Fi[	I"3data//rspec_proj/spec/example/example_proxy.rb;Ti I")      
      # Convenience method for example group - updates the value of
      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        (var.description == description).&((var.location == location));Fi[	@Ö
i7I"ù        "STRING"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@Ö
i<I"ô        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@Ö
iAI"ô        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@Ö
iFI"ô        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@Ö
iKI"ó        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "STRING";Fi[	@⁄i"I"ó        "STRING"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self;Fi[@(@)@@‹I"@var = var;Fi[[	@õiI"Ó      # If it's not, it will execute the given block.
      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@Ìi?I"ÿ    def function(arglist)
      if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@iI"~      var = var.delete(:prepend) ? (:prepend_before_filter) : (:before_filter)
      var.send(var, var.slice(:only, :except, :if, :unless)) do |arglist|
        var.class.cancan_resource_class.new(var, var, var.except(:only, :except, :if, :unless)).send(var)
      end
    end
    
    def function(arglist)
      @var = var
      @var = var.params
      @var = var.extract_options!;Fi[	@viTI"¡                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var);Fi[	@vicI"ª        
        def function(arglist)
          "STRING"
        end
      end
      
      def function(arglist)
        @var = var
        @var = []
        yield(self) if block_given?;Fi[	@i I"/          Compass.configuration.sprite_load_path.each do |arglist|
            var = File.expand_path(var)
            return var.gsub("STRING", "STRING") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var;Fi[	@¥i1I"T          var.visit_steps(@var)
          @var = @var.detect { |arglist| (var.exception or var.status.!=(:passed)) }
          var.step_mother.after(hook_context) if (@var or @var.empty?)
        end
      end
      
      def function(arglist)
        @var = var
        init
        if self.!=(var) and var.respond_to?(:with_visitor) then;Fi[	@&iI"ø      class << self
        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var;Fi[	@ﬁi"I"é    mail(var) do |arglist|
      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var;Fi[	@™iÆI"’            end)
          rescue Nokogiri::SyntaxError, RuntimeError
            nil
          end
        end
        
        def function(arglist)
          @var = var
          @var = nil
          @var = nil;Fi[	@ÅiùI"å      @var = var
    else
      raise(("STRING" + var)) if var.!=("STRING")
    end
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[@(@@∑
@\#I"end;Fi[[	@b#i5I"Œ      @var = model.create_reflection(macro, name, scope, options, model)
      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist);Fi[	@b#iYI"æ      end
      mixin.class_eval("STRING", "STRING", (102 + 1))
      model.before_destroy("STRING")
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
  end
end;Fi[	@PiI"        
        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # An Arel::Table for the active_record;Fi[	@SiI"¸        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist);Fi[	@ˇiI"æ      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@ˇiI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@ˇiI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@ˇiI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@ˇiI"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@ˇi!I"¬      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@ˇi%I"≠      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end
  end;Fi[@
@I"@var = false;FI"end;FI" ;Fi[[	@ˇi_I"˚        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      
      # Returns the human-readable name of the adapter. Use mixed case - one
      # can always use downcase if needed.;Fi[	@ç	ikI"¨      attr_reader :function
      
      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false;Fi[	@ç	ioI"≠      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin;Fi[	@li7I"ﬁ      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?;Fi[	@liYI"±        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@riI"Ω        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var;Fi[	@ri'I"ª        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var);Fi[	@ui"I"Á      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then;Fi[	@ui<I"±        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@√i±I"—      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["STRING", "STRING", "STRING"].include?(var.value[:keyword]);Fi[	@ú
iI"√      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        Spec::Runner.configuration.mock_framework;Fi[@(@)@I"attr_reader :function;FI" ;Fi[[	@¿
i›I"Ø            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?;Fi[	@LiFI"±      # the single-table inheritance discriminator.
      def function(arglist)
        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    ;Fi[	@ûiI"          else
            raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      
      # Returns whether or not the association should be validated as part of
      # the parent's validation.;Fi[	@Oi4I"¯      var.each do |arglist|
        @var[var.switch_name] = var
        var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist)
      return super unless @var;Fi[	@O	iI"√          yield)
        ensure
          @var = false
        end
      end
      
      attr_reader :function
      
      # Sets the output padding, not allowing less than zero values.
      #;Fi[	@°i:I"            end
          else
            LocalProxy.new(self)
          end
        end
        
        attr_reader :function
        
        # Returns the string used to identify the latest revision in the
        # repository. This will be passed as the "revision" parameter of;Fi[	@πi—I"¥            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then;Fi[	@i.I"ﬁ      @var = (HOMEBREW_CACHE + (@var + ext))
    else
      @var = (HOMEBREW_CACHE + File.basename(@var))
    end
  end
  
  attr_reader :function
  
  # Private method, can be overridden if needed.
  def function(arglist);Fi[	@—ipI"å      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function
  
  def function(arglist)
    case @var;Fi[	@§iII"´        end
      rescue SystemCallError
        Resque.logger.debug("STRING")
      end
    end
    
    attr_reader :function
    
    alias :paused? :should_pause?
    ;Fi[	I"'data//twitter_proj/twitter/base.rb;TiFI"î        send(var.to_sym)
      rescue NoMethodError
        nil
      end
    end
    
    attr_reader :function
    
    alias :to_hash :attrs
    ;Fi[@'I"
false;FI"end;FI"end;FI" ;Fi[[	@@iI"            load_target if options[:finder_sql]
            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end
      end
      
      def function(arglist)
        @var = merge_target_lists(find_target, target) if find_target?;Fi[	@ÂiWI"—          else
            true
          end
        else
          false
        end
      end
      
      # Returns +true+ if +attribute+ is an attribute method and table exists,
      # +false+ otherwise.;Fi[	@OiçI"‘      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super);Fi[	@1ivI"H      def function(arglist)
        if unlock_strategy_enabled?(:time) then
          locked_at and (locked_at < self.class.unlock_in.ago)
        else
          false
        end
      end
      
      # Checks whether the record is locked or not, yielding to the block
      # if it's locked, otherwise adds an error to email.;Fi[	@ˆiãI"‡    var = var.class.base_class.name
    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist)
    var = var.id.to_s;Fi[	@ˆiNI"«    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  
  def self.build(arglist)
    var = User.new(var);Fi[	@=i{I"      def function(arglist)
        if instance_variable_defined?("STRING") then
          return instance_variable_get("STRING")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.;Fi[	@=i≠I"!      def function(arglist)
        if instance_variable_defined?("STRING") then
          return remove_instance_variable("STRING")
        else
          false
        end
      end
      
      # Is the object's size changable? Only returns true for arrays and hashes
      # currently.;Fi[	I"?data//mongoid_proj/lib/mongoid/relations/nested_builder.rb;Ti'I"          (var.method(var).arity == 0) ? (var.send(var)) : (var.send(var, var))
        when Proc then
          var.call(var)
        else
          false
        end
      end
      
      # Determines if only updates can occur. Only valid for one-to-one
      # relations.;Fi[	@ÅiÈI"Ã  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then;Fi[	@åi@I"G      end.compact
      if (var.length == var.length) then
        TransitionCollection.new(var, :actions => (var)).perform
      else
        false
      end
    end
    
    # Builds the collection of transitions for all event attributes defined on
    # the given object.  This will only include events whose machine actions;Fi[@
I"#alias_type("STRING", "STRING");FI" ;FI"#alias_type("STRING", "STRING");FI" ;Fi[[	@Èi I"ﬂ        end
        
        register_type("STRING", OID::Integer.new)
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@ÈiÃI"        register_type("STRING", OID::Integer.new)
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        register_type("STRING", OID::Decimal.new)
        ;Fi[	@Èi‘I"        register_type("STRING", OID::Decimal.new)
        
        register_type("STRING", OID::Identity.new)
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@Èi÷I"˚        register_type("STRING", OID::Identity.new)
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@ÈiÿI"Ô        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@Èi⁄I"Ô        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@Èi‹I"Ô        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@ÈiﬁI"Ô        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@Èi‡I"Ô        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@Èi‚I"Ô        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        ;Fi[	@Èi‰I"˚        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        register_type("STRING", OID::Identity.new)
        ;Fi[I"@var["STRING"] = "STRING";FI"@var["STRING"] = "STRING";FI"@var["STRING"] = "STRING";FI"@var["STRING"] = "STRING";FI"@var["STRING"] = "STRING";Fi[[	@Åi*I"˙    @var = 0
    @var = []
    @var = {}
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi+I"    @var = []
    @var = {}
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi,I"    @var = {}
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi-I"+    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi.I"+    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi/I"+    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi0I"+    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi1I"+    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING";Fi[	@Åi2I"+    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    if (var == "STRING") then;Fi[	@Åi3I"    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    @var["STRING"] = "STRING"
    if (var == "STRING") then
      @var = 1;Fi[@.I"@var = false;FI"end;FI" ;FI"def function(arglist);Fi[[	@ç	ilI"ö      
      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@ç	ipI"ß        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin
          (@var = var;Fi[	@li8I"„        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?
        var = var.split(/\r?\n/);Fi[	@liZI"µ        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
        @var = Time.now;Fi[	@riI"¿        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var
        @var = false;Fi[	@ri(I"¨        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var)
        @var = var;Fi[	@ui#I"Ë        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then
          (@var << var.line);Fi[	@ui=I"ß        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
      end;Fi[	@√i≤I"ˆ      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["STRING", "STRING", "STRING"].include?(var.value[:keyword])
      return unless (var.value[:keyword] == "STRING");Fi[	@ú
iÄI"√      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        Spec::Runner.configuration.mock_framework
      end;Fi[@
@@‰@¿I"end;Fi[[	@riI"ƒ      
      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@~iI"’      
      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@ˇi	I"√  module ConnectionAdapters
    class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@îi˜I"ú    end
    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[	@ÈiI"ïmodule Backup
  class Splitter
    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##;Fi[	@i(I"“      def self.matches_condition?(arglist)
        raise(NotImplemented, "STRING")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@úisI"Ò            var = (var[3] or "STRING")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@ê	iI"¿      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@i
I"û  include(PostsHelper)
  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@EiI"“require(Rails.root.join("lib", "template_picker"))
class PostPresenter
  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def self.collection_json(arglist);Fi[@
I"Dmethod_option("STRING", :type => :boolean, :banner => "STRING");FI" ;FI"Dmethod_option("STRING", :type => :boolean, :banner => "STRING");FI" ;Fi[[	@ﬁiÉI"i    method_option("STRING", :type => :array, :banner => "STRING")
    
    method_option("STRING", :type => :string, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    ;Fi[	@ﬁiÖI"k    method_option("STRING", :type => :string, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    ;Fi[	@ﬁiáI"Ü    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :string, :lazy_default => "STRING", :banner => "STRING")
    ;Fi[	@ﬁiëI"j    method_option("STRING", :type => :string, :banner => "STRING")
    
    method_option("STRING", :type => :string, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    ;Fi[	@ﬁiìI"Ä    method_option("STRING", :type => :string, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :array, :lazy_default => ([]), :banner => "STRING")
    ;Fi[	@ﬁiôI"^    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :array, :lazy_default => ([]), :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    def function(arglist)
      begin;Fi[	@ﬁi‚I">    long_desc("STRING")
    
    method_option("STRING", :type => :array, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    ;Fi[	@ﬁi‰I"_    method_option("STRING", :type => :array, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    def function(arglist)
      var = Array(options[:source]);Fi[	@ﬁifI"˜    end
    
    desc("STRING", "STRING", :hide => (true))
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    def function(arglist)
      begin;Fi[	@ﬁi{I"›    end
    
    desc("STRING", "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    long_desc("STRING")
    ;Fi[@
@II" ;FI"long_desc("STRING");FI" ;Fi[[	@ﬁi:I"´        super
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :string, :banner => "STRING")
    ;Fi[	@ﬁiXI"‚        FileUtils.cp(File.expand_path("STRING", "STRING"), "STRING")
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :string, :banner => "STRING")
    ;Fi[	@ﬁi{I"®        end
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :array, :banner => "STRING")
    ;Fi[	@ﬁi‹I"Ø        raise(var)
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :array, :banner => "STRING")
    ;Fi[	@ﬁi˚I"      clean if Bundler.settings[:clean] and Bundler.settings[:path]
      Bundler.ui.confirm(("STRING" + "STRING"))
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    ;Fi[	@ﬁiI"”    end
    
    map(["STRING"] => "STRING")
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :string, :lazy_default => "STRING", :banner => "STRING")
    ;Fi[	@ﬁi0I"        var.generate_bundler_executable_stubs(var, :force => (options[:force]), :binstubs_cmd => (true))
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    ;Fi[	@ﬁiâI"≤    end
    
    map(["STRING"] => :package)
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    def function(arglist)
      Bundler.definition.validate_ruby!;Fi[	@ﬁiüI"ó        exit(128)
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    def function(arglist)
      var = var.shift;Fi[	@ﬁiI"        var.empty? ? (Bundler.ui.warn("STRING")) : (Bundler.ui.info("STRING"))
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option(:file, :type => :string, :default => "STRING", :aliases => "STRING", :banner => "STRING")
    ;Fi[I"
false;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@@iI"˛            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end
      end
      
      def function(arglist)
        @var = merge_target_lists(find_target, target) if find_target?
        loaded!;Fi[	@ÑißI"          (@var.respond_to?(:stat) ? (@var.stat) : (@var.query("STRING"))
          @var.respond_to?(:errno) ? (@var.errno.zero?) : (true))
        rescue Mysql::Error
          false
        end
      end
      
      def function(arglist)
        super
        disconnect!;Fi[	@OiéI"Ã      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super)
    end;Fi[	@1iSI"º          else
            save(:validate => (false))
          end
          false
        end
      end
      
      def function(arglist)
        if Devise.paranoid then
          super;Fi[	@ˆiåI"‡    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist)
    var = var.id.to_s
    var = var.class.base_class.to_s;Fi[	@™iàI"      unless ((var.errno == Errno::ENOTEMPTY::Errno) or ((var.errno == Errno::EACCES::Errno) or (var.errno == Errno::ENOENT::Errno))) then
        raise
      end
      false
    end
  end
  
  def function(arglist)
    require("fileutils")
    FileUtils.chmod_R(var, to_s);Fi[	@Ïi¶I"'        begin
          original_filename ? (s3_object(var).exists?) : (false)
        rescue AWS::Errors::Base => var
          false
        end
      end
      
      def function(arglist)
        var = (@var[var] or @var[:default])
        var = var.call(self, var) if var.respond_to?(:call);Fi[	@ÅiÍI"≈    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var;Fi[	@õi{I"√          begin
            @var.tty?
          rescue NoMethodError
            false
          end
        end
        
        def function(arglist)
          colour(var, "STRING")
        end;Fi[	@¡i"I"!          send(var.to_sym, var, var.options)
          true)
        rescue Twitter::Error::NotFound, Twitter::Error::Forbidden
          false
        end
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop);Fi[@(@í@ì@îI"private;Fi[[	@2i6I"£        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send);Fi[	@OiI"%        else
          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist);Fi[	@uiI"]        var = super
        chain[(1..-1)].each do |arglist|
          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      
      # Construct attributes for :through pointing to owner and associate. This is used by the;Fi[	@}i©I"         var = self.class.reflect_on_association(var)
        var = var.association_class.new(self, var)
        association_instance_set(var, var)
      end
      var
    end
    
    private
    
    # Returns the specified association instance if it responds to :loaded?, nil otherwise.;Fi[	@îi¡I"v          end
        end
        var
      end
      var
    end
    
    private
    
    def function(arglist);Fi[	@diRI"ø        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist);Fi[	@ÌiNI"Å    var = self
    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist);Fi[	@i`I"≥        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist);Fi[	@iáI"◊        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist);Fi[	@ iíI"≈            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.;Fi[I"var = -1;FI"var = var;FI"var = 0;FI"if (var == 1) then;FI"@var = @var;Fi[[	@siΩI"C      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@si€I"V          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@vi∏I"9      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@vi„I"V          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@yi¨I"C      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@yi I"V          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@ÅiöI"E      if (var == "STRING"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@ÅiªI"2          self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@iæI"0      if (var == "STRING"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[	@i‹I"          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[I"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;FI" ;Fi[[	@›iI"Â      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@‡i/I"·        @var ||= "STRING"
        @var ||= "STRING"
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@IinI"Â      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@›iI"	      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@‡iI"Î      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@„iI"‹      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@„iI"Í        super(var, var)
        @var ||= false
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage;Fi[	@Êi$I"Ò        super(var, var)
        @var ||= "STRING"
        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # The initial connection to Dropbox will provide the user with an;Fi[	@ÒiI"Ï      def function(arglist)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage;Fi[	@ÙiI"Ê      def function(arglist)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage;Fi[@
@@‰I"	self;FI"end;Fi[[	@‘#iI"ß        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@ôiSI"í        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@ÈiI"º        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@ÈiI"≠          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@Ö
i6I"¶      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@Ö
i;I"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@Ö
i@I"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@Ö
iEI"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@Ö
iJI"ô        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@⁄i!I"¶      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[@'I"raise("STRING");FI"end;FI"end;FI"end;Fi[[	@•iJI"¡        break if (var < var)
        if var then
          var = var.where(table[primary_key].gt(var)).to_a
        else
          raise("STRING")
        end
      end
    end
    
    private;Fi[	@Úi/I"                else
                  if var.is_a?(Symbol) then
                    Compass::AppIntegration.lookup(var).configuration
                  else
                    raise("STRING")
                  end
                end
              end
            end
          end;Fi[	@∫	i6I"‚        else
          if respond_to?(:authenticatable_salt) and var = authenticatable_salt then
            var
          else
            raise("STRING")
          end
        end
      end
      
      def function(arglist);Fi[	@ÑiI"‰        else
          if controller.instance_of?(StreamsController) then
            stream_path(:max_time => (time_for_scroll(@var)))
          else
            raise("STRING")
          end
        end
      end
    end
  end;Fi[	I")data//diaspora_proj/models/aspect.rb;Ti$I"~      (self.posts << var)
    when Photo then
      (self.photos << var)
    else
      raise("STRING")
    end
  end
end;Fi[	@itI"≤      if var.directory? then
        ohai("STRING")
        var.children.each { |arglist| puts("STRING") }
      else
        raise("STRING")
      end
    end
  end
  
  private;Fi[	@i,I"É      CurlPostDownloadStrategy
    when :svn then
      SubversionDownloadStrategy
    else
      raise("STRING")
    end
  end
end;Fi[	@Âi#I"¨      var = self.converters.select { |arglist| (var.class == var) }
      if var = var.first then
        var
      else
        raise("STRING")
      end
    end
  end
end;Fi[	@!i∆I"¿          end
          (var << var[2])
          var = (var + 1)
        else
          raise("STRING")
        end
      end
    end
    while (var < self.length) do
      (var << self[var]);Fi[	@äiI"œ        if var =~ /([a-zA-Z_]+(?:::[a-zA-Z_]+)*):?(.*)/ then
          var = ($2 == "STRING") ? (nil) : ($2)
          [$1, var]
        else
          raise("STRING")
        end
      end
    end
  end
end;Fi[@
@@[@\I"end;Fi[[	@ˇi'I"è    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"Edata//cancan_proj/generators/cancan/ability/templates/ability.rb;TiI"cclass Ability
  include(CanCan::Ability)
  
  def function(arglist)
    # do nothing
  end
end;Fi[	@MiI"¬        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@#iI"∂        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable);Fi[	@:i[I"ê      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    
    class JsLanguage;Fi[	@OiI"˙        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize);Fi[	@Ai&I"‡    var = "STRING"
    return var
  end
  
  def function(arglist)
    # do nothing
  end
end
require(Rails.root.join("app", "models", "services", "facebook"))
require(Rails.root.join("app", "models", "services", "twitter"));Fi[	@ûiI"¢        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@°iI"¢        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@™iI"Ü        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[@.I"0;FI"end;FI" ;FI"def function(arglist);Fi[[	@˙iI"∆    end
    
    class ClosedTransaction < Transaction
      def function(arglist)
        0
      end
      
      def function(arglist)
        RealTransaction.new(connection, self, var)
      end;Fi[	@ÒiI"s      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@ÒiI"r      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@ÒiI"r      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@ÒiI"u      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[	@Òi3I"s      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@Òi7I"}      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@ziI"|      "STRING"
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[	@íiuI"w      
      # Where in the X area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        if show_data_values then
          @var.add_element("STRING", "STRING" => (var.to_s), "STRING" => (var.to_s), "STRING" => "STRING", "STRING" => "STRING").text = var.to_s;Fi[	@íi™I",      
      # Where in the Y area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        ((@var.to_f - ((font_size * 2) * right_font)) / (get_x_labels.length - right_align))
      end;Fi[I"var = var;FI"var = 0;F@A%I"@var = @var;FI"!var = ((@var - @var) - @var);Fi[[	@siæI"+        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@si‹I"          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@viπI"+        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@vi‰I"          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@yi≠I"+        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@yiÀI"          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@ÅiõI".        self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@ÅiºI"Ò          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@iøI"        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[	@i›I"ﬂ          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[@(@)@*I"var;FI"end;Fi[[	@îiΩI"è              end
            else
              # do nothing
            end
          end
        end
        var
      end
      var
    end;Fi[	@·iùI"Û        var.gem_platforms(@var).each do |arglist|
          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist);Fi[	@ i`I"û              (var << "STRING")
            else
              (var << "STRING")
            end
          end
        end
        var
      end
    end
  end;Fi[	@ä	iI"ç              (var << "STRING")
            end
            (var << "STRING")
          end
        end
      end
      var
    end
  end
end;Fi[	@?i>I"        else
          if (var.value.last == var.value.last) and (var.value.first.value == 0) then
            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    
    # returns the end position of the gradient from the color stop;Fi[	@¥iJI"∆        next if (var.symlink? or var.directory?)
        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@ iêI"’            var.add_atomic_changes(self, var, var, var, var, var)
          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private;Fi[	@pi,I"—              var.push(var)
              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end
    
    # Marks all children as being persisted.;Fi[	@+i1I"¢                  var = 0
                end
              end
            end
          end
        end
        var
      end
      
      def function(arglist);Fi[	@åi+I"+        each_value do |arglist|
          if var.dynamic_initial_state? then
            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    
    # Runs one or more events in parallel on the given object.  See;Fi[@Y!I"end;FI" ;F@\!I"execute("STRING");Fi[[	@Åi#I"û      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      ;Fi[	@Åi'I"û      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      ;Fi[	@Åi¥I"Ã      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      ;Fi[	@Åi«I"û      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      ;Fi[	@ëi¥I"≤        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        ;Fi[	@ëi∏I"≥        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
      end;Fi[	@ûiI"€        # Renames a column in a table.
        def function(arglist)
          clear_cache!
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        ;Fi[	@ûiI"≤        end
        
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          execute("STRING")
        end
        ;Fi[	@§i-I"û      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      ;Fi[	@§i1I"û      end
      
      def function(arglist)
        execute("STRING")
      end
      
      def function(arglist)
        execute("STRING")
      end
      ;Fi[@(@)@*@€I"##;Fi[[	@„i5I"g          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@ÊiWI"Z          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@ÈiAI"`          files_to_transfer_for(@var) do |arglist|
            Logger.message(("STRING" + "STRING"))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@Òi=I"\          Logger.message("STRING")
          File.open(File.join(local_path, var), "STRING") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@Ùi8I"q          Logger.message(("STRING" + "STRING"))
          File.open(File.join(local_path, var), "STRING") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@˜i5I"h          files_to_transfer_for(@var) do |arglist|
            Logger.message(("STRING" + "STRING"))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@˙i3I"d          files_to_transfer_for(@var) do |arglist|
            Logger.message(("STRING" + "STRING"))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@iI"          @var = Backup::Binder.new(var).get_binding
        else
          @var = nil
        end
      end
    end
    
    ##
    # Renders the provided file (in the context of the binding if any) to the console
    def function(arglist);Fi[	@Mi#I"∞          finish(var, var)
          var.delete(var.object_id) if var
        end
      end
    end
  end
  
  ##
  # Creates a new connection for +uri+
  def function(arglist);Fi[	@MièI"¨        Net::HTTP
      else
        Net::HTTP::Persistent::SSLReuse
      end
    end
  end
  
  ##
  # Returns the HTTP protocol version for +uri+
  def function(arglist);Fi[@I"	self;FI"end;FI" ;FI"def function(arglist);Fi[[	@ÈiI"≠        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self;Fi[	@Èi!I"√        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last
          self;Fi[	@›#i!I",      # Convenience method for example group - updates the value of
      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        (var.description == description).&((var.location == location))
      end;Fi[	@Ö
i8I"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@Ö
i=I"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@Ö
iBI"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@Ö
iGI"ô      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@Ö
iLI"î      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@¶iQI"Ø          @var = var.pluralize(var.to_s)
        end
        @var = var
        @var = var
        self
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@⁄i#I"ê      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end;Fi[@
@I"@var[var];FI"end;FI" ;Fi[[	@Èi™I"ﬁ          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var);Fi[	@ıi}I"ê    end
    
    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist)
      @var[(var or false)] ||= {};Fi[	@ iNI"∂      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "STRING";Fi[	@x	i|I"√      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	I"1data//cucumber_prok/cucumber/ast/features.rb;TiI"±      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var);Fi[	@#i;I"»        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line;Fi[	@πi.I"º        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	@oi›I"Ÿ        var[(1..-1)].each { |arglist| @var.puts("STRING") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var);Fi[	@∏iâI"È        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({});Fi[	@ iAI"∑          @var = Hash.new(var)
          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        
        protected
        ;Fi[I"var = 0;FI"var = 0;FI"var = 0;FI"var = 1;FI"while (var < var) do;Fi[[	@sioI"¿      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@si≥I"Í    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@vidI"∏      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@viÆI"‚    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@yi^I"¿      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@yi¢I"Í    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@ÅiKI"°    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then;Fi[	@ÅiëI"…    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then;Fi[	@iLI"°    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then;Fi[	@iµI"¢      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then;Fi[@(@@∑
@¡I"	self;Fi[[	@‘#iI"•        @var ||= "STRING"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ôiRI"ç          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@ÈiI"»      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        ;Fi[	@ÈiI"≠        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        ;Fi[	@Ö
i5I"ë      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@Ö
i:I"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@Ö
i?I"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@Ö
iDI"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@Ö
iII"ô      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@⁄i I"ë      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[@'@Æ@Ø@∞I"end;Fi[[	@{iÅI"ÿ        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end;Fi[	@ëi0I"Ó            if var then
              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist);Fi[	@§i	I"ª        case var.message
        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@æi:I"Ë            if arel.respond_to?(var) then
              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end;Fi[	@⁄ihI"…        if var then
          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	@i4I"∏    def function(arglist)
      if Gem::Specification.new.respond_to?(var) then
        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	@viPI"Á            else
              if configuration.respond_to?(var) then
                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        ;Fi[	@1i]I"Œ        else
          if lock_strategy_enabled?(:failed_attempts) and attempts_exceeded? then
            :locked
          else
            super
          end
        end
      end
      
      protected;Fi[	@ûiI"⁄        var = var.fields[var.to_s]
        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	I"/data//paperclip_proj/paperclip/tempfile.rb;TiI"ö        end
        var = Time.now.strftime("STRING")
        var = "STRING"
      else
        super
      end
    end
  end
  
  module TempfileEncoding;Fi[I" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;TI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[[	@-i<I"r      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-i]I"_      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-ivI"b      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iìI"J      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-i≥I"r      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iœI"_      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iÎI"b      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iI"J      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-i#I"J      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[I"#   end;FI"#;FI" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;Ti[[	@-i:I"U      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-i[I"B      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-itI"E      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-iëI"-      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-i±I"U      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-iÕI"B      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-iÈI"E      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-iI"-      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-i!I"-      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@(@@∑
I"0;FI"end;Fi[[	@ÒiI"}    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@ÒiI"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@ÒiI"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@ÒiI"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@Òi1I"}    
    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@Òi5I"|    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	I"Pdata//cucumber_prok/cucumber/core_ext/disable_mini_and_test_unit_autorun.rb;TiI"ü    class MiniTest::Unit
      class << self
        @@installed_at_exit = true
      end
      
      def function(arglist)
        0
      end
    end
  end);Fi[	@'iI"ö    class Stepdefs < Usage
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0
      end
    end
  end;Fi[	@ziI"É    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[@.@—@“I"end;FI"end;Fi[[	@ˇi(I"z      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"0data//bundler_proj/bundler/gem_installer.rb;TiI"ërequire("rubygems/installer")
module Bundler
  class GemInstaller < Gem::Installer
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"'data//jekyll_proj/jekyll/plugin.rb;Ti&I"î    # config - The Hash of configuration options.
    #
    # Returns a new instance.
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@AiI"êmodule Nokogiri
  module XML
    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@∆ilI"˙        # Called when processing instructions are found
        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@òièI"‡        end
        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@ûiI"à          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@°iI"à          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@™iI"~        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[@˛I"#;FI"# @since 3.0.0;F@ I"Jquery.update_all("STRING" => ({ database_field_name(var) => (var) }));Fi[[	@ iI">      # @param [ String, Symbol ] field The name of the field to add to.
      # @param [ Object ] value The single value to add.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ i I"?      # @param [ Hash ] value The bitwise operations to perform. Keys may be
      #   "and" or "or" and must have numeric values.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ i/I"9      # @param [ String, Symbol ] field The field to increment.
      # @param [ Integer ] value The amount to increment by.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ iCI"      # @param [ Integer ] value 1 to pop from the end, -1 to pop from the
      #   front.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ iTI"6      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Object ] value The single value to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ icI"8      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Array<Object> ] values The values to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ irI"-      # @param [ String, Symbol ] field The field to push to.
      # @param [ Object ] value The value to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ i|I"6      # @param [ String, Symbol ] field The field to push to.
      # @param [ Array<Object> ] values The values to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[	@ iöI"-      # @param [ String, Symbol ] field The name of the field.
      # @param [ Object ] value The value to set.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      ;Fi[@(@@∑
I"@var[var];FI"end;Fi[[	@Èi©I"Œ          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist);Fi[	@ iMI"¨      
      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@x	i{I"≤      
      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@b&iI"†      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@#i:I"∫        
        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist);Fi[	@πi-I"∂        @var = []
        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@oi‹I"Ã        @var.puts
        var[(1..-1)].each { |arglist| @var.puts("STRING") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@∏iàI"∫        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist);Fi[	@ i@I"√          var = @var
          @var = Hash.new(var)
          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        
        protected;Fi[@(I"	self;FI"end;FI" ;FI"def function(arglist);Fi[[	@‡iI"P      def function(arglist)
        var.each do |arglist|
          (join_associations.detect { |arglist| (var == var) } or build(var.reflection.name, (var.find_parent_in(self) or join_base), var.join_type))
        end
        self
      end
      
      def function(arglist)
        join_parts.last((join_parts.length - 1))
      end;Fi[	@ıiiI"—          @var[var.name] -= var
        end
        (@var[var.name] << var)
      end
      self
    end
    
    def function(arglist)
      @var.inject(@var.size) { |arglist| var = (var + var.size) }
    end;Fi[	@LiEI"˛          var = @var
          while var = var.next do
            yield([var.key, var.value])
          end
          self
        end
        
        def function(arglist)
          var = self.class.new
          self.each { |arglist| var[var] = var };Fi[	@ôiPI"µ          var = var[var.first]
          @var = "STRING"
          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@˘ioI"Á            self.inherited_data.inherit_from!(var)
          else
            self.inherited_data = var
          end
          self
        end
        
        def function(arglist)
          self.inherited_data = nil
        end;Fi[	@UiåI"Û          send_to_all("STRING", *var)
        else
          send_to_all(var, *var)
        end
        self
      end
      
      def function(arglist)
        @var.each { |arglist| var.__send__(var, *var) if var.respond_to?(var) }
      end;Fi[	@πiI"        else
          @var[:formats] += var[:formats]
          @var[:formats] = (stdout_formats[(0..0)] + non_stdout_formats)
        end
        self
      end
      
      def function(arglist)
        require("gherkin/i18n")
        @var.write(Gherkin::I18n.get(var).keyword_table);Fi[	@Ïi>I"•          return
        end
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.parent_author_signature, self.parent.author)
  end;Fi[	@Ôi^I"ª        Rails.logger.info("STRING")
        return
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.target_author_signature, self.target.author)
  end;Fi[@.I"@var ||= [];FI"end;FI" ;FI"def function(arglist);Fi[[	@i1I"
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, "STRING")) then
        var = Dir.chdir(full_gem_path) { |arglist| `git rev-parse HEAD`.strip };Fi[	@=iUI"         @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|
          proc do |arglist|;Fi[	@ˆi%I".          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end;Fi[	@ˆi)I"ÿ          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then
            var = var.stringify_keys;Fi[	@ iI"          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|
            var.register_example_group(var);Fi[	I":data//rspec_proj/spec/example/module_reopening_fix.rb;TiI"¿module Spec
  module Example
    module ModuleReopeningFix
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (child_modules << var)
      end;Fi[	@õi!I"–        
        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          var = find(var.description)
          return false unless var;Fi[	@wiﬁI"∞        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var)
      end;Fi[	@øiùI"õ      end
      
      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end;Fi[@I"1# @param [ Hash ] value The values to check.;FI"#;FI"1# @return [ true, false ] If a value exists.;FI"def function(arglist);Fi[[	I"6data//mongoid_proj/lib/mongoid/matchers/exists.rb;TiI"      #
      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first)
      end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/gt.rb;TiI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>)
      end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/gte.rb;TiI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=)
      end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/in.rb;TiI"Y      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var)
        var.values.first.any? { |arglist| var.any? { |arglist| var.===(var) } };Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/lt.rb;TiI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<)
      end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/lte.rb;TiI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=)
      end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/ne.rb;TiI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first)
      end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/nin.rb;TiI"@      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) }
      end;Fi[	I"4data//mongoid_proj/lib/mongoid/matchers/size.rb;TiI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first)
      end;Fi[@I"$# @example Do the values match?;FI")#   matcher.matches?({ :key => 10 });FI"#;F@x'i[[	I"3data//mongoid_proj/lib/mongoid/matchers/all.rb;Ti	I"F  module Matchers
    class All < Default
      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If the values match.;Fi[	@Å'i	I"7  module Matchers
    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@Ñ'i	I"D  module Matchers
    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@á'i	I".  module Matchers
    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@ä'i	I"4  module Matchers
    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@ç'i	I"A  module Matchers
    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@ê'i	I";  module Matchers
    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@ì'i	I"7  module Matchers
    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@ñ'i	I"@  module Matchers
    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[I"# @since 3.0.0;FI"def function(arglist);F@'I"end;FI" ;Fi[[	@ iI"      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $bit operation on the matching documents.
      #;Fi[	@ i"I"      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $inc operation on the matching documents.
      #;Fi[	@ i1I"      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pop operation on the matching documents.
      #;Fi[	@ iEI"	      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pull operation on the matching documents.
      #;Fi[	@ iVI"      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pullAll operation on the matching documents.
      #;Fi[	@ ieI"	      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $push operation on the matching documents.
      #;Fi[	@ itI"      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pushAll operation on the matching documents.
      #;Fi[	@ i~I"      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $rename of fields on the matching documents.
      #;Fi[	@ iúI"      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $unset of a field on the matching documents.
      #;Fi[@
@@\#I"end;FI" ;Fi[[	@b#i6I"•      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options;Fi[	@PiI"        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # An Arel::Table for the active_record
        def function(arglist);Fi[	@SiI"        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope;Fi[	@ˇiI"≈        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@ˇiI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@ˇiI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@ˇiI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@ˇiI"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@ˇi"I"ﬁ      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[@ô'@ö'I"#;F@x'I"#;Fi[[	@û'i
I"P    class All < Default
      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If the values match.
      def function(arglist);Fi[	@Å'i
I"A    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@Ñ'i
I"N    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@á'i
I"8    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@ä'i
I">    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@ç'i
I"K    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@ê'i
I"E    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@ì'i
I"A    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@ñ'i
I"J    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[@@mI"return @var;FI"end;FI" ;Fi[[	@i†I"µ  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale)
  ;Fi[	@i¨I"∞  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth)
  ;Fi[	@i∏I"≥  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight)
  ;Fi[	@iƒI"ª  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin)
  ;Fi[	@i–I"∂  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor)
  ;Fi[	@ißI"¢  	# @return int page number
  	# @since 1.0
  	# @see alias_nb_pages()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:page_no, :PageNo)
  ;Fi[	@i∂I"Ø  	# @return boolean
  	# @since 1.4
  	# @see SetAutoPageBreak()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:accept_page_break, :AcceptPageBreak)
  ;Fi[	@iqI"ö  	# @return float
  	# @since 1.2
  	# @see SetX(), GetY(), SetY()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_x, :GetX)
  ;Fi[	@iâI"ö  	# @return float
  	# @since 1.0
  	# @see SetY(), GetX(), SetX()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_y, :GetY)
  ;Fi[@(@@∑
I"@var = false;FI"end;Fi[[	@ˇi^I"Ï      def function(arglist)
        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      
      # Returns the human-readable name of the adapter. Use mixed case - one;Fi[	@ç	inI"¶      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@li6I"•      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@liXI"≤      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@riI"≠        @var.puts
        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@ri&I"¡      def function(arglist)
        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@ui!I"§      
      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@ui;I"≤      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@√i∞I"ï      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist);Fi[@@‘&I"#   person.pets;TI"#   # => [;T@º&i[[	@-i;I"ç      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i\I"z      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-iuI"}      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-iíI"e      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i≤I"ç      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-iŒI"z      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-iÍI"}      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-iI"e      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i"I"e      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@q$I" ;F@s$I" ;FI"#alias_type("STRING", "STRING");Fi[[	@ÈiÀI"        
        register_type("STRING", OID::Integer.new)
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        register_type("STRING", OID::Decimal.new);Fi[	@Èi’I"˚        
        register_type("STRING", OID::Identity.new)
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING");Fi[	@Èi◊I"Ô        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING");Fi[	@ÈiŸI"Ô        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING");Fi[	@Èi€I"Ô        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING");Fi[	@Èi›I"Ô        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING");Fi[	@ÈiﬂI"Ô        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING");Fi[	@Èi·I"Ô        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING");Fi[	@Èi„I"˚        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        alias_type("STRING", "STRING")
        
        register_type("STRING", OID::Identity.new);Fi[@ö'I"#;F@x'I"#;F@z'i[[	@~'iI"(      # non-existence.
      #
      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first);Fi[	@Å'iI"E      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>);Fi[	@Ñ'iI"R      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=);Fi[	@á'iI"@      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var);Fi[	@ä'iI"B      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<);Fi[	@ç'iI"O      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=);Fi[	@ê'iI"P      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first);Fi[	@ì'iI"u      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) };Fi[	@ñ'iI"Y      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first);Fi[@.I"var;FI"end;FI"end;FI" ;Fi[[	@ÑiÏI"¬            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type
          def function(arglist);Fi[	@ÑiÚI"¬        end
        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Integer < Type
          def function(arglist);Fi[	@ÈiI"¬            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type
          def function(arglist);Fi[	@ÈiI"¿        end
        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Bytea < Type
          def function(arglist);Fi[	@Èi=I"M          # FIXME: this should probably split on +delim+ and use +subtype+
          # to cast the values.  Unfortunately, the current Rails behavior
          # is to just return the string.
          def function(arglist)
            var
          end
        end
        
        class Array < Type
          attr_reader(:subtype);Fi[	@XiµI"ﬁ      end
      
      class LogFormatter < ::Logger::Formatter
        def function(arglist)
          var
        end
      end
      
      def function(arglist)
        @var[:env_vars].each { |arglist| ENV[var] = var };Fi[	@)i¯I"Õ      
      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin
          (require("syntax/convertors/html");Fi[	@êièI"ú      include(Base)
      
      # @see Base#render
      def function(arglist)
        var
      end
    end
    
    module Javascript
      include(Base);Fi[	@≥i
I"€    module Formatter
      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin
          (require("syntax/convertors/html");Fi[@ÛI"end;FI" ;F@ˆI"def function(arglist);Fi[[	@˘iI"@      def self.included(arglist)
        var.send(:attr_accessor, :inherited_data, :set_attributes, :top_level)
        var.send(:include, InstanceMethods)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          var.each do |arglist|
            var = (20 + 1);Fi[	@?i1I"∫  
  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        class_eval("STRING")
      end;Fi[	@Òi	I"R  module Acts
    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          unless self.included_modules.include?(Redmine::Acts::ActivityProvider::InstanceMethods) then
            cattr_accessor(:activity_provider_options);Fi[	@ˆi	I"  module Acts
    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          cattr_accessor(:attachable_options)
          self.attachable_options = {};Fi[	@˘i	I""  module Acts
    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Customizable::InstanceMethods) then
            return;Fi[	@¸i	I"  module Acts
    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Event::InstanceMethods) then
            return;Fi[	@
i	I"  module Acts
    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Watchable::InstanceMethods) then
            return;Fi[	@|i
I"    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var);Fi[	@!iI"∆module Redmine
  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = nil
        begin;Fi[@q"@r"I" ;F@J'I"@var = var;Fi[[	@‘#iI"∫      def function(arglist)
        @var ||= "STRING"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@ôiQI"†          @var = "STRING"
          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@„i#I"!        
        def function(arglist)
          @var = var.flatten
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class)
          @var and (@var and (allowed_types_allowed? and rejected_types_rejected?));Fi[	@ÈiI"≠        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@Èi'I"9        
        def function(arglist)
          @var, @var = var.first, var.last
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class)
          lower_than_low? and (higher_than_low? and (lower_than_high? and higher_than_high?));Fi[	@Ö
i9I"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@Ö
i>I"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@Ö
iCI"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@Ö
iHI"ô      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[@.I"@var[var];FI"end;FI" ;FI"def function(arglist);Fi[[	@Èi´I"Ã            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var)
          end;Fi[	@ıi~I"≤    
    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist)
      @var[(var or false)] ||= {}
      @var[(var or false)][var] ||= begin;Fi[	@ iOI"§        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@x	i}I"±        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	@b&iI"ü        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end;Fi[	@#i<I"∂          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line
        end;Fi[	@πi/I"ß        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	@oiﬁI"∫        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var)
        print_snippets(@var);Fi[	@∏iäI"„          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({})
          case var.to_s;Fi[@
I"private;FI" ;F@"I"
begin;Fi[[	@ei%I"≤    end
    
    (alias :attributes= :assign_attributes)
    
    private
    
    def function(arglist)
      begin
        public_send("STRING", var)
      rescue NoMethodError;Fi[	@i%I"∂      ((var << read_file("STRING")) << "STRING")
      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip
      rescue Errno::ENOENT;Fi[	@ôi`I"Ÿ        (var << "STRING") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var
          configuration.invoke_command(var, var) do |arglist|;Fi[	@&i<I"˙        Cucumber.logger = @var.log
        @var
      end
      
      private
      
      def function(arglist)
        begin
          (return false unless configuration.drb?
          @var = DRbClient.run(@var, @var, @var, configuration.drb_port);Fi[	@ëi4I"Í      def function(arglist)
        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin
          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var;Fi[	@i-I"è      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir["STRING"].empty? then
        safe_system("STRING");Fi[	@KiI"+      var = GeometryParser.new(geometry_string.strip).make
      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin
        silence_stream(STDERR) do |arglist|
          Paperclip.run("STRING", "STRING", :file => "STRING");Fi[	@ái
I"˚    def function(arglist)
      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find_ids(var);Fi[	@–i[I"    def function(arglist)
      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin
        connection.send(var.to_sym, var, var) do |arglist|
          var.headers[:authorization] = auth_header(var.to_sym, var, var).to_s;Fi[@.I"
begin;FI"((Threaded.begin_execution("STRING");FI"yield);FI"ensure;Fi[[	@⁄iéI"       # @return [ Object ] The result of the yield.
      #
      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end;Fi[	@âiƒI"       # @return [ Object ] The result of the block.
      #
      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end;Fi[	@èiI"˙      # @return [ Object ] The yielded value.
      #
      # @since 2.2.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end;Fi[	@èi7I"      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end;Fi[	@èiVI"      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end;Fi[	@èi|I"      # @return [ Object ] The return value of the block.
      #
      # @since 2.3.2
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end;Fi[	@èiõI"      # @return [ Object ] The return value of the block.
      #
      # @since 2.3.4
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end;Fi[	@èiØI"        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("STRING")
            yield)
          ensure
            Threaded.exit_execution("STRING")
          end;Fi[	@°iI"9      # @return [ Object ] The result of the yield.
      #
      # @since 3.0.2
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          (klass.clear_persistence_options unless var.errors.empty?
          Threaded.exit_execution("STRING"));Fi[@I"# @since 3.0.0;F@≤'@'I"end;Fi[[	@ iI"9      # @param [ Object ] value The single value to add.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $bit operation on the matching documents.;Fi[	@ i!I"6      #   "and" or "or" and must have numeric values.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $inc operation on the matching documents.;Fi[	@ i0I"=      # @param [ Integer ] value The amount to increment by.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pop operation on the matching documents.;Fi[	@ iDI"      #   front.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pull operation on the matching documents.;Fi[	@ iUI">      # @param [ Object ] value The single value to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pullAll operation on the matching documents.;Fi[	@ idI"=      # @param [ Array<Object> ] values The values to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $push operation on the matching documents.;Fi[	@ isI"7      # @param [ Object ] value The value to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $pushAll operation on the matching documents.;Fi[	@ i}I"?      # @param [ Array<Object> ] values The values to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $rename of fields on the matching documents.;Fi[	@ iõI"5      # @param [ Object ] value The value to set.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("STRING" => ({ database_field_name(var) => (var) }))
      end
      
      # Perform an atomic $unset of a field on the matching documents.;Fi[@(@I"module ClassMethods;FI"I# Convert the object from its mongo friendly ruby type to this type.;FI"#;Fi[[	@)iI"      # @since 3.0.0
      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Object.demongoize(object);Fi[	@/iI"      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Date.demongoize(object);Fi[	@4i%I"&      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   DateTime.demongoize(object);Fi[	@Ci+I""      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Range.demongoize({ "min" => 1, "max" => 5 });Fi[	@IiI"0      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Set.demongoize({ "min" => 1, "max" => 5 });Fi[	@Li¢I"˘        else
          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   String.demongoize(object);Fi[	@OiI"      # @since 2.3.1
      def function(arglist)
        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Symbol.demongoize(object);Fi[	@WiI"=      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   TimeWithZone.demongoize(object);Fi[I"if (var == 1) then;FI"@var = @var;F@‹%I"/var = (((var - (2 * @var)) * 1000) / @var);FI"end;Fi[[	@si¿I"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@siﬁI"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@viªI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@viÊI"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@yiØI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@yiÕI"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@ÅiùI"        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@ÅiæI"Ó        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[I"	true;FI"end;FI"end;FI"end;FI"end;Fi[[	@∂i€I"∆      # Helper method for asking the user if he/she wants to overwrite the file
      def function(arglist)
        return yes?("STRING") if File.exist?(var)
        true
      end
    end
  end
end;Fi[	@#i|I"n        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@&i§I"¨        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array);Fi[	@:i¡I"™        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash);Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/and.rb;TiI"ó            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/persistence/deletion.rb;TiI"è        document.destroyed = true
        IdentityMap.remove(document)
        Threaded.clear_options!
        true
      end
    end
  end
end;Fi[	@|i&I"à              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end
end;Fi[	@·i‚I"∆        end
        var.class.changed if var.class.respond_to?(:changed)
        var.class.notify_observers("STRING", ObserverUpdate.new("STRING", var, var))
        true
      end
    end
  end
end;Fi[@ˆI"0assert_version_detected("STRING", "STRING");FI"0assert_version_detected("STRING", "STRING");FI"0assert_version_detected("STRING", "STRING");FI"0assert_version_detected("STRING", "STRING");Fi[[	@˚i˝I"‚  #   assert_version_detected '7.0.4', 'http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-i386-apple-darwin.tar.bz2'
  # end
  def function(arglist)
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@˚i˛I"ü  # end
  def function(arglist)
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@˚iˇI"«  def function(arglist)
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@˚i I"ﬂ    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@˚iI"ﬂ    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@˚iI"ﬂ    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING");Fi[	@˚iI"µ    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end;Fi[	@˚iI"â    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
    assert_version_detected("STRING", "STRING")
  end
end;Fi[@(@)@I"##;FI"I# Removes the transferred archive file(s) from the storage location.;Fi[[	@„i6I"à          File.open(File.join(local_path, var), "STRING") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@ÊiXI"{          File.open(File.join(local_path, var), "STRING") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@ÈiBI"q            Logger.message(("STRING" + "STRING"))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@Ói!I"o          var = File.join(local_path, var)
          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@Òi>I"}          File.open(File.join(local_path, var), "STRING") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@Ùi9I"Ö          File.open(File.join(local_path, var), "STRING") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@˜i6I"y            Logger.message(("STRING" + "STRING"))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@˙i4I"u            Logger.message(("STRING" + "STRING"))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[@I"-# @return [ Time ] The object mongoized.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@/iI"›      #
      # @example Mongoize the object.
      #   date.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self)
      end;Fi[	@/i7I"-        #   Date.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          unless var.blank? then
            var = var.__mongoize_time__;Fi[	@4iI"Ê      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self)
      end;Fi[	@4i=I"        #   DateTime.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end;Fi[	@RiI"›      #
      # @example Mongoize the object.
      #   time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Time.mongoize(self)
      end;Fi[	@Ri=I"        #   Time.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return nil if var.blank?
          begin;Fi[	@WiI"˘      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end;Fi[	@Wi,I"        #   TimeWithZone.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end;Fi[I"yield);FI"ensure;FI"&Threaded.exit_execution("STRING");FI"end;FI"end;Fi[[	@⁄iëI"⁄      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      module ClassMethods;Fi[	@âi«I"Œ      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      private;Fi[	@èiI"Ò      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in assigning mode?;Fi[	@èi:I"Ô      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in binding mode?;Fi[	@èiYI"      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in building mode?;Fi[	@èiI"Ô      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in loading mode?;Fi[	@èiûI"⁄      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      module ClassMethods;Fi[	@èi≤I"        def function(arglist)
          begin
            (Threaded.begin_execution("STRING")
            yield)
          ensure
            Threaded.exit_execution("STRING")
          end
        end
        
        # Is the current thread in loading revision mode?;Fi[@o&@A%I"@var = @var;F@‹%@)i[[	@siøI"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@si›I"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@vi∫I"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@viÂI"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@yiÆI"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@yiÃI"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@ÅiúI"˚        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@ÅiΩI"Ô        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[I"homepage("STRING");FI" ;FI"url("STRING");FI" ;FI"sha1("STRING");Fi[[	@o i~I"à  end
end
class ExplicitVersionSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  version("STRING");Fi[	@o iíI"Ñ  end
end
class OldBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|;Fi[	@o i¢I"Ö  end
end
class AncientBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle("STRING");Fi[	@o i›I"¨  end
end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle { |arglist| sha1("STRING" => :snowleopard) };Fi[	@o iÍI"û  end
end
class LionBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle { |arglist| sha1("STRING" => :lion) };Fi[	@o i˜I"à  end
end
class AllCatsBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|;Fi[	@o iI"à  end
end
class RevisedBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|;Fi[	@o iI"øclass CustomVersionScheme < Version
end
class CustomVersionSchemeTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  version("STRING" => (CustomVersionScheme));Fi[@(@@∑
I"@var = nil;FI"end;Fi[[	@=iTI"ı      # actually gets built.
      def function(arglist)
        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      
      # Set the inverse association, if possible;Fi[	@ûiœI"æ      
      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@)ieI"∞      def function(arglist)
        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@oi©I"À      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@ri3I"¢      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@=i,I"∑      def function(arglist)
        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@Ci~I"†      
      def function(arglist)
        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      private;Fi[	@N
i=I"ü        log("STRING")
      end
      @var[var] = { :path => (var), :class => (var) }
    end
    
    def function(arglist)
      @var = nil
    end
  end
end;Fi[@(@)@@‹I"case var;Fi[[	@Åi?I"æ            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var
          when /blob|text/i then
            case var;Fi[	@åiÇI"ﬂ            else
              ("STRING" % var.to_s.gsub(/(["\\])/, "STRING"))
            end
          end
        end
        
        def function(arglist)
          case var
          when "STRING" then
            var;Fi[	@≠i»I"-      (var - var).each do |arglist|
        var = Arel.sql(var) if String.===(var)
        var.where(Arel::Nodes::Grouping.new(var))
      end
    end
    
    def function(arglist)
      case var
      when String, Array then
        [@var.send(:sanitize_sql, (var.empty? ? (var) : (([var] + var))))];Fi[	@ni†I"Ú          options[var].keys.each do |arglist|
            options[var][var] = coerce_variable(options[var][var])
          end
        end
      end
      
      def function(arglist)
        case var
        when /^"(.*)"$/ then
          $1;Fi[	@iøI"˝      Sass::Script::Color::HTML4_COLORS_REVERSE
    else
      Sass::Script::Color::COLOR_NAMES_REVERSE
    end
  end
  
  def function(arglist)
    case var
    when Sass::Script::Color then
      Sass::Script::String.new(reversed_color_names[var.rgb]);Fi[	I";data//homebrew_proj/vendor/multi_json/vendor/okjson.rb;TiUI"¶        arrenc(var)
      else
        raise(Error, "STRING")
      end
    end
    
    def function(arglist)
      case var
      when Hash then
        objenc(var);Fi[	@`içI"Ã          "STRING"
        else
          "STRING"
        end
      end
      
      def function(arglist)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@ú
iîI"‘            warn("STRING")
            @var = false
          end
        end
      end
      
      def function(arglist)
        case var
        when :context, "STRING", "STRING" then
          @var = :context;Fi[@I"L# There is also a list of default options supported by every validator:;FI"-# +:if+, +:unless+, +:on+ and +:strict+.;FI"J# See <tt>ActiveModel::Validation#validates</tt> for more information;FI"def function(arglist);Fi[[	I"?data//activemodel_proj/active_model/validations/absence.rb;TiI"≤      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AbsenceValidator, _merge_attributes(var))
      end;Fi[	I"Bdata//activemodel_proj/active_model/validations/acceptance.rb;Ti1I"ˆ      #   an HTML checkbox. This should be set to +true+ if you are validating
      #   a database column, since the attribute is typecast from "1" to +true+
      #   before validation.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AcceptanceValidator, _merge_attributes(var))
      end;Fi[	I"Ddata//activemodel_proj/active_model/validations/confirmation.rb;Ti3I"∆      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "doesn't match
      #   confirmation").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ConfirmationValidator, _merge_attributes(var))
      end;Fi[	I"Adata//activemodel_proj/active_model/validations/exclusion.rb;Ti+I"Ì      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the
      #   attribute is blank(default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ExclusionValidator, _merge_attributes(var))
      end;Fi[	@7ilI"*      # * <tt>:multiline</tt> - Set to true if your regular expression contains
      #   anchors that match the beginning or end of lines as opposed to the
      #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(FormatValidator, _merge_attributes(var))
      end;Fi[	I"Adata//activemodel_proj/active_model/validations/inclusion.rb;Ti*I"      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(InclusionValidator, _merge_attributes(var))
      end;Fi[	@:iiI"      #   (e.g. <tt>tokenizer: ->(str) { str.scan(/\w+/) }</tt> to count words
      #   as in above example). Defaults to <tt>->(value) { value.split(//) }</tt>
      #   which counts individual characters.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(LengthValidator, _merge_attributes(var))
      end;Fi[	I"@data//activemodel_proj/active_model/validations/presence.rb;Ti I"¥      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end;Fi[@I"#   class BlogPost;FI"%#     extend ActiveModel::Naming;FI"#   end;FI"#;Fi[[	@.iI"=    #
    # Equivalent to <tt>String#==</tt>. Returns +true+ if the class name and
    # +other+ are equal, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name == 'BlogPost'  # => true
    #   BlogPost.model_name == 'Blog Post' # => false;Fi[	@.i'I"˚    #   ===(other)
    #
    # Equivalent to <tt>#==</tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name === 'BlogPost'  # => true
    #   BlogPost.model_name === 'Blog Post' # => false;Fi[	@.i5I"˙    #   ==(other)
    #
    # Equivalent to <tt>String#<=></tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name <=> 'BlogPost'  # => 0
    #   BlogPost.model_name <=> 'Blog'      # => 1;Fi[	@.iFI"]    # Equivalent to <tt>String#=~</tt>. Match the class name against the given
    # regexp. Returns the position where the match starts or +nil+ if there is
    # no match.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name =~ /Post/ # => 4
    #   BlogPost.model_name =~ /\d/   # => nil;Fi[	@.iUI"O    #
    # Equivalent to <tt>String#!~</tt>. Match the class name against the given
    # regexp. Returns +true+ if there is no match, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name !~ /Post/ # => false
    #   BlogPost.model_name !~ /\d/   # => true;Fi[	@.idI"\    #
    # Equivalent to <tt>String#eql?</tt>. Returns +true+ if the class name and
    # +other+ have the same length and content, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.eql?('BlogPost')  # => true
    #   BlogPost.model_name.eql?('Blog Post') # => false;Fi[	@.irI"æ    #   to_s()
    #
    # Returns the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.to_s # => "BlogPost"
    ##;Fi[	@.iòI"    
    # Transform the model name into a more humane format, using I18n. By default,
    # it will underscore then humanize the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.human # => "Blog post"
    #;Fi[@(@@∑
I"@var.empty?;FI"end;Fi[[	@Êi8I"Æ      rescue Exception => var
        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end
    
    ##;Fi[	@LiNI"’          self.each { |arglist| var[var] = var }
          var.each { |arglist| var[var] = var }
          var
        end
        
        def function(arglist)
          @var.empty?
        end
      end
    end;Fi[	@L	i7I"®    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist);Fi[	I"8data//cucumber_prok/cucumber/ast/step_collection.rb;Ti,I"«      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist);Fi[	@OidI"$      def function(arglist)
        load_programming_language("STRING") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("STRING")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist);Fi[	@¬iI"å  def function(arglist)
    @var = var
    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function;Fi[	@—i•I"ï  
  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist);Fi[	@#iI"Ä  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist);Fi[I",#         transition :parked => :idling;FI"#       end;FI"#     end;FI"#   end;FI"#;Fi[[	@Õi I"◊    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events
    #   ;Fi[	@ÕiEI"œ    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events
    #   ;Fi[	@ÕieI"`    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">
    #   events = Vehicle.state_machine.events;Fi[	@ÀiI""        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@ÀiZI""        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@Ài~I".        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|;Fi[	@FiÊI"7    #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[	@FiˇI"z    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[@(@@∑
I"(@var << var);FI"end;Fi[[	@i"I"´          var.init
          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@ö	iI"ß      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@#iI"∏        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist);Fi[	@)i1I"Ã        build_cell(@var, var, var)
        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@ÑiI"§      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@Ri4I"¶    def function(arglist)
      @var = true
      (@var << "STRING")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist);Fi[	I"/data//rspec_proj/spec/mocks/order_group.rb;TiI"∑      def function(arglist)
        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@ú
i-I"©        @var = []
        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[I"#       event :ignite do;F@;*I"#       end;FI"#     end;FI"#   end;Fi[[	@ÕiI"˙    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events;Fi[	@ÕiDI"Ú    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events;Fi[	@ÕidI"9    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">;Fi[	@ÀiI"        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@ÀiYI"        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@Ài}I"        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@FiÂI"—    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new;Fi[	@Fi˛I"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">;Fi[@
I"url("STRING");FI" ;FI"sha1("STRING");FI" ;Fi[[	@o iI"Öend
class ExplicitVersionSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  version("STRING")
  ;Fi[	@o iìI"êend
class OldBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|
    url("STRING");Fi[	@o i£I"Çend
class AncientBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle("STRING")
  ;Fi[	@o iﬁI"©end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle { |arglist| sha1("STRING" => :snowleopard) }
  ;Fi[	@o iÎI"õend
class LionBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle { |arglist| sha1("STRING" => :lion) }
  ;Fi[	@o i¯I"•end
class AllCatsBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|
    sha1("STRING" => :snowleopard);Fi[	@o i	I"ëend
class RevisedBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|
    version(1);Fi[	@o iI"ûend
class CustomVersionSchemeTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  version("STRING" => (CustomVersionScheme))
  ;Fi[@b)I"6# Any error raised will be rescued during Cycling;FI"B# and a warning will be logged, containing the error message.;FI"def function(arglist);FI"var = remote_path_for(var);Fi[[	@„i:I"      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|
          Logger.message(("STRING" + "STRING"));Fi[	@Êi\I"Ä      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |arglist| (var << ("STRING" + "STRING")) };Fi[	@ÈiFI"q      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[	@Ói%I"s      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |arglist| (var << "STRING") };Fi[	@ÒiBI"[      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then
          var = [];Fi[	@Ùi=I"m      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock
        transferred_files_for(var) do |arglist|;Fi[	@˜i:I"Ä      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |arglist| (var << ("STRING" + "STRING")) };Fi[	@˙i8I"q      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[@'I"#raise(ArgumentError, "STRING");FI"end;FI"end;FI"end;Fi[[	@≥iRI".            self.nested_attributes_options = var
            var = var.collection? ? (:collection) : (:one_to_one)
            generated_feature_methods.module_eval("STRING", "STRING", (284 + 1))
          else
            raise(ArgumentError, "STRING")
          end
        end
      end
    end
    ;Fi[	@≥iI"Ò            var = "STRING"
            if respond_to?(var) then
              send(var, var.except(*UNASSIGNABLE_KEYS))
            else
              raise(ArgumentError, "STRING")
            end
          end
        end
      end
    end;Fi[	@åidI"!                if var[:proc] then
                  remember_load(var) unless var[:reloading]
                  instance_eval(&var[:proc])
                else
                  raise(ArgumentError, "STRING")
                end
              end
            end
          end
        end;Fi[	@x	ibI"Ê          prepare_sftp_transfer(var, var, var)
        when :scp then
          prepare_scp_transfer(var, var, var)
        else
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    def function(arglist);Fi[	@x	iûI"‡          var.upload(var, var, var, &var)
        when :down then
          var.download(var, var, var, &var)
        else
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    def function(arglist);Fi[	@`iõI"—        else
          if var.respond_to?(:call) then
            var.call(self)
          else
            raise(ArgumentError, "STRING")
          end
        end
      end
      
      def function(arglist);Fi[	I";data//state_machine_proj/state_machine/eval_helpers.rb;TiLI"È        var.is_a?(Proc) ? (var.call(*var)) : (var.call(*var, &var))
      when String then
        eval(var, var.instance_eval { |arglist| binding }, &var)
      else
        raise(ArgumentError, "STRING")
      end
    end
  end
end;Fi[	I"*data//twitter_proj/twitter/factory.rb;TiI"°          $1.upcase
        end
        var.const_get(var.to_sym).fetch_or_new(var)
      else
        raise(ArgumentError, "STRING")
      end
    end
  end
end;Fi[I"
begin;F@⁄(I"yield);FI"ensure;F@ç)i[[	@⁄ièI"÷      #
      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end;Fi[	@âi≈I"÷      #
      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end;Fi[	@èiI"÷      #
      # @since 2.2.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end;Fi[	@èi8I"÷      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end;Fi[	@èiWI"÷      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end;Fi[	@èi}I"÷      #
      # @since 2.3.2
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end;Fi[	@èiúI"÷      #
      # @since 2.3.4
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end;Fi[	@èi∞I"Í        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("STRING")
            yield)
          ensure
            Threaded.exit_execution("STRING")
          end
        end;Fi[@>%I"var = 0;FI"var = 0;FI"var = 0;FI"var = 1;Fi[[	@sinI"Ï        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@si≤I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@vicI"Ï        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@vi≠I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@yi]I"Ï        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@yi°I"    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@ÅiêI"’    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[	@i¥I"©      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[@(@@∑
I"(@var << "STRING");FI"end;Fi[[	@)iTI"Ω      def function(arglist)
        @var = []
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[	@)iXI"≤      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[	@)i\I"≤      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[	@)i´I"æ      def function(arglist)
        (@var << "STRING")
        @var = nil
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[	@)iØI"≤      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[	@)iªI"Ã          @var.text!("STRING")
          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[	@)iøI"≤      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[	@)i¿I"®      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist);Fi[@(@@II" ;FI"def function(arglist);Fi[[	@ﬁi‹I"˜        (Bundler.ui.error("STRING")
        exit(1))
      end
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      var = [ENV["STRING"], ENV["STRING"], ENV["STRING"]].find do |arglist|
        var.nil?.! and var.empty?.!;Fi[	@ﬁiÓI"◊      else
        Bundler.ui.info("STRING")
      end
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      if var then
        Bundler.require(:default, *group.split.map! { |g| g.to_sym });Fi[	@ﬁi˚I"¶      ARGV.clear
      require("irb")
      IRB.start
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      Bundler.ui.info("STRING")
    end;Fi[	@ﬁiîI"ª        end
      end
      Bundler.ui.info(var.join("STRING"))
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      var.unshift(var).unshift(var)
      var = [];Fi[	@ﬁi£I"ß      else
        Bundler.ui.confirm("STRING")
      end
    end
    
    desc("STRING", "STRING")
    
    def function(arglist)
      Env.new.write($stdout)
    end;Fi[	@–i[I"±      FileUtils.cp_r(var, var)
    end
    thor_yaml[var][:filename]
  end
  
  desc("STRING", "STRING")
  
  def function(arglist)
    require("thor/version")
    say("STRING");Fi[	@–ibI"«  def function(arglist)
    require("thor/version")
    say("STRING")
  end
  
  desc("STRING", "STRING")
  
  def function(arglist)
    raise(Error, "STRING") unless thor_yaml[var]
    say("STRING");Fi[	@–imI"Ê    thor_yaml.delete(var)
    save_yaml(thor_yaml)
    puts("STRING")
  end
  
  desc("STRING", "STRING")
  
  def function(arglist)
    raise(Error, "STRING") if (thor_yaml[var].! or thor_yaml[var][:location].!)
    say("STRING");Fi[@
@I"@var = [];FI"end;FI" ;Fi[[	@b&iI"±      include(Enumerable)
      
      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var];Fi[	@#iI"ª      
      class Builder
        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var);Fi[	@fi®I"∞        @var.puts(format_string(var, :tag).indent(@var))
        @var.flush
      end
      
      def function(arglist)
        @var = []
      end
      
      private
      ;Fi[	@)iDI"Õ        @var.td(:class => "STRING") { |arglist| (@var << @var.join("STRING")) }
        empty_messages
      end
      
      def function(arglist)
        @var = []
      end
      
      protected
      ;Fi[	@Ñi
I"œ  module PySupport
    class PyLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var);Fi[	@'iI"“  module WireSupport
    class WireLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing;Fi[	I""data//homebrew_proj/debrew.rb;TiI"µ  attr_accessor(:prompt)
  
  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist)
    (entries << { :name => (var), :action => (var) });Fi[	I";data//paperclip_proj/paperclip/io_adapters/registry.rb;TiI"£    end
    
    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      (@var << [var, var]);Fi[@
I"##;F@b)@ì*@î*i[[	@„i8I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@ÊiZI"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@ÈiDI"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@Ói#I"_          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@Òi@I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@Ùi;I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@˜i8I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@˙i6I"9          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[@⁄(I"yield);FI"ensure;F@ç)I"end;Fi[[	@⁄iêI"’      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      ;Fi[	@âi∆I"’      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      ;Fi[	@èiI"’      # @since 2.2.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      ;Fi[	@èi9I"’      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      ;Fi[	@èiXI"’      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      ;Fi[	@èi~I"’      # @since 2.3.2
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      ;Fi[	@èiùI"’      # @since 2.3.4
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      ;Fi[	@èi±I"È        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("STRING")
            yield)
          ensure
            Threaded.exit_execution("STRING")
          end
        end
        ;Fi[I"@var = @var;F@‹%@)I"end;FI"var = (var + 1);Fi[[	@si¡I"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@siﬂI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@viºI"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@viÁI"˜        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var);Fi[	@yi∞I"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@yiŒI"        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@ÅiûI"È        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@ÅiøI"ı        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1);Fi[@(@@I@ +I"long_desc("STRING");Fi[[	@ﬁi9I"±      else
        super
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :string, :banner => "STRING");Fi[	@ﬁiWI"Ù        puts("STRING")
        FileUtils.cp(File.expand_path("STRING", "STRING"), "STRING")
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :string, :banner => "STRING");Fi[	@ﬁiI"«          Bundler.ui.info("STRING")
        end
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :array, :banner => "STRING");Fi[	@ﬁi€I"Ó        Bundler.ui.warn("STRING") if Bundler.definition.no_sources?
        raise(var)
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :array, :banner => "STRING");Fi[	@ﬁi˙I"B      Bundler.load.cache if Bundler.root.join("STRING").exist?
      clean if Bundler.settings[:clean] and Bundler.settings[:path]
      Bundler.ui.confirm(("STRING" + "STRING"))
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING");Fi[	@ﬁi/I"      else
        var.generate_bundler_executable_stubs(var, :force => (options[:force]), :binstubs_cmd => (true))
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING");Fi[	@ﬁiûI"§        Bundler.ui.error("STRING")
        exit(128)
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    def function(arglist);Fi[	@ﬁiI"<        var = (var.license or var.licenses)
        var.empty? ? (Bundler.ui.warn("STRING")) : (Bundler.ui.info("STRING"))
      end
    end
    
    desc("STRING", "STRING")
    
    long_desc("STRING")
    
    method_option(:file, :type => :string, :default => "STRING", :aliases => "STRING", :banner => "STRING");Fi[@
I"module ClassMethods;F@)I"#;FI"&# @example Demongoize the object.;Fi[[	@)i I"      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Object.demongoize(object)
        #;Fi[	@/i I"      def function(arglist)
        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Date.demongoize(object)
        #;Fi[	@4i&I"      def function(arglist)
        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   DateTime.demongoize(object)
        #;Fi[	@Ci,I"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Range.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@IiI"%      def function(arglist)
        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Set.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@Li£I"ˆ          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   String.demongoize(object)
        #;Fi[	@OiI"      def function(arglist)
        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Symbol.demongoize(object)
        #;Fi[	@WiI"2      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   TimeWithZone.demongoize(object)
        #;Fi[I"##;F@b)@ì*@î*@ï*i[[	@„i9I"[        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|;Fi[	@Êi[I"<        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@ÈiEI"K        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[	@Ói$I"<        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@ÒiAI"T        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then;Fi[	@Ùi<I"I        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock;Fi[	@˜i9I"<        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@˙i7I"K        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[@(@I"##;F@b)@ì*i[[	@„i7I"]            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@ÊiYI"P            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@ÈiCI"[            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@Ói"I"`          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@Òi?I"R            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@Ùi:I"Z            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@˜i7I"c            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@˙i5I"_            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[@
@I"@var ||= [];FI"end;FI" ;Fi[[	@i0I"‘    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, "STRING")) then;Fi[	@iI"˘      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end
    
    # Returns an array of Rule instances which match the action and subject
    # This does not take into consideration any hash conditions or block statements;Fi[	@=iTI"       def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|;Fi[	@ˆi$I"@        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= [];Fi[	@ˆi(I"—        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then;Fi[	@ iI"Ì          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|;Fi[	@õi I"∫        end
        
        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          var = find(var.description);Fi[	@wi›I"¬      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var);Fi[@.I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@ÒiI"ãmodule ActiveRecord
  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end;Fi[	@b&iI"°      
      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end;Fi[	@#iI"¿      class Builder
        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end;Fi[	@ÑiI"∆    class PyLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@'iI"«    class WireLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@%+iI"¢  
  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist)
    (entries << { :name => (var), :action => (var) })
  end;Fi[	@(+iI"£    
    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      (@var << [var, var])
    end;Fi[	@YiI"¡module Spec
  module Runner
    class BacktraceTweaker
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        var.gsub!("STRING", "STRING")
      end;Fi[@
@I"(@var << var);FI"end;FI" ;Fi[[	@i#I"¡          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@ö	iI"⁄      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self };Fi[	@#iI"∆        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing;Fi[	@)i2I"«        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?;Fi[	@ÑiI"≤      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing;Fi[	@Ri5I"•      @var = true
      (@var << "STRING")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "STRING");Fi[	@b*iI"æ        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var);Fi[	@ú
i.I"Ø        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!;Fi[@.@Ï*I"end;FI" ;FI"def function(arglist);Fi[[	@)iVI"¥        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end;Fi[	@)iZI"¥        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end;Fi[	@)i^I"∑        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        @var.text!(var)
        @var.br;Fi[	@)i≠I"¨        @var = nil
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end;Fi[	@)i±I"Ÿ        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        @var.h4 do |arglist|
          @var.span(var, :class => "STRING");Fi[	@)iΩI"•        end
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end;Fi[	@)i¡I"√        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        @var = var.dom_id
        @var = (@var + 1);Fi[	@)i¬I"‰        "STRING"
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        var = 100.0
        var = (((@var.to_f / @var.to_f) * 1000).to_i / 10.0) if @var.!=(0);Fi[@.I"(@var << var);FI"end;FI" ;FI"def function(arglist);Fi[[	@i$I"±        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init;Fi[	@ö	iI"»        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self }
      end;Fi[	@#iI"¥          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@)i3I"∆        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?
        @var.each do |arglist|;Fi[	@ÑiI"†        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@Ri6I"≤      (@var << "STRING")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "STRING")
      self.instance_eval(&var);Fi[	@b*iI"µ        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var)
      end;Fi[	@ú
i/I"§        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!
      end;Fi[@
@@Ï*I"end;FI" ;Fi[[	@)iUI"º        @var = []
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING");Fi[	@)iYI"∆      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING");Fi[	@)i]I"√      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        @var.text!(var);Fi[	@)i¨I"Ω        (@var << "STRING")
        @var = nil
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING");Fi[	@)i∞I"»      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        @var.h4 do |arglist|;Fi[	@)iºI"»          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING");Fi[	@)i¿I"≈      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        @var = var.dom_id;Fi[	@)i¡I"µ      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        var = 100.0;Fi[I"ensure;F@ç)I"end;FI"end;FI" ;Fi[[	@⁄iíI"        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      module ClassMethods
        # Adds the existence check for relations.;Fi[	@âi»I"π        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      private
      ;Fi[	@èiI"›        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in assigning mode?
      #;Fi[	@èi;I"€        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in binding mode?
      #;Fi[	@èiZI"‹        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in building mode?
      #;Fi[	@èiÄI"€        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      # Is the current thread in loading mode?
      #;Fi[	@èiüI"Í        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING")
        end
      end
      
      module ClassMethods
        # Execute a block in creating mode.;Fi[	@èi≥I"¯          begin
            (Threaded.begin_execution("STRING")
            yield)
          ensure
            Threaded.exit_execution("STRING")
          end
        end
        
        # Is the current thread in loading revision mode?
        #;Fi[@@Ò(@≤'I"@var = var;FI"end;Fi[[	@ i,I"÷      # @param [ Integer ] value The limit.
      #
      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Get the skiping value.;Fi[	@ iHI"’      # @param [ Integer ] value The skip.
      #
      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Apply criteria options.;Fi[	I"/data//mongoid_proj/lib/mongoid/criteria.rb;TieI"¸    # @param [ Array<Document> ] docs The embedded documents.
    #
    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Is the criteria for embedded documents?;Fi[	@S,iI"
    # @param [ Array<Metadata> ] The inclusions.
    #
    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Merges another object with this +Criteria+ and returns a new criteria.;Fi[	I"/data//mongoid_proj/lib/mongoid/loggable.rb;TiI"∂    # @param [ Logger ] The logger to set.
    #
    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private;Fi[	@mióI"        # @param [ true, false ] value The flag.
        #
        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Normalize the documents, in case they were provided as an array of;Fi[	@miŒI"        # @param [ String ] value The path.
        #
        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Get the selector for executing atomic operations on the collection.;Fi[I"(@var << "STRING");FI"end;FI" ;FI"def function(arglist);F@Ï*i[[	@)iSI"®      
      def function(arglist)
        @var = []
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      ;Fi[	@)iWI"†      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      ;Fi[	@)i[I"†      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      ;Fi[	@)iëI"        @var = (@var + 1)
        @var = false
        var = { Ast::Scenario => "STRING", Ast::ScenarioOutline => "STRING" }[var.class]
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
        @var = true
      end;Fi[	@)i•I"≥      
      def function(arglist)
        @var = 0
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
        @var = nil
      end;Fi[	@)iÆI"†      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      ;Fi[	@)iæI"†      end
      
      def function(arglist)
        (@var << "STRING")
      end
      
      def function(arglist)
        (@var << "STRING")
      end
      ;Fi[I"@var.puts("STRING");FI"@var.flush;FI"end;FI" ;FI"def function(arglist);Fi[[	@°iI"Ù    module Formatter
      class FailingExamplesFormatter < BaseTextFormatter
        def function(arglist)
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@§i-I"Î          end
          @var.puts("STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          @var.puts("STRING")
          @var.puts("STRING");Fi[	@§i3I"“        
        def function(arglist)
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          @var = (@var + 1)
        end;Fi[	@§i=I"        
        def function(arglist)
          move_progress
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          var = extra_failure_content(var)
          var = var.pending_fixed? ? ("STRING") : ("STRING");Fi[	@§iPI"A          @var.puts("STRING") unless var.exception.nil?
          @var.puts(var) unless (var == "STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          @var.puts("STRING") unless @var
          @var.puts("STRING") unless @var;Fi[	@§ifI"À        end
        
        def function(arglist)
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          var = 100.0
          if @var.!=(0) then;Fi[	@§i}I"ﬁ          @var.puts("STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          "STRING"
        end;Fi[I"return "STRING";FI"end;FI"end;FI"end;FI"end;Fi[[	@ßiìI"ú          return "STRING"
        else
          var = (var < 0) ? ("STRING") : ("STRING")
          return "STRING"
        end
      end
    end
  end
end;Fi[	@!i4I"e      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@íiíI"e      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@iiçI"e      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@Oi…I"e      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@°i¡I"e      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@≤i[I"õ      def function(arglist)
        return "STRING" if (var == 1)
        return "STRING" if (var == 2)
        return "STRING"
      end
    end
  end
end;Fi[@¬@√@è@êI" ;Fi[[	@@i0I"Q          interpolate(options[:finder_sql]).sub(/SELECT\b(\/\*.*?\*\/ )?(.*)\bFROM\b/mi) do |arglist|
            var = $2.to_s
            var = "STRING" if (var.blank? or (var =~ /,/ or var =~ /\.\*/))
            "STRING"
          end
        end
      end
      
      def function(arglist)
        interpolate(options[:finder_sql]);Fi[	@xi\I"            if ActiveRecord::Base.!=(self) and table_exists? then
              connection.schema_cache.primary_keys[table_name]
            else
              "STRING"
            end
          end
        end
        
        # Sets the name of the primary key column.
        #;Fi[	@)
isI"ó        when 41 then
          "STRING"
        else
          "STRING"
        end
      end
  end
  
  def function(arglist)
    (version.to_f < 4.3);Fi[	@i,I"¬        end
        var = pba(var)
        var = shelve(var) if var
        "STRING"
      end
    end
  end
  
  LINK_RE = /\n            (\n            ([\s\[{(]|[#{PUNCT}STRING#{C}STRING/x
  ;Fi[	@iEI"Ô        (var << "STRING") if var
        var = shelve(var) if var
        var = var =~ /^https?:\/\// ? ("STRING") : ("STRING")
        "STRING"
      end
    end
  end
  
  MARKDOWN_REFLINK_RE = /
              \[([^\[\]]+)\]      # $text;Fi[	@iSI"ê        end
        "STRING"
      else
        "STRING"
      end
    end
  end
  
  ALLOWED_TAGS = ["STRING", "STRING", "STRING", "STRING"]
  ;Fi[	@«i5I"⁄        if ((defined? Gem and var.filename.include?(Gem.dir)) or var.filename =~ /\/bin\/(\w+)$/) then
          "STRING"
        else
          "STRING"
        end
      end
    end
    
    TEMPLATE = "STRING"
  end;Fi[I"require("formula");FI"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);Fi[[	@<i I"∏require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise("STRING".undent) unless (HOMEBREW_REPOSITORY / "STRING").directory?
    if ARGV.named.empty? then;Fi [	I"%data//homebrew_proj/cmd/fetch.rb;Ti I"®require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("STRING") then;Fi [	@˝i I"árequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    var = []
    HOMEBREW_CELLAR.subdirs.each do |arglist|;Fi [	I""data//homebrew_proj/cmd/sh.rb;TiI"ãrequire("superenv")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    if superenv? then
      ENV.x11 = true;Fi[	I")data//homebrew_proj/cmd/uninstall.rb;TiI"úrequire("keg")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    begin
      (raise(KegUnspecifiedError) if ARGV.named.empty?;Fi[	I"$data//homebrew_proj/cmd/uses.rb;Ti I"™require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    var = Formula.select do |arglist|;Fi [	@¢i I"ærequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise("STRING") unless which("STRING")
    raise("STRING") unless (HOMEBREW_REPOSITORY / "STRING").directory?;Fi [@(@@∑
I"return "STRING";FI"end;Fi[[	@!i1I"õ          var = min_scale_value
        end
        return var
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end;Fi[	@íièI"»        calculate_top_margin
        @var = ((width - @var) - @var)
        @var = ((height - @var) - @var)
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end;Fi[	@iiäI"õ          var = var.dup
          var = (var - 1))
        end
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end;Fi[	@Oi∆I"∏      def function(arglist)
        var = (10 ** var.to_f)
        ((var * var).to_i / var)
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end;Fi[	@°iæI"ê      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end;Fi[	@ïiÄI"$          @var.add_element("STRING", "STRING" => (var.to_s), "STRING" => (var.to_s), "STRING" => (var.to_s), "STRING" => (var.to_s), "STRING" => "STRING")
          var = (var + 1)
        end
      end
      
      def function(arglist)
        return "STRING"
      end
      
      private;Fi[	@ûi/I"Â      
      def function(arglist)
        @var.empty? ? ("STRING") : (parenthesize(inspected_args.join("STRING")))
      end
      
      def function(arglist)
        return "STRING"
      end
      
      def function(arglist);Fi[@.@/@0@1I"##;Fi[[	@Zi®I"~      ##
      # Returns the MongoDB syntax for determining where to output all the database dumps,
      # e.g. ~/Backup/.tmp/databases/MongoDB/<databases here>/<database collections>
      def function(arglist)
        "STRING"
      end
      
      ##
      # Locks and FSyncs the database to bring it up to sync
      # and ensure no 'write operations' are performed during the;Fi[	@∆iUI"¯      
      ##
      # Returns the Redis database file name
      def function(arglist)
        "STRING"
      end
      
      ##
      # Builds the Redis credentials syntax to authenticate the user
      # to perform the database dumping process;Fi[	@„i#I"Û      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage
      def function(arglist)
        "STRING"
      end
      
      ##
      # Establishes a connection to Rackspace Cloud Files
      def function(arglist);Fi[	@ÒiI"‰      
      ##
      # This is the provider that Fog uses for the Ninefold storage
      def function(arglist)
        "STRING"
      end
      
      ##
      # Establishes a connection to Amazon S3
      def function(arglist);Fi[	@°iyI"       
      ##
      # Returns Rsync syntax for defining a port to connect to
      def function(arglist)
        "STRING"
      end
      
      ##
      # RSync options
      # -z = Compresses the bytes that will be transferred to reduce bandwidth usage;Fi[	@Ùi!I"ﬁ      
      ##
      # This is the provider that Fog uses for the S3 Storage
      def function(arglist)
        "STRING"
      end
      
      ##
      # Establishes a connection to Amazon S3
      def function(arglist);Fi[	@iOI"        
        ##
        # Returns Rsync syntax for defining a port to connect to
        def function(arglist)
          "STRING"
        end
        
        ##
        # Returns Rsync syntax for setting a password (via a file)
        def function(arglist);Fi[@
@I"@var.empty?;FI"end;FI" ;Fi[[	@Êi9I"⁄        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end
    
    ##
    # Returns a multi-line String, reporting all STDERR messages received;Fi[	@L	i8I"ü      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first;Fi[	@0*i-I"Í        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length };Fi[	@OieI"<        load_programming_language("STRING") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("STRING")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) };Fi[	@¬iI"|    @var = var
    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  ;Fi[	@—i¶I"¶  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var);Fi[	@#iI"°  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?;Fi[@
@I"0;FI"end;FI" ;Fi[[	@ÒiI"Ä    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@ÒiI"    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@ÒiI"    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@ÒiI"Ç    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[	@Òi2I"Ä    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@Òi6I"ä    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing;Fi[	@ziI"â    def function(arglist)
      "STRING"
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[I"!Compass.projectize(var, var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@˙
i.I"<      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then
          Compass.projectize(var, var);Fi[	@˙
i4I">      
      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then
          Compass.projectize(var, var);Fi[	@˙
i:I"K      
      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.generated_images_dir then
          Compass.projectize(var, var);Fi[	@˙
iHI"J      
      def function(arglist)
        if var = top_level.project_path and var = top_level.javascripts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then
          Compass.projectize(var, var);Fi[	@˙
iNI"D      
      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then
          Compass.projectize(var, var);Fi[	@˙
iTI"?      
      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then
          Compass.projectize(var, var);Fi[	@˙
iZI"Ù      
      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        top_level.images_dir
      end;Fi[I"try("STRING", var);FI"	self;FI"end;FI" ;FI"def function(arglist);Fi[[	@ôiI"∆      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var);Fi[	@ôiI"∆      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var);Fi[	@ôi!I"∆      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var);Fi[	@ôi'I"Â      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        var = configuration.fetch(:gem_command, "STRING");Fi[	@ôi.I"˘      def function(arglist)
        @var ||= "STRING"
        var = configuration.fetch(:gem_command, "STRING")
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var);Fi[	@ôi4I"∆      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var);Fi[	@ôi:I"Ì      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        var = Regexp.new(Regexp.escape(var.to_s)) unless var.is_a?(Regexp)
        var = {};Fi[@(@)I"	self;FI"end;FI" ;Fi[[	@Ïi=I"≈          Rails.logger.info("STRING")
          return
        end
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.parent_author_signature, self.parent.author);Fi[	@Ôi]I"¿      else
        Rails.logger.info("STRING")
        return
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.target_author_signature, self.target.author);Fi[	I"/data//mongoid_proj/lib/mongoid/observer.rb;Ti,I"ü            end
          end
          var.send(var, var)
        end
      end
      self
    end
    
    # Are the observers disabled for the object?
    #;Fi[	@⁄iÂI"%              else
                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        
        # Defines the setter method that allows you to set documents
        # in this relation by their ids. The defined setter, finds;Fi[	@Fi:I"/              var = send("STRING", var)
              var.run_callbacks(:build)
              var
            end
          end
          self
        end
        
        # Defines a creator method for an embeds_one relation. This is
        # defined as #create_name. After the object is built it will;Fi[	@ßi<I"7              var.value[0].value = ["STRING"]
              var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["STRING"]), Node.new(:FUNCTION, ["STRING", var])])
            end
          end
        end
        self
      end
      
      # Find a node by type using +types+
      def function(arglist);Fi[	I"1data//nokogiri_proj/nokogiri/xml/node_set.rb;Ti±I"…            end
          else
            var.delete("STRING")
          end
        end
        self
      end
      
      ###
      # Set the attribute +key+ to +value+ or the return value of +blk+;Fi[@(@)@*@€I"protected;Fi[[	@◊i}I"ü          false
        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[	@Âi/I"ˆ            unless var.send(CHECKS[var], var) then
              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@æi(I"¬          @var.synchronize do |arglist|
            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@iDI"¥          else
            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[	@i\I"u        var.value.first
      else
        var
      end
    end
  end
  
  protected
  
  def function(arglist);Fi[	@1i_I"í            :locked
          else
            super
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@ i,I"ì          puts("STRING")
          puts("STRING")
          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[I"/File.open("STRING", "STRING") do |arglist|;FI"var.puts(var);FI"var.puts("STRING");FI"var.puts(var);FI"end;Fi[[	@∆i#I"r        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
        if var then
          var = var["STRING", "STRING"].all;Fi[	@–iI"w        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:id]), "STRING" => (var[:alias]), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end;Fi[	@”i"I"O        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end;Fi[	@÷iI"b        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:entry_id]), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end;Fi[	I"4data//jekyll_proj/jekyll/migrators/posterous.rb;Ti/I"f          var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |arglist|
            (var.nil? or (var == "STRING"))
          end.to_yaml
          File.open("STRING", "STRING") do |arglist|
            var.puts(var)
            var.puts("STRING")
            var.puts(var)
          end
        end
        var = (var + 1);Fi[	@‹iI"_        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:Keywords].split("STRING")) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end;Fi[	@‚i]I"      var = { "STRING" => (var[:type].to_s), "STRING" => (var[:status].to_s), "STRING" => ((var[:status].to_s == "STRING")), "STRING" => (var.to_s), "STRING" => (var[:author].to_s), "STRING" => (var[:author_login].to_s), "STRING" => (var[:author_email].to_s), "STRING" => (var[:author_url].to_s), "STRING" => (var), "STRING" => (var), "STRING" => (var[:id]), "STRING" => (var[:guid].to_s), "STRING" => (var), "STRING" => (var[:categories] ? (var) : (nil)), "STRING" => (var[:tags] ? (var) : (nil)), "STRING" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == "STRING"))
      end.to_yaml
      File.open("STRING", "STRING") do |arglist|
        var.puts(var)
        var.puts("STRING")
        var.puts(var)
      end
    end
    ;Fi[@@@@XI"private;Fi[[	@~i%I"∆          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist);Fi[	@ÑiêI"≠        begin
          exec_query("STRING")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist);Fi[	@ßiLI"œ          when /\(yes\/no\)/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option;Fi[	@ØiäI"          when /accept \(t\)emporarily/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the;Fi[	@≤iJI"¡          when /yes\/no/i then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands;Fi[	@∏iLI"          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "STRING")
          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.;Fi[	@ΩiUI"          when /accept \(t\)emporarily/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line;Fi[@(I"	else;FI"var;FI"end;FI"end;Fi[[	@åiqI"¶                else
                  nil
                end
              end
            else
              var
            end
          end
        end
        ;Fi[	@≠iI"         when Hash then
          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    ;Fi[	@7iYI"æ            var[:project_name]
          else
            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist);Fi[	@Ci¢I"¿            var.backtrace.clear
            var.backtrace.push(var.backtrace_line("STRING"))
            raise(var)
          end
        else
          var
        end
      end
    end
  end;Fi[	@OiìI"·            end.min
            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      ;Fi[	@¿i&I"∫            var = var.call(var)
            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end;Fi[	@mi∞I"              var = { :metadata => (metadata), :_parent => (base) }
              var.merge!(var)
              Factory.build(klass, var, base.send(:mass_assignment_options))
            end
          else
            var
          end
        end
        
        # Get the atomic path.;Fi[@.I"@var = true;FI"end;FI" ;FI"def function(arglist);Fi[[	@7i I"ü        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@<iI"˘        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("STRING") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@<iI"°        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash
      end;Fi[	@¸iII"º        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?
      end;Fi[	@vi'I"±        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end;Fi[	@li4I"∑        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@øi°I"¢        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false
      end;Fi[@.I"@var = nil;FI"end;FI" ;FI"def function(arglist);Fi[[	@ûi—I"        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!
        if has_and_belongs_to_many? and (association_foreign_key == foreign_key) then;Fi[	@Úi:I"¿      end
      
      # Support for testing.
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        configuration.to_sass_plugin_options
      end;Fi[	@‡i	I"	module Cucumber
  module Cli
    class ProfileLoader
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        raise(ProfileNotFound, "STRING") unless cucumber_yml.has_key?(var)
        var = (cucumber_yml[var] or "STRING");Fi[	@)igI"µ        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var
        @var = "STRING";Fi[	@oi´I"≥        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var)
        @var = 0;Fi[	@ri5I"Ø        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var
        var ||= @var;Fi[	@=i.I"§        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var)
        var;Fi[@.I"@var, @var = var, var;FI"end;FI" ;FI"def function(arglist);Fi[[	@~iI"„    class ConnectionSpecification
      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        @var = var.config.dup
      end;Fi[	I"Idata//activerecord_proj/active_record/tasks/sqlite_database_tasks.rb;Ti
I"T    class SQLiteDatabaseTasks
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        raise(DatabaseAlreadyExists) if File.exist?(configuration["STRING"])
        establish_connection(configuration);Fi[	@˘i&I"Ì        end
        
        class ArrayProxy
          def function(arglist)
            @var, @var = var, var
          end
          
          def function(arglist)
            @var.send(:"read_inherited_#{@var}STRING")
          end;Fi[	@#i#I"        
        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) };Fi[	I"-data//cucumber_prok/cucumber/ast/tags.rb;TiI"˚    class Tags
      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        @var.each { |arglist| var.visit_tag_name(var.name) };Fi[	I":data//cucumber_prok/cucumber/step_definition_light.rb;Ti	I"  class StepDefinitionLight
    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist)
      (regexp_source == var.regexp_source) and (file_colon_line == var.file_colon_line)
    end;Fi[	I"=data//cucumber_prok/cucumber/wire_support/wire_packet.rb;TiI"Ã      
      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        var = [@var]
        (var << @var) if @var;Fi[@±'@≤'I"	self;FI"end;FI" ;Fi[[	@S,iII"ù    #
    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    
    # Convert the criteria to a proc.
    #;Fi[	@=iI"¬      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[	@=iI"¥      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.
      #;Fi[	@=i)I"∂      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.
      #;Fi[	@=iAI"æ      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.
      #;Fi[	@=iÉI"Ø      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Is the object multi args.
      #;Fi[	@@iI"—      #
      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[@±'@≤'I"@var = var;FI"end;FI" ;Fi[[	@ i-I"≤      #
      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Get the skiping value.
      #;Fi[	@ iII"≤      #
      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Apply criteria options.
      #;Fi[	@S,ifI"ƒ    #
    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Is the criteria for embedded documents?
    #;Fi[	@S,iÒI"!    #
    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Merges another object with this +Criteria+ and returns a new criteria.
    # The other object may be a +Criteria+ or a +Hash+. This is used to;Fi[	@X,i I"ê    #
    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@miòI"˝        #
        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Normalize the documents, in case they were provided as an array of
        # hashes.;Fi[	@miœI"Ò        #
        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Get the selector for executing atomic operations on the collection.
        #;Fi[@(@)@@‹I"
super;Fi[[	I"+data//activemodel_proj/active_model.rb;Ti7I"´    eager_autoload do |arglist|
      autoload(:JSON)
      autoload(:Xml)
    end
  end
  
  def function(arglist)
    super
    ActiveModel::Serializer.eager_load!
  end;Fi[	@ÑixI"Û        
        def function(arglist)
          @var[Process.pid]
        end
      end
      
      def function(arglist)
        super
        @var = StatementPool.new(@var, var.fetch(:statement_limit) { |arglist| 1000 })
        @var = nil;Fi[	@Ñi®I"ÿ          @var.respond_to?(:errno) ? (@var.errno.zero?) : (true))
        rescue Mysql::Error
          false
        end
      end
      
      def function(arglist)
        super
        disconnect!
        connect;Fi[	@ªiI"          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super
        if ActiveRecord::Base.connected? then
          var[:db_runtime] = ((db_runtime or 0) + ActiveRecord::LogSubscriber.reset_runtime);Fi[	@ i$I"        @var = {}
        ALL.each do |arglist|
          @var[var] = reverse.find { |arglist| var.match_platform(var) }
        end
      end
      
      def function(arglist)
        super
        @var = var.required_by.dup
        @var = var.activated.dup;Fi[	@«iI"µ      flash[:error] = @var.errors.full_messages.join("STRING")
      Rails.logger.info("STRING")
      redirect_to(:back)
    end
  end
  
  def function(arglist)
    super
  end
  ;Fi[	@ß
iI"Â    @var = var
    if other_connection.last_ref_id.!=(var) then
      self.other_connection.last_ref_id = var
    end
  end
  
  def function(arglist)
    super
    self.processed_headers = false
    self.output_buffer = "STRING";Fi[@(@@∑
I"@var ||= [];FI"end;Fi[[	@i/I"¨    # RubyGems 1.8+ used only.
    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist);Fi[	@iI"Ë        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end
    
    # Returns an array of Rule instances which match the action and subject;Fi[	@=iSI"∆      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist);Fi[	@ˆi#I"3        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@ˆi'I"∏        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@ iI"Œ        def function(arglist)
          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@wi‹I"ß      
      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist);Fi[@.@b@Ä@Æ I"end;Fi[[	@eidI"ﬁ    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@›iaI"        ##
        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##;Fi[	@vi<I"˚        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@i
I"Ω    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@[iòI"À  fatal(ARGV.force?.!)
  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@OiI"Û      class AttributeAssignmentError < Mongoid::Errors::MongoidError
        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      ;Fi[	@Ji	I"∫  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[I"raise("STRING");FI"end;FI"end;FI"end;FI"end;Fi[[	I"Odata//activemodel_proj/active_model/deprecated_mass_assignment_security.rb;TiI"e      end
      
      def function(arglist)
        raise("STRING")
      end
    end
  end
end;Fi[	@Úi0I"                  if var.is_a?(Symbol) then
                    Compass::AppIntegration.lookup(var).configuration
                  else
                    raise("STRING")
                  end
                end
              end
            end
          end
        end;Fi[	@ÑiI"⁄          if controller.instance_of?(StreamsController) then
            stream_path(:max_time => (time_for_scroll(@var)))
          else
            raise("STRING")
          end
        end
      end
    end
  end
  ;Fi[	@Âi$I"m      if var = var.first then
        var
      else
        raise("STRING")
      end
    end
  end
end;Fi[	@=i?I"y        end
        
        def function(arglist)
          raise("STRING")
        end
      end
    end
  end
end;Fi[	@äiI"í          var = ($2 == "STRING") ? (nil) : ($2)
          [$1, var]
        else
          raise("STRING")
        end
      end
    end
  end
end;Fi[	I">data//rspec_proj/spec/runner/heckle_runner_unsupported.rb;Ti	I"{  module Runner
    class HeckleRunner
      def function(arglist)
        raise("STRING")
      end
    end
  end
end;Fi[@'I"nil;FI"end;FI"end;FI"end;Fi[[	@ÅiI"E          if var.to_s =~ /PRIMARY KEY\s+(?:USING\s+\w+\s+)?\((.+)\)/ then
            var = $1.split("STRING").map { |arglist| var.delete("STRING") }
            (var.length == 1) ? ([var.first, nil]) : (nil)
          else
            nil
          end
        end
      end
      
      # Returns just a table's primary key;Fi[	@#i)I"‡        else
          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end;Fi[	I"Fdata//bundler_proj/bundler/vendor/thor/actions/empty_directory.rb;TiqI"        else
          if base.respond_to?(var, true) then
            raise(Thor::PrivateMethodEncodedError, "STRING")
          else
            nil
          end
        end
      end
      
      # Receives a hash of options and just execute the block if some;Fi[	@FiI"¨            var = var.offset(var)[0]
            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@Oi±I"            (@var << var)
            nil
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@˙	i#I"ä        if var then
          var.email_the_user(var, var)
          var
        else
          nil
        end
      end
    end
  end
  ;Fi[	@idI"r      "STRING"
    when /^#{HOMEBREW_LIBRARY}STRING/ then
      "STRING"
    else
      nil
    end
  end
end;Fi[@
@I"@var = nil;FI"end;FI" ;Fi[[	@=iUI"Ù      def function(arglist)
        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      
      # Set the inverse association, if possible
      def function(arglist);Fi[	@ûi–I"⁄      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!;Fi[	@)ifI"µ        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var;Fi[	@oi™I"“        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var);Fi[	@ri4I"∂      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var;Fi[	@=i-I"ª        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var);Fi[	@CiI"†      def function(arglist)
        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      ;Fi[@(@@∑
I"var;FI"end;Fi[[	@ˇiI"ù      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist);Fi[	@Åi I"√      
      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist);Fi[	@ÑiÍI"∑        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[	@ÈiI"∑        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[	@Ui+I".          def function(arglist)
            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end
          
          alias :handle_snippet_text :handle_success;Fi[	@‚iI"Å    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist);Fi[	@‚iI"p    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[I"end.to_yaml;FI"/File.open("STRING", "STRING") do |arglist|;FI"var.puts(var);F@b-I"var.puts(var);Fi[[	@∆i"I"Ä        var = ((var.strftime("STRING") + var) + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
        if var then;Fi[	@–iI"Æ        var = ("STRING" % [var.year, var.month, var.day, var])
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:id]), "STRING" => (var[:alias]), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end;Fi[	@”i!I"ï        var = ([var.year, var.month, var.day, var].join("STRING") + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end;Fi[	@÷iI"Ω        var = (([var.year, var.month, var.day, var].join("STRING") + "STRING") + self.suffix(var))
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:entry_id]), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end;Fi[	@o-i.I"è          var = ("STRING" % [var.year, var.month, var.day, var])
          var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |arglist|
            (var.nil? or (var == "STRING"))
          end.to_yaml
          File.open("STRING", "STRING") do |arglist|
            var.puts(var)
            var.puts("STRING")
            var.puts(var)
          end
        end;Fi[	@‹iI"ü        var = ([var.strftime("STRING"), var].join("STRING") + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:Keywords].split("STRING")) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end;Fi[	@‚i\I"      end
      var = { "STRING" => (var[:type].to_s), "STRING" => (var[:status].to_s), "STRING" => ((var[:status].to_s == "STRING")), "STRING" => (var.to_s), "STRING" => (var[:author].to_s), "STRING" => (var[:author_login].to_s), "STRING" => (var[:author_email].to_s), "STRING" => (var[:author_url].to_s), "STRING" => (var), "STRING" => (var), "STRING" => (var[:id]), "STRING" => (var[:guid].to_s), "STRING" => (var), "STRING" => (var[:categories] ? (var) : (nil)), "STRING" => (var[:tags] ? (var) : (nil)), "STRING" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == "STRING"))
      end.to_yaml
      File.open("STRING", "STRING") do |arglist|
        var.puts(var)
        var.puts("STRING")
        var.puts(var)
      end
    end;Fi[@'@å%@ç%@é%I" ;Fi[[	@ıiAI"‰        specs_by_name(var)
      when Gem::Dependency then
        search_by_dependency(var, var)
      else
        raise("STRING")
      end
    end
    
    def function(arglist)
      sources.map { |arglist| var.class }.uniq;Fi[	@i!I"¸        when Ast::ScenarioOutline then
          @var = true
          @var.scenario_outline(var.gherkin_statement)
        else
          raise("STRING")
        end
      end
      
      def function(arglist)
        @var.step(var.gherkin_statement);Fi[	@ëi(I"'        if var then
          puts(var)
          var
        else
          raise("STRING")
        end
      end
      
      # Embed +src+ of MIME type +mime_type+ into the output. The +src+ argument may
      # be a path to a file, or if it's an image it may also be a Base64 encoded image. ;Fi[	I"-data//homebrew_proj/test/test_updater.rb;TiI"Ü      @var ||= []
      (@var << var)
      @var[var].shift
    else
      raise("STRING")
    end
  end
  
  alias :safe_system :`
  ;Fi[	I"3data//redmine_proj/redmine/helpers/calendar.rb;TiI"        when :week then
          @var = (var - ((var.cwday - first_wday) % 7))
          @var = (var + ((last_wday - var.cwday) % 7))
        else
          raise("STRING")
        end
      end
      
      # Sets calendar events
      def function(arglist);Fi[	@|
iI"ø            ::I18n.t(var.first, :count => (var.last))
          end
        end
      else
        raise("STRING")
      end
    end
    
    def function(arglist)
      var = "STRING".to_sym;Fi[	@íiII"J        @var = [] unless defined? @var
        if var[:data] and var[:data].kind_of?(Array) then
          (@var << var)
        else
          raise("STRING")
        end
      end
      
      # This method removes all data from the object so that you can
      # reuse it to create a new graph but with the same config options.;Fi[I"$(var.nil? or (var == "STRING"));FI"end.to_yaml;F@à.I"var.puts(var);F@b-i[[	@∆i!I"*        var = var.strip.downcase.gsub(/(&|&amp;)/, "STRING").gsub(/[\s\.\/\\]/, "STRING").gsub(/[^\w-]/, "STRING").gsub(/[-_]{2,}/, "STRING").gsub(/^[-_]/, "STRING").gsub(/[-_]$/, "STRING")
        var = ((var.strftime("STRING") + var) + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@–iI"¿        var = var[:content]
        var = ("STRING" % [var.year, var.month, var.day, var])
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:id]), "STRING" => (var[:alias]), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@”i I"§        var = var[:body]
        var = ([var.year, var.month, var.day, var].join("STRING") + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@÷iI"È        var = ((var + "STRING") + var) if var.!=(nil)
        var = (([var.year, var.month, var.day, var].join("STRING") + "STRING") + self.suffix(var))
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:entry_id]), "STRING" => (var) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@o-i-I"£          var = var["STRING"].!
          var = ("STRING" % [var.year, var.month, var.day, var])
          var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var) }.delete_if do |arglist|
            (var.nil? or (var == "STRING"))
          end.to_yaml
          File.open("STRING", "STRING") do |arglist|
            var.puts(var)
            var.puts("STRING")
            var.puts(var)
          end;Fi[	@‹iI"Æ        var = var[:Body]
        var = ([var.strftime("STRING"), var].join("STRING") + "STRING")
        var = { "STRING" => "STRING", "STRING" => (var.to_s), "STRING" => (var[:Keywords].split("STRING")) }.delete_if do |arglist|
          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end;Fi[	@‚i[I"@        var.sort! { |arglist| (var["STRING"] <=> var["STRING"]) }
      end
      var = { "STRING" => (var[:type].to_s), "STRING" => (var[:status].to_s), "STRING" => ((var[:status].to_s == "STRING")), "STRING" => (var.to_s), "STRING" => (var[:author].to_s), "STRING" => (var[:author_login].to_s), "STRING" => (var[:author_email].to_s), "STRING" => (var[:author_url].to_s), "STRING" => (var), "STRING" => (var), "STRING" => (var[:id]), "STRING" => (var[:guid].to_s), "STRING" => (var), "STRING" => (var[:categories] ? (var) : (nil)), "STRING" => (var[:tags] ? (var) : (nil)), "STRING" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == "STRING"))
      end.to_yaml
      File.open("STRING", "STRING") do |arglist|
        var.puts(var)
        var.puts("STRING")
        var.puts(var)
      end;Fi[@@I"#   end;TI"#;TI"#   person.pets;Ti[[	@-i%I"&      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-i^I"]      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-i|I"D      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-iïI"D      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-iI"P      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>]
      #;Ti[	@-iAI")      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-i[I"\      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,;Ti[@%@%@%I"end;FI"end;Fi[[	@Oi5I"[      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@Ri¶I"ë      
      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@RiåI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@UiI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@7idI"[      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@%+iWI"â      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist)
  puts("STRING");Fi[	@ïiI"í          true)
        rescue DRb::DRbConnError
          var.error_stream.puts("STRING")
          false
        end
      end
    end
  end
end;Fi[@“&@”&I"7# @param [ Symbol ] name The name of the relation.;FI"4# @param [ Hash ] options The relation options.;FI"D# @param [ Proc ] block Optional block for defining extensions.;Fi[[	@ri/I"ê        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then;Fi[	@riMI"ì        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var);Fi[	@riiI"è        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var);Fi[	@riÄI"î        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = reference_one_to_one(var, var, Referenced::In, &var);Fi[	@riôI"ë        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Referenced::Many, var, &var);Fi[	@riµI"m        #   class Preference
        #     include Mongoid::Document
        #     has_and_belongs_to_many :people
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        #
        # @since 2.0.0.rc.1;Fi[	@ri”I"è        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var);Fi[@X@YI"newobj;FI"out("STRING");FI"out("STRING");Fi[[	@si>I"´    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((((("STRING" + textstring("STRING")) + "STRING") + textstring(var["STRING"]["STRING"])) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"));Fi[	@viGI"y    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"));Fi[	@yi-I"y    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"));Fi[	@iéI"y    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"));Fi[	@iM
I".    out("STRING")
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out((("STRING" + (@var + 2).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out((("STRING" + var["STRING"]) + "STRING"))
    out((("STRING" + (@var + 2).to_s) + "STRING"));Fi[	@i^
I"ÿ    end
    out((("STRING" + var) + "STRING"))
    out((("STRING" + (@var + 4).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@iw
I"¨    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[@@Ò(@≤'I"	true;FI"end;Fi[[	@&iwI"≥      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@&i°I"≥        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[	@7iI"∏      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@:i|I"·      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the;Fi[	@:iæI"∞        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[	I"9data//mongoid_proj/lib/mongoid/extensions/integer.rb;TiI"Ê      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Is the object not to be converted to bson on criteria creation?;Fi[	@Ci'I"≤      #   range.resizable?
      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[@@Ò(@≤'I"	self;FI"end;Fi[[	@S,iHI"¥    #   criteria.to_criteria
    #
    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    
    # Convert the criteria to a proc.;Fi[	@=iI"·      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__);Fi[	@=iI"À      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.;Fi[	@=i(I"—      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.;Fi[	@=i@I"‘      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.;Fi[	@=iÇI"¡      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Is the object multi args.;Fi[	@@iI"Û      #   object_id.__evolve_object_id__
      #
      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__);Fi[@2)@3)@4)I" ;FI"def function(arglist);Fi[[	@RitI"ƒ        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested
        var = load_target if (var == :all);Fi[	@&i≥I"°            raise(var)
          end
        end
        true
      end
    end
    
    def function(arglist)
      var = class << Gem::SourceIndex
        self;Fi[	@&i1I"          var.results.failure?)
        rescue ProfilesNotDefinedError, YmlLoadError, ProfileNotFound => var
          @var.puts(var.message)
          true
        end
      end
      
      def function(arglist)
        return @var if @var
        @var = Configuration.new(@var, @var);Fi[	@üi@I"    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist)
    var = StatusMessage.find_by_guid(self.status_message_guid)
    if self.status_message_guid and var then;Fi[	@ˆiöI"Ω    else
      self.add_hidden_shareable(var, var)
      self.save
      true
    end
  end
  
  def function(arglist)
    var = var.base_class.to_s
    self.hidden_shareables[var].present?;Fi[	@`i5I"π            @var[:fog_public]
          end
        else
          true
        end
      end
      
      def function(arglist)
        for var, var in @var do
          (log("STRING");Fi[	@7iI"      class FilesystemAdapter < AbstractAdapter
        class << self
          def function(arglist)
            true
          end
        end
        
        def function(arglist)
          @var = with_trailling_slash(var)
          @var = var.blank? ? ("STRING") : (var);Fi[@
@@√-I"end;FI" ;Fi[[	@~i
I"ı  module ConnectionAdapters
    class ConnectionSpecification
      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        @var = var.config.dup;Fi[	@À-i	I"7  module Tasks
    class SQLiteDatabaseTasks
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        raise(DatabaseAlreadyExists) if File.exist?(configuration["STRING"]);Fi[	@#i"I"˚        include(Gherkin::Formatter::Escaping)
        
        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit;Fi[	@“-i
I"À  module Ast
    class Tags
      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	I"Fdata//cucumber_prok/cucumber/runtime/for_programming_languages.rb;Ti
I"˛  class Runtime
    class ForProgrammingLanguages
      extend(Forwardable)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def_delegators(:@user_interface, :embed, :ask, :puts, :features_paths, :step_match)
      ;Fi[	@’-iI"module Cucumber
  class StepDefinitionLight
    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist)
      (regexp_source == var.regexp_source) and (file_colon_line == var.file_colon_line);Fi[	@ÿ-iI"∏      end
      
      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        var = [@var];Fi[@/@0@nI"protected;FI" ;Fi[[	@1i%I"*            var[:encoding] = "STRING" if (type == :binary)
            var[:type] = (type == :string) ? (nil) : (type)
            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist)
            return if value.nil?;Fi[	@ƒiéI"‰        end
        raise(ActiveRecord::Rollback) unless var
      end
      var
    end
    
    protected
    
    # Save the new record state and id of a record so it can be restored later if a transaction fails.
    #:nodoc:;Fi[	@O	iÓI"¡      # Thor::Shell::Basic class.
      #
      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist)
        return var unless var.is_a?(Symbol);Fi[	@n	ijI"        trigger(var[:before], var) if var[:before]
        var = execute_task(var)
        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist)
        return if Thread.current[:rollback_requests].nil?;Fi[	@`i∑I"              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected
        
        def function(arglist)
          @var ||= Devise::ParamFilter.new(case_insensitive_keys, strip_whitespace_keys);Fi[	I"0data//paperclip_proj/paperclip/thumbnail.rb;TiXI"      (var << "STRING") if auto_orient
      ((var << "STRING") << "STRING") unless (var.nil? or var.empty?)
      (((var << "STRING") << "STRING") << "STRING") if var
      var
    end
    
    protected
    
    # Return true if the format is animated
    def function(arglist);Fi[	@~iI"·        var = true
        example_groups.each { |arglist| var = var.&(var.run(@var)) }
        finish
        var
      end
      
      protected
      
      def function(arglist)
        reporter.start(number_of_examples);Fi[I"7# Notify the user of the backup operation results.;FI"/# `status` indicates one of the following:;FI"#;FI"# `:success`;FI"+# : The backup completed successfully.;Fi[[	@›iI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@‡i5I"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@IitI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@›iI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@‡i%I"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@„iI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[@I"%# @return [ Mongo ] The context.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@ i∏I"¯      #   context.limit(20)
      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.limiting = var
        self;Fi[	@ i«I"ı      #   context.skip(20)
      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.skipping = var
        self;Fi[	@ i◊I"˘      #
      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        in_place_sort(var) and self
      end;Fi[	@  iÙI"˚      #   context.limit(20)
      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.limit(var) and self
      end;Fi[	@  i$I"˜      #   context.skip(20)
      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.skip(var) and self
      end;Fi[	@  i3I"˛      #
      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          super(&var);Fi[@I"1# @param [ String ] name The attribute name.;FI"7# @param [ String ] meth The name of the accessor.;FI"#;FI"# @since 3.0.0;Fi[[	@ i
I"K      #
      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@ iI"E      #
      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@ i(I"M      #
      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@ i7I"S      #
      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@ iFI"C      #
      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@ iUI">      #
      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[@I"7# @param [ Symbol ] name The name of the relation.;F@Á.@Ë.I"def function(arglist);Fi[[	@ri0I"Ø        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then
            raise(Errors::VersioningNotOnRoot.new(self));Fi[	@riNI"¶        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@rijI"•        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@riÅI"∞        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = reference_one_to_one(var, var, Referenced::In, &var)
          aliased_fields[var.to_s] = var.foreign_key;Fi[	@riöI"ï        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Referenced::Many, var, &var)
          relate(var, var);Fi[	@ri‘I"Ç        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var)
        end;Fi[@(@)@I"# :nodoc:;FI"def function(arglist);Fi[[	@MiÉI"¢      var.finish)
    rescue IOError
      # do nothing
    end
  end
  
  # :nodoc:
  def function(arglist)
    if (RUBY_VERSION > "STRING") then
      Net::HTTP;Fi[	@!i)I"√    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist)
    File.exist?("STRING") ? ("STRING") : ("STRING")
  end;Fi[	@HiI"⁄          var
        else
          Spec.warn(Spec::Example::NoDescriptionError.message("STRING", @var.location))
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var.options
      end;Fi[	@áiãI"0          (ENV["STRING"] or (rcov_opts.join("STRING") or "STRING"))
        else
          "STRING"
        end
      end
      
      # :nodoc:
      def function(arglist)
        STDERR.puts("STRING") if ENV["STRING"]
        (ENV["STRING"] or (ENV["STRING"] or (spec_opts.join("STRING") or "STRING")));Fi[	@áiöI"∂          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["STRING"] then
          FileList[ENV["STRING"]];Fi[	@øi+I"ƒ          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= mock_framework_path("STRING")
      end;Fi[I"private;FI" ;FI"##;F@i/@j/i[[	@›iI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@‡i2I"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@IiqI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@›iI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@‡i"I"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@„iI"ﬂ        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[@ı!@ˆ!I" ;FI"private;FI" ;Fi[[	@=iOI"¥  class BlockValidator < EachValidator
    def function(arglist)
      @var = var
      super
    end
    
    private
    
    def function(arglist)
      @var.call(var, var, var);Fi[	@¡iI"®    
    def function(arglist)
      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist)
      if self.record_timestamps then;Fi[	@œi!I"2      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super
      end
      
      private
      
      def function(arglist)
        ("STRING" if @var or "STRING" if @var);Fi[	@“i'I"8      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("STRING" + "STRING") + "STRING") + "STRING"))
        super
      end
      
      private
      
      def function(arglist)
        var = ("STRING" if @var or "STRING" if @var);Fi[	@«iI"î  end
  
  def function(arglist)
    super
  end
  
  private
  
  def function(arglist)
    return true if AppConfig.settings.enable_registrations?;Fi[	I"2data//mongoid_proj/lib/mongoid/validations.rb;TiœI"”            end
          end
        end
        super
      end
      
      private
      
      # Adds an associated validator for the relation if the validate option
      # was not provided or set to true.;Fi[@(@)@I"module InstanceMethods;FI"def self.included(arglist);Fi[[	@ÒiI"+          var[:find_options] ||= {}
          var[:author_key] = "STRING" if var[:author_key].is_a?(Symbol)
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@ˆiI"l          has_many(:attachments, var.merge(:as => :container, :order => "STRING", :dependent => :destroy))
          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@˘iI"4          send(:include, Redmine::Acts::Customizable::InstanceMethods)
          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@¸iI""          cattr_accessor(:event_options)
          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@i%I"Ö          searchable_options[:order_column] ||= searchable_options[:date_column]
          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@
iI"          end
          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[@
@@‰@ÂI"end;Fi[[	@˙i	I"«  module ConnectionAdapters
    class Transaction
      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    
    class ClosedTransaction < Transaction;Fi[	I"4data//activerecord_proj/active_record/errors.rb;TiaI"≈  
  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  
  class UnknownPrimaryKey < ActiveRecordError;Fi[	@*iI"        include(Devise::Controllers::Rememberable)
        
        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      
      # Remembers the given resource by setting up a cookie;Fi[	@ZiI"¬        def function(arglist)
          defined? @var ? (@var) : (Devise.scoped_views)
        end
        
        def function(arglist)
          @var = var
        end
      end
    end
  end;Fi[	@”i)I"–  def function(arglist)
    name =~ /(\w+)\/(\w+)\/([^\/]+)/ ? ("STRING".undent) : ("STRING")
  end
  
  def function(arglist)
    @var = var
  end
end
module Homebrew
  class InstallationError < RuntimeError;Fi[	@OiI"Õ      
      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError
        attr_reader(:errors)
        
        def function(arglist)
          @var = var
        end
      end
    end
    ;Fi[@÷!@◊!@– @ÿ!I"	else;Fi[[	I".data//capistrano_proj/capistrano/shell.rb;TiƒI"“    # then the scope is unrestricted.
    def function(arglist)
      var = case var
      when "STRING" then
        "STRING"
      when "STRING" then
        "STRING"
      else
        # do nothing
      end;Fi[	@÷ iI"            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else
            (Compass::Util.compass_warn("STRING")
            var.value);Fi[	@÷ iJI"√          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        else
          var
        end;Fi[	@çi˝I"                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              when "STRING" then
                "STRING"
              else
                "STRING"
              end;Fi[	@çi	I"Ò        else
          if @var.html4? then
            case @var.value[:type]
            when "STRING" then
              "STRING"
            when "STRING" then
              "STRING"
            else
              "STRING"
            end;Fi[	@ßioI"            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          when "STRING" then
            "STRING"
          else
            (var.value.first + "STRING")
          end;Fi[@(I"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;Fi[[	@simI"Ô        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@vibI"Ô        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@yi\I"Ô        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@ÅiHI"ﬂ        var = (var + "STRING") unless var.index("STRING").nil?
        var = var.index("STRING").nil?.! ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@iII"™          var = var.include?("STRING") ? ((var + "STRING")) : (var)
        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@i≥I"¡    if (var == 1) and (var == "STRING") then
      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[@(@)@@‹I""with_temp_folder do |arglist|;Fi[[	I"6data//homebrew_proj/test/test_pathname_install.rb;TiI"R      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(["STRING", "STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING");Fi[	@(0i'I"U      TARGET_FOLDER.install(["STRING", "STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(Dir["STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING");Fi[	@(0i/I""      TARGET_FOLDER.install(Dir["STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("STRING")
      system("STRING");Fi[	@(0i9I"P      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING");Fi[	@(0iBI"~      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("STRING" => "STRING", "STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING");Fi[	@(0iLI"5      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("STRING")
      system("STRING");Fi[@I"# `:failure`;FI"%# : The backup operation failed.;FI"H# : Notification will be sent, including the Exception which caused;FI"F# : the failure, the Exception's backtrace, a copy of the current;Fi[[	@›i(I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@‡i@I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@IiI"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@›i&I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@‡i0I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@„i$I"Î      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[@I"# `:warning`;FI"D# : The backup completed successfully, but warnings were logged;FI"C# : Notification will be sent, including a copy of the current;FI"6# : backup log, if `on_warning` was set to `true`;Fi[[	@›i#I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@‡i;I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@IizI"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@›i!I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@‡i+I"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@„iI"~      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[I"var.puts(var);F@b-I"var.puts(var);FI"end;FI"end;Fi[[	@–iI"·          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end;Fi[	@”i#I"·          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end;Fi[	@÷iI"‡          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
    ;Fi[	@o-i0I"/            (var.nil? or (var == "STRING"))
          end.to_yaml
          File.open("STRING", "STRING") do |arglist|
            var.puts(var)
            var.puts("STRING")
            var.puts(var)
          end
        end
        var = (var + 1)
        var = JSON.parse(self.fetch("STRING").body);Fi[	@‹iI"·          (var.nil? or (var == "STRING"))
        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end;Fi[	@‚i^I"Ì        (var.nil? or (var == "STRING"))
      end.to_yaml
      File.open("STRING", "STRING") do |arglist|
        var.puts(var)
        var.puts("STRING")
        var.puts(var)
      end
    end
    
    def self.clean_entities(arglist);Fi[@I"# `:success`;F@m/I"D# : Notification will be sent if `on_success` was set to `true`;FI"#;Fi[[	@›iI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@‡i7I"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@IivI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@›iI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@‡i'I"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@„iI"a      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[@o&@p&I"var = 1;F@s&I"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[[	@sipI"⁄    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then;Fi[	@si¥I"Á    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then;Fi[	@vieI"»    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@viØI"’    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@yi_I"⁄    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then;Fi[	@yi£I"Á    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then;Fi[@
@@µ@∂I"end;Fi[[	@˙ipI"¶      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end
    end
    
    class RealTransaction < OpenTransaction;Fi[	@#izI"ñ        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end;Fi[	@úi,I"É  def function(arglist)
    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	I"%data//haml_proj/haml/template.rb;TiI"º  
  module Util
    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end
Haml::Template.options[:ugly] = Rails.env.development?.!;Fi[	@ziI"≥    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|;Fi[	I":data//rspec_proj/spec/interop/test/unit/autorunner.rb;TiI"nclass Test::Unit::AutoRunner
  remove_method(:process_args)
  
  def function(arglist)
    true
  end
end;Fi[I"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);FI"assert(var.dylib?.!);FI"%assert(var.mach_o_executable?.!);Fi[[	I"*data//homebrew_proj/test/test_mach.rb;TiFI"!    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@§0iTI"!    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@§0ipI"%    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@§0ièI"    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@§0iüI"    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@§0iØI"    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs);Fi[@
@I"@var ||= "STRING";F@%-I"	self;Fi[[	@ôiI"¶        @var = true
        @var = nil
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      ;Fi[	@ôiI"ß        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      ;Fi[	@ôiI"ß        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      ;Fi[	@ôi$I"ß        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      ;Fi[	@ôi1I"ß        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      ;Fi[	@ôi7I"ß        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      ;Fi[@(@@∑
I"@var ||= "STRING";F@%-i[[	@ôiI"≤        @var = var
        @var = true
        @var = nil
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end;Fi[	@ôiI"∫        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end;Fi[	@ôiI"∫        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end;Fi[	@ôi#I"∫        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end;Fi[	@ôi0I"⁄        var = configuration.fetch(:gem_command, "STRING")
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end;Fi[	@ôi6I"∫        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end;Fi[I"assert(var.i386?.!);F@ù0@û0@ü0@†0i[[	@§0i7I"  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?)
    assert(var.text_executable?.!);Fi[	@§0iEI"  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@§0ioI"  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@§0iéI"     var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@§0iûI"     var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@§0iÆI""    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[@(@)@*@€I"'initializer("STRING") do |arglist|;Fi[[	@∂iHI"¿              end
            end
          end
        end
      end
    end
    
    initializer("STRING") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|
        begin;Fi[	@∂i|I"             ActiveRecord::Base.clear_reloadable_connections!
            ActiveRecord::Base.clear_cache!
          end
        end
      end
    end
    
    initializer("STRING") do |arglist|
      var = var.paths["STRING"].first
      config.watchable_files.concat(["STRING", "STRING"]);Fi[	@üi,I"m            handle_configuration_error(var)
          rescue ::Mongoid::Errors::NoSessionHosts => var
            handle_configuration_error(var)
          end
        end
      end
      
      initializer("STRING") do |arglist|
        config.after_initialize do |arglist|
          unless (Rails.root.join("STRING", "STRING").file? or ::Mongoid.configured?) then;Fi[	@üi5I"O          unless (Rails.root.join("STRING", "STRING").file? or ::Mongoid.configured?) then
            puts("STRING")
            puts("STRING")
          end
        end
      end
      
      initializer("STRING") do |arglist|
        config.after_initialize do |arglist|
          unless config.action_dispatch.rescue_responses then;Fi[	@üi=I"e        config.after_initialize do |arglist|
          unless config.action_dispatch.rescue_responses then
            ActionDispatch::ShowExceptions.rescue_responses.update(Railtie.rescue_responses)
          end
        end
      end
      
      initializer("STRING") do |arglist|
        config.to_prepare do |arglist|
          if $rails_rake_task then;Fi[	@üiRI"`          ::Mongoid.instantiate_observers
          ActionDispatch::Reloader.to_prepare do |arglist|
            ::Mongoid.instantiate_observers
          end
        end
      end
      
      initializer("STRING") do |arglist|
        config.after_initialize do |arglist|
          if defined? Unicorn and Unicorn::HttpServer::START_CTX.empty?.! then;Fi[@(@)@*@€I"module ClassMethods;Fi[[	@æi>I"∂              super
            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2)
      ;Fi[	I"Ddata//activerecord_proj/active_record/validations/associated.rb;TiI"h          (var.marked_for_destruction? or var.valid?(var.validation_context))
        end.any?) then
          var.errors.add(var, :invalid, options.merge(:value => (var)))
        end
      end
    end
    
    module ClassMethods
      # Validates whether the associated object or objects are all valid
      # themselves. Works with any kind of association.;Fi[	@<iI"f          if var.present? and var.all? { |arglist| var.marked_for_destruction? } then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods
      # Validates that the specified attributes are not blank (as defined by
      # Object#blank?), and, if the attribute is an association, that the;Fi[	@_i!I"4              var = var.cascade_strategy
              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods
        # Attempt to add the cascading information for the document to know how
        # to handle associated documents on a removal.;Fi[	@ÄiZI"          end
          unless var.empty? then
            var.criteria(var, self.class).without_options.pull(var.inverse_foreign_key, id)
          end
        end
      end
      
      module ClassMethods
        # Set up the syncing of many to many foreign keys.
        #;Fi[	@≠iêI"          if (_parent.nil? or instance_variable_get("STRING").!=(_parent)) then
            remove_instance_variable("STRING")
          end
        end
      end
    end
    
    module ClassMethods
      # This is convenience for librarys still on the old API.
      #;Fi[@q"@r"@î(@J'I"@var ||= "STRING";Fi[[	@ôiI"Ã      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self;Fi[	@ôiI"Ã      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self;Fi[	@ôi"I"Ã      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self;Fi[	@ôi(I"˘      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        var = configuration.fetch(:gem_command, "STRING")
        try("STRING", var);Fi[	@ôi/I"Í        @var ||= "STRING"
        var = configuration.fetch(:gem_command, "STRING")
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self;Fi[	@ôi5I"Ã      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self;Fi[@I"#   end;TI"#;TI"#   person.pets;TI"#   # => [;Ti[[	@-i&I"[      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-i_I"9      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-i}I"0      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-iñI"0      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-iBI"      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>;Ti[	@-i\I"K      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[@XI"end;FI" @var.each_pair do |arglist|;FI"newobj;FI"@var[var]["STRING"] = @var;Fi[[	@siÙI"    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var);Fi[	@siI"˚      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then;Fi[	@vi˝I"    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var);Fi[	@viI"˚      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then;Fi[	@yi„I"    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var);Fi[	@yiÛI"˚      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then;Fi[@I"#   class Person;FI"+#     include ActiveModel::Validations;FI"#;FI"#     attr_accessor :name;Fi[[	@5iI"k      # <tt>ActiveModel::StrictValidationFailed</tt> instead of adding error
      # when validation fails. See <tt>validates</tt> for more information about
      # the validation itself.
      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name
      #     validates! :name, presence: true
      #   end;Fi[	I"7data//activemodel_proj/active_model/validations.rb;TiπI"    
    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@91i I"    
    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@91i⁄I"D    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[	@91iÒI"    
    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@91iI"D    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[@(@@∑
I"var = "STRING";FI")var.extend(StringInreplaceExtension);Fi[[	I"/data//homebrew_proj/test/test_inreplace.rb;TiI"    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@H1iI"    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@H1iI"    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@H1i"I"    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var);Fi[	@H1i)I"    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.remove_make_var!("STRING")
    assert_equal("STRING", var);Fi[	@H1i0I"    var.extend(StringInreplaceExtension)
    var.remove_make_var!("STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.remove_make_var!(["STRING", "STRING"])
    assert_equal("STRING", var);Fi[@@11I"0#     include ActiveModel::AttributeMethods;FI"#;FI"#     attr_accessor :name;Fi[[	@◊i#I"K      #
      # An instance method <tt>#{prefix}attribute</tt> must exist and accept
      # at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_prefix 'clear_'
      #     define_attribute_methods :name;Fi[	@◊iGI"L      #
      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@◊ikI"s      #
      # An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and
      # accept at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
      #     define_attribute_methods :name;Fi[	@◊iÅI"      end
      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@◊i√I"x      # To use, pass an attribute name (as string or symbol), be sure to declare
      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #;Fi[	@◊iÍI"0      end
      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name;Fi[@.@≥#@¥#I"end;FI"end;Fi[[	I"1data//activemodel_proj/active_model/model.rb;Ti'I"ê    #
    #  person = Person.new(id: 1, name: 'bob')
    #  person.persisted? # => false
    def function(arglist)
      false
    end
  end
end;Fi[	@Oi4I"g        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@Ri•I"õ      end
      
      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@Òi?I"\      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@7icI"†        ((var.index(File::SEPARATOR) == 0) or (var.index("STRING") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/railties/document.rb;TiI"∫    # only supports immediate deletion of associations.
    #
    # See ActionView::Helpers::FormHelper::fields_for for more info.
    def function(arglist)
      false
    end
  end
end;Fi[I" assert_equal("STRING", var);FI"end;FI" ;FI"def function(arglist);FI"var = "STRING";Fi[[	@H1iI"    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@H1iI"    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@H1iI"    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@H1i!I"    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING");Fi[	@H1i(I"    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.remove_make_var!("STRING");Fi[	@H1i/I"
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.remove_make_var!("STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.remove_make_var!(["STRING", "STRING"]);Fi[@j/I"#;FI"# `:success`;F@m/@l0i[[	@›iI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@‡i6I""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@IiuI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@›iI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@‡i&I""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@„iI""      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[I"# `:success`;F@m/@l0I"#;FI"# `:warning`;Fi[[	@›i I"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@‡i8I"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@IiwI"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@›iI"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@‡i(I"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@„iI"ù      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[@(I""STRING";FI"end;FI" ;FI"def function(arglist);Fi[[	@åi>I"Ú            else
              var.type_cast(var, var, true)
            end
          end
          "STRING"
        end
        
        def function(arglist)
          String.===(var) ? (ActiveSupport::JSON.decode(var)) : (var)
        end;Fi[	@/i<I"Â          path
        else
          options["STRING"] ? (shortref_for_display(options["STRING"])) : (ref)
        end
        "STRING"
      end
      
      def function(arglist)
        File.basename(@var, "STRING")
      end;Fi[	@li+I"Ò      AppConfig.services.facebook.open_graph_namespace
    else
      "STRING"
    end
    "STRING"
  end
  
  def function(arglist)
    [og_title(var), og_type, og_url(var), og_image(var), og_description(var)].join("STRING").html_safe
  end;Fi[	@ÁiÕI"·      var = self.owner.username
    else
      var = self.diaspora_handle.split("STRING")[0]
    end
    "STRING"
  end
  
  def function(arglist)
    Base64.encode64(OpenSSL::Digest::SHA256.new(self.exported_key).to_s)
  end;Fi[	@i@I"›      var.parent.cd { |arglist| var = github_fork }
      var = "STRING"
      var = "STRING"
    end
    "STRING"
  end
  
  def function(arglist)
    begin
      (exec("STRING", github_info(var)) if ARGV.flag?("STRING");Fi[	@õioI"	          return var if output_to_file?
          unless (ENV["STRING"] or colour?.&((autospec? or output_to_tty?))) then
            return var
          end
          "STRING"
        end
        
        def function(arglist)
          File.===(@var)
        end;Fi[I"#@var = (HOMEBREW_CACHE + @var);FI"end;FI" ;FI"attr_reader :function;FI" ;Fi[[	@iµI".    @@svn ||= "STRING"
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (@var + "STRING") if ARGV.include?("STRING")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.sub!(/^svn\+/, "STRING") if @var =~ /^svn\+http:\/\//;Fi[	@iI"Ò    super
    @@git ||= "STRING"
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.!=(:revision) and host_supports_depth?;Fi[	@i\I"’  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    ohai("STRING");Fi[	@iáI"  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["STRING", "STRING", "STRING"].find { |arglist| File.executable?(var) };Fi[	@iØI"  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["STRING", "STRING"].find { |arglist| File.executable?(var) };Fi[	@iÕI"  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["STRING", "STRING"].find { |arglist| File.executable?(var) };Fi[@m/@l0I"#;FI"# `:warning`;F@H0i[[	@›i!I"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@‡i9I"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@IixI"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@›iI"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@‡i)I"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@„iI"ú      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[@(@@∑
I"@var[var] = var;FI"end;Fi[[	@Èi•I"Ÿ        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist);Fi[	@x	iI"¶      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[	@±iI"Õ      
      def function(arglist)
        @var[var].nil? ? (raise(Compass::Error, "STRING")) : (eval(@var[var]))
      end
      
      def function(arglist)
        @var[var] = var
      end
    end
    ;Fi[	@πi1I"¶      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[	@∏iÑI"«        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist);Fi[	@ ipI"       
      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[@l0I"#;FI"# `:warning`;F@H0@I0i[[	@›i"I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@‡i:I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@IiyI"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@›i I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@‡i*I"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@„iI"s      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[@'I"
raise;FI"end;FI"end;FI"end;Fi[[	@ÅiÌI"c        rescue ActiveRecord::StatementInvalid => var
          if var.message.split("STRING").first =~ /Packets out of order/ then
            raise(ActiveRecord::StatementInvalid, "STRING")
          else
            raise
          end
        end
      end
      
      # MysqlAdapter has to free a result after using it, so we use this method to write;Fi[	@4	iI"        rescue ActiveRecord::StatementInvalid => var
          if /database .* already exists/.===(var.message) then
            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist);Fi[	@ﬁi(I"Û        if var.message =~ /GraphViz not installed or dot not in PATH/ then
          Bundler.ui.error(var.message)
          Bundler.ui.warn("STRING")
        else
          raise
        end
      end
    end
    
    desc("STRING", "STRING");Fi[	I"4data//devise_proj/devise/rails/warden_compat.rb;Ti(I"§      if var.message =~ /uninitialized constant/ then
        Rails.logger.debug("STRING")
        # do nothing
      else
        raise
      end
    end
  end
end;Fi[	I"!data//homebrew_proj/build.rb;Ti{I"Ÿ      else
        if ((var = var.rack.children).size == 1) and var.first.directory? then
          var.first
        else
          raise
        end
      end
    end
    Keg.new(var).optlink)
  rescue StandardError;Fi[	@iHI"-          ignore_interrupts { |arglist| @var.unlink if @var.exist? }
          if var.kind_of?(ErrorDuringExecution) then
            raise(CurlDownloadStrategyError, "STRING")
          else
            raise
          end
        end
      end
      return @var)
    rescue CurlDownloadStrategyError;Fi[@.@—@“@'I" ;Fi[[	@=iGI"O    # Hook method that gets called by the initializer allowing verification
    # that the arguments supplied are valid. You could for example raise an
    # +ArgumentError+ when invalid options are supplied.
    def function(arglist)
      # do nothing
    end
  end
  
  class BlockValidator < EachValidator
    def function(arglist);Fi[	@˙i%I"‡      end
      
      # This is a noop when there are no open transactions
      def function(arglist)
        # do nothing
      end
    end
    
    class OpenTransaction < Transaction
      attr_reader(:parent, :records);Fi[	@MiI"–          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist)
        @var = (var or EmptyBackground.new);Fi[	@#iI"ü          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable)
      ;Fi[	@:i\I"∂      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    
    class JsLanguage
      include(LanguageSupport::LanguageMethods);Fi[	@OiI"„          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize)
      ;Fi[I"# `:warning`;F@H0@I0@J0I"#;Fi[[	@›i$I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@‡i<I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@Ii{I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@›i"I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@‡i,I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@„i I"í      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[@XI"	else;FI"if (@var == "STRING") then;FI"out("STRING");FI"	else;Fi[[	@ÅiÁI"‹    out("STRING")
    out("STRING")
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then
          out("STRING");Fi[	@ÅiÍI"      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then
          out("STRING")
        else
          out((("STRING" + (@var / 100)) + "STRING")) if @var.kind_of?(String).!
        end;Fi[	@ÅiÙI"≈      end
    end
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        out("STRING") if (@var == "STRING")
      end;Fi[	@i	I"‹    out("STRING")
    out("STRING")
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then
          out("STRING");Fi[	@i	I"       out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then
          out("STRING")
        else
          out((("STRING" + (@var / 100)) + "STRING")) if @var.is_a?(String).!
        end;Fi[	@i 	I"≈      end
    end
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        out("STRING") if (@var == "STRING")
      end;Fi[@é/@è/I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@ iI"å      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_change(var) };Fi[	@ iI"à      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_changed?(var) };Fi[	@ i)I"ù      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_changed_from_default?(var) };Fi[	@ i8I"ë      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_was(var) };Fi[	@ iGI"ä      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_will_change!(var) };Fi[	@ iVI"      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| reset_attribute!(var) };Fi[I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;FI"#     end;Fi[[	@ÕicI"Ó    # == Examples
    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@ÀiI"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@ÀiXI"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@Ài|I"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	I"<data//state_machine_proj/state_machine/macro_methods.rb;TiçI".    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do;Fi[	@Fi˝I"ÿ    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[@H0@I0@J0I"#;FI"# `:failure`;Fi[[	@›i%I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@‡i=I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@Ii|I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@›i#I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@‡i-I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@„i!I"Ø      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[@(I"
super;FI"end;FI" ;FI"def function(arglist);Fi[[	@:iI"%        end
        if (var[:allow_blank] == false) and (var[:minimum].nil? and var[:is].nil?) then
          var[:minimum] = 1
        end
        super
      end
      
      def function(arglist)
        var = CHECKS.keys.&(options.keys)
        raise(ArgumentError, "STRING") if var.empty?;Fi[	@Ri"I"”            raise_on_type_mismatch(var)
            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested
        var = super;Fi[	@≠i\I"      def function(arglist)
        if (var.size == 1) and (var == nil) then
          raise(ActiveRecord::IrreversibleMigration, "STRING")
        end
        super
      end
      
      def function(arglist)
        [:rename_table, var.reverse]
      end;Fi[	@¡iI"Ÿ            write_attribute(var.to_s, var)
          end
        end
      end
      super
    end
    
    def function(arglist)
      if should_record_timestamps? then
        var = current_time_from_proper_timezone;Fi[	@¡i)I"&          next if attribute_changed?(var)
          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist)
      self.record_timestamps and (partial_writes?.! or (changed? or attributes.keys.&(self.class.serialized_attributes.keys).present?))
    end;Fi[	@7i$I"ñ        if var.name.nil? then
          var = StepDefKey.new(var.step_definition.regexp_source, var.step_definition.file_colon_line)
          (@var[var] << { :keyword => (var), :step_match => (var), :status => (var), :file_colon_line => (@var.file_colon_line), :duration => (@var) })
        end
        super
      end
      
      def function(arglist)
        add_unused_stepdefs
        aggregate_info;Fi[@I0@J0I"#;FI"# `:failure`;F@60i[[	@›i&I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@‡i>I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@Ii}I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@›i$I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@‡i.I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@„i"I"±      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[@è/I"#;FI"# @since 3.0.0;F@H2I"/generated_methods.module_eval do |arglist|;Fi[[	@ iI"r      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_change(var) }
        end;Fi[	@ iI"q      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_changed?(var) }
        end;Fi[	@ i*I"Ü      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_changed_from_default?(var) }
        end;Fi[	@ i9I"w      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_was(var) }
        end;Fi[	@ iHI"t      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| attribute_will_change!(var) }
        end;Fi[	@ iWI"h      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("STRING") { |arglist| reset_attribute!(var) }
        end;Fi[@¬@ÈI"# do nothing;FI"end;FI"end;Fi[[	@ˇiFI"ä      when :hash then
        "STRING"
      when :array then
        "STRING"
      else
        # do nothing
      end
    end
  end
end;Fi[	@ßiJI"À          when /\bpassword.*:/i then
            "STRING"
          when /\(yes\/no\)/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private;Fi[	@ØiàI"¡            end
            "STRING"
          when /accept \(t\)emporarily/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private;Fi[	@≤iHI"≥            end
            "STRING"
          when /yes\/no/i then
            "STRING"
          else
            # do nothing
          end
        end
        
        private;Fi[	@ΩiSI"          when /The entry \'(.+?)\' is no longer a directory/ then
            raise(Capistrano::Error, "STRING")
          when /accept \(t\)emporarily/ then
            "STRING"
          else
            # do nothing
          end
        end
        
        private;Fi[	@[i@I"î    when :rbx then
      "STRING"
    when :ruby then
      "STRING"
    else
      # do nothing
    end
  end
end
class X11Dependency < Requirement;Fi[@'I"	true;FI"end;FI"end;FI" ;Fi[[	@RisI"ÿ          inverse_updates_counter_cache?(through_reflection).!
        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested;Fi[	@üi?I"	  def function(arglist)
    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist)
    var = StatusMessage.find_by_guid(self.status_message_guid);Fi[	@üiHI"    var = StatusMessage.find_by_guid(self.status_message_guid)
    if self.status_message_guid and var then
      (self.diaspora_handle == var.diaspora_handle)
    else
      true
    end
  end
  
  def self.diaspora_initialize(arglist)
    var = self.new(var.to_hash);Fi[	@—inI"•    @var = case @var
    when :provided_pre_mountain_lion then
      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function
  ;Fi[	@`i4I"Ø          else
            @var[:fog_public]
          end
        else
          true
        end
      end
      
      def function(arglist)
        for var, var in @var do;Fi[	@FiXI"        @var = @var = nil
        raise(var) if var
        var.!
      else
        true
      end
    end
    
    # Runs the machine's +before+ callbacks for this transition.  Only
    # callbacks that are configured to match the event, from state, and to;Fi[@)I"var = "STRING";FI"var = "STRING";FI"var = "STRING";FI"	else;Fi[[	@sicI"    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?;Fi[	@viXI"    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?;Fi[	@yiRI"    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?;Fi[	@Åi>I"    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "STRING")
    var = 0
    if var.!=(0) then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.index("STRING").nil?;Fi[	@i=I"‘    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        if var.is_a?(String) then
          var = "STRING";Fi[	@iˆI"Ì    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        if var.is_a?(String) then
          var = "STRING";Fi[@(@@„/@‰/I"var.extend(ClassMethods);Fi[[	@ÒiI"          var[:author_key] = "STRING" if var[:author_key].is_a?(Symbol)
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@ˆiI"
          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@˘iI"ˆ          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@¸iI"          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@i&I"=          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@
iI"          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[@J0I"#;FI"# `:failure`;F@60@70i[[	@›i'I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@‡i?I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@Ii~I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@›i%I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@‡i/I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@„i#I"ˆ      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[I"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);FI"if ARGV.named.empty? then;Fi[[	I"'data//homebrew_proj/cmd/--cache.rb;Ti I"{module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CACHE)
    else;Fi [	I"(data//homebrew_proj/cmd/--cellar.rb;Ti I"|module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CELLAR)
    else;Fi [	I"(data//homebrew_proj/cmd/--prefix.rb;Ti I"|module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_PREFIX)
    else;Fi [	@öi	I"Írequire("keg")
require("bottles")
require("cmd/prune")
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      if HOMEBREW_CELLAR.directory? then
        HOMEBREW_CELLAR.children.each do |arglist|;Fi[	I"$data//homebrew_proj/cmd/home.rb;Ti I"Åmodule Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      exec_browser(HOMEBREW_WWW)
    else;Fi [	I"#data//homebrew_proj/cmd/log.rb;Ti I"®module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      cd(HOMEBREW_REPOSITORY)
      exec("STRING", "STRING", *ARGV.options_only);Fi [I"# `:failure`;F@60@70@80I"K# : backup log and other information if `on_failure` was set to `true`;Fi[[	@›i)I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@‡iAI"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@Ii{I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@›i'I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@‡i1I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@„i%I"¡      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[@60@70@80@3I"#;Fi[[	@›i*I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@‡iBI"ò      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@Ii|I"ò      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@›i(I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@‡i2I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@„i&I"ì      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[@70@80@3I"#;FI"def function(arglist);Fi[[	@›i+I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@‡iCI"{      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@Ii}I"{      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@›i)I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@‡i3I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@„i'I"v      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[@
@„/@‰/@„2I"end;Fi[[	@ÒiI"‰          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@ˆiI"„          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@˘iI"‚          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@¸iI"!          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["STRING", "STRING", "STRING", "STRING", "STRING"].each do |arglist|;Fi[	@i'I"ı          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@
iI"          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers;Fi[I"var = "STRING";FI"	else;FI"var = "STRING";FI"end;FI"end;Fi[[	@—iõI"»      when :universal, "STRING" then
        var = "STRING"
      when "STRING" then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    (@var << Option.new(var, var))
  end;Fi[	@ÅibI"’      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING"))
    out(sprintf("STRING"));Fi[	@ÅitI"      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING", (var * @var), ((@var - var) * @var), (var * @var), (-var * @var), var))
  end;Fi[	@ipI"’      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING"))
    out(sprintf("STRING"));Fi[	@iäI"      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING", (var * @var), ((@var - var) * @var), (var * @var), (-var * @var), var))
  end;Fi[	@iπI"√    if (var == "STRING") then
      if (var == "STRING") then
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
      end
    end
    case var
    when "STRING" then;Fi[@.I"@var ||= "STRING";F@%-I"	self;FI"end;Fi[[	@ôiI"Æ        @var = nil
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist);Fi[	@ôiI"®        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist);Fi[	@ôiI"®        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist);Fi[	@ôi%I"®        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist);Fi[	@ôi2I"®        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist);Fi[	@ôi8I"®        self
      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist);Fi[@>%@?%@@%I"var = (var + 1);FI"$var = var if var and (var == 2);Fi[[	@siyI"      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@siçI"4          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[	@vinI"˚      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@viáI"&          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var);Fi[	@yihI"      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@yi|I"4          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[@@l@m@ÙI"
begin;Fi[[	@õiI"⁄    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled
        var = ActiveRecord::Base.connection_id;Fi[	@/	iI"P      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database)
          connection.create_database(configuration["STRING"], creation_options);Fi[	@4	iI"y      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var
          connection.create_database(configuration["STRING"], configuration.merge("STRING" => (encoding)));Fi[	@¯iI"ﬂ    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then
          Bundler.definition.ensure_equivalent_gemfile_and_lockfile(true);Fi[	@Îi9I"      
      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false unless var.has_key?(var) and (var == var[var]);Fi[	@ÎiNI"
      
      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false if var.has_key?(var) and (var == var[var]);Fi[@(@@∑
I"__raise("STRING");FI"end;Fi[[	@≤iI"™      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist);Fi[	@≤iI"˜        var = format_args(*var.expected_args)
        var = var.empty? ? ("STRING") : (format_args(*var))
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist);Fi[	@≤i I"∞      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist);Fi[	@≤i$I"∞      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist);Fi[	@≤i(I"∞      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist);Fi[	@≤i,I"¢      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      private;Fi[I";var = (var[var].chr == "STRING") ? ((var + 1)) : (var);FI"end;FI"var = -1;FI"var = var;FI"var = 0;Fi[[	@siãI"P          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@siŸI"Q          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@viÖI"P          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@vi·I"Q          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@yiI"P          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@yi»I"Q          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[@
@++@i/@j/I"#;Fi[[	@›iI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@‡i3I"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@IirI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@›iI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@‡i#I"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@„iI"‡      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[@
@¬(@√(I"##;F@i/i[[	@›iI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@‡i1I"Ê        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@IipI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@›iI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@‡i!I"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@„iI"ﬂ        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[@
@¬(@√(I"attr_reader :function;FI" ;Fi[[	@/	iMI"ÿ        var.concat(["STRING", "STRING"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("STRING" => (nil));Fi[	@4	iAI"œ        set_psql_env
        Kernel.system("STRING")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["STRING"] or DEFAULT_ENCODING);Fi[	@À-i*I"Ω        var = configuration["STRING"]
        `sqlite3 #{var}STRING#{var}STRING`
      end
      
      private
      
      attr_reader :function
      
      attr_reader :function
    end;Fi[	@x	iSI"«    def function(arglist)
      to.responds_to?(:read) ? ("STRING") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("STRING") if logger;Fi[	@Ci‚I"      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "STRING"
    end
    
    private
    
    attr_reader :function
    
    # Adds a predicate method to the owner class so long as a name has
    # actually been configured for the state;Fi[	@ÌiKI"Ä    protected
    
    attr_reader(:results)
    
    private
    
    attr_reader :function
    
    attr_reader :function
    ;Fi[I"(@var << var);FI"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@ri[I"        raise(ConnectionNotEstablished) unless @var
        var = new_connection
        var.pool = self
        (@var << var)
        var
      end
      
      def function(arglist)
        var.run_callbacks(:checkout) { |arglist| var.verify! }
        var;Fi[	I"Ddata//capistrano_proj/capistrano/recipes/deploy/dependencies.rb;TiI"Í      
      def function(arglist)
        var = RemoteDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        var = LocalDependency.new(configuration)
        (@var << var);Fi[	@ı3i!I"⁄      
      def function(arglist)
        var = LocalDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        @var.each { |arglist| yield(var) }
        self;Fi[	@CinI"Û      
      def function(arglist)
        var = RbStepDefinition.new(self, var, var, var)
        (@var << var)
        var
      end
      
      def function(arglist)
        if var then
          raise(MultipleWorld.new(@var, var)) if @var;Fi[	@2iÇI"Q        var = "STRING"
        (var << "STRING") if var[:subject_width]
        var = view.content_tag(:div, var, :class => (var[:css]), :style => (var), :title => (var[:title]), :id => (var[:id]))
        (@var << var)
        var
      end
      
      def function(arglist)
        var[:pdf].SetY(var[:top])
        var[:pdf].SetX(15);Fi[	@2iÂI"(          (var << "STRING")
          (var << view.content_tag(:div, var.html_safe, :style => (var), :class => "STRING"))
        end
        (@var << var)
        var
      end
      
      def function(arglist)
        var = (var[:height] or 2)
        if var[:bar_start] and var[:bar_end] then;Fi[I"@var ||= "STRING";F@%-I"	self;FI"end;FI" ;Fi[[	@ôiI"µ      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING";Fi[	@ôiI"µ      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING";Fi[	@ôi I"µ      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING";Fi[	@ôi&I"µ      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING";Fi[	@ôi3I"µ      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        @var ||= "STRING";Fi[	@ôi9I"Ê      end
      
      def function(arglist)
        @var ||= "STRING"
        try("STRING", var)
        self
      end
      
      def function(arglist)
        var = Regexp.new(Regexp.escape(var.to_s)) unless var.is_a?(Regexp);Fi[@ê+@i/@j/I"#;FI"# `:success`;Fi[[	@›iI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@‡i4I"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@IisI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@›iI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@‡i$I"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@„iI"      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[@\#I"end;FI" ;F@_#I"raise(NotImplementedError);Fi[[	@ˇiI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@ˇiI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@ˇiI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@ˇiI"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@ˇi I"∞      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@ˇi$I"±      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end;Fi[I"#raise(ArgumentError, "STRING");FI"end;FI"end;FI"end;FI"end;Fi[[	@7i1I"           raise(ArgumentError, "STRING")
        else
          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var[:multiline].!=(true))) then
            raise(ArgumentError, "STRING")
          end
        end
      end
    end
    
    module HelperMethods;Fi[	@≥iSI"K            var = var.collection? ? (:collection) : (:one_to_one)
            generated_feature_methods.module_eval("STRING", "STRING", (284 + 1))
          else
            raise(ArgumentError, "STRING")
          end
        end
      end
    end
    
    # Returns ActiveRecord::AutosaveAssociation::marked_for_destruction? It's;Fi[	@≥iÄI"€            if respond_to?(var) then
              send(var, var.except(*UNASSIGNABLE_KEYS))
            else
              raise(ArgumentError, "STRING")
            end
          end
        end
      end
    end
    ;Fi[	@åieI"                  remember_load(var) unless var[:reloading]
                  instance_eval(&var[:proc])
                else
                  raise(ArgumentError, "STRING")
                end
              end
            end
          end
        end
      end;Fi[	@ª*iMI"•      when String then
        eval(var, var.instance_eval { |arglist| binding }, &var)
      else
        raise(ArgumentError, "STRING")
      end
    end
  end
end;Fi[	@æ*iI"ç        end
        var.const_get(var.to_sym).fetch_or_new(var)
      else
        raise(ArgumentError, "STRING")
      end
    end
  end
end;Fi[I"@var = nil;FI"@var = nil;FI"@var = nil;FI"@var = nil;FI"@var = nil;Fi[[	@∞iI"        connection.clear_cache!
        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@∞iI"
        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@∞iI"        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var;Fi[	@∞iI"€        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var
        @var = nil;Fi[	@cioI"÷      def function(arglist)
        FileUtils.rm_rf(@var, :secure => (true)) if @var
        @var = []
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
      end
      ;Fi[	@MiÌI"    @var = [var, "STRING"].join("STRING").intern
    @var = [var, "STRING"].join("STRING").intern
    @var = [var, "STRING"].join("STRING").intern
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = OpenSSL::SSL::VERIFY_PEER
    @var = nil;Fi[I"if (@var == "STRING") then;FI"out("STRING");FI"	else;F@52I"out("STRING");Fi[[	@ÅiÊI"‹  def function(arglist)
    out("STRING")
    out("STRING")
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then;Fi[	@ÅiÈI"    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then
          out("STRING")
        else
          out((("STRING" + (@var / 100)) + "STRING")) if @var.kind_of?(String).!;Fi[	@ÅiÛI"«        end
      end
    end
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        out("STRING") if (@var == "STRING");Fi[	@i	I"‹  def function(arglist)
    out("STRING")
    out("STRING")
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then;Fi[	@i	I"    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        if (@var == "STRING") then
          out("STRING")
        else
          out((("STRING" + (@var / 100)) + "STRING")) if @var.is_a?(String).!;Fi[	@i	I"«        end
      end
    end
    if (@var == "STRING") then
      out("STRING")
    else
      if (@var == "STRING") then
        out("STRING")
      else
        out("STRING") if (@var == "STRING");Fi[@(@á-I"# do nothing;FI"end;FI"end;Fi[[	@‡iPI"“              end
            end
            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      
      protected;Fi[	@îi∫I"G                var[var].concat(var.map do |arglist|
                  { var.foreign_key => (var[primary_key_name]), var.association_foreign_key => (ActiveRecord::FixtureSet.identify(var)) }
                end)
              end
            else
              # do nothing
            end
          end
        end
        var;Fi[	@ûiAI"ÿ            Associations::HasOneThroughAssociation
          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@◊iI"”            @var = "STRING"
            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@i9I"ó          SetLineWidth(0.1)
        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #;Fi[	@˝i(I"Ω              LoopbackMatcher.instance
            else
              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end;Fi[@
@@õ3I"end;FI" ;Fi[[	@≤iI"—      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        var = format_args(*var.expected_args);Fi[	@≤iI"„        var = var.empty? ? ("STRING") : (format_args(*var))
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING");Fi[	@≤i!I"√      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING");Fi[	@≤i%I"√      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING");Fi[	@≤i)I"√      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING");Fi[	@≤i-I"¢      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      private
      ;Fi[@„/@‰/@„2I"end;FI" ;Fi[[	@ÒiI"        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Returns events of type event_type visible by user that occured between from and to;Fi[	@ˆiI"A        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:view_permission], self.project);Fi[	@˘iI"„        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          CustomField.where("STRING").sorted.all;Fi[	@¸iI"˙        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["STRING", "STRING", "STRING", "STRING", "STRING"].each do |arglist|
          var = "STRING";Fi[	@i(I"‰        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Searches the model for the given tokens;Fi[	@
iI"Ù        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers
        def function(arglist);Fi[@å I"end;FI" ;F@è I"2broadcast(var) { |arglist| var.accept(self) };Fi[[	@UiI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@UiI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@Ui0I"      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@Ui<I"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@UiPI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@UipI"÷      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[I"nil;FI"end;FI"end;FI"end;FI"end;Fi[[	@îiCI"Ê          begin
            var.instance_variable_set("STRING", var.find)
          rescue FixtureClassNotFound
            nil
          end
        end
      end
    end
    
    def self.instantiate_all_loaded_fixtures(arglist);Fi[	@#i*I"÷          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  ;Fi[	@FiI"á            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@Oi≤I"e            nil
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@˙	i$I"é          var.email_the_user(var, var)
          var
        else
          nil
        end
      end
    end
  end
  
  def function(arglist);Fi[	@¢iGI"¨        Object.send(:remove_const, Formula.class_s(name))
        var)
      rescue SyntaxError, TypeError, NameError, ArgumentError
        nil
      end
    end
  end
end;Fi[@.I"Jif (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then;FI",@var = sprintf("STRING", (var / 255.0));FI"	else;FI"J@var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0));Fi
[
[	@ÅiI"&  
  attr_reader :function
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    out(@var) if (@var > 0);Fi[	@ÅiI"*    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[	@ÅiI"*    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[	@i∂I"k  	# @since 1.3
  	# @see SetFillColor(), SetTextColor(), Line(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    out(@var) if (@var > 0);Fi[	@i I"`  	# @since 1.3
  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[@(@@∑
I"super("STRING");FI"end;Fi
[
[	@o iwI"Õ    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end
class ExplicitVersionSpecTestBall < Formula;Fi[	@o iãI"ü    version("STRING")
    url("STRING")
    sha1("STRING")
  end
  
  def function(arglist)
    super("STRING")
  end
end
class OldBottleSpecTestBall < Formula;Fi[	@o iõI"£  bottle do |arglist|
    url("STRING")
    sha1("STRING")
  end
  
  def function(arglist)
    super("STRING")
  end
end
class AncientBottleSpecTestBall < Formula;Fi[	@o iI"À    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end
class RevisedBottleSpecTestBall < Formula;Fi[	@o iI"≈    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end
class CustomVersionScheme < Version;Fi[@≠4@Æ4@Ø4I" ;FI"def function(arglist);Fi
[
[	@ëi;I"        begin
          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var
          nil
        end
      end
      
      def function(arglist)
        var = nil
        var = java.lang.Thread.new { |arglist| var = STDIN.gets };Fi[	@ˆikI"æ    begin
      self.invitations_to_me.first.sender.invitation_code
    rescue Exception => var
      nil
    end
  end
  
  def function(arglist)
    self.invited_by = var.user
    var.use!;Fi[	@†iËI"      if var and (var < (self.site.posts.length - 1)) then
        self.site.posts[(var + 1)]
      else
        nil
      end
    end
    
    def function(arglist)
      var = self.site.posts.index(self)
      var and (var > 0) ? (self.site.posts[(var - 1)]) : (nil);Fi[	@™i≠I"€              # do nothing
            end)
          rescue Nokogiri::SyntaxError, RuntimeError
            nil
          end
        end
        
        def function(arglist)
          @var = var
          @var = nil;Fi[	@ô
iI"’            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist)
        determine_best_match(var, var)
        best_match[:line];Fi[@F4@G4I"end;FI" ;FI"def function(arglist);Fi
[
[	@SiI"          @var = var
          @var = var
          @var = (var.first and var.first.class)
          @var = nil
          @var = nil
        end
        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end;Fi[	@ÍiI"±      @var = []
      @var = []
      @var = []
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      begin
        (var ||= Bundler.read_file(var.to_s);Fi[	@√iÆI"ï    
    def function(arglist)
      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end;Fi[	@¶iI"      def function(arglist)
        @var = (var == :no) ? (0) : (var)
        @var = var
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var ||= { :exactly => "STRING", :at_least => "STRING", :at_most => "STRING" }
      end;Fi[	@ƒiI"ﬁ        @var = []
        @var = 0
        @var = 0
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var = var
        formatters.each { |arglist| var.example_group_started(var) };Fi[@
@I"return "STRING";FI"end;FI"end;Fi
[
[	@!i2I"        end
        return var
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@íiêI"Ø        @var = ((width - @var) - @var)
        @var = ((height - @var) - @var)
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@iiãI"á          var = (var - 1))
        end
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@Oi«I"†        var = (10 ** var.to_f)
        ((var * var).to_i / var)
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@°iøI"ç      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[I"6source_root(File.expand_path("STRING", "STRING"));FI" ;FI"desc("STRING");FI" ;FI"
hide!;Fi
[
[	@i-I"
    class SharedViewsGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      
      # Override copy_views to just copy mailer and shared.;Fi[	@i<I"–    class FormForGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
    end
    ;Fi[	@iFI"÷    class SimpleFormForGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
    end
    ;Fi[	@iPI"‚    class ErbGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      
      def function(arglist);Fi[	@i^I"Ê    class MarkerbGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      
      def function(arglist);Fi[@
@I"teardown_db;FI"end;FI" ;Fi
[
[	I">data//redmine_proj/plugins/acts_as_list/test/list_test.rb;Ti3I"    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id));Fi[	@ 5iΩI"-      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id));Fi[	I"Fdata//redmine_proj/plugins/acts_as_tree/test/acts_as_tree_test.rb;Ti@I"π    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var]);Fi[	@%5iòI"F    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "STRING", :order => "STRING");Fi[	@%5iæI"·    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root));Fi[@34@44@54@64I" ;Fi
[
[	@:iI"         var.each do |arglist|
          var = options[var]
          unless ((var.is_a?(Integer) and (var >= 0)) or (var == Float::INFINITY)) then
            raise(ArgumentError, "STRING")
          end
        end
      end
      
      def function(arglist)
        var = tokenize(var);Fi[	@x	icI"        when :scp then
          prepare_scp_transfer(var, var, var)
        else
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    def function(arglist)
      var = (callback or Proc.new { |arglist| logger.trace("STRING") if logger and (var == 0) });Fi[	@x	iüI"÷        when :down then
          var.download(var, var, var, &var)
        else
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    def function(arglist)
      if var.is_a?(String) then;Fi[	@`iúI"˘          if var.respond_to?(:call) then
            var.call(self)
          else
            raise(ArgumentError, "STRING")
          end
        end
      end
      
      def function(arglist)
        @var ||= ::Fog::Storage.new(fog_credentials);Fi[	I"Sdata//paperclip_proj/paperclip/validators/attachment_content_type_validator.rb;Ti1I"%      
      def function(arglist)
        unless (options.has_key?(:content_type) or options.has_key?(:not)) then
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the content type of the file;Fi[@(@@∑
I"teardown_db;FI"end;Fi
[
[	@ 5i2I"∆  def function(arglist)
    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@ 5iºI"ﬁ    (1..4).each do |arglist|
      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@%5i?I"¡    @var = TreeMixin.create!(:parent_id => (@var.id))
    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@%5ióI",    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@%5iΩI"∞    setup_db
    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[@(@á-I"
super;FI"end;FI"end;Fi
[
[	@Åi˜I"∂            "STRING"
          else
            raise(ActiveRecordError, "STRING")
          end
        else
          super
        end
      end
      
      def function(arglist);Fi[	@îiLI"®              end
            else
              super
            end
          else
            super
          end
        end
        
        def function(arglist);Fi[	@ûiEI"              "STRING"
            else
              raise(ActiveRecordError, "STRING")
            end
          else
            super
          end
        end
        
        # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.;Fi[	@ﬁi5I"©          Kernel.exec("STRING")
        else
          puts(File.read("STRING"))
        end
      else
        super
      end
    end
    
    desc("STRING", "STRING");Fi[	@Ìi»I"Ù        end
        if skip_after and success? then
          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    
    # Tracks that before callbacks have now completed;Fi[@.I"teardown_db;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@ 5i4I".    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@ 5iæI"Ê    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@%5iAI"ƒ    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var])
    assert_equal(@var.children, [@var]);Fi[	@%5iôI"'    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "STRING", :order => "STRING")
    assert_equal([@var, @var, @var], var);Fi[	@%5iøI"æ    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root))
  end;Fi[@.I"[];FI"end;FI" ;FI"def function(arglist);Fi
[
[	@ÒiI"{      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end;Fi[	@¥ieI"<      # Override this method, as there are situations where the background
      # wind up being the one called fore Before scenarios, and
      # backgrounds don't have tags.
      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end;Fi[	@MiI"∞          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var)
        end;Fi[	@HiBI"g    "STRING"
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end;Fi[	@YiI"œ        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?
        var = var.backtrace.collect do |arglist|;Fi[I"include(ViewPathTemplates);FI" ;FI"6source_root(File.expand_path("STRING", "STRING"));FI" ;FI"desc("STRING");Fi
[
[	@i+I"‘    end
    
    class SharedViewsGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!;Fi[	@i:I"–    end
    
    class FormForGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!;Fi[	@iDI"÷    end
    
    class SimpleFormForGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!;Fi[	@iNI"Ã    end
    
    class ErbGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!;Fi[	@i\I"–    end
    
    class MarkerbGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!;Fi[@(@@∑
I"!var = Pathname.new("STRING");FI"assert(var.universal?.!);Fi
[
[	@§0iI"(    assert(var.text_executable?.!)
    assert((var.arch == :universal))
    assert_match(/Mach-O (64-bit )?dynamically linked shared library/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!);Fi[	@§0i$I"    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O dynamically linked shared library/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?);Fi[	@§0iNI"    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!);Fi[	@§0i\I"˝    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?);Fi[	@§0ijI"    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[I"if var then;F@)I"var = "STRING";FI"var = "STRING";FI"var = "STRING";Fi
[
[	@sibI"Ú    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING";Fi[	@viWI"Ú    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING";Fi[	@yiQI"Ú    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING";Fi[	@i<I"‚    var = var.gsub("STRING", "STRING")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        if var.is_a?(String) then;Fi[	@iıI"‚    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        if var.is_a?(String) then;Fi[@(@)I"var = -1;FI"var = 0;FI"var = 0;Fi
[
[	@silI"        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@viaI"        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@yi[I"        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@ÅiGI"
        var = "STRING" unless var.index("STRING").nil?
        var = (var + "STRING") unless var.index("STRING").nil?
        var = var.index("STRING").nil?.! ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0;Fi[	@iHI"‘          (var << "STRING") if var.include?("STRING")
          var = var.include?("STRING") ? ((var + "STRING")) : (var)
        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0;Fi[@.I"@var = {};FI"end;FI" ;FI"def function(arglist);Fi
[
[	@Èi£I"√        end
        
        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end;Fi[	@ iI"Ù      search(var).size
    end
    
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      if var = @var[var.name] and var.any? then
        var = [var.requirement.as_list, var.first.version.to_s].flatten.compact;Fi[	@LiI"‡        
        Node = Struct.new(:key, :value, :next, :prev)
        
        def function(arglist)
          @var = {}
        end
        
        def function(arglist)
          @var[var] and @var[var].value
        end;Fi[	@iÆI"    end
    
    # Removes previously aliased actions including the defaults.
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      var = ModelAdapters::AbstractAdapter.adapter_class(var)
      var.new(var, relevant_rules_for_query(var, var));Fi[	I"Bdata//paperclip_proj/paperclip/interpolations/plural_cache.rb;TiI"«module Paperclip
  module Interpolations
    class PluralCache
      def function(arglist)
        @var = {}
      end
      
      def function(arglist)
        @var[var] ||= var.pluralize
      end;Fi[@
@öI" ;FI"private;FI" ;Fi
[
[	I"Qdata//activerecord_proj/active_record/associations/belongs_to_association.rb;TiI"æ        super
        @var = false
      end
      
      attr_reader :function
      
      private
      
      def function(arglist)
        loaded?.! and (foreign_key_present? and klass);Fi[	I"Pdata//activerecord_proj/active_record/attribute_methods/before_type_cast.rb;TiI"»      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      
      private
      
      # Handle *_before_type_cast for method_missing.
      def function(arglist);Fi[	@ˇi≥I"            @var = var.slice((-32..-1))
            @var = @var.sub((@var + "STRING"), "STRING")
          end
          
          attr_reader :function
          
          private
          
          ##
          # Sanitize string and replace any invalid UTF-8 characters.;Fi[	@L	i/I"†      check_requirement!
      @var
    end
    
    attr_reader :function
    
    private
    
    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/;Fi[	@‘#iI"¯        @var = var
        self
      end
      
      attr_reader :function
      
      private
      
      # Searches the path, looking for the given utility. If an executable
      # file is found that matches the parameter, this returns true.;Fi[@
@ö@∆5I"attr_reader :function;FI" ;Fi
[
[	@LiHI"‰        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Returns true if the record is persisted, i.e. it's not a new record and it was
    # not destroyed, otherwise returns false.;Fi[	@ç	ieI"¥      def function(arglist)
        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      
      protected
      ;Fi[	@?iûI"7      var = @var[:processors]
      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Saves the file, if there are no errors. If there are, it flushes them to
    # the instance's errors and returns false, cancelling the save.;Fi[	@§iI"Ω          @var = 0
          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist)
          @var = var;Fi[	@ÌiMI"∞    attr_reader(:results)
    
    private
    
    attr_reader :function
    
    attr_reader :function
    
    # Gets the object being transitioned
    def function(arglist);Fi[@
@I""STRING".undent;FI"end;FI"end;Fi
[
[	I"&data//homebrew_proj/cmd/create.rb;TiaI"á    end
    path.write(ERB.new(template, nil, "STRING").result(binding))
  end
  
  def function(arglist)
    "STRING".undent
  end
end;Fi[	@[iÆI"¡  fatal(true)
  
  satisfy(:build_env => (false)) { |arglist| MacOS::Xcode.installed? }
  
  def function(arglist)
    "STRING".undent
  end
end
class MysqlInstalled < Requirement
  fatal(true);Fi[	@[iπI"´  env(:userpaths)
  
  satisfy { |arglist| which("STRING") }
  
  def function(arglist)
    "STRING".undent
  end
end
class PostgresqlInstalled < Requirement
  fatal(true);Fi[	@[iƒI"§  env(:userpaths)
  
  satisfy { |arglist| which("STRING") }
  
  def function(arglist)
    "STRING".undent
  end
end
class TeXInstalled < Requirement
  fatal(true);Fi[	@[iœI"ä  env(:userpaths)
  
  satisfy { |arglist| (which("STRING") or which("STRING")) }
  
  def function(arglist)
    "STRING".undent
  end
end;Fi[@(@)I"module Homebrew;FI"extend(self);FI" ;Fi
[
[	I"$data//homebrew_proj/cmd/deps.rb;Ti
I"Â  var.deps.each do |arglist|
    puts((("STRING" * var) + var.to_s))
    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("STRING") then;Fi[	I"#data//homebrew_proj/cmd/irb.rb;TiI"¶class String
  def function(arglist)
    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("STRING") then;Fi[	@
iI"≤      raise(FormulaUnspecifiedError) if ARGV.named.empty?
      ARGV.formulae
    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    ff.each do |arglist|;Fi[	I"'data//homebrew_proj/cmd/upgrade.rb;Ti	I"›class Fixnum
  def function(arglist)
    (self > 1) ? ("STRING") : ("STRING")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then;Fi[	@”iãI"à  
  def function(arglist)
    (super + advice.to_s)
  end
end
module Homebrew
  extend(self)
  
  SUDO_BAD_ERRMSG = "STRING".undent
end;Fi[@.I"super(var);FI"(instance_eval(&var) if block_given?;FI"end;FI" ;Fi
[
[	@›iI"—      # Campfire account's subdomain
      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@IilI"-      # Folder where mail will be kept when using the `:file` `delivery_method` option.
      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@›iI"‡      ##
      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@‡iI"Ã      # The message title
      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@„iI"Ã      # Twitter consumer key credentials
      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[@.I"return "STRING";FI"end;FI"end;FI"end;Fi
[
[	@!i3I"x        return var
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@íiëI"à        @var = ((height - @var) - @var)
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@iiåI"q        end
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@Oi»I"Å        ((var * var).to_i / var)
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[	@°i¿I"v        "STRING"
      end
      
      def function(arglist)
        return "STRING"
      end
    end
  end
end;Fi[@.@õ3I"end;FI" ;FI"def function(arglist);Fi
[
[	@≤iI"Ò        @var ||= {}
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        var = format_args(*var.expected_args)
        var = var.empty? ? ("STRING") : (format_args(*var));Fi[	@≤iI"±        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end;Fi[	@≤i"I"±        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end;Fi[	@≤i&I"±        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end;Fi[	@≤i*I"±        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end;Fi[@(@@ö@õI"private;Fi
[
[	@À5iI"£      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function
      
      private
      
      def function(arglist);Fi[	@Œ5iI"˝      #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      
      private
      
      # Handle *_before_type_cast for method_missing.;Fi[	@ˇi≤I"ı            @var = var.slice((4..-36))
            @var = var.slice((-32..-1))
            @var = @var.sub((@var + "STRING"), "STRING")
          end
          
          attr_reader :function
          
          private
          
          ##;Fi[	@L	i.I"Ñ      end
      check_requirement!
      @var
    end
    
    attr_reader :function
    
    private
    
    def function(arglist);Fi[	@‘#iI"œ      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      
      private
      
      # Searches the path, looking for the given utility. If an executable;Fi[@.I"@var[var] = var;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@ÈißI"«            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end;Fi[	@x	iÅI"°        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!
      end;Fi[	@πi3I"ª        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var
        @var = (var = false;Fi[	@∏iÜI"¥          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end;Fi[	@ irI"¸        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end;Fi[@(@I"#:nodoc:;FI"def function(arglist);FI"
begin;Fi
[
[	@ÅiI"¶        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue;Fi[	@ÅiI"¶        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue;Fi[	@óiI"p      module ReferentialIntegrity
        def function(arglist)
          true
        end
        
        #:nodoc:
        def function(arglist)
          begin
            (if supports_disable_referential_integrity? then
              execute(tables.collect { |arglist| "STRING" }.join("STRING")) rescue execute(tables.collect { |arglist| "STRING" }.join("STRING"));Fi[	@#iÀI"Ì          var[0].value = var
          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          require("diff/lcs")
        rescue LoadError => var;Fi[	@ÇiHI"ø        else
          raise(MockExpectationError, "STRING")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          verify_expectations
        ensure;Fi[@(@@S6@T6I"@var.each do |arglist|;Fi
[
[	@?iõI"=      instance_write(:fingerprint, nil)
      instance_write(:created_at, nil) if has_enabled_but_unset_created_at?
      instance_write(:updated_at, nil)
    end
    
    #:nodoc:
    def function(arglist)
      @var.each do |arglist|
        [var].flatten.each { |arglist| instance.errors.add(name, var) }
      end;Fi[	I"9data//paperclip_proj/paperclip/storage/filesystem.rb;TiI"'      
      def function(arglist)
        original_filename ? (File.exist?(path(var))) : (false)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          FileUtils.mkdir_p(File.dirname(path(var)))
          File.open(path(var), "STRING") do |arglist|;Fi[	@g6i!I"æ        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING");Fi[	@Ïi∏I"Ÿ      
      def function(arglist)
        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING");Fi[	@Ïi‘I"æ        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING");Fi[@@Ò@##I"@var = var;FI"end;Fi
[
[	@ÌiI"§    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function;Fi[	@iI"Œ    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick;Fi[	@i*I"¬        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@» iI"Ù    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.;Fi[	@HiI"H      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created;Fi[I"require("rubygems");FI"require("sequel");FI"require("fileutils");FI"require("yaml");FI"module Jekyll;Fi
[
[	@∆i I"}require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Drupal
    QUERY = "STRING";Fi [	@–i I"Ürequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Joomla
    def self.process(arglist);Fi [	@÷i I"~require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module MT
    QUERY = "STRING";Fi [	@‹i I"Çrequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module TextPattern
    QUERY = "STRING";Fi [	@‚i I"ârequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module WordPress
    def self.process(arglist);Fi [@.I"@var.empty?;TI"end;TI" ;TI"def function(arglist);Fi
[
[	@L	i9I"Å      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first
    end;Fi[	@0*i.I"‘        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length }
        var.max;Fi[	@OifI"˘        @var.map { |arglist| var.snippet_text(var, var, var) }.join("STRING")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) }
      end;Fi[	@—ißI"î    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end;Fi[	@#iI"ß    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?
    curl(*external_curl_args);Fi[@.I"var = "STRING";FI")var.extend(StringInreplaceExtension);FI"-var.change_make_var!("STRING", "STRING");FI" assert_equal("STRING", var);Fi
[
[	@H1iI"require("testing_env")
require("extend/string")
class InreplaceTest < Test::Unit::TestCase
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  ;Fi[	@H1iI"“    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  ;Fi[	@H1iI"“    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  ;Fi[	@H1iI"“    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  ;Fi[	@H1i$I"“    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  ;Fi[@@Ò@##@p6I"@var = var;Fi
[
[	@ûieI"      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s)
      end;Fi[	@iI"‘    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = []
      @var = Hash.new { |arglist| var[var] = Set.new };Fi[	@x	i#I"ƒ    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var.fetch(:via, :sftp);Fi[	@x	i$I"…    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var.fetch(:via, :sftp)
      @var = var.delete(:logger);Fi[	@i)I"Ÿ        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        ;Fi[@.@ã@åI"end;FI"end;Fi
[
[	@#i{I"|          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@ï0iI"Â  module Util
    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end
Haml::Template.options[:ugly] = Rails.env.development?.!
Haml::Template.options[:escape_html] = true;Fi[	@&i£I"ñ        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@:i¿I"ñ        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@ziI"›      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|
  (var.nil? or (Paperclip::Attachment.===(var) and var.present?.!));Fi[@¬@√@ƒI"protected;FI" ;Fi
[
[	@‡i'I"≈        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          var = @var.instance_methods.map(&:to_s);Fi[	@„i5I"≥        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          if @var.present? then;Fi[	@Êi&I"π        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          @var.send(@var).assign(nil);Fi[	@Èi9I"™        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist)
          class << var;Fi[	I"4data//state_machine_proj/state_machine/event.rb;TiÕI"	      var = branches.map do |arglist|
        (var.state_requirements.map { |arglist| "STRING" } * "STRING")
      end
      "STRING"
    end
    
    protected
    
    # Add the various instance methods that can transition the object using
    # the current event;Fi[@¿4@¡4I"	else;F@√4I"end;Fi
[
[	@ÅiI")  attr_reader :function
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    out(@var) if (@var > 0)
  end;Fi[	@ÅiI"*  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[	@ÅiI"  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end;Fi[	@i∑I"a  	# @see SetFillColor(), SetTextColor(), Line(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    out(@var) if (@var > 0)
  end;Fi[	@iÀI"l  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[@X3@†6@°6@¢6I"end;Fi
[
[	@H1i	I"require("extend/string")
class InreplaceTest < Test::Unit::TestCase
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist);Fi[	@H1iI"   end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist);Fi[	@H1iI"   end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist);Fi[	@H1iI"   end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist);Fi[	@H1i%I"   end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist);Fi[@
I"&def self.required_fields(arglist);FI"[];FI"end;FI" ;Fi
[
[	@`iI"P        before_validation(:downcase_keys)
        before_validation(:strip_whitespace)
      end
      
      def self.required_fields(arglist)
        []
      end
      
      # Check if the current object is valid for authentication. This method and
      # find_for_authentication are the methods used in a Warden::Strategy to check;Fi[	I"4data//devise_proj/devise/models/omniauthable.rb;Ti
I"Í  module Models
    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        Devise::Models.config(self, :omniauth_providers);Fi[	@hi	I"˝  module Models
    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        # A convenience method that receives both parameters and session to;Fi[	@ûi
I"   module Models
    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      # Checks whether the user session has expired based on configured time.
      def function(arglist);Fi[	@ói	I"I  module Models
    module Validatable
      VALIDATIONS = [:validates_presence_of, :validates_uniqueness_of, :validates_format_of, :validates_confirmation_of, :validates_length_of].freeze
      
      def self.required_fields(arglist)
        []
      end
      
      def self.included(arglist)
        var.extend(ClassMethods);Fi[@
I"6source_root(File.expand_path("STRING", "STRING"));FI" ;FI"desc("STRING");FI" ;Fi
[
[	@i,I"”    
    class SharedViewsGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      ;Fi[	@i;I"–    
    class FormForGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
    end;Fi[	@iEI"÷    
    class SimpleFormForGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
    end;Fi[	@iOI"À    
    class ErbGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      ;Fi[	@i]I"œ    
    class MarkerbGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      ;Fi[@@@@ I" ;Fi
[
[	@(i7I"«          when :nullify then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private
      ;Fi[	@âiÜI"#          begin
            sessions.delete(var).close
          rescue IOError
            # do nothing
          end
        end
      end
      
      # Determines the set of servers within the current task's scope and
      # establishes connections to them, and then yields that list of;Fi[	@ihI"∏      when "STRING", "STRING" then
        problem("STRING".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|;Fi[	@i∞I"Ï      when /macports\/trunk/ then
        problem("STRING")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then;Fi[	@™iªI"ª      when "STRING" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("STRING") { |arglist| var.read(1024) });Fi[@.@ã@å@çI"module ClassMethods;Fi
[
[	@ói)I"ˇ        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length)
      end;Fi[	@&iyI"„      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.
        #;Fi[	@7iI"Ù      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@/i(I"      # @return [ true ] If the object is unconvertable.
      #
      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@Ci)I"Ê      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #;Fi[@(@)I"
super;FI"end;FI" ;Fi
[
[	@Ri!I"Á          var.flatten.each do |arglist|
            raise_on_type_mismatch(var)
            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested;Fi[	@	iI"'        if (var = var.first).is_a?(Hash) then
          if var = subclass_from_attrs(var) then
            return var.new(*var, &var)
          end
        end
        super
      end
      
      # True if this isn't a concrete subclass needing a STI type condition.
      def function(arglist);Fi[	@¡iI"           if respond_to?(var) and (respond_to?("STRING") and self.send(var).nil?) then
            write_attribute(var.to_s, var)
          end
        end
      end
      super
    end
    
    def function(arglist)
      if should_record_timestamps? then;Fi[	@¡i(I"7          var = var.to_s
          next if attribute_changed?(var)
          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist)
      self.record_timestamps and (partial_writes?.! or (changed? or attributes.keys.&(self.class.serialized_attributes.keys).present?));Fi[	@‡/iÕI"             if var and var[:autosave].!=(false) then
              autosave(var.merge!(:autosave => (true)))
            end
          end
        end
        super
      end
      
      private
      ;Fi[I"# @author Nicola Asuni;FI"# @since 1.5.2;FI"#;FI"def function(arglist);FI"return @var;Fi
[
[	@iûI"£  #
  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@i™I"®  #
  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@i∂I"™  #
  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@i¬I"≠  #
  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@iŒI"√  #
  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[I"# @since 1.5.2;FI"#;FI"def function(arglist);FI"return @var;FI"end;Fi
[
[	@iüI"–  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale);Fi[	@i´I"”  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth);Fi[	@i∑I"◊  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight);Fi[	@i√I"‹  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin);Fi[	@iœI"Ú  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor);Fi[@3@3@3@3I"8raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi
[
[	I"#data//homebrew_proj/cmd/cat.rb;Ti I"Œmodule Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    cd(HOMEBREW_REPOSITORY)
    exec("STRING", ARGV.formulae.first.path, *ARGV.options_only);Fi [	@∑,iI"∑require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("STRING") then
      var = [];Fi[	@OiI"require("formula_installer")
require("hardware")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    raise("STRING") if ARGV.include?("STRING")
    unless ARGV.force? then;Fi[	I"$data//homebrew_proj/cmd/test.rb;TiI"Ôrequire("extend/ENV")
require("hardware")
require("keg")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    ENV.extend(HomebrewEnvExtension)
    ENV.setup_build_environment;Fi[	@¬,iI"–require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    var = Formula.select do |arglist|
      ARGV.formulae.all? do |arglist|;Fi[@(@@∑
I"@var.each(&var);FI"end;Fi
[
[	@b&iI"¶      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist);Fi[	@0*i#I"˛      # Duplicates this instance and adds +step_invocations+ to the end
      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist);Fi[	@#iRI"Í          map do |arglist|
            var.value ? (escape_cell(var.value.to_s).unpack("STRING").length) : (0)
          end.max
        end
        
        def function(arglist)
          @var.each(&var)
        end
      end
      ;Fi[	@—i©I"Ä  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist);Fi[	@#iI"ê  
  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist);Fi[@
@I"	to_s;FI"end;FI" ;Fi
[
[	@ì	iI"°      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var);Fi[	@?iI"‹      end
      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    
    def self.color_to_s(arglist)
      var.is_a?(Sass::Script::String) ? (var.value.dup) : (var.inspect.dup);Fi[	@?i9I"§        class_eval("STRING")
      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var);Fi[	I"Qdata//compass_proj/compass/sass_extensions/monkey_patches/browser_support.rb;Ti%I"í    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "STRING";Fi[	I"1data//mongoid_proj/lib/mongoid/extensions.rb;TiI"≥end
class Moped::BSON::ObjectId
  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist)
    ActiveSupport::XmlMini.to_tag(var[:root], self.to_s, var);Fi[@(@@∑
I"+source_tags.map { |arglist| var.name };FI"end;Fi
[
[	@¥igI"ø      # backgrounds don't have tags.
      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
    end
  end;Fi[	@i=I"Ω      
      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@ö	iGI"ı      
      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@ i'I"ƒ      
      def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@ iQI"Ÿ        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist);Fi[@õ3I"end;FI" ;F@)6I"__raise("STRING");Fi
[
[	@≤iI"˜      def function(arglist)
        var = format_args(*var.expected_args)
        var = var.empty? ? ("STRING") : (format_args(*var))
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      ;Fi[	@≤iI"û      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      ;Fi[	@≤i#I"û      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      ;Fi[	@≤i'I"û      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      ;Fi[	@≤i+I"û      end
      
      def function(arglist)
        __raise("STRING")
      end
      
      def function(arglist)
        __raise("STRING")
      end
      ;Fi[@(@@∑
I"[];FI"end;Fi
[
[	@Òi	I"ñ  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist);Fi[	@MiI"º      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist);Fi[	@Hi@I"u  
  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist);Fi[	@HiDI"|  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end
  
  def self.excluding_blocks(arglist);Fi[	@YiI"ú      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist);Fi[I"B@var = "STRING" unless (var.to_s.empty? or (var == "STRING"));FI"#@var = (HOMEBREW_CACHE + @var);FI"end;FI" ;FI"attr_reader :function;Fi
[
[	@iI"Ÿ  def function(arglist)
    super
    @@git ||= "STRING"
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@i[I"˜class CVSDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@iÜI"˝class MercurialDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@iÆI"˙class BazaarDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@iÃI"˙class FossilDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[@
I")def self.matching_ancestors(arglist);FI"["STRING"];FI"end;FI" ;Fi
[
[	@‰iI"      require("state_machine/integrations/active_record/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist)
        require("active_record/version");Fi[	@#iI"N      require("state_machine/integrations/data_mapper/versions")
      
      @var = { :action => :save, :use_transactions => (false) }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist)
        require("dm-core/version") unless ::DataMapper.const_defined?("STRING");Fi[	@ÁiI"◊      require("state_machine/integrations/mongo_mapper/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      protected
      ;Fi[	@ÍiI"ˇ      require("state_machine/integrations/mongoid/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist)
        require("mongoid/version");Fi[	@ #iI"-      require("state_machine/integrations/sequel/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      # Forces the change in state to be recognized regardless of whether the
      # state value actually changed;Fi[@
@I"@var ||= {};FI"end;FI" ;Fi
[
[	@⁄iI"Ÿ        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("STRING" + "STRING");Fi[	@=iHI"ñ      end
      
      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {};Fi[	@=iLI"”      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] };Fi[	@|
iìI">          load_translations(var)
          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        # Looks up a translation from the translations hash. Returns nil if
        # eiher key is nil, or locale, scope or key do not exist as a key in the;Fi[	@≤iI"≠        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("STRING");Fi[@
@I"[];FI"end;FI" ;Fi
[
[	@Òi
I"à    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0;Fi[	@MiI"¬        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var);Fi[	@HiAI"y  def function(arglist)
    "STRING"
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    [];Fi[	@HiEI"©  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end
  
  def self.excluding_blocks(arglist)
    var = var.blocks.map { |arglist| var.person_id };Fi[	@YiI"∫      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?;Fi[@
I"J# Defines an initialization hook into the owner class for setting the;FI"J# initial state of the machine *before* any attributes are set on the;FI"# object;FI"def function(arglist);Fi
[
[	@‰i'I"F          var.default
        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_static_state_initializer
        define_dynamic_state_initializer;Fi[	@#iQI"m      def function(arglist)
        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (426 + 1))
      end;Fi[	@Ái%I"b      def function(arglist)
        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (325 + 1))
      end;Fi[	@Íi)I"d      def function(arglist)
        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (386 + 1))
      end;Fi[	@ #iEI"h      def function(arglist)
        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (344 + 1))
      end;Fi[@(I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi
[
[	@iI"«            else
              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist)
          send("STRING")
          @var;Fi[	@g6i7I"…          rescue SystemCallError => var
            log("STRING")
          end
        end
        @var = []
      end
      
      def function(arglist)
        FileUtils.cp(path(var), var)
      end;Fi[	@`iPI"Á        for var in @var do
          (log("STRING")
          directory.files.new(:key => (var)).destroy)
        end
        @var = []
      end
      
      def function(arglist)
        if @var[:fog_host] then
          "STRING";Fi[	@ÏiﬂI"¬          rescue AWS::Errors::Base => var
            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist)
        begin
          (log("STRING");Fi[	@õiI"«            @var = File.open(var, "STRING")
          else
            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end;Fi[@
@@·1I"end;FI" ;Fi
[
[	@Èi¶I"Ÿ          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var];Fi[	@x	iÄI"≥      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!;Fi[	@πi2I"ª      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var;Fi[	@∏iÖI"Ω          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var];Fi[	@ iqI"      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call);Fi[@'@M.@N.@O.I" ;Fi
[
[	@†iÁI"ı      var = self.site.posts.index(self)
      if var and (var < (self.site.posts.length - 1)) then
        self.site.posts[(var + 1)]
      else
        nil
      end
    end
    
    def function(arglist)
      var = self.site.posts.index(self);Fi[	I"5data//paperclip_proj/paperclip/interpolations.rb;TiéI"        ("STRING" % var).scan(/\d{3}/).join("STRING")
      when String then
        var.scan(/.{3}/).first(3).join("STRING")
      else
        nil
      end
    end
    
    # Returns the pluralized form of the attachment name. e.g.
    # "avatars" for an attachment of :avatar;Fi[	@§i.I"ï        var = new(*var)
        var.to_s = var
        var
      else
        nil
      end
    end
    
    def self.attach(arglist)
      find(var);Fi[	@ô
iI"           else
            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist)
        determine_best_match(var, var);Fi[	@·iI"N            var.jump(:ident).source.to_sym
          when :string_literal then
            var.jump(:tstring_content).source
          else
            nil
          end
        end
        
        # Extracts the values from the node as either strings or symbols.
        # If the node isn't an array, it'll be converted to an array.;Fi[@(@@¯7@˘7I"# object;Fi
[
[	@‰i&I"ó        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default
        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_static_state_initializer;Fi[	@#iPI"ú      # Pluralizes the name using the built-in inflector
      def function(arglist)
        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (426 + 1));Fi[	@Ái$I"°      # Gets the Mongoid key for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (325 + 1));Fi[	@Íi(I"ù      # Gets the field for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (386 + 1));Fi[	@ #iDI"É      # Loads the built-in inflector
      def function(arglist)
        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (344 + 1));Fi[I"	end);FI"end;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@(iQI"*          if target.persisted? and (owner.persisted? and target.save.!) then
            set_owner_attributes(target)
            raise(RecordNotSaved, ("STRING" + "STRING"))
          end)
        end
      end
      
      def function(arglist)
        var[reflection.foreign_key] = nil
      end;Fi[	@·i9I"      var.any? do |arglist|
        (var or specs_changed?(var) do |arglist|
          var.class.===(var.class) and (var.uri == var.uri)
        end)
      end
    end
    
    def function(arglist)
      @var.any? do |arglist|
        next unless var.instance_of?(Source::Path);Fi[	@ıiíI"≥        var.reject! { |arglist| var.version.prerelease? } unless (var or var)
        var.sort_by do |arglist|
          [var.version, (var.platform.to_s == "STRING") ? ("STRING") : (var.platform.to_s)]
        end)
      end
    end
    
    def function(arglist)
      specs_by_name(var.name).select do |arglist|
        same_version?(var.version, var.version) and (Gem::Platform.new(var.platform) == Gem::Platform.new(var.platform));Fi[	@ i"I"¬          end
        else
          var = []
        end)
      end
    end
    
    def function(arglist)
      if var.to_s.include?("STRING") then
        var.to_s.gsub(/ \(.*?\)$/, "STRING");Fi[	@i@I"g            if @var.any?(&:repeat_x?) then
              calculate_repeat_extra_width!
              tile_images_that_repeat
            end)
          end
        end
        
        def function(arglist)
          @var.map { |arglist| var if var.repeat_x? }.compact.each do |arglist|
            var = (var.left - ((var.left / var.width).ceil * var.width));Fi[I"module ClassMethods;FI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;FI"$# @example Mongoize the object.;Fi
[
[	@,iI"module Mongoid
  module Extensions
    module Boolean
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Boolean.mongoize("123.11")
        #;Fi[	@7i I"ˆ        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11")
        #;Fi[	@:ißI"        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ])
        #;Fi[	@/i,I"˚        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #;Fi[	@FiI"module Mongoid
  module Extensions
    module Regexp
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Regexp.mongoize(/^[abc]/)
        #;Fi[@†6@°6@¢6I"end;FI" ;Fi
[
[	@H1i
I"ˇclass InreplaceTest < Test::Unit::TestCase
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING";Fi[	@H1iI"◊  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING";Fi[	@H1iI"◊  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING";Fi[	@H1iI"◊  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING";Fi[	@H1i&I"◊  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING";Fi[@'I"[];FI"end;FI"end;FI" ;Fi
[
[	@iKI"    def function(arglist)
      if self[:without] then
        self[:without].split("STRING").map { |arglist| var.to_sym }
      else
        []
      end
    end
    
    # @local_config["BUNDLE_PATH"] should be prioritized over ENV["BUNDLE_PATH"]
    def function(arglist);Fi[	@ä	i#I"          Dir.glob(File.join(templates_directory, "STRING")).map do |arglist|
            File.basename(var)
          end
        else
          []
        end
      end
      
      def function(arglist)
        File.join(templates_directory, var.to_s, "STRING");Fi[	I"Cdata//diaspora_proj/helpers/interim_stream_hackiness_helper.rb;Ti#I"Á  def function(arglist)
    if defined? @var and (params[:controller] == "STRING") then
      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist)
    defined? @var ? (@var.publisher.open?) : (false);Fi[	@Ì)iºI"“            [:val, var[0], Integer(var[0])]
          end
        end
      else
        []
      end
    end
    
    def function(arglist)
      var = /"([^"\\]|\\["\/\\bfnrt]|\\u[0-9a-fA-F]{4})*"/.match(var);Fi[	@S,iõI"@    def function(arglist)
      if options[:fields] then
        options[:fields].keys.reject { |arglist| (var == "STRING") }
      else
        []
      end
    end
    
    # When freezing a criteria we need to initialize the context first
    # otherwise the setting of the context on attempted iteration will raise a;Fi[@q"@r"@î(@J'I"@var = var if var;Fi
[
[	@wiˇI"¿      
      def function(arglist)
        set_expected_received_count(:at_most, var)
        self
      end
      
      def function(arglist)
        @var = var if var
        self
      end;Fi[	@wiI"±      
      def function(arglist)
        @var = var if var
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = :any
        self;Fi[	@wiI"•      
      def function(arglist)
        @var = 0
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 1
        self;Fi[	@wiI"∏      def function(arglist)
        @var = var if var
        @var = 1
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 2
        self;Fi[	@wiI"       def function(arglist)
        @var = var if var
        @var = 2
        self
      end
      
      def function(arglist)
        @var = var if var
        @var.register(self)
        @var = true;Fi[@¬@ÈI"var;FI"end;FI"end;Fi
[
[	@®iêI".    def function(arglist)
      var.map! do |arglist|
        if var.is_a?(Symbol) and self.column_names.include?(var.to_s) then
          "STRING"
        else
          var
        end
      end
      if has_include?(var.first) then
        construct_relation_for_association_calculations.pluck(*var);Fi[	@∏iI"¨          when "STRING" then
            "STRING"
          when /^\d+/ then
            "STRING"
          else
            var
          end
        end
      end
    end;Fi[	@÷ iMI"—        when "STRING" then
          "STRING"
        when "STRING" then
          "STRING"
        else
          var
        end
      end
      Sass::Script::String.new(var.join("STRING"), var.type)
    end;Fi[	@[
i'I"„    def function(arglist)
      if var[:timestamp] and timestamp_possible? then
        var = var.match(/\?.+=/) ? ("STRING") : ("STRING")
        "STRING"
      else
        var
      end
    end
    
    def function(arglist);Fi[	@i©I"‚            var.gsub(/^(\S)/, "STRING")
            if var then
              var = var
              "STRING"
            else
              var
            end
          end
          var = 0
          @var.each do |arglist|;Fi[@.@bI"reconnect_ssl;FI"end;FI" ;Fi
[
[	@Mi˝I"õ  
  ##
  # Sets this client's OpenSSL::X509::Certificate
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :cert= :certificate=
  ;Fi[	@MiI"‘  # For Net::HTTP parity
  ##
  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Overrides the default SSL certificate store used for verifying;Fi[	@MiI"Î  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Finishes all connections on the given +thread+ that were created before;Fi[	@Mi‚I"è  
  ##
  # Sets this client's SSL private key
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :key= :private_key=
  ;Fi[	@Mi‚I")  # Setting this to VERIFY_NONE is a VERY BAD IDEA and should NEVER be used.
  # Securely transfer the correct certificate and update the default
  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # SSL verification callback.;Fi[@(@I"G# Creates a scope for finding records *with* a particular state or;FI"# states for the attribute;FI"def function(arglist);Fi
[
[	@‰iFI"é      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["STRING", var] })
      end;Fi[	@#ipI"c      # Uses internal save hooks if using the :save action
      def function(arglist)
        (action == :save) ? (:save_self) : (super)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) }
      end;Fi[	@Ái?I"∫      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "STRING" => (var) }) }) };Fi[	@ÍiCI"ß      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "STRING" => (var) }) } })
      end;Fi[	@ #ipI"¨      # Uses the DB literal to match the default against the specified state
      def function(arglist)
        (owner_class.db.literal(var.value) == owner_class_attribute_default)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) })
      end;Fi[@(@I"J# Creates a scope for finding records *without* a particular state or;FI"# states for the attribute;FI"def function(arglist);Fi
[
[	@‰iLI"`      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["STRING", var] })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["STRING", var] })
      end;Fi[	@#ivI"]      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) }
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute.to_sym.not => (var)) }
      end;Fi[	@ÁiGI"í        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "STRING" => (var) }) }) }
        end)
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "STRING" => (var) }) }) };Fi[	@ÍiII"í      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "STRING" => (var) }) } })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "STRING" => (var) }) } })
      end;Fi[	@ #ivI"ç      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.exclude(attribute_column => (var)) })
      end;Fi[@@I"#   end;FI"#;FI"#   person = Person.new;Fi
[
[	@ÂiáI"|    # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
    # which will all return +true+. It also define the attribute methods if they have
    # not been generated.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.respond_to(:name)    # => true
    #   person.respond_to(:name=)   # => true;Fi[	@ÂiõI"(    end
    
    # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.has_attribute?(:name)    # => true
    #   person.has_attribute?('age')    # => true;Fi[	@Âi®I"    end
    
    # Returns an array of names for the attributes available on this object.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.attribute_names
    #   # => ["id", "created_at", "updated_at", "name", "age"];Fi[	@ÂiÌI"¥    
    # Returns the column object for the named attribute. Returns +nil+ if the
    # named attribute not exists.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter
    #   # => #<ActiveRecord::ConnectionAdapters::SQLite3Column:0x007ff4ab083980 @name="name", @sql_type="varchar(255)", @null=true, ...>;Fi[	@ÂiI"5    
    # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
    # (Alias for the protected <tt>write_attribute</tt> method).
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person[:age] = '22'
    #   person[:age] # => 22;Fi[@(@)@@‹I"# do nothing;Fi
[
[	@ûi·I"ﬁ          if has_inverse? and inverse_of.nil? then
            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Ái+I"˜        def function(arglist)
          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@fiÉI"“          print_elements(var, :passed, "STRING")
        else
          @var.puts(format_string("STRING", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@çiyI"ß            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@ûiI"·            @var.puts(@var.description.gsub(/ \(druby.*\)/, "STRING"))
            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[@±'@≤'I"	true;FI"end;FI" ;Fi
[
[	@&ixI"·      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.;Fi[	@7iI"Ï      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly;Fi[	@:i}I"      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the
      # hash which must correspond to method on a criteria object. The hash;Fi[	@/iI"‘      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Is the object not to be converted to bson on criteria creation?
      #;Fi[	@Ci(I"‰      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.;Fi[@°6@¢6I"end;FI" ;FI"def function(arglist);Fi
[
[	@H1iI"˝  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@H1iI"˝  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@H1iI"˝  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@H1i I"˝  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[	@H1i'I"˝  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension);Fi[@/@0@nI"def function(arglist);FI"
begin;Fi
[
[	@Âi"I"¸    
    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) }
      var
    end
    
    def function(arglist)
      begin
        (var = send(var, var)
        var.duplicable? ? (var.clone) : (var));Fi[	@&iÄI"˛        end
        var = {}
        var.each { |arglist| var[var.uri] = var.map { |arglist| var.to_a } }
        var
      end
      
      def function(arglist)
        begin
          Gem::Package.new(var).spec
        rescue Gem::Package::FormatError;Fi[	@)i°I"K        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm_rf(var) if File.exists?(var) }
      end
      var
    end
    
    def function(arglist)
      begin
        ENV["STRING"] = Bundler.rubygems.bin_path("STRING", "STRING", VERSION)
      rescue Gem::GemNotFoundException;Fi[	I"0data//diaspora_proj/models/o_embed_cache.rb;TiI"*    var = OEmbedCache.find_or_initialize_by_url(var)
    return var if var.persisted?
    var.fetch_and_save_oembed_data!
    var
  end
  
  def function(arglist)
    begin
      var = OEmbed::Providers.get(self.url, :maxwidth => 420, :maxheight => 420, :frame => 1, :iframe => 1)
    rescue => var;Fi[	@i:I"≥          var["STRING"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin
        require("psych")
      rescue LoadError;Fi[@(I"def function(arglist);FI"# do nothing;FI"end;FI"def function(arglist);Fi
[
[	@ i.I"∫      end
      def function(arglist)
        super(var)
      end
      def function(arglist)
        # do nothing
      end
      def function(arglist)
        puts("STRING")
      end;Fi[	@’i0I"Ï        end
        def function(arglist)
          (action == :save) ? (:create_or_update) : (super)
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          false
        end;Fi[	@’i9I"‘        end
        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          var.to_s.humanize.downcase
        end;Fi[	@€i!I"3      version("STRING") do |arglist|
        def self.active?(arglist)
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == 2) and (::Sequel::MINOR <= 11)))
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing
        end;Fi[	@€i$I"Á        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          (action == :save) ? (:save) : (super)
        end;Fi[@'I"raise(Error, "STRING");FI"end;FI"end;FI" ;Fi
[
[	@Ì)i%I"Ó        objparse(var)
      when "STRING" then
        arrparse(var)
      else
        raise(Error, "STRING")
      end
    end
    
    # Parses a "value" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.;Fi[	@Ì)i6I"¯        arrparse(var)
      when :val, :str then
        [var, var[(1..-1)]]
      else
        raise(Error, "STRING")
      end
    end
    
    # Parses an "object" in the sense of RFC 4627.
    # Returns the parsed value and any trailing tokens.;Fi[	@Ì)i?I"6        ((var.ord - "STRING".ord) + 10)
      when (("STRING" <= var) and (var <= "STRING")) then
        ((var.ord - "STRING".ord) + 10)
      else
        raise(Error, "STRING")
      end
    end
    
    # Encodes x into a json text. It may contain only
    # Array, Hash, String, Numeric, true, false, nil.;Fi[	@Ì)iSI"ß        objenc(var)
      when Array then
        arrenc(var)
      else
        raise(Error, "STRING")
      end
    end
    
    def function(arglist)
      case var;Fi[	@Ì)iyI"≠      case var
      when String then
        strenc(var)
      else
        raise(Error, "STRING")
      end
    end
    
    def function(arglist)
      var = StringIO.new;Fi[@(@)@@‹I"var = 0;Fi
[
[	@)iuI"        @var.script do |arglist|
          @var.text!("STRING") unless @var
          @var.text!("STRING") unless @var
        end
      end
      
      def function(arglist)
        var = 0
        var = var.instance_variable_get("STRING")
        var.each do |arglist|;Fi[	@ˆiãI"    end
    if unconfirmed_email_changed? then
      self.confirm_email_token = unconfirmed_email ? (SecureRandom.hex(15)) : (nil)
    end
  end
  
  def function(arglist)
    var = 0
    var.each do |arglist|
      self.aspects.find(var).update_attributes(:order_id => (var));Fi[	@si;I"¶      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length;Fi[	@vi+I"®      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length;Fi[	@yi*I"¶      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length;Fi[@(@)@@‹I"var = [];Fi
[
[	@)i I"¯            var[(var..var)].join("STRING")
          else
            "STRING"
          end
        end
        
        def function(arglist)
          var = []
          var.split("STRING").each_with_index do |arglist|
            var = "STRING";Fi[	@iLI"µ          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = []
    var = []
    var = "STRING";Fi[	@¥i=I"˜  def function(arglist)
    join("STRING").find do |arglist|
      break var if (var.basename == Pathname.new(var))
    end
  end
  
  def function(arglist)
    var = []
    var = ["STRING", "STRING", "STRING"]
    var.map! { |arglist| join(var) };Fi[	@˘ikI"C        def function(arglist)
          if (new_record? or custom_field_values_changed?) then
            custom_field_values.each(&:validate_value)
          end
        end
        
        def function(arglist)
          var = []
          custom_field_values.each do |arglist|
            if var.value.is_a?(Array) then;Fi[	@≥i2I"¯            var[(var..var)].join("STRING")
          else
            "STRING"
          end
        end
        
        def function(arglist)
          var = []
          var.split("STRING").each_with_index do |arglist|
            var = "STRING";Fi[@(@)@*@€I"module HelperMethods;Fi
[
[	@*iI"H      def function(arglist)
        if include?(var, var) then
          var.errors.add(var, :exclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates that the value of the specified attribute is not in a
      # particular enumerable object.;Fi[	@7i3I"ã          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var[:multiline].!=(true))) then
            raise(ArgumentError, "STRING")
          end
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is of the correct
      # form, going by the regular expression provided.You can require that the;Fi[	@*iI"U      def function(arglist)
        unless include?(var, var) then
          var.errors.add(var, :inclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is available in a
      # particular enumerable object.;Fi[	@75i2I"J      def function(arglist)
        unless (options.has_key?(:content_type) or options.has_key?(:not)) then
          raise(ArgumentError, "STRING")
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the content type of the file
      # assigned. The possible options are:;Fi[	@∞iI"           if var.send(:read_attribute_for_validation, "STRING").blank? then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the presence of a file.
      # Options:;Fi[I"#     end;FI"#   end;FI"#;FI"#   person = Person.new;FI"#   person.name = 'Bob';Fi
[
[	@◊i/I"˘      #
      #     def clear_attribute(attr)
      #       send("#{attr}=", nil)
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.clear_name;Fi[	@◊iSI"      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.name_short?   # => true;Fi[	@◊ièI"      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob"
      #   person.nickname        # => "Bob";Fi[	@◊i”I"      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob"
      #   person.name_short? # => true;Fi[	@◊iˆI"„      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true
      #;Fi[I"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;FI"&# @return [Array<Twitter::Tweet>];FI";# @param options [Hash] A customizable set of options.;Fi
[
[	I"0data//twitter_proj/twitter/api/timelines.rb;TiI"Ø      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@s9iZI"≠      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@s9ioI"ø      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@s9iÅI"ø      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@s9iñI"Õ      # Returns the 20 most recent tweets of the authenticated user that have been retweeted by others
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets_of_me
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[@I"# == Examples;FI"#;FI"#   class Vehicle;F@W2i
[
[	@ÕiI"i    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@Õi;I"i    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@´iI"E    # object's current value doesn't match the state, then this will return
    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@´i&I"[    # Determines the current state of the given object as configured by this
    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@´iAI"8    # Determines the current state of the given object as configured by this
    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[I"# @since 2.4.0;FI"def function(arglist);FI"@var ||= {};FI"end;FI" ;Fi
[
[	@‚i4I"∆    #
    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the pulls that need to happen.
    #;Fi[	@‚i@I"À    #
    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the unique adds that need to happen.
    #;Fi[	@‚iLI"    #
    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the atomic updates that need to happen for the current
    # +Document+. This includes all changes that need to happen in the;Fi[	@ i4I"«    #
    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the changes for the document.
    #;Fi[	@ imI"    #
    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Remove a change from the dirty attributes hash. Used by the single field
    # atomic updators.;Fi[@û0@ü0@†0@°0I"#assert(var.text_executable?.!);Fi
[
[	@§0iGI"7    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var));Fi[	@§0iUI"-    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var));Fi[	@§0icI"4    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var));Fi[	@§0iqI"%    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert((var.arch == :dunno));Fi[	@§0i∞I"$    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs)
    assert((var.arch == :dunno));Fi[@2)I"	else;FI"
false;TI"end;TI"end;Ti
[
[	@≥i(I"Æ      else
        if (var - var).any? then
          ActiveSupport::Deprecation.warn("STRING")
          true
        else
          false
        end
      end
    end
    ;Ti[	@OiåI"¡    def function(arglist)
      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist);Fi[	@ìi:I"»        protect(var) do |arglist|
          if @var.key?(var) then
            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      ;Fi[	@ˆiMI"∑    end
    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  
  def self.build(arglist);Fi[	@ÅiËI"´  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist);Fi[@o&I"if var then;F@)I"var = "STRING";FI"var = "STRING";Fi
[
[	@siaI"    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else;Fi[	@viVI"    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else;Fi[	@yiPI"    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else;Fi[	@i;I"›    var = (var - (3 * @var))
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else;Fi[	@iÙI"Œ    SetX(var)
    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else;Fi[I";# @param options [Hash] A customizable set of options.;FI"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;FI"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;FI"¥# @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi
[
[	@s9iI"ø      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user
      #   Twitter.mentions;Fi[	@s9iGI"r      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@s9i^I"@      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@s9isI"Ø      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.;Fi[	@s9iÖI"@      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[I"
raise;FI"end;FI"end;FI"end;FI" ;Fi
[
[	@¿
i€I"≈            commit_transaction unless var
          rescue Exception
            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      ;Fi[	@ÅiÓI"â          if var.message.split("STRING").first =~ /Packets out of order/ then
            raise(ActiveRecord::StatementInvalid, "STRING")
          else
            raise
          end
        end
      end
      
      # MysqlAdapter has to free a result after using it, so we use this method to write
      # stuff in an abstract way without concerning ourselves about whether it needs to be;Fi[	@4	iI"Ù          if /database .* already exists/.===(var.message) then
            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist)
        establish_master_connection;Fi[	@ﬁi)I"≠          Bundler.ui.error(var.message)
          Bundler.ui.warn("STRING")
        else
          raise
        end
      end
    end
    
    desc("STRING", "STRING")
    ;Fi[	@§i—I"˝          retry
        else
          Resque.logger.info("STRING")
          raise
        end
      end
    end
    
    # Returns a list of queues to use when searching for a job.
    # A splat ("*") means you want every queue (in alpha order) - this;Fi[@I"# @since 2.4.0;F@é9I"@var ||= {};FI"end;Fi
[
[	@‚i3I"„    #   person.atomic_array_pushes
    #
    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the pulls that need to happen.;Fi[	@‚i?I"Á    #   person.atomic_array_pulls
    #
    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the unique adds that need to happen.;Fi[	@‚iKI"Ú    #   person.atomic_array_add_to_sets
    #
    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the atomic updates that need to happen for the current;Fi[	@ i3I"‚    #   model.changed_attributes
    #
    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the changes for the document.;Fi[	@ ilI"    #   model.previous_changes
    #
    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Remove a change from the dirty attributes hash. Used by the single field;Fi[@I"$# @example Define the relation.;FI"#;FI"#   class Person;FI"$#     include Mongoid::Document;Fi
[
[	@ri$I"è        # necessary to set the references from the child back to the parent
        # document. If a child does not define this relation calling
        # persistence methods on the child object will cause a save to fail.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses
        #   end;Fi[	@riBI"Y        # Adds the relation from a parent document to its children. The name
        # of the relation needs to be a pluralized form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses
        #   end;Fi[	@ri^I"N        # Adds the relation from a parent document to its child. The name
        # of the relation needs to be a singular form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_one :name
        #   end;Fi[	@riéI"1        
        # Adds a relational association from a parent Document to many
        # Documents in another database or collection.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_many :posts
        #   end;Fi[	@ri™I"C        
        # Adds a relational many-to-many association between many of this
        # Document and many of another Document.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_and_belongs_to_many :preferences
        #   end;Fi[I"super(var);F@6I"end;FI" ;FI"private;Fi
[
[	@›iI"µ      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@IimI"ﬁ      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@›iI"‡      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@‡iI"ª      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@„iI"¨      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[@I"0# @return [ Class ] The class being set up.;FI"#;FI"# @since 2.0.0.rc.1;FI"def function(arglist);Fi
[
[	@⁄i∂I"m        #
        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method(var) { |arglist| get_relation(var, var, var) }
          self;Fi[	@⁄iŸI"q        #
        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("STRING") do |arglist|
            without_autobuild do |arglist|;Fi[	@Fi.I"K        #   Person.builder("name")
        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("STRING") do |arglist|
            var, var = parse_args(*var);Fi[	@FiGI"K        #   Person.creator("name")
        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("STRING") do |arglist|
            var, var = parse_args(*var);Fi[	@ziI"6        #   Movie.polymorph(metadata)
        #
        # @param [ Metadata ] metadata The relation metadata.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          if var.polymorphic? then
            self.polymorphic = true;Fi[I"raise(var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@ˇi%I"          @var.error(var) if @var
          var = translate_exception(var, var)
          var.set_backtrace(var.backtrace)
          raise(var)
        end
      end
      
      def function(arglist)
        ActiveRecord::StatementInvalid.new(var)
      end;Fi[	@#i”I"·          require("diff/lcs")
        rescue LoadError => var
          (var.message << "STRING")
          raise(var)
        end
      end
      
      def function(arglist)
        @var = @var = @var = @var = nil
      end;Fi[	@ci5I"        var)
      rescue Gherkin::Lexer::LexingError, Gherkin::Parser::ParseError => var
        var.message.insert(0, "STRING")
        raise(var)
      end
    end
    
    def function(arglist)
      @var ||= if @var =~ /^http/ then
        require("open-uri");Fi[	@Ñi3I"Ó        begin
          var = RubyPython.import(var)
        rescue RubyPython::PythonError => var
          raise(var)
        end
      end
      
      def function(arglist)
        var = File.expand_path(var)
        @var.unshift(var);Fi[	@ûilI"€        begin
          return @var = var.__send__(present_tense_predicate, *@var, &@var)
        rescue NameError
          raise(var)
        end
      end
      
      def function(arglist)
        "STRING"
      end;Fi[@ı!@ˆ!@—/I"protected;FI" ;Fi
[
[	@7iI"†      end
      
      def function(arglist)
        super
      end
      
      protected
      
      def function(arglist)
        add_project_configuration;Fi[	@|
iàI"æ        def function(arglist)
          @var = nil
          @var = nil
          super
        end
        
        protected
        
        def function(arglist)
          var = var.to_s;Fi[	@‰iI"Ê      
      def self.extended(arglist)
        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist);Fi[	@ÍiI"‡      
      def self.extended(arglist)
        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist);Fi[	@ #i0I"˘      # Pluralizes the name using the built-in inflector
      def function(arglist)
        load_inflector
        super
      end
      
      protected
      
      # Initializes class-level extensions for this machine
      def function(arglist);Fi[@I"-# @return [ Hash ] The object mongoized.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi
[
[	@:iØI"A        #   Hash.mongoize([ 1, 2, 3 ])
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return if var.nil?
          evolve(var).update_values { |arglist| var.mongoize };Fi[	@CiI"ﬂ      #
      # @example Mongoize the object.
      #   range.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Range.mongoize(self)
      end;Fi[	@CiCI"=        #   Range.mongoize(1..3)
        #
        # @param [ Range ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : ({ "STRING" => (var.first), "STRING" => (var.last) })
        end;Fi[	@IiI"€      #
      # @example Mongoize the object.
      #   set.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self)
      end;Fi[	@Ii+I"˘        #   Set.mongoize(1..3)
        #
        # @param [ Set ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.to_a
        end;Fi[@(@0I"var = var;FI"var = 0;FI"if (var == 1) then;Fi
[
[	@si⁄I".        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@vi‚I".        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@yi…I".        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@Åi∫I"
        else
          self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@i€I"        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[I"var.print("STRING");FI"when "STRING" then;FI"var.print("STRING");FI"when "STRING" then;FI"var.print("STRING");Fi
[
[	@Ì)iÜI"      while (var < var.length) do
        case var[var]
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@Ì)iàI"        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@Ì)iäI"        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@Ì)iåI"        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING");Fi[	@Ì)iéI"
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        else
          (var = var[var];Fi[I"-var = Category.create(:name => "STRING");FI"-var = Category.create(:name => "STRING");FI"-var = Category.create(:name => "STRING");FI"var.move_to_child_of(var);FI"var.move_to_child_of(var);Fi
[
[	I"Rdata//redmine_proj/plugins/awesome_nested_set/spec/awesome_nested_set_spec.rb;Ti?I"[    (categories(:child_2_1).right.should == 9)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING");Fi[	@Å:iJI"\    (Category.roots.last.to_text.should == var)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING");Fi[	@Å:iUI"K    (Category.roots.last.to_text.should == var)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var.name = nil
    var.save!(:validate => (false));Fi[	I"Rdata//redmine_proj/plugins/awesome_nested_set/test/awesome_nested_set_test.rb;TiãI"ã  
  #rebuild swaps the position of the 2 children when added using move_to_child twice onto same parent
  def function(arglist)
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING");Fi[	@à:iòI"r  
  # doing move_to_child twice onto same parent from the furthest right first
  def function(arglist)
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING");Fi[I"[];FI"end;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@	i∫I"5        var = connection.select_all(var, "STRING", var.bind_values.dup)
        var.instantiate(var))
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = (eager_load_values + includes_values).uniq
      ActiveRecord::Associations::JoinDependency.new(@var, var, []);Fi[	@ä	i$I"ƒ            File.basename(var)
          end
        else
          []
        end
      end
      
      def function(arglist)
        File.join(templates_directory, var.to_s, "STRING")
      end;Fi[	@{8i$I"’    if defined? @var and (params[:controller] == "STRING") then
      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist)
    defined? @var ? (@var.publisher.open?) : (false)
  end;Fi[	@Ì)iΩI"Ã          end
        end
      else
        []
      end
    end
    
    def function(arglist)
      var = /"([^"\\]|\\["\/\\bfnrt]|\\u[0-9a-fA-F]{4})*"/.match(var)
      raise(Error, "STRING") if var.!;Fi[	@áiI"?        var = connection.select_all(var, "STRING", var.bind_values)
        var.map { |arglist| var["STRING"].to_i })
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = except(:includes, :eager_load, :preload, :select).select("STRING")
      apply_join_dependency(var, var);Fi[@/@0@n@9I""STRING";Fi
[
[	@ÅitI"Œ        var = select_one("STRING", "STRING")["STRING"]
        var = "STRING"
        add_column_options!(var, var)
        var
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@Ái¡I"x    rescue => var
      var = @var["STRING"]
    end
    var
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@]i/I"      var = add_code_tags(Pygments.highlight(var, :lexer => (@var), :options => (@var)), @var)
      var = (var["STRING"] + var) if var["STRING"]
      var = (var + var["STRING"]) if var["STRING"]
      var
    end
    
    def function(arglist)
      "STRING"
    end
    ;Fi[	@:ihI"È        if (var.is_a?(Document) or (var.is_a?(XML::Attr) or var.is_a?(XML::Node).!)) then
          raise(ArgumentError, "STRING")
        end
        var
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@©iI"›        var = (var + "STRING")
        var = (var + "STRING") unless @var.empty?
        var = (var + "STRING") unless @var.empty?
        var
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[@(@@ @!@‹3i
[
[	@/	iLI"“        var.concat(["STRING", "STRING"])
        var.concat(["STRING", "STRING"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist);Fi[	@4	i@I"µ      def function(arglist)
        set_psql_env
        Kernel.system("STRING")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist);Fi[	@À-i)I"—      def function(arglist)
        var = configuration["STRING"]
        `sqlite3 #{var}STRING#{var}STRING`
      end
      
      private
      
      attr_reader :function
      
      attr_reader :function;Fi[	@x	iRI"¶    
    def function(arglist)
      to.responds_to?(:read) ? ("STRING") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist);Fi[	@Ci·I"    def function(arglist)
      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "STRING"
    end
    
    private
    
    attr_reader :function
    
    # Adds a predicate method to the owner class so long as a name has;Fi[@
I"protected;FI" ;F@I"
begin;Fi
[
[	@ˇiI"      def function(arglist)
        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin
          @var.instrument("STRING", :sql => (var), :name => (var), :connection_id => (object_id), :binds => (var)) do |arglist|
            yield;Fi[	@	i∞I"÷        false
      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find(var);Fi[	@iI"©        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift
        var = Compass::Commands[$command];Fi[	@≠i¨I"«    end
    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin
      if var.symlink? and var.directory? then
        var = (var.parent + var.readlink).cleanpath;Fi[	@wiéI"‚        (var << var) unless var.nil?
        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin
          @var.call(*var)
        rescue => var;Fi[@÷!I"%["STRING", var[0, 1], var[0, 1]];FI"when "STRING" then;FI"%["STRING", var[0, 1], var[0, 1]];FI"when "STRING" then;Fi
[
[	@Ì)iÉI""    # it is the lexeme.
    def function(arglist)
      case var[0]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then;Fi[	@Ì)iÖI"2      case var[0]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then;Fi[	@Ì)iáI"I        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then;Fi[	@Ì)iâI"I        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then;Fi[	@Ì)iãI"5        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        nulltok(var)
      when "STRING" then;Fi[@÷!I"var.print("STRING");F@j:@k:@l:i
[
[	@Ì)iÖI".      var = var.class.method_defined?(:encoding)
      while (var < var.length) do
        case var[var]
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@Ì)iáI"        case var[var]
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@Ì)iâI"          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@Ì)iãI"          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then;Fi[	@Ì)içI"          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        when "STRING" then
          var.print("STRING")
        else;Fi[I"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;F@A%i
[
[	@siºI"&      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@vi∑I"      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@yi´I"&      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@ÅiôI"%      var = var[var]
      if (var == "STRING"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@iΩI""      var = var[var]
      if (var == "STRING"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[@/@0@n@9I"var = {};Fi
[
[	@ÅifI"         var = "STRING"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end
      
      def function(arglist)
        var = {}
        if var = columns(var).find { |arglist| (var.name == var.to_s) } then
          var[:default] = var.default;Fi[	@diII"      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {}
      if @var.kind_of?(Hash) then
        @var.each do |arglist|;Fi[	@˘iøI"ı          while var.last.inherited_data do
            (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {}
          ATTRIBUTES.each do |arglist|
            var = [];Fi[	@√i”I"•          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var)
      var.scan(/\s+/);Fi[	@˝iI"      var = Formula.factory(var.basename.to_s) rescue nil
      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {}
    var.each do |arglist|
      var = var.recursive_deps.uniq.reject do |arglist|;Fi[I"rescue LoadError;FI"STDERR.puts("STRING");FI"STDERR.puts("STRING");FI"(raise(FatalException.new("STRING"));FI"end;Fi
[
[	@WiI"*          end
          @var = {}
          @var["STRING"]["STRING"].each { |arglist| @var[var.to_sym] = true })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin;Fi[	@Wi'I"˛      when "STRING" then
        begin
          require("kramdown")
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin;Fi[	@Wi0I"/        begin
          (require("rdiscount")
          @var = @var["STRING"]["STRING"].map { |arglist| var.to_sym })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin;Fi[	@WiFI"W            MaRuKu::Globals[:html_png_dir] = @var["STRING"]["STRING"]
            MaRuKu::Globals[:html_png_url] = @var["STRING"]["STRING"]
          end)
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      else
        (STDERR.puts("STRING");Fi[	@ZiI"ﬁ        (return if @var
        require("redcloth")
        @var = true)
      rescue LoadError
        STDERR.puts("STRING")
        STDERR.puts("STRING")
        raise(FatalException.new("STRING"))
      end
    end
    ;Fi[@(@@∑
I"broadcast(var, var);FI"end;Fi	[	[	@Ui(I"”      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # +feature_element+ is either Scenario or ScenarioOutline;Fi[	@UiAI"Œ      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@UieI"Œ      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@UiuI"      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.;Fi[I"var = 1;F@s&@}0I"var = (var < 128);FI""if (var.chr == "STRING") then;Fi	[	[	@sirI"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@si∂I"%    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1);Fi[	@yiaI"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@yi•I"%    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1);Fi[@I"# @return [ true ] true.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@&iuI"ƒ      #
      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@&iüI"◊        #
        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end;Fi[	@:iI"æ      #
      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@:iºI"“        #
        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end;Fi[I"var.move_to_child_of(var);F@~:I"&var = Category.roots.last.to_text;FI""Category.update_all("STRING");FI"Category.rebuild!;Fi	[	[	@Å:iBI"V    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end;Fi[	@Å:iMI"V    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end;Fi[	@à:iéI"Y    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var)
  end;Fi[	@à:iõI"Y    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var)
  end;Fi[@I"$# @return [ true ] Always true.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@iI"      #   context.eager_load(docs)
      #
      # @param [ Array<Document> ] docs The docs returning from the db.
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        load_inclusions(var)
        self.eager_loaded = true;Fi[	@7iI"…      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@/iI"…      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@’iI",        #
        # @example Execute the upsert.
        #   operation.persist
        #
        # @return [ true ] Always true.
        #
        # @since 3.0.0
        def function(arglist)
          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert]);Fi[@÷!I"var = var;FI"while (var < var) do;FI"(var << var);FI"var = Time.at(var).to_a;Fi	[	[	@ïiûI"#          if var then
            var = nil
            case var
            when "STRING" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[4] += var
                if (var[4] > 12) then;Fi[	@ïi™I":                end
                var = Time.local(*var).to_i
              end
            when "STRING" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[5] += var
                var = Time.local(*var).to_i;Fi[	@òieI"#          if var then
            var = nil
            case var
            when "STRING" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[4] += var
                if (var[4] > 12) then;Fi[	@òiqI":                end
                var = Time.local(*var).to_i
              end
            when "STRING" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[5] += var
                var = Time.local(*var).to_i;Fi[@„:I"end;FI"var = -1;FI"var = var;FI"var = 0;Fi	[	[	@ÅitI"              out(sprintf("STRING", (@var * @var)))
            end
            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1);Fi[	@ÅiπI"0          self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
        else
          self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@iwI"¸            out(sprintf("STRING", (@var * @var)))
          end
          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1);Fi[	@i⁄I"(          Cell(var, var, var[var, (var - 1)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[@I"C# @return [ nil, false ] False if no attributes were provided.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@ iÂI"/      #   context.update(name: "Smiths")
      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, [first])
      end;Fi[	@ iÛI"4      #   context.update_all(name: "Smiths")
      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, entries)
      end;Fi[	@  iGI"7      #   context.update({ "$set" => { name: "Smiths" }})
      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var)
      end;Fi[	@  iUI"E      #   context.update({ "$set" => { name: "Smiths" }})
      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, :update_all)
      end;Fi[@÷!I"var["STRING"] = "STRING";FI"when "STRING" then;FI"var["STRING"] = "STRING";FI"when "STRING" then;Fi	[	[	I"?data//redmine_proj/plugins/rfpdf/lib/core/image_science.rb;TiI"      var[0] = var.width
      var[1] = var.height
      case var[2]
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then;Fi[	@Ñ;iI"      case var[2]
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then;Fi[	@Ñ;iI"        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      else;Fi[	@åi-I"C            case @var
            when "STRING" then
              var["STRING"] = var["STRING"]
            when "STRING" then
              var["STRING"] = "STRING"
            when "STRING" then
              var["STRING"] = "STRING"
            when "STRING" then
              var["STRING"] = "STRING"
            else;Fi[I"if (var == "STRING") then;FI"var = "STRING";FI"	else;FI"5if ((var == "STRING") or (var == "STRING")) then;FI"var = "STRING";Fi	[	[	@Åi^I"    var = (var - (var * var))
    var = var
    out(sprintf("STRING", var, var, var, var, var, var))
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING";Fi[	@ÅipI"Ã  end
  
  def function(arglist)
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING";Fi[	@ilI"    var = (var - (var * var))
    var = var
    out(sprintf("STRING", var, var, var, var, var, var))
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING";Fi[	@iÜI"  	# @see SetLineWidth(), SetDrawColor(), SetFillColor()
  	#
  def function(arglist)
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING";Fi[@I")# @return [ Criteria ] The criteria.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@S,iåI"s    # @option options [ String, Symbol ] :collection The collection name.
    # @option options [ String, Symbol ] :database The database name.
    # @option options [ String, Symbol ] :session The session name.
    #
    # @return [ Criteria ] The criteria.
    #
    # @since 3.0.0
    def function(arglist)
      Threaded.set_persistence_options(klass, var)
      self;Fi[	@iI"D      #
      # @example Apply the default scope.
      #   criteria.apply_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        klass.without_default_scope { |arglist| merge!(klass.default_scoping.call) }
        self.scoping_options = true, false;Fi[	@iI"/      #
      # @example Get the criteria with the default scope.
      #   criteria.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then;Fi[	@âiúI"˝      #
      # @example Get a criteria with the default scope.
      #   Model.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        queryable.with_default_scope
      end;Fi[@(@)@@a)I"A# Transfers the archived file to the specified remote server;Fi	[	[	@Èi5I"%        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@°i5I"      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin;Fi[	@˜i)I"5      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@˙i'I"6      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[@I"1# @return [ Array<Object> ] The dumped data.;FI"#;FI"# @since 3.0.15;FI"def function(arglist);Fi	[	[	@.iI"a      #
      # @example Dump the criteria.
      #   Marshal.dump(criteria)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        var = [klass, driver, inclusions, documents, strategy, negating]
        var.push(scoping_options).push(dump_hash(:selector)).push(dump_hash(:options));Fi[	I"<data//mongoid_proj/lib/mongoid/relations/marshalable.rb;TiI"Ê      #
      # @example Dump the proxy.
      #   Marshal.dump(proxy)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        [base, target, metadata]
      end;Fi[	@Éi/I"˛        #
        # @example Dump the proxy.
        #   Marshal.dump(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          [_added, _loaded, _unloaded]
        end;Fi[	@Éi;I"¯        #
        # @example Load the proxy.
        #   Marshal.load(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          @var, @var, @var = var
        end;Fi[@I"# @since 2.1.0;FI"def function(arglist);FI""Threaded.executing?("STRING");FI"end;Fi	[	[	@èi'I"¯      #   proxy._assigning?
      #
      # @return [ true, false ] If the thread is assigning.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Execute a block in binding mode.;Fi[	@èiFI"Ù      #   proxy.binding?
      #
      # @return [ true, false ] If the thread is binding.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Execute a block in building mode.;Fi[	@èieI"˝      #   proxy._building?
      #
      # @return [ true, false ] If the thread is building.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Is the current thread in creating mode?;Fi[	@èiqI"ı      #   proxy.creating?
      #
      # @return [ true, false ] If the thread is creating.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Execute a block in loading mode.;Fi[I"# Returns true;FI"def function(arglist);FI"	true;FI"end;FI" ;Fi	[	[	@§isI"€        "STRING"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.
      def function(arglist);Fi[	@§iåI"ü        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var.!=(false);Fi[	@§i¢I"£        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@§ißI"ï        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true;Fi[@I"%# @return [ Object ] The object.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@)iI"∆      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        to_s
      end;Fi[	@)i(I"/        #   Object.demongoize(object)
        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var.numeric? ? (::BigDecimal.new(var.to_s)) : (var) if var
        end;Fi[	@=iÄI"∆      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@=iÛI"¯        #   Object.demongoize(object)
        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var
        end;Fi[@I"/# @return [ String ] The object mongoized.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@,iI"ˆ        #
        # @example Mongoize the object.
        #   Boolean.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          evolve(var)
        end;Fi[	@7i(I"3        #   Float.mongoize("123.11")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0)
        end;Fi[	@/i2I"#        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_i rescue 0)
        end;Fi[	@Li∫I"        #   String.mongoize("123.11")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end;Fi[I"var.puts("STRING");FI"var.puts(var);FI"end;FI"end;FI"end;Fi	[	[	@–iI"ª        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@”i$I"ª        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@÷iI"”        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
    
    def self.suffix(arglist);Fi[	@‹iI"ª        end.to_yaml
        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[I"undef_method(:namespace);FI" ;FI")undef_method(:namespace_definitions);FI" ;FI"2undef_method(:line) if method_defined?(:line);Fi	[	[	@€iI"Ÿ      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	I",data//nokogiri_proj/nokogiri/xml/dtd.rb;TiI"Ÿ      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@·iI"˜module Nokogiri
  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@miI"‹      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist);Fi[@I"# @return [ Object ] self.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@=iI"       #
      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@=iI"Ã      #
      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@=i&I"…      #
      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@=i>I"–      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[@z:@{:@}:@~:@9;i	[	[	@Å:i@I"B  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!;Fi[	@Å:iKI"B  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!;Fi[	@à:iåI"û  #rebuild swaps the position of the 2 children when added using move_to_child twice onto same parent
  def function(arglist)
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!;Fi[	@à:iôI"Ö  # doing move_to_child twice onto same parent from the furthest right first
  def function(arglist)
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!;Fi[@(@)@@‹I"out("STRING");Fi	[	[	@si6I"œ          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]));Fi[	@vi?I"œ          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]));Fi[	@yi%I"œ          out("STRING")
        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]));Fi[	@ÅiøI"  def function(arglist)
    @var.each_value do |arglist|
      out((((("STRING" + var["STRING"].to_s) + "STRING") + var["STRING"].to_s) + "STRING"))
    end
  end
  
  def function(arglist)
    out("STRING")
    out("STRING")
    @var.each_value do |arglist|;Fi[@(@)@@‹I"var = @var["STRING"];Fi	[	[	@si©I"‹      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@vi§I"ﬁ      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@yiòI"‹      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Åi2I"‚      @var = @var if (var == 1)
    else
      @var = (@var + var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[I"Avar = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);FI"var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@i≈I"˚      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@i I"˚      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@iœI"˚      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@i‘I"⁄      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var;Fi[I"rescue;FI"# do nothing;FI"end;FI"end;FI" ;Fi	[	[	@ÅiI"≤      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin;Fi[	@ÅiI"∏        begin
          (execute("STRING")
          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@ÅiI"≥      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@ÅiI"æ      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("STRING");Fi[@I"<# @return [ Array<Object> ] The new value of the field.;FI"#;FI"# @since 2.0.0;FI"def function(arglist);Fi	[	[	I"9data//mongoid_proj/lib/mongoid/persistence/atomic.rb;Ti"I"{      # @param [ Symbol ] field The name of the field.
      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        AddToSet.new(self, var, var, var).persist
      end;Fi[	@n<iKI"d      # @param [ Symbol ] field The name of the field.
      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Inc.new(self, var, var, var).persist
      end;Fi[	@n<iI"j      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        PullAll.new(self, var, var, var).persist
      end;Fi[	@n<iêI"_      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Push.new(self, var, var, var).persist
      end;Fi[@@h<@i<I"# @since 2.1.0;FI"def function(arglist);Fi	[	[	@n<i_I"n      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pop.new(self, var, var, var).persist
      end;Fi[	@n<irI"_      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pull.new(self, var, var, var).persist
      end;Fi[	@n<i°I"j      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        PushAll.new(self, var, var, var).persist
      end;Fi[	@n<i√I"_      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Sets.new(self, var, var, var).persist
      end;Fi[@@Ò(@≤'I"counts["STRING"];FI"end;Fi	[	[	@i1I"ˇ      #   map_reduce.emitted
      #
      # @return [ Integer ] The number of emitted documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Provide a finalize js function for the map/reduce.;Fi[	@i]I"Î      #   map_reduce.input
      #
      # @return [ Integer ] The number of input documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Sets the map/reduce to use jsMode.;Fi[	@iãI"¸      #   map_reduce.output
      #
      # @return [ Integer ] The number of output documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Get the raw output from the map/reduce operation.;Fi[	@iÆI"      #   map_reduce.reduced
      #
      # @return [ Integer ] The number of reduced documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Adds a javascript object to the global scope of the map/reduce.;Fi[I"#     relation.push(doc);FI"#   end;FI"#;FI"8# @return [ Object ] The return value of the block.;FI"#;Fi	[	[	@èi1I"Ó      #
      # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@èiPI"Ò      #
      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@èi{I"Ô      #
      # @example Execute in loading mode.
      #   _loading do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.3.2
      def function(arglist);Fi[	@èi©I"        #
        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist);Fi[@Y%I"@var = "STRING";FI"@var = "STRING";FI"end;FI" ;Fi	[	[	@…iI"À      def function(arglist)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      private
      ;Fi[	@ÃiI"À      def function(arglist)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      private
      ;Fi[	@œiI"        load_defaults!
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      ##
      # Yields to the block the compressor command and filename extension.;Fi[	@“iI"        @var ||= false
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      ##
      # Yields to the block the compressor command and filename extension.;Fi[@I"(# @example Instantiate the strategy;FI")#   Strategy.new(document, metadata);FI"#;FI"A# @param [ Document ] document The document to cascade from.;Fi	[	[	@IiI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@PiI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@WiI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@ZiI"n        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[@@Ø<I"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;FI"-# @return [ Strategy ] The new strategy.;Fi	[	[	@IiI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@PiI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@WiI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@ZiI"j        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[@@º<I"def function(arglist);FI"@var, @var = var, var;FI"@var = var.send(var.name);Fi	[	[	@IiI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@PiI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@WiI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@ZiI"@        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[@:I"end;FI"end;FI"end;FI"end;Fi	[	[	I"=data//mongoid_proj/lib/mongoid/extensions/false_class.rb;Ti I"Ë      # @since 1.0.0
      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::FalseClass.__send__(:include, Mongoid::Extensions::FalseClass);Fi[	I"<data//mongoid_proj/lib/mongoid/extensions/true_class.rb;Ti I"Ê      # @since 1.0.0
      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::TrueClass.__send__(:include, Mongoid::Extensions::TrueClass);Fi[	I"0data//twitter_proj/twitter/api/arguments.rb;TiI"ä      
      def function(arglist)
        @var = var.last.is_a?(::Hash) ? (var.pop) : ({})
        super(var)
      end
    end
  end
end;Fi[	I"7data//twitter_proj/twitter/response/raise_error.rb;TiI"i      
      def function(arglist)
        @var = var
        super(var)
      end
    end
  end
end;Fi[@Y%I"'@var = path.sub(/^\~\//, "STRING");FI"end;FI" ;FI"private;Fi	[	[	@Èi I"         @var ||= 21
        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##;Fi[	@°i"I"         @var ||= 22
        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##;Fi[	@˜iI"À        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##;Fi[	@˙iI"À        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##;Fi[I"0;FI"end;FI" ;F@¬%I"0;Fi	[	[	@ÒiI"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@ÒiI"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@ÒiI"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@Òi4I"o    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[@Ÿ%@⁄%I"var = 0;FI"var = (var + 1);FI"$var = var if var and (var == 2);Fi	[	[	@ÅiZI"	        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == "STRING"[0]) then;Fi[	@ÅiwI"ﬂ            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1);Fi[	@i\I"Î        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@izI"À          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1);Fi[@z:@}:@~:@9;@:;i	[	[	@Å:iAI"l  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    (Category.roots.last.to_text.should == var);Fi[	@Å:iLI"l  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    (Category.roots.last.to_text.should == var);Fi[	@à:içI"k  def function(arglist)
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var);Fi[	@à:iöI"k  def function(arglist)
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("STRING")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var);Fi[@I"/# @return [ String, Symbol ] The override.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	I"/data//mongoid_proj/lib/mongoid/threaded.rb;TiI"Ë    #
    # @example Get the global database override.
    #   Threaded.database_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["STRING"]
    end;Fi[	@=i*I"    #   Threaded.database_override = :testing
    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["STRING"] = var
    end;Fi[	@=i:I"Ê    #
    # @example Get the global session override.
    #   Threaded.session_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["STRING"]
    end;Fi[	@=iHI"    #   Threaded.session_override = :testing
    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["STRING"] = var
    end;Fi[I"%categories(:child_2).save(false);FI".assert(Category.left_and_rights_valid?.!);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@à:iﬁI"-  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil;Fi[	@à:iÂI"L  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt];Fi[	@à:iÛI"_  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt];Fi[	@à:i˙I")  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    var = Category.create
    var = Category.create;Fi[@)=I"end;FI" ;FI"def function(arglist);FI",assert(Category.left_and_rights_valid?);Fi	[	[	@à:iﬂI":    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false);Fi[	@à:iÊI"]    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false);Fi[	@à:iÌI"v    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false);Fi[	@à:iÙI"l    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false);Fi[@€9@‹9@›9I" ;FI"def function(arglist);Fi	[	[	@ßi+I"Ÿ          var)
        rescue Exception
          send((var + "STRING"), var)
          raise
        end
      end
      
      def function(arglist)
        var = super
        if locking_enabled? and var.!=(1) then;Fi[	@&
i8I"‚      end)
    rescue FormulaUnavailableError => var
      var.dependent = f.name
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? then
      raise(CannotInstallFormulaError, "STRING".undent);Fi[	@&
i¬I"Ô        f.prefix.rmtree if f.prefix.directory?
        f.rack.rmdir_if_possible
      end
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? and (f.linked_keg.realpath == f.prefix) then
      opoo("STRING");Fi[	@≠iüI"±    rescue Exception
      opoo("STRING")
      unlink
      raise
    end
  end
  
  def function(arglist)
    var = ((HOMEBREW_PREFIX / :opt) / fname)
    if var.symlink? then;Fi[I"Logger.message("STRING");FI"end;FI"end;FI"end;FI"end;Fi	[	[	@øi/I"Ã      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database
      def function(arglist)
        Logger.message("STRING")
      end
    end
  end
end;Fi[	@ÀiI"Œ      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive
      def function(arglist)
        Logger.message("STRING")
      end
    end
  end
end;Fi[	@fiNI"”      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process
      def function(arglist)
        Logger.message("STRING")
      end
    end
  end
end;Fi[	@Ïi`I"•        return unless (keep.to_i > 0)
        Logger.message("STRING")
        Cycler.cycle!(self, @var)
        Logger.message("STRING")
      end
    end
  end
end;Fi[I"@var.each do |arglist|;FI"newobj;FI"'out((("STRING" + var) + "STRING"));FI"out("STRING");FI"end;Fi	[	[	@siÒI"√  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@vi˙I"√  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@yi‡I"√  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@i2I"¿  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each do |arglist|
      newobj;Fi[I"puts("STRING");FI"puts("STRING");FI"puts(var);FI"@var = true;FI"end;Fi	[	[	@&
i/I"õ      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  ;Fi[	@&
i?I"î    end
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  ;Fi[	@&
iKI"‡    var = f.bin.children.select { |arglist| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  ;Fi[	@&
iWI"·    var = f.sbin.children.select { |arglist| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  ;Fi[@o&I"var = (var + 1);F@}3I"	next;FI"end;Fi	[	[	@si{I"«        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[	@vipI"Â        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@yijI"«        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[	@i^I"Œ        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var == "STRING"[0]) then
        var = var;Fi[@I"#   class Vehicle;FI"7#     state_machine :state, :initial => :parked do;FI"#       ...;FI"#     end;Fi	[	[	@f2i◊I"»    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   ;Fi[	@f2iÂI"6    # the default behavior of initializing the state machine attributes is used.
    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize;Fi[	@f2iˆI"R    # never get initialized.  In order to ensure that all initialization hooks
    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[	@f2iI"/    # 
    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[@o&I"var = 1;F@s&I"var = var[var];FI"!if (var == "STRING"[0]) then;Fi	[	[	@ÅiMI"∫    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@ÅiìI"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var)
        var = (var + 1);Fi[	@iNI"∫    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@i∑I"Ì    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1);Fi[@o&@ô=@s&@}0I"var = (var < 128);Fi	[	[	@siqI"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@siµI"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var);Fi[	@yi`I"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@yi§I"    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var);Fi[@I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;Fi	[	[	@ÀiI"!        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@ÀiWI"!        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@Ài{I"!        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@f2iåI"    #   class Vehicle
    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     ;Fi[@o=I"puts(var);FI"@var = true;FI"end;FI"end;Fi	[	[	@&
i0I"û      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@&
i@I"§    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@&
iLI"§    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@&
iXI"§    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[@o&@p&@|0@s&I"var = var[var];Fi	[	[	@ÅiLI"¥    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        if (@var > 0) then;Fi[	@ÅiíI"Ì    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var);Fi[	@iMI"¥    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        if (@var > 0) then;Fi[	@i∂I"›    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var);Fi[@I"%# @return [Array<Twitter::User>];FI"def function(arglist);FI"S@var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) };FI"end;Fi	[	[	I"0data//twitter_proj/twitter/action/follow.rb;TiI"¸      end
      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	I";data//twitter_proj/twitter/action/list_member_added.rb;TiI"      end
      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	I"1data//twitter_proj/twitter/action/mention.rb;Ti&I"˝      end
      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	I"1data//twitter_proj/twitter/action/retweet.rb;TiI"˝      end
      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[I"puts(var);FI"@var = true;FI"end;FI"end;FI" ;Fi	[	[	@&
i1I"¨      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?;Fi[	@&
iAI"¨      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?;Fi[	@&
iMI"≠      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?;Fi[	@&
iYI"ò      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars;Fi[I"newobj;FI"out("STRING");FI"$out(("STRING" + var["STRING"]));FI"out("STRING");FI"out("STRING");Fi	[	[	@siUI"…    end
    out((("STRING" + var) + "STRING"))
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@viVI"∆    out((var + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@yi@I"…    end
    out((("STRING" + var) + "STRING"))
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@iùI"∆    out((var + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[I"class Base;FI""include(Backup::CLI::Helpers);FI" ;FI",include(Backup::Configuration::Helpers);FI" ;Fi	[	[	@πiI"‰module Backup
  module Compressor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##
      # Yields to the block the compressor command and filename extension.;Fi[	@øiI"’module Backup
  module Database
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##
      # Creates a new instance of the MongoDB database object;Fi[	@ÀiI"¬module Backup
  module Encryptor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      def function(arglist)
        load_defaults!;Fi[	@€iI"Æmodule Backup
  module Syncer
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      attr_accessor(:path)
      ;Fi[I"#   class Person;F@U1I"#;F@W1I",#     attribute_method_suffix '_short?';Fi	[	[	@◊iHI"L      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@◊iÇI"      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@◊iƒI"k      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #
      #     # Call to define_attribute_method must appear after the;Fi[	@◊iÎI".      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #;Fi[I"@var ||= false;FI"(instance_eval(&var) if block_given?;FI"@var = "STRING";FI"@var = "STRING";FI"end;Fi	[	[	@…iI"       # Creates a new instance of Backup::Compressor::Bzip2
      def function(arglist)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      private;Fi[	@ÃiI"ˇ      # Creates a new instance of Backup::Compressor::Gzip
      def function(arglist)
        load_defaults!
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      private;Fi[	@œiI"÷      def function(arglist)
        load_defaults!
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      ##;Fi[	@“iI"—        load_defaults!
        @var ||= false
        @var ||= false
        @var ||= false
        instance_eval(&var) if block_given?
        @var = "STRING"
        @var = "STRING"
      end
      
      ##;Fi[@(@)@@‹I"&@var ||= if locate("STRING") then;Fi	[	[	@,
i]I"ﬁ      else
        (Xcode.version >= "STRING") ? (:llvm) : (:gcc)
      end
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /build (\d{4,})/
      $1.to_i;Fi[	@,
ikI":    @var ||= if locate("STRING") and locate("STRING").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("STRING")}STRING` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /LLVM build (\d{4,})/
      $1.to_i;Fi[	@,
irI"    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /LLVM build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /clang version (\d\.\d)/
      $1;Fi[	@,
iyI"    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /clang version (\d\.\d)/
      $1
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /tags\/Apple\/clang-(\d{2,})/
      $1.to_i;Fi[I"#     private;FI"#;FI"%#     def attribute_short?(attr);FI""#       send(attr).length < 5;FI"#     end;Fi	[	[	@◊iOI"Ì      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@◊iãI"…      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@◊iœI"Ì      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@◊iÚI"Ï      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[I",self.class.to_s.sub("STRING", "STRING");FI"end;FI" ;FI"##;FI";# Logs a message to the console and log file to inform;Fi	[	[	@πiI"@      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor
      def function(arglist);Fi[	@øi(I">      ##
      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database
      def function(arglist);Fi[	@ÀiI"A      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive
      def function(arglist);Fi[	@fiGI"E      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process
      def function(arglist);Fi[@[9@\9@]9I"K#   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;FI".#   vehicle.state           # => "parked";Fi	[	[	@f2i€I"L    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,;Fi[	@f2iˇI"9    #     def initialize(attributes = {})
    #       ...
    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling;Fi[	@f2iI"R    #     def initialize(attributes = {})
    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually;Fi[	@f2i+I"P    #       initialize_state_machines(:static => :force) do
    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid;Fi[@“&@”&I"#   person.pets;TI"#   # => [;T@'i	[	[	@-i'I"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i`I"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i~I"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-ióI"K      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@º<@«<@»<@…<I"end;Fi	[	[	@IiI"Ü        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@PiI"Ü        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@WiI"É        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead;Fi[	@ZiI"Ü        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[@I"#   person.pets;TI"#   # => [;T@'@(i	[	[	@-i(I"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iaI"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iI"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iòI"T      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@@mI"var = case var;FI"when :success then;FI""STRING";Fi	[	[	@›i.I"u      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING";Fi[	@›i,I"u      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING";Fi[	@‡i6I"u      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :failure then
          "STRING";Fi[	@„i*I"u      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING";Fi[@Ø<@∫<I"#;F@º<@«<i	[	[	@IiI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@PiI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@WiI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@ZiI"Ñ        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[@≠<I"#;F@Ø<@∫<I"#;Fi	[	[	@IiI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@PiI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@WiI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@ZiI"f        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[@“&@”&@\>@]>I"#;Fi	[	[	@f2i‹I"á    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,
    # the default behavior of initializing the state machine attributes is used.;Fi[	@f2i I"\    #       ...
    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling
    # <tt>super()</tt> will not only call the superclass's +initialize+, but;Fi[	@f2iI"x    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually
    # in cases where you want to change how static / dynamic initial states get;Fi[	@f2i,I"a    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid
    # initialization issues when +nil+ is a valid state.  Without passing in;Fi[@.I"raise("STRING");FI"end;FI"end;FI"end;Fi	[	[	@=.iI"}        raise("STRING")
      end
      
      def function(arglist)
        raise("STRING")
      end
    end
  end
end;Fi[	@vi}I"]      end
    end
    
    def function(arglist)
      raise("STRING")
    end
  end
end;Fi[	@=i>I"Ç          end
        end
        
        def function(arglist)
          raise("STRING")
        end
      end
    end
  end
end;Fi[	@J.iI"Çmodule Spec
  module Runner
    class HeckleRunner
      def function(arglist)
        raise("STRING")
      end
    end
  end
end;Fi[@.I"@var ||= {};FI"end;FI" ;FI"def function(arglist);Fi	[	[	@⁄iI"Ë          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("STRING" + "STRING")
          (var << "STRING") if var[:message];Fi[	@=iII"ñ      
      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@=iMI"¡        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end;Fi[	@≤iI"§        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("STRING")
      end;Fi[@¨<@≠<I"#;F@Ø<@∫<i	[	[	@IiI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@PiI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@WiI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@ZiI"ñ        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[@(@)@@‹I"var = {};Fi	[	[	@eiKI"       unless var.empty? then
        var = var.map { |arglist| var.message }.join("STRING")
        raise(MultiparameterAssignmentErrors.new(var), "STRING")
      end
    end
    
    def function(arglist)
      var = {}
      var.each do |arglist|
        var = var.split("STRING").first;Fi[	@i&I"      var = @var.keys.|(@var.keys).|(var)
      var.map do |arglist|
        var.sub(/^BUNDLE_/, "STRING").gsub(/__/, "STRING").downcase
      end
    end
    
    def function(arglist)
      var = {}
      all.each { |arglist| var[$'] = self[var] if var =~ /^local\./ }
      var;Fi[	@≤	iRI"ﬁ        (attempted_path or scope_path)
      else
        scope_path
      end
    end
    
    def function(arglist)
      var = {}
      var = :"new_#{scope}STRING"
      var[:format] = request_format unless skip_format?;Fi[	@∑i2I"/          super(var, *var, &var))
        rescue NameError
          __mock_proxy.raise_unexpected_message_error(var, *var)
        end
      end
      
      def function(arglist)
        var = {}
        extract_option(var, var, :null_object)
        extract_option(var, var, :__declared_as, "STRING");Fi[@(@I"# @param klass [Class];FI"%# @param request_method [Symbol];FI"# @param path [String];Fi	[	[	@ƒi$I"2          merge_user!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::User, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@ƒi/I":        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        objects_from_response(var, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Array];Fi[	@ƒi@I"      # @return [Array]
      def function(arglist)
        var.map { |arglist| var.fetch_or_new(var) }
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@ƒiLI"1        var.flatten.threaded_map do |arglist|
          object_from_response(var, var, var, var.options.merge(:id => (var)))
        end
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Object];Fi[@@@>@A>I"#     end;FI"#   end;Fi	[	[	@◊iPI"›      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@◊iåI"ﬂ      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@◊i–I"‹      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@◊iÛI"‹      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[@¬I"end.compact.join("STRING");FI"end;FI" ;FI"##;Fi	[	[	@ZiäI"<      def function(arglist)
        ["STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Builds the MongoDB connectivity options syntax to connect the user
      # to perform the database dumping process;Fi[	@ZiîI"      def function(arglist)
        ["STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Returns the mongodump syntax for enabling ipv6
      def function(arglist);Fi[	@]ihI"-      def function(arglist)
        ["STRING", "STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Builds a MySQL compatible string for the additional options
      # specified by the user;Fi[	@∆ifI"-      def function(arglist)
        ["STRING", "STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Builds a Redis compatible string for the
      # additional options specified by the user;Fi[@I"#     private;FI"#;F@@>@A>i	[	[	@◊iNI"      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@◊iäI"Ï      #     define_attribute_methods :name
      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@◊iŒI"'      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@◊iÒI"      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[I"(attr_accessor(:username, :password);FI" ;FI"attr_accessor(:ip, :port);FI" ;FI"attr_accessor(:path);Fi	[	[	@Èi	I"–module Backup
  module Storage
    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:passive_mode);Fi[	@°iI"◊    class RSync < Base
      include(Backup::CLI::Helpers)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:local);Fi[	@˜i
I"∂module Backup
  module Storage
    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##;Fi[	@˙i
I"∑module Backup
  module Storage
    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##;Fi[@XI"newobj;FI"out("STRING");FI"out("STRING");FI"$out(("STRING" + var["STRING"]));Fi	[	[	@si?I"õ    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((((("STRING" + textstring("STRING")) + "STRING") + textstring(var["STRING"]["STRING"])) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[	@viHI"i    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[	@yi.I"i    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[	@ièI"i    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[I""next if send(var).to_s.empty?;FI""STRING";F@?I"end;FI" ;Fi	[	[	@ZiâI"<      # to perform the database dumping process
      def function(arglist)
        ["STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Builds the MongoDB connectivity options syntax to connect the user;Fi[	@ZiìI"(      # to perform the database dumping process
      def function(arglist)
        ["STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Returns the mongodump syntax for enabling ipv6;Fi[	@]igI"?      # to perform the database dumping process
      def function(arglist)
        ["STRING", "STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Builds a MySQL compatible string for the additional options;Fi[	@∆ieI",      # to perform the database dumping process
      def function(arglist)
        ["STRING", "STRING", "STRING"].map do |arglist|
          next if send(var).to_s.empty?
          "STRING"
        end.compact.join("STRING")
      end
      
      ##
      # Builds a Redis compatible string for the;Fi[@R8I"end;FI"end;FI"end;FI"end;Fi	[	[	@ˆi\I"°          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@˘iÜI"s          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@¸i?I"{          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@
iSI"Ñ          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[@X@.?@/?@˚=I"out("STRING");Fi	[	[	@siTI"¡      end
    end
    out((("STRING" + var) + "STRING"))
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@viUI"º    end
    out((var + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@yi?I"‘      var = (var + "STRING")
    end
    out((("STRING" + var) + "STRING"))
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@iúI"º    end
    out((var + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING");Fi[@
I"MESSAGE = "STRING";FI"end;FI"end;FI"end;Fi	[	[	I"4data//twitter_proj/twitter/error/bad_gateway.rb;Ti
I"è  class Error
    class BadGateway < Twitter::Error::ServerError
      HTTP_STATUS_CODE = 502
      
      MESSAGE = "STRING"
    end
  end
end;Fi[	I"8data//twitter_proj/twitter/error/gateway_timeout.rb;Ti
I"ì  class Error
    class GatewayTimeout < Twitter::Error::ServerError
      HTTP_STATUS_CODE = 504
      
      MESSAGE = "STRING"
    end
  end
end;Fi[	I">data//twitter_proj/twitter/error/internal_server_error.rb;Ti
I"ò  class Error
    class InternalServerError < Twitter::Error::ServerError
      HTTP_STATUS_CODE = 500
      
      MESSAGE = "STRING"
    end
  end
end;Fi[	I"<data//twitter_proj/twitter/error/service_unavailable.rb;Ti
I"ó  class Error
    class ServiceUnavailable < Twitter::Error::ServerError
      HTTP_STATUS_CODE = 503
      
      MESSAGE = "STRING"
    end
  end
end;Fi[@.@√-@…<I"end;FI" ;Fi	[	[	@IiI"é        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@PiI"é        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@WiI"l        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead
        # sets the foreign key values to nil.;Fi[	@ZiI"é        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[@XI"Cout(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]));FI"$out(("STRING" + var["STRING"]));FI"3out((("STRING" + (@var + 1).to_s) + "STRING"));FI"out("STRING");Fi	[	[	@si:I"˚  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj;Fi[	@viCI"˚  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj;Fi[	@yi)I"˚  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj;Fi[	@iäI"  def function(arglist)
    newobj
    out("STRING")
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj;Fi[@X@1?I"out("STRING");FI"out("STRING");FI"out("STRING");Fi	[	[	@siVI"”    out((("STRING" + var) + "STRING"))
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@viWI"æ    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@yiAI"”    out((("STRING" + var) + "STRING"))
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@iûI"æ    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[@
I" @var = { :action => :save };FI" ;FI")def self.matching_ancestors(arglist);FI"["STRING"];Fi	[	[	@‰iI"„      include(ActiveModel)
      
      require("state_machine/integrations/active_record/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      ;Fi[	@ÁiI"‚      include(ActiveModel)
      
      require("state_machine/integrations/mongo_mapper/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      ;Fi[	@ÍiI"›      include(ActiveModel)
      
      require("state_machine/integrations/mongoid/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      ;Fi[	@ #iI"’      include(Base)
      
      require("state_machine/integrations/sequel/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      ;Fi[@
@<I" ;F@<I" ;Fi	[	[	@€iI"„      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING";Fi[	@<iI"Í      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys;Fi[	@·i	I"¯  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING";Fi[	@miI"˙      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist)
        var.create_entity(var, *var);Fi[@(@I"E# Unbinds the base object and the inverse, caused by setting the;FI"# reference to nil.;FI"#;Fi	[	[	@‡i$I"X                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true);Fi[	@ÓiI"e            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true);Fi[	@ıi%I"!                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true);Fi[	@iI"o          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.game.unbind(:continue => true);Fi[@
I"J# Initialize the new cascade strategy, which will set up the relation;FI"# and the metadata.;FI"#;F@¨<i	[	[	@Ii
I">    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@Pi
I"?    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@Wi
I"?    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@Zi
I"@    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[I"/var = (((var - (2 * @var)) * 1000) / @var);FI"'var = var.gsub("STRING", "STRING");FI"var = var.length;FI"var = -1;FI"var = 0;Fi	[	[	@siØI"Ì  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@vi™I"Ì  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@yiûI"Ì  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@ÅiçI"Ì  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[@¬@È@Æ2@Ø2I"var = ("STRING" % var);Fi	[	[	@›i6I"Œ        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end;Fi[	@›i4I"Œ        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end;Fi[	@‡i>I"Œ        when :failure then
          "STRING"
        when :warning then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end;Fi[	@„i2I"Œ        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end;Fi[@¬@ÈI"'raise(ActiveRecordError, "STRING");FI"end;FI"when "STRING" then;Fi	[	[	@ÅiÿI"¯          when nil then
            "STRING"
          when (4096..4294967295) then
            "STRING"
          else
            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then
          case var
          when 1 then;Fi[	@ÅiÁI"˙          when nil, 4, 11 then
            "STRING"
          when (5..8) then
            "STRING"
          else
            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then
          case var
          when (0..255) then;Fi[	@ûi0I"            when 3, 4 then
              "STRING"
            when (5..8) then
              "STRING"
            else
              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then
            return super unless var
            case var;Fi[	@ûi8I"            return super unless var
            case var
            when (0..6) then
              "STRING"
            else
              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then
            return "STRING" unless var
            case var;Fi[@.I"
super;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@Ñi…I"^      
      # Many Rails applications monkey-patch a replacement of the configure_connection method
      # and don't call 'super', so leave this here even though it looks superfluous.
      def function(arglist)
        super
      end
      
      def function(arglist)
        @var.query_with_result = true
        var = exec_query(var, var, var);Fi[	@—iAI"É  end
end
class HeadSoftwareSpec < SoftwareSpec
  def function(arglist)
    super
  end
  
  def function(arglist)
    return
  end;Fi[	I"Ödata//redmine_proj/plugins/open_id_authentication/generators/open_id_authentication_tables/open_id_authentication_tables_generator.rb;TiI"‘class OpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("STRING", "STRING") }
  end;Fi[	I"ïdata//redmine_proj/plugins/open_id_authentication/generators/upgrade_open_id_authentication_tables/upgrade_open_id_authentication_tables_generator.rb;TiI"€class UpgradeOpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("STRING", "STRING") }
  end;Fi[@.@˜?I"@var = nil;FI"end;FI" ;Fi	[	[	I"Gdata//bundler_proj/bundler/vendor/net/http/persistent/ssl_reuse.rb;TiI"|  
  @var = nil
  
  def function(arglist)
    super
    @var = nil
  end
  
  if (RUBY_VERSION > "STRING") then
    ##;Fi[	I",data//compass_proj/compass/test_case.rb;TiI"ô  else
    Test::Unit::TestCase
  end
    def function(arglist)
      super
      @var = nil
    end
    
    def function(arglist)
      var = open(var);Fi[	@ iNI"        attr_reader(:scenario_outline)
        
        # https://rspec.lighthouseapp.com/projects/16211/tickets/342
        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name };Fi[	@ﬁiI"Æ      @var = var[:guard]
    end
    
    def function(arglist)
      super
      @var = nil
    end
    
    # The initial state name for this path
    def function(arglist);Fi[@.@˜?I"B@var = "STRING" unless (var.to_s.empty? or (var == "STRING"));FI"#@var = (HOMEBREW_CACHE + @var);FI"end;Fi	[	[	@iYI"Ê  end
end
class CVSDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function;Fi[	@iÑI"Ï  end
end
class MercurialDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function;Fi[	@i¨I"È  end
end
class BazaarDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function;Fi[	@i I"È  end
end
class FossilDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function;Fi[@–?I"end;FI"var = (var + 1);FI"	next;FI"end;Fi	[	[	@si√I"4        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == "STRING"))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@viæI"        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@yi≤I"4        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == "STRING"))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@Åi†I"¸        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == "STRING"[0]) then
        var = var;Fi[@
@∂?@∑?I"#;FI"$# @example Unbind the document.;Fi	[	[	@‡i%I"-              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true)
          #   name.person = nil;Fi[	@Ói I"d              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true)
          #   person.name = nil;Fi[	@ıi&I"-              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true)
          #   game.person = nil;Fi[	@iI"q          def function(arglist)
            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.game.unbind(:continue => true)
          #   person.game = nil;Fi[@(@I"# For testing only;FI"#:nodoc:;FI"def function(arglist);Fi	[	[	I"3data//cucumber_prok/cucumber/ast/doc_string.rb;Ti)I"¬      
      def function(arglist)
        index(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:doc_string, to_step_definition_arg]
      end;Fi[	@#iÆI"‰      def function(arglist)
        var = "STRING"
        var.match(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:table, *cells_rows.map { |arglist| var.to_sexp }]
      end;Fi[	@#i+I"          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) }
          nil
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:row, line, *@var.map { |arglist| var.to_sexp }]
        end;Fi[	@#imI"‚        
        def function(arglist)
          (SurplusCell.===(var) or (value == var.value))
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:cell, @var]
        end;Fi[@ƒ?I"#;F@¨<@≠<I"#;Fi	[	[	@IiI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@PiI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@WiI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@ZiI"õ        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[@)@)I"	else;FI"if (var == 0) then;FI"@var = var;Fi	[	[	@siòI"    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@viìI"    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@yiáI"    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@iâI"    end
    (var << "STRING") if var.is_a?(String) and var.include?("STRING")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var);Fi[@
I"acts_as_api;FI" ;FI"+api_accessible(:backbone) do |arglist|;FI"var.add(:id);Fi	[	[	I"'data//diaspora_proj/models/like.rb;TiI"Õ  after_destroy { |arglist| self.parent.update_likes_counter }
  
  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author);Fi[	I"0data//diaspora_proj/models/participation.rb;TiI"ü      { :target => (@var) }
    end
  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author);Fi[	@ÁiI"≠  include(Encryptor::Public)
  
  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:name);Fi[	@üiI"º  include(Diaspora::Commentable)
  
  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:created_at);Fi[@80@3I"#;F@:3I"var = case var;Fi	[	[	@›i,I"Å      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING";Fi[	@›i*I"Å      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING";Fi[	@‡i4I"Å      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING";Fi[	@„i(I"Å      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING";Fi[@
I"J# Determines what the response should be for a particular bit of text;FI"H# from the SCM. Password prompts, connection requests, passphrases,;FI"# etc. are handled here.;FI"def function(arglist);Fi	[	[	@ßi@I"Y          end.sort.last + "STRING")
          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          logger.info("STRING")
          case var;Fi[	@ØixI"t        def function(arglist)
          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("STRING");Fi[	@∏i=I"n        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          case var
          when /\(P4PASSWD\) invalid or unset\./i then;Fi[	@ΩiBI"i        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("STRING");Fi[@(@@Ä@@Å@@Ç@i	[	[	@ßi?I"j            var[/^date: (.*?);/, 1]
          end.sort.last + "STRING")
          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          logger.info("STRING");Fi[	@ØiwI"]        
        def function(arglist)
          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host];Fi[	@∏i<I"v        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          case var;Fi[	@ΩiAI"à        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host];Fi[@3I"#;F@:3I"var = case var;F@å>i	[	[	@›i-I"â      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then;Fi[	@›i+I"â      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then;Fi[	@‡i5I"â      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :failure then;Fi[	@„i)I"â      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then;Fi[@√?@ƒ?I"#;F@¨<@≠<i	[	[	@IiI"n      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@PiI"o      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@WiI"o      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@ZiI"p      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[@Ê<I"end;FI" ;FI"private;FI" ;Fi	[	[	@Èi!I"Ï        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@°i#I"ˇ        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored;Fi[	@˜iI"È        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@˙iI"È        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[I"3attr_accessor(:document, :relation, :metadata);FI" ;F@√?@ƒ?I"#;Fi	[	[	@Ii	I"G  module Relations
    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@Pi	I"H  module Relations
    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@Wi	I"H  module Relations
    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@Zi	I"I  module Relations
    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[@.I"var = @var;TI"@var.each do |arglist|;FI"newobj;F@b=i	[	[	@siÔI"£  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end;Fi[	@vi¯I"£  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end;Fi[	@yiﬁI"£  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end;Fi[	@i0I"Ω  	# putfonts
  	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end;Fi[@(@@£+@™;I"def function(arglist);Fi	[	[	@Èi6I"
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	@°i6I"0        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin
          (write_password_file! unless local;Fi[	@˜i*I"9        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	@˙i(I":        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[@(@I"# Returns true;F@”;I"	true;Fi	[	[	@§iqI"õ      #:nodoc:
      def function(arglist)
        "STRING"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@§iäI"è      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@§i†I"º      # Clears the prepared statements cache.
      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@§i•I"ù      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[@>%@?%@@%I"var = 0;FI"var = (var + 1);Fi	[	[	@ÅiYI"        var = (var == 0) ? (0) : ((var - 1))
        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@ÅivI"            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else;Fi[	@i[I"        var = (var == 0) ? (1) : (var)
        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@iyI"Ô          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[@.@/@0@1I"protected;Fi	[	[	@‡i&I"¶          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist);Fi[	@„i4I"°          end
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist);Fi[	@Êi%I"¶          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist);Fi[	@Èi8I"¶          "STRING"
        end
        
        def function(arglist)
          "STRING"
        end
        
        protected
        
        def function(arglist);Fi[@
@!?I" ;F@#?I" ;Fi	[	[	@Èi
I"…  module Storage
    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:passive_mode)
      ;Fi[	@°iI"«      include(Backup::CLI::Helpers)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:local)
      ;Fi[	@˜iI"√  module Storage
    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[	@˙iI"ƒ  module Storage
    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[I"E# are referenced to the actual objects themselves on both sides.;FI"#;FI"G# This case sets the metadata on the inverse object as well as the;FI"# document itself.;FI"#;Fi	[	[	@‡iI"®      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   name.person.bind(:continue => true);Fi[	@ÓiI"®      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.name.bind(:continue => true);Fi[	@ıiI"™      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   game.person.bind(:continue => true);Fi[	@iI"™      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.game.bind(:continue => true);Fi[@(@@ö@õ@◊5i	[	[	@LiGI"“      def function(arglist)
        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Returns true if the record is persisted, i.e. it's not a new record and it was;Fi[	@ç	idI"ÿ      # Enumerates over the manifest files
      def function(arglist)
        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      
      protected;Fi[	@?iùI"    def function(arglist)
      var = @var[:processors]
      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Saves the file, if there are no errors. If there are, it flushes them to;Fi[	@§iI"ª          @var = 0
          @var = 0
          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist);Fi[@(@)I"
false;FI"end;FI" ;Fi	[	[	@Mi9I"‰    @var.each do |arglist|
      if ((var[-var.length, var.length] == var) or (var[-var.length, var.length] == var)) then
        return true
      end
    end
    false
  end
  
  ##
  # Forces reconnection of HTTP connections.;Fi[	@‘#i-I"          var.each do |arglist|
            var = File.join(var, (var + var))
            return true if File.executable?(var)
          end
        end
        false
      end
      
      def self.on_windows?(arglist)
        RUBY_PLATFORM =~ /mswin|mingw/;Fi[	@riMI"Ω          return options.skip_info.call(uid)
        else
          return true
        end
      end
      false
    end
    
    def function(arglist)
      self.env["STRING"] = auth_hash;Fi[	I">data//rescue_proj/resque/vendor/utf8_util/utf8_util_18.rb;Ti>I"i            var.pos -= 1
          end
        end
      end
    end
    false
  end
  
  private
  ;Fi[@
I"# Returns true;F@”;I"	true;FI"end;Fi	[	[	@§irI"€      def function(arglist)
        "STRING"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.;Fi[	@§iãI"§      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@§i°I"£      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@§i¶I"§      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[@¬@√@è@∑I"# :call-seq:;Fi	[	[	@ûi§I"î      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should be_true
    #   should be_false;Fi[	@Ö
iQI"—      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should change(receiver, message, &block)
    #   should change(receiver, message, &block).by(value);Fi[	@¶iVI"Ÿ      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should have(number).named_collection__or__sugar
    #   should_not have(number).named_collection__or__sugar;Fi[	@·iI"ù      end
      
      def function(arglist)
        "STRING"
      end
    end
    
    # :call-seq:
    #   should satisfy {}
    #   should_not satisfy {};Fi[@.@e(@f(I" ;FI"def function(arglist);Fi	[	[	@wiI"    end
    
    class ColumnDefinition < Struct.new(:base, :name, :type, :limit, :precision, :scale, :default, :null)
      def function(arglist)
        var
      end
      
      def function(arglist)
        base.type_to_sql(type.to_sym, limit, precision, scale)
      end;Fi[	@ˇiI"Æ        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var))
      end;Fi[	@Åi"I"Ã        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true)
      end;Fi[	@‚iI"y      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end;Fi[@(@@∑
I"colour(var, "STRING");FI"end;Fi	[	[	@õi}I"ƒ          rescue NoMethodError
            false
          end
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist);Fi[	@õi|I"Ã        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist);Fi[	@õiÄI"Ã        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist);Fi[	@õiÑI"Ã        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist);Fi[I"J# Binds the base object to the inverse of the relation. This is so we;F@AI"#;F@A@Ai	[	[	@‡i
I"ä    module Bindings
      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.;Fi[	@Ói
I"ä    module Bindings
      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.;Fi[	@ıi
I"å    module Bindings
      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.;Fi[	@i
I"å    module Bindings
      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.;Fi[I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;FI"@var = @var;FI"	else;F@X@i	[	[	@sióI"      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@viíI"      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@yiÜI"      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@iàI"      out("STRING")
    end
    (var << "STRING") if var.is_a?(String) and var.include?("STRING")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = var;Fi[@Ÿ$I" ;F@€$I" ;FI"Dmethod_option("STRING", :type => :boolean, :banner => "STRING");Fi	[	[	@ﬁiÑI"k    
    method_option("STRING", :type => :string, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING");Fi[	@ﬁiÜI"Ü    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :string, :lazy_default => "STRING", :banner => "STRING");Fi[	@ﬁiíI"Ä    
    method_option("STRING", :type => :string, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :array, :lazy_default => ([]), :banner => "STRING");Fi[	@ﬁi„I"@    
    method_option("STRING", :type => :array, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    def function(arglist);Fi[I"@var = (var + var);FI"	else;FI"@var = var if (var == 2);FI"end;FI"end;Fi	[	[	@siùI"ñ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@viòI"ñ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@yiåI"ñ    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@ièI"†      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[@(@@∑
@?<I"!var = ((@var - @var) - @var);Fi	[	[	@si™I"·    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING");Fi[	@vi•I"·    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING");Fi[	@yiôI"·    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING");Fi[	@ÅiàI"B    var = (var + "STRING") if var.!=(0) and var.index("STRING").nil?.!
    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING");Fi[I"var["STRING"] = "STRING";F@;@Ä;@Å;I"var["STRING"] = "STRING";Fi	[	[	@Ñ;iI"      var[1] = var.height
      case var[2]
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING";Fi[	@Ñ;iI"!      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING";Fi[	@Ñ;iI"      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      when "STRING" then
        var["STRING"] = "STRING"
      else
        # do nothing;Fi[	@åi.I"H            when "STRING" then
              var["STRING"] = var["STRING"]
            when "STRING" then
              var["STRING"] = "STRING"
            when "STRING" then
              var["STRING"] = "STRING"
            when "STRING" then
              var["STRING"] = "STRING"
            else
              # do nothing;Fi[@ëAI"end;FI"end;FI"end;FI" ;Fi	[	[	@siüI"µ        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then;Fi[	@viöI"µ        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then;Fi[	@yiéI"µ        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then;Fi[	@iëI"ü        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell)
  ;Fi[@
@¬(@√(I"%# @param request_method [Symbol];FI"# @param path [String];Fi	[	[	@¡i˛I"      def function(arglist)
        list_from_response_with_users(:post, "STRING", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[	I"5data//twitter_proj/twitter/api/places_and_geo.rb;TiqI"˝      def function(arglist)
        object_from_response(Twitter::Place, :post, "STRING", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash]
      # @return [Array];Fi[	@+i¸I"          object_from_response(Twitter::OEmbed, :get, "STRING", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>];Fi[	@ƒiI"⁄  module API
    module Utils
      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[@
@¬(@√(@"I"var = @var;Fi	[	[	@siÏI"∆      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@viıI"∆      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@yi€I"∆      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@ÅiI"Ó      open(var, "STRING") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "STRING")) then
      1.upto(var) { |arglist| @var[var].gsub!(@var, var.to_s) };Fi[@
@¬(@√(@"I""STRING";Fi	[	[	@•iOI"o        end
      end
    end
    
    private
    
    def function(arglist)
      "STRING"
    end
  end;Fi[	@ÌiEI"    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "STRING"
    end
  end;Fi[	@7i‹I"∞        raise("STRING") unless Nokogiri.jruby?
        return toJavaDocument
      end
      
      private
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@ji3I"µ      @var.write(nonce_key(var, var), var, :expires_in => (OpenID::Nonce.skew))
      return true
    end
    
    private
    
    def function(arglist)
      "STRING"
    end
    ;Fi[I"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;F@º<@«<@»<i	[	[	@IiI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@PiI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@WiI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@ZiI"d        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[@.@M>I"end;FI" ;FI"##;Fi	[	[	@πiI"+      
      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor;Fi[	@øi'I")      
      ##
      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database;Fi[	@ÀiI",      
      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive;Fi[	@fiFI"0      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("STRING", "STRING")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process;Fi[@.I""STRING" if @var;FI"end;FI" ;FI"##;Fi	[	[	@°isI"      
      ##
      # Returns Rsync syntax for using a password file
      def function(arglist)
        "STRING" if @var
      end
      
      ##
      # Returns Rsync syntax for defining a port to connect to
      def function(arglist);Fi[	@i#I"˚        
        ##
        # Returns Rsync syntax for enabling mirroring
        def function(arglist)
          "STRING" if @var
        end
        
        ##
        # Returns Rsync syntax for invoking "archive" mode
        def function(arglist);Fi[	@iII"        
        ##
        # Returns Rsync syntax for compressing the file transfers
        def function(arglist)
          "STRING" if @var
        end
        
        ##
        # Returns Rsync syntax for defining a port to connect to
        def function(arglist);Fi[	@iUI"3        
        ##
        # Returns Rsync syntax for setting a password (via a file)
        def function(arglist)
          "STRING" if @var
        end
        
        ##
        # Writes the provided password to a temporary file so that
        # the rsync utility can read the password from this file;Fi[@ 4I"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;Fi	[	[	@‡i.I"º        @var ||= []
        @var ||= "STRING"
        @var ||= "STRING"
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@„iI"ø      def function(arglist)
        super(var, var)
        @var ||= false
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@ÒiI"›      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@ÙiI"›      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[@
@¬(@√(@"I"case var;Fi	[	[	@riDI"Ï      def function(arglist)
        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var
        when Hash then
          preload_hash(var);Fi[	@{i'I"€      def function(arglist)
        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var
        when BigDecimal then
          var.to_s;Fi[	@ÏiÔI"æ          false
        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@iI"•        end
        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var
        when /\.jpe?g/i then
          "STRING";Fi[@ûAI"/var = (((var - (2 * @var)) * 1000) / @var);FI"'var = var.gsub("STRING", "STRING");FI"var = var.length;FI"var = -1;Fi	[	[	@siÆI"‰  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@vi©I"‰  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@yiùI"‰  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@ÅiåI"‰  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[@.I"%@var, @var, @var = var, var, var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@#i^I"        
        attr_accessor(:status, :value)
        
        def function(arglist)
          @var, @var, @var = var, var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          var.visit_table_cell_value(value, status);Fi[	@UiI"÷      
      #:nodoc:
      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@åiI"⁄    class FeaturesLoader
      include(Formatter::Duration)
      
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        load unless @var
        @var;Fi[	@£iI"€module Spec
  module Matchers
    class Has
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        var.__send__(predicate(@var), *@var, &@var)
      end;Fi[I"G# destination<String>:: the relative path to the destination root.;FI"C# config<Hash>:: give :verbose => false to not log the status.;FI"#;FI"# ==== Examples;FI"#;Fi	[	[	@W.i
I"    # Creates an empty directory.
    #
    # ==== Parameters
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   empty_directory "doc"
    #;Fi[	I"Hdata//bundler_proj/bundler/vendor/thor/actions/file_manipulation.rb;Ti,I"1    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   link_file "README", "doc/README"
    #;Fi[	@KBiBI">    #
    # ==== Parameters
    # source<String>:: the address of the given content.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   get "http://gist.github.com/103208", "doc/README"
    #;Fi[	@KBibI"0    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   template "README", "doc/README"
    #;Fi[I"var = @var;FI"if (var > 0) then;FI"@var = 0;FI"out("STRING");FI"end;Fi	[	[	@ÅiÒI"–  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("STRING")
      end
      self.AddPage(@var)
      @var = var;Fi[	@i◊I"    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("STRING")
        end
        AddPage(@var)
        @var = var;Fi[	@i(I"K      var = 1 if (var >= 1)
      if ((var + ((var["STRING"] * var) / (@var * @var))) > @var) and (@var.! and AcceptPageBreak) then
        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("STRING")
          end
          AddPage(@var)
          if (var > 0) then;Fi[	@iXI"˛    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("STRING")
        end
        AddPage(@var)
        @var = var;Fi[@RB@À@I"newobj;F@b=I"out("STRING");Fi	[	[	@siI"¿  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|;Fi[	@vi˘I"¿  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|;Fi[	@yiﬂI"¿  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|;Fi[	@i1I"   	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each do |arglist|;Fi[@RBI"var = @var;FI"var = @var;FI"var = @var;FI"var = @var;Fi	[	[	@Åi“I"–    self.Open if (@var == 0)
    var = @var
    var = (@var + (@var ? ("STRING") : ("STRING")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then;Fi[	@Åi”I"≈    var = @var
    var = (@var + (@var ? ("STRING") : ("STRING")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then
      @var = true;Fi[	@i«I"    Open if (@var == 0)
    var = @var
    var = ((@var + (@var ? ("STRING") : ("STRING"))) + (@var ? ("STRING") : ("STRING")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then;Fi[	@i»I"Í    var = @var
    var = ((@var + (@var ? ("STRING") : ("STRING"))) + (@var ? ("STRING") : ("STRING")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then
      @var = true;Fi[@.I"	to_s;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@ì	iI"í      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var)
    end;Fi[	@?i:I"è      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end;Fi[	@à7i&I"Ä      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "STRING"
    end;Fi[	@ã7iI"µclass Moped::BSON::ObjectId
  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist)
    ActiveSupport::XmlMini.to_tag(var[:root], self.to_s, var)
  end;Fi[@.@é7I"end;FI" ;FI"def function(arglist);Fi	[	[	@i?I"√        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end;Fi[	@ö	iII"$        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq
      end;Fi[	@ i)I"Á        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init
        example_rows.each { |arglist| var.skip_invoke! };Fi[	@ iSI"“          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags
        end;Fi[@.I"@var ||= var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@fiI"Ì      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_comment(@var) unless @var.empty?;Fi[	@iI"œ      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var
        @var.init if @var;Fi[	@ö	iI"”      
      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@PiI"©      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end;Fi[@≠"@Æ"@Ø"I"end;FI"end;Fi	[	[	@uiMI"m      
      def function(arglist)
        yield if @var
        @var = true
      end
    end
  end
end;Fi[	@&
iI"∑        unless ORIGINAL_PATHS.include?(var) then
          opoo("STRING")
          puts("STRING")
          @var = true
        end
      end
    end
  end
  
  def function(arglist);Fi[	@OiI"            content_for(:header_tags) do |arglist|
              ((javascript_include_tag("STRING") + javascript_include_tag("STRING")) + stylesheet_link_tag("STRING"))
            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	@∑i§I"ó          failure_hooks.each { |arglist| payload_class.send(var, var, *var) }
        end)
      ensure
        @var = true
      end
    end
  end
end;Fi[@.I"@var.each(&var);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@b&iI"µ        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self
        (@var << var);Fi[	@0*i%I"ÿ        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)];Fi[	@—i´I"ä    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag }
  end;Fi[	@#iI"ã    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end;Fi[@ûA@&BI"end;FI"var = (var + 1);FI"	next;Fi	[	[	@si¬I"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == "STRING"));Fi[	@viΩI"Ò        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then;Fi[	@yi±I"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == "STRING"));Fi[	@ÅiüI"˙        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == "STRING"[0]) then;Fi[@ûA@&B@æB@øBI"	else;Fi	[	[	@si‡I"˝        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@viËI"        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@yiœI"˝        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@Åi¿I"Ì        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1)
      end;Fi[I"DCell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var);FI"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;Fi	[	[	@siªI"@      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@vi∂I".      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@yi™I"@      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@iºI"    while (var < var) do
      var = var[var]
      if (var == "STRING"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[@(@@∑
@J<I"var;Fi	[	[	@i¬I"Î      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@i«I"˚      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@iÃI"˚      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@i—I"˚      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[@
@@\AI"end;FI" ;Fi	[	[	@õi~I"≈            false
          end
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING");Fi[	@õi}I"„        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING");Fi[	@õiÅI"„        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING");Fi[	@õiÖI"Ê        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          Spec.deprecate("STRING");Fi[I"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;Fi	[	[	@si±I"·    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@vi¨I"·    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@yi†I"·    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@ÅièI"·    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[@&I";#   #       #<Pet id: 4, name: "Benny", person_id: 1>,;TI";#   #       #<Pet id: 5, name: "Brain", person_id: 1>,;TI":#   #       #<Pet id: 6, name: "Boss",  person_id: 1>;TI"#   #    ];Ti	[	[	@-iEI"B      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4");Ti[	@-i`I"5      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary;Ti[	@-igI"Z      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')]);Ti[	@-itI"U      #
      #   person.pets
      #   # This is not affected by replace
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      def function(arglist)
        load_target.dup;Ti[@&I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];TI"#;Ti	[	[	@-i¿I"=      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>;Ti[	@-i¯I"E      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=1;Ti[	@-i0I"/      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [;Ti[	@-i6I">      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => [];Ti[I"if (@var > @var) then;FI"@var = @var;FI"@var = (@var + var);FI"!var = ((@var - @var) - @var);FI"/var = (((var - (2 * @var)) * 1000) / @var);Fi	[	[	@siÃI"p      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[	@vi‘I"C      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var)
            var = (var + 1);Fi[	@yiªI"p      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[	@Åi¨I"P      var = (var + GetCharWidth(var, var))
      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[@.I"flag?("STRING");FI"end;FI" ;FI"def function(arglist);Fi	[	[	@iDI"ø    (at((@var + 1)) or raise(UsageError))
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    (flag?("STRING") or (ENV["STRING"] or ENV["STRING"]))
  end;Fi[	@iPI"ñ    (flag?("STRING") or ENV["STRING"])
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end;Fi[	@iTI"É    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end;Fi[	@iXI"ù    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    (include?("STRING") or switch?("STRING"))
  end;Fi[@.I"include?("STRING");FI"end;FI" ;FI"def function(arglist);Fi	[	[	@idI"÷    (include?("STRING") or ENV["STRING"])
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    var = find { |arglist| var =~ /--json=.+/ }
    var.split("STRING").last if var;Fi[	@imI"ô    var.split("STRING").last if var
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    include?("STRING")
  end;Fi[	@iqI"ô    include?("STRING")
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    (build_head? or build_devel?).!
  end;Fi[	@i{I"  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal
  # when a 32-bit version is needed.
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    include?("STRING") and MacOS.bottles_supported?(true)
  end;Fi[I"O# * <tt>:if</tt> - Specifies a method, proc or string to call to determine;FI"M#   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;FI"O#   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;FI"O#   proc or string should return or evaluate to a +true+ or +false+ value.;FI"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi	[	[	@91i)I"      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@91icI"      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@Û0i)I"˛      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@¥iÑI"      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should ot occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[I"=# @param [ Hash ] options The mongo persistence options.;FI"#;F@h<I"#;FI"# @since 2.1.0;Fi	[	[	@n<i^I"l      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pop.new(self, var, var, var).persist;Fi[	@n<iqI"]      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pull.new(self, var, var, var).persist;Fi[	@n<i†I"h      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        PushAll.new(self, var, var, var).persist;Fi[	@n<i¬I"]      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Sets.new(self, var, var, var).persist;Fi[@aC@bC@h<@cCI"# @since 2.0.0;Fi	[	[	@n<i!I"y      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        AddToSet.new(self, var, var, var).persist;Fi[	@n<iJI"b      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Inc.new(self, var, var, var).persist;Fi[	@n<i~I"h      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        PullAll.new(self, var, var, var).persist;Fi[	@n<ièI"]      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Push.new(self, var, var, var).persist;Fi[@
@@?<@ûA@&Bi	[	[	@si´I"Ì      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length;Fi[	@vi¶I"Ì      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length;Fi[	@yiöI"Ì      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length;Fi[	@ÅiâI"    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length;Fi[@s,I"@var.puts("STRING");FI"@var.flush;FI"end;FI" ;Fi	[	[	@§i,I"Ì            @var.puts("STRING")
          end
          @var.puts("STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          @var.puts("STRING");Fi[	@§i2I"“        end
        
        def function(arglist)
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          @var = (@var + 1);Fi[	@§iOI"O          @var.puts("STRING") unless var.exception.nil?
          @var.puts("STRING") unless var.exception.nil?
          @var.puts(var) unless (var == "STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          @var.puts("STRING") unless @var;Fi[	@§i|I"          @var.puts("STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.puts("STRING")
          @var.flush
        end
        
        def function(arglist)
          "STRING";Fi[@.I"6super(compose_message("STRING", :klass => (var)));FI"end;FI"end;FI"end;Fi	[	[	I":data//mongoid_proj/lib/mongoid/errors/invalid_path.rb;TiI"¬      # @param [ Class ] klass The document class.
      #
      # @since 3.0.14
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/errors/no_metadata.rb;TiI"¡      # @param [ Class ] klass The document class.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/errors/no_parent.rb;TiI"—      # @param [ Class ] klass The class of the embedded document.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/errors/versioning_not_on_root.rb;TiI"¡      # @param [ Class ] klass The embedded class.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[I"@var.puts;FI"@var.flush;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@fi|I"        if var then
          @var.puts(format_string((("STRING" + "STRING") + "STRING"), :failed))
        end
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        return unless var[:wip]
        var = step_mother.scenarios(:passed);Fi[	@oiDI"≤      
      def function(arglist)
        @var.puts("STRING")
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2
        @var = 2;Fi[	@oiNI"†      end
      
      def function(arglist)
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2
        @var = 2;Fi[	@oiZI"»      
      def function(arglist)
        @var = nil
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        print_feature_element_name(var, var, var, var)
      end;Fi[@
@@J<I"var;FI"end;Fi	[	[	@i√I"Î        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@i»I"˚        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@iÕI"˚        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@i“I"˚        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[@.@J<I"var;FI"end;FI" ;Fi	[	[	@iƒI"˚        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@i…I"˚        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@iŒI"˚        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@i”I"⁄        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[I"$out(("STRING" + var["STRING"]));FI"out("STRING");FI"out("STRING");FI"out("STRING");FI"out("STRING");Fi	[	[	@siWI"æ    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@viXI"æ    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@yiBI"æ    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[	@iüI"æ    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING");Fi[@.I"%var = Node.new(:COMBINATOR, var);FI"var;FI"end;FI" ;Fi	[	[	@i(I"·      
      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@i-I"√        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@i2I"√        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@i7I"≤        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted
      # reduce 56 omitted;Fi[@<I"#;FI"# @since 3.0.0;F@<I"	self;Fi	[	[	@=iI"…      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@=iI"À      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@=i'I"»      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@=i?I"œ      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[@_,I"	self;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@RiI"ï    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self;Fi[	@Ri!I"Æ    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      label_field(var, var)
      input_field("STRING", var);Fi[	@Ri=I"¿    def function(arglist)
      (@var << "STRING")
      self.instance_eval(&var)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self;Fi[	@RiBI"∞    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      return self if @var
      (@var << "STRING") unless @var;Fi[@ê+I"-# Credentials for the specified database;FI"##;FI"# Connectivity options;FI"##;Fi	[	[	@ZiI"‡      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # IPv6 support (disabled by default)
      ##;Fi[	@]iI""      ##
      # Name of the database that needs to get dumped
      # To dump all databases, set this to `:all` or leave blank.
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	I"4data//backup_proj/backup/database/postgresql.rb;TiI"Á      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	@∆iI"H      
      ##
      # Name of and path to the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Determines whether Backup should invoke the SAVE command through
      # the 'redis-cli' utility to persist the most recent data before;Fi[@.@?<@ûA@&B@'Bi	[	[	@si¨I"⁄    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1;Fi[	@vißI"⁄    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1;Fi[	@yiõI"⁄    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1;Fi[	@ÅiäI"‚    @var = @var
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1;Fi[@
@I"include?("STRING");FI"end;FI" ;Fi	[	[	@icI"   def function(arglist)
    (include?("STRING") or ENV["STRING"])
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    var = find { |arglist| var =~ /--json=.+/ };Fi[	@ilI"√    var = find { |arglist| var =~ /--json=.+/ }
    var.split("STRING").last if var
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    include?("STRING");Fi[	@ipI"´  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    (build_head? or build_devel?).!;Fi[	@ixI"Á  def function(arglist)
    (build_head? or build_devel?).!
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  # Request a 32-bit only build.
  # This is needed for some use-cases though we prefer to build Universal;Fi[@(@@∑
I"include?("STRING");FI"end;Fi	[	[	@ibI"ù  
  def function(arglist)
    (include?("STRING") or ENV["STRING"])
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist);Fi[	@ikI"ƒ  def function(arglist)
    var = find { |arglist| var =~ /--json=.+/ }
    var.split("STRING").last if var
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist);Fi[	@ioI"ä  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  def function(arglist);Fi[	@iwI"†  
  def function(arglist)
    (build_head? or build_devel?).!
  end
  
  def function(arglist)
    include?("STRING")
  end
  
  # Request a 32-bit only build.;Fi[@
@I"flag?("STRING");FI"end;FI" ;Fi	[	[	@iCI"—  def function(arglist)
    (at((@var + 1)) or raise(UsageError))
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    (flag?("STRING") or (ENV["STRING"] or ENV["STRING"]));Fi[	@iOI"®  def function(arglist)
    (flag?("STRING") or ENV["STRING"])
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING");Fi[	@iSI"ï  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING");Fi[	@iWI"Ø  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    (include?("STRING") or switch?("STRING"));Fi[@@èAI"	else;F@ëAI"end;Fi	[	[	@siúI"•      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@vióI"•      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@yiãI"•      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@iéI"¶    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[I"/render(:nothing => (true), :status => 422);FI"end;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@≠iI"Á        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id])
    if (current_user.owns?(@var) or current_user.owns?(@var.parent)) then;Fi[	@wiI"Ê        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id)
    current_user.retract(@var);Fi[	@ªiÄI"      Webfinger.in_background(params[:diaspora_handle], :single_aspect_form => (true))
      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id])
    if @var then;Fi[	@æiJI"Ô        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first
    if var then;Fi[@(@@∑
I"flag?("STRING");FI"end;Fi	[	[	@iBI"ö  
  def function(arglist)
    (at((@var + 1)) or raise(UsageError))
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist);Fi[	@iNI"ó  
  def function(arglist)
    (flag?("STRING") or ENV["STRING"])
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist);Fi[	@iRI"Ñ  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist);Fi[	@iVI"Ñ  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist)
    flag?("STRING")
  end
  
  def function(arglist);Fi[I"acts_as_api;FI" ;F@f@I"var.add(:id);FI"var.add(:guid);Fi	[	[	@j@iI"ß  
  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	@m@iI"ú    end
  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	@ÁiI"€  
  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:name)
    var.add(lambda { |arglist| var.diaspora_handle }, :as => :diaspora_id);Fi[	@üiI"∞  
  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:created_at)
    var.add(:author);Fi[@.@\AI"end;FI" ;FI"def function(arglist);Fi	[	[	@õiI"ø          end
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end;Fi[	@õi~I"—          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end;Fi[	@õiÇI"—          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end;Fi[	@õiÜI"€          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          Spec.deprecate("STRING")
          red(var);Fi[@@lI"end;FI" ;FI"def function(arglist);Fi	[	[	@ÍiùI"ﬂ        (@var, var = var, @var
        yield)
      ensure
        @var = var
      end
    end
    
    def function(arglist)
      var = caller[0].split("STRING")[(0..1)].join("STRING")
      raise(GemfileError, "STRING");Fi[	@—i*I"©    @var = var
    unless var.nil? then
      @var = var.delete(:using)
      @var = var
    end
  end
  
  def function(arglist)
    @var ||= case var
    when nil then;Fi[	@Åi@I"Ö        @var = @var
      end
      @var = (@var - @var)
      @var = var
    end
  end
  
  def function(arglist)
    @var = 1
  end;Fi[	@¨i*I"¬          (@var[@var]
          @var = true)
        rescue Exception => var
          @var = var
        end
      end
      
      def function(arglist)
        case @var
        when nil then;Fi[@@l@mI"private;FI" ;Fi	[	[	@ÌiCI"~    end
    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "STRING";Fi[	@i(I"Û    # once the remote gem is downloaded, the backend specification will
    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      @var ||= @var.fetch_spec([@var, @var, @var]);Fi[	@X,i"I"ó    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    
    # Gets the default Mongoid logger - stdout.
    #;Fi[	@&i6I"÷              @var = var
            end
            @var = var
            @var = var
          end
          
          private
          
          # Can the existing relation potentially be deleted?
          #;Fi[@@l@mI"attr_reader :function;FI" ;Fi	[	[	@ÌiI"‘      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    
    # needed for standalone, load required_paths from local gemspec
    # after the gem in installed;Fi[	@:iWI"®    
    class JsArg
      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing;Fi[	@&i2I"ê  
  def function(arglist)
    @var = var.to_s
    @var = var
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == "STRING");Fi[	@mi2I"«    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    
    ERROR_MESSAGES.keys.each do |arglist|
      define_method("STRING") { |arglist| (@var == var) };Fi[@ÃC@É?I"out("STRING");FI"out("STRING");FI"newobj;Fi	[	[	@si<I"  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING");Fi[	@viEI"  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING");Fi[	@yi+I"  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING");Fi[	@iåI"    out("STRING")
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING");Fi[@.@⁄=I"end;FI"end;FI"end;Fi	[	[	@ﬁ=iI"Ô      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@·=i!I"Ù      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@‰=i(I"      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@Á=iI"      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[I"var = @var["STRING"];FI"/var = ((@var - @var) - @var) if (var == 0);F@–?@—?I"var = var.length;Fi	[	[	@si[I"6  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0;Fi[	@viPI"6  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0;Fi[	@yiJI"6  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0;Fi[	@Åi6I"%  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "STRING")
    var = 0;Fi[@Å?@Ç?@É?I"out("STRING");FI"out("STRING");Fi	[	[	@si;I"  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING");Fi[	@viDI"  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING");Fi[	@yi*I"  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING");Fi[	@iãI"	    newobj
    out("STRING")
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING");Fi[@ƒD@ûA@&B@'BI"var = var.length;Fi	[	[	@si≠I"ﬁ  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0;Fi[	@vi®I"ﬁ  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0;Fi[	@yiúI"ﬁ  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0;Fi[	@ÅiãI"ﬁ  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0;Fi[@@>@A>I"#     end;FI"#   end;FI"#;Fi	[	[	@◊iQI"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@◊içI"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@◊i—I"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@◊iÙI"–      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[@A>I"#     end;FI"#   end;FI"#;FI"#   person = Person.new;Fi	[	[	@◊iRI"Ú      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob";Fi[	@◊iéI"Ù      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob";Fi[	@◊i“I"      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob";Fi[	@◊iıI"Ô      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true;Fi[I"# type.;FI"#;F@“I"#   object.mongoize;FI"#;Fi	[	[	@&iSI"Ë      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.
      #;Fi[	@)iI"È      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[	@:ioI"Á      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.
      #;Fi[	@=i|I"È      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[@É?I"out("STRING");FI"out("STRING");FI"newobj;FI"out("STRING");Fi	[	[	@si=I""    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]));Fi[	@viFI""    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]));Fi[	@yi,I""    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]));Fi[	@içI""    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]));Fi[@
@@;I"end;FI" ;Fi	[	[	@Ui)I"Ë      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist);Fi[	@UiBI"˝      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@UifI"ﬁ      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var);Fi[	@UivI"      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.
      def function(arglist);Fi[@@@ﬂ?I"send_message(var);FI"end;Fi	[	[	@›i8I"∞        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      ##;Fi[	@›i6I"√        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      def function(arglist);Fi[	@‡i@I"”        when :warning then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      # Push a message via the Pushover API;Fi[	@„i4I"√        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      def function(arglist);Fi[@X3@Y3@ê;I"var = "STRING";FI"	else;Fi	[	[	@Åi_I"¸    var = var
    out(sprintf("STRING", var, var, var, var, var, var))
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end;Fi[	@ÅiqI"–  
  def function(arglist)
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end;Fi[	@imI"¸    var = var
    out(sprintf("STRING", var, var, var, var, var, var))
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end;Fi[	@iáI"“  	#
  def function(arglist)
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end;Fi[@X3I"var = "STRING";FI"var = "STRING";FI"	else;FI"var = "STRING";Fi	[	[	@sidI"    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?;Fi[	@viYI"    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?;Fi[	@yiSI"    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?;Fi[	@Åi?I"    var = 0
    if var.!=(0) then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.index("STRING").nil?
        var = (var + "STRING") unless var.index("STRING").nil?;Fi[@ÉI"# type.;FI"#;F@“@Ei	[	[	@&iRI"	        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.;Fi[	@)iI"Ó        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[	@:inI"Î        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.;Fi[	@=i{I"Ì        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[@íCI"end;FI"end;FI"end;FI"end;Fi	[	[	@òCiI"è      #
      # @since 3.0.14
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	@õCiI"é      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	@ûCiI"é      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	@°CiI"é      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[I"'var = var.gsub("STRING", "STRING");FI"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;Fi	[	[	@si∞I"·    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@vi´I"·    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@yiüI"·    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@ÅiéI"·    var = @var["STRING"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[@@@@XI"#;Fi	[	[	@i£I"û      end
      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #
  	# Calculate closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@i≥I"Æ      @var = (@var + 1)
      @var.push([])
    else
      # do nothing
    end
  end
  
  #
  	# Convert to accessible file path
  	# @param string :attrname image file name;Fi[	@iéI"≥      SetStyle("STRING", true)
      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #
  	# Process closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@i;I"µ        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.
  	# @param string :tag tag name (in lowercase);Fi[I"yield(var);FI"end;FI"end;FI" ;FI"##;Fi	[	[	@Èi4I"4        Net::FTP.send(:const_set, :FTP_PORT, port)
        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@°i4I"G      # Establishes a connection to the remote server
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@˜i(I"O      # Net::SCP will use this connection to transfer backups
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@˙i&I"H      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[@¡4I"	else;F@√4I"end;FI"@var = @var.!=(@var);Fi	[	[	@ÅiI"*  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
  end;Fi[	@ÅiI"  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end
  ;Fi[	@iÃI"H  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
    @var = [var, var, var] if var;Fi[	@iÏI"/  	#
  def function(arglist)
    if (((var == 0) and ((:g == 0) and (:b == 0))) or (:g == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    @var = [var, var, var] if var
  end;Fi[@
@I"var = @var;F@À@I"newobj;Fi	[	[	@siÓI"°  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING");Fi[	@vi˜I"°  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING");Fi[	@yi›I"°  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING");Fi[	@Åi@I"≈    out("STRING")
    out("STRING")
  end
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out(((("STRING" + "STRING") + var) + "STRING"))
      out("STRING");Fi[@
@I"@var.each(&var);FI"end;FI" ;Fi	[	[	@b&iI"ª      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self;Fi[	@0*i$I"‹      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1);Fi[	@—i™I"ú  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag };Fi[	@#iI"ù  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?;Fi[@
@I"@var ||= var;FI"end;FI" ;Fi	[	[	@fiI"ƒ      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@iI"ø      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var;Fi[	@ö	iI"Á      attr_accessor(:feature)
      
      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var);Fi[	@PiI"©      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false;Fi[@
@@é7I"end;FI" ;Fi	[	[	@i>I"’      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var);Fi[	@ö	iHI"6      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq;Fi[	@ i(I"       def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init;Fi[	@ iRI"÷          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags;Fi[I"# @access private;FI"#;FI"def function(arglist);FI"case var;FI"when "STRING" then;Fi	[	[	@i~I"ﬁ  	#
  	# @param string :tag tag name (in upcase)
  	# @param string :attr tag attribute (in upcase)
  	# @access private
  	#
  def function(arglist)
    case var
    when "STRING" then
      @var[@var] = 0
      @var = 0;Fi[	@i™I"Í  #
  	# Calculate closing tags.
  	# @param string :tag tag name (in upcase)
  	# @access private
  	#
  def function(arglist)
    case var
    when "STRING" then
      @var[@var] = @var if (@var[@var] < @var)
      @var = (@var + 1);Fi[	@iƒI"P  	# @param string :tag tag name (in upcase)
  	# @param string :attr tag attribute (in upcase)
  	# @param int :fill Indicates if the cell background must be painted (1) or transparent (0). Default value: 0.
  	# @access private
  	#
  def function(arglist)
    case var
    when "STRING" then
      @var = true
      @var = (@var + 5);Fi[	@iïI"Ã  #
  	# Process closing tags.
  	# @param string :tag tag name (in upcase)
  	# @access private
  	#
  def function(arglist)
    case var
    when "STRING" then
      @var = false
      @var = (@var - 5);Fi[I"5if ((var == "STRING") or (var == "STRING")) then;FI"@var = "STRING";FI"@var = @var;FI"@var = @var;FI"	else;Fi	[	[	@Åi`I"
    @var = (@var / @var)
    @var = (@var / @var)
    var.downcase!
    if ((var == "STRING") or (var == "STRING")) then
      @var = "STRING"
      @var = @var
      @var = @var
    else
      if ((var == "STRING") or (var == "STRING")) then
        @var = "STRING";Fi[	@ÅieI"ÿ      @var = @var
      @var = @var
    else
      if ((var == "STRING") or (var == "STRING")) then
        @var = "STRING"
        @var = @var
        @var = @var
      else
        raise(("STRING" + var))
      end;Fi[	@iiI"    @var = (@var / @var)
    @var = (@var / @var)
    var = var.downcase
    if ((var == "STRING") or (var == "STRING")) then
      @var = "STRING"
      @var = @var
      @var = @var
    else
      if ((var == "STRING") or (var == "STRING")) then
        @var = "STRING";Fi[	@inI"–      @var = @var
      @var = @var
    else
      if ((var == "STRING") or (var == "STRING")) then
        @var = "STRING"
        @var = @var
        @var = @var
      else
        Error("STRING")
      end;Fi[@
@I"	name;FI"end;FI" ;Fi	[	[	@7i\I"£        @var = app_cache_path if has_app_cache?
        local_specs
      end
      
      def function(arglist)
        name
      end
      
      private
      ;Fi[	@ö%iI"π  attr_accessible(:name, :contacts_visible, :order_id)
  
  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var;Fi[	I"Idata//redmine_proj/plugins/awesome_nested_set/spec/support/models.rb;Ti$I"»  def function(arglist)
    @@var
  end
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } });Fi[	I"Ldata//redmine_proj/plugins/awesome_nested_set/test/fixtures/category.rb;TiI"Ÿclass Category < ActiveRecord::Base
  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } });Fi[@(@@∑
I"	to_s;FI"end;Fi	[	[	@ì	iI"•    def function(arglist)
      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[	@?iI"ª        raise(Sass::SyntaxError, "STRING")
      end
      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    
    def self.color_to_s(arglist);Fi[	@?i8I"õ      def function(arglist)
        class_eval("STRING")
      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[	@à7i$I"Ç    
    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[@'@(@)@ﬂ?@+Ei	[	[	@›i7I"∫          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      ;Fi[	@›i5I"∫          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      ;Fi[	@‡i?I"∫          "STRING"
        when :warning then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      ;Fi[	@„i3I"∫          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      ;Fi[@6.@7.@8.I" ;FI"def function(arglist);Fi	[	[	@ıiBI"—      when Gem::Dependency then
        search_by_dependency(var, var)
      else
        raise("STRING")
      end
    end
    
    def function(arglist)
      sources.map { |arglist| var.class }.uniq
    end;Fi[	@i"I"Í          @var = true
          @var.scenario_outline(var.gherkin_statement)
        else
          raise("STRING")
        end
      end
      
      def function(arglist)
        @var.step(var.gherkin_statement)
        if @var then;Fi[	@Oi*I"‚      raise("STRING")
    end
    unless (HOMEBREW_PREFIX.writable_real? or (HOMEBREW_PREFIX.to_s == "STRING")) then
      raise("STRING")
    end
  end
  
  def function(arglist)
    require("cmd/doctor")
    var = Checks.new;Fi[	@|
iI"æ          end
        end
      else
        raise("STRING")
      end
    end
    
    def function(arglist)
      var = "STRING".to_sym
      ::I18n.t(var, :default => (var.to_s.humanize));Fi[@'@©*@™*@´*I" ;Fi	[	[	@riOI"‚          preload_one(var)
        when String then
          preload_one(var.to_sym)
        else
          raise(ArgumentError, "STRING")
        end
      end
      
      def function(arglist)
        var.each do |arglist|;Fi[	@ıi|I"°      if var.is_a?(Index) then
        (@var << var)
        @var.uniq!
      else
        raise(ArgumentError, "STRING")
      end
    end
    
    private
    ;Fi[	@…iI"v            Compression.new("STRING", [var, "STRING"], [var, "STRING"])
          when :zip then
            Compression.new("STRING", ["STRING", "STRING"], ["STRING", "STRING"])
          else
            raise(ArgumentError, "STRING")
          end
        end
        
        # Returns the command necessary to compress the given directory
        # into the given file.;Fi[	@Ïi˙I"Ó          YAML.load(ERB.new(File.read(var)).result)
        when Hash then
          var
        else
          raise(ArgumentError, "STRING")
        end
      end
      
      def function(arglist)
        (s3_protocol(var) == "STRING");Fi[@‚EI"var = "STRING";FI"	else;FI"var = "STRING";FI"end;Fi	[	[	@ÅiaI"ÿ    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING"));Fi[	@ÅisI"    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING", (var * @var), ((@var - var) * @var), (var * @var), (-var * @var), var));Fi[	@ioI"ÿ    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING"));Fi[	@iâI"    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end
    out(sprintf("STRING", (var * @var), ((@var - var) * @var), (var * @var), (-var * @var), var));Fi[I"%#         transition all => :off;FI"#       end;FI"#     end;FI"#   end;FI"#;Fi	[	[	@áiQI"N    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.state                                 # => "parked";Fi[	@ái~I"J    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.fire_events(:ignite, :disable_alarm)  # => true;Fi[	@f2iïI"A    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly
    #   vehicle = Vehicle.create    # => #<Vehicle id=1 state="parked" alarm_state="active">;Fi[	@f2i–I"5    #       end
    #       
    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end
    #   end
    # 
    # The above class defines two state machines: +heater_state+ and +alarm_state+.
    # For the +heater_state+ machine, the following methods are generated since;Fi[@(@@∑
I"@var ||= {};FI"end;Fi	[	[	@⁄iI"ÿ        # Used only within the specs
        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist);Fi[	@=iKI"§      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist);Fi[	@|
iíI"I          var = ::I18n.load_path.select { |arglist| (File.basename(var, "STRING") == var) }
          load_translations(var)
          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        # Looks up a translation from the translations hash. Returns nil if;Fi[	@≤iI"ƒ        @var = (var[:__declared_as] or "STRING")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist);Fi[@(I"	@var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@Pi6I"?            ([primary_key] + (column_names - [primary_key])).compact.each_with_index do |arglist|
              (@var << [var, "STRING"])
            end
          end
          @var
        end
        
        def function(arglist)
          Hash[column_names_with_alias.map { |arglist| [var, var[var]] }]
        end;Fi[	@πiPI"˝        end)
        unless (@var.include?(NO_PROFILE_LONG_FLAG) or @var.include?(NO_PROFILE_SHORT_FLAG)) then
          @var.push("STRING")
        end
        @var
      end
      
      def function(arglist)
        @var = var
        @var = @var.dup;Fi[	@§.i,I"Ù    unless @var then
      require("yaml")
      @var = YAML.load_file((Pathname.new(ABS__FILE__).parent.realpath + "STRING"))
    end
    @var
  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new;Fi[	@?iêI"        var.each_pair do |arglist|
          @var[var.to_sym] = Paperclip::Style.new(var.to_sym, var.dup, self)
        end
      end
      @var
    end
    
    def function(arglist)
      var = @var[:only_process].dup
      var = var.call(self) if var.respond_to?(:call);Fi[@ú?I" ;F@û?I"["STRING"];FI"end;Fi	[	[	@‰iI"È      
      require("state_machine/integrations/active_record/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist);Fi[	@ÁiI"◊      
      require("state_machine/integrations/mongo_mapper/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      protected;Fi[	@ÍiI"„      
      require("state_machine/integrations/mongoid/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist);Fi[	@ #iI"      
      require("state_machine/integrations/sequel/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      # Forces the change in state to be recognized regardless of whether the;Fi[@(@VF@WFI"end;FI"end;Fi	[	[	@‡iVI"€        @var = {}
        [:token, :user, :message, :title, :priority, :device].each do |arglist|
          @var.merge!(var => (self.instance_variable_get("STRING")))
        end
        @var
      end
    end
  end
end;Fi[	@c	i}I"~          else
            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end
end;Fi[	@|i&I"±      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!((self.class.read_inheritable_attribute(:rfpdf) or {})) do |arglist|
        var
      end
      @var
    end
  end
end;Fi[	@åiZI"]        var = (var + TimeEntryActivityCustomField.all)
        var.select { |arglist| ["STRING", "STRING"].include?(var.field_format) }.each do |arglist|
          @var["STRING"] = { :sql => "STRING", :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[@(@G'@H'I"end;FI"end;Fi	[	[	@⁄i˚I"Õ          var = "STRING"
          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	@FiSI"•            var.save
            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end
end;Fi[	@ziI"               field(var.inverse_type, :type => (String))
              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end
end;Fi[	@∏i£I"§            var = @var.instance_eval(&var)
            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end
end;Fi[@(@@∑
I"if var.nil? then;FI"nil;Fi	[	[	@åiI"	        
        def function(arglist)
          Hash.===(var) ? (var.map { |arglist| "STRING" }.join("STRING")) : (var)
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if String.===(var) then;Fi[	@åiPI"¸        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if ("STRING" == var) then;Fi[	@åibI"ø              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if Range.===(var) then;Fi[	@ÚiI"Í        var.inherit_from!(configuration)
        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then;Fi[@
@@âFI"nil;FI"	else;Fi	[	[	@åiI"9        def function(arglist)
          Hash.===(var) ? (var.map { |arglist| "STRING" }.join("STRING")) : (var)
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if String.===(var) then
              Hash[var.scan(HstorePair).map do |arglist|;Fi[	@åiQI"        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if ("STRING" == var) then
              (nil..nil);Fi[	@åicI"˝            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if Range.===(var) then
              if [var.first, var.last].all? { |arglist| Integer.===(var) } then;Fi[	@ÚiI"—        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then
            var;Fi[I"&# @return [Array<Twitter::Tweet>];F@p9I"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;FI"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi	[	[	@s9iI"æ      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user;Fi[	@s9i]I"®      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@s9irI"®      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@s9iÑI"®      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[@ÿ=@Ÿ=@⁄=I"end;FI"end;Fi	[	[	@ﬁ=iI"ˆ      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@·=i I"˚      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@‰=i'I"˜      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@Á=iI"˜      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@
@I"var;FI"end;FI" ;Fi	[	[	@ˇiI"¿      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var));Fi[	@Åi!I"ﬁ      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true);Fi[	@Ui,I"            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end
          
          alias :handle_snippet_text :handle_success
        end;Fi[	@‚iI"Ü    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var;Fi[@@@¡.@¬.I" #   person.pets.size # => 3;Ti	[	[	@-ièI"      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@-iI"0      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@-iI"D      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@-içI"Ç      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #;Ti[@*;I"#;FI"# @since 3.0.0;F@-;I"	true;Fi	[	[	@&ivI"√      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@&i†I"◊        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[	@:i{I"Ω      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@:iΩI"“        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[@⁄=I"end;FI"end;FI"end;FI"end;Fi	[	[	@ﬁ=iI"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@·=i"I"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@‰=i)I"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@Á=iI"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@'@ODI"end;FI"end;FI" ;Fi	[	[	@≠iI"ˇ          render(:partial => "STRING", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id]);Fi[	@wiI"          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id);Fi[	@ªiI"2    if params[:diaspora_handle] then
      Webfinger.in_background(params[:diaspora_handle], :single_aspect_form => (true))
      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id]);Fi[	@æiII"Í      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first;Fi[I"# @since 2.1.0;F@≈;@∆;I"end;FI" ;Fi	[	[	@èi(I"‰      #
      # @return [ true, false ] If the thread is assigning.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Execute a block in binding mode.
      #;Fi[	@èiGI"„      #
      # @return [ true, false ] If the thread is binding.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Execute a block in building mode.
      #;Fi[	@èifI"Í      #
      # @return [ true, false ] If the thread is building.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Is the current thread in creating mode?
      #;Fi[	@èirI"„      #
      # @return [ true, false ] If the thread is creating.
      #
      # @since 2.1.0
      def function(arglist)
        Threaded.executing?("STRING")
      end
      
      # Execute a block in loading mode.
      #;Fi[@(@ﬂ?@+EI"end;FI" ;Fi	[	[	@›i9I"ÿ          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      ##
      # Creates a new Campfire::Interface object and passes in the;Fi[	@›i7I"¯          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      def function(arglist)
        var = Prowler.new(:application => (application), :api_key => (api_key));Fi[	@‡iAI"‘          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      # Push a message via the Pushover API
      def function(arglist);Fi[	@„i5I"—          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var)
      end
      
      def function(arglist)
        ::Twitter.configure do |arglist|;Fi[@(@9I"	true;FI"end;FI"def function(arglist);Fi	[	[	@»i.I"˝        end
        def function(arglist)
          defined? I18n ? (super) : (var ? (var.to_s.humanize.downcase) : ("STRING"))
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end;Fi[	@»i1I"∂        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end;Fi[	@»i4I"ø        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          :activerecord
        end;Fi[	@’i6I"ø        end
        def function(arglist)
          false
        end
        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing
        end;Fi[@(@@∑
@D1I")ActiveSupport::Deprecation.warn(var);Fi	[	[	@{i+I".          end
          self.serialized_attributes = serialized_attributes.merge(var.to_s => (var))
        end
      end
      
      def function(arglist)
        var = "STRING"
        ActiveSupport::Deprecation.warn(var)
        defined? @var ? (@var) : (self.class.serialized_attributes)
      end;Fi[	@ˇiÙI"Î      
      def function(arglist)
        ActiveSupport::Deprecation.warn("STRING")
      end
      
      def function(arglist)
        var = "STRING"
        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end;Fi[	@ëi´I"        # Aborts a transaction.
        def function(arglist)
          execute("STRING")
        end
        
        def function(arglist)
          var = "STRING"
          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end;Fi[	@"!iI"Î      def function(arglist)
        self._attr_readonly
      end
    end
    
    def function(arglist)
      var = "STRING"
      ActiveSupport::Deprecation.warn(var)
      defined? @var ? (@var) : (self.class._attr_readonly)
    end;Fi[@
@I"var = "STRING";F@E1I"-var.change_make_var!("STRING", "STRING");Fi	[	[	@H1iI"¸    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@H1iI"¸    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@H1iI"¸    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[	@H1i#I"¸    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end
  
  def function(arglist)
    var = "STRING"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("STRING", "STRING")
    assert_equal("STRING", var)
  end;Fi[@(@@∑
@¡0I"end;Fi	[	[	@Ëi4I"Æ          @var = proc { |arglist| extending(var) }
        end
      end
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist);Fi[	@Òi)I"ê    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist);Fi[	@˛i;I"¨    
    def function(arglist)
      (super or @var.respond_to?(*var))
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist);Fi[	@i#I"Ø      
      def function(arglist)
        directory(var.to_s, (var or "STRING"))
      end
      
      def function(arglist)
        @var ||= "STRING"
      end
    end
    ;Fi[@%@%I" ;F@∂#I"
false;Fi	[	[	@˙iI"Ü      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@ˇi|I"      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@Òi$I"w    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@HixI"º  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  ;Fi[@±'@≤'@É<I"end;FI" ;Fi	[	[	@i2I"Í      #
      # @return [ Integer ] The number of emitted documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Provide a finalize js function for the map/reduce.
      #;Fi[	@i^I"ÿ      #
      # @return [ Integer ] The number of input documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Sets the map/reduce to use jsMode.
      #;Fi[	@iåI"Ë      #
      # @return [ Integer ] The number of output documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Get the raw output from the map/reduce operation.
      #;Fi[	@iØI"˜      #
      # @return [ Integer ] The number of reduced documents.
      #
      # @since 3.0.0
      def function(arglist)
        counts["STRING"]
      end
      
      # Adds a javascript object to the global scope of the map/reduce.
      #;Fi[@m9@n9@o9@p9@¢Fi	[	[	@s9iI"       # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@s9i[I"      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@s9ipI"0      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@s9iÇI"0      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[@'@ëAI"end;FI"end;FI"end;Fi	[	[	@siûI"•      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@viôI"•      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@yiçI"•      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@iêI"Ø        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell);Fi[@2)@3)I" ;F@éI"	true;Fi	[	[	@ÅiàI"√      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@ÅiëI"√      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@§iÖI"ê      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@§i©I"è      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[@(I"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);Fi	[	[	@˙5iI"¯    puts((("STRING" * var) + var.to_s))
    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("STRING") then
      Formula.each { |arglist| puts("STRING") };Fi[	@˝5iI"Æ  def function(arglist)
    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("STRING") then
      puts("STRING");Fi[	@
iI"ó      ARGV.formulae
    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    ff.each do |arglist|
      next if var.build.empty?;Fi[	@6i
I"Ê  def function(arglist)
    (self > 1) ? ("STRING") : ("STRING")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then
      abort("STRING");Fi[@ı!@@@@I"end;FI" ;Fi	[	[	@iZI"„end
class CVSDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  ;Fi[	@iÖI"Èend
class MercurialDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  ;Fi[	@i≠I"Êend
class BazaarDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  ;Fi[	@iÀI"Êend
class FossilDownloadStrategy < AbstractDownloadStrategy
  def function(arglist)
    super
    @var = "STRING" unless (var.to_s.empty? or (var == "STRING"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  ;Fi[@ı!@ˆ!@˜!@#I" ;Fi	[	[	@ëi1I"Ì              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist)
          super.insert;Fi[	@æi'I"ƒ        def function(arglist)
          @var.synchronize do |arglist|
            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      ;Fi[	@1i^I"»          if lock_strategy_enabled?(:failed_attempts) and attempts_exceeded? then
            :locked
          else
            super
          end
        end
      end
      
      protected
      ;Fi[	@∂&iI"€        var = Time.now.strftime("STRING")
        var = "STRING"
      else
        super
      end
    end
  end
  
  module TempfileEncoding
    # This overrides Tempfile#binmode to make sure that the extenal encoding;Fi[@'I"5if ((var == "STRING") or (var == "STRING")) then;FI"var = "STRING";FI"	else;FI"var = "STRING";Fi	[	[	@Åi`I"ˆ    out(sprintf("STRING", var, var, var, var, var, var))
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end;Fi[	@ÅirI"’  def function(arglist)
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end;Fi[	@inI"ˆ    out(sprintf("STRING", var, var, var, var, var, var))
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end;Fi[	@iàI"’  def function(arglist)
    if (var == "STRING") then
      var = "STRING"
    else
      if ((var == "STRING") or (var == "STRING")) then
        var = "STRING"
      else
        var = "STRING"
      end
    end;Fi[@n9@o9@p9@¢F@£Fi	[	[	@s9iI"ä      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@s9i\I"å      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@s9iqI"û      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@s9iÉI"û      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[@(I"it("STRING") do |arglist|;FI"-var = Category.create(:name => "STRING");F@{:@|:i	[	[	@Å:i=I"q    (categories(:top_level).right.should == 13)
    (categories(:child_2_1).left.should == 8)
    (categories(:child_2_1).right.should == 9)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var);Fi[	@Å:iHI"L    Category.update_all("STRING")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var);Fi[	@Å:iSI"L    Category.update_all("STRING")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var);Fi[	@Å:i≠I"õ    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(:validate => (false))
    Category.left_and_rights_valid?.should(be_false)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = [var, var, var, var];Fi[@∆:@«:@»:@…:I"%["STRING", var[0, 1], var[0, 1]];Fi	[	[	@Ì)iÑI"3    def function(arglist)
      case var[0]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]];Fi[	@Ì)iÜI"I      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]];Fi[	@Ì)iàI"I      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]];Fi[	@Ì)iäI"5      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        ["STRING", var[0, 1], var[0, 1]]
      when "STRING" then
        nulltok(var);Fi[@¿/@¡/@"I""STRING";FI"end;Fi	[	[	@•iPI"g      end
    end
    
    private
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@ÌiFI"n      @var = var
    end
    
    private
    
    def function(arglist)
      "STRING"
    end
  end
end;Fi[	@7i›I"ù        return toJavaDocument
      end
      
      private
      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist);Fi[	@ji4I"      return true
    end
    
    private
    
    def function(arglist)
      "STRING"
    end
    
    def function(arglist);Fi[I"8assert((TARGET_FOLDER + "STRING").exist?, "STRING");FI"8assert((TARGET_FOLDER + "STRING").exist?, "STRING");FI"end;FI"end;FI" ;Fi	[	[	@(0i%I"*  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(["STRING", "STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|;Fi[	@(0i-I"#  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(Dir["STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|;Fi[	@(0i7I"      FileUtils.mkdir_p("STRING")
      system("STRING")
      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|;Fi[	@(0iUI"D      system("STRING")
      TARGET_FOLDER.install("STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  # test_install_symlink
  # test_install_relative_symlink;Fi[@/@0@n@9@J<i	[	[	@i¡I"Î      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@i∆I"˚      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@iÀI"˚      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@i–I"˚      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[I"/assert(var.include?("STRING").!, "STRING");FI"-assert(var.include?("STRING"), "STRING");FI"end;FI"end;FI"end;Fi	[	[	@?
i$I"    shutup do |arglist|
      DefaultPatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist);Fi[	@?
i.I"    shutup do |arglist|
      ListPatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist);Fi[	@?
i8I"    shutup do |arglist|
      P0PatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist);Fi[	@?
iBI"Î    shutup do |arglist|
      P1PatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
end;Fi[@/@0@n@9I"var = "STRING";Fi	[	[	@§i¥I"E      def function(arglist)
        var = exec_query("STRING", "STRING").to_hash
        raise(ActiveRecord::StatementInvalid, "STRING") if var.empty?
        var
      end
      
      def function(arglist)
        var = "STRING"
        var = lambda { |arglist| yield(var) if block_given? }
        transaction do |arglist|;Fi[	@ﬁiƒI"      unless var then
        raise(GemNotFound, not_found_message(var, Bundler.load.dependencies))
      end
      var
    end
    
    def function(arglist)
      var = "STRING"
      var = var.map { |arglist| var.name }
      var = SimilarityDetector.new(var).similar_word_list(var);Fi[	@<i4I"      def self.from_lock(arglist)
        var = new(var)
        Array(var["STRING"]).each { |arglist| var.add_remote(var) }
        var
      end
      
      def function(arglist)
        var = "STRING"
        (var << remotes.map { |arglist| "STRING" }.join)
        (var << "STRING");Fi[	@2iûI"            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = "STRING"
        if var[:bar_start] and var[:bar_end] then
          var = ((var[:bar_end] - var[:bar_start]) - 2);Fi[@
@I"raise("STRING");FI"end;FI"end;Fi	[	[	@=.iI"î      def function(arglist)
        raise("STRING")
      end
      
      def function(arglist)
        raise("STRING")
      end
    end
  end
end;Fi[	@vi|I"Ñ        ::OmniAuth.config.path_prefix = var
      end
    end
    
    def function(arglist)
      raise("STRING")
    end
  end
end;Fi[	@&ißI"  end
  
  private
  
  def function(arglist)
    raise("STRING")
  end
end
class MacOSVersion < Version
  compare do |arglist|;Fi[	@=i=I"é            end
          end
        end
        
        def function(arglist)
          raise("STRING")
        end
      end
    end
  end;Fi[@â5I"assert(var.i386?.!);FI"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);Fi	[	[	@§0inI"¸  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@§0içI"  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@§0iùI"  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@§0i≠I"  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[@
@{+I"end;FI"end;FI"end;Fi	[	[	@ˆi[I"ø        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@˘iÖI"É          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@¸i>I"™          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@
iRI"¢        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[@À9@Ã9@Õ9@Œ9I"S# @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi	[	[	@s9iHI"O      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik;Fi[	@s9i_I"h      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user;Fi[	@s9itI"3      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@s9iÜI"ñ      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.;Fi[@(@@)I"end;FI"end;Fi	[	[	@ˆiZI"ƒ        
        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@˘iÑI"ù        def function(arglist)
          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@¸i=I"Õ          var = project.notified_users
          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@
iQI"÷        # Returns an array of watchers' email addresses
        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[I"ï#   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.;FI"=#   @param options [Hash] A customizable set of options.;FI"def function(arglist);FI">threaded_user_objects_from_response(:post, "STRING", var);FI"end;Fi	[	[	I"<data//twitter_proj/twitter/api/friends_and_followers.rb;Ti≥I"Ï      #   @example Unfollow @sferik
      #     Twitter.unfollow('sferik')
      # @overload unfollow(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "STRING", var)
      end
      
      (alias :friendship_destroy :unfollow);Fi[	I"5data//twitter_proj/twitter/api/spam_reporting.rb;TiI"·      #     Twitter.report_spam("spam")
      #     Twitter.report_spam(14589771) # Same as above
      # @overload report_spam(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "STRING", var)
      end
    end
  end;Fi[	I",data//twitter_proj/twitter/api/users.rb;Ti’I"      #     Twitter.block('sferik')
      #     Twitter.block(7505382)  # Same as above
      # @overload block(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "STRING", var)
      end
      
      # Un-blocks the users specified by the authenticating user;Fi[	@]HiËI"	      #     Twitter.unblock('sferik')
      #     Twitter.unblock(7505382)  # Same as above
      # @overload unblock(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "STRING", var)
      end
      
      # Returns extended information for up to 100 users;Fi[I"var = read_file("STRING");F@˜G@¯GI"end;FI"end;Fi	[	[	@?
i#I"  def function(arglist)
    shutup do |arglist|
      DefaultPatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  ;Fi[	@?
i-I"  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  ;Fi[	@?
i7I"  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  ;Fi[	@?
iAI"  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
end;Fi[@X@Y@Z@[I"end;Fi	[	[	@si]I"á    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@vi^I"á    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@yiHI"á    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@i•I"ä    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
  
  #;Fi[@/@0@1@I"# :nodoc:;Fi[[	@!i(I"’  def function(arglist)
    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist)
    File.exist?("STRING") ? ("STRING") : ("STRING");Fi[	@áiôI"´        when Proc then
          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["STRING"] then;Fi[	@øi*I"”        when Symbol then
          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= mock_framework_path("STRING");Fi[I"var = nil;FI"	else;FI"&if list_of_color_stops?(var) then;FI"var = (var.value + var);FI"var = nil;Fi[[	@?iÛI"‰    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@?i˝I"Û      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@?iI"‰    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[@¿/@¡/@√A@ƒAI"# @param args [Array];Fi[[	@¡iˇI"        list_from_response_with_users(:post, "STRING", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[	@+i˝I"’        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>]
      def function(arglist);Fi[	@ƒiI"È    module Utils
      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[@¿/@¡/@‹3I" ;FI"def function(arglist);Fi[[	@/	iNI"π        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("STRING" => (nil))
      end;Fi[	@4	iBI"ƒ        Kernel.system("STRING")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["STRING"] or DEFAULT_ENCODING)
      end;Fi[	@x	iTI"‘      to.responds_to?(:read) ? ("STRING") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("STRING") if logger
      @var = sessions.map do |arglist|;Fi[@/@0@n@9I" var = [var.first, var.last];Fi[[	@i’I"⁄      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[	@i⁄I"π      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[	@iﬂI"π      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[@/@0@n@9I"%var = Node.new(:COMBINATOR, var);Fi[[	@i*I"÷      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@i/I"√      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@i4I"√      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[@/@0@nI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;Fi[[	@:ikI"          var = (var[var] or var[var.to_i])
          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@=i¯I"Ò        #
        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@Ri3I"5          if Mongoid::Config.use_activesupport_time_zone? then
            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[@/I"	else;FI"var;FI"end;FI"end;Fi[[	@@iUI"ˆ            (var.attribute_names.&(var.attribute_names) - var.changes.keys).each do |arglist|
              var[var] = var[var]
            end
            var
          else
            var
          end
        end
        (var + var)
      end;Fi[	@~i-I"ü              (var << "STRING")
            end
          end
          var
        else
          var
        end
      end
      
      def function(arglist);Fi[	@x	i¨I"¨          var = var.pos
          var = StringIO.new(var.read)
          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    ;Fi[@/@øHI"raise("STRING");FI"end;FI"end;Fi[[	@ëi'I"        Cucumber::JRUBY ? (var = jruby_gets(var)) : (var = mri_gets(var))
        if var then
          puts(var)
          var
        else
          raise("STRING")
        end
      end
      
      # Embed +src+ of MIME type +mime_type+ into the output. The +src+ argument may;Fi[	@∫	i5I"ﬂ          remember_token
        else
          if respond_to?(:authenticatable_salt) and var = authenticatable_salt then
            var
          else
            raise("STRING")
          end
        end
      end
      ;Fi[	@Âi"I"∆    def function(arglist)
      var = self.converters.select { |arglist| (var.class == var) }
      if var = var.first then
        var
      else
        raise("STRING")
      end
    end
  end
end;Fi[@¿/@¡/@"I"var = @var;F@À@i[[	@siÌI"ï    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"));Fi[	@viˆI"ï    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"));Fi[	@yi‹I"ï    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"));Fi[@¿/@¡/@"I"# do nothing;FI"end;Fi[[	@1icI"£          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@˛iEI"µ      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@™iI"é          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[I"protected;FI" ;FI"B# Only runs validations on the action if using <tt>:save</tt>;FI"def function(arglist);FI"(action == :save);Fi[[	@‰iI"¿        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@ÁiI"≈        ["STRING"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@ÍiI"¿        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[@ı!@ˆ!@˜!@¯!I":# Runs state events around the machine's :save action;Fi[[	@‰i?I"[        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@Ái8I"[        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@Íi<I"[        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[I"#:nodoc:;FI"def function(arglist);F@b6I"
begin;FI"(log("STRING");Fi[[	@g6i#I"        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING")
            FileUtils.rm(var) if File.exist?(var))
          rescue Errno::ENOENT => var;Fi[	@Ïi∫I"&        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING")
            var = (@var[var] or @var[:default])
            var = var.call(self, var) if var.respond_to?(:call);Fi[	@Ïi÷I"        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING")
            s3_bucket.objects[var.sub(/^\//, "STRING")].delete)
          rescue AWS::Errors::Base => var;Fi[@'I"out("STRING");FI"end;FI"end;FI"end;Fi[[	@siI"          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING");Fi[	@vi$I"          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING");Fi[	@yi
I"          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING");Fi[@ı!I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@@i%I"—      end
      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist)
        if block_given? then
          load_target.select.each { |arglist| yield(var) };Fi[	@ßiI"Ê        INDENT = "STRING"
        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super
          var.nested_descriptions.each_with_index do |arglist|;Fi[	@≠iI"Á    module Formatter
      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          @var.puts("STRING")
        end;Fi[@'I"$out(("STRING" + var["STRING"]));FI"out("STRING");FI"out("STRING");FI".out((("STRING" + (@var + 1)) + "STRING"));Fi[[	@siI"s        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then;Fi[	@viI"s        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then;Fi[	@yiI"s        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then;Fi[@'I"DCell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var);FI";var = (var[var].chr == "STRING") ? ((var + 1)) : (var);FI"end;FI"var = -1;Fi[[	@si◊I"h          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@viﬂI"Z          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@yi∆I"h          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[@'I"super(var, var, var, var);FI"end;FI"end;FI" ;Fi[[	@sißI"Õ  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"];Fi[	@vi¢I"œ  def function(arglist)
    if (@var["STRING"] == "STRING") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"];Fi[	@yiñI"Õ  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"];Fi[@'@X@I"@var = var;F@èAI"	else;Fi[[	@siöI"Í    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@viïI"Í    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@yiâI"Í    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[@'I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);F@´3I"end;FI"var = -1;Fi[[	@siâI"x        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@viÉI"j        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@yi}I"x        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[@%I"	else;FI"	true;FI"end;FI"end;Fi[[	@RirI"Ÿ        when :destroy then
          inverse_updates_counter_cache?(through_reflection).!
        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist);Fi[	@Oi∑I"ı        else
          if ["STRING", "STRING", "STRING", "STRING", false].include?(peek) then
            shift
            false
          else
            true
          end
        end
      else
        (@var.key?(var) or no_or_skip?(var).!);Fi[	@·i`I"µ  def function(arglist)
    if user and user.blocks.where(:person_id => (person_id)).exists? then
      (errors[:base] << "STRING")
      false
    else
      true
    end
  end
end;Fi[@'I"-super(var, var, var, var, var, var, var);FI"end;FI"end;FI" ;Fi[[	@siSI"Â  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[	@viHI"Á  def function(arglist)
    if (@var["STRING"] == "STRING") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[	@yiBI"Â  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[@'I"var = (var + 1000);FI"var = (var + 2);FI"end;FI"end;Fi[[	@siHI"€      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[	@vi<I"Ê        if (var >= 161) and (var <= 223) then
          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000);Fi[	@yi7I"€      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[@'I"return super(var);FI"end;FI"end;FI" ;Fi[[	@si9I"π  def function(arglist)
    if (@var["STRING"] == "STRING") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[	@vi)I"ª  def function(arglist)
    if (@var["STRING"] == "STRING") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[	@yi(I"π  def function(arglist)
    if (@var["STRING"] == "STRING") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[@%@%@%@‘.I" ;Ti[[	@≥i*I"∫          ActiveSupport::Deprecation.warn("STRING")
          true
        else
          false
        end
      end
    end
    
    def function(arglist)
      return [] if var.blank?;Ti[	@ìi<I"&            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      
      # Access a named variable. If the value of the variable responds_to? :call,
      # #call will be invoked (without parameters) and the return value cached;Fi[	@ i(I"Â          begin
            instance_exec(var, &@var)
          rescue Spec::Expectations::ExpectationNotMetError
            false
          end
        end
      end
      
      # See Spec::Matchers
      def function(arglist);Fi[@'I"var = var["STRING"];FI"out(("STRING" + var));FI"(if (var["STRING"] == "STRING") then;FI"out("STRING");Fi[[	@siI"*      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else;Fi[	@viI"*      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else;Fi[	@yi˚I"*      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else;Fi[@'I"%super(absolutify_local_url(var));FI"end;FI"end;FI" ;Fi[[	@ÍipI"Ò    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING");Fi[	@ÍiyI"Ò    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING");Fi[	@Íi}I"    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["STRING", "STRING"].all? { |arglist| var[var].present? } then;Fi[@'I"/render(:nothing => (true), :status => 404);FI"end;FI"end;FI" ;Fi[[	@—	i2I"6    if var.present? then
      var = OEmbedPresenter.new(var, params.slice(:format, :maxheight, :minheight))
      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).newer(@var);Fi[	@ƒi#I"    @var = Person.find_by_guid_and_closed_account(params[:guid], false)
    if @var.present? and @var.local? then
      render("STRING")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    render("STRING", :content_type => "STRING");Fi[	@ziìI"¯    var = User.find_by_username(var)
    if var.present? then
      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    if current_user.confirm_email(params[:token]) then;Fi[@q"@r"@î(I"private;FI" ;Fi[[	@iﬁI"≈    
    def function(arglist)
      var.send(:rules).each { |arglist| (rules << var.dup) }
      self
    end
    
    private
    
    def function(arglist)
      unless var.kind_of?(Symbol) then;Fi[	I"*data//diaspora_proj/models/request.rb;TiUI"    if var.auto_follow_back and var.receiving.! then
      var.share_with(var, var.auto_follow_back_aspect)
    end
    self
  end
  
  private
  
  # Checks if a [Contact] does not already exist between the requesting [User] and receiving [Person]
  def function(arglist);Fi[	@õiI""      IdentityMap.set(self)
      run_callbacks(:find) unless _find_callbacks.empty?
      run_callbacks(:initialize) unless _initialize_callbacks.empty?
      self
    end
    
    private
    
    # Reload the document, determining if it's embedded or not and what
    # behaviour to use.;Fi[@'I"clean_url(var);FI"end;FI"end;FI"end;Fi[[	@ëi(I"Æ      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl;Fi[	@ëiAI"Ø      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl;Fi[	@ëitI"ø      var = "STRING" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl;Fi[@'@ÖH@ÜHI"var = nil;FI"end;Fi[[	@?iÙI"Û      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@?i˛I"Û      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@?iI"Û      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[@'I"$raise(Compass::Error, "STRING");FI"end;FI"end;FI" ;Fi[[	@˜
i,I"'    def function(arglist)
      if (var.index(from) == 0) then
        var[((from.length + 1)..-6)].sub(/\.css$/, "STRING")
      else
        raise(Compass::Error, "STRING")
      end
    end
    
    def function(arglist)
      @var ||= sass_files.map { |arglist| corresponding_css_file(var) };Fi[	@Bi9I"¥      "STRING"
    when /\.([a-zA-Z]+)$/ then
      "STRING"
    else
      raise(Compass::Error, "STRING")
    end
  end
  
  def function(arglist)
    if File.readable?(var) then;Fi[	@i?I"    def self.path_and_name(arglist)
      if var.=~(SPRITE_IMPORTER_REGEX) then
        [$1, $3]
      else
        raise(Compass::Error, "STRING")
      end
    end
    
    def self.sprite_name(arglist)
      var, var = path_and_name(var);Fi[@'@Í?I"end;F@Ï?I"case var;Fi[[	@ÅiŸI"ı            "STRING"
          when (4096..4294967295) then
            "STRING"
          else
            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then
          case var
          when 1 then
            "STRING";Fi[	@ÅiËI"            "STRING"
          when (5..8) then
            "STRING"
          else
            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then
          case var
          when (0..255) then
            "STRING";Fi[	@ûiI"             case var
            when nil, (0..1073741823) then
              super(var)
            else
              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then
            case var
            when nil, (0..1073741823) then
              super(var);Fi[@6.@7.@8.@9.I" ;Fi[[	@•iKI"©        if var then
          var = var.where(table[primary_key].gt(var)).to_a
        else
          raise("STRING")
        end
      end
    end
    
    private
    ;Fi[	@∫	i7I"˝          if respond_to?(:authenticatable_salt) and var = authenticatable_salt then
            var
          else
            raise("STRING")
          end
        end
      end
      
      def function(arglist)
        self.class.rememberable_options;Fi[	@iuI"ò        ohai("STRING")
        var.children.each { |arglist| puts("STRING") }
      else
        raise("STRING")
      end
    end
  end
  
  private
  ;Fi[@'@(@)I"var;FI"end;Fi[[	@,i-I"œ          when :stderr then
            var = $stderr
            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        
        def self.wrap(arglist);Fi[	@¡iJI"˘        when Twitter::List then
          var[:list_id] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      
      # Take an owner and merge it into the hash with the correct key;Fi[	@ƒiëI"F          var[[var, "STRING"].compact.join("STRING").to_sym] = var
        when Twitter::User then
          var[[var, "STRING"].compact.join("STRING").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      
      # Take a multiple users and merge them into the hash with the correct keys;Fi[@¡*I"execute("STRING");FI"rescue;FI"# do nothing;FI"end;Fi[[	@Åi I"ô      end
      
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      ;Fi[	@ÅiI"û      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      ;Fi[	@ÅiI"û      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      ;Fi[@'@(@)I"	else;FI""STRING";Fi[[	@2iI",            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          "STRING"
        end
      end;Fi[	@2i1I",            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          "STRING"
        end
      end;Fi[	@2ilI"Ê            image_task(var, var, :label => (var))
          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          "STRING"
        end
      end;Fi[@¡*I"!var = (var + var.iconv(var));FI""rescue Iconv::IllegalSequence;FI"var = (var + $!.success);FI"6var = ("STRING" + $!.failed[1, $!.failed.length]);Fi[[	@iI":        else
          var = Iconv.new("STRING", "STRING")
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@i>I"5        else
          var = Iconv.new("STRING", var)
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@i|I"5        else
          var = Iconv.new(var, "STRING")
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[@'@ø2@¿2@¡2I"end;Fi[[	@·iaI"ù    if user and user.blocks.where(:person_id => (person_id)).exists? then
      (errors[:base] << "STRING")
      false
    else
      true
    end
  end
end;Fi[	@‰iaI"¨  def function(arglist)
    if self.parent and self.parent.participants.include?(self.author).! then
      (errors[:base] << "STRING")
    else
      true
    end
  end
end;Fi[	@æi I"`              if var.last then
                if [:attribute_nodes, :children].include?(var.first) then
                  var.last.empty?.!
                else
                  true
                end
              end
            end
            var.seplist(var) do |arglist|
              if [:attribute_nodes, :children].include?(var.first) then;Fi[@@@‹@‘I"var;Fi[[	@ˇiI"ã      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      ;Fi[	@ÑiÈI"¬      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[	@ÈiI"ø      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[@@@‹@‘I"
false;Fi[[	@Òi<I"    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end;Fi[	@¸iI"~    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@i4I"Á      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      ;Fi[@@@‹@‘I""STRING";Fi[[	@ÑiI"ê      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "STRING"
      end
      ;Fi[	@Hi;I"m  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "STRING"
  end
  ;Fi[	@ziI"•module Paperclip
  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      "STRING"
    end
    ;Fi[@'@T$@U$@V$I"end;Ti[[	@≥i)I"Ω        if (var - var).any? then
          ActiveSupport::Deprecation.warn("STRING")
          true
        else
          false
        end
      end
    end
    
    def function(arglist);Ti[	@ìi;I"¯          if @var.key?(var) then
            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      
      # Access a named variable. If the value of the variable responds_to? :call,;Fi[	I"'data//compass_proj/compass/util.rb;TiI"i      true
    when String, Array then
      var.length.zero?
    else
      false
    end
  end
end;Fi[@'I"var = "STRING";FI"8var = "STRING" unless var.to_s.index("STRING").nil?;FI"@var = (var + "STRING") unless var.to_s.index("STRING").nil?;FI"@var = var.to_s.index("STRING") ? ((var + "STRING")) : (var);Fi[[	@sigI"<        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end;Fi[	@vi\I"<        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end;Fi[	@yiVI"<        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end;Fi[@X3I"G32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) };FI"out((var + "STRING"));FI"out("STRING");FI"newobj;Fi[[	@si%I"X        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|;Fi[	@vi.I"X        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|;Fi[	@yiI"X        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|;Fi[@X3@TJ@UJ@VJI"end;Fi[[	@sihI"2        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1;Fi[	@vi]I"2        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1;Fi[	@yiWI"2        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1;Fi[@X3@CEI"	else;FI"var = "STRING";F@TJi[[	@sieI"S    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var);Fi[	@viZI"S    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var);Fi[	@yiTI"S    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var);Fi[@@I"	else;FI""STRING";FI"end;Fi[[	@2iI"ﬂ          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      ;Fi[	@2i2I"ﬂ          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      ;Fi[	@2imI"ª          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      ;Fi[@X3@Y3@Z3@TJ@UJi[[	@sifI"M      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end;Fi[	@vi[I"M      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end;Fi[	@yiUI"M      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end;Fi[@@I"var;FI"end;FI" ;Fi[[	@,i.I"–            var = $stderr
            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        
        def self.wrap(arglist)
          validate_pipe(var);Fi[	@¡iKI"·          var[:list_id] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      
      # Take an owner and merge it into the hash with the correct key
      #;Fi[	@ƒiíI"        when Twitter::User then
          var[[var, "STRING"].compact.join("STRING").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      
      # Take a multiple users and merge them into the hash with the correct keys
      #;Fi[@X3I"(var << "STRING");FI"(var << "STRING");FI"(var << "STRING");FI"](var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"));Fi[[	@2i≥I"∑          (var << view.content_tag(:div, "STRING".html_safe, var))
          if var[:bar_late_end] then
            var = ((var[:bar_late_end] - var[:bar_start]) - 2)
            var = "STRING"
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
            (var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"))
          end
          if var[:bar_progress_end] then;Fi[	@2i∆I"K        end
        if var[:markers] then
          if var[:start] then
            var = "STRING"
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
            (var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"))
          end
          if var[:end] then;Fi[	@2iÕI"Ç            (var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"))
          end
          if var[:end] then
            var = "STRING"
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
            (var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"))
          end
        end;Fi[@@Ò@Ú@ÛI"##;Fi[[	@›icI"        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##
        # Wrapper method for the #send_message (private) method
        def function(arglist);Fi[	@Èi
I"    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##
    # This is called as part of the procedure used to build the final
    # backup package file(s). It yields it's portion of the command line;Fi[	@ÏiI"ı      # * Called with super(model, storage_id) from each subclass
      def function(arglist)
        load_defaults!
        @var = var
        @var = var
      end
      
      ##
      # Performs the backup transfer
      def function(arglist);Fi[@@Ò@ÚI"end;FI" ;Fi[[	@¯/iAI"ú    
    def function(arglist)
      super("STRING")
      @var = var
      @var = var
    end
  end
  
  class ConfigurationError < ActiveRecordError
  end;Fi[	@¯/iZI"∂    
    def function(arglist)
      super(var)
      @var = var
      @var = var
    end
  end
  
  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors);Fi[	@OiI"Í        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      
      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError
        attr_reader(:errors);Fi[@X3I"
begin;F@J@J@Ji[[	@iI"          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "STRING")
        else
          var = Iconv.new("STRING", "STRING")
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry;Fi[	@i=I"z          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "STRING")
        else
          var = Iconv.new("STRING", var)
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry;Fi[	@i{I"z          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "STRING")
        else
          var = Iconv.new(var, "STRING")
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry;Fi[@.I"+var = Twitter::API::Arguments.new(var);FI"Eunless (var.options[:user_id] or var.options[:screen_name]) then;FI"7merge_user!(var.options, (var.pop or screen_name));FI"end;Fi[[	@]Hi∞I"‡      #   @example Return the specified user's profile banner
      #     Twitter.profile_banner('sferik')
      #     Twitter.profile_banner(7505382)  # Same as above
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::ProfileBanner, :get, "STRING", var.options)
      end;Fi[	@ƒiI"ä      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::User, var, var, var.options)
      end;Fi[	@ƒi_I"ã      # @param args [Array]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(var, var, var, var, var.options, var)
      end;Fi[@.@ƒJI"&merge_list!(var.options, var.pop);FI"Lunless (var.options[:owner_id] or var.options[:owner_screen_name]) then;FI"8merge_owner!(var.options, (var.pop or screen_name));Fi[[	@¡iHI"˚      #     Twitter.list_timeline('sferik', 8863586)
      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::Tweet, :get, "STRING", var.options);Fi[	@¡iI"±      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options);Fi[	@¡iI"≤        object_from_response(Twitter::List, var, var, var.options)
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var);Fi[@.I"9@var = Array(@var[:target_objects]).map do |arglist|;FI"%Twitter::Tweet.fetch_or_new(var);FI"end;FI"end;Fi[[	@‰=iI"6      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user;Fi[	I"/data//twitter_proj/twitter/action/reply.rb;TiI"=      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets;Fi[	@Á=iI"$      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user;Fi[@.I"Rvar.class.state_machines.transitions(var, action).perform { |arglist| yield };FI"end;FI" ;F@≠8i[[	@‰iDI"U      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@Ái=I"U      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@ÍiAI"U      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[@@l@m@ÙI"@var = nil;Fi[[	@oitI"ö      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
        @var = 4
      end;Fi[	@oi®I"∂      
      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@ri2I"ê      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[@.@ÌHI"end;FI" ;FI"6# Gets the db default for the machine's attribute;Fi[[	@‰iI"o      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then;Fi[	@ÁiI"+      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value;Fi[	@ÍiI")      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default;Fi[@.I"#if (action_hook == :save) then;FI"Gowner_class.set_callback(:save, :around, self, :prepend => (true));FI"	else;FI"
super;Fi[[	@‰i;I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@Ái4I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@Íi8I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[@.@KI"Jowner_class.set_callback(:save, :after, "STRING", :prepend => (true));FI"end;FI"
super;Fi[[	@»igI"T        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end;Fi[	@’iOI"L        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end;Fi[	@ÿiI"7        def function(arglist)
          define_helper(:instance, "STRING", "STRING", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end;Fi[@I"@var = nil;FI"end;FI" ;FI"def function(arglist);Fi[[	@˛iI"Œ      @var = var
      @var = []
      @var = var
      @var = var
      @var = nil
    end
    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "STRING";Fi[	@&iI"º      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil
      end
      
      def function(arglist)
        begin
          (trap_interrupt;Fi[	@wi$I"¿        @var = []
        @var = nil
        @var = false
        @var = var
        @var = nil
      end
      
      def function(arglist)
        var = clone
        var.expected_from = var;Fi[@I"reconnect_ssl;FI"end;FI" ;FI"##;Fi[[	@MiI"Ã  ##
  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.;Fi[	@MiI"'  # Overrides the default SSL certificate store used for verifying
  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Finishes all connections on the given +thread+ that were created before
  # the given +generation+ in the threads +generation_key+ list.;Fi[	@Mi„I"Ù  # Securely transfer the correct certificate and update the default
  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # SSL verification callback.
  def function(arglist);Fi[@.I"(@var.nil? ? ("STRING") : ("STRING");FI"end;FI" ;FI"def function(arglist);Fi[[	@¨iRI"⁄        end
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        caller.first(3).find { |arglist| var =~ /should_not/ }
      end;Fi[	@⁄i3I"        @var.nil? ? (true) : ((@var == var.method(var).arity))
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        (@var.length == 1) ? ("STRING") : (@var.inspect)
      end;Fi[	@Øi4I"∆      
      private
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end;Fi[@.I"var = max_value;FI"var = min_value;FI"var = (var - var);FI"-var = (var == 0) ? (10) : ((var / 20.0));Fi[[	@TiI"        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@WiI"      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@iiQI"        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[@.I"@var[:fields];FI"end;FI" ;FI"def function(arglist);Fi[[	@TiI"¨      
      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value;Fi[	@Wi$I"°        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        (var / -2.0)
      end;Fi[	@iiGI"“        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super
        var = (((@var[:fields][0].length / 2) * font_size) * 0.6);Fi[@ñ5I"Ñvar = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"));FI"end;FI"out((var + "STRING"));FI"out("STRING");Fi[[	@si/I"n            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end;Fi[	@vi8I"n            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end;Fi[	@yiI"n            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end;Fi[I"var = [];FI"5var = ((var % var) == 0) ? (var) : ((var + var));FI"2var.step(var, var) { |arglist| (var << var) };FI"return var;FI"end;Fi[[	@Ti!I"O        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@WiI"O        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@iiYI"O        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[I"when Proc then;FI"var.call;FI"	else;FI"var;FI"end;Fi[[	@(ijI"Ω      case var
      when Symbol then
        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end
  end;Fi[	@≥i©I"‚        var = case var
        when Symbol then
          send(var)
        when Proc then
          var.call
        else
          var
        end
        raise(TooManyRecords, "STRING") if var and (var.size > var)
      end;Fi[	@áiñI"ï      
      def function(arglist)
        case var
        when Proc then
          var.call
        else
          var
        end
      end
      ;Fi[@.I"out("STRING");F@Å?@Ç?@É?i[[	@si9I"¯    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING");Fi[	@viBI"¯    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING");Fi[	@yi(I"¯    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING");Fi[@.I"2AddCIDFont(var, "STRING", var, var, var, var);FI"?AddCIDFont(var, "STRING", (var + "STRING"), var, var, var);FI"?AddCIDFont(var, "STRING", (var + "STRING"), var, var, var);FI"?AddCIDFont(var, "STRING", (var + "STRING"), var, var, var);Fi[[	@siI"¬    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  ;Fi[	@viI"¬    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -120, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  ;Fi[	@yiI"¬    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  ;Fi[@.I"it("STRING") do |arglist|;FI"Eexpect((last_request.env["STRING"] or {})["STRING"]).to(eq(var));FI"end;FI"end;Fi[[	@›iI"ﬁ        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist);Fi[	@›iI"ﬁ        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist);Fi[	@›iI"…        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
    end
  end;Fi[@ê+I"3# Creates a new instance of the storage object;FI"def function(arglist);FI"super(var, var);FI"@var ||= "STRING";Fi[[	@ÊiI"/      #   :dropbox (full access)
      ##
      # Path to where the backups will be stored
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "STRING"
        @var ||= :app_folder
        instance_eval(&var) if block_given?;Fi[	@ÒiI"      # Ninefold Credentials
      ##
      # Ninefold directory path
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end;Fi[	@ÙiI"      # Amazon S3 bucket name and path
      ##
      # Region of the specified S3 bucket
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "STRING"
        instance_eval(&var) if block_given?
      end;Fi[@ê+@°K@¢K@£KI"@var ||= 22;Fi[[	@°iI"      # Path to store backups to
      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        @var ||= false;Fi[	@˜iI"      # Server IP Address and SCP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?;Fi[	@˙iI"      # Server IP Address and SFTP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?;Fi[@.@£HI"var;FI"end;FI" ;Fi[[	@iÿI"π        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@i›I"π        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@i‚I"≠        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted
      # reduce 42 omitted;Fi[@ê+@™;@◊@I" var = remote_path_for(@var);FI"connection do |arglist|;Fi[[	@Èi8I""        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[	@˜i,I"        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("STRING")
          files_to_transfer_for(@var) do |arglist|;Fi[	@˙i*I""        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[I"+#     include ActiveModel::Validations;FI"#;F@41I"&#     validates_presence_of :name;FI"#   end;Fi[[	@91iªI"”    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@91iÃI"‹    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@91iÛI"›    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[I"#       end;FI"#     end;FI"#   end;FI"#;FI"#   class VehicleObserver;Fi[[	@ÀiI""        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@Ài[I""        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@ÀiI"=        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|
        #       # log failure;Fi[@◊KI"#;FI"#       event :park do;FI",#         transition :idling => :parked;FI"#       end;Fi[[	@áiDI"    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@áivI"    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@f2i°I"    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end;Fi[@√-@…<I"end;FI" ;FI"L# Execute the cascading deletion for the relation if it already exists.;Fi[[	@IiI"m        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@PiI"m        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@ZiI"m        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[@.I"/var = Node.new(:CONDITIONAL_SELECTOR, var);FI"var;FI"end;FI" ;Fi[[	@ijI"æ        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      # reduce 13 omitted
      def function(arglist);Fi[	@ipI"Â      end
      
      # reduce 13 omitted
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var);Fi[	@iuI"        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [Node.new(:ELEMENT_NAME, ["STRING"]), Node.new(:COMBINATOR, var)]);Fi[@.I"Gsuper(compose_message("STRING", :name => (var), :config => (var)));FI"end;FI"end;FI"end;Fi[[	I"Idata//mongoid_proj/lib/mongoid/errors/mixed_session_configuration.rb;TiI"Ÿ      # @param [ Hash ] config The configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/errors/no_session_database.rb;TiI"ﬁ      # @param [ Hash ] config The hash configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/errors/no_session_hosts.rb;TiI"ﬁ      # @param [ Hash ] config The hash configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[@34@44@54I" ;FI"def function(arglist);Fi[[	@ÂiI"^        var = (CHECKS.keys - [:odd, :even])
        options.slice(*var).each do |arglist|
          next if (var.is_a?(Numeric) or (var.is_a?(Proc) or var.is_a?(Symbol)))
          raise(ArgumentError, "STRING")
        end
      end
      
      def function(arglist)
        var = :"#{var}STRING"
        var = var.send(var) if var.respond_to?(var);Fi[	@riPI"         when String then
          preload_one(var.to_sym)
        else
          raise(ArgumentError, "STRING")
        end
      end
      
      def function(arglist)
        var.each do |arglist|
          Preloader.new(records, var, preload_scope).run;Fi[	@Ïi˚I"ƒ        when Hash then
          var
        else
          raise(ArgumentError, "STRING")
        end
      end
      
      def function(arglist)
        (s3_protocol(var) == "STRING")
      end;Fi[@.I")super(compose_message("STRING", {}));FI"end;FI"end;FI"end;Fi[[	I":data//mongoid_proj/lib/mongoid/errors/invalid_find.rb;TiI"õ      #   InvalidFind.new
      #
      # @since 2.2.0
      def function(arglist)
        super(compose_message("STRING", {}))
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/errors/no_environment.rb;TiI"ù      #   NoEnvironment.new
      #
      # @since 2.4.0
      def function(arglist)
        super(compose_message("STRING", {}))
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/no_sessions_config.rb;TiI"†      #   NoSessionsConfig.new
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", {}))
      end
    end
  end
end;Fi[@≠4@Æ4@Ø4@∞4I" ;Fi[[	@Âi=I"›          begin
            Kernel.Float(var)
          rescue ArgumentError, TypeError
            nil
          end
        end
      end
      
      def function(arglist)
        var.to_i if var.to_s =~ /\A[+-]?\d+\Z/;Fi[	@ÅiI"            var = $1.split("STRING").map { |arglist| var.delete("STRING") }
            (var.length == 1) ? ([var.first, nil]) : (nil)
          else
            nil
          end
        end
      end
      
      # Returns just a table's primary key
      def function(arglist);Fi[	@W.irI"          if base.respond_to?(var, true) then
            raise(Thor::PrivateMethodEncodedError, "STRING")
          else
            nil
          end
        end
      end
      
      # Receives a hash of options and just execute the block if some
      # conditions are met.;Fi[@.I"3to_a.any? { |arglist| (var.to_s == "STRING") };FI"end;FI" ;FI"def function(arglist);Fi[[	@&i?I"Ã    (alpha? or (beta? or rc?))
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end;Fi[	@&iCI"‡    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end;Fi[	@&iGI"    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    return unless var.is_a?(Version)
    return 0 if head? and var.head?;Fi[@.I"'var = (HOMEBREW_PREFIX / "STRING");FI"var.write("STRING");FI"assert(var.universal?.!);FI"assert(var.i386?.!);Fi[[	@§0iäI"Ò    (HOMEBREW_PREFIX / "STRING").unlink
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@§0iöI"¯    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[	@§0i™I"¯    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[@.I"!var = Pathname.new("STRING");FI"assert(var.universal?);FI"assert(var.i386?.!);F@ù0i[[	@§0i
I"  `/usr/bin/file -h '#{var}STRING`.chomp
end
class MachOPathnameTests < Test::Unit::TestCase
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@§0i4I"    assert_match(/Mach-O 64-bit dynamically linked shared library/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@§0iBI"˝    assert_match(/Mach-O (64-bit )?executable/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[@SC@TC@UC@VCI"^#   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[[	@91i*I"      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@91idI"      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@Û0i*I"      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[@TC@UC@VC@[LI"L#   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[[	@91i+I"Ê      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@91ieI"Ê      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@Û0i+I"Ω      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[@UC@VC@[L@dLI"P#   method, proc or string should return or evaluate to a +true+ or +false+;Fi[[	@91i,I"π      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@91ifI"π      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@Û0i,I"π      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[I"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;F@[L@dL@mLI"#   value.;Fi[[	@91i-I"≠      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var);Fi[	@91igI"ã      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!;Fi[	@Û0i-I"¨      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var));Fi[@[L@dL@mLI"#   value.;FI"def function(arglist);Fi[[	@91i.I"h      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var)
      end;Fi[	@91ihI"Z      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!
        if var.key?(:on) then;Fi[	@Û0i.I"g      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var))
      end;Fi[I"(var << var);FI"end;FI"end;FI"end;FI"end;Fi[[	@~iI"¿          else
            if (var < var) then
              execute("STRING")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist);Fi[	@åi∑I"◊      def function(arglist)
        if self.class.current_feature then
          var = self.class.recipes_per_feature[self.class.current_feature] ||= []
          (var << var)
        end
      end
    end
  end
end;Fi[	@HiTI"-                    var = true
                  end
                else
                  (var << var)
                end
              end
            end
          end
          var = [var.strip, var.strip, var.strip]
          var.each { |arglist| smooth_offtags_without_code_highlighting(var) };Fi[@äL@ãL@åLI"(var << "STRING");FI"var.run;Fi[[	@UiLI"ˆ      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "STRING")
      var.run
      if var.success? then
        Logger.message("STRING");Fi[	@]i>I"
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING");Fi[	@Di>I"
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING");Fi[@äLI"(var << var);FI"end;FI"end;FI"(var << "STRING");Fi[[	@UiKI"˙      (var << ("STRING" + "STRING"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "STRING")
      var.run
      if var.success? then;Fi[	@]i=I"        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then;Fi[	@Di=I"ˇ        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then;Fi[@.I"#describe_path(which("STRING"));FI"end;FI" ;FI"def function(arglist);Fi[[	@
iPI"     return ("STRING" + describe_path(MacOS::XQuartz.prefix))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end;Fi[	@
iTI"∞    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end;Fi[	@
iXI"ö    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    "STRING"
  end;Fi[@&I":#   #      #<Pet id: 2, name: "Spook", person_id: 1>,;TI"=#   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];TI"#;Ti[[	@-iLI"J      # Array#select.
      #
      #   person.pets.select { |pet| pet.name =~ /oo/ }
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name) { |pet| pet.name =~ /oo/ }
      #   # => [;Ti[	@-i£I"Ö      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #
      #   person.pets.last(2)
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   another_person_without.pets         # => []
      #   another_person_without.pets.last    # => nil;Ti[	@-i◊I"v      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #
      #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 3
      #   person.pets.count # => 3;Ti[@.I"*return image_url if (var == "STRING");FI"4if (var.nil? or var.match(/^https?:\/\//)) then;FI"super(var);FI"	else;Fi[[	@ÍilI"    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@ÍiuI"œ    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@Íi~I"œ    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[@.I"+self.author = Webfinger.new(var).fetch;FI"end;FI" ;FI"def function(arglist);Fi[[	@˜	i;I"„    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then
      return Notifications::CommentOnPost;Fi[	@◊i,I"ú    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end;Fi[	@‰i3I"≠    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid
  end;Fi[I"#   #    ];FI"#;TI"#   person.pets.delete_all;TI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[[	@-iBI"       #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-icI"       #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i|I"       #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@.I" self.author.diaspora_handle;FI"end;FI" ;FI"def function(arglist);Fi[[	@˜	i7I"  after_destroy { |arglist| self.parent.update_comments_counter }
  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[	@◊i(I"∫    (self.participants - [self.author])
  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[	@‰i/I"«  
  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[@.@Ï*I"	self;FI"end;FI" ;Fi[[	@RiI"î      var
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      (@var << "STRING");Fi[	@Ri I"ò      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      label_field(var, var);Fi[	@RiAI"ñ      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      return self if @var;Fi[@F4I"end;FI" ;FI"private;FI" ;Fi[[	@∂i2I"Õ    def function(arglist)
      @var = columns.dup
      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist)
      @var ||= (var = @var.map { |arglist| var.dup.freeze };Fi[	@MimI"∞      def function(arglist)
        @var = var
        yield
        @var = nil
      end
      
      private
      
      def function(arglist)
        (@var.failed? or @var);Fi[	@CiÅI"ñ      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist)
        if @var then;Fi[@F4@MI"end;FI"end;FI"end;Fi[[	@xirI"¨        #   Project.primary_key # => "foo_id"
        def function(arglist)
          @var = (var and var.to_s)
          @var = nil
        end
      end
    end
  end
end;Fi[	@iiI"´        # (temporary file containing the password)
        def function(arglist)
          @var.delete if @var
          @var = nil
        end
      end
    end
  end
end;Fi[	@'i1I"ì      def function(arglist)
        var = @var
        @var.each { |arglist| var.end_scenario(var) }
        @var = nil
      end
    end
  end
end;Fi[@F4@M@MI" ;FI"def function(arglist);Fi[[	@ÍitI"ˆ          yield if block_given?
          return @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      source(Source::Path.new(_normalize_hash(var).merge("STRING" => (Pathname.new(var)))), var, &var)
    end;Fi[	@ä	i8I"ª        yield
        @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      @var = Framework.new(var, *var)
      if var = ALL.index(self[var]) then;Fi[	@ûiI"Ô          if @var then
            @var.puts(@var.description.gsub(/ \(druby.*\)/, "STRING"))
            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end;Fi[@5,I"@var = nil;FI"end;FI"end;FI" ;Fi[[	@ÍisI":          var[:prepend] ? (@var = [@var].|(@var)) : (@var = @var.|([@var]))
          yield if block_given?
          return @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      source(Source::Path.new(_normalize_hash(var).merge("STRING" => (Pathname.new(var)))), var, &var);Fi[	@ä	i7I"¶        (@var = nil
        yield
        @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      @var = Framework.new(var, *var);Fi[	@ç	ixI"‹        begin
          (@var = var
          yield)
        ensure
          @var = nil
        end
      end
      
      # parses a manifest file which is a ruby script
      # evaluated in a Manifest instance context;Fi[@.I"ávar.to_s.gsub(/::/, "STRING").gsub(/([A-Z]+)([A-Z][a-z])/, "STRING").gsub(/([a-z\d])([A-Z])/, "STRING").tr("STRING", "STRING").downcase;FI"end;FI"end;FI"end;Fi[[	I"0data//cucumber_prok/cucumber/constantize.rb;TiI"Ë    end
    
    # Snagged from active_support
    def function(arglist)
      var.to_s.gsub(/::/, "STRING").gsub(/([A-Z]+)([A-Z][a-z])/, "STRING").gsub(/([a-z\d])([A-Z])/, "STRING").tr("STRING", "STRING").downcase
    end
  end
end;Fi[	@4iI"Û      private
      
      # Props to Rails
      def function(arglist)
        var.to_s.gsub(/::/, "STRING").gsub(/([A-Z]+)([A-Z][a-z])/, "STRING").gsub(/([a-z\d])([A-Z])/, "STRING").tr("STRING", "STRING").downcase
      end
    end
  end
end;Fi[	I"#data//haml_proj/haml/buffer.rb;Ti“I"i    # Changes a word from camel case to underscores.
    # Based on the method of the same name in Rails' Inflector,
    # but copied here so it'll run properly without Rails.
    def function(arglist)
      var.to_s.gsub(/::/, "STRING").gsub(/([A-Z]+)([A-Z][a-z])/, "STRING").gsub(/([a-z\d])([A-Z])/, "STRING").tr("STRING", "STRING").downcase
    end
  end
end;Fi[I"@var[var] = var;FI"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@wi	I"      def function(arglist)
        var = ColumnDefinition.new(var, var, var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        var = columns.detect { |arglist| (var.type == :primary_key) }
        var and var.name;Fi[	@Li%I"Œ              @var = var
            end
          end
          @var[var] = var
          var
        end
        
        def function(arglist)
          if var = @var[var] then
            var = var.prev;Fi[	@OiNI"        var = constantize("STRING")
        var = var.new(@var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        log.debug("STRING")
        var.each { |arglist| load_file(var) };Fi[@.I"broadcast(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@UiI"Ê        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@Ui&I"Ã        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@UikI"Ã        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[@.I"@var.accept_hook?(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@iCI"“        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init
        var = @var.index(var);Fi[	@ i!I"ß        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags
      end;Fi[	@ iÉI"π          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end;Fi[@≠"@Æ"I" ;FI"def function(arglist);FI"@var = false;Fi[[	@li5I"ì      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@liWI"ù      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@ui:I"ù      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[@RB@mBI"var = @var["STRING"];F@≈D@–?i[[	@siYI"Ò  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length;Fi[	@viNI"Ò  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length;Fi[	@yiHI"Ò  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length;Fi[@.I"(@var == "STRING");FI"end;FI" ;FI"def function(arglist);Fi[[	@úiyI"             @var = var
          end
          
          def function(arglist)
            (@var == "STRING")
          end
          
          def function(arglist)
            "STRING"
          end;Fi[	@”iWI"¨    super(var, "STRING")
  end
  
  def function(arglist)
    (@var == "STRING")
  end
  
  def function(arglist)
    @var ||= GitHub.issues_for_formula(formula.name)
  end;Fi[	@&i7I"í  
  attr_reader :function
  
  def function(arglist)
    (@var == "STRING")
  end
  
  def function(arglist)
    (alpha? or (beta? or rc?))
  end;Fi[@RB@mBI"if (var > 0) then;FI"@var = 0;FI"out("STRING");Fi[[	@ÅiI"¬  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("STRING")
      end
      self.AddPage(@var);Fi[	@i÷I"    var = @var
    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("STRING")
        end
        AddPage(@var);Fi[	@iWI"˙    var = @var
    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("STRING")
        end
        AddPage(@var);Fi[@RB@lM@≈D@–?@—?i[[	@siZI"-  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING");Fi[	@viOI"-  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING");Fi[	@yiII"-  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING");Fi[@.I"	name;FI"end;FI" ;FI"def function(arglist);Fi[[	@ö%iI"ï  
  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var
    when Post then;Fi[	@˙Ei%I"∂    @@var
  end
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[	@˝EiI"ﬂclass Category < ActiveRecord::Base
  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[@.I"(@var or @var);FI"end;FI" ;FI"def function(arglist);Fi[[	@/i√I"∏        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        options["STRING"]
      end;Fi[	@ iáI"¿          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end;Fi[	@@iI"ä    class GherkinBuilder
      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("STRING")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, [])
        @var.gherkin_statement(var);Fi[I"	@var;FI"end;FI"end;FI"end;FI"end;Fi[[	@‡iWI"…        [:token, :user, :message, :title, :priority, :device].each do |arglist|
          @var.merge!(var => (self.instance_variable_get("STRING")))
        end
        @var
      end
    end
  end
end;Fi[	@c	i~I"t            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end
end;Fi[	@åi[I"&        var.select { |arglist| ["STRING", "STRING"].include?(var.field_format) }.each do |arglist|
          @var["STRING"] = { :sql => "STRING", :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[@.I"var = case var;F@å>I""STRING";FI"when :warning then;Fi[[	@›i/I"F      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then;Fi[	@›i-I"F      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then;Fi[	@„i+I"F      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then;Fi[@.I"Logger.message("STRING");FI"end;FI"end;FI"end;Fi[[	@øi.I"’      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database
      def function(arglist)
        Logger.message("STRING")
      end
    end
  end
end;Fi[	@ÀiI"◊      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive
      def function(arglist)
        Logger.message("STRING")
      end
    end
  end
end;Fi[	@fiMI"‹      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process
      def function(arglist)
        Logger.message("STRING")
      end
    end
  end
end;Fi[@.I"binding;FI"end;FI"end;FI"end;Fi[[	I"'data//backup_proj/backup/binder.rb;TiI"ù    
    ##
    # Returns the binding (needs a wrapper method because #binding is a private method)
    def function(arglist)
      binding
    end
  end
end;Fi[	@ç	iÑI"i        end
      end
      
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	I":data//compass_proj/compass/sprite_importer/binding.rb;Ti	I"Ümodule Compass
  module Sprites
    class Binding < OpenStruct
      def function(arglist)
        binding
      end
    end
  end
end;Fi[I"@var = [];FI"end;FI" ;F@II"@var = var;Fi[[	@ûiEI"”    class BeComparedTo < Be
      def function(arglist)
        @var, @var = var, var
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.__send__(@var, @var)
      end;Fi[	@⁄iI"      def function(arglist)
        @var = var
        @var = nil
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.each do |arglist|
          (@var << var) unless var.respond_to?(var) and matches_arity?(var, var);Fi[	@õiI"§          else
            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        ;Fi[@.I"Thread.current["STRING"];FI"end;FI" ;FI"def function(arglist);Fi[[	I"Adata//activerecord_proj/active_record/connection_handling.rb;Ti8I"≥      retrieve_connection
    end
    
    def function(arglist)
      Thread.current["STRING"]
    end
    
    def function(arglist)
      Thread.current["STRING"] = var
    end;Fi[	@∆ixI"À          end
        end
        
        def function(arglist)
          Thread.current["STRING"]
        end
        
        def function(arglist)
          Thread.current["STRING"] = var
        end;Fi[	I"5data//activerecord_proj/active_record/scoping.rb;TiI"∆    
    module ClassMethods
      #:nodoc:
      def function(arglist)
        Thread.current["STRING"]
      end
      
      def function(arglist)
        Thread.current["STRING"] = var
      end;Fi[@.I"var = 0;FI"var = @var["STRING"];FI"var = var.length;FI"var = 0;Fi[[	@si>I"»    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@vi.I"»    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@yi-I"»    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[@.@6I"@var = var;FI"end;FI"end;Fi[[	@¯/i-I"›  class WrappedDatabaseException < StatementInvalid
    attr_reader(:original_exception)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class RecordNotUnique < WrappedDatabaseException;Fi[	I""data//haml_proj/haml/error.rb;TiI"◊    # @return [Fixnum]
    # @param message [String] The error message
    # @param line [Fixnum] See \{#line}
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class SyntaxError < Error;Fi[	@”i2I"Ω  class InstallationError < RuntimeError
    attr(:formula)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
end
class CannotInstallFormulaError < RuntimeError;Fi[@.@e(@f(@g(I"end;Fi[[	@‚iI"Q      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[	@Üi©I"ì      # @return [ Object ] The serialized default.
      #
      # @since 3.0.0
      def function(arglist)
        var
      end
    end
  end
end;Fi[	I"Cdata//paperclip_proj/paperclip/io_adapters/identity_adapter.rb;TiI"Âmodule Paperclip
  class IdentityAdapter < AbstractAdapter
    def function(arglist)
      var
    end
  end
end
Paperclip.io_adapters.register(Paperclip::IdentityAdapter.new) do |arglist|
  Paperclip.io_adapters.registered?(var);Fi[@.I"@var.clear;FI"end;FI" ;FI"def function(arglist);Fi[[	@ÇiæI"ö        "STRING"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@Çi¬I"ú        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@Çi∆I"§        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var
          self;Fi[@.@ @I"var = @var;F@lM@≈Di[[	@siXI"‰    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING");Fi[	@viMI"‰    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING");Fi[	@yiGI"‰    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING");Fi[@.@k3I"end;FI" ;FI"def function(arglist);Fi[[	@Ëi6I"Œ      end
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist)
      var = "STRING"
      model.class_attribute(var.to_sym) unless model.method_defined?(var);Fi[	@Òi+I"Ç      false
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist)
      {}
    end;Fi[	@˛i=I"Ÿ      (super or @var.respond_to?(*var))
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end;Fi[@.@ã@å@º6I" ;Fi[[	@˙iqI"¶        false
      end
      
      def function(arglist)
        true
      end
    end
    
    class RealTransaction < OpenTransaction
      def function(arglist);Fi[	@ixI"ç  end
  
  class HiddenTask < Task
    def function(arglist)
      true
    end
  end
  
  class DynamicTask < Task
    def function(arglist);Fi[	@7iI"ˆ    module Adapters
      class FilesystemAdapter < AbstractAdapter
        class << self
          def function(arglist)
            true
          end
        end
        
        def function(arglist)
          @var = with_trailling_slash(var);Fi[@.@˜?I" @var = file_name.underscore;FI" @var = plugin_name.titleize;FI"@var = "STRING";Fi[[	@X"i
I"√  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING"
  end
  ;Fi[	I"cdata//redmine_proj/generators/redmine_plugin_controller/redmine_plugin_controller_generator.rb;TiI"ﬂ  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING"
    @var = controller.camelize
  end;Fi[	I"Ydata//redmine_proj/generators/redmine_plugin_model/redmine_plugin_model_generator.rb;TiI"Ì  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING"
    @var = model.camelize
    @var = @var.tableize;Fi[@.@˜?I"@var = [];FI"end;FI" ;Fi[[	@@i$I"Â        replace(klass.find(var).index_by { |arglist| var.id }.values_at(*var))
      end
      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist)
        if block_given? then;Fi[	@ßiI"€      class NestedTextFormatter < BaseTextFormatter
        INDENT = "STRING"
        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super;Fi[	@≠i
I"Î  module Runner
    module Formatter
      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          @var.puts("STRING");Fi[@.@˜?I"@var = false;FI"end;FI" ;Fi[[	@À5iI"ù        self.target = var
      end
      
      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function
      ;Fi[	I"<data//activerecord_proj/active_record/log_subscriber.rb;TiI"à      var
    end
    
    def function(arglist)
      super
      @var = false
    end
    
    def function(arglist)
      if var then;Fi[	@Ìi’I"Ÿ    end
    
    # Resets callback tracking
    def function(arglist)
      super
      @var = false
    end
    
    # Resets the event attribute so it can be re-evaluated if attempted again
    def function(arglist);Fi[@.@Ÿ(@JI"rescue;FI"# do nothing;Fi[[	@ÅiˇI"≠        @var.affected_rows
      end
      
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end;Fi[	@ÅiI"°      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end;Fi[	@ÅiI"°      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end;Fi[@.@bI"super("STRING");FI"end;FI"end;Fi[[	@kiI"µmodule Devise
  module OmniAuth
    class StrategyNotFound < NameError
      def function(arglist)
        @var = var
        super("STRING")
      end
    end
    
    class Config;Fi[	@”iI"Øclass MultipleVersionsInstalledError < RuntimeError
  attr(:name)
  
  def function(arglist)
    @var = var
    super("STRING")
  end
end
class NotAKegError < RuntimeError
end;Fi[	@”iI"¥class NoSuchKegError < RuntimeError
  attr(:name)
  
  def function(arglist)
    @var = var
    super("STRING")
  end
end
class FormulaUnavailableError < RuntimeError
  attr(:name);Fi[@¬I"when (5..8) then;FI""STRING";FI"	else;FI"'raise(ActiveRecordError, "STRING");Fi[[	@ÅiÂI"ı          when 3 then
            "STRING"
          when nil, 4, 11 then
            "STRING"
          when (5..8) then
            "STRING"
          else
            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then;Fi[	@ûi.I"            when 1, 2 then
              "STRING"
            when 3, 4 then
              "STRING"
            when (5..8) then
              "STRING"
            else
              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then;Fi[	@ûi@I"            return "STRING" unless var
            case var
            when (1..4) then
              "STRING"
            when (5..8) then
              "STRING"
            else
              raise(ActiveRecordError, "STRING")
            end
          else;Fi[@.@b@cI"end;FI" ;Fi[[	@˙i
I"«    class Transaction
      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    
    class ClosedTransaction < Transaction
      def function(arglist);Fi[	@¯/ibI"⁄  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  
  class UnknownPrimaryKey < ActiveRecordError
    attr_reader(:model);Fi[	@*iI"Î        
        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      
      # Remembers the given resource by setting up a cookie
      def function(arglist);Fi[@.@b@c@dI"private;Fi[[	@ÌiBI"~      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist);Fi[	@i'I"
    # Because Rubyforge cannot be trusted to provide valid specifications
    # once the remote gem is downloaded, the backend specification will
    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist);Fi[	@X,i!I"∫    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    
    # Gets the default Mongoid logger - stdout.;Fi[@¬@ªMI""STRING";FI"when :failure then;FI""STRING";Fi[[	@›i2I"‡      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing;Fi[	@›i0I"‡      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing;Fi[	@„i.I"‡      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing;Fi[@¬@úNI""STRING";FI"	else;FI"# do nothing;Fi[[	@›i4I"ÿ        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var);Fi[	@›i2I"ÿ        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var);Fi[	@„i0I"ÿ        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var);Fi[@“&@”&I"A# @param [ Array ] args The names of the fields to validate.;FI"#;FI"# @since 2.4.0;Fi[[	@‡/iéI"I      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::FormatValidator, _merge_attributes(var));Fi[	@‡/iüI"=      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::LengthValidator, _merge_attributes(var));Fi[	@‡/i∞I"      #     field :title
      #
      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var));Fi[@ì@îI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];Ti[[	@-iøI"=      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@-i˜I"=      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@-i/I"_      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3));Ti[@“&@”&@í<I"#;FI"# @since 2.1.0;Fi[[	@èi2I"Ù      # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@èiQI"˜      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@èi™I"
        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin;Fi[@@1@1@»FI"#   person.pets;Ti[[	@-iêI"       # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-iI",      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-i I"<      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[@“&@”&I"-# @return [ Enumerator ] The enumerator.;FI"#;FI"# @since 3.0.0;Fi[[	@i"I"*      # @example Iterate over the results.
      #   map_reduce.each do |doc|
      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        block_given? ? (documents.each { |arglist| yield(var) }) : (to_enum);Fi[	@ iaI"ˇ      # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then;Fi[	@  iqI"ˇ      # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then;Fi[@'@(@)@I"def function(arglist);Ti[[	@-i·I"R      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.create(var, &var)
      end;Ti[	@-i~I"]      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var)
      end;Ti[	@-i≤I"m      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length
      end;Ti[@(@)I"#   #    ];TI"#;T@ﬂLi[[	@-i@I"t      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-iaI"t      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@-izI"t      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[@)I"#   #    ];TI"#;T@ﬂLI"#   # => [;Ti[[	@-iAI"õ      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-ibI"õ      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@-i{I"õ      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@W1@ÕKI"#   end;FI"#;FI"#   person = Person.new;Fi[[	@91iΩI"?    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false
    #   person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:["can't be blank"]}>;Fi[	@91iŒI"Ò    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.valid? # => false;Fi[	@91iıI"Ú    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.invalid? # => true;Fi[@ﬂLI"#   # => [;T@·LI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[[	@-iDI"c      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-ieI"c      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i~I"c      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[I"?#   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];TI"#;TI" #   person.pets.size # => 2;TI"#   person.pets;TI"#   # => [;Ti[[	@-iºI"Q      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-iÙI"Q      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@-i,I"R      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@OI"#   person.pets;TI"#   # => [;T@ºN@ΩNi[[	@-iæI"Q      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-iˆI"Q      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@-i.I"R      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[@C@C@CI"#   #    ];TI"#;Ti[[	@-iFI"s      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4")
      #   # => #<Pet id: 4, name: "Benny", person_id: 1>;Ti[	@-iaI"8      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [;Ti[	@-ihI"Q      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')])
      #;Ti[I"unless var.empty? then;FI"opoo("STRING");FI"puts("STRING");FI"puts("STRING");FI"puts(var);Fi[[	@&
i=I"       next if var.directory?
      var.include?(var.extname).!
    end
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end;Fi[	@&
iII"  def function(arglist)
    return unless f.bin.directory?
    var = f.bin.children.select { |arglist| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end;Fi[	@&
iUI"  def function(arglist)
    return unless f.sbin.directory?
    var = f.sbin.children.select { |arglist| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end;Fi[@>@21I"#;F@41@ÕKi[[	@91i∫I"    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@91iÀI"    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@91iÚI"    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[@I"# @note Undocumented;FI"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	I"3data//twitter_proj/twitter/api/undocumented.rb;TiI"à      include(Twitter::API::Utils)
      
      # Returns activity about me
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.;Fi[	@VOiMI"o      end
      
      # Returns activity summary for a Tweet
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.;Fi[	@VOi`I"ù      (alias :tweet_activity :status_activity)
      
      # Returns activity summary for Tweets
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.
      # @overload statuses_activity(*ids);Fi[@I"K# @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline;FI"<# @note This method can only return up to 3,200 Tweets.;FI"# @rate_limited Yes;FI",# @authentication Requires user context;Fi[[	@s9i'I"‰      (alias :mentions :mentions_timeline)
      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@s9i?I"≈      end
      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@s9iWI"Ô      (alias :retweeted_by :retweeted_by_user)
      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[@I"E# @see https://dev.twitter.com/docs/api/1.1/get/friendships/show;FI"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	@WHiŒI"˝      end
      
      # Returns detailed information about the relationship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship]
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;Fi[	@WHiÏI".      (alias :relationship :friendship)
      
      # Test for the existence of friendship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if user_a follows user_b, otherwise false.
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;Fi[	@WHiI"Ê      end
      
      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={});Fi[@@ÿ=@Ÿ=I"S@var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) };FI"end;Fi[[	@ﬁ=iI"^      attr_reader(:max_position, :min_position, :target_objects)
      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection containing the followed user;Fi[	@·=iI"S      attr_reader(:max_position, :min_position)
      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection of lists that were added to;Fi[	@‰=iI"B      attr_reader(:max_position, :min_position)
      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # The user who mentioned a user;Fi[@o&@p&I"var = (var + 1);F@=I"	else;Fi[[	@Åi[I"ﬁ        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == "STRING"[0]) then
          var = var;Fi[	@ÅixI"œ          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1)
        end;Fi[	@i{I"ª        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1)
      end;Fi[@o&I"while (var < var) do;FI"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);FI"if (var < 128) then;FI"/var = (var + var[var.chr]) if var[var.chr];Fi[[	@siBI"    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@vi2I"    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@yi1I"    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[@o&@˘MI"var = var.length;FI"var = 0;FI"while (var < var) do;Fi[[	@si?I"⁄  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@vi/I"⁄  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@yi.I"⁄  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[@@°FI"def function(arglist);FI"9@var = Array(@var[:target_objects]).map do |arglist|;F@‹Ji[[	@‰=iI"      end
      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[	@„Ji
I"6  module Action
    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[	@Á=i
I"%  module Action
    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[@I"#     property :id, Serial;FI"##     property :state, :String;FI"#;F@±=i[[	@ÀiI";        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@ÀiTI";        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@ÀixI";        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[@@ÂK@ÊKI"#       end;FI"#     end;Fi[[	@áiEI"%    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do;Fi[	@áiwI")    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do;Fi[	@f2i¢I"ﬂ    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end
    #   ;Fi[@@ã=I"'#     include DataMapper::Resource;FI"#;F@™Oi[[	@ÀiI"!        # information about the various configuration options available.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@ÀiQI"        # as the given requirements match the transition.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@ÀiuI"&        # be performed so long as the given requirements match the transition.
        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[@@ã=@W2I"!#       other_states :idling;FI"#     end;Fi[[	@´iI"æ    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@´i(I"ÿ    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@´iCI"∂    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[@@ã=@W2I"#       event :ignite do;FI",#         transition :parked => :idling;Fi[[	@ái?I"    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@áiqI"    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@Fi˚I"     # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[@I"!# Valid requirement options:;FI"N# * <tt>:from</tt> - One or more states being transitioned from.  If none;FI"E#   are specified, then this will be the object's current state.;FI"N# * <tt>:to</tt> - One or more states being transitioned to.  If none are;Fi[[	@÷6iI"$    
    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless;Fi[	@ÕiI"›    end
    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[	@Õi1I"‡    end
    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[@I"# == Example;FI"#;FI"#   class Vehicle;FI"/#     state_machine :initial => :parked do;Fi[[	@ái=I"z    # On the other hand, any <tt>:halt</tt> error that's thrown within an
    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@áioI"?    # a StateMachine::InvalidTransition exception will be raised.
    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@Fi˘I"6    
    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[I"C# +binds+ as the bind substitutes. +name+ is logged along with;FI"$# the executed +sql+ statement.;FI"def function(arglist);FI"exec_query(var, var, var);FI"end;Fi[[	@¿
iII"j      end
      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes delete +sql+ statement in the context of this connection using;Fi[	@¿
iPI"j      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes update +sql+ statement in the context of this connection using;Fi[	@¿
iWI"^      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Returns the last auto-generated ID from the affected table.;Fi[@ˆO@˜O@¯OI"end;FI" ;Fi[[	@¿
iJI"•      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@¿
iQI"•      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@¿
iXI"\      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Returns the last auto-generated ID from the affected table.
      #;Fi[@I"/#    it "should do small edition stuff" do;FI"#      ...;FI"#    end;FI"#  end;Fi[[	@`i1I"Ù      #
      #  describe SmallEdition do
      #    it_should_behave_like "All Editions"
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist)
        add_options(var);Fi[	@`iFI"      #
      #  describe SmallEdition do
      #    it_should_behave_like AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      #
      # And, for those of you who prefer to use something more like Ruby, you;Fi[	@`iQI"ı      #
      #  describe SmallEdition do
      #    include AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist)
        Spec.deprecate("STRING", "STRING");Fi[I"# == Examples;FI"#;FI"#   class Vehicle;F@W2@…Oi[[	@´iI"    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@´i'I"    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@´iBI"˜    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[@úJI"end;FI"end;FI"end;FI"end;Fi[[	@viI"ø      else
        options[:env].inject("STRING") do |arglist|
          var = var.to_s.gsub(/[ "]/) { |arglist| "STRING" }
          (var << "STRING")
        end
      end
    end
  end
end;Fi[	I"@data//compass_proj/compass/installers/manifest_installer.rb;Ti0I"ô          var = "STRING" if var.options[:condition]
          (var << (var + "STRING"))
        end
        (var << "STRING")
      end
    end
  end
end;Fi[	I"6data//diaspora_proj/helpers/markdownify_helper.rb;Ti&I"d        var
      else
        var.strip!
        (var << "STRING")
      end
    end
  end
end;Fi[@úJ@#PI"var;FI"end;FI" ;Fi[[	@˛i0I"      end
      dependencies.sort_by { |arglist| var.to_s }.each do |arglist|
        next if (var.type == :development)
        (var << "STRING")
      end
      var
    end
    
    def function(arglist)
      @var = source.specs.search(Gem::Dependency.new(name, version)).last;Fi[	@irI"Q      var = "STRING"
      unless (requirement == Gem::Requirement.default) then
        var = requirement.requirements.map { |arglist| "STRING" }.sort.reverse
        (var << "STRING")
      end
      var
    end
    
    unless allocate.respond_to?(:matches_spec?) then
      # Backport of performance enhancement added to Rubygems 1.4;Fi[	@ßi^I"          var = "STRING"
          if var then
            var = var.split(/\//)
            (var << "STRING")
          end
          var
        end
        
        # attempts to guess what type of revision we're working with
        def function(arglist);Fi[@úJI"var.run;FI"if var.success? then;F@Q=I"	else;Fi[[	@UiOI"Ú          (var << var)
        end
      end
      (var << "STRING")
      var.run
      if var.success? then
        Logger.message("STRING")
      else
        raise(Errors::Archive::PipelineError, ("STRING" + var.error_messages))
      end;Fi[	@]iAI"            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages))
        end;Fi[	@DiAI"            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages))
        end;Fi[@úJI"(var << "STRING");FI"(var << "STRING");F@üJI"end;Fi[[	@2i¥I"∑          if var[:bar_late_end] then
            var = ((var[:bar_late_end] - var[:bar_start]) - 2)
            var = "STRING"
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
            (var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"))
          end
          if var[:bar_progress_end] then
            var = ((var[:bar_progress_end] - var[:bar_start]) - 2);Fi[	@2i«I"Z        if var[:markers] then
          if var[:start] then
            var = "STRING"
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
            (var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"))
          end
          if var[:end] then
            var = "STRING";Fi[	@2iŒI"9          end
          if var[:end] then
            var = "STRING"
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
            (var << view.content_tag(:div, "STRING".html_safe, :style => (var), :class => "STRING"))
          end
        end
        if var[:label] then;Fi[@úJI"	else;FI"(var << "STRING");FI"(var << "STRING");FI"end;Fi[[	@Øi*I"H            (var << "STRING")
            (var << "STRING")
            if (false == variable(:git_submodules_recursive)) then
              (var << "STRING")
            else
              (var << "STRING")
              (var << "STRING")
            end
          end
          var.compact.join("STRING").gsub(/\s+/, "STRING");Fi[	@ØiII")            (var << "STRING")
            (var << "STRING")
            if (false == variable(:git_submodules_recursive)) then
              (var << "STRING")
            else
              (var << "STRING")
              (var << "STRING")
            end
          end
          (var << "STRING");Fi[	@ˇiII"˝          if f.plist_startup then
            (var << "STRING")
            (var << "STRING")
            (var << "STRING")
          else
            (var << "STRING")
            (var << "STRING")
          end
        else
          (var << "STRING");Fi[@@±NI"#;FI"# @since 2.4.0;FI"def function(arglist);Fi[[	@‡/ièI":      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::FormatValidator, _merge_attributes(var))
      end;Fi[	@‡/i†I".      #
      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::LengthValidator, _merge_attributes(var))
      end;Fi[	@‡/i±I"      #
      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end;Fi[@Y!I"rescue;FI"# do nothing;FI"end;FI"end;Fi[[	@ÅiI"´      
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@ÅiI"¶      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:;Fi[	@ÅiI"≥      #:nodoc:
      def function(arglist)
        begin
          execute("STRING")
        rescue
          # do nothing
        end
      end
      
      def function(arglist);Fi[@Y!I"var;FI"end;FI"end;FI"end;Fi[[	@àiI"Ó            if document[field] then
              var = document.send(field)
              (value > 0) ? (var.pop) : (var.shift)
              execute("STRING")
              var
            end
          end
        end
      end
    end;Fi[	@èiI"⁄            if document[field] then
              var = document.send(field)
              var.delete(value)
              execute("STRING")
              var
            end
          end
        end
      end
    end;Fi[	@ñiI"¯            if document[field] then
              var = document.send(field)
              var.delete_if { |arglist| value.include?(var) }
              execute("STRING")
              var
            end
          end
        end
      end
    end;Fi[@Ÿ%I"end;FI"end;FI"var;FI"end;Fi[[	@iÚI"ﬁ            var = ["STRING", "STRING", "STRING", "STRING"]
            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      
      def function(arglist);Fi[	@iI"¢          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8(arglist);Fi[	@iGI"≠          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8_by_setting(arglist);Fi[@Ÿ%@⁄%I"var = (var + 1);F@}3I"	next;Fi[[	@sizI"ı        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[	@vioI"˚        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then;Fi[	@yiiI"ı        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[@Ÿ%@⁄%@çP@}3I"	else;Fi[[	@siéI"¸          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@viàI"          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@yi}I"¸          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[@@í<I"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	@èi3I"¯      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING");Fi[	@èiRI"˙      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING");Fi[	@èi´I"        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("STRING");Fi[@I"0# @return [ Hash ] The reloaded attributes.;FI"#;FI"# @since 2.3.2;FI"def function(arglist);Fi[[	@õi)I"˘    #
    # @example Reload the document.
    #   document._reload
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      embedded? ? (reload_embedded_document) : (reload_root_document)
    end;Fi[	@õi5I"    #
    # @example Reload the document.
    #   document.reload_root_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      {}.merge((with(:consistency => :strong).collection.find(:_id => (id)).one or {}))
    end;Fi[	@õiAI"=    #
    # @example Reload the document.
    #   document.reload_embedded_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      extract_embedded_attributes({}.merge(_root.with(:consistency => :strong).collection.find(:_id => (_root.id)).one))
    end;Fi[@I"#   class Game;FI"$#     include Mongoid::Document;FI"#     belongs_to :person;FI"#   end;Fi[[	@ri|I"¯        # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person;Fi[	@riïI"        #     include Mongoid::Document
        #     has_many :posts
        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.;Fi[	@ri I"¯        # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person;Fi[@:I"	else;F@°II"end;FI"end;Fi[[	@ÍioI"ﬂ  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@ÍixI"ﬂ  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@Íi|I"ﬂ  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[@I"+# @return [ Array<Hash> ] The inserts.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@miI"/        #   batchable.batch_insert([ doc_one, doc_two ])
        #
        # @param [ Array<Document> ] docs The docs to add.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          execute_batch_insert(var, "STRING")
        end;Fi[	@miEI"a        #   batchable.batch_replace([ doc_one, doc_two ])
        #
        # @param [ Array<Document> ] docs The docs to replace with.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          if var.blank? then
            base.add_atomic_unset(first) if _assigning? and empty?.!;Fi[	@mitI"N        #
        # @param [ Array<Document> ] docs The docs to persist.
        # @param [ String ] operation The atomic operation.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          self.inserts_valid = true
          var = pre_process_batch_insert(var);Fi[@I"N# @option options [ true, false ] :continue Continue binding the inverse.;FI"E# @option options [ true, false ] :binding Are we in build mode?;FI"#;FI"# @since 2.0.0.rc.1;Fi[[	@‡iI"≥          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata;Fi[	@ÈiI"ö          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base);Fi[	@Èi&I"∆          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) };Fi[@I"&# @return [ Proxy ] The relation.;FI"#;FI"# @since 2.0.0.rc.1;FI"def function(arglist);Fi[[	@⁄iI"ç      # @param [ Hash, Moped::BSON::ObjectId ] object The id or attributes to use.
      # @param [ Metadata ] metadata The relation's metadata.
      # @param [ true, false ] building If we are in a build operation.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = create_relation(var, var)
        set_relation(var, var);Fi[	@⁄i$I"N      #
      # @param [ Document, Array<Document ] object The relation target.
      # @param [ Metadata ] metadata The relation metadata.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = @var[var.inverse_type]
        var = var.builder(self, var).build(var);Fi[	@⁄iQI"$      #
      # @param [ String, Symbol ] name The name of the relation.
      # @param [ Proxy ] relation The relation to set.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        instance_variable_set("STRING", var)
      end;Fi[@+:@,:@-:I"end;FI"end;Fi[[	@iãI"º            Bundler.ui.info("STRING"))
          rescue ArgumentError => var
            $stderr.puts("STRING")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	@kiPI"ä        when Capistrano::Error then
          abort(var.message)
        else
          raise(var)
        end
      end
    end
  end
end;Fi[	I"Bdata//diaspora_proj/models/jobs/receive_unencrypted_salmon.rb;TiI"Ñ        var.perform!)
      rescue => var
        FEDERATION_LOGGER.info(var.message)
        raise(var)
      end
    end
  end
end;Fi[@+:@,:@-:@ÚPI" ;Fi[[	@i3I"&        if handle_no_method_error?(var, var, caller) then
          var.class.handle_no_task_error(name)
        else
          raise(var)
        end
      end
    end
    
    # Returns the formatted usage by injecting given required arguments
    # and required options into the given usage.;Fi[	@XiØI"˚            var.new(var, var, @var))
          rescue Exception => var
            (var.message << "STRING")
            raise(var)
          end
        end
      end
      
      class LogFormatter < ::Logger::Formatter
        def function(arglist);Fi[	@ciNI"ñ            STDERR.puts("STRING", "STRING")
            exit(1)
          end
          raise(var)
        end
      end
    end
    
    private
    ;Fi[I"super(var, var, var, var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@si®I"÷    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var);Fi[	@vi£I"ÿ    if (@var["STRING"] == "STRING") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var);Fi[	@yióI"÷    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["STRING"]
    var = ((@var - @var) - @var);Fi[@I".# @return [ Object ] The new array value.;FI"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	@àiI"
        #
        # @example Persist the new values.
        #   pop.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@èiI"        #
        # @example Persist the new values.
        #   pull.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@†iI"˜        #
        # @example Persist the new values.
        #   pushAll.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          append_with("STRING")
        end;Fi[@Y<I"var = (var + $!.success);FI"end;FI"var = var;FI"end;Fi[[	@iI"Ï            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@iDI"Ï            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@iÇI"Í            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end;Fi[@@Q@QI"# @since 2.0.0;FI"def function(arglist);Fi[[	@xiI"#        #
        # @example Persist the new values.
        #   addToSet.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            document[field] = [] unless document[field];Fi[	@ñiI"        #
        # @example Persist the new values.
        #   pull_all.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@ùiI"Ù        #
        # @example Persist the new values.
        #   push.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          append_with("STRING")
        end;Fi[@I"<# @raise [ Errors::InvalidIndex ] If validation failed.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@diI"x        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var)
          validate_options(var, var, var);Fi[	@di,I"Ä        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|
            unless VALID_OPTIONS.include?(var) then;Fi[	@diBI"ú        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!
          var.each_pair do |arglist|;Fi[@I":# @return [ Array<Document> ] The matching documents.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	I"9data//mongoid_proj/lib/mongoid/criterion/findable.rb;TizI"H      #   criteria.from_database(ids)
      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        ((var.size > 1) ? (any_in(:id => (var))) : (where(:id => (var.first)))).entries
      end;Fi[	@GQiÖI"&      #   criteria.from_identity_map(ids)
      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        var = []
        var = selector_with_type_selection;Fi[	I"3data//mongoid_proj/lib/mongoid/identity_map.rb;Ti3I"7    #
    # @param [ Class ] klass The class of the document.
    # @param [ Hash ] idenfier The selector.
    #
    # @return [ Array<Document> ] The matching documents.
    #
    # @since 3.0.0
    def function(arglist)
      documents_for(var)[var].try(:values) if Mongoid.using_identity_map? and var
    end;Fi[@I".# @param [ Class ] klass The model class.;FI"4# @param [ Hash ] spec The index specification.;FI"1# @param [ Hash ] options The index options.;FI"#;Fi[[	@diI"^        #
        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[	@di(I"c        #
        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[	@di>I"]        #
        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[@I"1# @return [ Array<Document> ] The documents.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@  i˝I"‡      #
      # @example Get the cached documents.
      #   context.documents
      #
      # @return [ Array<Document> ] The documents.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= []
      end;Fi[	@S,iVI"∆    #
    # @example Get the documents.
    #   criteria.documents
    #
    # @return [ Array<Document> ] The documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= []
    end;Fi[	@mi8I"Y        #
        # @param [ Array<Document> ] docs The documents.
        # @param [ Symbol ] method Delete or destroy.
        #
        # @return [ Array<Document> ] The documents.
        #
        # @since 3.0.0
        def function(arglist)
          var.each do |arglist|
            var.run_after_callbacks(:destroy) if (var == :destroy);Fi[@÷!I"var[2] = "STRING";FI"when "STRING" then;FI"var[2] = "STRING";FI"when "STRING" then;Fi[[	I"9data//redmine_proj/plugins/rfpdf/lib/core/rmagick.rb;TiI"È    var[0] = var.columns
    var[1] = var.rows
    case var.mime_type
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then;Fi[	@mQiI"È    case var.mime_type
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then;Fi[	@mQiI"‹      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    else;Fi[@@⁄NI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@i#I"	      #   map_reduce.each do |doc|
      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        block_given? ? (documents.each { |arglist| yield(var) }) : (to_enum)
      end;Fi[	@ ibI"3      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          (documents[(skipping or 0), (limiting or documents.length)] or []).each do |arglist|;Fi[	@  irI"ı      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          selecting do |arglist|;Fi[@|NI""STRING";FI"	else;F@NI"end;Fi[[	@ÅiÊI"Ú            "STRING"
          when nil, 4, 11 then
            "STRING"
          when (5..8) then
            "STRING"
          else
            raise(ActiveRecordError, "STRING")
          end
        when "STRING" then
          case var;Fi[	@ûi/I"              "STRING"
            when 3, 4 then
              "STRING"
            when (5..8) then
              "STRING"
            else
              raise(ActiveRecordError, "STRING")
            end
          when "STRING" then
            return super unless var;Fi[	@ûiAI"Ô            case var
            when (1..4) then
              "STRING"
            when (5..8) then
              "STRING"
            else
              raise(ActiveRecordError, "STRING")
            end
          else
            super;Fi[I"rescue LoadError => var;FI"(var.message << "STRING");FI"raise(var);FI"end;FI"end;Fi[[	@#i—I"Ÿ      def function(arglist)
        begin
          require("diff/lcs")
        rescue LoadError => var
          (var.message << "STRING")
          raise(var)
        end
      end
      
      def function(arglist);Fi[	@`iI"Ë          begin
          begin
            require("fog")
          rescue LoadError => var
            (var.message << "STRING")
            raise(var)
          end
          end
        end
        var.instance_eval do |arglist|;Fi[	@ÏiI"          begin
          begin
            require("aws-sdk")
          rescue LoadError => var
            (var.message << "STRING")
            raise(var)
          end
          end
        end
        if (AWS::VERSION >= "STRING") then;Fi[@I"5# @param [ String, Symbol ] name The config key.;FI"0# @param [ Hash ] config The configuration.;FI"#;FI"# @since 3.0.0;Fi[[	@	i&I"à        #
        # @example Validate the session has database.
        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionDatabase.new(var, var)) if no_database_or_uri?(var);Fi[	@	i5I"|        #
        # @example Validate the session has hosts.
        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionHosts.new(var, var)) if no_hosts_or_uri?(var);Fi[	@	iEI"W        #
        # @example Validate the uri and options.
        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          if both_uri_and_standard?(var) then;Fi[@I"# @since 2.0.0.rc.1;FI"def function(arglist);FI"@var ||= "STRING";FI"end;Fi[[	@] i*I"˚      #   metadata.foreign_key_setter
      #
      # @return [ String ] The foreign_key plus =.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var ||= "STRING"
      end
      
      # Returns the index option of the relation.;Fi[	@] i∫I"      #   metadata.setter # => "person="
      #
      # @return [ String ] The name plus "=".
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var ||= "STRING"
      end
      
      # Returns the name of the field in which to store the name of the class;Fi[	@] iEI"Ë      #   metadata.classify
      #
      # @return [ String ] The classified name.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var ||= "STRING"
      end
      
      # Get the name for the inverse field.;Fi[@ ;I"
false;FI"end;FI"end;FI"end;Fi[[	@RiãI"î        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@Ui~I"î        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@%+iVI"ì      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist);Fi[@I"# @since 2.3.0;FI"def function(arglist);FI"@var ||= {};FI"end;Fi[[	@‚i
I"◊    #   person.delayed_atomic_sets
    #
    # @return [ Hash ] The delayed $sets.
    #
    # @since 2.3.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get a hash of atomic pulls that are pending.;Fi[	I"5data//mongoid_proj/lib/mongoid/config/options.rb;TiI"‰      #   options.defaults
      #
      # @return [ Hash ] The default options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
      
      # Define a configuration option with a default.;Fi[	@√Qi6I"µ      #   options.settings
      #
      # @return [ Hash ] The setting options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
    end
  end;Fi[@„:@b;I"end;FI"end;FI"end;Fi[[	@?iáI"S              var[var].stop = var[(var - 1)].stop.plus(var[var].stop.minus(var[(var - 1)].stop).div(Sass::Script::Number.new(var)))
              break
            else
              var = (var + 1)
            end
          end
        end
      end
      var.each do |arglist|
        if var.stop.unitless? and (var.stop.value <= 1) then;Fi[	@TiAI"∂            make_datapoint_text((var + (var / 2.0)), (var - 6), var.to_s)
            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	@WiAI"ª            make_datapoint_text(((var + var) + 5), (var + var), var, "STRING")
            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[@I"K# @param [ Document ] document The document to generate the paths for.;FI"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	@ÎiI"O          #
          # @example Create the path util.
          #   Many.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent
            @var, @var = "STRING", "STRING";Fi[	@iI"N          #
          # @example Create the path util.
          #   One.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent
            @var, @var = "STRING", "STRING";Fi[	@¯iI"?        #
        # @example Create the root path util.
        #   Root.new(document)
        #
        # @param [ Document ] document The document to generate the paths for.
        #
        # @since 2.1.0
        def function(arglist)
          @var, @var, @var, @var = var, "STRING", "STRING", "STRING"
        end;Fi[@„:I"	else;F@tII"var = (var + 2);FI"end;Fi[[	@siGI"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000);Fi[	@vi;I"–      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end
    end;Fi[	@yi6I"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000);Fi[@„:@‰:@Â:@Ê:I"var = (var + 1);Fi[[	@sixI"      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@vimI"      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@yigI"      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[@I"# @since 2.2.0;FI"def function(arglist);FI"@var ||= {};FI"end;Fi[[	I"7data//mongoid_proj/lib/mongoid/atomic/modifiers.rb;Ti’I"Ù      #   modifiers.pull_fields
      #
      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be pushed.;Fi[	@˘Qi·I"Ò      #   modifiers.push_fields
      #
      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be set.;Fi[	@˘QiÌI"Ú      #   modifiers.set_fields
      #
      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the $pullAll operations or intialize a new one.;Fi[@@ÛQ@ÙQI"conflicts["STRING"] ||= {};FI"end;Fi[[	@˘Qi•I"      #   modifiers.conflicting_pulls
      #
      # @return [ Hash ] The conflicting pull operations.
      #
      # @since 2.2.0
      def function(arglist)
        conflicts["STRING"] ||= {}
      end
      
      # Get the conflicting push modifications.;Fi[	@˘Qi±I"      #   modifiers.conflicting_pushs
      #
      # @return [ Hash ] The conflicting push operations.
      #
      # @since 2.2.0
      def function(arglist)
        conflicts["STRING"] ||= {}
      end
      
      # Get the conflicting set modifications.;Fi[	@˘QiΩI"      #   modifiers.conflicting_sets
      #
      # @return [ Hash ] The conflicting set operations.
      #
      # @since 2.2.0
      def function(arglist)
        conflicts["STRING"] ||= {}
      end
      
      # Get the push operations that would have conflicted with the sets.;Fi[@@ƒ;@≈;I"
begin;FI"((Threaded.begin_execution("STRING");Fi[[	@èi5I"‰      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure;Fi[	@èiTI"‰      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure;Fi[	@èi≠I"¯        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("STRING")
            yield)
          ensure;Fi[@@Ò(@≤'I"
false;FI"end;Fi[[	@=iéI"æ      #   object.multi_arged?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Is the object a number?;Fi[	@=iöI"›      #   object.numeric?
      #
      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Remove the instance variable for the provided name.;Fi[	@=iπI"–      #   object.resizable?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Get the substitutable version of an object.;Fi[@ÍMI"end;FI" ;F@ÌMI"#Thread.current["STRING"] = var;Fi[[	@Mi9I"û    end
    
    def function(arglist)
      Thread.current["STRING"]
    end
    
    def function(arglist)
      Thread.current["STRING"] = var
    end
    ;Fi[	@∆iyI"∆        end
        
        def function(arglist)
          Thread.current["STRING"]
        end
        
        def function(arglist)
          Thread.current["STRING"] = var
        end
        ;Fi[	@ıMiI"…    module ClassMethods
      #:nodoc:
      def function(arglist)
        Thread.current["STRING"]
      end
      
      def function(arglist)
        Thread.current["STRING"] = var
      end
    end;Fi[I"var = case var;F@å>I""STRING";F@ªMI""STRING";Fi[[	@›i0I"      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING";Fi[	@›i.I"      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING";Fi[	@„i,I"      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING";Fi[@@Ò(@≤'I"6super(compose_message("STRING", :klass => (var)));FI"end;Fi[[	@õCiI"Á      #   NoMetadata.new(Address)
      #
      # @param [ Class ] klass The document class.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end;Fi[	@ûCiI"Û      #   NoParent.new(klass)
      #
      # @param [ Class ] klass The class of the embedded document.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end;Fi[	@°CiI"      #   VersioningNotOnRoot.new(Address)
      #
      # @param [ Class ] klass The embedded class.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end;Fi[I"var.save;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@‰iPI"(  def function(arglist)
    if var = ConversationVisibility.where(:conversation_id => (self.conversation_id), :person_id => (var.person.id)).first then
      var.unread += 1
      var.save
    end
  end
  
  def function(arglist)
    Notifications::PrivateMessage unless (var.person == var)
  end;Fi[	@üi}I"‹    var = Profile.where(:image_url => (url(:thumb_large)))
    var.each do |arglist|
      var.image_url = nil
      var.save
    end
  end
  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end;Fi[	I"Hdata//redmine_proj/plugins/acts_as_versioned/test/versioned_test.rb;TizI"    assert_equal(2, var.versions.size)
    assert_raises(ActiveRecord::StaleObjectError) do |arglist|
      var.title = "STRING"
      var.save
    end
  end
  
  def function(arglist)
    var = Page.create!(:title => "STRING")
    assert_equal(1, var.version);Fi[I"end.new;FI"assert(var.satisfied?);FI"end;FI" ;FI"def function(arglist);Fi[[	I"1data//homebrew_proj/test/test_requirement.rb;Ti(I",  def function(arglist)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (false)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (false)) { |arglist| false };Fi[	@SRi9I"    var = Class.new(Requirement) do |arglist|
      env(:userpaths)
      satisfy(:build_env => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    ENV.expects(:with_build_environment).yields.returns(true)
    ENV.expects(:userpaths!);Fi[	@SRiBI";    ENV.expects(:userpaths!)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (true), :userpaths => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) { |arglist| satisfy(true) }.new
    assert(var.satisfied?);Fi[@@Ò(@≤'I"translate("STRING", var);FI"end;Fi[[	I";data//mongoid_proj/lib/mongoid/errors/mongoid_error.rb;Ti2I"¯      # @param [ Hash ] attributes The attributes to interpolate.
      #
      # @return [ String ] The problem.
      #
      # @since 3.0.0
      def function(arglist)
        translate("STRING", var)
      end
      
      # Create the summary.;Fi[	@^RiAI"˚      # @param [ Hash ] attributes The attributes to interpolate.
      #
      # @return [ String ] The summary.
      #
      # @since 3.0.0
      def function(arglist)
        translate("STRING", var)
      end
      
      # Create the resolution.;Fi[	@^RiPI"Ê      # @param [ Hash ] attributes The attributes to interpolate.
      #
      # @return [ String ] The resolution.
      #
      # @since 3.0.0
      def function(arglist)
        translate("STRING", var)
      end
    end
  end;Fi[@@Ò(@≤'@LI"end;Fi[[	@LiI"      #
      # @param [ Symbol ] name The name of the session config.
      # @param [ Hash ] config The configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end;Fi[	@LiI"      #
      # @param [ Symbol, String ] name The db config key.
      # @param [ Hash ] config The hash configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end;Fi[	@LiI"      #
      # @param [ Symbol, String ] name The db config key.
      # @param [ Hash ] config The hash configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end;Fi[I"$stderr.puts("STRING");FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@æi1I"          $stderr.puts("STRING")
        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("STRING")
        end
      end
      
      def function(arglist)
        each_local_configuration { |arglist| create(var) }
      end;Fi[	@æiHI"#          class_for_adapter(var["STRING"]).new(*var).drop)
        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("STRING")
        end
      end
      
      def function(arglist)
        each_local_configuration { |arglist| drop(var) }
      end;Fi[	I"/data//compass_proj/compass/exec/helpers.rb;TiI"Ì      if var[:trace] then
        var.backtrace[(1..-1)].each { |arglist| $stderr.puts("STRING") }
      else
        $stderr.puts("STRING")
      end
    end
    
    def function(arglist)
      var.backtrace[0].split(/:/, 2)[0]
    end;Fi[@@Ò(@≤'I"@var.!.!;FI"end;Fi[[	@  i!I"Ó      #   context.cached?
      #
      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the number of documents matching the query.;Fi[	@  iÒI"Ë      #   context.cache_loaded?
      #
      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the documents for cached queries.;Fi[	@S,iqI"Ù    #   criteria.embedded?
    #
    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    
    # Extract a single id from the provided criteria. Could be in an $and;Fi[@@Ò(@≤'I""STRING";FI"end;Fi[[	@ixI"ˇ        #   aggregable.finalizer
        #
        # @return [ String ] The finalize JS function.
        #
        # @since 3.0.0
        def function(arglist)
          "STRING"
        end
        
        # Get the map function for the provided field.;Fi[	@iÉI"        # @param [ String, Symbol ] field The name of the field.
        #
        # @return [ String ] The map JS function.
        #
        # @since 3.0.0
        def function(arglist)
          "STRING"
        end
        
        # Get the reduce function for the provided field.;Fi[	@iëI"’        #   aggregable.reducer(:likes)
        #
        # @return [ String ] The reduce JS function.
        #
        # @since 3.0.0
        def function(arglist)
          "STRING"
        end
      end
    end;Fi[@@Ò(@≤'I"@var ||= {};FI"end;Fi[[	@‚i"I"Ë    #   document.delayed_atomic_unsets
    #
    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Flag the document as destroyed and return the atomic path.;Fi[	I"-data//mongoid_proj/lib/mongoid/config.rb;Ti’I"œ    #   config.sessions
    #
    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Set the session configuration options.;Fi[	I"9data//mongoid_proj/lib/mongoid/contextual/command.rb;TiI"       #   command.command
      #
      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the database session.;Fi[I"if @var.compressor then;FI"/@var.compressor.compress_with do |arglist|;FI"(var << var);FI"(var << var);FI"end;Fi[[	@UiII"ˇ      var = "STRING"
      var = Pipeline.new
      (var << ("STRING" + "STRING"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "STRING");Fi[	@]i;I"        var = Pipeline.new
        var = "STRING"
        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING");Fi[	@Di;I"        var = Pipeline.new
        var = "STRING"
        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING");Fi[@ùRI"(var << var);FI"(var << var);FI"end;FI"end;Fi[[	@UiJI"¯      var = Pipeline.new
      (var << ("STRING" + "STRING"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "STRING")
      var.run;Fi[	@]i<I"¸        var = "STRING"
        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run;Fi[	@Di<I"˘        var = "STRING"
        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run;Fi[@I"=# base - The String path to the dir containing the file.;FI".# name - The String filename of the file.;FI"#;FI"# Returns nothing.;Fi[[	@√iI"·    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin;Fi[	@ci!I"Î    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[	@†i?I"Î    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[@o=I"end;FI"end;FI" ;FI"def function(arglist);Fi[[	I"&data//homebrew_proj/cmd/bottle.rb;TiI"Ÿ      puts("STRING")
      puts("STRING") if (var > 0)
      puts("STRING")
      puts("STRING")
    end
  end
  
  def function(arglist)
    ARGV.formulae.each { |arglist| bottle_formula(Formula.factory(var)) }
  end;Fi[	@Oi;I"    unless MacOS.macports_or_fink.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
    end
  end
  
  def function(arglist)
    FileUtils.mkdir_p(HOMEBREW_CELLAR) if File.exist?(HOMEBREW_CELLAR).! rescue raise("STRING".undent)
  end;Fi[	@ø,i)I"‘      end)
    rescue MultipleVersionsInstalledError => var
      ofail(var)
      puts("STRING")
    end
  end
  
  def function(arglist)
    var = ((HOMEBREW_PREFIX / :opt) / var)
    var.unlink if var.symlink?;Fi[@o=@¡RI" ;FI"private;FI" ;Fi[[	@∂i“I"˘      # [Version]
      # Returns the current version of the Backup gem
      def function(arglist)
        puts("STRING")
      end
      
      private
      
      ##
      # Helper method for asking the user if he/she wants to overwrite the file;Fi[	@iRI"Ê      var.find_formula { |arglist| (var << var.basename.join(var)) }
      var = (var + link_tap_formula(var))
    end
    puts("STRING")
  end
  
  private
  
  def function(arglist)
    ARGV.first =~ /^(\S+)\/(homebrew-)?(\w+)$/;Fi[	@ ivI"Æ  end
  
  def function(arglist)
    puts("STRING")
  end
  
  private
  
  def function(arglist)
    $APP_CONFIG = OpenStruct.new(YAML.load_file(File.expand_path("STRING")));Fi[@o=@p=I"	puts;FI"puts("STRING");FI"puts("STRING");Fi[[	@∂i©I"Ê      def function(arglist)
        unless options.any? then
          puts
          puts("STRING")
          puts("STRING")
          puts
          puts("STRING")
          puts("STRING")
          puts
          puts("STRING");Fi[	@∂i¨I"Œ          puts("STRING")
          puts("STRING")
          puts
          puts("STRING")
          puts("STRING")
          puts
          puts("STRING")
          puts("STRING")
          exit
        end;Fi[	@i%I"Ã    curl("STRING", "STRING", "STRING") rescue puts
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts
      puts("STRING")
      puts("STRING")
      puts
  end;Fi[@o=@p=I"puts("STRING");FI"puts("STRING");FI"puts("STRING");Fi[[	@
iÑI"•  end
  
  def function(arglist)
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts(hardware)
    puts("STRING");Fi[	@
iíI"¥    puts("STRING")
    puts("STRING")
    puts("STRING") if macports_or_fink
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
    puts("STRING")
  end
  ;Fi[	@&
i,I"˝    var = f.lib.children.select { |arglist| var.to_s =~ /\.jar$/ }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true;Fi[@I"# @example;FI"#   class Person;FI"$#     include Mongoid::Document;FI"#     field :title;Fi[[	@‡/iáI"Ò      end
      
      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i;Fi[	@‡/iòI"Â      end
      
      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_length_of :title, minimum: 100;Fi[	@‡/i©I"¸      end
      
      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_presence_of :title;Fi[@I"# For example,;FI"#;FI"#   class Vehicle;F@å=i[[	@f2iiI"    # * <tt>human_state_event_name(event)</tt> - Gets the humanized value for
    #   the given event.  This may be generated by internationalization
    #   libraries if supported by the integration.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@f2iöI"p    #   specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@f2i’I"H    # automatically assigned when a new object is created.  However, this
    # behavior will *not* work if the class defines an +initialize+ method
    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end;Fi[@I"# ==== Parameters;FI"=# source<String>:: the relative path to the source root.;FI"G# destination<String>:: the relative path to the destination root.;F@CBi[[	@?i&I"ò    # <b>Encoded path note:</b> Since Thor internals use Object#respond_to? to check if it can
    # expand %something%, this `something` should be a public method in the class calling
    # #directory. If a method is private, Thor stack raises PrivateMethodEncodedError.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #                If :recursive => false, does not look for paths recursively.
    #                If :mode => :preserve, preserve the file mode from the source.;Fi[	@KBi)I"ö    
    # Links the file from the relative source to the relative destination. If
    # the destination is not given it's assumed to be equal to the source.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples;Fi[	@KBi_I"‹    # Gets an ERB template at the relative source, executes it and makes a copy
    # at the relative destination. If the destination is not given it's assumed
    # to be equal to the source removing .tt from the filename.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples;Fi[@@OI"#   person.pets;TI"#   # => [;T@ºNi[[	@-iΩI"Q      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-iıI"Q      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-i-I"R      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[I"var.join("STRING");FI"end;FI"end;FI"end;FI"end;Fi[[	@–iAI"∏        (var << "STRING") if @var
        (var << "STRING") if @var
        (var << (@var.to_s.empty? ? ("STRING") : ("STRING")))
        var.join("STRING")
      end
    end
  end
end;Fi[	@)i*I"î            var = "STRING" if (var == 2)
            (var << var)
          end
          var.join("STRING")
        end
      end
    end
  end
end;Fi[	@≥i<I"î            var = "STRING" if (var == 2)
            (var << var)
          end
          var.join("STRING")
        end
      end
    end
  end
end;Fi[@@ﬂLI"#   # => [;T@·L@Oi[[	@-iCI"ò      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-idI"ò      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@-i}I"ò      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@@W1@ÕKI"#   end;FI"#;Fi[[	@91iºI"ﬁ    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false;Fi[	@91iÕI"÷    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[	@91iÙI"÷    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[@@11I"#     has_many :pets;TI"#   end;TI"#;Ti[[	@-i≥I"`      # with +attributes+ and linked to this object, but have not yet been saved.
      # You can pass an array of attributes hashes, this will return an array
      # with the new objects.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.build
      #   # => #<Pet id: nil, name: nil, person_id: 1>;Ti[	@-iŒI"Ü      # Returns a new object of the collection type that has been instantiated with
      # attributes, linked to this object and that has already been saved (if it
      # passes the validations).
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.create(name: 'Fancy-Fancy')
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@-iÍI"Ú      end
      
      # Like +create+, except that if the record is invalid, raises an exception.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   class Pet
      #     validates :name, presence: true;Ti[I"
end));FI"end;FI"end;FI"end;FI" ;Fi[[	@ªihI"L      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display
  # it next to the avatar image in a nice box;Fi[	@–iBI"'      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist)
    session[:a_ids] = params[:a_ids] if params[:a_ids].present?;Fi[	@”i*I"‹      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  ;Fi[I"#extend(ActiveSupport::Concern);FI" ;FI"&def self.required_fields(arglist);FI"[];FI"end;Fi[[	@¸6i	I"ømodule Devise
  module Models
    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods;Fi[	@hiI"ømodule Devise
  module Models
    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods;Fi[	@ûi	I"Úmodule Devise
  module Models
    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      # Checks whether the user session has expired based on configured time.;Fi[@
@√A@ƒA@êHI"%# @return [Array<Twitter::User>];Fi[[	@¡i I"˜      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[	@ƒiI"      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[	@ƒiI"D          object_from_response(Twitter::User, var, var, merge_user(var.options, var))
        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[@
@ˆHI"def function(arglist);F@ËJI"end;Fi[[	@‰iBI"4          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@Ái;I"4          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@Íi?I"4          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[@
I"H# Uses around callbacks to run state events if using the :save hook;FI"def function(arglist);FI"#if (action_hook == :save) then;F@Ki[[	@‰i9I"c      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@Ái2I"U        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@Íi6I"d        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[@
@ÎH@ÏH@ÌHI"end;Fi[[	@‰iI"Í      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@ÁiI"Í      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@ÍiI"Í      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[@
I"Aattr_reader(:plugin_path, :plugin_name, :plugin_pretty_name);FI" ;FI"def function(arglist);FI"
super;Fi[[	@X"iI"class RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("STRING", "STRING"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[	@JNiI"   argument(:controller, :type => :string)
  
  argument(:actions, :type => :array, :default => ([]), :banner => "STRING")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[	@MNiI"9  class_option(:parent, :type => :string, :desc => "STRING")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "STRING")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[@
@<I" ;F@<I" ;Fi[[	@€iI"›      undef_method(:attributes)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[	@<iI"Ÿ      undef_method(:values)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[	@miI"Â      undef_method(:attribute_nodes)
      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[@
@ÚKI"I# This should be optimized in the future potentially not to load all;FI"# objects from the db.;FI"#;Fi[[	@IiI"l          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[	@PiI"m          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.
        #   strategy.cascade;Fi[	@ZiI"l          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[@
I"# Obtain destination path.;FI"#;FI"5# dest - The String path to the destination dir.;FI"#;Fi[[	@citI"0    def function(arglist)
      self.data.deep_merge("STRING" => (File.join(@var, self.url)), "STRING" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.
    def function(arglist);Fi[	@†i¿I"Q      var = { "STRING" => ({ "STRING" => (related_posts(var["STRING"]["STRING"])) }), "STRING" => (self.to_liquid) }.deep_merge(var)
      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.
    def function(arglist);Fi[	@» iI"Á    def function(arglist)
      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.
    def function(arglist);Fi[@
I"!# Read the YAML frontmatter.;FI"#;F@µR@∂Ri[[	@√iI"ˆ    def function(arglist)
      (self.content or "STRING")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@ciI"      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@†i=I"        self.categories = self.data.pluralized_array("STRING", "STRING")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[@
I"desc("STRING");FI" ;FI"
hide!;FI" ;Fi[[	@i.I"Ì      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      
      # Override copy_views to just copy mailer and shared.
      def function(arglist);Fi[	@iQI"—      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      
      def function(arglist)
        view_directory(:mailer);Fi[	@i_I"ﬂ      include(ViewPathTemplates)
      
      source_root(File.expand_path("STRING", "STRING"))
      
      desc("STRING")
      
      hide!
      
      def function(arglist)
        view_directory(:markerb, target_path);Fi[@
I"$attr_reader(:gherkin_statement);FI" ;FI"def function(arglist);FI"@var ||= var;Fi[[	@fiI"⁄      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@iI"      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@PiI"œ      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[@
I"I# Returns the command that will sync the given revision to the given;FI"L# destination directory. The perforce client has a fixed destination so;FI"K# the files must be copied from there to their intended resting place.;FI"def function(arglist);Fi[[	@∏iI"Ö        def function(arglist)
          "STRING"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@∏iI"ú        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@∏i!I"ú        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[@
I";# Increments the given revision number and returns it.;FI"def function(arglist);FI"(var.to_i + 1);FI"end;Fi[[	@§iAI"Ù          var = scm("STRING", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private;Fi[	@∏i8I"d          var = scm(authentication, :changes, "STRING", "STRING", "STRING")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[	@Ωi=I"a          raise("STRING") unless Hash.===(var)
          [(var["STRING"] or 0).to_i, (var["STRING"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[@å>I""STRING";F@ªMI""STRING";F@úNi[[	@›i1I"—      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else;Fi[	@›i/I"—      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else;Fi[	@„i-I"—      #
      def function(arglist)
        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else;Fi[@ªMI""STRING";F@úNI""STRING";FI"	else;Fi[[	@›i3I"–        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end;Fi[	@›i1I"–        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end;Fi[	@„i/I"–        var = case var
        when :success then
          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end;Fi[@úNI""STRING";FI"	else;FI"# do nothing;FI"end;Fi[[	@›i5I"◊          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var);Fi[	@›i3I"◊          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var);Fi[	@„i1I"◊          "STRING"
        when :warning then
          "STRING"
        when :failure then
          "STRING"
        else
          # do nothing
        end
        var = ("STRING" % var)
        send_message(var);Fi[I"if (var > 0) then;FI"@var = 0;FI"out("STRING");FI"end;FI"AddPage(@var);Fi[[	@iÿI"›      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("STRING")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[	@i)I"F      if ((var + ((var["STRING"] * var) / (@var * @var))) > @var) and (@var.! and AcceptPageBreak) then
        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("STRING")
          end
          AddPage(@var)
          if (var > 0) then
            @var = var;Fi[	@iYI"›      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("STRING")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[@°K@¢KI"super(var, var);FI"@var ||= 22;FI"@var ||= "STRING";Fi[[	@°iI"      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@˜iI"       ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING");Fi[	@˙iI"       ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "STRING"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING");Fi[@
I"def self.process(arglist);FI"gvar = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "STRING");FI" FileUtils.mkdir_p("STRING");FI"!var[QUERY].each do |arglist|;Fi[[	@”iI"*    end
    
    QUERY = "STRING"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |arglist|
        var = var[:title]
        var = var[:permalink];Fi[	@÷iI"Vmodule Jekyll
  module MT
    QUERY = "STRING"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |arglist|
        var = var[:entry_title]
        var = var[:entry_basename].gsub(/_/, "STRING");Fi[	@‹iI"@module Jekyll
  module TextPattern
    QUERY = "STRING"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |arglist|
        var = var[:Title]
        var = var[:url_title];Fi[@ì*@î*@ï*@ñ*I"var = [];Fi[[	@Êi]I"°      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |arglist| (var << ("STRING" + "STRING")) }
        Logger.message(var.join("STRING"));Fi[	@Ói&I"î      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |arglist| (var << "STRING") }
        Logger.message(var.join("STRING"));Fi[	@˜i;I"°      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) { |arglist| (var << ("STRING" + "STRING")) }
        Logger.message(var.join("STRING"));Fi[@
I"@var = nil;FI" ;FI"@var = nil;FI" ;Fi[[	@@iI"xclass Net::HTTP::Persistent::SSLReuse < Net::HTTP
  @var = false
  
  @var = nil
  
  @var = nil
  
  @var = nil
  ;Fi[	@@i	I"V  @var = false
  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  @var = nil
  ;Fi[	@@iI"f  @var = nil
  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  def function(arglist)
    super;Fi[@
I"attr_accessor(:source);FI" ;FI"def function(arglist);FI"@var = var;Fi[[	@ÌiI"Ã    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var;Fi[	@˛iI"À    include(MatchPlatform)
    
    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = [];Fi[	@iI"Ω    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var;Fi[@
I"1class_option(:timestamps, :type => :boolean);FI" ;FI"?class_option(:parent, :type => :string, :desc => "STRING");FI" ;Fi[[	I"Tdata//activerecord_proj/rails/generators/active_record/model/model_generator.rb;TiI";      check_class_collision
      
      class_option(:migration, :type => :boolean)
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "STRING")
      
      class_option(:indexes, :type => :boolean, :default => (true), :desc => "STRING")
      ;Fi[	I"Mdata//mongoid_proj/lib/rails/generators/mongoid/model/model_generator.rb;TiI"a      argument(:attributes, :type => :array, :default => ([]), :banner => "STRING")
      
      check_class_collision
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "STRING")
      
      class_option(:versioning, :type => :boolean, :default => (false), :desc => "STRING")
      ;Fi[	@MNiI"K  argument(:attributes, :type => :array, :default => ([]), :banner => "STRING")
  
  class_option(:migration, :type => :boolean)
  
  class_option(:timestamps, :type => :boolean)
  
  class_option(:parent, :type => :string, :desc => "STRING")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "STRING")
  ;Fi[@
I"#:nodoc:;FI"def function(arglist);F@b6I"
begin;Fi[[	@g6i"I"Â        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING")
            FileUtils.rm(var) if File.exist?(var));Fi[	@ÏiπI"      def function(arglist)
        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING")
            var = (@var[var] or @var[:default]);Fi[	@Ïi’I"Ú        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("STRING")
            s3_bucket.objects[var.sub(/^\//, "STRING")].delete);Fi[@Ÿ$@ÇA@€$@ÉAI"def function(arglist);Fi[[	@ﬁiöI"5    
    method_option("STRING", :type => :array, :lazy_default => ([]), :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    def function(arglist)
      begin
        (var = options.dup;Fi[	@ﬁiÂI"K    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    def function(arglist)
      var = Array(options[:source])
      Bundler.ui.be_quiet! if options[:quiet];Fi[	@ﬁigI"    
    desc("STRING", "STRING", :hide => (true))
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    method_option("STRING", :type => :boolean, :banner => "STRING")
    
    def function(arglist)
      begin
        (Bundler.definition.validate_ruby!;Fi[I"if (var == 0) then;FI"@var = var;F@èAI"	else;F@ëAi[[	@siõI"∂    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@viñI"∂    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@yiäI"∂    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[@
@++@™;@◊@@¡Ki[[	@Èi7I"          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[	@˜i+I"˚          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("STRING");Fi[	@˙i)I"          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[@HTI" ;F@JTI"@var = var;FI"@var = var;Fi[[	@ÌiI"¬    
    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@˛iI"¡    
    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = []
      @var = var;Fi[	@iI"≥    
    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[I"
break;FI"end;FI"end;FI"end;FI"end;Fi[[	@tifI"π          var = I18n.inflector.true_token(var, :gender, var)
          unless var.nil? then
            @var = var
            break
          end
        end
      end
    end
  end
  ;Fi[	@iLI"Ì                var = $1
                next if (var == "STRING") and var =~ /^(?!http)\w+:/
                (var << "STRING")
                break
              end
            end
          end
        end
        "STRING"
      else;Fi[	@≤
ihI"(            if (var == (var[var][(0...var)] + var[var][((var + 1)..-1)])) then
              var[var][var] += ("STRING" + var[var][var])
              var.delete_at(var)
              break
            end
          end
        end
      end
      var.map { |arglist| var.join("STRING") }
    end;Fi[I"var = (var - var);F@EKI"var = ((var + var) - var);FI",var = (scale_divisions or (var / 10.0));FI":var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[[	@TiI"p      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@WiI"p      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@iiTI"p      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[I"
true);FI"rescue LoadError;FI"
false;FI"end;FI"end;Fi[[	@RiäI"µ        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end;Fi[	@Ui}I"µ        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end;Fi[	@%+iUI"á    begin
      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end;Fi[I"if var["STRING"] then;FI"!if var["STRING"].nil?.! then;FI"9out((("STRING" + (var + var["STRING"])) + "STRING"));FI"	else;F@Ii[[	@siI"V          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end;Fi[	@vi!I"V          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end;Fi[	@yiI"V          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end;Fi[@S+I"	else;F@X@I"@var = var;F@èAi[[	@siôI"&    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@viîI"&    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@yiàI"&    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[@
@¬(@√(@Õ3I"4# Establishes a connection to the remote server;Fi[[	@Èi#I"—        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #
      # Note:;Fi[	@˜iI"%        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.
      # Net::SCP will use this connection to transfer backups;Fi[	@˙iI"4        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "STRING")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|;Fi[@S+@)C@*C@+CI"var = (var + 1);Fi[[	@siÕI"H      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@yiºI"H      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@Åi≠I"6      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[I"
retry;FI"rescue;F@QI"end;FI"var = var;Fi[[	@iI"
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@iCI"
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@iÅI"
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[@
@¬(@√(@"I"# do nothing;Fi[[	@1ibI"≠            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@˛iDI"µ    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@™iI"‹            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end;Fi[I"var.unshift(var);FI"var = nil;FI"	else;F@ÖH@ÜHi[[	@?iÚI"ﬂ    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@?i¸I"Û      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@?iI"ﬂ    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[@
@@6KI"end;FI" ;Fi[[	@¨iQI"„          "STRING"
        end
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        caller.first(3).find { |arglist| var =~ /should_not/ };Fi[	@⁄i2I"      def function(arglist)
        @var.nil? ? (true) : ((@var == var.method(var).arity))
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        (@var.length == 1) ? ("STRING") : (@var.inspect);Fi[	@Øi3I"∆      end
      
      private
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING");Fi[@¸BI"var = 0;F@óO@äO@ãOi[[	@siAI"  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@vi1I"  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@yi0I"  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[@¸BI"Bvar = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING");FI"var = 0;FI"if var then;F@)i[[	@si_I">    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING";Fi[	@viTI">    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING";Fi[	@yiNI">    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING";Fi[@
@I"var = max_value;FI"var = min_value;F@DKi[[	@TiI"˚      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[	@WiI"‡      end
      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[	@iiPI".        var = (((@var[:fields][0].length / 2) * font_size) * 0.6)
        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[I"+var.send(:alias_method, "STRING", var);FI"+var.send(:alias_method, var, "STRING");FI"end;FI"end;FI" ;Fi[[	@ÜiI"    module Callbacks
      def self.included(arglist)
        ["STRING", "STRING"].each do |arglist|
          var.send(:alias_method, "STRING", var)
          var.send(:alias_method, var, "STRING")
        end
      end
      
      attr_reader(:callbacks)
      ;Fi[	@ìiI"        ["STRING", "STRING", "STRING"].each do |arglist|
          var = var[/^\w+/]
          var = var[/\W+$/]
          var.send(:alias_method, "STRING", var)
          var.send(:alias_method, var, "STRING")
        end
      end
      
      attr_reader(:variables)
      ;Fi[	@¢i
I"ó    module XssMods
      def self.included(arglist)
        ["STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING", "STRING"].each do |arglist|
          var.send(:alias_method, "STRING", var)
          var.send(:alias_method, var, "STRING")
        end
      end
      
      # Don't escape text that's already safe,
      # output is always HTML safe;Fi[@
@I"@var[:fields];FI"end;FI" ;Fi[[	@TiI"û      end
      
      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value;Fi[	@Wi#I"Õ        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        (var / -2.0);Fi[	@iiFI"ú        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super;Fi[@‚S@„S@‰SI"end;FI" ;Fi[[	@§iBI"”          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        ;Fi[	@∏i9I"d          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[	@Ωi>I"~          [(var["STRING"] or 0).to_i, (var["STRING"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[@÷S@◊S@ÿS@ŸSI"$p4_sync(var, var, p4sync_flags);Fi[[	@∏iI"p          "STRING"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@∏iI"á          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@∏i"I"á          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[@◊S@ÿS@ŸS@LUI"end;Fi[[	@∏iI"™        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@∏iI"™        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@∏i#I"≠        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.;Fi[@ÿS@ŸS@LUI"end;FI" ;Fi[[	@∏iI"Ó        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@∏iI"Ó        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@∏i$I"ø        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.
        def function(arglist);Fi[I"@var = (@var + var);F@*C@+C@ŸTI"var = (var + 1);Fi[[	@siŒI"<        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@yiΩI"<        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@ÅiÆI"*        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[@
@@¿4@¡4I"	else;Fi[[	@ÅiI"  end
  
  attr_reader :function
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end;Fi[	@ÅiI"    end
    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end;Fi[	@ÅiI"*    @var = @var.!=(@var)
    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("STRING", (var / 255.0))
    else
      @var = sprintf("STRING", (var / 255.0), (var / 255.0), (var / 255.0))
    end;Fi[@
@I"out("STRING");F@Å?@Ç?i[[	@si8I"      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING");Fi[	@viAI"      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING");Fi[	@yi'I"      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING");Fi[I"binding;FI"end;FI"end;FI"end;FI"end;Fi[[	@ç	iÖI"]      end
      
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	@ê	i'I"}      
      def function(arglist)
        @var.each { |arglist| eval("STRING") }
        binding
      end
    end
  end
end;Fi[	@€Mi
I"|  module Sprites
    class Binding < OpenStruct
      def function(arglist)
        binding
      end
    end
  end
end;Fi[I"if color_stop?(var) then;FI"var.unshift(var);FI"var = nil;FI"	else;F@ÖHi[[	@?iÒI"€    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@?i˚I"Û        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@?iI"€    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[@ÖH@ÜHI"var = nil;FI"end;FI"end;Fi[[	@?iıI"Û        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then;Fi[	@?iˇI"        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then;Fi[	@?iI"!        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first);Fi[@ÜHI"var = nil;FI"end;FI"end;FI"'var = nil if var and var.to_bool.!;Fi[[	@?iˆI"Û        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var);Fi[	@?i I"        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then
        var = var.first.value;Fi[	@?iI"@        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first)
      LinearGradient.new(var, send(:color_stops, *var));Fi[I"if var.to_bool then;FI".Sass::Script::String.new(clean_path(var));FI"	else;FI"clean_url(var);FI"end;Fi[[	@ëi&I"∞        end
      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[	@ëi?I"“        Compass.configuration.http_fonts_path
      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[	@ëirI"∑        end
      end
      var = "STRING" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[@µUI"	else;FI"clean_url(var);FI"end;FI"end;Fi[[	@ëi'I"ß      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@ëi@I"ß      end
      var = "STRING"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@ëisI"Æ      end
      var = "STRING" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[I"clean_url(var);FI"end;FI"end;FI"end;FI" ;Fi[[	@ëi)I"∏      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl
    def self.included(arglist);Fi[	@ëiBI"π      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl
    def self.included(arglist);Fi[	@ëiuI"¬      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl
    def self.included(arglist);Fi[@ SI" ;F@ÃSI"@var ||= var;FI"end;Fi[[	@fiI"⁄        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@iI"        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@PiI"œ        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[I" @var.each_pair do |arglist|;FI"newobj;F@"1I"5var = (FPDF_FONTPATH + var) if defined("STRING");FI"var = filesize(var);Fi[[	@siˆI"      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var));Fi[	@viˇI"      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var));Fi[	@yiÂI"      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var));Fi[@ÂU@ÊU@"1I"out("STRING");FI"(if (var["STRING"] == "STRING") then;Fi[[	@siI"⁄      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else;Fi[	@viI"⁄      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else;Fi[	@yiıI"⁄      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else;Fi[@ãQI"raise(var);FI"end;FI"end;FI"end;Fi[[	@XiÆI"            (var = formatter_class(var)
            var.new(var, var, @var))
          rescue Exception => var
            (var.message << "STRING")
            raise(var)
          end
        end
      end
      
      class LogFormatter < ::Logger::Formatter;Fi[	@`iI"          begin
            require("fog")
          rescue LoadError => var
            (var.message << "STRING")
            raise(var)
          end
          end
        end
        var.instance_eval do |arglist|
          unless @var[:url].to_s.match(/^:fog.*url$/) then;Fi[	@ÏiI"          begin
            require("aws-sdk")
          rescue LoadError => var
            (var.message << "STRING")
            raise(var)
          end
          end
        end
        if (AWS::VERSION >= "STRING") then
          AWS::Core::LogFormatter.class_eval do |arglist|;Fi[@
@@âK@äK@ãKi[[	@siI"Ê    var = var.gsub("STRING", "STRING")
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end;Fi[	@viI"€    var = (@var.length + 1)
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -120, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end;Fi[	@yiI"Ê    var = var.gsub("STRING", "STRING")
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end;Fi[@å @ú4@ù4@è I"broadcast(var, var);Fi[[	@Ui@I"º      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@UidI"º      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@UitI"º      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[@
@I"&var = (var.downcase + var.upcase);FI"*Error("STRING") unless @var[var].nil?;FI"var = (@var.length + 1);Fi[[	@si	I"  Big5_widths = { "STRING" => 250, "STRING" => 250, "STRING" => 408, "STRING" => 668, "STRING" => 490, "STRING" => 875, "STRING" => 698, "STRING" => 250, "STRING" => 240, "STRING" => 240, "STRING" => 417, "STRING" => 667, "STRING" => 250, "STRING" => 313, "STRING" => 250, "STRING" => 520, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 250, "STRING" => 250, "STRING" => 667, "STRING" => 667, "STRING" => 667, "STRING" => 396, "STRING" => 921, "STRING" => 677, "STRING" => 615, "STRING" => 719, "STRING" => 760, "STRING" => 625, "STRING" => 552, "STRING" => 771, "STRING" => 802, "STRING" => 354, "STRING" => 354, "STRING" => 781, "STRING" => 604, "STRING" => 927, "STRING" => 750, "STRING" => 823, "STRING" => 563, "STRING" => 823, "STRING" => 729, "STRING" => 542, "STRING" => 698, "STRING" => 771, "STRING" => 729, "STRING" => 948, "STRING" => 771, "STRING" => 677, "STRING" => 635, "STRING" => 344, "STRING" => 520, "STRING" => 344, "STRING" => 469, "STRING" => 500, "STRING" => 250, "STRING" => 469, "STRING" => 521, "STRING" => 427, "STRING" => 521, "STRING" => 438, "STRING" => 271, "STRING" => 469, "STRING" => 531, "STRING" => 250, "STRING" => 250, "STRING" => 458, "STRING" => 240, "STRING" => 802, "STRING" => 531, "STRING" => 500, "STRING" => 521, "STRING" => 521, "STRING" => 365, "STRING" => 333, "STRING" => 292, "STRING" => 521, "STRING" => 458, "STRING" => 677, "STRING" => 479, "STRING" => 458, "STRING" => 427, "STRING" => 480, "STRING" => 496, "STRING" => 480, "STRING" => 667 }
  
  GB_widths = { "STRING" => 207, "STRING" => 270, "STRING" => 342, "STRING" => 467, "STRING" => 462, "STRING" => 797, "STRING" => 710, "STRING" => 239, "STRING" => 374, "STRING" => 374, "STRING" => 423, "STRING" => 605, "STRING" => 238, "STRING" => 375, "STRING" => 238, "STRING" => 334, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 462, "STRING" => 238, "STRING" => 238, "STRING" => 605, "STRING" => 605, "STRING" => 605, "STRING" => 344, "STRING" => 748, "STRING" => 684, "STRING" => 560, "STRING" => 695, "STRING" => 739, "STRING" => 563, "STRING" => 511, "STRING" => 729, "STRING" => 793, "STRING" => 318, "STRING" => 312, "STRING" => 666, "STRING" => 526, "STRING" => 896, "STRING" => 758, "STRING" => 772, "STRING" => 544, "STRING" => 772, "STRING" => 628, "STRING" => 465, "STRING" => 607, "STRING" => 753, "STRING" => 711, "STRING" => 972, "STRING" => 647, "STRING" => 620, "STRING" => 607, "STRING" => 374, "STRING" => 333, "STRING" => 374, "STRING" => 606, "STRING" => 500, "STRING" => 239, "STRING" => 417, "STRING" => 503, "STRING" => 427, "STRING" => 529, "STRING" => 415, "STRING" => 264, "STRING" => 444, "STRING" => 518, "STRING" => 241, "STRING" => 230, "STRING" => 495, "STRING" => 228, "STRING" => 793, "STRING" => 527, "STRING" => 524, "STRING" => 524, "STRING" => 504, "STRING" => 338, "STRING" => 336, "STRING" => 277, "STRING" => 517, "STRING" => 450, "STRING" => 652, "STRING" => 466, "STRING" => 452, "STRING" => 407, "STRING" => 370, "STRING" => 258, "STRING" => 370, "STRING" => 605 }
  
  def function(arglist)
    var = (var.downcase + var.upcase)
    Error("STRING") unless @var[var].nil?
    var = (@var.length + 1)
    var = var.gsub("STRING", "STRING")
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) };Fi[	@viI"¨module PDF_Japanese
  SJIS_widths = { "STRING" => 278, "STRING" => 299, "STRING" => 353, "STRING" => 614, "STRING" => 614, "STRING" => 721, "STRING" => 735, "STRING" => 216, "STRING" => 323, "STRING" => 323, "STRING" => 449, "STRING" => 529, "STRING" => 219, "STRING" => 306, "STRING" => 219, "STRING" => 453, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 614, "STRING" => 219, "STRING" => 219, "STRING" => 529, "STRING" => 529, "STRING" => 529, "STRING" => 486, "STRING" => 744, "STRING" => 646, "STRING" => 604, "STRING" => 617, "STRING" => 681, "STRING" => 567, "STRING" => 537, "STRING" => 647, "STRING" => 738, "STRING" => 320, "STRING" => 433, "STRING" => 637, "STRING" => 566, "STRING" => 904, "STRING" => 710, "STRING" => 716, "STRING" => 605, "STRING" => 716, "STRING" => 623, "STRING" => 517, "STRING" => 601, "STRING" => 690, "STRING" => 668, "STRING" => 990, "STRING" => 681, "STRING" => 634, "STRING" => 578, "STRING" => 316, "STRING" => 614, "STRING" => 316, "STRING" => 529, "STRING" => 500, "STRING" => 387, "STRING" => 509, "STRING" => 566, "STRING" => 478, "STRING" => 565, "STRING" => 503, "STRING" => 337, "STRING" => 549, "STRING" => 580, "STRING" => 275, "STRING" => 266, "STRING" => 544, "STRING" => 276, "STRING" => 854, "STRING" => 579, "STRING" => 550, "STRING" => 578, "STRING" => 566, "STRING" => 410, "STRING" => 444, "STRING" => 340, "STRING" => 575, "STRING" => 512, "STRING" => 760, "STRING" => 503, "STRING" => 529, "STRING" => 453, "STRING" => 326, "STRING" => 380, "STRING" => 326, "STRING" => 387 }
  
  def function(arglist)
    var = (var.downcase + var.upcase)
    Error("STRING") unless @var[var].nil?
    var = (@var.length + 1)
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -120, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end;Fi[	@yiI"Ãmodule PDF_Korean
  UHC_widths = { "STRING" => 333, "STRING" => 416, "STRING" => 416, "STRING" => 833, "STRING" => 625, "STRING" => 916, "STRING" => 833, "STRING" => 250, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 833, "STRING" => 291, "STRING" => 833, "STRING" => 291, "STRING" => 375, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 625, "STRING" => 333, "STRING" => 333, "STRING" => 833, "STRING" => 833, "STRING" => 916, "STRING" => 500, "STRING" => 1000, "STRING" => 791, "STRING" => 708, "STRING" => 708, "STRING" => 750, "STRING" => 708, "STRING" => 666, "STRING" => 750, "STRING" => 791, "STRING" => 375, "STRING" => 500, "STRING" => 791, "STRING" => 666, "STRING" => 916, "STRING" => 791, "STRING" => 750, "STRING" => 666, "STRING" => 750, "STRING" => 708, "STRING" => 666, "STRING" => 791, "STRING" => 791, "STRING" => 750, "STRING" => 1000, "STRING" => 708, "STRING" => 708, "STRING" => 666, "STRING" => 500, "STRING" => 375, "STRING" => 500, "STRING" => 500, "STRING" => 500, "STRING" => 333, "STRING" => 541, "STRING" => 583, "STRING" => 541, "STRING" => 583, "STRING" => 583, "STRING" => 375, "STRING" => 583, "STRING" => 583, "STRING" => 291, "STRING" => 333, "STRING" => 583, "STRING" => 291, "STRING" => 875, "STRING" => 583, "STRING" => 583, "STRING" => 583, "STRING" => 583, "STRING" => 458, "STRING" => 541, "STRING" => 375, "STRING" => 583, "STRING" => 583, "STRING" => 833, "STRING" => 625, "STRING" => 625, "STRING" => 500, "STRING" => 583, "STRING" => 583, "STRING" => 583, "STRING" => 750 }
  
  def function(arglist)
    var = (var.downcase + var.upcase)
    Error("STRING") unless @var[var].nil?
    var = (@var.length + 1)
    var = var.gsub("STRING", "STRING")
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) };Fi[@
@I"it("STRING") do |arglist|;F@ñKI"end;Fi[[	@›iI"          expect(last_request.env["STRING"]).to(be_kind_of(Hash))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      ;Fi[	@›iI"          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      ;Fi[	@›iI"          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
    end;Fi[I"STDERR.puts("STRING");FI"STDERR.puts("STRING");F@;I"end;FI"when "STRING" then;Fi[[	@Wi I":          @var = {}
          @var["STRING"]["STRING"].each { |arglist| @var[var.to_sym] = true })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          require("kramdown");Fi[	@Wi(I"        begin
          require("kramdown")
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          (require("rdiscount");Fi[	@Wi1I">          (require("rdiscount")
          @var = @var["STRING"]["STRING"].map { |arglist| var.to_sym })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          (require("maruku");Fi[@-V@;I"end;F@0VI"
begin;Fi[[	@Wi!I"?          @var["STRING"]["STRING"].each { |arglist| @var[var.to_sym] = true })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          require("kramdown")
        rescue LoadError;Fi[	@Wi)I"?          require("kramdown")
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          (require("rdiscount")
          @var = @var["STRING"]["STRING"].map { |arglist| var.to_sym });Fi[	@Wi2I"I          @var = @var["STRING"]["STRING"].map { |arglist| var.to_sym })
        rescue LoadError
          STDERR.puts("STRING")
          STDERR.puts("STRING")
          raise(FatalException.new("STRING"))
        end
      when "STRING" then
        begin
          (require("maruku")
          if @var["STRING"]["STRING"] then;Fi[@
@@¨HI"var;FI"end;Fi[[	@i,I"√        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@i1I"√        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@i6I"¡        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted;Fi[@
@@£HI"var;FI"end;Fi[[	@i◊I"⁄        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@i‹I"π        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@i·I"∑        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted;Fi[I"@var.flush;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@fi7I"T            @var.puts(format_string(var.backtrace_line, var))
          end
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        @var = step_mother.scenarios(:failed).select do |arglist|
          (var.is_a?(Cucumber::Ast::Scenario) or var.is_a?(Cucumber::Ast::OutlineTable::ExampleRow));Fi[	@oi7I"Â      def function(arglist)
        if (@var == 1) then
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        var = format_string(var, :tag).indent(@var)
        @var.print(var);Fi[	@uiI"Á        unless @var.empty? then
          after_first_time { |arglist| @var.print("STRING") }
          @var.print("STRING")
          @var.flush
        end
      end
      
      def function(arglist)
        @var.close
      end;Fi[@
@@8LI"end;FI" ;Fi[[	@&i>I"ﬁ  def function(arglist)
    (alpha? or (beta? or rc?))
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") };Fi[	@&iBI"Ú  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") };Fi[	@&iFI"‰  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    return unless var.is_a?(Version);Fi[@
@@DLI"var.write("STRING");F@FLi[[	@§0iâI"Ó  def function(arglist)
    (HOMEBREW_PREFIX / "STRING").unlink
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@§0iôI"˛    assert((var.arch == :dunno))
    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[	@§0i©I"˛    assert((var.arch == :dunno))
    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!);Fi[I"'@var.span(var, :class => "STRING");FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@)iâI"        @var.h3(:id => "STRING") do |arglist|
          @var.span(var, :class => "STRING")
          @var.text!("STRING")
          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        @var = (@var + 1)
        @var = false;Fi[	@)iüI"        @var.h3(:id => "STRING") do |arglist|
          @var.span((var + "STRING"), :class => "STRING")
          @var.text!("STRING")
          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        @var = 0
        (@var << "STRING");Fi[	@)iπI"Û        @var.h4 do |arglist|
          @var.span(var, :class => "STRING")
          @var.text!("STRING")
          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        (@var << "STRING")
      end;Fi[I"@var.text!("STRING");FI"'@var.span(var, :class => "STRING");FI"end;FI"end;FI" ;Fi[[	@)iàI"        @var = true
        @var.h3(:id => "STRING") do |arglist|
          @var.span(var, :class => "STRING")
          @var.text!("STRING")
          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        @var = (@var + 1);Fi[	@)iûI"        @var = false
        @var.h3(:id => "STRING") do |arglist|
          @var.span((var + "STRING"), :class => "STRING")
          @var.text!("STRING")
          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        @var = 0;Fi[	@)i∏I"      def function(arglist)
        @var.h4 do |arglist|
          @var.span(var, :class => "STRING")
          @var.text!("STRING")
          @var.span(var, :class => "STRING")
        end
      end
      
      def function(arglist)
        (@var << "STRING");Fi[I"if (var > var) then;FI"*if ((var == -1) or (var == var)) then;F@'CI"@var = @var;F@)Ci[[	@si I"v      end
      var = var if (var.! or (var.chr == "STRING"))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[	@vi“I")          var = var
        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[	@yiπI"v      end
      var = var if (var.! or (var.chr == "STRING"))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[I"var = var["STRING"];FI"var = "STRING";F@_J@`JI"out("STRING");Fi[[	@si$I"?        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var);Fi[	@vi-I"?        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var);Fi[	@yiI"?        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var);Fi[@úV@ñI@óII"out("STRING");FI";out("STRING") if var.!=("STRING") and var.!=("STRING");Fi[[	@siI"@      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]));Fi[	@viI"@      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]));Fi[	@yi¸I"@      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]));Fi[@úVI"if var then;F@ZKI"end;F@\Ki[[	@si.I"ì          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end;Fi[	@vi7I"ì          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end;Fi[	@yiI"ì          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end;Fi[@
@@à5@â5I"assert(var.i386?.!);Fi[[	@§0i%I"    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O dynamically linked shared library/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!);Fi[	@§0i]I"ı    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!);Fi[	@§0ikI"˛    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var))
  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!);Fi[I"var.json do |arglist|;FI"8render(:json => (@var.stream_posts.map do |arglist|;FI"ILastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));FI"
end));FI"end;Fi[[	@ªieI"D    end
    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[	@–i?I"H    respond_with do |arglist|
      var.html { |arglist| render("STRING") }
      var.mobile { |arglist| render("STRING") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[	@”i'I"Ö    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[I"/render(:nothing => (true), :status => 404);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@—	i3I"9      var = OEmbedPresenter.new(var, params.slice(:format, :maxheight, :minheight))
      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).newer(@var)
    respond_to do |arglist|;Fi[	@ƒi$I"Ÿ    if @var.present? and @var.local? then
      render("STRING")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    render("STRING", :content_type => "STRING")
  end;Fi[	@ziîI"    if var.present? then
      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    if current_user.confirm_email(params[:token]) then
      flash[:notice] = I18n.t("STRING", :email => (current_user.email));Fi[@
@@≠LI"end;FI" ;Fi[[	@
iOI"˘    return "STRING" unless MacOS::XQuartz.installed?
    return ("STRING" + describe_path(MacOS::XQuartz.prefix))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"));Fi[	@
iSI"¬  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"));Fi[	@
iWI"¨  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    "STRING";Fi[@≈V@∆VI"
end));FI"end;FI"end;Fi[[	@ªifI"?    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	@–i@I"-      var.html { |arglist| render("STRING") }
      var.mobile { |arglist| render("STRING") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	@”i(I"X    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[@∆VI"
end));FI"end;FI"end;FI"end;Fi[[	@ªigI"r      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display;Fi[	@–iAI"      var.mobile { |arglist| render("STRING") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist);Fi[	@”i)I"˜    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private;Fi[I"-include_analytics("STRING") do |arglist|;FI"4javascript_tag { |arglist| "STRING".html_safe };FI"end;FI"end;FI" ;Fi[[	@÷iI"Ÿmodule AnalyticsHelper
  def function(arglist)
    include_analytics("STRING") do |arglist|
      javascript_tag { |arglist| "STRING".html_safe }
    end
  end
  
  def function(arglist)
    return unless current_user;Fi[	@÷iI"Ì  
  def function(arglist)
    return unless current_user
    include_analytics("STRING") do |arglist|
      javascript_tag { |arglist| "STRING".html_safe }
    end
  end
  
  def function(arglist)
    return unless configured?("STRING");Fi[	@÷iI"°  end
  
  def function(arglist)
    include_analytics("STRING") do |arglist|
      javascript_tag { |arglist| "STRING".html_safe }
    end
  end
  
  private
  ;Fi[@ÍLI"end;FI" ;FI"def function(arglist);F@—Li[[	@˜	i8I"≈  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	@◊i)I"ï  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	@‰i0I"«  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[@
@@≈L@∆LI"super(var);Fi[[	@ÍikI"=    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@ÍitI"Ó      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@Íi}I"Ó      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[@ƒDI"var = var.length;FI"var = 0;F@óO@äOi[[	@si@I"  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@vi0I"  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@yi/I"  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[@
@@—LI"end;FI" ;Fi[[	@˜	i:I"—  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then;Fi[	@◊i+I"Æ  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false;Fi[	@‰i2I"ø  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid;Fi[@
@@Ï*I"	self;FI"end;Fi[[	@RiI"º      (var.arity > 0) ? (yield(var)) : (var.instance_eval(&var))
      var
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist);Fi[	@RiI"ï      (@var << "STRING")
      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist);Fi[	@Ri@I"ï      (@var << "STRING")
      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist);Fi[@≈L@∆LI"super(var);FI"	else;F@°Ii[[	@ÍimI"Õ  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@ÍivI"Õ  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@ÍiI"Õ  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[@∆LI"super(var);FI"	else;F@°II"end;Fi[[	@ÍinI"   
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@ÍiwI"   
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@Íi{I"   
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[@°II"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@ÍiqI"˚    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@ÍizI"˚    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@Íi~I"    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["STRING", "STRING"].all? { |arglist| var[var].present? } then
      var["STRING"] = "STRING" if var["STRING"].blank?;Fi[@
@I"broadcast(var);FI"end;FI" ;Fi[[	@UiI"¯      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@Ui%I"ﬁ      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@UijI"ﬁ      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[@kE@lE@UI"var = 0;FI"if var then;Fi[[	@si^I"@    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING";Fi[	@viSI"@    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING";Fi[	@yiMI"@    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING";Fi[@
@I"@var.language;FI"end;FI" ;Fi[[	@ i?I"      def function(arglist)
        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      
      class ExampleRow < Cells
        class InvalidForHeaderRowError < NoMethodError;Fi[	@ ißI"©        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          @var.language
        end
        
        private
        ;Fi[	@PiWI"'      def function(arglist)
        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      
      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "STRING").gsub(/\./, "STRING").gsub(/:/, "STRING");Fi[I"# @example;FI"#   class Person;F@ÒR@ÚRI"#;Fi[[	@‡/iàI"ı      
      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end;Fi[	@‡/iôI"È      
      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end;Fi[	@‡/i™I"       
      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_presence_of :title
      #   end;Fi[@
@@°EI"var = @var;F@lMi[[	@siWI"Ï      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@viLI"Ï      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@yiFI"Ï      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[@
@@UMI"end;FI" ;Fi[[	@iBI"–      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init;Fi[	@ i I"©        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags;Fi[	@ iÇI"Ω            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var);Fi[@3@3@3@3I"$if ARGV.include?("STRING") then;Fi[[	@˙5iI"Ÿ    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("STRING") then
      Formula.each { |arglist| puts("STRING") }
    else;Fi[	@˝5iI"´    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("STRING") then
      puts("STRING")
      puts("STRING");Fi[	@ùiI"´require("formula")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("STRING") then
      exec_browser("STRING")
    else;Fi[@
@@uMI"end;FI" ;Fi[[	@úixI"”            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "STRING")
          end
          
          def function(arglist)
            "STRING";Fi[	@”iVI"˜    var = var.map { |arglist| var.to_s.gsub("STRING", "STRING") }.join("STRING")
    super(var, "STRING")
  end
  
  def function(arglist)
    (@var == "STRING")
  end
  
  def function(arglist)
    @var ||= GitHub.issues_for_formula(formula.name);Fi[	@&i6I"í  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == "STRING")
  end
  
  def function(arglist)
    (alpha? or (beta? or rc?));Fi[I"opoo("STRING");FI"puts("STRING");FI"puts("STRING");FI"puts(var);FI"@var = true;Fi[[	@&
i>I"≥      var.include?(var.extname).!
    end
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end;Fi[	@&
iJI"     return unless f.bin.directory?
    var = f.bin.children.select { |arglist| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end;Fi[	@&
iVI"    return unless f.sbin.directory?
    var = f.sbin.children.select { |arglist| (var.directory? or var.executable?.!) }
    unless var.empty? then
      opoo("STRING")
      puts("STRING")
      puts("STRING")
      puts(var)
      @var = true
    end
  end;Fi[@
@I"	self;FI"end;FI" ;Fi[[	@iCI"Ñ      @var = nil
      var
    end
    
    def function(arglist)
      self
    end
    
    def function(arglist)
      sorted.dup;Fi[	@B@iI"µ        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@⁄i&I"í        @var = var
        self
      end
      
      def function(arglist)
        self
      end
      
      alias :arguments :argument
      ;Fi[@
@I"(@var or @var);FI"end;FI" ;Fi[[	@/i¬I"∫        end
        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        options["STRING"];Fi[	@ iÜI"“        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var;Fi[	@@iI"v  module Parser
    class GherkinBuilder
      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("STRING")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, []);Fi[I"(HOMEBREW_REPOSITORY.cd do |arglist|;FI"var = UpdaterMock.new;FI"!var.in_repo_expect("STRING");FI"+var.in_repo_expect("STRING", "STRING");FI"!var.in_repo_expect("STRING");Fi[[	@§.i1I"'  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	@§.iCI"=  
  def function(arglist)
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[	@§.iWI"=  
  def function(arglist)
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING");Fi[@
@I"Btemplate("STRING", File.join("STRING", class_path, "STRING"));FI"end;FI" ;Fi[[	@ZTiI"        end
        migration_template("STRING", "STRING")
      end
      
      def function(arglist)
        template("STRING", File.join("STRING", class_path, "STRING"))
      end
      
      def function(arglist)
        return if regular_class_path.empty?;Fi[	@]TiI"H      class_option(:versioning, :type => :boolean, :default => (false), :desc => "STRING")
      
      class_option(:collection, :type => :string, :desc => "STRING")
      
      def function(arglist)
        template("STRING", File.join("STRING", class_path, "STRING"))
      end
      
      hook_for(:test_framework)
    end;Fi[	I"Sdata//mongoid_proj/lib/rails/generators/mongoid/observer/observer_generator.rb;Ti
I"	  module Generators
    class ObserverGenerator < Base
      check_class_collision(:suffix => "STRING")
      
      def function(arglist)
        template("STRING", File.join("STRING", class_path, "STRING"))
      end
      
      hook_for(:test_framework)
    end;Fi[@
@@j I"@var = var;FI"end;Fi[[	@¯/iiI"ü  
  class UnknownPrimaryKey < ActiveRecordError
    attr_reader(:model)
    
    def function(arglist)
      super("STRING")
      @var = var
    end
  end
  ;Fi[	@#iI"ƒ    class Table
      class Different < StandardError
        attr_reader(:table)
        
        def function(arglist)
          super("STRING")
          @var = var
        end
      end
      ;Fi[	@ﬁ"iI"∫module Cucumber
  class Undefined < StandardError
    attr_reader(:step_name)
    
    def function(arglist)
      super("STRING")
      @var = var
    end
    
    def function(arglist);Fi[I"$1.to_i;FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@,
icI"?  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") and locate("STRING").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("STRING")}STRING` =~ /build (\d{4,})/;Fi[	@,
ijI"D  def function(arglist)
    @var ||= if locate("STRING") and locate("STRING").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("STRING")}STRING` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /LLVM build (\d{4,})/;Fi[	@,
iqI"  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /LLVM build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("STRING") then
      `#{locate("STRING")}STRING` =~ /clang version (\d\.\d)/;Fi[I"MockFormula.new("STRING");FI"MockFormula.new("STRING");FI"MockFormula.new("STRING");FI"MockFormula.new("STRING");FI"MockFormula.new("STRING");Fi[[	@7
iI"!  
  def function(arglist)
    assert_nothing_raised do |arglist|
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING");Fi[	@7
iI"&  def function(arglist)
    assert_nothing_raised do |arglist|
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
    end;Fi[	@7
iI"    assert_nothing_raised do |arglist|
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
      MockFormula.new("STRING")
    end
  end;Fi[@
@I"var = 0;F@˘MI"var = var.length;Fi[[	@si=I"ü      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@vi-I"ü      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@yi,I"ü      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do;Fi[I"var.write("STRING");F@FLI"assert(var.i386?.!);FI"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);Fi[[	@§0iåI"ı  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@§0iúI"ı  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@§0i¨I"ı  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[I"0assert_version_equal("STRING", var.version);FI""assert_nil(var.head.checksum);FI"$assert_equal("STRING", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);Fi[[	@<
i∂I"à    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@<
i≈I"à    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@<
i‘I"à    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[I"good_checksum(var);FI"end;FI" ;FI"def function(arglist);FI"var = TestBall.new;Fi[[	I"/data//homebrew_proj/test/test_checksums.rb;TiI"  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval { |arglist| md5("STRING") }
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval { |arglist| md5("STRING") }
    bad_checksum(var);Fi[	@:Xi#I"  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval { |arglist| sha1("STRING") }
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval { |arglist| sha1("STRING") }
    bad_checksum(var);Fi[	@:Xi/I"  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval { |arglist| sha256("STRING") }
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval { |arglist| sha256("STRING") }
    bad_checksum(var);Fi[I"url("STRING");FI" ;FI"sha1("STRING");FI" ;FI"bottle do |arglist|;Fi[[	@o iîI"üclass OldBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|
    url("STRING")
    sha1("STRING");Fi[	@o i˘I"Ωclass AllCatsBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion);Fi[	@o i
I"∞class RevisedBottleSpecTestBall < Formula
  homepage("STRING")
  
  url("STRING")
  
  sha1("STRING")
  
  bottle do |arglist|
    version(1)
    sha1("STRING" => :snowleopard);Fi[I"$assert_equal("STRING", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);FI"3assert_instance_of(HeadSoftwareSpec, var.head);FI"end;Fi[[	@<
i∏I"n    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@<
i«I"n    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@<
i÷I"n    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[I""assert_nil(var.head.checksum);F@(X@)X@*X@QXi[[	@<
i∑I"p    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@<
i∆I"p    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@<
i’I"p    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[I",assert_equal(var.head, var.active_spec);FI"0assert_version_equal("STRING", var.version);F@'X@(X@)Xi[[	@<
iµI"ù    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@<
iƒI"ù    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@<
i”I"ù    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[@OX@PX@QXI"end;FI" ;Fi[[	@<
iπI"m    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@<
i»I"m    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@<
i◊I"m    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new;Fi[@PX@QXI"end;FI" ;FI"def function(arglist);Fi[[	@<
i∫I"Z    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@<
i…I"Z    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@<
iÿI"\    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new
    assert_not_nil(var.stable);Fi[I"assert_nil(var.bottle);FI"assert_nil(var.devel);FI",assert_equal(var.head, var.active_spec);FI"0assert_version_equal("STRING", var.version);F@'Xi[[	@<
i≥I"n    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@<
i¬I"v    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@<
i—I"v    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[I"assert_not_nil(var.head);FI"assert_nil(var.stable);FI"assert_nil(var.bottle);F@ÑX@ÖXi[[	@<
i±I"(  
  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum);Fi[	@<
i¿I"0  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum);Fi[	@<
iœI"0  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum);Fi[@êX@ëX@ÑX@ÖX@ÜXi[[	@<
i≤I"I  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url);Fi[	@<
i¡I"Q  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url);Fi[	@<
i–I"Q  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url);Fi[@ÑX@ÖX@ÜX@'X@(Xi[[	@<
i¥I"á    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@<
i√I"á    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@<
i“I"á    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("STRING", var.version)
    assert_nil(var.head.checksum)
    assert_equal("STRING", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[@
@@ªF@ºFI"end;Fi[[	@ÑiÎI"¬          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@ÈiI"¬          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@‚iI"k    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[@
@I"@var.clear;FI"end;FI" ;Fi[[	@ÇiΩI"¨      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@Çi¡I"Æ      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@Çi≈I"±      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var;Fi[@PL@QLI"assert(var.i386?.!);F@ù0@û0i[[	@§0iI"end
class MachOPathnameTests < Test::Unit::TestCase
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?);Fi[	@§0i5I"€  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@§0iCI"€  end
  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[@QLI"assert(var.i386?.!);F@ù0@û0@ü0i[[	@§0iI"%class MachOPathnameTests < Test::Unit::TestCase
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!);Fi[	@§0i6I"¯  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?);Fi[	@§0iDI"˙  
  def function(arglist)
    var = Pathname.new("STRING")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[@
@@∑!@∏!I"end;Fi[[	@Oi3I"£          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@Òi>I"v    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@7ibI"º      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index("STRING") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[@
@@±0I"end;FI" ;Fi[[	@Ëi5I"ê        end
      end
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist)
      var = "STRING";Fi[	@Òi*I"î    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist)
      {};Fi[	@˛i<I"Î    def function(arglist)
      (super or @var.respond_to?(*var))
    end
    
    def function(arglist)
      @var ||= "STRING"
    end
    
    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash;Fi[@û0@ü0I"assert(var.dylib?);FI"%assert(var.mach_o_executable?.!);FI"#assert(var.text_executable?.!);Fi[[	@§0iI"V    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert((var.arch == :universal))
    assert_match(/Mach-O (64-bit )?dynamically linked shared library/, file(var));Fi[	@§0iI"H    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O dynamically linked shared library/, file(var));Fi[	@§0i+I"O    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O 64-bit dynamically linked shared library/, file(var));Fi[@
@I"
super;F@CN@DNi[[	@X"i	I"Ù  source_root(File.expand_path("STRING", "STRING"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING"
  end;Fi[	@JNiI"&  argument(:actions, :type => :array, :default => ([]), :banner => "STRING")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING"
    @var = controller.camelize;Fi[	@MNiI"'  class_option(:indexes, :type => :boolean, :default => (true), :desc => "STRING")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING"
    @var = model.camelize;Fi[@ü0@†0@°0@û9I"assert(var.mach_o_bundle?);Fi[[	@§0iHI""    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var))
  end;Fi[	@§0iVI"    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var))
  end;Fi[	@§0idI"    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var))
  end;Fi[@
@∑:@∏:@ÎH@ÏHi[[	@‰iI"‚        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@ÁiI"È      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@ÍiI"‹        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[@DLI"var.write("STRING");F@FLI"assert(var.i386?.!);F@Xi[[	@§0iãI"‚  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@§0iõI"‚  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[	@§0i´I"‚  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!);Fi[I"var = var.patches[0];FI"#assert_equal(:p1, var.patch_p);FI"end;FI" ;FI"def function(arglist);Fi[[	I"-data//homebrew_proj/test/test_patches.rb;TiI"  def function(arglist)
    var = Patches.new("STRING")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(["STRING", "STRING"])
    assert_equal(2, var.patches.length);Fi[	@YiI"    assert_equal(2, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(:p0 => "STRING")
    assert_equal(1, var.patches.length);Fi[	@Yi+I"  def function(arglist)
    var = Patches.new(:p1 => "STRING")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = { :p1 => "STRING", :p0 => "STRING" }
    var = Patches.new(var);Fi[@
@{+I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;Fi[[	@7iI"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11");Fi[	@:i¶I".        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ]);Fi[	@/i+I"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11");Fi[@(@\KI"out("STRING");FI"end;FI"end;Fi[[	@si1I".          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end;Fi[	@vi:I".          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end;Fi[	@yi I".          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end;Fi[@¯GI"end;FI"end;FI"end;FI" ;Fi[[	@?
i%I"      DefaultPatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@?
i/I"      ListPatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@?
i9I"      P0PatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING")
        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[@(I"var = var["STRING"];FI"if var then;F@ZKI"end;Fi[[	@si-I"®          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING");Fi[	@vi6I"®          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING");Fi[	@yiI"®          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING");Fi[@ﬁGI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@(0i&I"=    with_temp_folder do |arglist|
      TARGET_FOLDER.install(["STRING", "STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(Dir["STRING"]);Fi[	@(0i.I"-    with_temp_folder do |arglist|
      TARGET_FOLDER.install(Dir["STRING"])
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("STRING");Fi[	@(0i8I"-      system("STRING")
      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("STRING" => "STRING");Fi[I":assert((TARGET_FOLDER + "STRING").exist?.!, "STRING");FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@(0iI":    with_temp_folder do |arglist|
      TARGET_FOLDER.install("STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(["STRING", "STRING"]);Fi[	@(0iAI"v      TARGET_FOLDER.install("STRING" => "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("STRING" => "STRING", "STRING" => "STRING");Fi[	@(0iKI"X      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
      assert((TARGET_FOLDER + "STRING").exist?.!, "STRING")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("STRING");Fi[@‘W@’W@÷W@◊WI"!var.in_repo_expect("STRING");Fi[[	@§.i2I"D  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING");Fi[	@§.iDI"b  def function(arglist)
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var);Fi[	@§.iXI"b  def function(arglist)
    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var);Fi[@’W@÷W@◊W@fYI"+var.in_repo_expect("STRING", "STRING");Fi[[	@§.i3I"Q  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.pull!;Fi[	@§.iEI"Z    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!;Fi[	@§.iYI"Z    var = fixture("STRING")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING")
      var.in_repo_expect("STRING", "STRING")
      var.in_repo_expect("STRING", var)
      var.pull!;Fi[I"@assert_equal(-1, (version("STRING") <=> version("STRING")));FI"@assert_equal(-1, (version("STRING") <=> version("STRING")));FI"@assert_equal(-1, (version("STRING") <=> version("STRING")));FI"@assert_equal(-1, (version("STRING") <=> version("STRING")));FI"@assert_equal(-1, (version("STRING") <=> version("STRING")));Fi[[	@˚iI"}    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(0, (version("STRING") <=> version("STRING")))
    assert_equal(1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")));Fi[	@˚iI"|    assert_equal(0, (version("STRING") <=> version("STRING")))
    assert_equal(1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(1, (version("STRING") <=> version("STRING")));Fi[	@˚iI"n    assert_equal(1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(-1, (version("STRING") <=> version("STRING")))
    assert_equal(1, (version("STRING") <=> version("STRING")))
    assert_nil((version("STRING") <=> "STRING"));Fi[@(I"out("STRING");FI"out("STRING");FI"'if var["STRING"].!=("STRING") then;FI"newobj;Fi[[	@siI"‰              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING";Fi[	@vi(I"‰              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING";Fi[	@yiI"‰              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING";Fi[@(I"if var.!=(var) then;FI"XCell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var);FI"end;FI"end;Fi[[	@siÁI"—      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private;Fi[	@viI"⁄        var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private;Fi[	@yi÷I"—      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private;Fi[@(I"Fvar = (var + "STRING") if var and var.to_s.index("STRING").nil?.!;FI"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;FI"@var = @var;Fi[[	@siïI"      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@viêI"        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@yiÑI"      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[I"#sha1("STRING" => :snowleopard);FI"sha1("STRING" => :lion);FI"$sha1("STRING" => :mountainlion);FI"end;FI" ;Fi[[	@o itI"∂  end
  
  bottle do |arglist|
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING");Fi[	@o i˛I"¡  sha1("STRING")
  
  bottle do |arglist|
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING");Fi[	@o iI"ø  
  bottle do |arglist|
    version(1)
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING");Fi[@™Y@´YI"end;FI" ;FI"def function(arglist);Fi[[	@o iuI"∂  
  bottle do |arglist|
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end;Fi[	@o iˇI"∂  
  bottle do |arglist|
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end;Fi[	@o iI"¬  bottle do |arglist|
    version(1)
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end;Fi[@´YI"end;FI" ;FI"def function(arglist);FI"super("STRING");Fi[[	@o ivI"∑  bottle do |arglist|
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end;Fi[	@o i I"∑  bottle do |arglist|
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end;Fi[	@o iI"∞    version(1)
    sha1("STRING" => :snowleopard)
    sha1("STRING" => :lion)
    sha1("STRING" => :mountainlion)
  end
  
  def function(arglist)
    super("STRING")
  end
end;Fi[@(@0@Z:@[:I"var = (var + 1);Fi[[	@siåI"        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@viÜI"        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@yi{I"        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[@¥SI"#;F@µR@∂RI"#;Fi[[	@√iI"ˆ      (self.content or "STRING")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@ci I"      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@†i>I"ﬂ      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[@µR@∂RI"#;FI"# Returns nothing.;FI"def function(arglist);Fi[[	@√iI"    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin
        (self.content = File.read(File.join(var, var));Fi[	@ci"I",    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["STRING"] = "STRING" unless self.data.has_key?("STRING");Fi[	@†i@I",    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["STRING"] = "STRING" unless self.data.has_key?("STRING");Fi[I"QUERY = "STRING";FI" ;FI"def self.process(arglist);F@(T@)Ti[[	@”iI"      CSV.process
    end
    
    QUERY = "STRING"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |arglist|
        var = var[:title];Fi[	@÷iI"/require("yaml")
module Jekyll
  module MT
    QUERY = "STRING"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |arglist|
        var = var[:entry_title];Fi[	@‹iI"2require("yaml")
module Jekyll
  module TextPattern
    QUERY = "STRING"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "STRING")
      FileUtils.mkdir_p("STRING")
      var[QUERY].each do |arglist|
        var = var[:Title];Fi[@(I"!return ((var * @var) / 1000);FI"end;FI" ;FI"def function(arglist);Fi[[	@siLI"‰        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[	@viAI"Ÿ          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      SJISMultiCell(var, var, var, var, var, var, var);Fi[	@yi;I"‰        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[@(I"after_flush_writes;FI"@var = {};FI"end;FI" ;Fi[[	@g6iI"√            FileUtils.chmod(var, path(var))
          end
          var.rewind
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist);Fi[	@`iGI"∑          ensure
            var.rewind
          end)
        end
        after_flush_writes
        @var = {}
      end
      
      def function(arglist)
        for var in @var do;Fi[	@Ïi—I"™          ensure
            var.rewind
          end
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist);Fi[@(@ÂUI"newobj;F@"1I"out("STRING");Fi[[	@siI"      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var);Fi[	@viI"      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var);Fi[	@yiÙI"      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var);Fi[@Y0I"end;FI"end;FI"end;FI"end;Fi[[	@–iI"ß        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@”i%I"ß        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@‹iI"ß        File.open("STRING", "STRING") do |arglist|
          var.puts(var)
          var.puts("STRING")
          var.puts(var)
        end
      end
    end
  end
end;Fi[I"!if var["STRING"].nil?.! then;F@ºTI"	else;F@II"end;Fi[[	@siI"J          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end;Fi[	@vi"I"J          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end;Fi[	@yiI"J          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end;Fi[I"var = ("STRING" + var);FI")var["STRING"].each_pair do |arglist|;FI"8var = (var + ((("STRING" + var) + "STRING") + var));FI"end;F@BYi[[	@si*I"´          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"));Fi[	@vi3I"´          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"));Fi[	@yiI"´          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"));Fi[@(@ÂU@Z@"1@ÁUi[[	@siıI"      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!;Fi[	@vi˛I"      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!;Fi[	@yi‰I"      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!;Fi[@±'@≤'I"@var ||= {};FI"end;FI" ;Fi[[	@‚i#I"«    #
    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Flag the document as destroyed and return the atomic path.
    #;Fi[	@ñRi÷I"Ω    #
    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Set the session configuration options.
    #;Fi[	@ôRiI"∏      #
      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the database session.
      #;Fi[@(I"nil;FI"end;FI" ;FI"def function(arglist);Fi[[	@˜
iRI"      var = File.mtime(var)
      css_files.each do |arglist|
        return var if File.exists?(var) and (var > File.mtime(var))
      end
      nil
    end
    
    def function(arglist)
      remove(options[:cache_location])
      css_files.each { |arglist| remove(var) };Fi[	@iI"Ó    def function(arglist)
      if var.=~(SPRITE_IMPORTER_REGEX) then
        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@ iI"ˇ        init
        cells_rows.each_with_index do |arglist|
          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end;Fi[@(@9@K@KI"end;Fi[[	@»ifI"o      version("STRING") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end;Fi[	@’iNI"g      version("STRING") do |arglist|
        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end;Fi[	@ÿiI"9        end
        def function(arglist)
          define_helper(:instance, "STRING", "STRING", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end;Fi[@(@9I""STRING";FI"end;FI"def function(arglist);Fi[[	I"#data//homebrew_proj/bottles.rb;Ti,I"”def function(arglist)
  return 0 unless bottle_current?(var)
  (var.bottle.revision + 1)
end
def function(arglist)
  "STRING"
end
def function(arglist)
  var = (var.to_i > 0) ? ("STRING") : ("STRING")
  "STRING";Fi[	@€i3I"G      version("STRING") do |arglist|
        def self.active?(arglist)
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == 2) or ((::Sequel::MAJOR == 3) and (::Sequel::MINOR <= 13))))
        end
        def function(arglist)
          "STRING"
        end
        def function(arglist)
          "STRING"
        end;Fi[	@€i?I"F      version("STRING") do |arglist|
        def self.active?(arglist)
          defined? ::Sequel::MAJOR and ((::Sequel::MAJOR == 3) and ((::Sequel::MINOR >= 14) and (::Sequel::MINOR <= 23)))
        end
        def function(arglist)
          "STRING"
        end
        def function(arglist)
          "STRING"
        end;Fi[@±'@≤'I"@var.!.!;FI"end;FI" ;Fi[[	@  i"I"‹      #
      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the number of documents matching the query.
      #;Fi[	@  iÚI"–      #
      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the documents for cached queries.
      #;Fi[	@S,irI"˛    #
    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    
    # Extract a single id from the provided criteria. Could be in an $and
    # query or a straight _id query.;Fi[@(I"
false;FI"end;FI" ;FI"def function(arglist);Fi[[	@˜
iCI"    def function(arglist)
      sass_files.zip(css_files).each do |arglist|
        return var if needs_update?(var, var)
      end
      false
    end
    
    def function(arglist)
      staleness_checker.stylesheet_needs_update?(var, File.expand_path(var), importer)
    end;Fi[	@ä	i^I"      var ||= "STRING"
      if var = self[var] and var.templates_directory then
        return File.directory?(File.join(var.templates_directory, var))
      end
      false
    end
    
    def function(arglist)
      var, var = var.split(/\//, 2)
      var = self[var];Fi[	@riNI"†        else
          return true
        end
      end
      false
    end
    
    def function(arglist)
      self.env["STRING"] = auth_hash
      call_app!;Fi[@±'@≤'@LI"end;FI"end;Fi[[	@LiI"      # @param [ Symbol ] name The name of the session config.
      # @param [ Hash ] config The configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	@LiI"      # @param [ Symbol, String ] name The db config key.
      # @param [ Hash ] config The hash configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	@LiI"      # @param [ Symbol, String ] name The db config key.
      # @param [ Hash ] config The hash configuration options.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[@±'@≤'@4RI"end;FI"end;Fi[[	@õCiI"…      #
      # @param [ Class ] klass The document class.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	@ûCiI"Ÿ      #
      # @param [ Class ] klass The class of the embedded document.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[	@°CiI"…      #
      # @param [ Class ] klass The embedded class.
      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :klass => (var)))
      end
    end
  end
end;Fi[@(I"(var << "STRING");FI"var.run;F@=P@Q=i[[	@UiNI"ˇ          (var << var)
          (var << var)
        end
      end
      (var << "STRING")
      var.run
      if var.success? then
        Logger.message("STRING")
      else
        raise(Errors::Archive::PipelineError, ("STRING" + var.error_messages));Fi[	@]i@I"            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages));Fi[	@Di@I"            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else
          raise(Errors::Database::PipelineError, ("STRING" + var.error_messages));Fi[@±'@≤'I"
false;FI"end;FI" ;Fi[[	@=ièI"®      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Is the object a number?
      #;Fi[	@=iõI"À      #
      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Remove the instance variable for the provided name.
      #;Fi[	@=i∫I"º      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Get the substitutable version of an object.
      #;Fi[@(I"@var = true;TI"end;FI"end;FI" ;Fi[[	@ÚiUI"          end
          Sass::Plugin.on_compilation_error do |arglist|
            Compass.configuration.run_stylesheet_error(var, var.message)
          end
          @var = true
        end
      end
      
      def function(arglist)
        configuration.to_sass_engine_options;Fi[	@Mi;I"          var.step_mother.with_hooks(self, skip_hooks?) do |arglist|
            skip_invoke! if failed?
            var.visit_steps(@var)
          end
          @var = true
        end
      end
      
      # Returns true if one or more steps failed
      def function(arglist);Fi[	@FièI"=            var = @var ? (:after) : (:failure)
            machine.callbacks[var].each { |arglist| var.call(object, context, self) }
          end
        end
        @var = true
      end
    end
    
    # Gets a hash of the context defining this unique transition (including
    # event, from state, and to state).;Fi[@˚F@≈;I"
begin;F@RI"yield);Fi[[	@èi6I"      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING");Fi[	@èiUI"      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield)
        ensure
          Threaded.exit_execution("STRING");Fi[	@èiÆI"        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("STRING")
            yield)
          ensure
            Threaded.exit_execution("STRING");Fi[I"# @since 2.2.0;F@ÙQ@ RI"end;FI" ;Fi[[	@˘Qi¶I"Ê      #
      # @return [ Hash ] The conflicting pull operations.
      #
      # @since 2.2.0
      def function(arglist)
        conflicts["STRING"] ||= {}
      end
      
      # Get the conflicting push modifications.
      #;Fi[	@˘Qi≤I"Â      #
      # @return [ Hash ] The conflicting push operations.
      #
      # @since 2.2.0
      def function(arglist)
        conflicts["STRING"] ||= {}
      end
      
      # Get the conflicting set modifications.
      #;Fi[	@˘QiæI"ˇ      #
      # @return [ Hash ] The conflicting set operations.
      #
      # @since 2.2.0
      def function(arglist)
        conflicts["STRING"] ||= {}
      end
      
      # Get the push operations that would have conflicted with the sets.
      #;Fi[@≈Z@ÙQI"@var ||= {};FI"end;FI" ;Fi[[	@˘Qi÷I"‹      #
      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be pushed.
      #;Fi[	@˘Qi‚I"Ÿ      #
      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be set.
      #;Fi[	@˘QiÓI"€      #
      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the $pullAll operations or intialize a new one.
      #;Fi[I")var["STRING"].each_pair do |arglist|;F@1ZI"end;F@BYI"if var then;Fi[[	@si+I"ô          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end;Fi[	@vi4I"ô          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end;Fi[	@yiI"ô          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end;Fi[I"$#     include Mongoid::Document;FI"#     embedded_in :person;FI"#   end;FI"#;F@Ê.i[[	@ri-I"R        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[	@riKI"R        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[	@rigI"O        #   end
        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[@£Q@§Q@•QI"end;FI" ;Fi[[	@] i+I"›      #
      # @return [ String ] The foreign_key plus =.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var ||= "STRING"
      end
      
      # Returns the index option of the relation.
      #;Fi[	@] iªI"      #
      # @return [ String ] The name plus "=".
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var ||= "STRING"
      end
      
      # Returns the name of the field in which to store the name of the class
      # for the polymorphic relation.;Fi[	@] iFI"‘      #
      # @return [ String ] The classified name.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var ||= "STRING"
      end
      
      # Get the name for the inverse field.
      #;Fi[@óQ@òQI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@	i'I"ä        # @example Validate the session has database.
        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionDatabase.new(var, var)) if no_database_or_uri?(var)
        end;Fi[	@	i6I"~        # @example Validate the session has hosts.
        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionHosts.new(var, var)) if no_hosts_or_uri?(var)
        end;Fi[	@	iFI"ê        # @example Validate the uri and options.
        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          if both_uri_and_standard?(var) then
            raise(Errors::MixedSessionConfiguration.new(var, var));Fi[I"# defined.;FI"#;FI"# @api private;FI"#;FI"%# @example Validate the options.;Fi[[	@	iQI"         end
        
        # Return true if the configuration has no database or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config)
        #;Fi[	@	ibI"˙        end
        
        # Return true if the configuration has no hosts or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_hosts_or_uri?(config)
        #;Fi[	@	isI"        end
        
        # Return true if the configuration has both standard options and a uri
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config)
        #;Fi[@(I"end.compact;FI"end;FI" ;FI"def function(arglist);Fi[[	@:iÉI"‹            StepMatch.new(var, var, var, var)
          else
            nil
          end
        end.compact
      end
      
      def function(arglist)
        (@var << JsStepDefinition.new(self, var, var))
      end;Fi[	@i~I"î        Pathname.new($1)
      else
        # do nothing
      end
    end.compact
  end
  
  def function(arglist)
    tapped_formula_for(:A)
  end;Fi[	I"=data//rspec_proj/spec/example/example_group_hierarchy.rb;Ti6I"¬            nil
          else
            nested_description_from(var)
          end
        end.compact
      end
      
      def function(arglist)
        var.description_args.join
      end;Fi[@(@G'@H'@I'I"###;Fi[[	@L-iûI"T        each do |arglist|
          var = var["STRING"].to_s.split(/\s+/)
          var["STRING"] = var.push(var).uniq.join("STRING")
        end
        self
      end
      
      ###
      # Remove the class attribute +name+ from all Node objects in the NodeSet.
      # If +name+ is nil, remove the class attribute from all Nodes in the;Fi[	@L-i≤I"Â          else
            var.delete("STRING")
          end
        end
        self
      end
      
      ###
      # Set the attribute +key+ to +value+ or the return value of +blk+
      # on all Node objects in the NodeSet.;Fi[	@L-iËI"‰          var = document.parse(var).first
          var.add_next_sibling(var)
          var.add_child(var)
        end
        self
      end
      
      ###
      # Convert this NodeSet to a string.
      def function(arglist);Fi[@OQ@PQ@QQI"#;F@5Qi[[	@diI"k        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@di)I"p        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@di?I"j        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[@(I"	end);FI"end;FI" ;FI"def function(arglist);Fi[[	@°iFI"          self.instance_variable_get(var).inject({}) do |arglist|
            var[var[0]] = var[1]
            var
          end
        end)
      end
      
      def function(arglist)
        @var, @var, @var, @var, @var = var
        prepare_default_proc;Fi[	@)
i8I"ï            var if (var / "STRING").executable?
          end
        end
      end
    end)
  end
  
  def function(arglist)
    prefix.nil?.!
  end;Fi[	@i#I"´        end
      else
        MacOS.pkgutil_info(FORGE_PKG_ID) =~ /version: (\d\.\d\.\d).+$/ and $1
      end
    end)
  end
  
  def function(arglist)
    "STRING"
  end;Fi[@(I"@var = var;FI"end;FI" ;FI"def function(arglist);Fi[[	@iUI"Î      def function(arglist)
        if Cucumber::WINDOWS and (var and ENV["STRING"].!) then
          var = var.gsub(/\//, "STRING")
        end
        @var = var
      end
      
      def function(arglist)
        "STRING"
      end;Fi[	@oiåI"‡        if var.!=(:failed) and @var.^(var) then
          @var = true
          return
        end
        @var = var
      end
      
      def function(arglist)
        return if @var
        var = nil unless @var[:source];Fi[	@√iyI"}      unless ((flat? and (closes_flat?(var).! and closes_flat?(@var).!)) or (var and ((@var.text[0] == "STRING") and var.full =~ /^#{@var.full[/^\s+/]}STRING/))) then
        return next_line if var.text.empty?
        handle_multiline(var)
      end
      @var = var
    end
    
    def function(arglist)
      var and (var.text.empty?.! and (not var.full =~ /^#{@var}/))
    end;Fi[@ LI"end;FI"end;FI"end;FI"end;Fi[[	@&LiI"Å      #
      # @since 2.2.0
      def function(arglist)
        super(compose_message("STRING", {}))
      end
    end
  end
end;Fi[	@)LiI"Å      #
      # @since 2.4.0
      def function(arglist)
        super(compose_message("STRING", {}))
      end
    end
  end
end;Fi[	@,LiI"Å      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", {}))
      end
    end
  end
end;Fi[@(@?[I"@var = var;FI"end;FI" ;Fi[[	@&i4I"ˇ              @var = var.with_indifferent_access.sort { |arglist| (var[0].to_i <=> var[0].to_i) }
            else
              @var = var
            end
            @var = var
            @var = var
          end
          
          private
          ;Fi[	@ÅiˆI"é    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage)
  ;Fi[	@iÎI"é    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage)
  ;Fi[@LI"end;FI"end;FI"end;FI"end;Fi[[	@LiI"ü      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	@LiI"ü      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	@LiI"ü      #
      # @since 3.0.0
      def function(arglist)
        super(compose_message("STRING", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[@(@á-I""STRING";FI"end;FI"end;Fi[[	@2iI"‚            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      
      def function(arglist);Fi[	@2i3I"‚            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      
      def function(arglist);Fi[	@2inI"œ            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          "STRING"
        end
      end
      
      if Object.const_defined?(:Magick) then;Fi[@(@á-@ODI"end;FI"end;Fi[[	@≠iI"˙        var.mobile do |arglist|
          render(:partial => "STRING", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	@wiI"„        var.json do |arglist|
          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	@æiHI"∂        end
      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[I"A# Get the value of the object as a mongo friendy sort value.;FI"#;FI"0# @example Get the object as sort criteria.;FI"#   object.__sortable__;FI"#;Fi[[	@⁄<iI"module Mongoid
  module Extensions
    module FalseClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 0.
      #;Fi[	@=i:I"Ì        "STRING"
      end
      
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #;Fi[	@›<iI"module Mongoid
  module Extensions
    module TrueClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 1.
      #;Fi[@(@á-I"nil;FI"end;FI"end;Fi[[	@FiI"ƒ            var = (var + 1)
            var = var.offset(var)[0]
            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end;Fi[	@Oi∞I"ñ            log.debug("STRING")
            (@var << var)
            nil
          end
        else
          nil
        end
      end
    end
  end;Fi[	@ô
iI"∏            "STRING"
          else
            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist);Fi[@PQ@QQI"#;F@5QI"#;Fi[[	@diI"]        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@di*I"e        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@di@I"b        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[@QQI"#;F@5QI"#;FI"# @since 3.0.0;Fi[[	@diI"X        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var);Fi[	@di+I"V        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|;Fi[	@diAI"Å        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!;Fi[@(@í@ì@îI"	####;Fi[[	@:iWI"9          var.each { |arglist| add_child_node(var) }
        else
          add_child_node(var)
        end
        var
      end
      
      ####
      # Replace this Node with +node_or_tags+.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@:ioI"          unlink
        else
          replace_node(var)
        end
        var
      end
      
      ####
      # Swap this Node for +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@:iÂI"t        if var.empty? and ((document.errors.length > var) and var.recover?) then
          var = Nokogiri::HTML::DocumentFragment.parse(var)
          var = var.children
        end
        var
      end
      
      ####
      # Set the Node's content to a Text node containing +string+. The string gets XML escaped, not interpreted as markup.
      def function(arglist);Fi[@(@í@ì@îI"##;Fi[[	@ÊiKI"	          rescue => var
            Logger.warn(Errors::Storage::Dropbox::CacheError.wrap(var, "STRING"))
          end
        end
        var
      end
      
      ##
      # Transfers the archived file to the specified Dropbox folder
      def function(arglist);Fi[	@ˇi£I"G            if var.invalid? then
              Logger.warn(("STRING" + "STRING"))
              return nil
            end
            var
          end
          
          ##
          # Creates a new LocalFile object using the given directory and line
          # from the md5 hash checkup. This object figures out the path,;Fi[	@Mi-I"    unless (var.user or var.password) then
      var.user = escape((ENV["STRING"] or ENV["STRING"]))
      var.password = escape((ENV["STRING"] or ENV["STRING"]))
    end
    var
  end
  
  ##
  # Returns true when proxy should by bypassed for host.
  def function(arglist);Fi[@(@)I"out("STRING");FI"out("STRING");F@áYi[[	@siI"‹            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"];Fi[	@vi'I"‹            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"];Fi[	@yiI"‹            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"];Fi[@(@)I"if var.!=(var) then;F@íYI"end;Fi[[	@siÊI"ﬂ        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  ;Fi[	@viÔI"€      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  ;Fi[	@yi’I"ﬂ        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  ;Fi[@(@)@ùY@ûYI"if (var == 1) then;Fi[[	@siîI"         var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[	@vièI"      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[	@yiÉI"         var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[@(@)@ˆYI"end;FI" ;Fi[[	@siKI"∫      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then;Fi[	@vi@I"ø          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then;Fi[	@yi:I"∫      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then;Fi[@:I"#;F@:@:I",re_define_method("STRING") do |arglist|;Fi[[	@⁄i⁄I"£        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("STRING") do |arglist|
            without_autobuild do |arglist|
              if (var.many? or get_relation(var, var)) then;Fi[	@Fi/I"]        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("STRING") do |arglist|
            var, var = parse_args(*var)
            var = Factory.build(var.klass, var, var);Fi[	@FiHI"]        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("STRING") do |arglist|
            var, var = parse_args(*var)
            var = Factory.build(var.klass, var, var);Fi[@(@)I"@var = [];FI"end;FI" ;Fi[[	@iI"‡              (var.width <=> var.width)
            else
              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist)
          send("STRING");Fi[	@g6i6I"ÿ            # do nothing
          rescue SystemCallError => var
            log("STRING")
          end
        end
        @var = []
      end
      
      def function(arglist)
        FileUtils.cp(path(var), var);Fi[	@ÏiﬁI"È            s3_bucket.objects[var.sub(/^\//, "STRING")].delete)
          rescue AWS::Errors::Base => var
            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist)
        begin;Fi[@(@)I"	true;FI"end;FI"end;Fi[[	@&i±I"∂              var.version_requirement = var.requirement
            end
            raise(var)
          end
        end
        true
      end
    end
    
    def function(arglist);Fi[	@A)iI"»            var = var
            var = var[var]
            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	@|i$I"ß              end
            else
              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end;Fi[I"3# @param [ Hash ] options The binding options.;FI"#;F@⁄P@€PI"#;Fi[[	@‡iI"í          #   name.person.bind(:continue => true)
          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[	@ÈiI"´          #   person.addresses.bind_one(address)
          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[	@Èi%I"ó          # @example Unbind the document.
          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[@⁄P@€PI"#;F@›PI"def function(arglist);Fi[[	@‡iI"Ø          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata
            base.parentize(target);Fi[	@ÈiI"Ø          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base)
            binding do |arglist|;Fi[	@Èi'I"†          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end;Fi[@(@)I"(var << "STRING");FI"var.run;F@=Pi[[	@UiMI"„        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "STRING")
      var.run
      if var.success? then
        Logger.message("STRING")
      else;Fi[	@]i?I"˜          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else;Fi[	@Di?I"˜          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "STRING")
        var.run
        if var.success? then
          Logger.message("STRING")
        else;Fi[@(@)I"	@var;FI"end;FI" ;Fi[[	@Pi5I"I            @var = []
            ([primary_key] + (column_names - [primary_key])).compact.each_with_index do |arglist|
              (@var << [var, "STRING"])
            end
          end
          @var
        end
        
        def function(arglist)
          Hash[column_names_with_alias.map { |arglist| [var, var[var]] }];Fi[	@?ièI"Ú        @var = var.dup
        var.each_pair do |arglist|
          @var[var.to_sym] = Paperclip::Style.new(var.to_sym, var.dup, self)
        end
      end
      @var
    end
    
    def function(arglist)
      var = @var[:only_process].dup;Fi[	@Ñi I"˛            @var.self_and_descendants.detect do |arglist|
              @var.allowed_to?("STRING".to_sym, var)
            end
          end
        end
        @var
      end
      
      # Yields to filter the activity scope
      def function(arglist);Fi[@(@)I"	else;F@ODI"end;Fi[[	@≠iI",        var.html { |arglist| render(:nothing => (true), :status => 201) }
        var.mobile do |arglist|
          render(:partial => "STRING", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  ;Fi[	@wiI"        var.mobile { |arglist| redirect_to(post_path(@var.post_id)) }
        var.json do |arglist|
          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  ;Fi[	@æiDI"æ        respond_to do |arglist|
          var.js do |arglist|
            render(:json => ({ :photo_id => (@var.id), :image_url => (@var.url(:thumb_large)), :image_url_medium => (@var.url(:thumb_medium)), :image_url_small => (@var.url(:thumb_small)), :author_id => (var) }), :status => 201)
          end
        end
      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422);Fi[@(@)@*I"out("STRING");FI"out("STRING");Fi[[	@siI"              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj;Fi[	@vi&I"              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj;Fi[	@yiI"              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj;Fi[@(@)@*I"	self;FI"end;Fi[[	@Ïi<I"ã        else
          Rails.logger.info("STRING")
          return
        end
      end
    end
    self
  end
  
  def function(arglist);Fi[	@⁄i‰I":                set_relation(var, get_relation(var, var).substitute(var.substitutable))
              else
                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        
        # Defines the setter method that allows you to set documents;Fi[	@ßi;I"H              var = var.value[0].value.first
              var.value[0].value = ["STRING"]
              var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["STRING"]), Node.new(:FUNCTION, ["STRING", var])])
            end
          end
        end
        self
      end
      
      # Find a node by type using +types+;Fi[@(@)@*I"return var;FI"end;Fi[[	@)iíI"ı              next if var.nil?
              var = var.instance_variable_get("STRING")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist);Fi[	@iÍ
I"|          (var << 65533)
          var = []
          var = 1
        end
      end
    end
    return var
  end
  
  #;Fi[	@i+I"‘          (var << var.&(255).chr)
          (var << (var >> 8).chr)
          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  
  # ====================================================;Fi[@(@)@*@€@9$i[[	@¿
i‹I"∑          rescue Exception
            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist);Fi[	@ûiI"˛            var
          else
            raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      
      # Returns whether or not the association should be validated as part of;Fi[	@πi–I"«          if var =~ /^(\w+)=(.*)$/ then
            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist);Fi[@…<I"end;FI" ;F@ÚK@ùSi[[	@IiI"m        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@PiI"m        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@ZiI"m        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[@ÁZI"#   end;FI"#;F@Ê.@Á.i[[	@ri.I"`        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@riLI"`        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@rihI"]        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[I"#   class Game;F@∏P@πPI"#   end;FI"#;Fi[[	@ri}I"ˆ        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[	@riñI"$        #     has_many :posts
        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.;Fi[	@riÀI"ˆ        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[@(@)@@ˆH@iSi[[	@‰i@I">          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@Ái9I">          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@Íi=I">          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[@í<I"#;FI"# @since 2.1.0;F@¢PI"
begin;Fi[[	@èi4I"Ù      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield);Fi[	@èiSI"Ù      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("STRING")
          yield);Fi[	@èi¨I"        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("STRING")
            yield);Fi[@(@)@I"extend(ClassMethods);FI" ;Fi[[	@ iRI"ç              self[nil]
            end
          end
        end
      end
      
      extend(ClassMethods)
      
      self.reset
    end;Fi[	@õi/I"∏        
        def function(arglist)
          File.expand_path(var.location)
        end
      end
      
      extend(ClassMethods)
      
      include(ExampleGroupMethods)
      ;Fi[	I"@data//state_machine_proj/state_machine/integrations/base.rb;TiYI"        # active
        def function(arglist)
          versions.each { |arglist| var.extend(var) if var.active? }
        end
      end
      
      extend(ClassMethods)
      
      def self.included(arglist)
        var.class_eval { |arglist| extend(ClassMethods) };Fi[@€CI"var;FI"end;FI" ;FI"def function(arglist);Fi[[	@i)I"Ê      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@i.I"√      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@i3I"√      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[@(@)@@∂?@∑?i[[	@‡i#I"7              else
                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[	@ÓiI"T            target.parentize(base)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[	@ıi$I"                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[@<I" ;F@<I" ;FI"def function(arglist);Fi[[	@€iI"–      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end;Fi[	@<iI"◊      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys
      end;Fi[	@·i
I"ı    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "STRING"
      end;Fi[@ïK@ºG@{:@|:@}:i[[	@Å:i>I"g    (categories(:child_2_1).left.should == 8)
    (categories(:child_2_1).right.should == 9)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text;Fi[	@Å:iII"P    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text;Fi[	@Å:iTI"=    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end
  it("STRING") do |arglist|
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var = Category.create(:name => "STRING")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var.name = nil;Fi[I"while (var < var) do;F@äO@ãO@åOI"var = (var + 1);Fi[[	@siCI"    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[	@vi3I"1    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then;Fi[	@yi2I"    var = @var["STRING"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[@áSI" ;FI"def function(arglist);FI"
super;F@CNi[[	@X"iI"*class RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("STRING", "STRING"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING";Fi[	@JNiI"
  
  argument(:actions, :type => :array, :default => ([]), :banner => "STRING")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING";Fi[	@MNiI"  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "STRING")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "STRING";Fi[@(@)@I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;Fi[[	@&iâI"/            var.blank? ? (var) : (var.convert(var))
          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@4iI"        else
          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@=i}I"Ú          return instance_variable_get("STRING")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[I"ListMixin.find(2).destroy;FI"iassert_equal([1, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id));FI"+assert_equal(1, ListMixin.find(1).pos);FI"+assert_equal(2, ListMixin.find(3).pos);FI"+assert_equal(3, ListMixin.find(4).pos);Fi[[	@ 5iÑI"  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    ListMixin.find(2).destroy
    assert_equal([1, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    assert_equal(1, ListMixin.find(1).pos)
    assert_equal(2, ListMixin.find(3).pos)
    assert_equal(3, ListMixin.find(4).pos)
    ListMixin.find(1).destroy
    assert_equal([3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id));Fi[	@ 5iØI"º  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    ListMixin.find(2).remove_from_list
    ListMixin.find(2).destroy
    assert_equal([1, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    assert_equal(1, ListMixin.find(1).pos)
    assert_equal(2, ListMixin.find(3).pos)
    assert_equal(3, ListMixin.find(4).pos)
  end
end;Fi[	@ 5i I"  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    ListMixin.find(2).destroy
    assert_equal([1, 3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id))
    assert_equal(1, ListMixin.find(1).pos)
    assert_equal(2, ListMixin.find(3).pos)
    assert_equal(3, ListMixin.find(4).pos)
    ListMixin.find(1).destroy
    assert_equal([3, 4], ListMixin.find(:all, :conditions => "STRING", :order => "STRING").map(&:id));Fi[I"&assert_equal("STRING", var.title);FI"<assert_equal("STRING", var.versions.first.version_type);FI"end;FI" ;FI"def function(arglist);Fi[[	@IRiUI"l    assert_equal("STRING", var.title)
    assert_equal("STRING", var.versions.first.version_type)
    assert(var.revert_to!(var.versions.first.version), "STRING")
    assert_equal("STRING", var.title)
    assert_equal("STRING", var.versions.first.version_type)
  end
  
  def function(arglist)
    var = locked_pages(:welcome)
    assert_equal("STRING", var.title);Fi[	@IRi^I"s    assert_equal("STRING", var.title)
    assert_equal("STRING", var.versions.first.version_type)
    assert(var.revert_to!(var.versions.first), "STRING")
    assert_equal("STRING", var.title)
    assert_equal("STRING", var.versions.first.version_type)
  end
  
  def function(arglist)
    var = SpecialLockedPage.create!(:title => "STRING")
    assert(var.new_record?.!);Fi[	@IRinI"O    var = locked_pages(:thinking)
    assert_equal("STRING", var.title)
    assert(var.revert_to!(var.versions.first.version), "STRING")
    assert_equal("STRING", var.title)
    assert_equal("STRING", var.versions.first.version_type)
  end
  
  def function(arglist)
    var = locked_pages(:thinking)
    var = LockedPage.find(var.id);Fi[@(@)@I"'initializer("STRING") do |arglist|;FI")config.after_initialize do |arglist|;Fi[[	@üi-I"\          rescue ::Mongoid::Errors::NoSessionHosts => var
            handle_configuration_error(var)
          end
        end
      end
      
      initializer("STRING") do |arglist|
        config.after_initialize do |arglist|
          unless (Rails.root.join("STRING", "STRING").file? or ::Mongoid.configured?) then
            puts("STRING");Fi[	@üi6I"Q            puts("STRING")
            puts("STRING")
          end
        end
      end
      
      initializer("STRING") do |arglist|
        config.after_initialize do |arglist|
          unless config.action_dispatch.rescue_responses then
            ActionDispatch::ShowExceptions.rescue_responses.update(Railtie.rescue_responses);Fi[	@üiSI"Ä          ActionDispatch::Reloader.to_prepare do |arglist|
            ::Mongoid.instantiate_observers
          end
        end
      end
      
      initializer("STRING") do |arglist|
        config.after_initialize do |arglist|
          if defined? Unicorn and Unicorn::HttpServer::START_CTX.empty?.! then
            ::Mongoid.default_session.disconnect if ::Mongoid.configured?;Fi[@(@)@@ ]I"7ActiveSupport.on_load(:active_record) do |arglist|;Fi[[	@∂i+I"4      ActiveSupport.on_load(:active_record) do |arglist|
        self.time_zone_aware_attributes = true
        self.default_timezone = :utc
      end
    end
    
    initializer("STRING") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|
        self.logger ||= ::Rails.logger
      end;Fi[	@∂iII"            end
          end
        end
      end
    end
    
    initializer("STRING") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|
        begin
          (var, ActiveSupport::Deprecation.behavior = ActiveSupport::Deprecation.behavior, :stderr;Fi[	@∂i`I"b          ActiveSupport::Deprecation.behavior = var
        end
        var.config.active_record.each { |arglist| send("STRING", var) }
      end
    end
    
    initializer("STRING") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|
        unless ENV["STRING"] then
          self.configurations = var.config.database_configuration;Fi[@(@)@@‹I"case var[:format];Fi[[	@2i’I"1          var[:indent] += var[:indent_increment]
          render_issues(var, var)
          var[:indent] -= var[:indent_increment]
        end
      end
      
      def function(arglist)
        case var[:format]
        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top]);Fi[	@2iﬁI"Î          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then
          var = "STRING";Fi[	@2iI"±          end
        else
          "STRING"
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then
          var = "STRING";Fi[@(@)@@‹I")if (@var["STRING"] == "STRING") then;Fi[[	@si°I"≤      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var)
    else;Fi[	@viúI"¥      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      SJISWrite(var, var, var, var)
    else;Fi[	@yiêI"≤      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBWrite(var, var, var, var)
    else;Fi[I"4categories(:child_2).save(:validate => (false));FI"5Category.left_and_rights_valid?.should(be_false);FI"end;FI"it("STRING") do |arglist|;FI"4Category.left_and_rights_valid?.should(be_true);Fi[[	@Å:iìI"å  it("STRING") do |arglist|
    Category.left_and_rights_valid?.should(be_true)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(:validate => (false))
    Category.left_and_rights_valid?.should(be_false)
  end
  it("STRING") do |arglist|
    Category.left_and_rights_valid?.should(be_true)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(:validate => (false));Fi[	@Å:iôI"Ø  it("STRING") do |arglist|
    Category.left_and_rights_valid?.should(be_true)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(:validate => (false))
    Category.left_and_rights_valid?.should(be_false)
  end
  it("STRING") do |arglist|
    Category.left_and_rights_valid?.should(be_true)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(:validate => (false));Fi[	@Å:i•I"æ  it("STRING") do |arglist|
    Category.left_and_rights_valid?.should(be_true)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(:validate => (false))
    Category.left_and_rights_valid?.should(be_false)
  end
  it("STRING") do |arglist|
    Category.left_and_rights_valid?.should(be_true)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(:validate => (false));Fi[I"0(categories(:child_2).should == var.parent);FI"6(categories(:child_2).id.should == var.parent_id);FI" var.left.should_not(be_nil);FI"!var.right.should_not(be_nil);FI"$Category.valid?.should(be_true);Fi[[	@Å:iÛI"e  end
  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("STRING") do |arglist|;Fi[	@Å:i˚I"_  end
  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("STRING") do |arglist|;Fi[	@Å:i'I"Ö  end
  it("STRING") do |arglist|
    var = categories(:child_2).children.create!(:name => "STRING")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  # create a new top-level node and move single-node top-level tree inside it.;Fi[@3]@4]@5]@6]I"end;Fi[[	@Å:iÙI"∞  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent => (categories(:child_2)));Fi[	@Å:i¸I"ú  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent_id => (nil));Fi[	@Å:i(I"Õ  it("STRING") do |arglist|
    var = categories(:child_2).children.create!(:name => "STRING")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  # create a new top-level node and move single-node top-level tree inside it.
  # create a new top-level node and move an entire top-level tree inside it.;Fi[@4]@5]@6]I"end;FI"it("STRING") do |arglist|;Fi[[	@Å:iıI"ƒ    var = Category.create!(:name => "STRING", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent);Fi[	@Å:i˝I"û    var = Category.create!(:name => "STRING", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("STRING") do |arglist|
    var = Category.create!(:name => "STRING", :parent_id => (nil))
    var.parent.should(be_nil);Fi[	@Å:iI"U    var = Category.create!(:name => "STRING", :parent_id => (nil))
    var.parent.should(be_nil)
    var.parent_id.should(be_nil)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("STRING") do |arglist|
    var = categories(:child_2_1)
    var.parent_id = categories(:child_3).id;Fi[I"assert(Category.valid?.!);FI"end;FI" ;FI"def function(arglist);FI"assert(Category.valid?);Fi[[	@à:i¶I"  def function(arglist)
    assert(Category.valid?)
    Category.update_all("STRING")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.update_all("STRING")
    assert(Category.valid?.!);Fi[	@à:i¨I"˘  def function(arglist)
    assert(Category.valid?)
    Category.update_all("STRING")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.delete(categories(:child_2).id)
    assert(Category.valid?);Fi[	@à:iπI"    assert(Category.valid?)
    categories(:top_level_2)["STRING"] = 0
    categories(:top_level_2).save
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    var = Category.root.to_text
    Category.update_all("STRING");Fi[@(@)@@‹I"var = @var;Fi[[	@siUI"Ã      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"];Fi[	@viJI"Œ      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"];Fi[	@yiDI"Ã      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"];Fi[@(@)@@‹@#Vi[[	@›iI"1      def function(arglist)
        it("STRING") do |arglist|
          expect(last_request.env["STRING"]).to(be_kind_of(Hash))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end;Fi[	@›iI":      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end;Fi[	@›iI":      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end;Fi[I"(assert_equal("STRING", var.message);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	I"Zdata//redmine_proj/plugins/open_id_authentication/test/open_id_authentication_test.rb;TiI"N    @var.expects(:logger).returns(mock(:error => (true)))
    @var.send(:authenticate_with_open_id, "STRING") do |arglist|
      assert(var.missing?)
      assert_equal("STRING", var.message)
    end
  end
  
  def function(arglist)
    @var.send(:authenticate_with_open_id, "STRING") do |arglist|
      assert(var.invalid?, "STRING");Fi[	@w]iI"  def function(arglist)
    @var.send(:authenticate_with_open_id, "STRING") do |arglist|
      assert(var.invalid?, "STRING")
      assert_equal("STRING", var.message)
    end
  end
  
  def function(arglist)
    var = mock
    var.expects(:begin).raises(Timeout::Error, "STRING");Fi[	@w]i)I"L    @var.expects(:logger).returns(mock(:error => (true)))
    @var.send(:authenticate_with_open_id, "STRING") do |arglist|
      assert(var.missing?)
      assert_equal("STRING", var.message)
    end
  end
  
  def function(arglist)
    @var.expects(:begin_open_id_authentication)
    @var.send(:authenticate_with_open_id, "STRING");Fi[I"H# * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.;FI"E# * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.;FI"#;FI"# Example:;FI"#;Fi[[	I"7data//redmine_proj/plugins/rfpdf/lib/core/rfpdf.rb;Ti=I"q  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text(x, y, header_left, :font_size => 10)
  	#;Fi[	@Ö]iUI"æ  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text_block(left_margin, 85, "question", left_margin, 280,
  #       :font_color => ReportHelper::COLOR_PALETTE[:dark_blue],;Fi[	@Ö]i‡I"p  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>18</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_title(left_margin, 60, 
  	#       "title:", ;Fi[I"var[2] = "STRING";FI"when "STRING" then;FI"var[2] = "STRING";FI"when "STRING" then;FI"var[2] = "STRING";Fi[[	@mQiI"Ë    var[1] = var.rows
    case var.mime_type
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING";Fi[	@mQiI"Í    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING";Fi[	@mQiI"◊    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    when "STRING" then
      var[2] = "STRING"
    else
      # do nothing;Fi[I"@var[var]["STRING"] = @var;F@ÁU@ËUI"Error("STRING") if var.!;FI"out(("STRING" + var));Fi[[	@si¯I"4    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]));Fi[	@viI"4    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]));Fi[	@yiÁI"4    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]));Fi[@ô]I"out("STRING");F@ÚUI"putType0(var);FI"	else;Fi[[	@siI"Ó    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var));Fi[	@viI"Ó    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var));Fi[	@yi˜I"Ó    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var));Fi[@˘=@b=I"out("STRING");FI"end;F@ 1i[[	@siÚI"·  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var;Fi[	@vi˚I"·  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var;Fi[	@yi·I"·  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var;Fi[@˘=@"1@ÁU@ËU@ö]i[[	@si˜I""      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING");Fi[	@vi I""      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING");Fi[	@yiÊI""      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING");Fi[@˘=@"1I"out("STRING");F@ÚUI"putType0(var);Fi[[	@siI"‰      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"];Fi[	@viI"‰      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"];Fi[	@yiˆI"‰      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"];Fi[@˘=I"var = var["STRING"];FI"var = "STRING";F@_J@`Ji[[	@si#I"4        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj;Fi[	@vi,I"4        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj;Fi[	@yiI"4        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj;Fi[@˘=I"var = ("STRING" + var);F@0Z@1ZI"end;Fi[[	@si)I"g          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then;Fi[	@vi2I"g          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then;Fi[	@yiI"g          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then;Fi[@˘=@˙=I"out("STRING");F@1?I"iout((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"));Fi[[	@viII"X    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    var = "STRING";Fi[	@yi/I"m    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    if (var["STRING"] == "STRING") then;Fi[	@iêI"X    out((("STRING" + (@var + 1).to_s) + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    var = "STRING";Fi[@(@)@@‹I"shutup do |arglist|;Fi[[	@?
i'I"        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING");Fi[	@?
i1I"        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING");Fi[	@?
i;I"        assert(var.include?("STRING").!, "STRING")
        assert(var.include?("STRING"), "STRING")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("STRING").brew do |arglist|
        var = read_file("STRING");Fi[@X@YI"end;FI" ;FI"def function(arglist);Fi[[	@Åi=I"Ã    out((var + "STRING"))
    out(("STRING" + var.to_s))
    out(sprintf("STRING", var, var))
    out("STRING")
    out("STRING")
  end
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	@Åi’I"    out("STRING")
    out("STRING")
    putresourcedict
    out("STRING")
    out("STRING")
  end
  
  def function(arglist)
    out(("STRING" + textstring(("STRING" + FPDF_VERSION))))
    out(("STRING" + textstring(@var))) unless @var.nil?;Fi[	@+i∫I"           newobj
          @var = self.n
          out("STRING")
          out("STRING")
          out("STRING")
        end
        
        def function(arglist)
          super
          putbookmarks;Fi[@X@Y@Ú]@Û]I"#;Fi[[	@i'I"¨    out((var + "STRING"))
    out(("STRING" + var.to_s))
    out(sprintf("STRING", var, var))
    out("STRING")
    out("STRING")
  end
  
  #
  	# Adds fonts
  	# putfonts;Fi[	@ißI"å    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
  
  #
  	# putimages
  	# @access protected;Fi[	@i˘I"å    out("STRING")
    out("STRING")
    putresourcedict
    out("STRING")
    out("STRING")
  end
  
  #
  	# putinfo
  	# @access protected;Fi[@X@Y@&II".out((("STRING" + (@var + 2)) + "STRING"));FI"if var["STRING"] then;Fi[[	@siI"õ          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"));Fi[	@viI"õ          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"));Fi[	@yiI"õ          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"));Fi[@X@Y@áYI"newobj;F@À]i[[	@si I"            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) };Fi[	@vi)I"            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) };Fi[	@yiI"            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) };Fi[@(@)@@‹I"if File.file?(var) then;Fi[[	@)iI"            [lines_around(var, var), var]
          else
            ["STRING", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("STRING")
            var = [0, (var - 3)].max;Fi[	@≥i%I"            [lines_around(var, var), var]
          else
            ["STRING", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("STRING")
            var = [0, (var - 3)].max;Fi[	@ú
i¢I"        else
          (@var = :custom
          self.differ_class = load_class(var, "STRING", "STRING"))
        end
      end
      
      def function(arglist)
        if File.file?(var) then
          @var = [File.open(var).read.split("STRING")].flatten
        else;Fi[@X@Y@˘.@˙.I"$out(("STRING" + var["STRING"]));Fi[[	@viTI"„      var = (var + (var["STRING"][var].to_s + "STRING"))
    end
    out((var + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING");Fi[	@iõI"„      var = (var + (var["STRING"][var].to_s + "STRING"))
    end
    out((var + "STRING"))
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    out("STRING")
    out("STRING");Fi[	@i}
I"˘    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out(("STRING" + var["STRING"]))
    var["STRING"].each do |arglist|
      out(((("STRING" + var.to_s) + "STRING") + var.to_s));Fi[@X@Y@1?@‡]I"3out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[[	@viJI"S    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    var = "STRING"
    var["STRING"].keys.sort.each do |arglist|;Fi[	@yi0I"O    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    if (var["STRING"] == "STRING") then
      var = "STRING";Fi[	@iëI"S    out("STRING")
    out("STRING")
    newobj
    out("STRING")
    out("STRING")
    out(("STRING" + var["STRING"]))
    out((((("STRING" + var["STRING"]["STRING"]) + "STRING") + var["STRING"]["STRING"].to_s) + "STRING"))
    out((("STRING" + (@var + 1).to_s) + "STRING"))
    var = "STRING"
    var["STRING"].keys.sort.each do |arglist|;Fi[@(@)@@‹I"var = var.value;Fi[[	@ëi3I"/      if var.respond_to?(:declare) then
        var.declare(:font_url, [:path])
        var.declare(:font_url, [:path, :only_path])
      end
    end
    
    def function(arglist)
      var = var.value
      return Sass::Script::String.new("STRING") if absolute_path?(var)
      var = if relative? then;Fi[	@ëiMI"P        var.declare(:image_url, [:path])
        var.declare(:image_url, [:path, :only_path])
        var.declare(:image_url, [:path, :only_path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_images_path)}STRING/ then
        var = $1;Fi[	@ëiI"U      if var.respond_to?(:declare) then
        var.declare(:generated_image_url, [:path])
        var.declare(:generated_image_url, [:path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_generated_images_path)}STRING/ then
        var = $1;Fi[@(@)@@‹I"puts("STRING");Fi[[	@i I"Œ          Compass.configuration.serialize)
        ensure
          Compass.configuration.project_path = var
        end
      end
      
      def function(arglist)
        puts("STRING")
      end
    end;Fi[	@
iÄI"¢      Homebrew.dump_build_config)
    ensure
      $stdout = var
    end
  end
  
  def function(arglist)
    puts("STRING")
    puts("STRING")
    puts("STRING");Fi[	@ irI"“      puts("STRING") and puts(`rm -rf #{var}`) if ($?.exitstatus == 0)
      puts("STRING") if ($?.exitstatus == 0)
      exit($?.exitstatus)
    end
  end
  
  def function(arglist)
    puts("STRING")
  end
  ;Fi[@X@Y@ZI"end;FI"end;Fi[[	@si^I"z    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@vi_I"z    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[	@yiII"z    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
    out("STRING")
  end
end;Fi[@(@)@@‹I"@var ||= [];Fi[[	@ÌiÇI"£              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= []
        (@var << [var, var])
      end;Fi[	@LiI"¸        unless @var.has_key?(var) then
          @var[var] = var
          scenarios.push(var)
        end
      end
      
      def function(arglist)
        @var ||= []
        var ? (@var.select { |arglist| (var.status == var) }) : (@var)
      end;Fi[	@—i8I"É      var.new(var)
    else
      Version.new(var)
    end
  end
  
  def function(arglist)
    @var ||= []
    (@var << var)
  end;Fi[@X@1I"end;FI"end;FI"out("STRING");Fi[[	@siI"            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then;Fi[	@vi%I"            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then;Fi[	@yiI"            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then;Fi[@X@1@Y^@Z^I"end;Fi[[	@si3I"            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist);Fi[	@vi<I"            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist);Fi[	@yi"I"            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  
  def function(arglist);Fi[@X@1@Y^@Z^I" ;Fi[[	@Åi∑I"        var = @var ? (Zlib::Deflate.deflate(var["STRING"])) : (var["STRING"])
        out((((("STRING" + var) + "STRING") + var.length.to_s) + "STRING"))
        putstream(var)
        out("STRING")
      end
    end
  end
  
  def function(arglist)
    @var.each_value do |arglist|;Fi[	@iœI"Ó        var = @var ? (gzcompress(var["STRING"])) : (var["STRING"])
        out((((("STRING" + var) + "STRING") + var.length.to_s) + "STRING"))
        putstream(var)
        out("STRING")
      end
    end
  end
  
  #
  	# putxobjectdict;Fi[	@+i«I"≈          super
          if (@var.size > 0) then
            out("STRING")
            out("STRING")
          end
        end
      end
      
      # fetch row values
      def function(arglist);Fi[@XI"var = fopen(var, "STRING");FI"putstream(fread(var, var));FI"fclose(var);FI"out("STRING");Fi[[	@si I"C      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|;Fi[	@vi	I"C      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|;Fi[	@yiÔI"A      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) if var["STRING"].nil?.!
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|;Fi[@X@ÚUI"putType0(var);FI"	else;FI"var = var["STRING"];Fi[[	@si	I"    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then;Fi[	@viI"    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then;Fi[	@yi¯I"    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then;Fi[@X@®VI"	else;F@#II"out("STRING");Fi[[	@siI"Y        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"));Fi[	@viI"Y        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"));Fi[	@yiˇI"Y        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"));Fi[@X@&I@^@^@ªTi[[	@siI"k        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else;Fi[	@viI"k        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else;Fi[	@yiI"k        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else;Fi[@X@áYI"newobj;F@À]@Ã]i[[	@si!I"%          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"));Fi[	@vi*I"%          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"));Fi[	@yiI"%          end
        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"));Fi[@X@.?@’]@0Z@1Zi[[	@si(I"j          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"];Fi[	@vi1I"j          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"];Fi[	@yiI"j          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"];Fi[@(@@ˆH@iS@ËJi[[	@‰iAI"¯        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@Ái:I"¯        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@Íi>I"¯        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[@(@@sS@tS@uSi[[	@‰i8I"v      # Initializes dynamic states
      def function(arglist)
        define_helper(:instance, "STRING", "STRING", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[	@Ái1I"a      def function(arglist)
        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[	@Íi5I"p      def function(arglist)
        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[@(@I"L# Describes the current validation errors on the given object.  If none;FI"F# are specific, then the default error is interpeted as a "halt".;FI"def function(arglist);Fi[[	@·i#I"ô          var = default_error_message_options(var, var, var)
          var.errors.add(var, var, var.merge(var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        var.errors.empty? ? ("STRING") : ((var.errors.full_messages * "STRING"))
      end;Fi[	@#iI"s        if supports_validations? then
          var.errors.add(self.attribute(var), generate_message(var, var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "STRING";Fi[	@ #i I"µ      # Adds a validation error to the given object
      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        var.errors.empty? ? ("STRING") : ((var.errors.full_messages * "STRING"))
      end;Fi[@(@@ÚK@ùS@ûSi[[	@IiI"m        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[	@PiI"n        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.;Fi[	@ZiI"m        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[@(@I" # Unbind a single document.;FI"#;FI"$# @example Unbind the document.;Fi[[	@ÈiI"                var.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.addresses.unbind_one(document)
          #;Fi[	@iI"1          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| bind_from_relational_parent(var) }
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.posts.unbind_one(document)
          #;Fi[	@iI";              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.preferences.unbind_one(document)
          #;Fi[@âK@äK@ãK@åKI"end;Fi[[	@siI"0  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist);Fi[	@viI"0  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist);Fi[	@yiI"0  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist);Fi[@äK@ãK@åKI"end;FI" ;Fi[[	@siI"@  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths;Fi[	@viI"=  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist)
    var = "STRING";Fi[	@yiI"?  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths;Fi[@äK@ãKI"end;FI" ;FI"def function(arglist);Fi[[	@siI"P  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths
    var = "STRING";Fi[	@viI"P  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist)
    var = "STRING"
    var = SJIS_widths;Fi[	@yiI"O  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths
    var = "STRING";Fi[I"(AddCIDFonts(var, var, cw, var, var);FI"end;FI" ;FI"def function(arglist);FI")if (@var["STRING"] == "STRING") then;Fi[[	@si3I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "STRING"
    var = { "STRING" => "STRING", "STRING" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      return GetMBStringWidth(var)
    else;Fi[	@vi#I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "STRING"
    var = { "STRING" => "STRING", "STRING" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      return GetSJISStringWidth(var)
    else;Fi[	@yi"I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "STRING"
    var = { "STRING" => "STRING", "STRING" => 1 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      return GetMBStringWidth(var)
    else;Fi[I"return super(var);FI"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@si:I"∫    if (@var["STRING"] == "STRING") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"];Fi[	@vi*I"º    if (@var["STRING"] == "STRING") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"];Fi[	@yi)I"∫    if (@var["STRING"] == "STRING") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"];Fi[@äO@ãO@åOI"var = (var + 1);FI"	else;Fi[[	@siDI"    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[	@vi4I"4    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500);Fi[	@yi3I"    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[@ˆYI"end;FI" ;FI"def function(arglist);FI")if (@var["STRING"] == "STRING") then;Fi[[	@siMI"“        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@viBI"»        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@yi<I"“        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[@hII"end;FI"end;FI" ;FI"def function(arglist);Fi[[	@siTI"‹    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@viII"ﬁ    if (@var["STRING"] == "STRING") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@yiCI"‹    if (@var["STRING"] == "STRING") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[@≈D@–?@—?I"var = var.length;F@Ui[[	@si\I".    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then;Fi[	@viQI".    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then;Fi[	@yiKI".    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then;Fi[@–?@—?@“?@UI"var = 0;Fi[[	@si]I"8    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then;Fi[	@viRI"8    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then;Fi[	@yiLI"8    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then;Fi[@(@@®SI"#;F@™Si[[	@cisI"J    # Returns the Hash representation of this Page.
    def function(arglist)
      self.data.deep_merge("STRING" => (File.join(@var, self.url)), "STRING" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.;Fi[	@†iøI"Q    def function(arglist)
      var = { "STRING" => ({ "STRING" => (related_posts(var["STRING"]["STRING"])) }), "STRING" => (self.to_liquid) }.deep_merge(var)
      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.;Fi[	@» iI"Ì    # Returns source file path.
    def function(arglist)
      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.;Fi[@(@@¥SI"#;F@µRi[[	@√iI"    # Returns the contents as a String.
    def function(arglist)
      (self.content or "STRING")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@ciI"¸      @var = var
      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@†i<I"      if self.categories.empty? then
        self.categories = self.data.pluralized_array("STRING", "STRING")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[@–?@ŸT@iUI"	next;FI"end;Fi[[	@si–I"r            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var);Fi[	@yiøI"r            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var);Fi[	@Åi∞I"e            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var)
          self.Cell(var, var, var[var, (var - var)], 0, 2, "STRING", 0, var);Fi[@UI"var = 0;FI"if var then;F@)I"var = "STRING";Fi[[	@si`I"&    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING";Fi[	@viUI"&    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING";Fi[	@yiOI"&    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("STRING", "STRING")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "STRING")
    var = 0
    if var then
      if (var == 1) then
        var = "STRING"
        var = "STRING"
        var = "STRING";Fi[@(@@ SI" ;F@ÃSi[[	@fiI"⁄      
      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[	@iI"      
      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[	@PiI"œ      
      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[@(@@÷S@◊S@ÿSi[[	@∏iI"ä        # depot.
        def function(arglist)
          "STRING"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[	@∏iI"ﬂ        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[	@∏i I"ﬂ        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[@(@@‚S@„S@‰Si[[	@§i@I"          return var unless (:head == var)
          var = scm("STRING", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[	@∏i7I"B          return var if var.to_s =~ /^\d+$/
          var = scm(authentication, :changes, "STRING", "STRING", "STRING")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[	@Ωi<I"2          var = YAML.load(var)
          raise("STRING") unless Hash.===(var)
          [(var["STRING"] or 0).to_i, (var["STRING"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[@TJ@UJ@VJI"end;FI"end;Fi[[	@siiI"'        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@vi^I"'        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@yiXI"'        var = "STRING"
      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0;Fi[@UJ@VJI"end;FI"end;FI"var = -1;Fi[[	@sijI"      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@vi_I"      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@yiYI"      else
        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[@VJI"end;FI"end;FI"var = -1;FI"var = 0;Fi[[	@sikI"        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@vi`I"        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@yiZI"        var = "STRING"
        var = "STRING" unless var.to_s.index("STRING").nil?
        var = (var + "STRING") unless var.to_s.index("STRING").nil?
        var = var.to_s.index("STRING") ? ((var + "STRING")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[@(@I"H# Returns the command that will check out the given revision to the;FI"# given destination.;FI"def function(arglist);Fi[[	@§iI"7        # committed revision.
        def function(arglist)
          :head
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, "STRING", revswitch(var), repository, var)
        end;Fi[	@ßiI"Ç        # repository.
        def function(arglist)
          "STRING"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          [prep_destination(var), scm(verbose, cvs_root, :checkout, cvs_revision(var), cvs_destination(var), variable(:scm_module))].join("STRING")
        end;Fi[	@ΩiI"\        # repository.
        def function(arglist)
          "STRING"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, arguments, arguments(:checkout), verbose, authentication, "STRING", repository, var)
        end;Fi[@(@I"alias :== :eql?;FI" ;FI"def function(arglist);Fi[[	@/i3I"S      
      def function(arglist)
        Git.===(var) and ((uri == var.uri) and ((ref == var.ref) and ((branch == var.branch) and ((name == var.name) and ((version == var.version) and (submodules == var.submodules))))))
      end
      
      alias :== :eql?
      
      def function(arglist)
        var = if local? then
          path;Fi[	@7i=I":      
      def function(arglist)
        var.instance_of?(Path) and ((path.expand_path(Bundler.root) == var.path.expand_path(Bundler.root)) and (version == var.version))
      end
      
      alias :== :eql?
      
      def function(arglist)
        File.basename(path.expand_path(Bundler.root).to_s)
      end;Fi[	@<i)I"       
      def function(arglist)
        Rubygems.===(var)
      end
      
      alias :== :eql?
      
      def function(arglist)
        { "STRING" => (@var.map { |arglist| var.to_s }) }
      end;Fi[@(@I"alias :create :insert_sql;FI" ;FI"def function(arglist);Fi[[	@Åi¡I"Ã      def function(arglist)
        super
        (var or @var.last_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        execute(to_sql(var, var), var)
      end;Fi[	@ÑiI"Ò      def function(arglist)
        super(var, var)
        (var or @var.insert_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        var = 0
        exec_query(var, var, var) { |arglist| var = var };Fi[	@§i$I"“      def function(arglist)
        super
        (var or @var.last_insert_row_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        exec_query(var, var).rows
      end;Fi[@(@I"J# Disconnects from the database if already connected. Otherwise, this;FI"# method does nothing.;FI"def function(arglist);Fi[[	@ˇi¡I"      def function(arglist)
        clear_cache!
        reset_transaction
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        clear_cache!
        reset_transaction;Fi[	@ÑiØI"Û        super
        disconnect!
        connect
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super
        @var.close rescue nil;Fi[	@§iìI"Ú      
      def function(arglist)
        @var.!=(false)
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super
        @var = false;Fi[@tAI"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;Fi[[	@siwI"G      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@vilI"5      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@yifI"G      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "STRING") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[@tAI"	else;F@QI@´3I"end;Fi[[	@siàI"Ç      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@viÇI"t      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@yi|I"Ç      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[@tA@´3I"end;FI"var = -1;FI"var = var;Fi[[	@siäI"b          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@viÑI"T          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@yi~I"b          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[@(@@∑
@6KI"end;Fi[[	@¨iPI"±        else
          "STRING"
        end
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist);Fi[	@⁄i1I"Á      
      def function(arglist)
        @var.nil? ? (true) : ((@var == var.method(var).arity))
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist);Fi[	@Øi6I"æ      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
      
      def function(arglist)
        @var.nil? ? ("STRING") : ("STRING")
      end
    end
    ;Fi[@íV@'CI"@var = @var;F@)C@*Ci[[	@siÀI"à      var = var if (var.! or (var.chr == "STRING"))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[	@vi”I"3        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var);Fi[	@yi∫I"à      var = var if (var.! or (var.chr == "STRING"))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[@(@@∑
I"split_words(@var);FI"end;Fi[[	@ûi7I"≈      
      def function(arglist)
        @var.collect { |arglist| var.inspect }
      end
      
      def function(arglist)
        split_words(@var)
      end
      
      def function(arglist);Fi[	@ûiâI"π      def function(arglist)
        var.to_s =~ /^(be_(an?_)?)(.*)/
        return [$1, $3]
      end
      
      def function(arglist)
        split_words(@var)
      end
    end
    ;Fi[	@ ixI"·      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end
      
      def function(arglist)
        split_words(@var)
      end
      
      def function(arglist);Fi[@ùY@ûYI"if (var == 1) then;FI"@var = @var;FI"	else;Fi[[	@siñI"        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@viëI"        var = var if (var >= 128)
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@yiÖI"        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "STRING") if var and var.to_s.index("STRING").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[@(@@∑
I"out("STRING");F@Å?i[[	@si7I"Í        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[	@vi@I"Í        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[	@yi&I"Í        end
      end
    end
  end
  
  def function(arglist)
    out("STRING")
    out(((("STRING" + var["STRING"]) + "STRING") + var["STRING"]))
    out(("STRING" + var["STRING"]))
    out((("STRING" + (@var + 1).to_s) + "STRING"));Fi[@(@@∑
@âK@äKi[[	@siI"¸    var = (@var.length + 1)
    var = var.gsub("STRING", "STRING")
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var);Fi[	@viI"ˇ    Error("STRING") unless @var[var].nil?
    var = (@var.length + 1)
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -120, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var);Fi[	@yiI"¸    var = (@var.length + 1)
    var = var.gsub("STRING", "STRING")
    @var[var] = { "STRING" => (var), "STRING" => "STRING", "STRING" => (var), "STRING" => -130, "STRING" => 40, "STRING" => (var), "STRING" => (var), "STRING" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "STRING", var, var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var)
    AddCIDFont(var, "STRING", (var + "STRING"), var, var, var);Fi[@(@@∑
I"var = Scoped.root;FI"var = var.children.first;Fi[[	@à:i€I"ê    assert(categories(:child_2_1).is_ancestor_of?(categories(:child_2)).!)
    assert(categories(:child_1).is_ancestor_of?(categories(:child_2)).!)
    assert(categories(:child_1).is_ancestor_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_ancestor_of?(var))
    var.update_attribute(:organization_id, "STRING");Fi[	@à:iıI"ò    assert(categories(:child_2).is_descendant_of?(categories(:child_2_1)).!)
    assert(categories(:child_2).is_descendant_of?(categories(:child_1)).!)
    assert(categories(:child_1).is_descendant_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_descendant_of?(var))
    var.update_attribute(:organization_id, "STRING");Fi[	@à:i˝I":    assert(var.is_or_is_descendant_of?(var))
    var.update_attribute(:organization_id, "STRING")
    assert(var.is_or_is_descendant_of?(var).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.same_scope?(var))
    var.update_attribute(:organization_id, "STRING");Fi[@(@@∑
@#V@ñKi[[	@›iI"        it("STRING") do |arglist|
          expect(last_request.env["STRING"]).to(be_kind_of(Hash))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end;Fi[	@›iI"(        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end;Fi[	@›iI"(        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("STRING") do |arglist|
          expect((last_request.env["STRING"] or {})["STRING"]).to(eq(var))
        end
      end;Fi[@(@@∑
@¨HI"var;Fi[[	@i+I"√      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@i0I"√      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@i5I"√      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[@ûA@&B@ŸT@iUI"	next;Fi[[	@siœI"H          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@yiæI"H          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@ÅiØI"8          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var);Fi[@(@@∑
@£HI"var;Fi[[	@i÷I"⁄      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@i€I"π      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@i‡I"π      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[@÷BI"	else;F@/I@0II"end;Fi[[	@si÷I"i            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@viﬁI"[            next
          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@yi≈I"i            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[@÷B@0II"end;FI"var = -1;FI"var = var;Fi[[	@siÿI"u          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@vi‡I"g          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@yi«I"u          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "STRING", var, var)
          var = (var[var].chr == "STRING") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[@(@@∑
@8LI"end;Fi[[	@&i=I"Æ  
  def function(arglist)
    (alpha? or (beta? or rc?))
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist);Fi[	@&iAI"¬  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist);Fi[	@&iEI"¬  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist)
    to_a.any? { |arglist| (var.to_s == "STRING") }
  end
  
  def function(arglist);Fi[I"if var.!=(var) then;F@íYI"end;FI"end;FI" ;Fi[[	@siËI"…        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  ;Fi[	@viÒI"√        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  ;Fi[	@yi◊I"…        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  ;Fi[@íYI"end;FI"end;FI" ;FI"private;Fi[[	@siÈI"π      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@viÚI"π      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@yiÿI"π      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "STRING", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[@b=I"out("STRING");FI"end;F@ 1I"newobj;Fi[[	@siÛI"     var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING");Fi[	@vi¸I"     var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING");Fi[	@yi‚I"     var = @var
    @var.each do |arglist|
      newobj
      out((("STRING" + var) + "STRING"))
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING");Fi[@ÁU@ËU@ö]@õ]I"+out("STRING") if (var[-2] == "STRING");Fi[[	@si˘I"y    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?;Fi[	@viI"y    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?;Fi[	@yiËI"w    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) if var["STRING"].nil?.!;Fi[@ËU@ö]@õ]@û`@ÃCi[[	@si˙I"m      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING");Fi[	@viI"m      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING");Fi[	@yiÈI"k      newobj
      @var[var]["STRING"] = @var
      var = (FPDF_FONTPATH + var) if defined("STRING")
      var = filesize(var)
      Error("STRING") if var.!
      out(("STRING" + var))
      out("STRING") if (var[-2] == "STRING")
      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) if var["STRING"].nil?.!
      out("STRING");Fi[@õ]@óII"out("STRING");F@®VI"	else;Fi[[	@siI".        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING");Fi[	@viI".        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING");Fi[	@yi˝I".        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING");Fi[@ÃC@ÕC@ŒC@&I@^i[[	@siI"p          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then;Fi[	@viI"p          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then;Fi[	@yiI"p          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then;Fi[@(@@∑
@DLI"var.write("STRING");Fi[[	@§0iàI"class TextExecutableTests < Test::Unit::TestCase
  def function(arglist)
    (HOMEBREW_PREFIX / "STRING").unlink
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@§0iòI"    assert_equal([], var.archs)
    assert((var.arch == :dunno))
    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[	@§0i®I"    assert_equal([], var.archs)
    assert((var.arch == :dunno))
    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "STRING")
    var.write("STRING")
    assert(var.universal?.!)
    assert(var.i386?.!);Fi[@(@@∑
@≠LI"end;Fi[[	@
iNI"Ó  def function(arglist)
    return "STRING" unless MacOS::XQuartz.installed?
    return ("STRING" + describe_path(MacOS::XQuartz.prefix))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist);Fi[	@
iRI"¢  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist);Fi[	@
iVI"¢  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist)
    describe_path(which("STRING"))
  end
  
  def function(arglist);Fi[@v^@w^I"fclose(var);FI"out("STRING");FI"end;Fi[[	@siI"#      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@vi
I"#      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@yiI"!      out(("STRING" + var["STRING"]))
      out((("STRING" + var["STRING"]) + "STRING")) if var["STRING"].nil?.!
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj;Fi[@w^I"fclose(var);FI"out("STRING");FI"end;FI" @var.each_pair do |arglist|;Fi[[	@siI"      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var;Fi[	@viI"      out((("STRING" + var["STRING"]) + "STRING")) unless var["STRING"].nil?
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var;Fi[	@yiÒI"      out((("STRING" + var["STRING"]) + "STRING")) if var["STRING"].nil?.!
      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var;Fi[I"fclose(var);FI"out("STRING");FI"end;F@·`I"newobj;Fi[[	@siI"Â      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING");Fi[	@viI"Â      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING");Fi[	@yiÚI"Â      out("STRING")
      var = fopen(var, "STRING")
      putstream(fread(var, var))
      fclose(var)
      out("STRING")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["STRING"] = @var
      out("STRING");Fi[@ÚUI"putType0(var);FI"	else;F@Ñ^@ñIi[[	@si
I"
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING");Fi[	@viI"
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING");Fi[	@yi˘I"
      newobj
      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING");Fi[@ÚUI"out("STRING");F@®VI"	else;F@#Ii[[	@siI"0      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING");Fi[	@viI"0      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING");Fi[	@yi˛I"0      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING");Fi[I"putType0(var);FI"	else;F@Ñ^@ñI@óIi[[	@siI">      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING");Fi[	@viI">      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING");Fi[	@yi˙I">      @var[var]["STRING"] = @var
      out("STRING")
      if (var["STRING"] == "STRING") then
        putType0(var)
      else
        var = var["STRING"]
        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING");Fi[@®VI"	else;F@#II"out("STRING");FI"out("STRING");Fi[[	@siI"q        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"));Fi[	@viI"q        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"));Fi[	@yi I"q        out(("STRING" + var))
        if (var["STRING"] == "STRING") then
          out("STRING")
          out("STRING") if var.!=("STRING") and var.!=("STRING")
        else
          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"));Fi[@&I@^@^@ªT@ºTi[[	@siI"z          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING");Fi[	@viI"z          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING");Fi[	@yiI"z          out(("STRING" + var["STRING"]))
          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING");Fi[@^@^@ªT@ºTI"	else;Fi[[	@siI"`          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end;Fi[	@vi I"`          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end;Fi[	@yiI"`          out("STRING")
          out("STRING")
          out((("STRING" + (@var + 1)) + "STRING"))
          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end;Fi[@ºTI"	else;F@II"end;FI"end;Fi[[	@siI",          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING");Fi[	@vi#I",          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING");Fi[	@yi	I",          out((("STRING" + (@var + 2)) + "STRING"))
          if var["STRING"] then
            if var["STRING"].nil?.! then
              out((("STRING" + (var + var["STRING"])) + "STRING"))
            else
              out("STRING")
            end
          end
        end
        out("STRING");Fi[@áYI"newobj;F@À]@Ã]@_Ji[[	@si"I"/        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING");Fi[	@vi+I"/        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING");Fi[	@yiI"/        end
        out("STRING")
        out("STRING")
        if var["STRING"].!=("STRING") then
          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING");Fi[@_J@`JI"out("STRING");FI"newobj;F@’]i[[	@si&I"m          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var));Fi[	@vi/I"m          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var));Fi[	@yiI"m          newobj
          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var));Fi[@`JI"out("STRING");FI"newobj;F@’]@0Zi[[	@si'I"j          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end;Fi[	@vi0I"j          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end;Fi[	@yiI"j          var = var["STRING"]
          var = "STRING"
          32.upto(255) { |arglist| var = (var + (var[var.chr] + "STRING")) }
          out((var + "STRING"))
          out("STRING")
          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end;Fi[@`J@NaI"end;FI"end;FI"end;Fi[[	@si2I"          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  ;Fi[	@vi;I"          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  ;Fi[	@yi!I"          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end
  end
  ;Fi[@1ZI"end;F@BYI"if var then;F@ZKi[[	@si,I"°          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"));Fi[	@vi5I"°          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"));Fi[	@yiI"°          newobj
          var = ("STRING" + var)
          var["STRING"].each_pair do |arglist|
            var = (var + ((("STRING" + var) + "STRING") + var))
          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"));Fi[@ZKI"end;F@\KI"out("STRING");FI"end;Fi[[	@si0I"6          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end;Fi[	@vi9I"6          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end;Fi[	@yiI"6          end
          var = var["STRING"]
          if var then
            var = (var + (((("STRING" + ((var["STRING"] == "STRING") ? ("STRING") : ("STRING"))) + "STRING") + @var[var]["STRING"]) + "STRING"))
          end
          out((var + "STRING"))
          out("STRING")
        end
      end
    end;Fi[@(@@∑
@≈L@∆Li[[	@ÍijI"{    var = { "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING", "STRING" => "STRING" }
    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[	@ÍisI"–    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[	@Íi|I"–    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "STRING")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[@(@@∑
@—LI"end;Fi[[	@˜	i9I"⁄  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@◊i*I"ß  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@‰i1I"¬  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[@(@@∑
I"Cucumber.logger;FI"end;Fi[[	@åi4I"§          end
        end
        raise(TagExcess.new(var)) if var.any?
      end
      
      def function(arglist)
        Cucumber.logger
      end
    end
  end;Fi[	@Oi°I"®        else
          log.debug("STRING")
        end
      end
      
      def function(arglist)
        Cucumber.logger
      end
      
      def function(arglist);Fi[	@öi†I"¿    def function(arglist)
      var = (@var.support_to_load + @var.step_defs_to_load)
      @var.load_files!(var)
    end
    
    def function(arglist)
      Cucumber.logger
    end
  end
end;Fi[@(@@∑
@Ï*I"	self;Fi[[	@RiI"∆      var = OmniAuth::Form.new(var)
      (var.arity > 0) ? (yield(var)) : (var.instance_eval(&var))
      var
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    ;Fi[	@RiI"ï    def function(arglist)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    ;Fi[	@Ri?I"ö      self.instance_eval(&var)
      (@var << "STRING")
      self
    end
    
    def function(arglist)
      (@var << "STRING")
      self
    end
    ;Fi[@(@@∑
I"broadcast(var);FI"end;Fi[[	@UiI"…      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[	@Ui$I"…      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[	@UiiI"Ø      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[@(@@∑
I"var = @var;FI"var = @var;Fi[[	@siVI"∆    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@viKI"∆    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@yiEI"∆    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["STRING"]
    var = ((@var - @var) - @var) if (var == 0);Fi[@(@@∑
I"@var.language;FI"end;Fi[[	@ i>I"¿      
      def function(arglist)
        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      
      class ExampleRow < Cells;Fi[	@ i¶I"©        
        def function(arglist)
          "STRING"
        end
        
        def function(arglist)
          @var.language
        end
        
        private;Fi[	@PiVI"œ      
      def function(arglist)
        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      
      def function(arglist);Fi[I"# @since 1.1;FI"#;FI"def function(arglist);FI"@var = var;FI"end;Fi[[	@i5I"Æ  	#
   	# Set header font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_font, :SetHeaderFont);Fi[	@i@I"≠  #
   	# Set footer font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_font, :SetFooterFont);Fi[	@iKI"µ  #
   	# Set language array.
  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_language_array, :SetLanguageArray);Fi[@(@@∑
@UMI"end;Fi[[	@iAI"       
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist);Fi[	@ iI"Â          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist);Fi[	@ iÅI"∂              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist);Fi[@J@J@J@JI"
retry;Fi[[	@iI"R          var = Iconv.new("STRING", "STRING")
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@i?I"M          var = Iconv.new("STRING", var)
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@i}I"M          var = Iconv.new(var, "STRING")
          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[@J@J@JI"
retry;FI"rescue;Fi[[	@iI"2          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@i@I"2          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@i~I"2          var = "STRING"
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[@J@JI"
retry;FI"rescue;F@Qi[[	@iI"-          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@iAI"-          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@iI"-          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[@JI"end;FI"var = var;FI"end;FI"end;Fi[[	@iI"œ            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@iEI"œ            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@iÉI"À            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end
  end;Fi[@JI"
retry;FI"rescue;F@QI"end;Fi[[	@iI")            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@iBI")            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@iÄI")            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("STRING" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[I"&(var << Notifiable.new("STRING"));FI"&(var << Notifiable.new("STRING"));FI"&(var << Notifiable.new("STRING"));FI"&(var << Notifiable.new("STRING"));FI"&(var << Notifiable.new("STRING"));Fi[[	I"-data//redmine_proj/redmine/notifiable.rb;TiI"≠      (var << Notifiable.new("STRING", "STRING"))
      (var << Notifiable.new("STRING", "STRING"))
      (var << Notifiable.new("STRING", "STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"));Fi[	@biI"Ö      (var << Notifiable.new("STRING", "STRING"))
      (var << Notifiable.new("STRING", "STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      var;Fi[	@biI"[      (var << Notifiable.new("STRING", "STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      (var << Notifiable.new("STRING"))
      var
    end;Fi[I"%Redmine::Scm::Base.add("STRING");FI"%Redmine::Scm::Base.add("STRING");FI"%Redmine::Scm::Base.add("STRING");FI"%Redmine::Scm::Base.add("STRING");FI"%Redmine::Scm::Base.add("STRING");Fi[[	I""data//redmine_proj/redmine.rb;Ti1I"  require("csv")
  FCSV = CSV
end
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING");Fi[	@bi2I"#  FCSV = CSV
end
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::CustomFieldFormat.map do |arglist|;Fi[	@bi3I"/end
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::Scm::Base.add("STRING")
Redmine::CustomFieldFormat.map do |arglist|
  var.register("STRING");Fi[I"var = max_value;FI"var = min_value;F@DK@EK@¢Ti[[	@TiI"7      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	@WiI"=      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	@iiRI"7      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[I"var = min_value;F@DK@EK@¢T@£Ti[[	@TiI">      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@WiI">      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@iiSI">      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[@EK@¢T@£T@§TI"var = [];Fi[[	@TiI"ä        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@WiI"ä        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@iiUI"ä        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[@¢T@£T@§TI"var = [];F@gKi[[	@TiI"Ö        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@WiI"Ö        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@iiVI"Ö        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[@£T@§TI"var = [];F@gK@hKi[[	@TiI"w        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@WiI"w        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@iiWI"w        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[@§TI"var = [];F@gK@hKI"return var;Fi[[	@Ti I"d        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@WiI"d        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@iiXI"d        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[@gK@hKI"return var;FI"end;FI" ;Fi[[	@Ti"I"A        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0);Fi[	@WiI"C        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields];Fi[	@iiZI"P        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 };Fi[@hKI"return var;FI"end;FI" ;FI"def function(arglist);Fi[[	@Ti#I"        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0)
      end;Fi[	@Wi I"        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@ii[I">        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 }
        var[:x] = (var * var);Fi[I".raise((("STRING" + "STRING") + "STRING"));FI"end;FI"'return if (var[:data].length == 0);FI"var = [];FI"var = [];Fi[[	@°i=I"ì        @var = [] unless @var
        raise("STRING") unless var[:data] and var[:data].kind_of?(Array)
        unless ((var[:data].length % 2) == 0) then
          raise((("STRING" + "STRING") + "STRING"))
        end
        return if (var[:data].length == 0)
        var = []
        var = []
        var[:data].each_index do |arglist|
          ((((var % 2) == 0) ? (var) : (var)) << var[:data][var]);Fi[	@ïiHI"b        @var = [] unless @var
        raise("STRING") unless var[:data] and var[:data].kind_of?(Array)
        unless ((var[:data].length % 3) == 0) then
          raise((("STRING" + "STRING") + "STRING"))
        end
        return if (var[:data].length == 0)
        var = []
        var = []
        var = []
        var[:data].each_index do |arglist|;Fi[	@òi9I"t        @var = [] unless @var
        raise("STRING") unless var[:data] and var[:data].kind_of?(Array)
        unless ((var[:data].length % 2) == 0) then
          raise((("STRING" + "STRING") + "STRING"))
        end
        return if (var[:data].length == 0)
        var = []
        var = []
        var[:data].each_index do |arglist|
          if ((var % 2) == 0) then;Fi[I"# == Example;FI"#;FI"#   class Vehicle;F@ÏO@”Oi[[	@ái>I"@    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@áipI"    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@Fi˙I"A    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[@(@@∑
I"%return if Cucumber.wants_to_quit;FI"	init;Fi[[	@¥i$I"6          @var = true
          @var.dup(var)
        end
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?
        var.visit_background_name(@var, name, file_colon_line(@var), source_indent(first_line_length));Fi[	@i&I"Î      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?
        var.visit_tags(@var);Fi[	@ iI"      def function(arglist)
        init
        super
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        cells_rows.each_with_index do |arglist|
          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var));Fi[@\AI"end;FI" ;F@zDI"colour(var, "STRING");Fi[[	@õi{I"∫        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        ;Fi[	@õiI"∫        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        ;Fi[	@õiÉI"∫        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        
        def function(arglist)
          colour(var, "STRING")
        end
        ;Fi[@›O@ﬁO@ﬂO@‡OI"6#   specified, then this will match any to state.;Fi[[	@÷6i{I"\    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.;Fi[	@ÕiI"    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[	@Õi2I"    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[I"#   class Vehicle;F@W2@”O@‘OI"#       end;Fi[[	@ái@I"‰    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@áirI"‰    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@Fi¸I"÷    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[@•b@W2@…OI"#     end;FI"#   end;Fi[[	@´iI"÷    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@´i)I"÷    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@´iDI"÷    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[@•b@øOI"#;F@™O@´Oi[[	@ÀiI"        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@ÀiRI"        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@ÀivI"
        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[@•b@å=I"#       ...;FI"#     end;FI"#;Fi[[	@f2iÊI"Û    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize
    #     end;Fi[	@f2i˜I"    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[	@f2iI"8    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[@(@@∑
I"var = 0;F@˘Mi[[	@si<I"è    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0;Fi[	@vi,I"è    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0;Fi[	@yi+I"è    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["STRING"]
    var = var.length
    var = 0;Fi[@W2@…OI"#     end;FI"#   end;FI"#;Fi[[	@´iI"&    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@´i*I"ÿ    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[	@´iEI"ÿ    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[@(@@∑
I"	self;FI"end;Fi[[	@iBI"Ñ      @var = nil
      @var = nil
      var
    end
    
    def function(arglist)
      self
    end
    
    def function(arglist);Fi[	@B@iI"®      def function(arglist)
        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end
      
      def function(arglist);Fi[	@⁄i%I"ß      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end
      
      alias :arguments :argument;Fi[@g*@;*@h*I"#;F@ÂKi[[	@áiBI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@áitI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@f2iüI"    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[@(@@∑
I"(@var or @var);FI"end;Fi[[	@/i¡I"¥          var = uri
        end
        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist);Fi[	@“iI"≤      @var = var
      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "STRING")
    end
    
    def function(arglist)
      (@var or @var)
    end
  end
end;Fi[	@ iÖI"∆        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist);Fi[@;*@<*I"#;F@ÂK@ÊKi[[	@áiCI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@áiuI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@f2i†I"    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[I"#       event :disable do;F@;FI"#       end;FI"#     end;FI"#   end;Fi[[	@áiPI"2    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	@ái}I"2    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	@f2iîI"Ú    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly;Fi[@(@@∑
I"
yield;FI"end;Fi[[	@&iWI"ä    
    def function(arglist)
      Gem.refresh
    end
    
    def function(arglist)
      yield
    end
    
    def function(arglist);Fi[	@iXI"{    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end
  end
end;Fi[	@iI"±        @var = StringScanner.new(var)
        @var = 1
        @var = nil
      end
      
      def function(arglist)
        yield
      end
      
      def function(arglist);Fi[@ 7I"["STRING"];FI"end;FI" ;FI"def self.extended(arglist);Fi[[	@‰iI"÷      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist)
        require("active_record/version")
        super;Fi[	@#iI"      
      @var = { :action => :save, :use_transactions => (false) }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist)
        require("dm-core/version") unless ::DataMapper.const_defined?("STRING")
        super;Fi[	@ÍiI"–      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      def self.extended(arglist)
        require("mongoid/version")
        super;Fi[@K@KI"end;FI"
super;FI"end;Fi[[	@»ihI":          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@’iPI"2          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@ÿiI"           define_helper(:instance, "STRING", "STRING", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
      ;Fi[@K@KI"	else;FI"
super;FI"end;Fi[[	@‰i<I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@Ái5I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@Íi9I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[@KI"end;FI"
super;FI"end;FI"end;Fi[[	@»iiI"Ê        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@’iQI"Ê        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@ÿiI"        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "STRING", :prepend => (true))
          end
          super
        end
      end
      
      version("STRING") do |arglist|;Fi[@(@@∑
@ RI"end;Fi[[	@Mi:I"ﬁ    
    def function(arglist)
      Thread.current["STRING"]
    end
    
    def function(arglist)
      Thread.current["STRING"] = var
    end
    
    # Returns the configuration of the associated connection as a hash:;Fi[	@∆izI"        
        def function(arglist)
          Thread.current["STRING"]
        end
        
        def function(arglist)
          Thread.current["STRING"] = var
        end
        
        # The ignore_default_scope flag is used to prevent an infinite recursion;Fi[	@ıMiI"∂      #:nodoc:
      def function(arglist)
        Thread.current["STRING"]
      end
      
      def function(arglist)
        Thread.current["STRING"] = var
      end
    end
    ;Fi[@ÎH@ÏH@ÌHI"end;FI" ;Fi[[	@‰iI"¸      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@ÁiI"¸      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@ÍiI"¸      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[@ÌHI"end;FI" ;F@˛JI"def function(arglist);Fi[[	@‰iI"u      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default;Fi[	@ÁiI"%      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value
      end;Fi[	@ÍiI"#      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default
      end;Fi[@sS@tS@uS@KI"	else;Fi[[	@‰i:I"S        define_helper(:instance, "STRING", "STRING", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@Ái3I"!        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@Íi7I"!        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[@KI"	else;FI"
super;FI"end;FI"end;Fi[[	@‰i=I"O      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@Ái6I"O      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@Íi:I"O      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[@ˆH@iS@ËJI"end;FI" ;Fi[[	@‰iCI"E        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@Ái<I"E        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@Íi@I"E        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[@ËJI"end;FI" ;F@≠8@Æ8i[[	@‰iEI"ã      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["STRING", var] });Fi[	@Ái>I"y      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|;Fi[	@ÍiBI"§      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "STRING" => (var) }) } });Fi[@øOI"#;F@™O@´OI"#;Fi[[	@ÀiI"!        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@ÀiSI"!        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@ÀiwI"         # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[@™O@´OI"#;F@±=@≤=i[[	@ÀiI"D        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@ÀiUI"D        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@ÀiyI"D        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[@´OI"#;F@±=@≤=@≥=i[[	@ÀiI"<        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@ÀiVI"<        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@ÀizI"<        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[@…OI"#     end;FI"#   end;FI"#;FI".#   states = Vehicle.state_machine.states;Fi[[	@´iI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">
    #   ;Fi[	@´i+I"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@´iFI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[@°F@†O@°O@‹JI"end;Fi[[	@‰=iI"
      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@„JiI"-    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@Á=iI"    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[@(@@∑
I"@var.clear;FI"end;Fi[[	@ÇiºI"†      
      def function(arglist)
        "STRING"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[	@Çi¿I"¢      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[	@ÇiƒI"¢      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[@ÿ=@Ÿ=@uOI"end;FI" ;Fi[[	@ﬁ=iI"%      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection containing the followed user
      #;Fi[	@·=iI"+      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection of lists that were added to
      #;Fi[	@‰=iI"      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # The user who mentioned a user
      #;Fi[@(@@∑
I")reflection.active_record_primary_key;FI"end;Fi[[	@^iI"        def function(arglist)
          var = super
          klass.connection.select_all(var.arel, "STRING", var.bind_values)
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        def function(arglist);Fi[	@aiI"Í      class HasMany < CollectionAssociation
        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
      end
    end;Fi[	@giI"Ó      class HasOne < SingularAssociation
        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        private;Fi[@(@@∑
@D1I"(var << "STRING");Fi[[	@i	I"›  class Env
    def function(arglist)
      var.write(report)
    end
    
    def function(arglist)
      var = "STRING"
      (var << "STRING")
      (var << "STRING") if defined? RUBY_PATCHLEVEL
      (var << "STRING");Fi[	@/i$I"      
      def self.from_lock(arglist)
        new(var.merge("STRING" => (var.delete("STRING"))))
      end
      
      def function(arglist)
        var = "STRING"
        (var << "STRING")
        (var << "STRING")
        ["STRING", "STRING", "STRING", "STRING"].each do |arglist|;Fi[	@7i*I"      
      def self.from_lock(arglist)
        new(var.merge("STRING" => (var.delete("STRING"))))
      end
      
      def function(arglist)
        var = "STRING"
        (var << "STRING")
        (var << "STRING") unless (@var == DEFAULT_GLOB)
        (var << "STRING");Fi[@€J@‹JI"end;FI"end;FI" ;Fi[[	@‰=i I"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user
      #;Fi[	@„JiI"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets
      #;Fi[	@Á=iI"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user
      #;Fi[@l9@m9@n9I" # @return [Twitter::Cursor];FI"'# @overload friend_ids(options={});Fi[[	@WHiI"Ã      include(Twitter::API::Utils)
      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@WHi I"      # Returns a cursored collection of user objects for users following the specified user.
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@WHiI":      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[@(@@∑
I"
super;FI"$puts("STRING") if ARGV.verbose?;Fi[[	@™i`I"¶    super
    puts("STRING") if ARGV.verbose?
    $n = ($n + 1)
  end
  
  def function(arglist)
    super
    puts("STRING") if ARGV.verbose?
    $d = ($d + 1)
  end;Fi[	@™ikI"ã  def function(arglist)
    super
    $n = ($n + 1)
  end
  
  def function(arglist)
    super
    puts("STRING") if ARGV.verbose?
  end
  ;Fi[	@™ipI"û  def function(arglist)
    super
    puts("STRING") if ARGV.verbose?
  end
  
  def function(arglist)
    super
    puts("STRING") if ARGV.verbose?
  end
end;Fi[@l9@m9@n9I";# @param options [Hash] A customizable set of options.;FI"Í# @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;Fi[[	@…AiI"=      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).;Fi[	@…Ai2I"?      # Search for places that can be attached to a {Twitter::API::Tweets#update}
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.;Fi[	@…AiLI"Õ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.;Fi[@m9@n9@ıc@ˆcI"[#   Returns an array of numeric IDs for every user the authenticated user is following;Fi[[	@WHiI"Ë      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@WHiI"Ï      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@WHi I"Ó      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[@(@@∑
@ˇcI"@var = false;Fi[[	@À5iI"∑        set_inverse_instance(var)
        @var = true if var
        self.target = var
      end
      
      def function(arglist)
        super
        @var = false
      end
      ;Fi[	@bNiI"•    def self.reset_runtime(arglist)
      var, self.runtime = runtime, 0
      var
    end
    
    def function(arglist)
      super
      @var = false
    end
    ;Fi[	@§i!I"           @var.puts(html_header)
          @var.puts(report_header)
          @var.flush
        end
        
        def function(arglist)
          super
          @var = false
          @var = (@var + 1)
          unless (example_group_number == 1) then;Fi[@m9@n9@	d@
dI""# @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[[	@…Ai I"ˆ      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).
      # @option options [String] :granularity ('neighborhood') This is the minimal granularity of place types to return and must be one of: 'poi', 'neighborhood', 'city', 'admin' or 'country'.;Fi[	@…Ai3I"m      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.
      # @option options [String] :ip An IP address. Used when attempting to fix geolocation based off of the user's IP address.;Fi[	@…AiMI"ì      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.;Fi[@n9@ıc@ˆc@dI"#;Fi[[	@WHiI"      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@WHiI"      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@WHi!I"      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@(@@∑
I"raise("STRING");FI"end;Fi[[	@=.iI"®    module ClassMethods
      def function(arglist)
        raise("STRING")
      end
      
      def function(arglist)
        raise("STRING")
      end
    end
  end;Fi[	@vi{I"è      else
        ::OmniAuth.config.path_prefix = var
      end
    end
    
    def function(arglist)
      raise("STRING")
    end
  end
end;Fi[	@=i<I"ö              end
            end
          end
        end
        
        def function(arglist)
          raise("STRING")
        end
      end
    end;Fi[@(@@ @!@√Ai[[	@¡i˝I"+      #     Twitter.list_remove_members(7505382, 8863586, [813286, 18755393])
      def function(arglist)
        list_from_response_with_users(:post, "STRING", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@…AipI"®      #   Twitter.place_create(:name => "@sferik's Apartment", :token => "22ff5b1f7159032cf69218c4d8bb78bc", :contained_within => "41bcb736f84a799e", :lat => "37.783699", :long => "-122.393581")
      def function(arglist)
        object_from_response(Twitter::Place, :post, "STRING", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash];Fi[	@+i˚I"        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::OEmbed, :get, "STRING", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[@(@@”@‘@ÎHi[[	@‰iI"˘      def self.extended(arglist)
        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[	@ÁiI"Ê      
      def self.matching_ancestors(arglist)
        ["STRING"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[	@ÍiI"Û      def self.extended(arglist)
        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[@Ã9@Õ9@Œ9@9HI"´# @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[[	@s9iII"U      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik
      #   Twitter.retweeted_by_user('sferik');Fi[	@s9i`I"!      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user
      #   Twitter.retweeted_by_me;Fi[	@s9iáI"ï      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.
      # @example Return the 20 most recent retweets posted by users followed by the authenticating user;Fi[I"=#   @param options [Hash] A customizable set of options.;FI"def function(arglist);F@SHI"end;FI" ;Fi[[	@WHi¥I"œ      #     Twitter.unfollow('sferik')
      # @overload unfollow(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "STRING", var)
      end
      
      (alias :friendship_destroy :unfollow)
      ;Fi[	@]Hi÷I"Ô      #     Twitter.block(7505382)  # Same as above
      # @overload block(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "STRING", var)
      end
      
      # Un-blocks the users specified by the authenticating user
      #;Fi[	@]HiÈI"Î      #     Twitter.unblock(7505382)  # Same as above
      # @overload unblock(*users, options)
      #   @param users [Array<Integer, String, Twitter::User>, Set<Integer, String, Twitter::User>] An array of Twitter user IDs, screen names, or objects.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "STRING", var)
      end
      
      # Returns extended information for up to 100 users
      #;Fi[I"I#   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;FI"=#   @param options [Hash] A customizable set of options.;F@[d@ƒJI"*var.flatten.threaded_map do |arglist|;Fi[[	I"0data//twitter_proj/twitter/api/favorites.rb;TiTI"      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "STRING", var.options.merge(:id => (var)));Fi[	@kdivI"      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "STRING", var.options.merge(:id => (var)));Fi[	@iYI"%      #   @example Destroys a saved search for the authenticated user with the ID 16129012
      #     Twitter.saved_search_destroy(16129012)
      # @overload saved_search_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "STRING", var.options)
        end;Fi[@ƒJ@–J@—J@“JI"end;Fi[[	@¡iII"–      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::Tweet, :get, "STRING", var.options)
      end;Fi[	@¡iI"û      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options)
      end;Fi[	@¡iI"y      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var)
      end;Fi[@ıc@ˆc@dI"#;FI"=#   @param options [Hash] A customizable set of options.;Fi[[	@WHiI"      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs;Fi[	@WHiI"U      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@WHi"I"U      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@ˆc@dI"#;F@|dI"-#   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@WHiI"      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids;Fi[	@WHiI"≈      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@WHi#I"≈      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[I">#   @example Return the authenticated user's friends' IDs;FI"#     Twitter.friend_ids;FI"-# @overload friend_ids(user, options={});FI"W#   Returns an array of numeric IDs for every user the specified user is following;FI"#;Fi[[	@WHiI"
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@WHiI"œ      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@WHi*I"œ      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[@êd@ëd@ídI"#;FI"`#   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[[	@WHiI"÷      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@WHiI"o      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@WHi+I"o      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@ëd@ídI"#;F@ùdI"=#   @param options [Hash] A customizable set of options.;Fi[[	@WHiI"»      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs;Fi[	@WHiI"o      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@WHi,I"o      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@ídI"#;F@ùd@ßdI"Õ#   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@WHiI"Ω      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs
      #     Twitter.friend_ids('sferik');Fi[	@WHiI"o      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@WHi-I"o      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[@(@@)@ YI"# type.;Fi[[	@7iI"¯      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@:i•I"#      def function(arglist)
        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@/i*I"¯      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[@√A@ƒA@êH@`SI"def function(arglist);Fi[[	@¡iI"      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop);Fi[	@ƒiI"      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|;Fi[	@ƒiI"7        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then;Fi[@ƒA@êH@`S@√dI"+var = Twitter::API::Arguments.new(var);Fi[[	@¡iI"`      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then;Fi[	@ƒiI"j      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::User, var, var, merge_user(var.options, var));Fi[	@ƒiI"h      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name));Fi[@]O@^O@_O@`OI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	@s9i(I"Î      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={});Fi[	@s9i@I"      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@s9iXI"˝      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[@^O@_O@`O@’dI"&# @return [Array<Twitter::Tweet>];Fi[[	@s9i)I"F      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@s9iAI"Q      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.;Fi[	@s9iYI"x      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[I"/var[var] = Twitter::Size.fetch_or_new(var);FI"var;FI"end;FI"end;FI"end;Fi[[	@«iI"⁄    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	@iI"Í      # @return [Array<Twitter::Size>]
      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	@ÃiI"‘    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi
