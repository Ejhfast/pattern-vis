[{:lociüÕ:projects[I"activemodel_proj:ETI"activerecord_proj;TI"backup_proj;TI"bundler_proj;TI"cancan_proj;TI"capistrano_proj;TI"compass_proj;TI"cucumber_prok;TI"devise_proj;TI"diaspora_proj;TI"haml_proj;TI"homebrew_proj;TI"jekyll_proj;TI"mongoid_proj;TI"nokogiri_proj;TI"omni_proj;TI"paperclip_proj;TI"redmine_proj;TI"rescue_proj;TI"rspec_proj;TI"sinatra_proj;TI"SiriProxy_proj;TI"state_machine_proj;TI"twitter_proj;TI"whenever_proj;T:options[I"
--var;TI"
--fun;TI"--fargs;T[$[I"end;FI"end;FI"end;FI"end;FiV[V[	I"6data//activemodel_proj/active_model/conversion.rb;TiGI"„        @var ||= (var = ActiveSupport::Inflector.underscore(ActiveSupport::Inflector.demodulize(self))
        var = ActiveSupport::Inflector.tableize(self)
        "#{collection}/#{element}".freeze)
      end
    end
  end
end;Fi[	I"Odata//activemodel_proj/active_model/deprecated_mass_assignment_security.rb;TiI"      
      def function(arglist)
        raise("`attr_accessible` is extracted out of Rails into a gem. Please use new recommended protection model for params(strong_parameters) or add `protected_attributes` to your Gemfile to use old one.")
      end
    end
  end
end;Fi[	I"1data//activemodel_proj/active_model/dirty.rb;Ti\I"û      if attribute_changed?(var) then
        __send__("#{attr}=", changed_attributes[var])
        changed_attributes.delete(var)
      end
    end
  end
end;Fi[	I"Kdata//activemodel_proj/active_model/forbidden_attributes_protection.rb;TiI"l        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	I"0data//activemodel_proj/active_model/lint.rb;TibI"è      
      def function(arglist)
        assert(((var == true) or (var == false)), "#{name} should be a boolean")
      end
    end
  end
end;Fi[	I";data//activemodel_proj/active_model/secure_password.rb;Ti@I"˚        if respond_to?(:attributes_protected_by_default) then
          def self.attributes_protected_by_default(arglist)
            (super + ["password_digest"])
          end
        end
      end
    end
    
    module InstanceMethodsOnActivation;Fi[	@<iiI"¨            BCrypt::Engine::DEFAULT_COST
          end
          self.password_digest = BCrypt::Password.create(var, :cost => (var))
        end
      end
    end
  end
end;Fi[	@<ijI"É          end
          self.password_digest = BCrypt::Password.create(var, :cost => (var))
        end
      end
    end
  end
end;Fi[	I"9data//activemodel_proj/active_model/serialization.rb;Ti^I"Ç      var.each do |arglist|
        if var = send(var) then
          yield(var, var, var)
        end
      end
    end
  end
end;Fi[	@Ci_I"k        if var = send(var) then
          yield(var, var, var)
        end
      end
    end
  end
end;Fi[	I"<data//activemodel_proj/active_model/serializers/json.rb;TiÜI"q        var = var.values.first if var
        self.attributes = var
        self
      end
    end
  end
end;Fi[	I";data//activemodel_proj/active_model/serializers/xml.rb;TiòI"$          if var = options.delete(:procs) then
            Array(var).each do |arglist|
              (var.arity == 1) ? (var.call(options)) : (var.call(options, @var))
            end
          end
        end
      end
      
      # Returns XML representing the model. Configuration can be;Fi[	@Ki’I"~      def function(arglist)
        self.attributes = Hash.from_xml(var).values.first
        self
      end
    end
  end
end;Fi[	I"?data//activemodel_proj/active_model/validations/absence.rb;TiI"ƒ      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AbsenceValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Bdata//activemodel_proj/active_model/validations/acceptance.rb;Ti7I"«      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AcceptanceValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Adata//activemodel_proj/active_model/validations/callbacks.rb;Ti^I"¶      # Overwrite run validations to include callbacks.
      def function(arglist)
        run_callbacks(:validation) { |arglist| super }
      end
    end
  end
end;Fi[	I"Adata//activemodel_proj/active_model/validations/clusivity.rb;Ti%I"π      # uses the previous logic of comparing a value with the range endpoints.
      def function(arglist)
        var.is_a?(Range) ? (:cover?) : (:include?)
      end
    end
  end
end;Fi[	I"Ddata//activemodel_proj/active_model/validations/confirmation.rb;Ti9I"…      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ConfirmationValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Adata//activemodel_proj/active_model/validations/exclusion.rb;Ti1I"∆      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ExclusionValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I">data//activemodel_proj/active_model/validations/format.rb;Ti2I"©        else
          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var[:multiline].!=(true))) then
            raise(ArgumentError, "The provided regular expression is using multiline anchors (^ or $), which may present a security risk. Did you mean to use \\A and \\z, or forgot to add the :multiline => true option?")
          end
        end
      end
    end
    
    module HelperMethods;Fi[	@birI"√      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(FormatValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Adata//activemodel_proj/active_model/validations/inclusion.rb;Ti0I"∆      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(InclusionValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Ddata//activemodel_proj/active_model/validations/numericality.rb;Ti{I"ã      #   end
      def function(arglist)
        validates_with(NumericalityValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"@data//activemodel_proj/active_model/validations/presence.rb;Ti&I"≈      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Adata//activemodel_proj/active_model/validations/validates.rb;Ti£I"q          { :in => (var) }
        else
          { :with => (var) }
        end
      end
    end
  end
end;Fi[	@pi§I"V        else
          { :with => (var) }
        end
      end
    end
  end
end;Fi[	I"<data//activemodel_proj/active_model/validations/with.rb;TiáI"x      var.each do |arglist|
        var = var.new(var, &var)
        var.validate(self)
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/aggregations.rb;TicI"Ø          else
            var.each { |arglist| self[var.first] = var.send(var.last) }
            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	@xidI"†            var.each { |arglist| self[var.first] = var.send(var.last) }
            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	@xieI"]            @var[var] = var.freeze
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//activerecord_proj/active_record/associations/alias_tracker.rb;Ti8I"}      
      def function(arglist)
        var.slice(0, (connection.table_alias_length - 2))
      end
    end
  end
end;Fi[	I"Fdata//activerecord_proj/active_record/associations/association.rb;Ti‘I"»          var = [reflection.foreign_key, reflection.type].compact
          var = create_scope.except(*(var.changed - var))
          var.assign_attributes(var)
        end
      end
    end
  end
end;Fi[	@}i’I"Ü          var = create_scope.except(*(var.changed - var))
          var.assign_attributes(var)
        end
      end
    end
  end
end;Fi[	I"Ldata//activerecord_proj/active_record/associations/association_scope.rb;TidI"é      
      def function(arglist)
        var.is_a?(Relation) ? (var) : (var.unscoped.instance_exec(owner, &var))
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/associations/belongs_to_association.rb;TiPI"ã      
      def function(arglist)
        owner[reflection.foreign_key] and owner[reflection.foreign_key].to_s
      end
    end
  end
end;Fi[	I"]data//activerecord_proj/active_record/associations/belongs_to_polymorphic_association.rb;Ti#I"ã      def function(arglist)
        var = super
        var and [var.to_s, owner[reflection.foreign_type].to_s]
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/associations/collection_association.rb;Ti»I"Ÿ              (var.size + count_records)
            else
              count_records
            end
          end
        end
      end
      
      # Returns the size of the collection calling +size+ on the target.;Fi[	@ãijI"#            add_to_target(build_record(var)) do |arglist|
              yield(var) if block_given?
              insert_record(var, true, var)
            end
          end
        end
      end
      
      # Do the relevant stuff to insert the given record into the association collection.;Fi[	@ãiÁI"Ê        var = fetch_first_or_last_using_find?(var) ? (scope) : (load_target)
        var.send(var, *var).tap do |arglist|
          set_inverse_instance(var) if var.is_a?(ActiveRecord::Base)
        end
      end
    end
  end
end;Fi[	@ãiËI"ô        var.send(var, *var).tap do |arglist|
          set_inverse_instance(var) if var.is_a?(ActiveRecord::Base)
        end
      end
    end
  end
end;Fi[	I"Kdata//activerecord_proj/active_record/associations/collection_proxy.rb;Ti∂I"j      def function(arglist)
        proxy_association.reload
        self
      end
    end
  end
end;Ti[	I"^data//activerecord_proj/active_record/associations/has_and_belongs_to_many_association.rb;Ti6I"Q      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/associations/has_many_association.rb;TivI"É      
      def function(arglist)
        owner.attribute_present?(reflection.association_primary_key)
      end
    end
  end
end;Fi[	I"Wdata//activerecord_proj/active_record/associations/has_many_through_association.rb;Ti©I"ä      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	I"Ndata//activerecord_proj/active_record/associations/has_one_association.rb;Ti&I"#                nullify_owner_attributes(var)
                set_owner_attributes(target) if target
                raise(RecordNotSaved, "Failed to save the new associated #{reflection.name}.")
              end
            end
          end
        end
        self.target = var
      end;Fi[	@†i[I"â      
      def function(arglist)
        var ? (reflection.klass.transaction { |arglist| yield }) : (yield)
      end
    end
  end
end;Fi[	I"Vdata//activerecord_proj/active_record/associations/has_one_through_association.rb;TiI"∑              var.update(var)
            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end;Fi[	@•iI"ù            else
              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	@•i I"å              owner.new_record? ? (var.build(var)) : (var.create(var))
            end
          end
        end
      end
    end
  end
end;Fi[	@•i!I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"[data//activerecord_proj/active_record/associations/join_dependency/join_association.rb;TivI"Ä        
        def function(arglist)
          @var ||= reflection.scope_chain.reverse
        end
      end
    end
  end
end;Fi[	@ÆiwI"|        def function(arglist)
          @var ||= reflection.scope_chain.reverse
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/associations/join_dependency/join_base.rb;TiI"v        
        def function(arglist)
          active_record.table_name
        end
      end
    end
  end
end;Fi[	@≥iI"m        def function(arglist)
          active_record.table_name
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/associations/join_dependency/join_part.rb;TiDI"ß        
        def function(arglist)
          @var[record_id(var)] ||= active_record.send(:instantiate, extract_record(var))
        end
      end
    end
  end
end;Fi[	@∏iEI"û        def function(arglist)
          @var[record_id(var)] ||= active_record.send(:instantiate, extract_record(var))
        end
      end
    end
  end
end;Fi[	I"Jdata//activerecord_proj/active_record/associations/join_dependency.rb;TiΩI"ç        var = var.association(var.reflection.name)
        var.target = var
        var.set_inverse_instance(var)
      end
    end
  end
end;Fi[	I"Fdata//activerecord_proj/active_record/associations/join_helper.rb;Ti%I"      
      def function(arglist)
        var.create_join(var, var.create_on(var), join_type)
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/associations/preloader/association.rb;TinI"§            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@√ioI"H          end
          var
        end
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/associations/preloader/belongs_to.rb;TiI"t        
        def function(arglist)
          reflection.foreign_key
        end
      end
    end
  end
end;Fi[	@»iI"k        def function(arglist)
          reflection.foreign_key
        end
      end
    end
  end
end;Fi[	I"[data//activerecord_proj/active_record/associations/preloader/collection_association.rb;TiI"±            var.loaded!
            var.target.concat(var)
            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	@ÕiI"ô            var.target.concat(var)
            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	@ÕiI"{            var.each { |arglist| var.set_inverse_instance(var) }
          end
        end
      end
    end
  end
end;Fi[	I"\data//activerecord_proj/active_record/associations/preloader/has_and_belongs_to_many.rb;Ti:I"        def function(arglist)
          var = table[reflection.association_primary_key].eq(join_table[reflection.association_foreign_key])
          table.create_join(join_table, table.create_on(var))
        end
      end
    end
  end
end;Fi[	@‘i;I"“          var = table[reflection.association_primary_key].eq(join_table[reflection.association_foreign_key])
          table.create_join(join_table, table.create_on(var))
        end
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/associations/preloader/has_many.rb;TiI"}        
        def function(arglist)
          reflection.active_record_primary_key
        end
      end
    end
  end
end;Fi[	@ŸiI"y        def function(arglist)
          reflection.active_record_primary_key
        end
      end
    end
  end
end;Fi[	I"Udata//activerecord_proj/active_record/associations/preloader/has_many_through.rb;TiI"ö        
        def function(arglist)
          super.each { |arglist| var.uniq! if reflection_scope.uniq_value }
        end
      end
    end
  end
end;Fi[	@ﬁiI"ë        def function(arglist)
          super.each { |arglist| var.uniq! if reflection_scope.uniq_value }
        end
      end
    end
  end
end;Fi[	I"Ldata//activerecord_proj/active_record/associations/preloader/has_one.rb;TiI"ß        
        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]))
        end
      end
    end
  end
end;Fi[	@„iI"û        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]))
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/associations/preloader/has_one_through.rb;Ti
I"É    class Preloader
      class HasOneThrough < SingularAssociation
        include(ThroughAssociation)
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/associations/preloader/singular_association.rb;TiI"Ø            var = var.association(reflection.name)
            var.target = var
            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	@ÎiI"|            var.target = var
            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	@ÎiI"d            var.set_inverse_instance(var)
          end
        end
      end
    end
  end
end;Fi[	I"Xdata//activerecord_proj/active_record/associations/preloader/through_association.rb;Ti4I"Ö            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@Úi5I"H          end
          var
        end
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/associations/preloader.rb;TiäI"d          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	@˜iãI"P        else
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/associations/singular_association.rb;Ti?I"        set_new_record(var)
        raise(RecordInvalid.new(var)) if var.! and var
        var
      end
    end
  end
end;Fi[	I"Ndata//activerecord_proj/active_record/associations/through_association.rb;TiFI"∫      def function(arglist)
        if reflection.nested? then
          raise(HasManyThroughNestedAssociationsAreReadonly.new(owner, reflection))
        end
      end
    end
  end
end;Fi[	@ˇiGI"û        if reflection.nested? then
          raise(HasManyThroughNestedAssociationsAreReadonly.new(owner, reflection))
        end
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/associations.rb;TiºI"º      #   has_and_belongs_to_many :categories, -> { readonly }
      def function(arglist)
        Builder::HasAndBelongsToMany.build(self, var, var, var, &var)
      end
    end
  end
end;Fi[	I"Bdata//activerecord_proj/active_record/attribute_assignment.rb;TiÆI"f      
      def function(arglist)
        [values.keys.max, var].min
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/attribute_methods/before_type_cast.rb;Ti"I"ö      # Handle *_before_type_cast for method_missing.
      def function(arglist)
        read_attribute_before_type_cast(var)
      end
    end
  end
end;Fi[	I"Edata//activerecord_proj/active_record/attribute_methods/dirty.rb;TifI"å      
      def function(arglist)
        (var == 0) and (var.is_a?(String) and (var.present? and var.!=("0")))
      end
    end
  end
end;Fi[	I"Kdata//activerecord_proj/active_record/attribute_methods/primary_key.rb;TisI"~        def function(arglist)
          @var = (var and var.to_s)
          @var = nil
        end
      end
    end
  end
end;Fi[	@itI"e          @var = (var and var.to_s)
          @var = nil
        end
      end
    end
  end
end;Fi[	I"Edata//activerecord_proj/active_record/attribute_methods/query.rb;Ti)I"      # Handle *? for method_missing.
      def function(arglist)
        query_attribute(var)
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/attribute_methods/read.rb;TibI"_      
      def function(arglist)
        read_attribute(var)
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/attribute_methods/serialization.rb;TiÉI"}            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end
end;Fi[	@iÑI"[          else
            super
          end
        end
      end
    end
  end
end;Fi[	@iÖI"L            super
          end
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/attribute_methods/time_zone_conversion.rb;Ti9I"i      
      def function(arglist)
        var.change(:usec => 0) if var
      end
    end
  end
end;Fi[	I"Edata//activerecord_proj/active_record/attribute_methods/write.rb;Ti3I"      def function(arglist)
        return var unless var
        var.type_cast_for_write(var)
      end
    end
  end
end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/abstract/connection_pool.rb;TiÜI"†            while true do
              sleep(var)
              var.reap
            end
          end
        end
      end
      
      include(MonitorMixin);Fi[	@(iÍI"É        end
        var) rescue ActiveRecord::Base.clear_active_connections! unless var
          raise
      end
    end
  end
end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/abstract/database_limits.rb;Ti9I"~      # Returns maximum number of joins in a single query.
      def function(arglist)
        256
      end
    end
  end
end;Fi[	I"^data//activerecord_proj/active_record/connection_adapters/abstract/database_statements.rb;TiàI"s      def function(arglist)
        var = var.rows.first
        var and var.first
      end
    end
  end
end;Fi[	I"Rdata//activerecord_proj/active_record/connection_adapters/abstract/quoting.rb;TiuI"x          var = var.send(var) if var.respond_to?(var)
        end
        var.to_s(:db)
      end
    end
  end
end;Fi[	I"]data//activerecord_proj/active_record/connection_adapters/abstract/schema_definitions.rb;Ti®I"{      #  t.string(:goat, :sheep)
      def function(arglist)
        @var.native_database_types
      end
    end
  end
end;Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract/schema_dumper.rb;Ti4I"p          "'#{value.to_s(:db)}'"
        else
          var.inspect
        end
      end
    end
  end
end;Fi[	@9i5I"O        else
          var.inspect
        end
      end
    end
  end
end;Fi[	I"\data//activerecord_proj/active_record/connection_adapters/abstract/schema_statements.rb;Ti%I"‹            if (var < var) then
              execute("INSERT INTO #{sm_table} (version) VALUES ('#{v}')")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist);Fi[	@>i¨I"e      
      def function(arglist)
        TableDefinition.new(self)
      end
    end
  end
end;Fi[	I"Vdata//activerecord_proj/active_record/connection_adapters/abstract/transaction.rb;TióI"ñ      def function(arglist)
        connection.release_savepoint
        records.each { |arglist| parent.add_record(var) }
      end
    end
  end
end;Fi[	I"Rdata//activerecord_proj/active_record/connection_adapters/abstract_adapter.rb;Ti+I"s      
      def function(arglist)
        ActiveRecord::StatementInvalid.new(var)
      end
    end
  end
end;Fi[	I"Xdata//activerecord_proj/active_record/connection_adapters/abstract_mysql_adapter.rb;Ti¬I"í          end
        end.compact.join(", ")
        execute("SET #{encoding} #{variable_assignments}", :skip_logging)
      end
    end
  end
end;Fi[	I"Zdata//activerecord_proj/active_record/connection_adapters/connection_specification.rb;TiLI"d            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	@LiMI"H          end
          var
        end
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/mysql2_adapter.rb;Ti„I"±      def function(arglist)
        @var ||= @var.info[:version].scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	@Qi‰I"ï        @var ||= @var.info[:version].scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	I"Odata//activerecord_proj/active_record/connection_adapters/mysql_adapter.rb;TiÿI"Æ      def function(arglist)
        @var ||= @var.server_info.scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	@ViŸI"í        @var ||= @var.server_info.scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i
        end
      end
    end
  end
end;Fi[	I"Ydata//activerecord_proj/active_record/connection_adapters/postgresql/array_parser.rb;Ti]I"≈        def function(arglist)
          unless (var.length == 0) then
            var.! and (var == "NULL") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	@[i^I"ß          unless (var.length == 0) then
            var.! and (var == "NULL") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	@[i_I"            var.! and (var == "NULL") ? (var.push(nil)) : (var.push(var))
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/postgresql/cast.rb;TigI"§                (var..var)
              else
                var
              end
            end
          end
        end
        
        def function(arglist);Fi[	@bièI"Å            var
          else
            "\"#{value.gsub(/"/, "\\\"")}\""
          end
        end
      end
    end
  end
end;Fi[	@biêI"v          else
            "\"#{value.gsub(/"/, "\\\"")}\""
          end
        end
      end
    end
  end
end;Fi[	@biëI"g            "\"#{value.gsub(/"/, "\\\"")}\""
          end
        end
      end
    end
  end
end;Fi[	I"`data//activerecord_proj/active_record/connection_adapters/postgresql/database_statements.rb;TiQI"˚                var.gsub!(/[^-\d,]/, "").sub!(/,/, ".")
              else
                # do nothing
              end
            end
          end
        end
        
        # Queries the database and returns the results in an Array-like object;Fi[	@kiøI"è        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end
    end
  end
end;Fi[	@ki¿I"Ü        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/postgresql/oid.rb;TiI"y        register_type("cidr", OID::Cidr.new)
        
        alias_type("inet", "cidr")
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/active_record/connection_adapters/postgresql/quoting.rb;TiôI"Å          end
          var = (var.sub(/^-/, "") + " BC") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	@uiöI"x          var = (var.sub(/^-/, "") + " BC") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	I"bdata//activerecord_proj/active_record/connection_adapters/postgresql/referential_integrity.rb;TiI"ˆ              end.join(";")) rescue execute(tables.collect do |arglist|
                  "ALTER TABLE #{quote_table_name(name)} ENABLE TRIGGER USER"
                end.join(";"))
            end
          end
        end
      end
    end
  end;Fi[	@zi I"≤                  "ALTER TABLE #{quote_table_name(name)} ENABLE TRIGGER USER"
                end.join(";"))
            end
          end
        end
      end
    end
  end
end;Fi[	@zi!I"i                end.join(";"))
            end
          end
        end
      end
    end
  end
end;Fi[	@zi"I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"^data//activerecord_proj/active_record/connection_adapters/postgresql/schema_statements.rb;TibI"Ñ            "#{column} AS alias_#{i}"
          end
          [super].concat(var).join(", ")
        end
      end
    end
  end
end;Fi[	@ÉicI"c          end
          [super].concat(var).join(", ")
        end
      end
    end
  end
end;Fi[	I"Ndata//activerecord_proj/active_record/connection_adapters/schema_cache.rb;TiXI"µ        end
        @var.default_proc = Proc.new do |arglist|
          var[var] = table_exists?(var) ? (connection.primary_key(var)) : (nil)
        end
      end
    end
  end
end;Fi[	@àiYI"©        @var.default_proc = Proc.new do |arglist|
          var[var] = table_exists?(var) ? (connection.primary_key(var)) : (nil)
        end
      end
    end
  end
end;Fi[	I"Qdata//activerecord_proj/active_record/connection_adapters/sqlite3_adapter.rb;TiI"q          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@çiI"I        else
          super
        end
      end
    end
  end
end;Fi[	I"Pdata//activerecord_proj/active_record/connection_adapters/statement_pool.rb;Ti)I"f      
      def function(arglist)
        raise(NotImplementedError)
      end
    end
  end
end;Fi[	I"2data//activerecord_proj/active_record/core.rb;Ti=I"               "#{super}(#{attr_list})"
            else
              "#{super}(Table doesn't exist)"
            end
          end
        end
      end
      
      # Overwrite the default class equality method to provide support for association proxies.;Fi[	I";data//activerecord_proj/active_record/counter_cache.rb;TiuI"õ      #   DiscussionBoard.decrement_counter(:post_count, 5)
      def function(arglist)
        update_counters(var, var => -1)
      end
    end
  end
end;Fi[	I"5data//activerecord_proj/active_record/explain.rb;TiXI"n        yield)
      ensure
        var[:available_queries_for_explain] = var
      end
    end
  end
end;Fi[	I"6data//activerecord_proj/active_record/fixtures.rb;TiDI"‡            var.instance_variable_set("@#{fixture_name}", var.find)
          rescue FixtureClassNotFound
            nil
          end
        end
      end
    end
    
    def self.instantiate_all_loaded_fixtures(arglist);Fi[	@ûi„I"‚        FixtureSet::File.open(var) do |arglist|
          var.each do |arglist|
            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist);Fi[	@ûiI"Õ        model_class.find(fixture[model_class.primary_key])
      else
        raise(FixtureClassNotFound, "No class attached to find.")
      end
    end
  end
end
module ActiveRecord
  module TestFixtures;Fi[	I"9data//activerecord_proj/active_record/inheritance.rb;Ti∞I"ü      var = self.class
      if var.finder_needs_type_condition? then
        write_attribute(var.inheritance_column, var.sti_name)
      end
    end
  end
end;Fi[	I"9data//activerecord_proj/active_record/integration.rb;Ti:I"ô        "#{self.class.model_name.cache_key}/#{id}-#{timestamp}"
      else
        "#{self.class.model_name.cache_key}/#{id}"
      end
    end
  end
end;Fi[	I"@data//activerecord_proj/active_record/locking/optimistic.rb;TioI"o            var[locking_column] ||= 0
          end
          var)
        end
      end
    end
  end
end;Fi[	@´ipI"I          end
          var)
        end
      end
    end
  end
end;Fi[	I"Adata//activerecord_proj/active_record/locking/pessimistic.rb;TiI"r        transaction do |arglist|
          lock!(var)
          yield
        end
      end
    end
  end
end;Fi[	@∞iI"Q          lock!(var)
          yield
        end
      end
    end
  end
end;Fi[	I"Hdata//activerecord_proj/active_record/migration/command_recorder.rb;TiÜI"√          @var.send(var, *var, &var)
        rescue NoMethodError => var
          raise(var, var.message.sub(/ for #<.*$/, " via proxy for #{@delegate}"))
        end
      end
    end
  end
end;Fi[	@µiáI"û        rescue NoMethodError => var
          raise(var, var.message.sub(/ for #<.*$/, " via proxy for #{@delegate}"))
        end
      end
    end
  end
end;Fi[	I"Bdata//activerecord_proj/active_record/migration/join_table.rb;TiI"v      
      def function(arglist)
        [var.to_s, var.to_s].sort.join("_").to_sym
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/model_schema.rb;Ti8I"≤          "#{full_table_name_prefix}#{contained}#{undecorated_table_name(name)}#{table_name_suffix}"
        else
          var.table_name
        end
      end
    end
  end
end;Fi[	@Ωi9I"R        else
          var.table_name
        end
      end
    end
  end
end;Fi[	I"?data//activerecord_proj/active_record/nested_attributes.rb;TiTI"ö            generated_feature_methods.module_eval("              if method_defined?(:#{association_name}_attributes=)\n                remove_method(:#{association_name}_attributes=)\n              end\n              def #{association_name}_attributes=(attributes)\n                assign_nested_attributes_for_#{type}_association(:#{association_name}, attributes)\n              end\n", "(string)", (284 + 1))
          else
            raise(ArgumentError, "No association found for name `#{association_name}'. Has it been defined yet?")
          end
        end
      end
    end
    
    # Returns ActiveRecord::AutosaveAssociation::marked_for_destruction? It's;Fi[	@¬iÅI"              send(var, var.except(*UNASSIGNABLE_KEYS))
            else
              raise(ArgumentError, "Cannot build association `#{association_name}'. Are you trying to build a polymorphic one-to-one association?")
            end
          end
        end
      end
    end
    ;Fi[	@¬iÇI"'            else
              raise(ArgumentError, "Cannot build association `#{association_name}'. Are you trying to build a polymorphic one-to-one association?")
            end
          end
        end
      end
    end
    
    # Assigns the given attributes to the collection association.;Fi[	@¬i–I"‡            end
          else
            raise_nested_attributes_record_not_found(var, var["id"])
          end
        end
      end
    end
    
    # Updates a record with the +attributes+ or marks it for destruction if;Fi[	I"9data//activerecord_proj/active_record/persistence.rb;Ti£I"≤    def function(arglist)
      if self.class.readonly_attributes.include?(var) then
        raise(ActiveRecordError, "#{name} is marked as readonly")
      end
    end
  end
end;Fi[	I"6data//activerecord_proj/active_record/querying.rb;TiFI"£      logging_query_plan do |arglist|
        var = sanitize_conditions(var)
        connection.select_value(var, "#{name} Count").to_i
      end
    end
  end
end;Fi[	I"5data//activerecord_proj/active_record/railtie.rb;TiEI"X                self.connection.schema_cache = var
              else
                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end;Fi[	@—iFI"*              else
                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end
    ;Fi[	@—iGI"Q                warn("Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}.")
              end
            end
          end
        end
      end
    end
    
    initializer("active_record.set_configs") do |arglist|;Fi[	@—i{I"          if ActiveRecord::Base.connected? then
            ActiveRecord::Base.clear_reloadable_connections!
            ActiveRecord::Base.clear_cache!
          end
        end
      end
    end
    
    initializer("active_record.add_watchable_files") do |arglist|;Fi[	I"Idata//activerecord_proj/active_record/railties/controller_runtime.rb;Ti-I"†          var, var = super, var[:db_runtime]
          (var << ("ActiveRecord: %.1fms" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	@⁄i.I"x          (var << ("ActiveRecord: %.1fms" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	I"8data//activerecord_proj/active_record/reflection.rb;TiÓI"~      
      def function(arglist)
        (options[:source_type] or source_reflection.class_name)
      end
    end
  end
end;Fi[	I"Adata//activerecord_proj/active_record/relation/delegation.rb;Ti<I"é              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end
    ;Fi[	@‚i=I"}            else
              super
            end
          end
        end
      end
    end
    
    module ClassMethods;Fi[	@‚ioI"¢          to_a.send(var, *var, &var)
        else
          arel.respond_to?(var) ? (arel.send(var, *var, &var)) : (super)
        end
      end
    end
  end
end;Fi[	@‚ipI"}        else
          arel.respond_to?(var) ? (arel.send(var, *var, &var)) : (super)
        end
      end
    end
  end
end;Fi[	I"=data//activerecord_proj/active_record/relation/merger.rb;TiqI"g          var
        else
          relation.where_values
        end
      end
    end
  end
end;Fi[	@ÎirI"Y        else
          relation.where_values
        end
      end
    end
  end
end;Fi[	I"Hdata//activerecord_proj/active_record/relation/predicate_builder.rb;TiZI"X        var.eq(var.name)
      else
        var.eq(var)
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/relation/query_methods.rb;Ti6I"‚      var.select { |arglist| Hash.===(var) }.each do |arglist|
        unless (var.values - [:asc, :desc]).empty? then
          raise(ArgumentError, "Direction should be :asc or :desc")
        end
      end
    end
  end
end;Fi[	@Ûi7I"£        unless (var.values - [:asc, :desc]).empty? then
          raise(ArgumentError, "Direction should be :asc or :desc")
        end
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/sanitization.rb;TiI"Á              var
            else
              (var % var.collect { |arglist| connection.quote_string(var.to_s) })
            end
          end
        end
      end
      
      alias_method(:sanitize_conditions, :sanitize_sql);Fi[	@¯iñI"Ó              quote_bound_value(var[var])
            else
              raise(PreparedStatementInvalid, "missing value for :#{match} in #{statement}")
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"=data//activerecord_proj/active_record/scoping/default.rb;TiqI"ﬁ                    var.merge(unscoped { |arglist| var.call })
                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end;Fi[	@˝irI"®                  else
                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        ;Fi[	@˝isI"Ø                    var.merge(var)
                  end
                end
              end
            end
          end
        end
        
        def function(arglist);Fi[	@˝iÜI"á            yield)
          ensure
            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	@˝iáI"y          ensure
            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	@˝iàI"h            self.ignore_default_scope = false
          end
        end
      end
    end
  end
end;Fi[	I";data//activerecord_proj/active_record/scoping/named.rb;TiòI"‡            var = var.respond_to?(:call) ? (unscoped { |arglist| var.call(*var) }) : (var)
            var = all.merge(var)
            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	@
iôI"Ö            var = all.merge(var)
            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	@
iöI"i            var ? (var.extending(var)) : (var)
          end
        end
      end
    end
  end
end;Fi[	I"5data//activerecord_proj/active_record/scoping.rb;TiI"∑      return unless self.class.scope_attributes?
      self.class.scope_attributes.each do |arglist|
        send("#{att}=", var) if respond_to?("#{att}=")
      end
    end
  end
end;Fi[	I"3data//activerecord_proj/active_record/store.rb;TiSI"ë          var.with_indifferent_access
        else
          ActiveSupport::HashWithIndifferentAccess.new
        end
      end
    end
  end
end;Fi[	@iTI"p        else
          ActiveSupport::HashWithIndifferentAccess.new
        end
      end
    end
  end
end;Fi[	I"Bdata//activerecord_proj/active_record/tasks/database_tasks.rb;TiîI"Ä      
      def function(arglist)
        (var["host"].blank? or LOCAL_HOSTS.include?(var["host"]))
      end
    end
  end
end;Fi[	I"Hdata//activerecord_proj/active_record/tasks/mysql_database_tasks.rb;Ti*I"\            $stderr.puts("Couldn't create database for #{configuration.inspect}, #{creation_options.inspect}")
            if configuration["encoding"] then
              $stderr.puts("(If you set the charset manually, make sure you have a matching collation)")
            end
          end
        end
      end
      
      def function(arglist);Fi[	@iâI"e          var.concat(["--#{k}", var]) if var
        end
        var
      end
    end
  end
end;Fi[	I"Mdata//activerecord_proj/active_record/tasks/postgresql_database_tasks.rb;TiYI"∏          ENV["PGPASSWORD"] = configuration["password"].to_s
        end
        ENV["PGUSER"] = configuration["username"].to_s if configuration["username"]
      end
    end
  end
end;Fi[	I"7data//activerecord_proj/active_record/timestamp.rb;TiVI"î      all_timestamp_attributes_in_model.each do |arglist|
        self[var] = nil
        changed_attributes.delete(var)
      end
    end
  end
end;Fi[	I":data//activerecord_proj/active_record/transactions.rb;TiÃI"{        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/validations/associated.rb;Ti4I"å      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Bdata//activerecord_proj/active_record/validations/presence.rb;TiI"Ù          var = Array(var.send(var))
          if var.present? and var.all? { |arglist| var.marked_for_destruction? } then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods;Fi[	@-i@I"…      #   See <tt>ActiveModel::Validation#validates!</tt> for more information.
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Ddata//activerecord_proj/active_record/validations/uniqueness.rb;Ti–I"∫      # * ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.
      def function(arglist)
        validates_with(UniquenessValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"\data//activerecord_proj/rails/generators/active_record/migration/migration_generator.rb;Ti4I"≠      def function(arglist)
        unless file_name =~ /^[_a-z0-9]+$/ then
          raise(IllegalMigrationNameError.new(file_name))
        end
      end
    end
  end
end;Fi[	@5i5I"ë        unless file_name =~ /^[_a-z0-9]+$/ then
          raise(IllegalMigrationNameError.new(file_name))
        end
      end
    end
  end
end;Fi[	I"Tdata//activerecord_proj/rails/generators/active_record/model/model_generator.rb;Ti8I"v      
      def function(arglist)
        (options[:parent] or "ActiveRecord::Base")
      end
    end
  end
end;Fi[	I">data//activerecord_proj/rails/generators/active_record.rb;TiI"∂      def self.next_migration_number(arglist)
        var = (current_migration_number(var) + 1)
        ActiveRecord::Migration.next_migration_number(var)
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/cli/helpers.rb;TiDI"|        var = var =~ /\s/
        var = var.slice(0, var) if var
        var.split("/")[-1]
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/cli/utility.rb;Ti‚I"ë          return yes?("A file already exists at '#{path}'. Do you want to overwrite? [y/n]")
        end
        true
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/compressor/base.rb;Ti I"Ë      # the client that Backup is using the compressor
      def function(arglist)
        Logger.message((("Using #{compressor_name} for compression.\n" + "  Command: '#{@cmd}'\n") + "  Ext: '#{@ext}'"))
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/compressor/bzip2.rb;Ti%I"a      
      def function(arglist)
        " -#{@level}" if @var
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/compressor/custom.rb;Ti0I"à      # If extension was not set, return an empty string
      def function(arglist)
        @var.to_s.strip
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/compressor/gzip.rb;Ti%I"a      
      def function(arglist)
        " -#{@level}" if @var
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/compressor/lzma.rb;Ti(I"t      
      def function(arglist)
        (" --best" if @var or " --fast" if @var)
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/compressor/pbzip2.rb;Ti0I"ñ        var = (" --best" if @var or " --fast" if @var)
        var = " -p#{@processors}" if @var
        "#{level}#{cpus}"
      end
    end
  end
end;Fi[	I"6data//backup_proj/backup/configuration/helpers.rb;TilI"~          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	@XimI"I        else
          super
        end
      end
    end
  end
end;Fi[	I"4data//backup_proj/backup/configuration/store.rb;TiI"r      # Used only within the specs
      def function(arglist)
        @var.clear
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/database/base.rb;Ti0I"¬      # the client that Backup is dumping the database
      def function(arglist)
        Logger.message("#{database_name} started dumping and archiving '#{name}'.")
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/database/mongodb.rb;Ti¿I"◊      # Builds a Mongo URI based on the provided attributes
      def function(arglist)
        ["#{host}:#{port}#{("/" + name) if name}", credential_options, ipv6_option].join(" ").strip
      end
    end
  end
end;Fi[	I"/data//backup_proj/backup/database/mysql.rb;TiçI"{      # so this will be true by default
      def function(arglist)
        (name == :all)
      end
    end
  end
end;Fi[	I"4data//backup_proj/backup/database/postgresql.rb;Ti}I"Ø      # during the dumping of the database
      def function(arglist)
        skip_tables.map { |arglist| "--exclude-table='#{table}'" }.join(" ")
      end
    end
  end
end;Fi[	I"/data//backup_proj/backup/database/redis.rb;TisI"      # additional options specified by the user
      def function(arglist)
        @var.join(" ")
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/database/riak.rb;Ti8I"≤      # Builds the full riak-admin string based on all attributes
      def function(arglist)
        "#{riak_admin_utility} backup #{node} #{cookie}"
      end
    end
  end
end;Fi[	I"+data//backup_proj/backup/dependency.rb;TiI"ú      rescue LoadError
        Logger.error(Errors::Dependency::LoadError.new("          Dependency missing\n          Dependency required for:\n          #{all[name][:for]}\n          To install the gem, issue the following command:\n          > gem install #{name} -v '#{all[name][:version]}'\n          Please try again after installing the missing dependency.\n"))
        exit(1)
      end
    end
  end
end;Fi[	I"/data//backup_proj/backup/encryptor/base.rb;TiI"∫      # the client that Backup is encrypting the archive
      def function(arglist)
        Logger.message("Using #{encryptor_name} to encrypt the archive.")
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/encryptor/gpg.rb;TizI"d            # do nothing
          end
        end.flatten.compact)
      end
    end
  end
end;Fi[	I"3data//backup_proj/backup/encryptor/open_ssl.rb;TiBI"±        (var << "-salt") if @var
        (var << (@var.to_s.empty? ? ("-k '#{@password}'") : ("-pass file:#{@password_file}")))
        var.join(" ")
      end
    end
  end
end;Fi[	I"'data//backup_proj/backup/errors.rb;TiHI"g      
      def function(arglist)
        var.gsub(/^ */, "  ").strip
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/notifier/base.rb;TiOI"≈      # the client that Backup is notifying about the process
      def function(arglist)
        Logger.message("#{notifier_name} started notifying about the process.")
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/notifier/campfire.rb;TiI"≥        # Returns the url for the specified room (in JSON format)
        def function(arglist)
          "/room/#{room_id}/#{action}.json"
        end
      end
    end
  end
end;Fi[	@ÑiÄI"v        def function(arglist)
          "/room/#{room_id}/#{action}.json"
        end
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/notifier/hipchat.rb;TiZI"“        var = HipChat::Client.new(token)
        [rooms_notified].flatten.each do |arglist|
          var[var].send(from, var, :color => (var), :notify => (notify_users))
        end
      end
    end
  end
end;Fi[	@âi[I"©        [rooms_notified].flatten.each do |arglist|
          var[var].send(from, var, :color => (var), :notify => (notify_users))
        end
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/notifier/mail.rb;TiπI"Z        var.to = @var
        var.from = @var
        var
      end
    end
  end
end;Fi[	I"/data//backup_proj/backup/notifier/prowl.rb;Ti?I"∆      def function(arglist)
        var = Prowler.new(:application => (application), :api_key => (api_key))
        var.notify(var, "#{@model.label} (#{@model.trigger})")
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/notifier/pushover.rb;TiXI"}          @var.merge!(var => (self.instance_variable_get("@#{k}")))
        end
        @var
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/notifier/twitter.rb;TiCI"h        end
        var = ::Twitter::Client.new
        var.update(var)
      end
    end
  end
end;Fi[	I")data//backup_proj/backup/pipeline.rb;TiiI"€        false
      else
        "        Pipeline STDERR Messages:\n        (Note: may be interleaved if multiple commands returned error messages)\n\n        #{@stderr}\n".gsub(/^ +/, "  ")
      end
    end
  end
end;Fi[	I"-data//backup_proj/backup/storage/base.rb;TiaI"∏        Logger.message("#{storage_name}: Cycling Started...")
        Cycler.cycle!(self, @var)
        Logger.message("#{storage_name}: Cycling Complete!")
      end
    end
  end
end;Fi[	I"3data//backup_proj/backup/storage/cloudfiles.rb;TiBI"        transferred_files_for(var) do |arglist|
          Logger.message(("#{storage_name} started removing '#{local_file}' " + "from container '#{container}'."))
          connection.delete_object(container, File.join(var, var))
        end
      end
    end
  end
end;Fi[	@†iCI"›          Logger.message(("#{storage_name} started removing '#{local_file}' " + "from container '#{container}'."))
          connection.delete_object(container, File.join(var, var))
        end
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/storage/dropbox.rb;TiàI"«          var)
        rescue => var
          raise(Errors::Storage::Dropbox::AuthenticationError.wrap(var, "Could not create or authenticate a new session"))
        end
      end
    end
  end
end;Fi[	@•iâI"∏        rescue => var
          raise(Errors::Storage::Dropbox::AuthenticationError.wrap(var, "Could not create or authenticate a new session"))
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/storage/ftp.rb;TidI"ñ            var.mkdir(var.join("/"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@™ieI"v          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@™ifI"S            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/storage/local.rb;Ti=I"Ï        else
          Logger.warn(Errors::Storage::Local::TransferError.new("            Local File Copy Warning!\n            The final backup file(s) for '#{@model.label}' (#{@model.trigger})\n            will be *copied* to '#{remote_path_for(@package)}'\n            To avoid this, when using more than one Storage, the 'Local' Storage\n            should be added *last* so the files may be *moved* to their destination.\n"))
          @var = :cp
        end
      end
    end
  end
end;Fi[	@±i>I"ﬂ          Logger.warn(Errors::Storage::Local::TransferError.new("            Local File Copy Warning!\n            The final backup file(s) for '#{@model.label}' (#{@model.trigger})\n            will be *copied* to '#{remote_path_for(@package)}'\n            To avoid this, when using more than one Storage, the 'Local' Storage\n            should be added *last* so the files may be *moved* to their destination.\n"))
          @var = :cp
        end
      end
    end
  end
end;Fi[	I"1data//backup_proj/backup/storage/ninefold.rb;TiWI"ß          end
        else
          raise(Errors::Storage::Ninefold::NotFoundError, "Directory at '#{remote_path}' not found")
        end
      end
    end
  end
end;Fi[	@∂iXI"ô        else
          raise(Errors::Storage::Ninefold::NotFoundError, "Directory at '#{remote_path}' not found")
        end
      end
    end
  end
end;Fi[	I".data//backup_proj/backup/storage/rsync.rb;Ti}I"ô      # -z = Compresses the bytes that will be transferred to reduce bandwidth usage
      def function(arglist)
        "-z"
      end
    end
  end
end;Fi[	I"+data//backup_proj/backup/storage/s3.rb;TiFI"        transferred_files_for(var) do |arglist|
          Logger.message(("#{storage_name} started removing " + "'#{local_file}' from bucket '#{bucket}'."))
          connection.delete_object(bucket, File.join(var, var))
        end
      end
    end
  end
end;Fi[	@æiGI"‘          Logger.message(("#{storage_name} started removing " + "'#{local_file}' from bucket '#{bucket}'."))
          connection.delete_object(bucket, File.join(var, var))
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/storage/scp.rb;TiLI"¬        end
        unless var.empty? then
          raise(Errors::Storage::SCP::SSHError, ("Net::SSH reported the following errors:\n" + var.join("\n")))
        end
      end
    end
  end
end;Fi[	@√iMI"∂        unless var.empty? then
          raise(Errors::Storage::SCP::SSHError, ("Net::SSH reported the following errors:\n" + var.join("\n")))
        end
      end
    end
  end
end;Fi[	I"-data//backup_proj/backup/storage/sftp.rb;TiVI"†            var.mkdir!(var.join("/"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@»iWI"          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@»iXI"S            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I",data//backup_proj/backup/syncer/base.rb;Ti,I"o      
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/cloud/base.rb;TiúI"Ó                else
                  MUTEX.synchronize do |arglist|
                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end;Fi[	@“iùI"‚                  MUTEX.synchronize do |arglist|
                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end
        ;Fi[	@“iûI"…                    Logger.message("  [leaving] '#{remote_path}'")
                  end
                end
              end
            end
          end
        end
        
        class LocalFile;Fi[	@“i»I"•              var if var.unpack("U").!.! rescue @var = true
                "\xEF\xBF\xBD"
            end.join
          end
        end
      end
    end
  end
end;Fi[	@“i…I"n                "\xEF\xBF\xBD"
            end.join
          end
        end
      end
    end
  end
end;Fi[	@“i I"O            end.join
          end
        end
      end
    end
  end
end;Fi[	I"9data//backup_proj/backup/syncer/cloud/cloud_files.rb;TiBI"ú        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "Rackspace"
        end
      end
    end
  end
end;Fi[	@ﬂiCI"`        def function(arglist)
          "Rackspace"
        end
      end
    end
  end
end;Fi[	I"0data//backup_proj/backup/syncer/cloud/s3.rb;Ti9I"ñ        # This is the provider that Fog uses for the Cloud Files
        def function(arglist)
          "AWS"
        end
      end
    end
  end
end;Fi[	@‰i:I"Z        def function(arglist)
          "AWS"
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/base.rb;Ti+I"ñ        # Returns Rsync syntax for invoking "archive" mode
        def function(arglist)
          "--archive"
        end
      end
    end
  end
end;Fi[	@Èi,I"`        def function(arglist)
          "--archive"
        end
      end
    end
  end
end;Fi[	I"3data//backup_proj/backup/syncer/rsync/local.rb;Ti-I"¬        # concatenated, ready for the CLI
        def function(arglist)
          ([archive_option, mirror_option] + additional_options).compact.join(" ")
        end
      end
    end
  end
end;Fi[	@Ói.I"ò        def function(arglist)
          ([archive_option, mirror_option] + additional_options).compact.join(" ")
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/pull.rb;TiI"©        # Return expanded @path, since this path is local
        def function(arglist)
          @var ||= File.expand_path(@var)
        end
      end
    end
  end
end;Fi[	@ÛiI"t        def function(arglist)
          @var ||= File.expand_path(@var)
        end
      end
    end
  end
end;Fi[	I"2data//backup_proj/backup/syncer/rsync/push.rb;TijI"}        def function(arglist)
          @var.delete if @var
          @var = nil
        end
      end
    end
  end
end;Fi[	@¯ikI"_          @var.delete if @var
          @var = nil
        end
      end
    end
  end
end;Fi[	I"&data//bundler_proj/bundler/cli.rb;TiI"           Bundler.ui.info("Gems included by the bundle:")
          Bundler.load.specs.sort_by { |arglist| var.name }.each do |arglist|
            Bundler.ui.info("  * #{s.name} (#{s.version}#{s.git_version})")
          end
        end
      end
    end
    
    map(["list"] => "show");Fi[	I"-data//bundler_proj/bundler/definition.rb;TiùI"ﬁ            var = var.specs
            var = (var + var.unmet_dependency_names)
            var.add_source(var)
          end
        end
      end
    end
    
    # used when frozen is enabled so we can find the bundler;Fi[	@ iºI"¶      var.map! { |arglist| var.to_sym }
      dependencies.reject do |arglist|
        (var.should_include?.! or var.groups.&(var).empty?)
      end
    end
  end
end;Fi[	I"-data//bundler_proj/bundler/deployment.rb;Ti$I"€          (var << var.to_s)
          (var << "--without #{bundle_without.join(" ")}") unless var.empty?
          run("cd #{app_path} && #{bundle_cmd} install #{args.join(" ")}")
        end
      end
    end
  end
end;Fi[	@i%I"ø          (var << "--without #{bundle_without.join(" ")}") unless var.empty?
          run("cd #{app_path} && #{bundle_cmd} install #{args.join(" ")}")
        end
      end
    end
  end
end;Fi[	I"&data//bundler_proj/bundler/dsl.rb;TibI"h              return
            else
              raise(GemfileError, "You cannot specify the same gem twice coming from different sources.\nYou specified that #{dep.name} (#{dep.requirement}) should come from #{(current.source or "an unspecified source")} and #{dep.source}\n")
            end
          end
        end
      end
      (@var << var)
    end;Fi[	I"&data//bundler_proj/bundler/env.rb;Ti1I"x        "<No #{filename} found>"
      rescue => var
        "#{e.class}: #{e.message}"
      end
    end
  end
end;Fi[	I".data//bundler_proj/bundler/gem_helpers.rb;TiI"ø      GENERIC_CACHE[var] ||= begin
        (var = GENERICS.find { |arglist| var.is_a?(Gem::Platform) and (var.os == var.os) }
        (var or Gem::Platform::RUBY))
      end
    end
  end
end;Fi[	I"(data//bundler_proj/bundler/graph.rb;TiéI"’          rescue ArgumentError => var
            $stderr.puts("Unsupported output format. See Ruby-Graphviz/lib/graphviz/constants.rb")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	@ièI"Ø            $stderr.puts("Unsupported output format. See Ruby-Graphviz/lib/graphviz/constants.rb")
            raise(var)
          end
        end
      end
    end
  end
end;Fi[	@iêI"Q            raise(var)
          end
        end
      end
    end
  end
end;Fi[	I"+data//bundler_proj/bundler/injector.rb;Ti/I"ç        var.puts
        var.puts("# Added at #{Time.now} by #{`whoami`.chomp}:")
        var.puts(new_gem_lines)
      end
    end
  end
end;Fi[	I",data//bundler_proj/bundler/installer.rb;Ti¿I"»        var.puts("path = File.expand_path('..', __FILE__)")
        var.each do |arglist|
          var.puts("$:.unshift File.expand_path(\"#{path}/#{path}\")")
        end
      end
    end
  end
end;Fi[	@i¡I"å        var.each do |arglist|
          var.puts("$:.unshift File.expand_path(\"#{path}/#{path}\")")
        end
      end
    end
  end
end;Fi[	I"7data//bundler_proj/bundler/remote_specification.rb;Ti6I"m        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	I"+data//bundler_proj/bundler/resolver.rb;TiÎI"√            if var.include?(var) then
              debug { |arglist| "    -> Jumping to: #{savepoint}" }
              throw(var)
            end
          end
        end
      end
    end
    ;Fi[	@%iÏI"∑              debug { |arglist| "    -> Jumping to: #{savepoint}" }
              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	@%ipI"F          end
        end
        var
      end
    end
  end
end;Fi[	I"/data//bundler_proj/bundler/ruby_version.rb;Ti+I"ï            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end
  ;Fi[	@,i,I"{          else
            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion;Fi[	@,iJI"}        (raise(BundlerError, "That RUBY_ENGINE is not recognized")
        # do nothing
        )
      end
    end
  end
end;Fi[	I"7data//bundler_proj/bundler/rubygems_integration.rb;Ti°I"™            @var = RubygemsIntegration::Legacy.new
          else
            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  ;Fi[	@3i¢I"á          else
            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  
  class << self;Fi[	I"*data//bundler_proj/bundler/runtime.rb;Ti>I"“              var = $1
              raise(var) if (var.autorequire or (var and var.gsub("-", "/").!=(var)))
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    ;Fi[	@8i?I"’              raise(var) if (var.autorequire or (var and var.gsub("-", "/").!=(var)))
              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"+data//bundler_proj/bundler/settings.rb;TiÖI"t        Hash[var.read.scan(/^(BUNDLE_.+): ['"]?(.+?)['"]?$/)]
      else
        {}
      end
    end
  end
end;Fi[	I"1data//bundler_proj/bundler/shared_helpers.rb;TiI"Ã    if instance_methods.map { |arglist| var.to_s }.include?("requirement").! then
      def function(arglist)
        version_requirements
      end
    end
  end
end
module Bundler
  module SharedHelpers;Fi[	I"7data//bundler_proj/bundler/source/git/git_proxy.rb;Ti}I"˝            in_path { |arglist| yield }
          else
            raise(GitError, "The git source #{uri} is not yet checked out. Please run `bundle install` before trying to start your application")
          end
        end
      end
    end
  end
end;Fi[	@Ci~I"’          else
            raise(GitError, "The git source #{uri} is not yet checked out. Please run `bundle install` before trying to start your application")
          end
        end
      end
    end
  end
end;Fi[	@CiI"∆            raise(GitError, "The git source #{uri} is not yet checked out. Please run `bundle install` before trying to start your application")
          end
        end
      end
    end
  end
end;Fi[	I"-data//bundler_proj/bundler/source/git.rb;Ti⁄I"Æ      def function(arglist)
        @var ||= GitProxy.new(cache_path, uri, ref, cached_revision) do |arglist|
          allow_git_ops?
        end
      end
    end
  end
end;Fi[	@Ji€I"í        @var ||= GitProxy.new(cache_path, uri, ref, cached_revision) do |arglist|
          allow_git_ops?
        end
      end
    end
  end
end;Fi[	I"8data//bundler_proj/bundler/source/path/installer.rb;Ti#I"            Bundler.mkdir_p("#{Bundler.rubygems.gem_dir}/bin")
            spec.executables.each do |arglist|
              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end;Fi[	@Oi$I"”            spec.executables.each do |arglist|
              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end
end;Fi[	@Oi%I"§              Bundler.sudo("cp -R #{Bundler.tmp}/bin/#{exe} #{Bundler.rubygems.gem_dir}/bin/")
            end
          end
        end
      end
    end
  end
end;Fi[	@Oi&I"J            end
          end
        end
      end
    end
  end
end;Fi[	I".data//bundler_proj/bundler/source/path.rb;TiªI"Ì            var = " at #{$1}" if var.inspect =~ /@(.*:\d+)/
            var = "#{type} hook#{location} failed for #{installer.spec.full_name}"
            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	@XiºI"±            var = "#{type} hook#{location} failed for #{installer.spec.full_name}"
            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	@XiΩI"c            raise(InstallHookError, var)
          end
        end
      end
    end
  end
end;Fi[	I"2data//bundler_proj/bundler/source/rubygems.rb;Ti“I"s          var)
        ensure
          Bundler.rubygems.sources = var
        end
      end
    end
  end
end;Fi[	@_i”I"d        ensure
          Bundler.rubygems.sources = var
        end
      end
    end
  end
end;Fi[	I"+data//bundler_proj/bundler/spec_set.rb;TiÖI"≈      var.dependencies.sort_by { |arglist| var.name }.each do |arglist|
        next if (var.type == :development)
        lookup[var.name].each { |arglist| yield(var) }
      end
    end
  end
end;Fi[	I"%data//bundler_proj/bundler/ui.rb;TimI"}          @var.info("with native extensions ")
        else
          @var.debug(var)
        end
      end
    end
  end
end;Fi[	@ginI"S        else
          @var.debug(var)
        end
      end
    end
  end
end;Fi[	I"9data//bundler_proj/bundler/vendor/net/http/faster.rb;TiI"y        end
      else
        timeout(@var) { |arglist| (@var << @var.sysread(65536)) }
      end
    end
  end
end;Fi[	I"=data//bundler_proj/bundler/vendor/net/http/persistent.rb;Ti$I"ï        var.each_value do |arglist|
          finish(var, var)
          var.delete(var.object_id) if var
        end
      end
    end
  end
  
  ##;Fi[	I"Bdata//bundler_proj/bundler/vendor/thor/actions/create_file.rb;TicI"É      #
      def function(arglist)
        base.shell.file_collision(destination) { |arglist| render }
      end
    end
  end
end;Fi[	I"Bdata//bundler_proj/bundler/vendor/thor/actions/create_link.rb;Ti4I"T          end
        end
        given_destination
      end
    end
  end
end;Fi[	I"@data//bundler_proj/bundler/vendor/thor/actions/directory.rb;Ti^I"¿            var = base.template(var, var[(0..-4)], config, &@var)
          else
            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	@xi_I"~          else
            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	@xi`I"t            var = base.copy_file(var, var, config, &@var)
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//bundler_proj/bundler/vendor/thor/actions/empty_directory.rb;TiâI"ë      #
      def function(arglist)
        base.shell.say_status(var, relative_destination, var) if config[:verbose]
      end
    end
  end
end;Fi[	I"Hdata//bundler_proj/bundler/vendor/thor/actions/file_manipulation.rb;Ti0I"e        output_buffer)
      ensure
        self.output_buffer = var
      end
    end
  end
end;Fi[	I"Gdata//bundler_proj/bundler/vendor/thor/actions/inject_into_file.rb;TiYI"“          if (var or var.include?(replacement).!) then
            var.gsub!(var, var)
            File.open(destination, "wb") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	@ÖiZI"õ            var.gsub!(var, var)
            File.open(destination, "wb") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	@Öi[I"{            File.open(destination, "wb") { |arglist| var.write(var) }
          end
        end
      end
    end
  end
end;Fi[	I"6data//bundler_proj/bundler/vendor/thor/actions.rb;TiI"b        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	I"Tdata//bundler_proj/bundler/vendor/thor/core_ext/hash_with_indifferent_access.rb;Ti=I"ä          var.empty? ? (self[$1].!.!) : ((self[$1] == var.first))
        else
          self[var]
        end
      end
    end
  end
end;Fi[	@èi>I"M        else
          self[var]
        end
      end
    end
  end
end;Fi[	I"Ddata//bundler_proj/bundler/vendor/thor/core_ext/ordered_hash.rb;TiRI"i        
        def function(arglist)
          @var.empty?
        end
      end
    end
  end
end;Fi[	@îiSI"`        def function(arglist)
          @var.empty?
        end
      end
    end
  end
end;Fi[	I">data//bundler_proj/bundler/vendor/thor/parser/argument.rb;TiMI"X        "one two three"
      else
        # do nothing
      end
    end
  end
end;Fi[	I"?data//bundler_proj/bundler/vendor/thor/parser/arguments.rb;TiìI"”        end.join("', '")
        var = self.class.name.split("::").last.downcase
        raise(RequiredArgumentMissingError, "No value provided for required #{class_name} '#{names}'")
      end
    end
  end
end;Fi[	I"=data//bundler_proj/bundler/vendor/thor/parser/options.rb;Ti“I"Ù                return var.lazy_default
              else
                raise(MalformattedArgumentError, "No value provided for option '#{switch}'")
              end
            end
          end
        end
      end
      @var.delete(var);Fi[	@üi”I"Ú              else
                raise(MalformattedArgumentError, "No value provided for option '#{switch}'")
              end
            end
          end
        end
      end
      @var.delete(var)
      send(:"parse_#{var.type}", var);Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/basic.rb;TiPI"G          end)
        end
        var
      end
    end
  end
end;Fi[	I":data//bundler_proj/bundler/vendor/thor/shell/color.rb;TiçI"e          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@ßiéI"U        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	I"9data//bundler_proj/bundler/vendor/thor/shell/html.rb;Ti{I"e          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@¨i|I"U        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	I"3data//bundler_proj/bundler/vendor/thor/task.rb;TiÇI"f        super
      else
        var.class.handle_no_task_error(name)
      end
    end
  end
end;Fi[	I"3data//bundler_proj/bundler/vendor/thor/util.rb;TiZI"ø              ENV["APPDATA"]
            else
              File.expand_path("~") rescue File::ALT_SEPARATOR ? ("C:/") : ("/")
            end
          end
        end
      end
    end
    ;Fi[	@¥i[I"¬            else
              File.expand_path("~") rescue File::ALT_SEPARATOR ? ("C:/") : ("/")
            end
          end
        end
      end
    end
    
    def self.thor_root(arglist);Fi[	I"4data//cancan_proj/cancan/controller_resource.rb;TiII"¶            true
          else
            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected;Fi[	I"@data//cancan_proj/cancan/model_adapters/abstract_adapter.rb;Ti0I"ß      
      def function(arglist)
        raise(NotImplemented, "This model adapter does not support fetching records from the database.")
      end
    end
  end
end;Fi[	I"Edata//cancan_proj/cancan/model_adapters/active_record_adapter.rb;TiìI"ƒ              "(#{conditions}) OR (#{sql})"
            else
              "not (#{conditions}) AND (#{sql})"
            end
          end
        end
      end
      
      def function(arglist);Fi[	@øi∂I"…          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end
ActiveRecord::Base.class_eval { |arglist| include(CanCan::ModelAdditions) };Fi[	I"Cdata//cancan_proj/cancan/model_adapters/data_mapper_adapter.rb;Ti$I"ø          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end
DataMapper::Model.append_extensions(CanCan::ModelAdditions::ClassMethods);Fi[	I"?data//cancan_proj/cancan/model_adapters/mongoid_adapter.rb;Ti&I"‘                var.or(var.conditions)
              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end;Fi[	@«i'I"≥              else
                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end;Fi[	@«i(I"§                var.base_behavior.! ? (var.excludes(var.conditions)) : (var)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@«i)I"~              end
            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods;Fi[	@«i*I"ú            end
          end
        end
      end
    end
  end
end
module Mongoid::Document::ClassMethods
  include(CanCan::ModelAdditions::ClassMethods);Fi[	I"%data//cancan_proj/cancan/rule.rb;Ti0I"©              matches_conditions_hash?(var)
            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    ;Fi[	@“i1I"ó            else
              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	@“iÄI"ƒ                end
              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end;Fi[	@“iÅI"µ              else
                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    ;Fi[	@“iÇI"º                var.kind_of?(Enumerable) ? (var.include?(var)) : ((var == var))
              end
            end
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"Edata//cancan_proj/generators/cancan/ability/ability_generator.rb;TiI"|      
      def function(arglist)
        copy_file("ability.rb", "app/models/ability.rb")
      end
    end
  end
end;Fi[	I"1data//capistrano_proj/capistrano/callback.rb;TiI"¶          return except.include?(var.fully_qualified_name).!
        else
          return true
        end
      end
    end
  end
  
  class ProcCallback < Callback;Fi[	I"4data//capistrano_proj/capistrano/cli/execute.rb;TiQI"k          abort(var.message)
        else
          raise(var)
        end
      end
    end
  end
end;Fi[	@„iRI"N        else
          raise(var)
        end
      end
    end
  end
end;Fi[	I"1data//capistrano_proj/capistrano/cli/help.rb;Ti|I"G          end
        end
        @var
      end
    end
  end
end;Fi[	I"4data//capistrano_proj/capistrano/cli/options.rb;Ti«I"U          nil
        else
          var
        end
      end
    end
  end
end;Fi[	@Îi»I"G        else
          var
        end
      end
    end
  end
end;Fi[	I"/data//capistrano_proj/capistrano/cli/ui.rb;Ti#I"∫            var.default = "y"
            var.validate = /(y(es)?)|(no?)|(a(bort)?|\n)/i
            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	@i$I"ú            var.validate = /(y(es)?)|(no?)|(a(bort)?|\n)/i
            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	@i%I"f            var.responses[:not_valid] = var
          end
        end
      end
    end
  end
end;Fi[	I"0data//capistrano_proj/capistrano/command.rb;TiRI"ø                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        
        def function(arglist);Fi[	@˜iI"ª        options[:env].inject("env") do |arglist|
          var = var.to_s.gsub(/[ "]/) { |arglist| "\#{m}" }
          (var << " #{name}=#{value}")
        end
      end
    end
  end
end;Fi[	@˜iI"ä          var = var.to_s.gsub(/[ "]/) { |arglist| "\#{m}" }
          (var << " #{name}=#{value}")
        end
      end
    end
  end
end;Fi[	I"Ldata//capistrano_proj/capistrano/configuration/actions/file_transfer.rb;Ti.I"Ò          execute_on_servers(var) do |arglist|
            var = var.map { |arglist| sessions[var] }
            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	@˛i/I"¬            var = var.map { |arglist| sessions[var] }
            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	@˛i0I"å            Transfer.process(var, var, var, var, var.merge(:logger => (logger)), &var)
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//capistrano_proj/capistrano/configuration/actions/inspect.rb;Ti/I"X            end
          end
          var
        end
      end
    end
  end
end;Fi[	@i0I"H          end
          var
        end
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/configuration/actions/invocation.rb;TiI"w            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@
iI"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@
iI"S            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"Adata//capistrano_proj/capistrano/configuration/alias_task.rb;TiI"f        var = var.dup
        var.name = var
        define_task(var)
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/configuration/callbacks.rb;TiqI"Ü              var[:only] = filter_deprecated_tasks(var[:only])
              var[:except] = filter_deprecated_tasks(var[:except])
              callbacks[var].concat(var.map { |arglist| TaskCallback.new(self, var, var) })
            end
          end
        end
      end
      
      # Filters the given task name or names and attempts to replace deprecated tasks with their equivalents.;Fi[	@iãI"≠          (var << " for `#{task.fully_qualified_name}'") if var
          logger.trace(var)
          var.each { |arglist| var.call }
        end
      end
    end
  end
end;Fi[	@iåI"r          logger.trace(var)
          var.each { |arglist| var.call }
        end
      end
    end
  end
end;Fi[	I"Bdata//capistrano_proj/capistrano/configuration/connections.rb;TiÿI"õ        rescue Exception => var
          raise unless var
          (var << { :server => (var), :error => (var) })
        end
      end
    end
  end
end;Fi[	@iŸI"{          raise unless var
          (var << { :server => (var), :error => (var) })
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/configuration/execution.rb;TiáI"≥      # Invokes the task's body directly, without setting up the call frame.
      def function(arglist)
        var.namespace.instance_eval(&var.body)
      end
    end
  end
end;Fi[	I">data//capistrano_proj/capistrano/configuration/loading.rb;TijI"Ô                  instance_eval(&var[:proc])
                else
                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end;Fi[	@#ikI"…                else
                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end
      ;Fi[	@#ilI"                  raise(ArgumentError, "don't know how to load #{options.inspect}")
                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,;Fi[	@#iºI"ª        if self.class.current_feature then
          var = self.class.recipes_per_feature[self.class.current_feature] ||= []
          (var << var)
        end
      end
    end
  end
end;Fi[	@#iΩI"ê          var = self.class.recipes_per_feature[self.class.current_feature] ||= []
          (var << var)
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/configuration/log_formatters.rb;TiI"j      
      def function(arglist)
        @var.disable_formatters = true
      end
    end
  end
end;Fi[	I"<data//capistrano_proj/capistrano/configuration/roles.rb;TiHI"á      
      def function(arglist)
        (roles.map { |arglist| var if var.include?(var) }.compact or [])
      end
    end
  end
end;Fi[	I">data//capistrano_proj/capistrano/configuration/servers.rb;TigI"ó      
      def function(arglist)
        Array(var).map { |arglist| var.respond_to?(:call) ? (var.call) : (var) }.flatten
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/configuration/variables.rb;TiyI"Ñ          self[var]
        else
          method_missing_without_variables(var, *var, &var)
        end
      end
    end
  end
end;Fi[	@7izI"u        else
          method_missing_without_variables(var, *var, &var)
        end
      end
    end
  end
end;Fi[	I"7data//capistrano_proj/capistrano/ext/multistage.rb;Ti3I"L          File.open(var, "w") do |arglist|
            var.puts("# #{name.upcase}-specific deployment configuration")
            var.puts("# please put general deployment config in config/deploy.rb")
          end
        end
      end
    end
  end
  on(:start, "multistage:ensure", :except => ((stages + ["multistage:prepare"])));Fi[	@<i4I"%            var.puts("# #{name.upcase}-specific deployment configuration")
            var.puts("# please put general deployment config in config/deploy.rb")
          end
        end
      end
    end
  end
  on(:start, "multistage:ensure", :except => ((stages + ["multistage:prepare"])))
end;Fi[	I">data//capistrano_proj/capistrano/recipes/deploy/assets.rb;TiHI"R        return false
      else
        run("          cd -- #{previous_release.shellescape} &&\n          cp -f -- #{previous_manifest.shellescape} #{shared_path.shellescape}/assets/manifest.yml &&\n          #{rake} RAILS_ENV=#{rails_env.to_s.shellescape} #{asset_env} assets:precompile:nondigest\n".compact)
      end
    end
  end
end;Fi[	I"Ddata//capistrano_proj/capistrano/recipes/deploy/dependencies.rb;Ti,I"h      
      def function(arglist)
        all? { |arglist| var.pass? }
      end
    end
  end
end;Fi[	I"Hdata//capistrano_proj/capistrano/recipes/deploy/local_dependency.rb;Ti8I"Å      
      def self.windows_executable_extensions(arglist)
        [".exe", ".bat", ".com", ".cmd"]
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/recipes/deploy/remote_dependency.rb;TimI"ì        rescue Capistrano::CommandError => var
          @var = false
          @var = var.hosts.join(", ")
        end
      end
    end
  end
end;Fi[	@JinI"i          @var = false
          @var = var.hosts.join(", ")
        end
      end
    end
  end
end;Fi[	I"Cdata//capistrano_proj/capistrano/recipes/deploy/scm/accurev.rb;Ti~I"Æ          
          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	@OiI"£          def function(arglist)
            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	@OiÄI"É            (stream == var.stream) and (transaction_id == var.transaction_id)
          end
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/scm/base.rb;Ti≤I"ä          var = variable(:scm_arguments)
          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	@Vi≥I"f          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/bzr.rb;TiKI"ò        
        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("-r #{revision}".chomp)
        end
      end
    end
  end
end;Fi[	@[iLI"è        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("-r #{revision}".chomp)
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/cvs.rb;TiâI"à          var = var.pop
          var = var.join("/")
          "mkdir -p #{dest} && cd #{dest}"
        end
      end
    end
  end
end;Fi[	@`iäI"u          var = var.join("/")
          "mkdir -p #{dest} && cd #{dest}"
        end
      end
    end
  end
end;Fi[	I"Adata//capistrano_proj/capistrano/recipes/deploy/scm/darcs.rb;Ti[I"j            nil
          else
            "-v"
          end
        end
      end
    end
  end
end;Fi[	@ei\I"Z          else
            "-v"
          end
        end
      end
    end
  end
end;Fi[	@ei]I"K            "-v"
          end
        end
      end
    end
  end
end;Fi[	I"?data//capistrano_proj/capistrano/recipes/deploy/scm/git.rb;TiòI"©        # command-line switch for "quiet" ("-q").
        def function(arglist)
          variable(:scm_verbose) ? (nil) : ("-q")
        end
      end
    end
  end
end;Fi[	@liôI"|        def function(arglist)
          variable(:scm_verbose) ? (nil) : ("-q")
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/scm/mercurial.rb;TinI"«          @var ||= (variable(:scm_password) or if variable(:scm_prefer_prompt) then
            Capistrano::CLI.password_prompt("hg password: ")
          end)
        end
      end
    end
  end
end;Fi[	@qioI"x            Capistrano::CLI.password_prompt("hg password: ")
          end)
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/scm/none.rb;Ti$I"¶        # log: There's no log, so it just echos from and to.
        def function(arglist)
          "No SCM: #{from} - #{to}"
        end
      end
    end
  end
end;Fi[	@vi%I"n        def function(arglist)
          "No SCM: #{from} - #{to}"
        end
      end
    end
  end
end;Fi[	I"Ddata//capistrano_proj/capistrano/recipes/deploy/scm/perforce.rb;TiÜI"t            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end
end;Fi[	@{iáI"Y          else
            var
          end
        end
      end
    end
  end
end;Fi[	@{iàI"J            var
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//capistrano_proj/capistrano/recipes/deploy/scm/subversion.rb;TitI"–        
        def function(arglist)
          @var ||= (variable(:scm_password) or (variable(:password) or Capistrano::CLI.password_prompt("Subversion password: ")))
        end
      end
    end
  end
end;Fi[	@ÇiuI"«        def function(arglist)
          @var ||= (variable(:scm_password) or (variable(:password) or Capistrano::CLI.password_prompt("Subversion password: ")))
        end
      end
    end
  end
end;Fi[	I";data//capistrano_proj/capistrano/recipes/deploy/scm.rb;TiI"õ          end)
        rescue LoadError
          raise(Capistrano::Error, "could not find any SCM named `#{scm}'")
        end
      end
    end
  end
end;Fi[	@áiI"å        rescue LoadError
          raise(Capistrano::Error, "could not find any SCM named `#{scm}'")
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/strategy/base.rb;TiOI"å        # and not a pseudo-id.
        def function(arglist)
          configuration[:real_revision]
        end
      end
    end
  end
end;Fi[	@åiPI"r        def function(arglist)
          configuration[:real_revision]
        end
      end
    end
  end
end;Fi[	I"Idata//capistrano_proj/capistrano/recipes/deploy/strategy/checkout.rb;TiI"Ÿ        # Returns the SCM's checkout command for the revision to deploy.
        def function(arglist)
          @var ||= source.checkout(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	@ëiI"ê        def function(arglist)
          @var ||= source.checkout(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	I"Edata//capistrano_proj/capistrano/recipes/deploy/strategy/copy.rb;Ti"I"í        def function(arglist)
          upload(filename, remote_filename)
          decompress_remote_file
        end
      end
    end
  end
end;Fi[	@ñi#I"y          upload(filename, remote_filename)
          decompress_remote_file
        end
      end
    end
  end
end;Fi[	I"Gdata//capistrano_proj/capistrano/recipes/deploy/strategy/export.rb;TiI"’        # Returns the SCM's export command for the revision to deploy.
        def function(arglist)
          @var ||= source.export(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	@õiI"é        def function(arglist)
          @var ||= source.export(revision, configuration[:release_path])
        end
      end
    end
  end
end;Fi[	I"Gdata//capistrano_proj/capistrano/recipes/deploy/strategy/remote.rb;Ti+I"‘        # revision being deployed to the REVISION file on each host.
        def function(arglist)
          "(echo #{revision} > #{configuration[:release_path]}/REVISION)"
        end
      end
    end
  end
end;Fi[	@†i,I"è        def function(arglist)
          "(echo #{revision} > #{configuration[:release_path]}/REVISION)"
        end
      end
    end
  end
end;Fi[	I"Mdata//capistrano_proj/capistrano/recipes/deploy/strategy/remote_cache.rb;Ti0I"è        
        def function(arglist)
          @var ||= Array(configuration.fetch(:copy_exclude, []))
        end
      end
    end
  end
end;Fi[	@•i1I"Ü        def function(arglist)
          @var ||= Array(configuration.fetch(:copy_exclude, []))
        end
      end
    end
  end
end;Fi[	I"Vdata//capistrano_proj/capistrano/recipes/deploy/strategy/unshared_remote_cache.rb;TiI"~        
        def function(arglist)
          configuration[:repository_cache]
        end
      end
    end
  end
end;Fi[	@™iI"u        def function(arglist)
          configuration[:repository_cache]
        end
      end
    end
  end
end;Fi[	I"@data//capistrano_proj/capistrano/recipes/deploy/strategy.rb;TiI"•          end)
        rescue LoadError
          raise(Capistrano::Error, "could not find any strategy named `#{strategy}'")
        end
      end
    end
  end
end;Fi[	@ØiI"ñ        rescue LoadError
          raise(Capistrano::Error, "could not find any strategy named `#{strategy}'")
        end
      end
    end
  end
end;Fi[	I"7data//capistrano_proj/capistrano/recipes/deploy.rb;TiyI"∏                :perforce
              else
                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end;Fi[	@¥izI"§              else
                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end;Fi[	@¥i{I"ï                File.exist?(".svn") ? (:subversion) : (:none)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@¥i|I"£              end
            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your;Fi[	@¥i}I"•            end
          end
        end
      end
    end
  end
end
# Auxiliary helper method for the `deploy:check' task. Lets you set up your
# own dependencies.;Fi[	I",data//capistrano_proj/capistrano/ssh.rb;Ti-I"        raise if (var.empty? or var[:auth_methods])
        var = var[:password]
        retry
      end
    end
  end
end;Fi[	I"1data//capistrano_proj/capistrano/transfer.rb;Ti¡I"R        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	I"8data//compass_proj/compass/app_integration/rails.rb;TiI"K      def function(arglist)
        Compass::Util.compass_warn("WARNING:  Please remove the call to Compass::AppIntegration::Rails.env from #{caller[0].sub(/:.*$/, "")};\nWARNING:  This is done automatically now. If this is default compass initializer you can just remove the file.")
        ::Rails.env
      end
    end
  end
end;Fi[	I"Udata//compass_proj/compass/app_integration/stand_alone/configuration_defaults.rb;TiI"k        
        def function(arglist)
          ".sass-cache"
        end
      end
    end
  end
end;Fi[	@»i I"b        def function(arglist)
          ".sass-cache"
        end
      end
    end
  end
end;Fi[	I"Hdata//compass_proj/compass/app_integration/stand_alone/installer.rb;Ti?I"k        
        def function(arglist)
          @var.compile?
        end
      end
    end
  end
end;Fi[	@Õi@I"b        def function(arglist)
          @var.compile?
        end
      end
    end
  end
end;Fi[	I">data//compass_proj/compass/app_integration/stand_alone.rb;TiI"î      
      def function(arglist)
        Compass::Configuration::Data.new("stand_alone").extend(ConfigurationDefaults)
      end
    end
  end
end;Fi[	I"0data//compass_proj/compass/commands/base.rb;Ti,I"±          raise(Compass::Error.new("No such framework: #{options[:framework].inspect}"))
        end
        Compass::Frameworks[options[:framework]]
      end
    end
  end
end;Fi[	I"=data//compass_proj/compass/commands/installer_command.rb;Ti I"ô      
      def function(arglist)
        [template_directory((options[:pattern] or "project")), project_directory, options]
      end
    end
  end
end;Fi[	I"8data//compass_proj/compass/commands/project_base.rb;TigI"Q      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	I"4data//compass_proj/compass/commands/registry.rb;TiI"            raise(Compass::Error, "Ambiguous abbreviation '#{name}'. Did you mean one of: #{matching.join(", ")}")
          else
            raise(Compass::Error, "Command not found: #{name}")
          end
        end
      end
    end
    
    def function(arglist);Fi[	I"9data//compass_proj/compass/configuration/adapters.rb;TiMI"e        end
        (var << Compass::SpriteImporter.new)
        var
      end
    end
  end
end;Fi[	I"9data//compass_proj/compass/configuration/comments.rb;Ti-I"k          "\n# If you prefer the indented syntax, you might want to regenerate this\n# project again passing --syntax sass, or you can uncomment this:\n# preferred_syntax = :sass\n# and then run:\n# sass-convert -R --from scss --to sass #{top_level.sass_dir} scss && rm -rf sass && mv scss sass\n"
        else
          ""
        end
      end
    end
  end
end;Fi[	@‰i.I"F        else
          ""
        end
      end
    end
  end
end;Fi[	I"5data//compass_proj/compass/configuration/data.rb;TiI"’            else
              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      ;Fi[	@ÈiÄI"‡              if inherited_data.respond_to?(:asset_cache_buster) then
                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	@Èi∞I"”        else
          if (var.size > 0) then
            raise(Error, "Illegal configuration attributes: #{illegal_attrs.map { |a| a.inspect }.join(", ")}")
          end
        end
      end
    end
  end
end;Fi[	@Èi±I"∆          if (var.size > 0) then
            raise(Error, "Illegal configuration attributes: #{illegal_attrs.map { |a| a.inspect }.join(", ")}")
          end
        end
      end
    end
  end
end;Fi[	@Èi≤I"•            raise(Error, "Illegal configuration attributes: #{illegal_attrs.map { |a| a.inspect }.join(", ")}")
          end
        end
      end
    end
  end
end;Fi[	I"9data//compass_proj/compass/configuration/defaults.rb;Ti¨I"o      
      def function(arglist)
        http_join(top_level.http_path, var)
      end
    end
  end
end;Fi[	I":data//compass_proj/compass/configuration/file_data.rb;TiI"Ü        var = new(var)
        var.with_defaults(var) { |arglist| var.parse_string(var, var) }
        var
      end
    end
  end
end;Fi[	I"8data//compass_proj/compass/configuration/helpers.rb;Ti1I"                    Compass::AppIntegration.lookup(var).configuration
                  else
                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end;Fi[	@˙i2I"”                  else
                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end;Fi[	@˙i3I"√                    raise("I don't know what to do with: #{config.inspect}")
                  end
                end
              end
            end
          end
        end
      end
      ;Fi[	@˙i4I"ì                  end
                end
              end
            end
          end
        end
      end
      
      # Support for testing.;Fi[	I"<data//compass_proj/compass/configuration/inheritance.rb;TiôI""                inherited_data.send("#{attribute}_without_default")
              else
                inherited_data.send(var) if inherited_data.respond_to?(var)
              end
            end
          end
        end
        
        # Reads the raw value that was set on this object.;Fi[	@i–I"c            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	@i—I"H          end
          var
        end
      end
    end
  end
end;Fi[	I">data//compass_proj/compass/configuration/serialization.rb;TiOI"ﬁ      def function(arglist)
        if (http_images_path == :relative) then
          $stderr.puts("DEPRECATION WARNING: Please set relative_assets = true to enable relative paths.")
        end
      end
    end
  end
end;Fi[	@
iPI"¬        if (http_images_path == :relative) then
          $stderr.puts("DEPRECATION WARNING: Please set relative_assets = true to enable relative paths.")
        end
      end
    end
  end
end;Fi[	I"6data//compass_proj/compass/exec/sub_command_ui.rb;Ti3I"ü      rescue OptionParser::ParseError => var
        puts("Error: #{e.message}")
        puts(var.usage) if var.respond_to?(:usage)
      end
    end
  end
end;Fi[	I"<data//compass_proj/compass/installers/bare_installer.rb;Ti%I"ﬁ      
      def function(arglist)
        puts("\n*********************************************************************\nCongratulations! Your compass project has been created.\n\nYou may now add sass stylesheets to the #{Compass.configuration.sass_dir} subdirectory of your project.\n\nSass files beginning with an underscore are called partials and won't be\ncompiled to CSS, but they can be imported into other sass stylesheets.\n\nYou can configure your project by editing the config.rb configuration file.\n\nYou must compile your sass stylesheets into CSS when they change.\nThis can be done in one of the following ways:\n  1. To compile on demand:\n     compass compile [path/to/project]\n  2. To monitor your project for changes and automatically recompile:\n     compass watch [path/to/project]\n\nMore Resources:\n  * Website: http://compass-style.org/\n  * Sass: http://sass-lang.com\n  * Community: http://groups.google.com/group/compass-users/\n")
      end
    end
  end
end;Fi[	I"2data//compass_proj/compass/installers/base.rb;Ti™I"Ú      # Emits an HTML fragment that can be used to link to the compiled css files
      def function(arglist)
        ""
      end
    end
  end
end
require("compass/installers/bare_installer")
require("compass/installers/manifest_installer");Fi[	I"6data//compass_proj/compass/installers/manifest.rb;TiÜI"S      
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	I"@data//compass_proj/compass/installers/manifest_installer.rb;Ti5I"g          (var << (var + "\n"))
        end
        (var << "</head>")
      end
    end
  end
end;Fi[	I">data//compass_proj/compass/installers/template_context.rb;Ti(I"}      def function(arglist)
        @var.each { |arglist| eval("#{k} = v") }
        binding
      end
    end
  end
end;Fi[	I"Rdata//compass_proj/compass/sass_extensions/functions/cross_browser_support.rb;TiAI"          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"Mdata//compass_proj/compass/sass_extensions/functions/gradient_support.rb;TiÔI"Í                ColorStop.new(var)
              else
                raise(Sass::SyntaxError, "Not a valid color stop: #{arg.class.name}: #{arg}")
              end
            end
          end
        end
      end, :comma)
    end;Fi[	@$iéI"œ              break
            else
              var = (var + 1)
            end
          end
        end
      end
      var.each do |arglist|
        if var.stop.unitless? and (var.stop.value <= 1) then;Fi[	I"Kdata//compass_proj/compass/sass_extensions/monkey_patches/traversal.rb;TiI"Ñ            var.visit_depth_first(var)
          end
          var.up(self) if children.any?
        end
      end
    end
  end
end;Fi[	@)iI"b          end
          var.up(self) if children.any?
        end
      end
    end
  end
end;Fi[	I"Tdata//compass_proj/compass/sass_extensions/sprites/engines/chunky_png_engine.rb;TiI"¥        def function(arglist)
          construct_sprite if canvas.nil?
          canvas.save(var, Compass.configuration.chunky_png_options)
        end
      end
    end
  end
end;Fi[	@.iI"ñ          construct_sprite if canvas.nil?
          canvas.save(var, Compass.configuration.chunky_png_options)
        end
      end
    end
  end
end;Fi[	I"Bdata//compass_proj/compass/sass_extensions/sprites/engines.rb;TiI"⁄        
        def function(arglist)
          raise(::Compass::Error, "You must impliment save(filename)")
        end
      end
    end
  end
end
require("compass/sass_extensions/sprites/engines/chunky_png_engine");Fi[	@3iI"—        def function(arglist)
          raise(::Compass::Error, "You must impliment save(filename)")
        end
      end
    end
  end
end
require("compass/sass_extensions/sprites/engines/chunky_png_engine");Fi[	I"@data//compass_proj/compass/sass_extensions/sprites/image.rb;TiïI"Ø        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end
      end
    end
  end
end;Fi[	@8iñI"¶        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end
      end
    end
  end
end;Fi[	I"Hdata//compass_proj/compass/sass_extensions/sprites/image_methods.rb;Ti I"À        # Return and array of image names that make up this sprite
        def function(arglist)
          image_names.map { |arglist| File.basename(var, ".png") }
        end
      end
    end
  end
end;Fi[	@=i!I"à        def function(arglist)
          image_names.map { |arglist| File.basename(var, ".png") }
        end
      end
    end
  end
end;Fi[	I"Ddata//compass_proj/compass/sass_extensions/sprites/image_row.rb;Ti/I"Å        
        def function(arglist)
          ((total_width + var.width) <= max_width)
        end
      end
    end
  end
end;Fi[	@Bi0I"}        def function(arglist)
          ((total_width + var.width) <= max_width)
        end
      end
    end
  end
end;Fi[	I"Idata//compass_proj/compass/sass_extensions/sprites/layout_methods.rb;Ti†I"å        
        def function(arglist)
          @var.map { |arglist| (var.width + var.offset) }.max
        end
      end
    end
  end
end;Fi[	@Gi°I"É        def function(arglist)
          @var.map { |arglist| (var.width + var.offset) }.max
        end
      end
    end
  end
end;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/row_fitter.rb;TiPI"Í                        var = true
                        (var << var)
                        throw(:done)
                      end
                    end
                  end
                end
              end
            end;Fi[	@LiQI"ﬂ                        (var << var)
                        throw(:done)
                      end
                    end
                  end
                end
              end
            end
          end while var;Fi[	@LiRI"∆                        throw(:done)
                      end
                    end
                  end
                end
              end
            end
          end while var
        end;Fi[	@LiWI"f              end
            end
          end while var
        end
      end
    end
  end
end;Fi[	@LiXI"T            end
          end while var
        end
      end
    end
  end
end;Fi[	I"Edata//compass_proj/compass/sass_extensions/sprites/sprite_map.rb;TiLI"÷          @var ||= Compass.configuration.sprite_engine.to_s.scan(/([^_.]+)/).flatten.map do |arglist|
            "#{chunk[0].chr.upcase}#{chunk[(1..-1)]}"
          end.join
        end
      end
    end
  end
end;Fi[	@WiMI"u            "#{chunk[0].chr.upcase}#{chunk[(1..-1)]}"
          end.join
        end
      end
    end
  end
end;Fi[	I"Idata//compass_proj/compass/sass_extensions/sprites/sprite_methods.rb;TiÄI"¯        def function(arglist)
          if options[:compass] and (options[:compass][:logger] and options[:quiet].!) then
            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	@\iÅI"⁄          if options[:compass] and (options[:compass][:logger] and options[:quiet].!) then
            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	@\iÇI"            options[:compass][:logger].record(var, relativize(var), *var)
          end
        end
      end
    end
  end
end;Fi[	I":data//compass_proj/compass/sprite_importer/binding.rb;TiI"k    class Binding < OpenStruct
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	I"(data//compass_proj/compass/stats.rb;Ti}I"_      
      def function(arglist)
        visitor.mixin_count
      end
    end
  end
end;Fi[	I"3data//cucumber_prok/cucumber/ast/background.rb;TikI"r      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
    end
  end
end;Fi[	I"0data//cucumber_prok/cucumber/ast/comment.rb;TiI"      
      def function(arglist)
        (@var.nil? or (@var == "")) ? (nil) : ([:comment, @var])
      end
    end
  end
end;Fi[	I"3data//cucumber_prok/cucumber/ast/doc_string.rb;Ti/I"y      #:nodoc:
      def function(arglist)
        [:doc_string, to_step_definition_arg]
      end
    end
  end
end;Fi[	I"1data//cucumber_prok/cucumber/ast/examples.rb;Ti0I"t        var = (var + [var]) if var
        var = (var + [@var.to_sexp])
        var
      end
    end
  end
end;Fi[	I"0data//cucumber_prok/cucumber/ast/feature.rb;TilI"ç        var = (var + [@var.to_sexp]) if @var
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	I"8data//cucumber_prok/cucumber/ast/feature_element.rb;Ti/I""              (((Ast::Step::INDENT + @var.unpack("U*").length) + ": ".length) + var.unpack("U*").length)
            else
              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("U*").length)
            end
          end
        end
      end
      
      def function(arglist);Fi[	@xiSI"a      
      def function(arglist)
        @var.language if @var
      end
    end
  end
end;Fi[	I"1data//cucumber_prok/cucumber/ast/features.rb;Ti"I"â        var = Time.now
        self.each { |arglist| var.visit_feature(var) }
        @var = (Time.now - var)
      end
    end
  end
end;Fi[	I".data//cucumber_prok/cucumber/ast/names.rb;TiI"x        var = @var
        var = (var + "\n#{@description}") if @var.!=("")
        var
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/ast/outline_table.rb;Ti~I"¸                var.invoke(var.step_mother, var.configuration)
                @var ||= var.reported_exception
                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist);Fi[	@Éi∞I"j        
        def function(arglist)
          (index == 0)
        end
      end
    end
  end
end;Fi[	@Éi±I"a        def function(arglist)
          (index == 0)
        end
      end
    end
  end
end;Fi[	I"1data//cucumber_prok/cucumber/ast/scenario.rb;TitI"b      
      def function(arglist)
        (@var.failed? or @var)
      end
    end
  end
end;Fi[	I"9data//cucumber_prok/cucumber/ast/scenario_outline.rb;TihI"Ü        var = (var + var) if var.any?
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	I"-data//cucumber_prok/cucumber/ast/step.rb;Ti~I"[          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	I"8data//cucumber_prok/cucumber/ast/step_collection.rb;TiJI"n      
      def function(arglist)
        @var.map { |arglist| var.to_sexp }
      end
    end
  end
end;Fi[	I".data//cucumber_prok/cucumber/ast/table.rb;TiÉI"b        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@ñiÑI"Y        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	I"-data//cucumber_prok/cucumber/ast/tags.rb;TiI"s      
      def function(arglist)
        @var.map { |arglist| [:tag, var.name] }
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/ast/tree_walker.rb;TiñI"q      
      def function(arglist)
        var[0].match(/in `(.*)'/).captures[0]
      end
    end
  end
end;Fi[	I"0data//cucumber_prok/cucumber/ast/visitor.rb;TiI"f      
      def function(arglist)
        raise(DEPRECATION_WARNING)
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/cli/configuration.rb;TiÕI"      
      def function(arglist)
        (feature_dirs + Dir["vendor/{gems,plugins}/*/cucumber"])
      end
    end
  end
end;Fi[	I"-data//cucumber_prok/cucumber/cli/main.rb;TiNI"«          exit!(1) if Cucumber.wants_to_quit
          Cucumber.wants_to_quit = true
          STDERR.puts("\nExiting... Interrupt again to exit immediately.")
        end
      end
    end
  end
end;Fi[	@ßiOI"ö          Cucumber.wants_to_quit = true
          STDERR.puts("\nExiting... Interrupt again to exit immediately.")
        end
      end
    end
  end
end;Fi[	I"0data//cucumber_prok/cucumber/cli/options.rb;Ti6I"      
      def function(arglist)
        { :strict => (false), :require => ([]), :dry_run => (false), :formats => ([]), :excludes => ([]), :tag_expressions => ([]), :name_regexps => ([]), :env_vars => ({}), :diff_enabled => (true) }
      end
    end
  end
end;Fi[	I"7data//cucumber_prok/cucumber/cli/profile_loader.rb;TiOI"       # in a .config/ or config/ subdirectory of the current directory.
      def function(arglist)
        @var ||= Dir.glob("{,.config/,config/}cucumber{.yml,.yaml}").first
      end
    end
  end
end;Fi[	I"1data//cucumber_prok/cucumber/feature_file.rb;TicI"x      else
        require("iconv")
        Iconv.new(DEFAULT_ENCODING, var).iconv(var)
      end
    end
  end
end;Fi[	I"8data//cucumber_prok/cucumber/formatter/ansicolor.rb;Ti_I"e      
      def function(arglist)
        blink(yellow(cukes(var)))
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/formatter/console.rb;Ti∂I"ê        var = FORMATS[var]
        raise("No format for #{key.inspect}: #{FORMATS.inspect}") if var.nil?
        var
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/formatter/debug.rb;Ti!I"X      
      def function(arglist)
        (" " * @var)
      end
    end
  end
end;Fi[	I"7data//cucumber_prok/cucumber/formatter/duration.rb;TiI"~      def function(arglist)
        var, var = var.divmod(60)
        "#{m}m#{("%.3f" % s)}s"
      end
    end
  end
end;Fi[	I"Hdata//cucumber_prok/cucumber/formatter/gherkin_formatter_adapter.rb;TiSI"ì        var = File.read(var)
        var = var.to_java_bytes if defined? JRUBY_VERSION
        @var.embedding(var, var)
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/formatter/gpretty.rb;TiI"\      def function(arglist)
        super
        @var.puts
      end
    end
  end
end;Fi[	I"3data//cucumber_prok/cucumber/formatter/html.rb;TiGI"            @var.div(:id => "expand-collapse") do |arglist|
              @var.p("Expand All", :id => "expander")
              @var.p("Collapse All", :id => "collapser")
            end
          end
        end
      end
      
      def function(arglist);Fi[	@«i7I"l            (var << var)
          end
          var.join("\n")
        end
      end
    end
  end
end;Fi[	@«i8I"S          end
          var.join("\n")
        end
      end
    end
  end
end;Fi[	I":data//cucumber_prok/cucumber/formatter/interceptor.rb;Ti@I"}            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ŒiAI"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ŒiBI"S            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"1data//cucumber_prok/cucumber/formatter/io.rb;Ti(I"s        end
        FileUtils.mkdir_p(var) unless File.directory?(var)
        var
      end
    end
  end
end;Fi[	I"3data//cucumber_prok/cucumber/formatter/json.rb;TiI"ü      def function(arglist)
        @var = ensure_io(var, "json")
        super(Gherkin::Formatter::JSONFormatter.new(@var), false)
      end
    end
  end
end;Fi[	I":data//cucumber_prok/cucumber/formatter/json_pretty.rb;TiI"Ç    class JsonPretty < Json
      def function(arglist)
        @var.write(JSON.pretty_generate(@var))
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/formatter/junit.rb;TiîI"|      
      def function(arglist)
        File.open(var, "w") { |arglist| var.write(var) }
      end
    end
  end
end;Fi[	I"Adata//cucumber_prok/cucumber/formatter/ordered_xml_markup.rb;TiI"¨        var.each do |arglist|
          var = (var[var.to_sym] or var[var])
          (@var << " #{k}=\"#{_attr_value(v)}\"") if var
        end
      end
    end
  end
end;Fi[	@·iI"é          var = (var[var.to_sym] or var[var])
          (@var << " #{k}=\"#{_attr_value(v)}\"") if var
        end
      end
    end
  end
end;Fi[	I"5data//cucumber_prok/cucumber/formatter/pretty.rb;TiÊI"|        print_stats(var, @var)
        print_snippets(@var)
        print_passing_wip(@var)
      end
    end
  end
end;Fi[	I"7data//cucumber_prok/cucumber/formatter/progress.rb;TiWI"c      
      def function(arglist)
        (var == :skipped_param)
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/formatter/rerun.rb;TiNI"f      def function(arglist)
        yield if @var
        @var = true
      end
    end
  end
end;Fi[	I"7data//cucumber_prok/cucumber/formatter/stepdefs.rb;TiI"M      
      def function(arglist)
        0
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/formatter/steps.rb;Ti/I"t      
      def function(arglist)
        (var.map { |arglist| var.size }.max + 1)
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/formatter/summary.rb;TiI"å      
      def function(arglist)
        [var, var, "#{what}#{(count == 1) ? ("") : ("s")}"].compact.join(" ")
      end
    end
  end
end;Fi[	I"6data//cucumber_prok/cucumber/formatter/unicode.rb;TiDI"·              rescue Iconv::IllegalSequence => var
                STDERR.cucumber_puts("WARNING: #{e.message}")
                cucumber_puts(*var)
              end
            end
          end
        end
      end
      ;Fi[	@¯iEI"»                STDERR.cucumber_puts("WARNING: #{e.message}")
                cucumber_puts(*var)
              end
            end
          end
        end
      end
      
      Kernel.extend(self);Fi[	I"4data//cucumber_prok/cucumber/formatter/usage.rb;TixI"¡        @var.unmatched_step_definitions.each do |arglist|
          var = StepDefKey.new(var.regexp_source, var.file_colon_line)
          @var[var] = []
        end
      end
    end
  end
end;Fi[	@˝iyI"á          var = StepDefKey.new(var.regexp_source, var.file_colon_line)
          @var[var] = []
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/js_support/js_language.rb;TißI"å        else
          var = var[0][/(^.*\/?features)/, 0]
          var ? ("#{path}/../") : ("../")
        end
      end
    end
  end
end;Fi[	@i®I"          var = var[0][/(^.*\/?features)/, 0]
          var ? ("#{path}/../") : ("../")
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/js_support/js_snippets.rb;TiI"-          var = "//#{multiline_arg_class.default_arg_name} is a #{multiline_arg_class.to_s}\n"
        end
        "#{code_keyword}(/^#{escaped}$/, function(#{block_arg_string}){\n  #{multiline_class_comment}  //express the regexp above with the code you wish you had\n});"
      end
    end
  end
end;Fi[	I"Fdata//cucumber_prok/cucumber/language_support/language_methods.rb;TirI"ó          var.invoke(var, var, &var)
        rescue Exception => var
          var ? (var.fail!(var)) : (raise)
        end
      end
    end
  end
end;Fi[	@
isI"w        rescue Exception => var
          var ? (var.fail!(var)) : (raise)
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/parser/gherkin_builder.rb;TiOI"f          end
          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	@iPI"X          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/py_support/py_language.rb;Ti<I"°        @var.unshift(var)
        @var.uniq!
        ENV["PYTHONPATH"] = @var.join(":")
      end
    end
  end
end
class String
  unless defined? end_with? then;Fi[	I".data//cucumber_prok/cucumber/rake/task.rb;TiƒI"v      
      def function(arglist)
        var.map { |arglist| var.gsub(" ", "\\ ") }
      end
    end
  end
end;Fi[	I"7data//cucumber_prok/cucumber/rb_support/rb_hook.rb;TiI"ò      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var)
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/rb_support/rb_language.rb;TißI"U          end
        else
          var
        end
      end
    end
  end
end;Fi[	@i®I"G        else
          var
        end
      end
    end
  end
end;Fi[	I"<data//cucumber_prok/cucumber/rb_support/rb_transform.rb;Ti.I"e      
      def function(arglist)
        var.gsub(/(^\^|\$$)/, "")
      end
    end
  end
end;Fi[	I"8data//cucumber_prok/cucumber/rb_support/rb_world.rb;TimI"S      
      def function(arglist)
        inspect
      end
    end
  end
end;Fi[	I"Gdata//cucumber_prok/cucumber/rb_support/regexp_argument_matcher.rb;TiI"U          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@(iI"G        else
          nil
        end
      end
    end
  end
end;Fi[	I"@data//cucumber_prok/cucumber/rspec/disable_option_parser.rb;TiI"é          @var = true
          define_method(var) { |arglist| NEUTERED_RSPEC }
          @var = false
        end
      end
    end
  end
end;Fi[	@-iI"}          define_method(var) { |arglist| NEUTERED_RSPEC }
          @var = false
        end
      end
    end
  end
end;Fi[	I"<data//cucumber_prok/cucumber/runtime/features_loader.rb;Ti8I"[      
      def function(arglist)
        Cucumber.logger
      end
    end
  end
end;Fi[	I"Fdata//cucumber_prok/cucumber/runtime/for_programming_languages.rb;Ti3I"f      #
      def function(arglist)
        Ast::DocString.parse(var)
      end
    end
  end
end;Fi[	I"4data//cucumber_prok/cucumber/runtime/results.rb;Ti1I"⁄          scenarios(:passed).any?
        else
          (scenarios(:failed).any? or (steps(:failed).any? or (@var.strict? and (steps(:undefined).any? or steps(:pending).any?))))
        end
      end
    end
  end
end;Fi[	@8i2I"∏        else
          (scenarios(:failed).any? or (steps(:failed).any? or (@var.strict? and (steps(:undefined).any? or steps(:pending).any?))))
        end
      end
    end
  end
end;Fi[	I"9data//cucumber_prok/cucumber/runtime/support_code.rb;Ti≥I"U          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@=i¥I"G        else
          nil
        end
      end
    end
  end
end;Fi[	I";data//cucumber_prok/cucumber/runtime/user_interface.rb;TiEI"]        var.start
        var.join((var * 1000))
        var
      end
    end
  end
end;Fi[	I",data//cucumber_prok/cucumber/runtime.rb;TiÇI"§                var = var.arguments_from(var.name)
                if var then
                  (var << { "name" => (var.name), "args" => (var.map { |arglist| { "offset" => (var.offset), "val" => (var.val) } }) })
                end
              end
            end
          end
          var["file_colon_line"] = var.file_colon_line
          var["steps"] = var.uniq.sort { |arglist| (var["name"] <=> var["name"]) };Fi[	I"3data//cucumber_prok/cucumber/term/ansicolor.rb;Ti>I"Å        var = RUBY_VERSION.split(".")
        var.map!(&:to_i)
        (var[0] >= 1) and (var[1] > 8)
      end
    end
  end
end;Fi[	I"<data//cucumber_prok/cucumber/wire_support/connection.rb;Ti8I"¸          @var ||= TCPSocket.new(@var.host, @var.port)
        rescue Errno::ECONNREFUSED => var
          raise(ConnectionError, "Unable to contact the wire server at #{@config.host}:#{@config.port}. Is it up?")
        end
      end
    end
  end
end;Fi[	@Ki9I"≈        rescue Errno::ECONNREFUSED => var
          raise(ConnectionError, "Unable to contact the wire server at #{@config.host}:#{@config.port}. Is it up?")
        end
      end
    end
  end
end;Fi[	I"Adata//cucumber_prok/cucumber/wire_support/request_handler.rb;TiI"—      # Props to Rails
      def function(arglist)
        var.to_s.gsub(/::/, "/").gsub(/([A-Z]+)([A-Z][a-z])/, "\\1_\\2").gsub(/([a-z\d])([A-Z])/, "\\1_\\2").tr("-", "_").downcase
      end
    end
  end
end;Fi[	I"@data//cucumber_prok/cucumber/wire_support/wire_exception.rb;TiI"[      
      def function(arglist)
        (@var or super)
      end
    end
  end
end;Fi[	I"?data//cucumber_prok/cucumber/wire_support/wire_language.rb;Ti2I"|        var = @var
        @var.each { |arglist| var.end_scenario(var) }
        @var = nil
      end
    end
  end
end;Fi[	I"=data//cucumber_prok/cucumber/wire_support/wire_packet.rb;TiI"p      
      def function(arglist)
        var.send("handle_#{@message}", @var)
      end
    end
  end
end;Fi[	I"Hdata//cucumber_prok/cucumber/wire_support/wire_protocol/requests.rb;TipI"á          
          def function(arglist)
            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	@\iqI"|          def function(arglist)
            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	@\irI"a            super(request_params(var))
          end
        end
      end
    end
  end
end;Fi[	I"?data//cucumber_prok/cucumber/wire_support/wire_protocol.rb;Ti*I"~      def function(arglist)
        var = Requests::EndScenario.new(self)
        var.execute(var)
      end
    end
  end
end;Fi[	I"Fdata//cucumber_prok/cucumber/wire_support/wire_step_definition.rb;TiI"Å      def function(arglist)
        return var unless var.is_a?(Cucumber::Ast::Table)
        var.raw
      end
    end
  end
end;Fi[	I"4data//devise_proj/devise/controllers/helpers.rb;TiËI"®      def function(arglist)
        Devise.mappings.each do |arglist|
          instance_variable_set("@current_#{m.name}", nil)
        end
      end
    end
  end
end;Fi[	@iiÈI"å        Devise.mappings.each do |arglist|
          instance_variable_set("@current_#{m.name}", nil)
        end
      end
    end
  end
end;Fi[	I"9data//devise_proj/devise/controllers/rememberable.rb;Ti2I"Ü      
      def function(arglist)
        var.rememberable_options.fetch(:key, "remember_#{scope}_token")
      end
    end
  end
end;Fi[	I"9data//devise_proj/devise/controllers/scoped_views.rb;TiI"h        
        def function(arglist)
          @var = var
        end
      end
    end
  end
end;Fi[	@qiI"_        def function(arglist)
          @var = var
        end
      end
    end
  end
end;Fi[	I"8data//devise_proj/devise/controllers/url_helpers.rb;TiI"	              var = var ? ("#{action}_") : ("")
              var = "#{action}#{module_name}_#{path_or_url}"
              class_eval("                def #{method}(resource_or_scope, *args)\n                  scope = Devise::Mapping.find_scope!(resource_or_scope)\n                  _devise_route_context.send(\"#{action}#{scope}_#{module_name}_#{path_or_url}\", *args)\n                end\n", "(string)", (53 + 1))
            end
          end
        end
      end
      
      generate_helpers!(Devise::URL_HELPERS);Fi[	@vi"I"w      
      def function(arglist)
        @var ||= send(Devise.available_router_name)
      end
    end
  end
end;Fi[	I"0data//devise_proj/devise/mailers/helpers.rb;TiYI"√      #
      def function(arglist)
        I18n.t(:"#{devise_mapping.name}_subject", :scope => ([:devise, :mailer, var]), :default => ([:subject, var.to_s.humanize]))
      end
    end
  end
end;Fi[	I"(data//devise_proj/devise/mapping.rb;TiÇI"á          @var = (self.routes - Array(var).map(&var))
        else
          @var = self.routes
        end
      end
    end
  end
end;Fi[	@~iÉI"V        else
          @var = self.routes
        end
      end
    end
  end
end;Fi[	I"7data//devise_proj/devise/models/authenticatable.rb;Ti«I"∫          loop do |arglist|
            var = Devise.friendly_token
            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	@Éi»I"û            var = Devise.friendly_token
            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	@Éi…I"{            break var unless to_adapter.find_first(var => (var))
          end
        end
      end
    end
  end
end;Fi[	I"3data//devise_proj/devise/models/confirmable.rb;Ti‰I"®        end
        
        Devise::Models.config(self, :allow_unconfirmed_access_for, :confirmation_keys, :reconfirmable, :confirm_within)
      end
    end
  end
end;Fi[	I"@data//devise_proj/devise/models/database_authenticatable.rb;TijI"â        # the proper fields.
        def function(arglist)
          find_for_authentication(var)
        end
      end
    end
  end
end;Fi[	@çikI"q        def function(arglist)
          find_for_authentication(var)
        end
      end
    end
  end
end;Fi[	I"0data//devise_proj/devise/models/lockable.rb;Ti•I"£        end
        
        Devise::Models.config(self, :maximum_attempts, :lock_strategy, :unlock_strategy, :unlock_in, :unlock_keys)
      end
    end
  end
end;Fi[	I"4data//devise_proj/devise/models/omniauthable.rb;TiI"z      
      module ClassMethods
        Devise::Models.config(self, :omniauth_providers)
      end
    end
  end
end;Fi[	I"3data//devise_proj/devise/models/recoverable.rb;TiwI"Ç        end
        
        Devise::Models.config(self, :reset_password_keys, :reset_password_within)
      end
    end
  end
end;Fi[	I"4data//devise_proj/devise/models/registerable.rb;TiI"x        # new with params.
        def function(arglist)
          new(var)
        end
      end
    end
  end
end;Fi[	@õiI"]        def function(arglist)
          new(var)
        end
      end
    end
  end
end;Fi[	I"4data//devise_proj/devise/models/rememberable.rb;TiaI"ì        end
        
        Devise::Models.config(self, :remember_for, :extend_remember_period, :rememberable_options)
      end
    end
  end
end;Fi[	I"3data//devise_proj/devise/models/timeoutable.rb;Ti"I"r      
      module ClassMethods
        Devise::Models.config(self, :timeout_in)
      end
    end
  end
end;Fi[	I"=data//devise_proj/devise/models/token_authenticatable.rb;Ti8I"é        end
        
        Devise::Models.config(self, :token_authentication_key, :expire_auth_token_on_timeout)
      end
    end
  end
end;Fi[	I"1data//devise_proj/devise/models/trackable.rb;TiI"˙        self.sign_in_count ||= 0
        self.sign_in_count += 1
        (save(:validate => (false)) or raise("Devise trackable could not save #{inspect}.Please make sure a model using trackable can be saved at sign in."))
      end
    end
  end
end;Fi[	I"3data//devise_proj/devise/models/validatable.rb;Ti1I"Å      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length)
      end
    end
  end
end;Fi[	I"0data//devise_proj/devise/omniauth/config.rb;Ti,I"ã          ::OmniAuth::Strategies.const_get(var)
        else
          raise(StrategyNotFound, var)
        end
      end
    end
  end
end;Fi[	@Øi-I"`        else
          raise(StrategyNotFound, var)
        end
      end
    end
  end
end;Fi[	I"5data//devise_proj/devise/omniauth/url_helpers.rb;TiI"ú      def function(arglist)
        var = Devise::Mapping.find_scope!(var)
        send("#{scope}_omniauth_callback_path", *var)
      end
    end
  end
end;Fi[	I"-data//devise_proj/devise/rails/routes.rb;Ti÷I"          end
          with_devise_exclusive_scope(var.fullpath, var.name, var) do |arglist|
            var.each { |arglist| send("devise_#{mod}", var, var.controllers) }
          end
        end
      end
    end
    
    # Allow you to add authentication request from the router.;Fi[	I"4data//devise_proj/devise/rails/warden_compat.rb;Ti*I"N        # do nothing
      else
        raise
      end
    end
  end
end;Fi[	I"&data//devise_proj/devise/rails.rb;Ti.I"¿        # We can get rid of this once we support only Rails > 3.2
        def function(arglist)
          (super or routes.url_helpers.respond_to?(var))
        end
      end
    end
  end
end;Fi[	@Ωi/I"~        def function(arglist)
          (super or routes.url_helpers.respond_to?(var))
        end
      end
    end
  end
end;Fi[	I";data//devise_proj/devise/strategies/authenticatable.rb;Ti°I"”      # becomes simply :database.
      def function(arglist)
        @var ||= ActiveSupport::Inflector.underscore(self.class.name.split("::").last).sub("_authenticatable", "").to_sym
      end
    end
  end
end;Fi[	I"0data//devise_proj/devise/strategies/base.rb;TiI"ó        @var ||= (var = Devise.mappings[scope]
        raise("Could not find mapping for #{scope}") unless var
        var)
      end
    end
  end
end;Fi[	I"Ddata//devise_proj/devise/strategies/database_authenticatable.rb;TiI"        if validate(var) { |arglist| var.valid_password?(password) } then
          var.after_database_authentication
          success!(var)
        end
      end
    end
  end
end
Warden::Strategies.add(:database_authenticatable, Devise::Strategies::DatabaseAuthenticatable);Fi[	@»iI"           var.after_database_authentication
          success!(var)
        end
      end
    end
  end
end
Warden::Strategies.add(:database_authenticatable, Devise::Strategies::DatabaseAuthenticatable);Fi[	I"8data//devise_proj/devise/strategies/rememberable.rb;Ti.I"¥      
      def function(arglist)
        @var ||= cookies.signed[remember_key]
      end
    end
  end
end
Warden::Strategies.add(:rememberable, Devise::Strategies::Rememberable);Fi[	I"Adata//devise_proj/devise/strategies/token_authenticatable.rb;Ti.I"      # Overwrite authentication keys to use token_authentication_key.
      def function(arglist)
        @var ||= [mapping.to.token_authentication_key]
      end
    end
  end
end
Warden::Strategies.add(:token_authenticatable, Devise::Strategies::TokenAuthenticatable);Fi[	I"Cdata//devise_proj/generators/active_record/devise_generator.rb;Ti(I"x      
      def function(arglist)
        "      ## Database authenticatable\n      t.string :email,              :null => false, :default => \"\"\n      t.string :encrypted_password, :null => false, :default => \"\"\n\n      ## Recoverable\n      t.string   :reset_password_token\n      t.datetime :reset_password_sent_at\n\n      ## Rememberable\n      t.datetime :remember_created_at\n\n      ## Trackable\n      t.integer  :sign_in_count, :default => 0\n      t.datetime :current_sign_in_at\n      t.datetime :last_sign_in_at\n      t.string   :current_sign_in_ip\n      t.string   :last_sign_in_ip\n\n      ## Confirmable\n      # t.string   :confirmation_token\n      # t.datetime :confirmed_at\n      # t.datetime :confirmation_sent_at\n      # t.string   :unconfirmed_email # Only if using reconfirmable\n\n      ## Lockable\n      # t.integer  :failed_attempts, :default => 0 # Only if lock strategy is :failed_attempts\n      # t.string   :unlock_token # Only if unlock strategy is :email or :both\n      # t.datetime :locked_at\n\n      ## Token authenticatable\n      # t.string :authentication_token\n"
      end
    end
  end
end;Fi[	I"<data//devise_proj/generators/devise/devise_generator.rb;TiI"ª        (var << ", :class_name => \"#{class_name}\"") if class_name.include?("::")
        (var << ", :skip => :all") unless options.routes?
        route(var)
      end
    end
  end
end;Fi[	I"=data//devise_proj/generators/devise/install_generator.rb;TiI"u      
      def function(arglist)
        readme("README") if (behavior == :invoke)
      end
    end
  end
end;Fi[	I"7data//devise_proj/generators/devise/orm_helpers.rb;TiI"}      
      def function(arglist)
        @var ||= File.join("app", "models", "#{file_path}.rb")
      end
    end
  end
end;Fi[	I"=data//devise_proj/generators/mongoid/devise_generator.rb;TiI"Î      
      def function(arglist)
        "  ## Database authenticatable\n  field :email,              :type => String, :default => \"\"\n  field :encrypted_password, :type => String, :default => \"\"\n  \n  ## Recoverable\n  field :reset_password_token,   :type => String\n  field :reset_password_sent_at, :type => Time\n\n  ## Rememberable\n  field :remember_created_at, :type => Time\n\n  ## Trackable\n  field :sign_in_count,      :type => Integer, :default => 0\n  field :current_sign_in_at, :type => Time\n  field :last_sign_in_at,    :type => Time\n  field :current_sign_in_ip, :type => String\n  field :last_sign_in_ip,    :type => String\n\n  ## Confirmable\n  # field :confirmation_token,   :type => String\n  # field :confirmed_at,         :type => Time\n  # field :confirmation_sent_at, :type => Time\n  # field :unconfirmed_email,    :type => String # Only if using reconfirmable\n\n  ## Lockable\n  # field :failed_attempts, :type => Integer, :default => 0 # Only if lock strategy is :failed_attempts\n  # field :unlock_token,    :type => String # Only if unlock strategy is :email or :both\n  # field :locked_at,       :type => Time\n\n  ## Token authenticatable\n  # field :authentication_token, :type => String\n"
      end
    end
  end
end;Fi[	I">data//diaspora_proj/controllers/application_controller.rb;TiiI"|          unless var.nil? then
            @var = var
            break
          end
        end
      end
    end
  end
  ;Fi[	@‚ijI"z            @var = var
            break
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I":data//diaspora_proj/controllers/aspects_controller.rb;Ti I"¥        var.html do |arglist|
          flash[:error] = I18n.t("aspects.create.failure")
          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"@data//diaspora_proj/controllers/conversations_controller.rb;TiUI"g    else
      if render(:layout => (false)) then
        # do nothing
      end
    end
  end
end;Fi[	I"8data//diaspora_proj/controllers/likes_controller.rb;Ti7I"Í      Comment.find(params[:comment_id]).tap do |arglist|
        unless current_user.find_visible_shareable_by_id(Post, var.commentable_id) then
          raise(ActiveRecord::RecordNotFound.new)
        end
      end
    end
  end
end;Fi[	@Ìi8I"±        unless current_user.find_visible_shareable_by_id(Post, var.commentable_id) then
          raise(ActiveRecord::RecordNotFound.new)
        end
      end
    end
  end
end;Fi[	I";data//diaspora_proj/controllers/profiles_controller.rb;Ti7I"í          redirect_to(getting_started_path)
        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private;Fi[	I"8data//diaspora_proj/controllers/users_controller.rb;TiMI"'                    flash[:notice] = I18n.t("users.update.follow_settings_changed")
                  else
                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end;Fi[	@ıiNI"›                  else
                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end
      end;Fi[	@ıiOI"œ                    flash[:error] = I18n.t("users.update.follow_settings_not_changed")
                  end
                end
              end
            end
          end
        end
      end
    else;Fi[	@ıiPI"•                  end
                end
              end
            end
          end
        end
      end
    else
      if var = params[:reorder_aspects] then;Fi[	I"6data//diaspora_proj/helpers/markdownify_helper.rb;Ti'I"U      else
        var.strip!
        (var << " \n")
      end
    end
  end
end;Fi[	I"0data//diaspora_proj/helpers/posts_helper.rb;TiI"Í        else
          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  ;Fi[	@iI"ı          if var.respond_to?(:photos) and var.photos.present? then
            I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"1data//diaspora_proj/helpers/stream_helper.rb;TiI"Ò            stream_path(:max_time => (time_for_scroll(@var)))
          else
            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  ;Fi[	@iI"À          else
            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"-data//diaspora_proj/models/invitation.rb;TiãI"©    if (self.service == "email") then
      unless self.identifier.match(Devise.email_regexp) then
        (errors[:base] << "invalid email")
      end
    end
  end
end;Fi[	I",data//diaspora_proj/models/jobs/base.rb;TiI"´      rescue => var
        Rails.logger.info("error in job: #{e.message}")
        raise(var) unless DUMB_ERROR_MESSAGES.include?(var.message)
      end
    end
  end
end;Fi[	I"2data//diaspora_proj/models/jobs/http_multi.rb;TiI"          Resque.enqueue(Jobs::HttpMulti, var, var, var.failed_people, var, (var + 1))
        else
          Rails.logger.info("event=http_multi_abandon sender_id=#{user_id} failed_recipient_ids='[#{person_ids.join(", ")}] '")
        end
      end
    end
  end
end;Fi[	@iI"¥        else
          Rails.logger.info("event=http_multi_abandon sender_id=#{user_id} failed_recipient_ids='[#{person_ids.join(", ")}] '")
        end
      end
    end
  end
end;Fi[	I";data//diaspora_proj/models/jobs/mail/also_commented.rb;TiI"ö      def self.perform(arglist)
        if var = Notifier.also_commented(var, var, var) then
          var.deliver
        end
      end
    end
  end
end;Fi[	@iI"        if var = Notifier.also_commented(var, var, var) then
          var.deliver
        end
      end
    end
  end
end;Fi[	I"<data//diaspora_proj/models/jobs/mail/comment_on_post.rb;TiI"      
      def self.perform(arglist)
        Notifier.comment_on_post(var, var, var).deliver
      end
    end
  end
end;Fi[	I":data//diaspora_proj/models/jobs/mail/confirm_email.rb;TiI"s      
      def self.perform(arglist)
        Notifier.confirm_email(var).deliver
      end
    end
  end
end;Fi[	I"Adata//diaspora_proj/models/jobs/mail/invite_user_by_email.rb;TiI"ù      def self.perform(arglist)
        var = Invitation.find(var)
        I18n.with_locale(var.language) { |arglist| var.send! }
      end
    end
  end
end;Fi[	I"2data//diaspora_proj/models/jobs/mail/liked.rb;TiI"u      
      def self.perform(arglist)
        Notifier.liked(var, var, var).deliver
      end
    end
  end
end;Fi[	I"6data//diaspora_proj/models/jobs/mail/mentioned.rb;TiI"y      
      def self.perform(arglist)
        Notifier.mentioned(var, var, var).deliver
      end
    end
  end
end;Fi[	I"<data//diaspora_proj/models/jobs/mail/private_message.rb;TiI"      
      def self.perform(arglist)
        Notifier.private_message(var, var, var).deliver
      end
    end
  end
end;Fi[	I"5data//diaspora_proj/models/jobs/mail/reshared.rb;TiI"x      
      def self.perform(arglist)
        Notifier.reshared(var, var, var).deliver
      end
    end
  end
end;Fi[	I"<data//diaspora_proj/models/jobs/mail/started_sharing.rb;TiI"z      
      def self.perform(arglist)
        Notifier.started_sharing(var, var).deliver
      end
    end
  end
end;Fi[	I"@data//diaspora_proj/models/jobs/receive_encrypted_salmon.rb;TiI"ñ        var = User.find(var)
        var = Postzord::Receiver::Private.new(var, :salmon_xml => (var))
        var.perform!
      end
    end
  end
end;Fi[	I"Bdata//diaspora_proj/models/jobs/receive_unencrypted_salmon.rb;TiI"s      rescue => var
        FEDERATION_LOGGER.info(var.message)
        raise(var)
      end
    end
  end
end;Fi[	I"/data//diaspora_proj/models/notification.rb;Ti%I"l          var
        else
          nil
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"%data//haml_proj/haml/compiler.rb;TiwI"ˇ          if Parser::MID_BLOCK_KEYWORDS.include?(var) then
            @var = @var.parent.value[:dont_indent_next_line]
            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist);Fi[	@<iI"F              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">"
            else
              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
            end
          end
        end
      end
    end
    ;Fi[	@<iI"            else
              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
            end
          end
        end
      end
    end
    
    # Evaluates `text` in the context of the scope object, but;Fi[	@<iÂI"°        rstrip_buffer!((var - 1))
      else
        raise(SyntaxError.new("[HAML BUG] Undefined entry in Haml::Compiler@to_merge."))
      end
    end
  end
end;Fi[	I"!data//haml_proj/haml/exec.rb;TiI"h        end
        var.write(var)
        var.close if var.is_a?(File)
      end
    end
  end
end;Fi[	I"$data//haml_proj/haml/filters.rb;TiàI"Ω            push_text(var.rstrip)
          else
            push_text(var.rstrip.gsub("\n", "\n#{("  " * @output_tabs)}"))
          end
        end
      end
    end
    
    module Plain;Fi[	@HiI"â      class << self
        def function(arglist)
          super.sub(/^#coding:.*?\n/, "")
        end
      end
    end
  end
end
begin;Fi[	@HiI"ó        def function(arglist)
          super.sub(/^#coding:.*?\n/, "")
        end
      end
    end
  end
end
begin
  (require("haml/filters/maruku");Fi[	I"$data//haml_proj/haml/railtie.rb;TiI"    initializer(:haml) do |arglist|
      if defined? ::Sass::Rails and var.config.assets.enabled then
        require("haml/sass_rails_filter")
      end
    end
  end
end
require("haml/helpers/safe_erubis_template")
Haml::Filters::Erb.template_class = Haml::SafeErubisTemplate;Fi[	I",data//haml_proj/haml/template/plugin.rb;Ti%I"⁄    def function(arglist)
      @var.fragment_for(var, var, var) do |arglist|
        eval("_hamlout.buffer", var.binding)
      end
    end
  end
end
ActionView::Template.register_template_handler(:haml, Haml::Plugin);Fi[	I"!data//haml_proj/haml/util.rb;TidI"W        return var)
      ensure
        var.pos = var
      end
    end
  end
end;Fi[	I"#data//homebrew_proj/caveats.rb;Ti\I"⁄            (var << "    sudo launchctl load #{plist_link}")
          else
            (var << "    launchctl load #{plist_link}")
          end
        end
      end
    end
    var.join("\n") unless var.empty?
  end;Fi[	I"#data//homebrew_proj/cleaner.rb;Ti:I"ƒ              var.unlink unless @var.skip_clean?(var)
            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end;Fi[	@[i;I"í            else
              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end;Fi[	@[i<I"ê              clean_file_permissions(var) if var.symlink?.!
            end
          end
        end
      end
    end
  end
end
class Pathname;Fi[	@[i=I"            end
          end
        end
      end
    end
  end
end
class Pathname
  alias_method(:orig_unlink, :unlink);Fi[	I"%data//homebrew_proj/cmd/audit.rb;TiæI"ƒ        end
        unless (var.hexdigest == var.hexdigest.downcase) then
          problem("#{cksum.hash_type} should be lowercase")
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"'data//homebrew_proj/cmd/cleanup.rb;TiLI"~          else
            puts("Removing: #{pn}...")
            rm(var)
          end
        end
      end
    end
  end
  ;Fi[	@giMI"á            puts("Removing: #{pn}...")
            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@gicI"Ñ        end.flatten.map do |arglist|
          Tab.for_keg(var).send("HEAD")
        end.include?(nil).!
      end
    end
  end
end;Fi[	I"$data//homebrew_proj/cmd/deps.rb;TiI"Û        var = ARGV.formulae.map { |arglist| ARGV.one? ? (var.deps) : (var.recursive_deps) }.intersection.map(&:name)
        var.sort! unless ARGV.include?("-n")
        puts(var)
      end
    end
  end
end
class Array
  def function(arglist);Fi[	I"#data//homebrew_proj/cmd/diy.rb;Ti!I"        puts("--prefix=#{prefix}")
      else
        raise("Couldn't determine build system")
      end
    end
  end
end;Fi[	I"$data//homebrew_proj/cmd/edit.rb;Ti-I"M        true
      else
        # do nothing
      end
    end
  end
end;Fi[	I"%data//homebrew_proj/cmd/fetch.rb;Ti$I"¨      rescue ChecksumMismatchError => var
        Homebrew.failed = true
        opoo("Formula reports different #{e.hash_type}: #{e.expected}")
      end
    end
  end
end;Fi[	I"$data//homebrew_proj/cmd/list.rb;TiI"√          exec("find", *(ARGV.kegs + ["-not", "-type", "d", "-print"]))
        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private;Fi[	@ziJI"„          var.symlink? ? (puts("#{pn} -> #{pn.readlink}")) : (print_dir(var))
        else
          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"&data//homebrew_proj/cmd/search.rb;Ti3I"          if ($found == 0) and blacklisted?(var).! then
            puts("No formula found for \"#{query}\". Searching open pull requests...")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  ;Fi[	@i4I"Ê            puts("No formula found for \"#{query}\". Searching open pull requests...")
            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@iWI"≈        if var.include?(var) then
          var = ((HOMEBREW_REPOSITORY + "Library/Aliases") + var).readlink.basename(".rb").to_s
          var.include?(var)
        end
      end
    end
  end
end;Fi[	@iXI"£          var = ((HOMEBREW_REPOSITORY + "Library/Aliases") + var).readlink.basename(".rb").to_s
          var.include?(var)
        end
      end
    end
  end
end;Fi[	I"(data//homebrew_proj/cmd/versions.rb;TiI"¬          print("#{version.to_s.ljust(8)} ")
          print(Tty.reset.to_s)
          puts("git checkout #{sha} #{f.pretty_relative_path}")
        end
      end
    end
  end
end
class Formula;Fi[	@àiI"≠          print(Tty.reset.to_s)
          puts("git checkout #{sha} #{f.pretty_relative_path}")
        end
      end
    end
  end
end
class Formula
  def function(arglist);Fi[	@àiNI"w        var)
      rescue SyntaxError, TypeError, NameError, ArgumentError
        nil
      end
    end
  end
end;Fi[	I""data//homebrew_proj/debrew.rb;TiDI"°        catch(:IRB_EXIT) { |arglist| var.eval_input }
      ensure
        irb_at_exit
      end
    end
  end
end
class Exception
  attr_accessor(:continuation);Fi[	@èiXI"É      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist)
  puts("#{exception.backtrace.first}");Fi[	I"-data//homebrew_proj/download_strategy.rb;Ti\I"5        safe_system(@@var, "submodule", "update")
        var = "#{@@git} checkout-index -a -f \"--prefix=#{dst}/$path/\""
        safe_system(@@var, "submodule", "--quiet", "foreach", "--recursive", var)
      end
    end
  end
end
class CVSDownloadStrategy < AbstractDownloadStrategy
  def function(arglist);Fi[	@îi±I"         safe_system(hgpath, "archive", "--subrepos", "-y", "-r", @var, "-t", "files", var)
      else
        safe_system(hgpath, "archive", "--subrepos", "-y", "-t", "files", var)
      end
    end
  end
end
class BazaarDownloadStrategy < AbstractDownloadStrategy
  def function(arglist);Fi[	I",data//homebrew_proj/extend/fileutils.rb;TiCI"            end
          else
            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	@ôiDI"o          else
            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	@ôiEI"`            File.chmod(var.mode, var)
          end
        end
      end
    end
  end
end;Fi[	I")data//homebrew_proj/extend/object.rb;TiI"ë        send(var, *var))
      ensure
        var.class_eval { |arglist| remove_method(var) if method_defined?(var) }
      end
    end
  end
end;Fi[	I"+data//homebrew_proj/extend/pathname.rb;TiI"é            raise("            Could not symlink file: #{src.expand_path}\n            #{dirname} is not writable. You should change its permissions.\n".undent)
          else
            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  ;Fi[	@£i	I"          else
            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"-data//homebrew_proj/formula_installer.rb;TiI"∆          opoo("#{bin} is not in your PATH")
          puts("You can amend this by altering your ~/.bashrc file")
          @var = true
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"data//homebrew_proj/keg.rb;Ti”I"◊        else
          var.delete if var.overwrite and var.exist?
          var.make_relative_symlink(var)
        end
      end
    end
  end
  
  # symlinks the contents of self+foo recursively into /usr/local/foo;Fi[	@´i˘I"¿            unless resolve_any_conflicts(var) then
              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end;Fi[	@´i˙I"ë              make_relative_symlink(var, var, var)
              Find.prune
            end
          end
        end
      end
    end
  end
end;Fi[	@´i˚I"              Find.prune
            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	@´i¸I"k            end
          end
        end
      end
    end
  end
end
require("keg_fix_install_names");Fi[	I"1data//homebrew_proj/keg_fix_install_names.rb;TiI"                  system(MacOS.locate("install_name_tool"), "-change", var, var, var)
                else
                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end;Fi[	@∂iI"∏                else
                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end;Fi[	@∂iI"©                  opoo("Could not fix install names for #{file}")
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@∂iI"o                end
              end
            end
          end
        end
      end
    end
  end
  ;Fi[	@∂iI"e              end
            end
          end
        end
      end
    end
  end
  
  private;Fi[	I"!data//homebrew_proj/macos.rb;TiI"ó          :snowleopard
        else
          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist);Fi[	@¡i6I"∑      else
        if File.exist?("#{Xcode.prefix}/usr/bin/make") then
          Pathname.new("#{Xcode.prefix}/usr/bin")
        end
      end
    end
  end
  
  def function(arglist);Fi[	I".data//homebrew_proj/test/test_patching.rb;TiDI"À        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
end;Fi[	I"Bdata//homebrew_proj/vendor/multi_json/adapters/json_common.rb;TiI"ë        var = {}
        var.merge!(JSON::PRETTY_STATE_PROTOTYPE.to_h) if var.delete(:pretty)
        var.merge!(var)
      end
    end
  end
end;Fi[	I"Jdata//homebrew_proj/vendor/multi_json/adapters/nsjsonserialization.rb;Ti I"•          NSMutableString.alloc.initWithData(var, :encoding => (NSUTF8StringEncoding))
        else
          super(var, var)
        end
      end
    end
  end
end;Fi[	@Ãi!I"S        else
          super(var, var)
        end
      end
    end
  end
end;Fi[	I"9data//homebrew_proj/vendor/multi_json/adapters/oj.rb;TiI"Ö      def self.dump(arglist)
        var.merge!(:indent => 2) if var[:pretty]
        ::Oj.dump(var, var)
      end
    end
  end
end;Fi[	I">data//homebrew_proj/vendor/multi_json/adapters/ok_json.rb;Ti)I"U          end
        else
          var
        end
      end
    end
  end
end;Fi[	@‘i*I"G        else
          var
        end
      end
    end
  end
end;Fi[	I";data//homebrew_proj/vendor/multi_json/adapters/yajl.rb;TiI"m      
      def self.dump(arglist)
        ::Yajl::Encoder.encode(var, var)
      end
    end
  end
end;Fi[	I"(data//jekyll_proj/jekyll/command.rb;TiI"á        var = (var - ["_site"])
        var = var.map { |arglist| "#{x}/**/*" }
        var = (var + ["*"])
      end
    end
  end
end;Fi[	I"/data//jekyll_proj/jekyll/commands/build.rb;Ti2I"e          exit(0)
        end
        loop { |arglist| sleep(1000) }
      end
    end
  end
end;Fi[	I"4data//jekyll_proj/jekyll/converters/markdown.rb;TiuI"`        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	I",data//jekyll_proj/jekyll/convertible.rb;TiYI"ú        end
        if var = var[var.data["layout"]] then
          var.include?(var) ? (var = nil) : ((var << var))
        end
      end
    end
  end
end;Fi[	@ÂiZI"ê        if var = var[var.data["layout"]] then
          var.include?(var) ? (var = nil) : ((var << var))
        end
      end
    end
  end
end;Fi[	I"(data//jekyll_proj/jekyll/filters.rb;TiI"ò        "#{array[0]} #{connector} #{array[1]}"
      else
        "#{array[(0...-1)].join(", ")}, #{connector} #{array[-1]}"
      end
    end
  end
end;Fi[	I"1data//jekyll_proj/jekyll/migrators/drupal.rb;Ti4I"ﬂ              var.puts("layout: refresh")
              var.puts("refresh_to_post_id: /#{(time.strftime("%Y/%m/%d/") + slug)}")
              var.puts("---")
            end
          end
        end
      end
    end
  end;Fi[	@Ìi5I"π              var.puts("refresh_to_post_id: /#{(time.strftime("%Y/%m/%d/") + slug)}")
              var.puts("---")
            end
          end
        end
      end
    end
  end
end;Fi[	@Ìi6I"h              var.puts("---")
            end
          end
        end
      end
    end
  end
end;Fi[	@Ìi7I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"/data//jekyll_proj/jekyll/migrators/enki.rb;TiI"Ñ          end.to_yaml)
          var.puts("---")
          var.puts(var[:body].delete("\r"))
        end
      end
    end
  end
end;Fi[	@ˆiI"r          var.puts("---")
          var.puts(var[:body].delete("\r"))
        end
      end
    end
  end
end;Fi[	I"1data//jekyll_proj/jekyll/migrators/joomla.rb;TiI"v          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@˚iI"^          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"3data//jekyll_proj/jekyll/migrators/mephisto.rb;Ti&I"v          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@ i'I"^          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"-data//jekyll_proj/jekyll/migrators/mt.rb;Ti,I"ê          "textile"
        else
          ((var == "0") or var.include?("richtext")) ? ("html") : (var)
        end
      end
    end
  end
end;Fi[	@i-I"|        else
          ((var == "0") or var.include?("richtext")) ? ("html") : (var)
        end
      end
    end
  end
end;Fi[	I"4data//jekyll_proj/jekyll/migrators/posterous.rb;Ti9I"∂        end
        var = (var + 1)
        var = JSON.parse(self.fetch("/api/v2/users/me/sites/#{blog}/posts?api_token=#{@api_token}&page=#{page}").body)
      end
    end
  end
end;Fi[	I".data//jekyll_proj/jekyll/migrators/rss.rb;TiI"á          var.puts(var.to_yaml)
          var.puts("---\n")
          var.puts(var.description)
        end
      end
    end
  end
end;Fi[	@i I"l          var.puts("---\n")
          var.puts(var.description)
        end
      end
    end
  end
end;Fi[	I"6data//jekyll_proj/jekyll/migrators/textpattern.rb;TiI"v          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@iI"^          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	I"/data//jekyll_proj/jekyll/migrators/typo.rb;TiI"Ñ          end.to_yaml)
          var.puts("---")
          var.puts(var[:body].delete("\r"))
        end
      end
    end
  end
end;Fi[	@iI"r          var.puts("---")
          var.puts(var[:body].delete("\r"))
        end
      end
    end
  end
end;Fi[	I"4data//jekyll_proj/jekyll/migrators/wordpress.rb;TiJI"ø                (var << clean_entities(var[:name]))
              else
                (var << var[:name])
              end
            end
          end
        end
      end
      var = [];Fi[	@iKI"À              else
                (var << var[:name])
              end
            end
          end
        end
      end
      var = []
      if var[:comments] and (var[:comment_count].to_i > 0) then;Fi[	I"%data//jekyll_proj/jekyll/site.rb;Ti|I"‹              (pages << Page.new(self, self.source, var, var))
            else
              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    ;Fi[	@!i}I"Â            else
              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    
    # Read all the files in <source>/<dir>/_posts and create a new Post;Fi[	@!i#I"x        var
      else
        raise("Converter implementation not found for #{klass}")
      end
    end
  end
end;Fi[	I"-data//jekyll_proj/jekyll/tags/include.rb;TiI"È          var.stack { |arglist| var.render(var) }
        else
          "Included file '#{@file}' not found in _includes directory"
        end
      end
    end
  end
end
Liquid::Template.register_tag("include", Jekyll::IncludeTag);Fi[	@(iI"∑        else
          "Included file '#{@file}' not found in _includes directory"
        end
      end
    end
  end
end
Liquid::Template.register_tag("include", Jekyll::IncludeTag);Fi[	I"7data//mongoid_proj/lib/mongoid/atomic/modifiers.rb;Ti-I"o      # @since 2.2.0
      def function(arglist)
        self["$unset"] ||= {}
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/atomic/paths/embedded/many.rb;Ti'I"˙            var = parent.atomic_position
            var = document.new_record? ? ("") : (".#{document._index}")
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}#{locator}"
          end
        end
      end
    end
  end
end;Fi[	@0i(I"—            var = document.new_record? ? ("") : (".#{document._index}")
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}#{locator}"
          end
        end
      end
    end
  end
end;Fi[	@0i)I"â            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}#{locator}"
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/atomic/paths/embedded/one.rb;Ti&I"»          def function(arglist)
            var = parent.atomic_position
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}"
          end
        end
      end
    end
  end
end;Fi[	@7i'I"®            var = parent.atomic_position
            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}"
          end
        end
      end
    end
  end
end;Fi[	@7i(I"            "#{pos}#{"." unless pos.blank?}#{document.metadata.store_as}"
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/atomic/paths/embedded.rb;TiBI"ñ        
        def function(arglist)
          document._root.updates_requested?.! and only_root_selector?.!
        end
      end
    end
  end
end;Fi[	@>iCI"ç        def function(arglist)
          document._root.updates_requested?.! and only_root_selector?.!
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/atomic/paths/root.rb;Ti/I"¶        # @since 2.1.0
        def function(arglist)
          { "_id" => (document._id) }.merge!(document.shard_key_selector)
        end
      end
    end
  end
end;Fi[	@Ci0I"è        def function(arglist)
          { "_id" => (document._id) }.merge!(document.shard_key_selector)
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/attributes/processing.rb;TiºI"y          yield)
        ensure
          self.mass_assignment_options = nil
        end
      end
    end
  end
end;Fi[	@HiΩI"h        ensure
          self.mass_assignment_options = nil
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/attributes/readonly.rb;Ti2I"ü        # @since 3.0.0
        def function(arglist)
          var.each { |arglist| (readonly_attributes << var.to_s) }
        end
      end
    end
  end
end;Fi[	@Mi3I"à        def function(arglist)
          var.each { |arglist| (readonly_attributes << var.to_s) }
        end
      end
    end
  end
end;Fi[	I"1data//mongoid_proj/lib/mongoid/attributes.rb;TiI"È      # @since 2.3.0
      def function(arglist)
        class_eval("          alias #{name}  #{original}\n          alias #{name}= #{original}=\n          alias #{name}? #{original}?\n          alias #{name}_change   #{original}_change\n          alias #{name}_changed? #{original}_changed?\n          alias reset_#{name}!   reset_#{original}!\n          alias #{name}_was      #{original}_was\n          alias #{name}_will_change! #{original}_will_change!\n")
      end
    end
  end
end;Fi[	I"1data//mongoid_proj/lib/mongoid/components.rb;Ti\I"Æ      def function(arglist)
        @var ||= MODULES.flat_map do |arglist|
          var.instance_methods.map { |arglist| var.to_sym }
        end
      end
    end
  end
end;Fi[	@Ui]I"í        @var ||= MODULES.flat_map do |arglist|
          var.instance_methods.map { |arglist| var.to_sym }
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/config/environment.rb;Ti*I"û      def function(arglist)
        var = var ? (var.to_s) : (env_name)
        YAML.load(ERB.new(File.new(var).read).result)[var]
      end
    end
  end
end;Fi[	I"5data//mongoid_proj/lib/mongoid/config/options.rb;Ti:I"e      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/config/validators/option.rb;TiI"À        def function(arglist)
          unless Config.settings.keys.include?(var.to_sym) then
            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	@`iI"≠          unless Config.settings.keys.include?(var.to_sym) then
            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	@`iI"r            raise(Errors::InvalidConfigOption.new(var))
          end
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/config/validators/session.rb;Ti|I"∑        # @since 3.0.0
        def function(arglist)
          var.has_key?(:uri) and var.keys.any? { |arglist| STANDARD.include?(var.to_sym) }
        end
      end
    end
  end
end;Fi[	@gi}I"†        def function(arglist)
          var.has_key?(:uri) and var.keys.any? { |arglist| STANDARD.include?(var.to_sym) }
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/contextual/aggregable/memory.rb;TijI"Æ        # @since 3.0.0
        def function(arglist)
          (count > 0) ? (send(var) { |arglist| var.send(var) }.send(var)) : (nil)
        end
      end
    end
  end
end;Fi[	@likI"ó        def function(arglist)
          (count > 0) ? (send(var) { |arglist| var.send(var) }.send(var)) : (nil)
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/contextual/aggregable/mongo.rb;TiïI"R        # @since 3.0.0
        def function(arglist)
          "\n          function(key, values) {\n            var agg = { count: 0, max: null, min: null, sum: 0 };\n            values.forEach(function(val) {\n              if (val.max !== null) {\n                if (agg.max == null || val.max > agg.max) agg.max = val.max;\n                if (agg.min == null || val.max < agg.min) agg.min = val.max;\n                agg.sum += val.sum;\n              }\n              agg.count += val.count;\n            });\n            return agg;\n          }"
        end
      end
    end
  end
end;Fi[	@qiñI";        def function(arglist)
          "\n          function(key, values) {\n            var agg = { count: 0, max: null, min: null, sum: 0 };\n            values.forEach(function(val) {\n              if (val.max !== null) {\n                if (agg.max == null || val.max > agg.max) agg.max = val.max;\n                if (agg.min == null || val.max < agg.min) agg.min = val.max;\n                agg.sum += val.sum;\n              }\n              agg.count += val.count;\n            });\n            return agg;\n          }"
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/contextual/atomic.rb;TiÆI"¿      def function(arglist)
        var = var.__find_args__.collect { |arglist| [database_field_name(var), true] }
        query.update_all("$unset" => (Hash[var]))
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/contextual/command.rb;Ti"I"u      # @since 3.0.0
      def function(arglist)
        collection.database.session
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/eager.rb;TióI"´          var = Factory.from_db(klass, var, criteria.object_id)
          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	@|iòI"p          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/contextual/find_and_modify.rb;TiCI"        end
        if var = criteria.options[:fields] then
          query.select(var)
        end
      end
    end
  end
end;Fi[	@ÅiDI"x        if var = criteria.options[:fields] then
          query.select(var)
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/contextual/map_reduce.rb;Ti1I"{          session.with(:consistency => :strong)
        else
          session
        end
      end
    end
  end
end;Fi[	@Üi2I"K        else
          session
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/contextual/memory.rb;Ti¢I"Ä        documents.delete_one(var)
        var._parent.remove_child(var)
        var.destroyed = true
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/contextual/mongo.rb;TiLI"i        end
        yield(var)
        documents.push(var) if cacheable?
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/criterion/findable.rb;Ti≠I"x      # @since 2.0.0
      def function(arglist)
        raise(Errors::InvalidFind.new)
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/criterion/inspection.rb;TiI"ﬁ      # @since 1.0.0
      def function(arglist)
        "#<Mongoid::Criteria\n  selector: #{selector.inspect}\n  options:  #{options.inspect}\n  class:    #{klass}\n  embedded: #{embedded?}>\n"
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/criterion/marshalable.rb;Ti/I"~        var = var.new(klass.aliased_fields, klass.fields)
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/criterion/modifiable.rb;Ti∑I"}        var = (first or create_document(var, var))
        yield(var) if block_given?
        var
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/criterion/scoping.rb;TiëI"ƒ        var.each do |arglist|
          send(var).reject! do |arglist|
            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	@ùiíI"¶          send(var).reject! do |arglist|
            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	@ùiìI"}            var.send(var).has_key?(var) and (var.send(var)[var] == var)
          end
        end
      end
    end
  end
end;Fi[	I",data//mongoid_proj/lib/mongoid/dirty.rb;TiaI"«      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) }
        end
      end
    end
  end
end;Fi[	@§ibI"´        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) }
        end
      end
    end
  end
end;Fi[	I"/data//mongoid_proj/lib/mongoid/document.rb;TisI"ù      # @since 2.2.0
      def function(arglist)
        Mongoid.logger
      end
    end
  end
end
ActiveSupport.run_load_hooks(:mongoid, Mongoid::Document);Fi[	I"Ddata//mongoid_proj/lib/mongoid/errors/ambiguous_relationship.rb;TiI"Ò      # @since 3.0.0
      def function(arglist)
        super(compose_message("ambiguous_relationship", :klass => (var), :inverse => (var), :name => (var.inspect), :candidates => (var.map(&:inspect).join(", "))))
      end
    end
  end
end;Fi[	I"6data//mongoid_proj/lib/mongoid/errors/callback.rb;TiI"õ      # @since 2.2.0
      def function(arglist)
        super(compose_message("callbacks", :klass => (var), :method => (var)))
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/delete_restriction.rb;TiI"Ø      # @since 3.0.0
      def function(arglist)
        super(compose_message("delete_restriction", :document => (var.class), :relation => (var)))
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/document_not_found.rb;TiWI"Ç          "document_with_attributes_not_found"
        else
          "document_not_found"
        end
      end
    end
  end
end;Fi[	@µiXI"X        else
          "document_not_found"
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/errors/eager_load.rb;TiI"â      # @since 2.2.0
      def function(arglist)
        super(compose_message("eager_load", :name => (var)))
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/invalid_collection.rb;Ti
I"≠    class InvalidCollection < MongoidError
      def function(arglist)
        super(compose_message("invalid_collection", :klass => (var.name)))
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/errors/invalid_config_option.rb;TiI"“      # @since 3.0.0
      def function(arglist)
        super(compose_message("invalid_config_option", :name => (var), :options => (Config.settings.keys.map(&:inspect).join(", "))))
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/errors/invalid_database.rb;Ti
I"Æ    class InvalidDatabase < MongoidError
      def function(arglist)
        super(compose_message("invalid_database", :name => (var.class.name)))
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/errors/invalid_field.rb;Ti1I"ö      # @since 3.0.0
      def function(arglist)
        @var ||= (var.instance_method(var).source_location or ["Unknown", 0])
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/errors/invalid_field_option.rb;TiI"“      # @since 3.0.0
      def function(arglist)
        super(compose_message("invalid_field_option", :name => (var), :klass => (var), :option => (var), :valid => (var.join(", "))))
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/errors/invalid_find.rb;TiI"ú      # @since 2.2.0
      def function(arglist)
        super(compose_message("calling_document_find_with_nil_is_invalid", {}))
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/errors/invalid_includes.rb;TiI"˝      # @since 3.0.2
      def function(arglist)
        super(compose_message("invalid_includes", :klass => (var.name), :args => (var.map(&:inspect).join(", ")), :relations => (var.relations.keys.map(&:inspect).join(", "))))
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/errors/invalid_index.rb;TiI"µ      # @since 3.0.0
      def function(arglist)
        super(compose_message("invalid_index", :klass => (var.name), :spec => (var), :options => (var)))
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/errors/invalid_options.rb;TiI"Ω      # @since 2.1.0
      def function(arglist)
        super(compose_message("invalid_options", :name => (var), :invalid => (var), :valid => (var.join(", "))))
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/errors/invalid_path.rb;TiI"ç      # @since 3.0.14
      def function(arglist)
        super(compose_message("invalid_path", :klass => (var)))
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/errors/invalid_scope.rb;TiI"û      # @since 3.0.0
      def function(arglist)
        super(compose_message("invalid_scope", :klass => (var), :value => (var)))
      end
    end
  end
end;Fi[	I"Ndata//mongoid_proj/lib/mongoid/errors/invalid_set_polymorphic_relation.rb;TiI"ﬁ      #   InvalidSetPolymorphicRelation.new
      def function(arglist)
        super(compose_message("invalid_set_polymorphic_relation", :name => (var), :klass => (var), :other_klass => (var)))
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/errors/invalid_storage_options.rb;TiI"™      # @since 3.0.0
      def function(arglist)
        super(compose_message("invalid_storage_options", :klass => (var), :options => (var)))
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/errors/invalid_time.rb;TiI"å      # @since 2.3.1
      def function(arglist)
        super(compose_message("invalid_time", :value => (var)))
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/errors/inverse_not_found.rb;TiI"ƒ      # @since 3.0.0
      def function(arglist)
        super(compose_message("inverse_not_found", :base => (var), :name => (var), :klass => (var), :inverse => (var)))
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/errors/mixed_relations.rb;Ti
I"µ    class MixedRelations < MongoidError
      def function(arglist)
        super(compose_message("mixed_relations", :root => (var), :embedded => (var)))
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/errors/mixed_session_configuration.rb;TiI"¨      # @since 3.0.0
      def function(arglist)
        super(compose_message("mixed_session_configuration", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/errors/mongoid_error.rb;TiTI"}      # @since 3.0.0
      def function(arglist)
        translate("#{key}.resolution", var)
      end
    end
  end
end;Fi[	I"Rdata//mongoid_proj/lib/mongoid/errors/nested_attributes_metadata_not_found.rb;TiI"¥      # @since 3.0.0
      def function(arglist)
        super(compose_message("nested_attributes_metadata_not_found", :klass => (var), :name => (var)))
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/no_default_session.rb;TiI"ú      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_default_session", :keys => (var.join(", "))))
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/errors/no_environment.rb;TiI"Å      # @since 2.4.0
      def function(arglist)
        super(compose_message("no_environment", {}))
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/errors/no_map_reduce_output.rb;TiI"ñ      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_map_reduce_output", :command => (var)))
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/errors/no_metadata.rb;TiI"ã      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_metadata", :klass => (var)))
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/errors/no_parent.rb;TiI"â      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_parent", :klass => (var)))
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/errors/no_session_config.rb;TiI"ê      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_session_config", :name => (var)))
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/errors/no_session_database.rb;TiI"§      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_session_database", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/errors/no_session_hosts.rb;TiI"°      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_session_hosts", :name => (var), :config => (var)))
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/no_sessions_config.rb;TiI"Ö      # @since 3.0.0
      def function(arglist)
        super(compose_message("no_sessions_config", {}))
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/errors/readonly_attribute.rb;TiI"¢      # @since 3.0.0
      def function(arglist)
        super(compose_message("readonly_attribute", :name => (var), :value => (var)))
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/errors/scope_overwrite.rb;Ti
I"Ω    class ScopeOverwrite < MongoidError
      def function(arglist)
        super(compose_message("scope_overwrite", :model_name => (var), :scope_name => (var)))
      end
    end
  end
end;Fi[	I"Odata//mongoid_proj/lib/mongoid/errors/too_many_nested_attribute_records.rb;Ti
I"⁄    class TooManyNestedAttributeRecords < MongoidError
      def function(arglist)
        super(compose_message("too_many_nested_attribute_records", :association => (var), :limit => (var)))
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/errors/unknown_attribute.rb;TiI"¶      # @since 3.0.0
      def function(arglist)
        super(compose_message("unknown_attribute", :klass => (var.name), :name => (var)))
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/errors/unsaved_document.rb;Ti
I"Õ    class UnsavedDocument < MongoidError
      def function(arglist)
        super(compose_message("unsaved_document", :base => (var.class.name), :document => (var.class.name)))
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/errors/unsupported_javascript.rb;TiI"¨      # @since 3.0.0
      def function(arglist)
        super(compose_message("unsupported_javascript", :klass => (var), :javascript => (var)))
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/errors/validations.rb;TiI"ƒ      def function(arglist)
        @var = var
        super(compose_message("validations", :document => (var.class), :errors => (var.errors.full_messages.join(", "))))
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/errors/versioning_not_on_root.rb;TiI"ñ      # @since 3.0.0
      def function(arglist)
        super(compose_message("versioning_not_on_root", :klass => (var)))
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/array.rb;Ti•I"¢        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array);Fi[	@)	i¶I"œ        def function(arglist)
          true
        end
      end
    end
  end
end
::Array.__send__(:include, Mongoid::Extensions::Array)
::Array.__send__(:extend, Mongoid::Extensions::Array::ClassMethods);Fi[	I"=data//mongoid_proj/lib/mongoid/extensions/big_decimal.rb;Ti=I"¿        # @since 3.0.7
        def function(arglist)
          var ? (var.to_s) : (var)
        end
      end
    end
  end
end
::BigDecimal.__send__(:include, Mongoid::Extensions::BigDecimal);Fi[	@.	i>I"˜        def function(arglist)
          var ? (var.to_s) : (var)
        end
      end
    end
  end
end
::BigDecimal.__send__(:include, Mongoid::Extensions::BigDecimal)
::BigDecimal.__send__(:extend, Mongoid::Extensions::BigDecimal::ClassMethods);Fi[	I"9data//mongoid_proj/lib/mongoid/extensions/boolean.rb;TiI"∫        # @since 3.0.0
        def function(arglist)
          evolve(var)
        end
      end
    end
  end
end
::Boolean.__send__(:extend, Mongoid::Extensions::Boolean::ClassMethods);Fi[	@3	iI"£        def function(arglist)
          evolve(var)
        end
      end
    end
  end
end
::Boolean.__send__(:extend, Mongoid::Extensions::Boolean::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/date.rb;Ti?I"≥          unless var.blank? then
            var = var.__mongoize_time__
            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end;Fi[	@8	i@I"«            var = var.__mongoize_time__
            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end
::Date.__send__(:include, Mongoid::Extensions::Date);Fi[	@8	iAI"·            ::Time.utc(var.year, var.month, var.day)
          end
        end
      end
    end
  end
end
::Date.__send__(:include, Mongoid::Extensions::Date)
::Date.__send__(:extend, Mongoid::Extensions::Date::ClassMethods);Fi[	I";data//mongoid_proj/lib/mongoid/extensions/date_time.rb;TiCI"∏        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::DateTime.__send__(:include, Mongoid::Extensions::DateTime);Fi[	@?	iDI"Î        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::DateTime.__send__(:include, Mongoid::Extensions::DateTime)
::DateTime.__send__(:extend, Mongoid::Extensions::DateTime::ClassMethods);Fi[	I"=data//mongoid_proj/lib/mongoid/extensions/false_class.rb;Ti!I"”      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::FalseClass.__send__(:include, Mongoid::Extensions::FalseClass);Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/float.rb;Ti.I"’        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0)
        end
      end
    end
  end
end
::Float.__send__(:include, Mongoid::Extensions::Float);Fi[	@G	i/I"        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0)
        end
      end
    end
  end
end
::Float.__send__(:include, Mongoid::Extensions::Float)
::Float.__send__(:extend, Mongoid::Extensions::Float::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/hash.rb;Ti¬I"†        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash);Fi[	@L	i√I"À        def function(arglist)
          true
        end
      end
    end
  end
end
::Hash.__send__(:include, Mongoid::Extensions::Hash)
::Hash.__send__(:extend, Mongoid::Extensions::Hash::ClassMethods);Fi[	I"9data//mongoid_proj/lib/mongoid/extensions/integer.rb;Ti;I"Ÿ        end
        
        (alias :demongoize :mongoize)
      end
    end
  end
end
::Integer.__send__(:include, Mongoid::Extensions::Integer)
::Integer.__send__(:extend, Mongoid::Extensions::Integer::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/module.rb;TiI"√      def function(arglist)
        undef_method(var) if method_defined?(var)
        define_method(var, &var)
      end
    end
  end
end
::Module.__send__(:include, Mongoid::Extensions::Module);Fi[	I";data//mongoid_proj/lib/mongoid/extensions/nil_class.rb;TiI"§      # @since 1.0.0
      def function(arglist)
        to_s.collectionize
      end
    end
  end
end
::NilClass.__send__(:include, Mongoid::Extensions::NilClass);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/object.rb;TiI"¨        # @since 3.0.0
        def function(arglist)
          var.mongoize
        end
      end
    end
  end
end
::Object.__send__(:include, Mongoid::Extensions::Object);Fi[	@Z	i	I"€        def function(arglist)
          var.mongoize
        end
      end
    end
  end
end
::Object.__send__(:include, Mongoid::Extensions::Object)
::Object.__send__(:extend, Mongoid::Extensions::Object::ClassMethods);Fi[	I";data//mongoid_proj/lib/mongoid/extensions/object_id.rb;Ti1I"…        # @since 3.0.0
        def function(arglist)
          var.__mongoize_object_id__
        end
      end
    end
  end
end
Moped::BSON::ObjectId.__send__(:include, Mongoid::Extensions::ObjectId);Fi[	@_	i2I"        def function(arglist)
          var.__mongoize_object_id__
        end
      end
    end
  end
end
Moped::BSON::ObjectId.__send__(:include, Mongoid::Extensions::ObjectId)
Moped::BSON::ObjectId.__send__(:extend, Mongoid::Extensions::ObjectId::ClassMethods);Fi[	I"7data//mongoid_proj/lib/mongoid/extensions/range.rb;TiII"‡        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : ({ "min" => (var.first), "max" => (var.last) })
        end
      end
    end
  end
end
::Range.__send__(:include, Mongoid::Extensions::Range);Fi[	@d	iJI"        def function(arglist)
          var.nil? ? (nil) : ({ "min" => (var.first), "max" => (var.last) })
        end
      end
    end
  end
end
::Range.__send__(:include, Mongoid::Extensions::Range)
::Range.__send__(:extend, Mongoid::Extensions::Range::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/regexp.rb;TiI"æ        # @since 3.0.0
        def function(arglist)
          ::Regexp.new(var)
        end
      end
    end
  end
end
::Regexp.__send__(:extend, Mongoid::Extensions::Regexp::ClassMethods);Fi[	@i	iI"ß        def function(arglist)
          ::Regexp.new(var)
        end
      end
    end
  end
end
::Regexp.__send__(:extend, Mongoid::Extensions::Regexp::ClassMethods);Fi[	I"5data//mongoid_proj/lib/mongoid/extensions/set.rb;Ti1I"¢        # @since 3.0.0
        def function(arglist)
          var.to_a
        end
      end
    end
  end
end
::Set.__send__(:include, Mongoid::Extensions::Set);Fi[	@n	i2I"À        def function(arglist)
          var.to_a
        end
      end
    end
  end
end
::Set.__send__(:include, Mongoid::Extensions::Set)
::Set.__send__(:extend, Mongoid::Extensions::Set::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/string.rb;Ti¿I"Ø        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::String.__send__(:include, Mongoid::Extensions::String);Fi[	@s	i¡I"ﬁ        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::String.__send__(:include, Mongoid::Extensions::String)
::String.__send__(:extend, Mongoid::Extensions::String::ClassMethods);Fi[	I"8data//mongoid_proj/lib/mongoid/extensions/symbol.rb;Ti0I"Ø        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::Symbol.__send__(:include, Mongoid::Extensions::Symbol);Fi[	@x	i1I"ﬁ        def function(arglist)
          demongoize(var)
        end
      end
    end
  end
end
::Symbol.__send__(:include, Mongoid::Extensions::Symbol)
::Symbol.__send__(:extend, Mongoid::Extensions::Symbol::ClassMethods);Fi[	I"6data//mongoid_proj/lib/mongoid/extensions/time.rb;TiII"Æ            ::Time.at(var.to_i, var).utc)
          rescue ArgumentError
            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end;Fi[	@}	iJI"π          rescue ArgumentError
            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end
::Time.__send__(:include, Mongoid::Extensions::Time);Fi[	@}	iKI"‹            raise(Errors::InvalidTime.new(var))
          end
        end
      end
    end
  end
end
::Time.__send__(:include, Mongoid::Extensions::Time)
::Time.__send__(:extend, Mongoid::Extensions::Time::ClassMethods);Fi[	I"@data//mongoid_proj/lib/mongoid/extensions/time_with_zone.rb;Ti2I"œ        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::ActiveSupport::TimeWithZone.__send__(:include, Mongoid::Extensions::TimeWithZone);Fi[	@Ñ	i3I"        def function(arglist)
          ::Time.mongoize(var)
        end
      end
    end
  end
end
::ActiveSupport::TimeWithZone.__send__(:include, Mongoid::Extensions::TimeWithZone)
::ActiveSupport::TimeWithZone.__send__(:extend, Mongoid::Extensions::TimeWithZone::ClassMethods);Fi[	I"<data//mongoid_proj/lib/mongoid/extensions/true_class.rb;Ti!I"—      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::TrueClass.__send__(:include, Mongoid::Extensions::TrueClass);Fi[	I".data//mongoid_proj/lib/mongoid/factory.rb;Ti,I"        var.instantiate(var, var)
      else
        var.camelize.constantize.instantiate(var, var)
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/fields/foreign_key.rb;Ti´I"]      # @since 3.0.0
      def function(arglist)
        var
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/fields/localized.rb;TiEI"ô          var[::I18n.fallbacks[var].map(&:to_s).find { |arglist| var[var] }]
        else
          var[var.to_s]
        end
      end
    end
  end
end;Fi[	@í	iFI"Q        else
          var[var.to_s]
        end
      end
    end
  end
end;Fi[	I"6data//mongoid_proj/lib/mongoid/fields/standard.rb;TiI"g      # @since 3.0.0
      def function(arglist)
        mongoize(var)
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/fields/validators/macro.rb;TiCI"          var.keys.each do |arglist|
            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end;Fi[	@ö	iDI"‡            if OPTIONS.include?(var).! and Fields.options.include?(var).! then
              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	@ö	iEI"ë              raise(Errors::InvalidFieldOption.new(var, var, var, OPTIONS))
            end
          end
        end
      end
    end
  end
end;Fi[	@ö	iFI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"0data//mongoid_proj/lib/mongoid/hierarchy.rb;Ti+I"Õ            Array.wrap(var).each do |arglist|
              var.push(var)
              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end;Fi[	@£	i±I"∞          field(:_type, :default => (self.name), :type => (String))
        end
        var.field(:_type, :default => (var.name), :type => (String))
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/indexes/validators/options.rb;TiLI"÷            next if (var == :options)
            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end;Fi[	@®	iMI"¥            unless VALID_TYPES.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	@®	iNI"Ç              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
      end
    end
  end
end;Fi[	@®	iOI"J            end
          end
        end
      end
    end
  end
end;Fi[	I".data//mongoid_proj/lib/mongoid/indexes.rb;TiçI"¢      # @since 3.1.0
      def function(arglist)
        index_options.values.map { |arglist| (var[:database] or database_name) }.uniq
      end
    end
  end
end;Fi[	I"1data//mongoid_proj/lib/mongoid/inspection.rb;Ti1I"~        return var.map { |arglist| "#{name}: #{@attributes[name].inspect}" }
      else
        []
      end
    end
  end
end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/all.rb;TiI"µ        return false if var.is_a?(Array) and var.empty?
        var = Array.wrap(@var)
        var.all? { |arglist| var.any? { |arglist| var.===(var) } }
      end
    end
  end
end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/and.rb;TiI"G          end
        end
        true
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/matchers/default.rb;TiGI"ß      def function(arglist)
        attribute.__array__.any? do |arglist|
          var ? (var.send(var, first(var))) : (false)
        end
      end
    end
  end
end;Fi[	@Ω	iHI"ã        attribute.__array__.any? do |arglist|
          var ? (var.send(var, first(var))) : (false)
        end
      end
    end
  end
end;Fi[	I"6data//mongoid_proj/lib/mongoid/matchers/exists.rb;TiI"ë      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first)
      end
    end
  end
end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/gt.rb;TiI"Ö      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>)
      end
    end
  end
end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/gte.rb;TiI"Ü      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=)
      end
    end
  end
end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/in.rb;TiI"¶      def function(arglist)
        var = Array.wrap(@var)
        var.values.first.any? { |arglist| var.any? { |arglist| var.===(var) } }
      end
    end
  end
end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/lt.rb;TiI"Ö      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<)
      end
    end
  end
end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/lte.rb;TiI"Ü      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=)
      end
    end
  end
end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/ne.rb;TiI"å      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first)
      end
    end
  end
end;Fi[	I"3data//mongoid_proj/lib/mongoid/matchers/nin.rb;TiI"∂      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) }
      end
    end
  end
end;Fi[	I"2data//mongoid_proj/lib/mongoid/matchers/or.rb;TiI"]          return var if var
        end
        return false
      end
    end
  end
end;Fi[	I"4data//mongoid_proj/lib/mongoid/matchers/size.rb;TiI"í      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first)
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/matchers/strategies.rb;TiRI"e          end
        else
          var.attributes[var]
        end
      end
    end
  end
end;Fi[	@‡	iSI"W        else
          var.attributes[var]
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/multi_parameter_attributes.rb;TiRI"k        var.mongoize(var)
      else
        var ? (var.new(*var)) : (var)
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/nested_attributes.rb;Ti6I"‚          re_define_method(var) do |arglist|
            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end;Fi[	@Ë	i7I"π            _assigning do |arglist|
              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ë	i8I"ï              var.nested_builder(var, var).build(self, mass_assignment_options)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ë	i9I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"/data//mongoid_proj/lib/mongoid/observer.rb;TiRI"¡          var.respond_to?(:to_sym) ? (var.to_s.camelize.constantize) : (var)
        end
        singleton_class.redefine_method(:observed_classes) { |arglist| var }
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/atomic/add_to_set.rb;Ti)I"π        # @since 2.0.0
        def function(arglist)
          { var => ({ path => (value.is_a?(Array) ? ({ "$each" => (value) }) : (value)) }) }
        end
      end
    end
  end
end;Fi[	@Ù	i*I"¢        def function(arglist)
          { var => ({ path => (value.is_a?(Array) ? ({ "$each" => (value) }) : (value)) }) }
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/bit.rb;TiI"}            end
            execute("$bit")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@˘	iI"r            execute("$bit")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@˘	i I"V            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/inc.rb;Ti*I"|        # @since 3.0.3
        def function(arglist)
          value.__to_inc__
        end
      end
    end
  end
end;Fi[	@ 
i+I"e        def function(arglist)
          value.__to_inc__
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/persistence/atomic/operation.rb;TiâI"ù            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	@
iäI"c            execute(var)
            var
          end
        end
      end
    end
  end
end;Fi[	@
iãI"J            var
          end
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/persistence/atomic/pop.rb;TiI"•              (value > 0) ? (var.pop) : (var.shift)
              execute("$pop")
              var
            end
          end
        end
      end
    end
  end;Fi[	@
iI"z              execute("$pop")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/pull.rb;TiI"í              var.delete(value)
              execute("$pull")
              var
            end
          end
        end
      end
    end
  end;Fi[	@
iI"{              execute("$pull")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/persistence/atomic/pull_all.rb;TiI"≥              var.delete_if { |arglist| value.include?(var) }
              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end;Fi[	@
iI"~              execute("$pullAll")
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	@
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/push.rb;TiI"{        # @since 2.0.0
        def function(arglist)
          append_with("$push")
        end
      end
    end
  end
end;Fi[	@'
iI"i        def function(arglist)
          append_with("$push")
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/persistence/atomic/push_all.rb;TiI"~        # @since 2.1.0
        def function(arglist)
          append_with("$pushAll")
        end
      end
    end
  end
end;Fi[	@,
iI"l        def function(arglist)
          append_with("$pushAll")
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/persistence/atomic/rename.rb;TiI"ö            execute("$rename")
            document.remove_change(value)
            document[value]
          end
        end
      end
    end
  end
end;Fi[	@1
iI"{            document.remove_change(value)
            document[value]
          end
        end
      end
    end
  end
end;Fi[	@1
iI"V            document[value]
          end
        end
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/persistence/atomic/sets.rb;TiI"ë            document[field] = value
            execute("$set")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@8
iI"r            execute("$set")
            document[field]
          end
        end
      end
    end
  end
end;Fi[	@8
iI"V            document[field]
          end
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/persistence/atomic/unset.rb;TiI"∏          prepare do |arglist|
            fields.each { |arglist| document.attributes.delete(var) }
            execute("$unset")
          end
        end
      end
    end
  end
end;Fi[	@?
iI"ô            fields.each { |arglist| document.attributes.delete(var) }
            execute("$unset")
          end
        end
      end
    end
  end
end;Fi[	@?
iI"X            execute("$unset")
          end
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/persistence/atomic.rb;Ti›I"™        var = var.__find_args__
        var = var[-1].is_a?(Hash) ? (var.delete_at(-1)) : ({})
        Unset.new(self, var, true, var).persist
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/persistence/deletion.rb;TiI"r        IdentityMap.remove(document)
        Threaded.clear_options!
        true
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/persistence/insertion.rb;Ti#I"n        end
        document.errors.clear unless validating?
        document
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/persistence/modification.rb;Ti!I"å        document.post_persist unless (var == false)
        document.errors.clear unless validating?
        var
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/insert.rb;TiI"∆                parent.insert
              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end;Fi[	@R
iI"Æ              else
                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end;Fi[	@R
iI"ü                collection.find(parent.atomic_selector).update(inserts)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@R
iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	@R
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Mdata//mongoid_proj/lib/mongoid/persistence/operations/embedded/remove.rb;TiI"˘              parent.remove_child(var) if notifying_parent?
              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end;Fi[	@]
iI"√              if parent.persisted? then
                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end;Fi[	@]
iI"ü                collection.find(parent.atomic_selector).update(deletes)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@]
iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	@]
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/insert.rb;TiI"§          prepare do |arglist|
            collection.insert(var.as_document)
            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	@h
iI"Ö            collection.insert(var.as_document)
            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	@h
iI"[            IdentityMap.set(var)
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/remove.rb;TiI"π        # @return [ true ] Always true.
        def function(arglist)
          prepare { |arglist| collection.find(var.atomic_selector).remove }
        end
      end
    end
  end
end;Fi[	@o
iI"ë        def function(arglist)
          prepare { |arglist| collection.find(var.atomic_selector).remove }
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/update.rb;TiI"Û              collection.find(selector).update(updates)
              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end;Fi[	@t
iI"¡              conflicts.each_pair do |arglist|
                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end;Fi[	@t
iI"ñ                collection.find(selector).update(var => (var))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@t
iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	@t
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//mongoid_proj/lib/mongoid/persistence/operations/upsert.rb;TiI"¿        def function(arglist)
          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	@
iI"¢          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	@
iI"É            collection.find(selector).update(document.as_document, [:upsert])
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/persistence/upsertion.rb;TiI"l        end
        document.post_persist unless (var == false)
        var
      end
    end
  end
end;Fi[	I"2data//mongoid_proj/lib/mongoid/persistence.rb;Ti8I"Ä      # @since 2.2.0
      def function(arglist)
        raise(Errors::Callback.new(var.class, var))
      end
    end
  end
end;Fi[	I".data//mongoid_proj/lib/mongoid/railtie.rb;Ti`I"E          if ::Mongoid.running_with_passenger? then
            PhusionPassenger.on_event(:starting_worker_process) do |arglist|
              ::Mongoid.default_session.disconnect if var
            end
          end
        end
      end
      
      # Exposes Mongoid's configuration to the Rails application configuration.;Fi[	@å
iáI"û      def function(arglist)
        puts("There is a configuration error with the current mongoid.yml.")
        puts(var.message)
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/accessors.rb;Ti˝I"á            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	@ë
i˛I"I          end
          self
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/auto_save.rb;TiGI"˚                  (var.do_or_do_not(:in_memory) or Array.wrap(var)).each { |arglist| var.save }
                end
                exit_autosave
              end
            end
          end
        end
        
        # Can the autosave be added?;Fi[	@ñ
iXI"£        # @since 3.0.0
        def function(arglist)
          autosaved_relations.include?(var.name).! and var.embedded?.!
        end
      end
    end
  end
end;Fi[	@ñ
iYI"å        def function(arglist)
          autosaved_relations.include?(var.name).! and var.embedded?.!
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/binding.rb;TiöI"          if var = metadata.inverse_metadata(var) then
            if var = var.inverse_of_field_setter then
              var.you_must(var, var)
            end
          end
        end
      end
      
      # Bind the provided document with the base from the parent relation.;Fi[	@ù
i“I"ä        bind_polymorphic_type(var, nil)
        bind_inverse(var, nil)
        bind_inverse_of_field(var, nil)
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/bindings/embedded/in.rb;Ti8I"ı                target.do_or_do_not(metadata.inverse(target)).delete(base)
              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end;Fi[	@¢
i9I"∞              else
                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end;Fi[	@¢
i:I"°                target.do_or_do_not(metadata.inverse_setter(target), nil)
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@¢
i;I"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	@¢
i<I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/many.rb;Ti-I"Ã          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	@≠
i.I"Æ          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	@≠
i/I"é            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/bindings/embedded/one.rb;Ti1I"           def function(arglist)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end;Fi[	@¥
i2I"Æ            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	@¥
i3I"ç              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end
          end
        end
      end
    end
  end
end;Fi[	@¥
i4I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/in.rb;Ti!I"!                    target.__send__(var).push(base) unless Mongoid.using_identity_map?
                  else
                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          ;Fi[	@Ω
i"I"                  else
                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the;Fi[	@Ω
i>I"ÿ                  target.__send__(var).delete(base)
                else
                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end;Fi[	@Ω
i?I"¨                else
                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end;Fi[	@Ω
i@I"ù                  target.__send__("#{inverse}=", nil)
                end
              end
            end
          end
        end
      end
    end
  end;Fi[	@Ω
iAI"p                end
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@Ω
iBI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	@Ω
iCI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many.rb;Ti!I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	@Œ
i"I"ö          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	@Œ
i#I"            binding { |arglist| unbind_from_relational_parent(var) }
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/many_to_many.rb;Ti/I"»              end
              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end;Fi[	@’
i0I"∫              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	@’
i1I"É              var.synced[metadata.inverse_foreign_key] = true
            end
          end
        end
      end
    end
  end
end;Fi[	@’
i2I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/bindings/referenced/one.rb;Ti#I"ª          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	@ﬁ
i$I"ù          def function(arglist)
            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	@ﬁ
i%I"}            binding { |arglist| unbind_from_relational_parent(target) }
          end
        end
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/builder.rb;Ti5I"í      def function(arglist)
        var = object.__array__.first
        var.is_a?(Mongoid::Document).! and var.nil?.!
      end
    end
  end
end;Fi[	I"Edata//mongoid_proj/lib/mongoid/relations/builders/embedded/in.rb;TiI"™              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end;Fi[	@Ë
iI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ë
iI"u              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@Ë
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/embedded/many.rb;Ti!I"l              end
            end
            var
          end
        end
      end
    end
  end
end;Fi[	@Ò
i"I"Z            end
            var
          end
        end
      end
    end
  end
end;Fi[	@Ò
i#I"J            var
          end
        end
      end
    end
  end
end;Fi[	I"Fdata//mongoid_proj/lib/mongoid/relations/builders/embedded/one.rb;TiI"™              Factory.from_db(klass, object)
            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end;Fi[	@¯
iI"Å            else
              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@¯
iI"u              Factory.build(klass, object)
            end
          end
        end
      end
    end
  end
end;Fi[	@¯
iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Pdata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/many.rb;Ti®I"Æ              var.assign_attributes(var, var)
            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end;Fi[	@i©I"Ñ            else
              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	@i™I"x              var.update_attributes(var, var)
            end
          end
        end
      end
    end
  end
end;Fi[	@i´I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Odata//mongoid_proj/lib/mongoid/relations/builders/nested_attributes/one.rb;Ti~I"´          # @since 2.0.0
          def function(arglist)
            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	@
iI"í          def function(arglist)
            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	@
i{I"w            existing and (destroyable?.! and acceptable_id?)
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//mongoid_proj/lib/mongoid/relations/builders/referenced/in.rb;TiI"‘            return object unless query?
            var = var ? (var.constantize) : (metadata.klass)
            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@iI"¨            var = var ? (var.constantize) : (metadata.klass)
            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@iI"t            metadata.criteria(object, var).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"Idata//mongoid_proj/lib/mongoid/relations/builders/referenced/many.rb;TiI"˘            return [] if object.is_a?(Array)
            var = metadata.criteria(Conversions.flag(object, metadata), base.class)
            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	@iI"Ã            var = metadata.criteria(Conversions.flag(object, metadata), base.class)
            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	@iI"}            (IdentityMap.get_many(var.klass, var.selector) or var)
          end
        end
      end
    end
  end
end;Fi[	I"Qdata//mongoid_proj/lib/mongoid/relations/builders/referenced/many_to_many.rb;Ti%I"∏          # @since 2.0.0.rc.1
          def function(arglist)
            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	@i&I"ö          def function(arglist)
            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	@i'I"            (object.nil? or object.first.is_a?(Mongoid::Document).!)
          end
        end
      end
    end
  end
end;Fi[	I"Hdata//mongoid_proj/lib/mongoid/relations/builders/referenced/one.rb;TiI"Â            return object unless query?
            return nil if base.new_record?
            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@&iI"Ω            return nil if base.new_record?
            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	@&iI"í            metadata.criteria(Conversions.flag(object, metadata), base.class).from_map_or_db
          end
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/relations/builders.rb;TiUI"Y            var
          end
          self
        end
      end
    end
  end
end;Fi[	@-iVI"I          end
          self
        end
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/mongoid/relations/cascading/delete.rb;Ti(I"≤              relation.clear
            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end;Fi[	@2i)I"ô            else
              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	@2i*I"à              ::Array.wrap(relation).each { |arglist| var.delete }
            end
          end
        end
      end
    end
  end
end;Fi[	@2i+I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/destroy.rb;Ti'I"ß              relation.each { |arglist| var.destroy }
            else
              relation.destroy
            end
          end
        end
      end
    end
  end;Fi[	@;i(I"z            else
              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	@;i)I"i              relation.destroy
            end
          end
        end
      end
    end
  end
end;Fi[	@;i*I"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/relations/cascading/nullify.rb;Ti!I"â        #   strategy.cascade
        def function(arglist)
          relation.nullify if relation
        end
      end
    end
  end
end;Fi[	@Di"I"q        def function(arglist)
          relation.nullify if relation
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/cascading/restrict.rb;Ti#I"√        def function(arglist)
          unless relation.blank? then
            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	@Ii$I"•          unless relation.blank? then
            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	@Ii%I"            raise(Errors::DeleteRestriction.new(document, metadata.name))
          end
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/cascading.rb;Ti I"÷            if var = relations[var] then
              var = var.cascade_strategy
              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods;Fi[	@Pi4I"ç        def function(arglist)
          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	@Pi5I"t          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/relations/constraint.rb;Ti+I"ó            var.map! { |arglist| var.mongoize(var) }
          else
            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	@Wi,I"g          else
            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	@Wi-I"X            var.mongoize(var)
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/conversions.rb;TiI"Ç        else
          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	@^iI"z          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/relations/cyclic.rb;Ti^I"Ã        # @since 2.0.0.rc.1
        def function(arglist)
          ("child_" << self.name.demodulize.underscore.send((var ? (:pluralize) : (:singularize)))).to_sym
        end
      end
    end
  end
end;Fi[	@ci_I"∞        def function(arglist)
          ("child_" << self.name.demodulize.underscore.send((var ? (:pluralize) : (:singularize)))).to_sym
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/embedded/batchable.rb;TiBI"ë            var.freeze
            var.destroyed = true
            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	@hiCI"            var.destroyed = true
            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	@hiDI"^            IdentityMap.remove(var)
          end
        end
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/relations/macros.rb;Ti'I"!                index({ var => 1, var.type => 1 }, :background => (true))
              else
                index({ var => 1 }, :background => (true))
              end
            end
          end
        end
        
        # Handle common behaviour for referenced 1-1 relation setup.;Fi[	@oiMI"…        def function(arglist)
          self.relations = relations.merge(var.to_s => (var))
          getter(var, var).setter(var, var).existence_check(var, var)
        end
      end
    end
  end
end;Fi[	@oiNI"´          self.relations = relations.merge(var.to_s => (var))
          getter(var, var).setter(var, var).existence_check(var, var)
        end
      end
    end
  end
end;Fi[	I"5data//mongoid_proj/lib/mongoid/relations/many.rb;TiÃI"Æ        var, var = {}, var if var.is_a?(Class)
        var["_type"] = var.to_s if var
        (where(var).first or send(var, var, var, var, &var))
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/marshalable.rb;TiI"q      # @since 3.0.15
      def function(arglist)
        @var, @var, @var = var
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/relations/metadata.rb;TiâI"p      # @since 3.0.0
      def function(arglist)
        klass.relations.values
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/relations/nested_builder.rb;TiFI"ü      # @since 2.0.0.rc.6
      def function(arglist)
        var.using_object_ids? ? (Moped::BSON::ObjectId.mongoize(var)) : (var)
      end
    end
  end
end;Fi[	I"4data//mongoid_proj/lib/mongoid/relations/one.rb;Ti,I"|      # @since 2.1.8
      def function(arglist)
        (target.respond_to?(var, var) or super)
      end
    end
  end
end;Fi[	I"8data//mongoid_proj/lib/mongoid/relations/options.rb;TiI"¬        var.keys.each do |arglist|
          if var.include?(var).! then
            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	@ÖiI"ü          if var.include?(var).! then
            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	@Öi I"~            raise(Errors::InvalidOptions.new(var[:name], var, var))
          end
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/polymorphic.rb;Ti!I"Y            end
          end
          self
        end
      end
    end
  end
end;Fi[	@åi"I"I          end
          self
        end
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/relations/reflections.rb;Ti9I"”        # @return [ Array<Metadata> ] The matching relation metadata.
        def function(arglist)
          relations.values.select { |arglist| var.include?(var.macro) }
        end
      end
    end
  end
end;Fi[	@ëi:I"ç        def function(arglist)
          relations.values.select { |arglist| var.include?(var.macro) }
        end
      end
    end
  end
end;Fi[	I"@data//mongoid_proj/lib/mongoid/relations/synchronization.rb;TiçI"®        def function(arglist)
          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	@ñiéI"ä          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/mongoid/relations/targets/enumerable.rb;Ti∑I"ü        
        def function(arglist)
          _unloaded.selector.values.any?(&:blank_criteria?) ? ([]) : (_unloaded)
        end
      end
    end
  end
end;Fi[	@õi∏I"ñ        def function(arglist)
          _unloaded.selector.values.any?(&:blank_criteria?) ? ([]) : (_unloaded)
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/relations/touchable.rb;TiI"è        def function(arglist)
          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	@†iI"v          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	I"0data//mongoid_proj/lib/mongoid/relations.rb;TièI"        if instance_variable_defined?("@#{name}") then
          if (_parent.nil? or instance_variable_get("@#{name}").!=(_parent)) then
            remove_instance_variable("@#{name}")
          end
        end
      end
    end
    
    module ClassMethods;Fi[	@•iüI"h      # @since 2.3.1
      def function(arglist)
        self.relations
      end
    end
  end
end;Fi[	I"0data//mongoid_proj/lib/mongoid/reloading.rb;TiWI"ó      atomic_position.split(".").inject(var) do |arglist|
        var = var[(var =~ /\d/ ? (var.to_i) : (var))]
        var
      end
    end
  end
end;Fi[	I".data//mongoid_proj/lib/mongoid/scoping.rb;Ti„I"0          else
            if Mongoid.logger then
              Mongoid.logger.warn(("Creating scope :#{name}. " + "Overwriting existing method #{self.name}.#{name}."))
            end
          end
        end
      end
      
      # Checks if the intended scope is a valid object, either a criteria or;Fi[	@≠i4I"]          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	@≠i5I"G        else
          var
        end
      end
    end
  end
end;Fi[	I"4data//mongoid_proj/lib/mongoid/serialization.rb;TiçI"y        var[var]
      else
        { :except => (var[:except]), :only => (var[:only]) }
      end
    end
  end
end;Fi[	I"7data//mongoid_proj/lib/mongoid/sessions/factory.rb;Ti|I"†      def function(arglist)
        var["hosts"] = var["hosts"].map { |arglist| var =~ /:/ ? (var) : ("#{host}:27017") }
        var
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/sessions/mongo_uri.rb;Ti`I"k      # @since 3.0.0
      def function(arglist)
        @var ||= match[3]
      end
    end
  end
end;Fi[	I"Bdata//mongoid_proj/lib/mongoid/sessions/validators/storage.rb;Ti,I"û        # @since 3.0.0
        def function(arglist)
          var.keys.all? { |arglist| VALID_OPTIONS.include?(var) }
        end
      end
    end
  end
end;Fi[	@Ωi-I"á        def function(arglist)
          var.keys.all? { |arglist| VALID_OPTIONS.include?(var) }
        end
      end
    end
  end
end;Fi[	I"/data//mongoid_proj/lib/mongoid/sharding.rb;Ti8I"u      # @since 2.0.0
      def function(arglist)
        self.shard_key_fields = var
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/threaded/lifecycle.rb;Ti¬I"ã        # @since 2.3.4
        def function(arglist)
          Threaded.executing?("load_revision")
        end
      end
    end
  end
end;Fi[	@≈i√I"y        def function(arglist)
          Threaded.executing?("load_revision")
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/timestamps/created/short.rb;TiI"§          include(Created)
          fields.delete("created_at")
          field(:c_at, :type => (Time), :as => :created_at)
        end
      end
    end
  end
end;Fi[	@ iI"â          fields.delete("created_at")
          field(:c_at, :type => (Time), :as => :created_at)
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/timestamps/created.rb;TiI"∞          var = Time.now.utc
          self.updated_at = var if is_a?(Updated) and updated_at_changed?.!
          self.created_at = var
        end
      end
    end
  end
end;Fi[	@œiI"ì          self.updated_at = var if is_a?(Updated) and updated_at_changed?.!
          self.created_at = var
        end
      end
    end
  end
end;Fi[	I":data//mongoid_proj/lib/mongoid/timestamps/timeless.rb;Ti/I"|        def function(arglist)
          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	@‘i0I"^          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	I"?data//mongoid_proj/lib/mongoid/timestamps/updated/short.rb;TiI"§          include(Updated)
          fields.delete("updated_at")
          field(:u_at, :type => (Time), :as => :updated_at)
        end
      end
    end
  end
end;Fi[	@ŸiI"â          fields.delete("updated_at")
          field(:u_at, :type => (Time), :as => :updated_at)
        end
      end
    end
  end
end;Fi[	I"9data//mongoid_proj/lib/mongoid/timestamps/updated.rb;Ti$I"ê      # @since 2.4.0
      def function(arglist)
        frozen?.! and (timestamping? and (new_record? or changed?))
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/validations/associated.rb;TiI"}          var.exit_validate
        end
        var.errors.add(var, :invalid, options) unless var
      end
    end
  end
end;Fi[	I">data//mongoid_proj/lib/mongoid/validations/localizable.rb;TiI"Å          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	@‰iI"I        else
          super
        end
      end
    end
  end
end;Fi[	I";data//mongoid_proj/lib/mongoid/validations/presence.rb;TiII"v      # @since 3.0.5
      def function(arglist)
        var.blank? and var.!=(false)
      end
    end
  end
end;Fi[	I"<data//mongoid_proj/lib/mongoid/validations/queryable.rb;TiI"¬        ensure
          (klass.clear_persistence_options unless var.errors.empty?
          Threaded.exit_execution("#{klass.name}-validate-with-query"))
        end
      end
    end
  end
end;Fi[	@ÏiI"≥          (klass.clear_persistence_options unless var.errors.empty?
          Threaded.exit_execution("#{klass.name}-validate-with-query"))
        end
      end
    end
  end
end;Fi[	I"=data//mongoid_proj/lib/mongoid/validations/uniqueness.rb;TiI"±      # @since 2.4.4
      def function(arglist)
        (var.new_record? or (var.send("attribute_changed?", var.to_s) or scope_value_changed?(var)))
      end
    end
  end
end;Fi[	I"2data//mongoid_proj/lib/mongoid/validations.rb;TiÎI"á      # @since 3.0.2
      def function(arglist)
        Threaded.executing?("#{name}-validate-with-query")
      end
    end
  end
end;Fi[	I"1data//mongoid_proj/lib/mongoid/versioning.rb;TiøI"ì      # @return [ Integer ] The max number of versions.
      def function(arglist)
        self.version_max = var.to_i
      end
    end
  end
end;Fi[	I"Cdata//mongoid_proj/lib/rack/mongoid/middleware/identity_map.rb;Ti!I"ö        # @since 2.1.0
        def function(arglist)
          ::Mongoid.unit_of_work { |arglist| @var.call(var) }
        end
      end
    end
  end
end;Fi[	@˙i"I"É        def function(arglist)
          ::Mongoid.unit_of_work { |arglist| @var.call(var) }
        end
      end
    end
  end
end;Fi[	I"Odata//mongoid_proj/lib/rails/generators/mongoid/config/config_generator.rb;TiI"Ç      
      def function(arglist)
        template("mongoid.yml", File.join("config", "mongoid.yml"))
      end
    end
  end
end;Fi[	I"Adata//mongoid_proj/lib/rails/generators/mongoid_generator.rb;Ti6I"~      
      def function(arglist)
        "#{name}.destroy"
      end
    end
  end
end
module Rails
  module Generators;Fi[	@iAI"õ        return "Time" if (type.to_s == "datetime")
        return "String" if (type.to_s == "text")
        type.to_s.camelcase
      end
    end
  end
end;Fi[	I"-data//nokogiri_proj/nokogiri/css/node.rb;TiQI"®      # Convert to array
      def function(arglist)
        ([@var] + @var.map { |arglist| var.respond_to?(:to_a) ? (var.to_a) : ([var]) })
      end
    end
  end
end;Fi[	I"/data//nokogiri_proj/nokogiri/css/parser.rb;Ti}I"e      # reduce 73 omitted
      def function(arglist)
        var[0]
      end
    end
  end
end;Fi[	I"2data//nokogiri_proj/nokogiri/css/tokenizer.rb;TiwI"{          raise(ScanError, (("undefined state: '" + state.to_s) + "'"))
        end
        var
      end
    end
  end
end;Fi[	I"6data//nokogiri_proj/nokogiri/css/xpath_visitor.rb;TiöI"Ω        else
          var = (var < 0) ? ("<=") : (">=")
          return "(#{position} #{compare} #{b}) and (((#{position}-#{b}) mod #{a.abs}) = 0)"
        end
      end
    end
  end
end;Fi[	@iõI"∞          var = (var < 0) ? ("<=") : (">=")
          return "(#{position} #{compare} #{b}) and (((#{position}-#{b}) mod #{a.abs}) = 0)"
        end
      end
    end
  end
end;Fi[	I"4data//nokogiri_proj/nokogiri/decorators/slop.rb;Ti!I"x        end
        super if var.empty?
        (var.length == 1) ? (var.first) : (var)
      end
    end
  end
end;Fi[	I"1data//nokogiri_proj/nokogiri/html/builder.rb;TiI"u      # Convert the builder to HTML
      def function(arglist)
        @var.to_html
      end
    end
  end
end;Fi[	I"2data//nokogiri_proj/nokogiri/html/document.rb;Ti«I"ƒ          var = @var.slice!(0, var)
          var = @var.read(var) and (var << var) if ((var = (var - var.length)) > 0)
          var.empty? ? (nil) : (var)
        end
      end
    end
  end
end;Fi[	@i»I"†          var = @var.read(var) and (var << var) if ((var = (var - var.length)) > 0)
          var.empty? ? (nil) : (var)
        end
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/html/document_fragment.rb;TiI"`          self.errors = var.errors
        end
        children
      end
    end
  end
end;Fi[	I"=data//nokogiri_proj/nokogiri/html/element_description.rb;TiI"é      # Inspection information
      def function(arglist)
        "#<#{self.class.name}: #{name} #{description}>"
      end
    end
  end
end;Fi[	I"Fdata//nokogiri_proj/nokogiri/html/element_description_defaults.rb;Ti4I"h          raise(var)
        end
        DefaultDescriptions[var] = var
      end
    end
  end
end;Fi[	I"7data//nokogiri_proj/nokogiri/html/entity_lookup.rb;TiI"      # Look up entity with +name+
      def function(arglist)
        var = get(var) and var.value
      end
    end
  end
end;Fi[	I"4data//nokogiri_proj/nokogiri/html/sax/parser.rb;TiI"ò          var = ParserContext.file(var, var)
          yield(var) if block_given?
          var.parse_with(self)
        end
      end
    end
  end
end;Fi[	@,iI"p          yield(var) if block_given?
          var.parse_with(self)
        end
      end
    end
  end
end;Fi[	I"<data//nokogiri_proj/nokogiri/html/sax/parser_context.rb;TiI"x            super
          else
            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	@1iI"f          else
            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	@1iI"W            memory(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"9data//nokogiri_proj/nokogiri/html/sax/push_parser.rb;TiI"õ          @var = var
          @var = HTML::SAX::Parser.new(var, @var)
          initialize_native(@var, var, @var)
        end
      end
    end
  end
end;Fi[	@8iI"Ü          @var = HTML::SAX::Parser.new(var, @var)
          initialize_native(@var, var, @var)
        end
      end
    end
  end
end;Fi[	I"-data//nokogiri_proj/nokogiri/xml/attr.rb;TiI"g      
      def function(arglist)
        [:name, :namespace, :value]
      end
    end
  end
end;Fi[	I"7data//nokogiri_proj/nokogiri/xml/attribute_decl.rb;TiI"å      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/builder.rb;Ti•I"`            return var
          end
          self
        end
      end
    end
  end
end;Fi[	@Ci¶I"I          end
          self
        end
      end
    end
  end
end;Fi[	I".data//nokogiri_proj/nokogiri/xml/cdata.rb;TiI"}      # Get the name of this CDATA node
      def function(arglist)
        "#cdata-section"
      end
    end
  end
end;Fi[	I"1data//nokogiri_proj/nokogiri/xml/document.rb;TiÂI"^      
      def function(arglist)
        [:name, :children]
      end
    end
  end
end;Fi[	I":data//nokogiri_proj/nokogiri/xml/document_fragment.rb;TihI"ã      def function(arglist)
        return super unless String.===(var)
        document.fragment(var).children
      end
    end
  end
end;Fi[	I",data//nokogiri_proj/nokogiri/xml/dtd.rb;TiI"~      
      def function(arglist)
        attributes.each { |arglist| var.call([var, var]) }
      end
    end
  end
end;Fi[	I"8data//nokogiri_proj/nokogiri/xml/element_content.rb;Ti I"Ö      # Get the children of this ElementContent node
      def function(arglist)
        [c1, c2].compact
      end
    end
  end
end;Fi[	I"5data//nokogiri_proj/nokogiri/xml/element_decl.rb;TiI"å      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	I"4data//nokogiri_proj/nokogiri/xml/entity_decl.rb;TiI"å      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	I"2data//nokogiri_proj/nokogiri/xml/namespace.rb;TiI"\      
      def function(arglist)
        [:prefix, :href]
      end
    end
  end
end;Fi[	I":data//nokogiri_proj/nokogiri/xml/node/save_options.rb;Ti=I"R        end
        
        alias :to_i :options
      end
    end
  end
end;Fi[	I"-data//nokogiri_proj/nokogiri/xml/node.rb;TiwI"|      
      def function(arglist)
        [:name, :namespace, :attribute_nodes, :children]
      end
    end
  end
end;Fi[	I"6data//nokogiri_proj/nokogiri/xml/parse_options.rb;TiiI"ú          (var << var.downcase) if send(:"#{var.downcase}?")
        end
        super.sub(/>$/, ((" " + var.join(", ")) + ">"))
      end
    end
  end
end;Fi[	I":data//nokogiri_proj/nokogiri/xml/pp/character_data.rb;TiI"ß        # :nodoc:
        def function(arglist)
          "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{text.inspect}>"
        end
      end
    end
  end
end;Fi[	@iiI"ï        def function(arglist)
          "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{text.inspect}>"
        end
      end
    end
  end
end;Fi[	I"0data//nokogiri_proj/nokogiri/xml/pp/node.rb;Ti1I"v              end
            end
            var.breakable
          end
        end
      end
    end
  end
end;Fi[	@ni2I"d            end
            var.breakable
          end
        end
      end
    end
  end
end;Fi[	@ni3I"T            var.breakable
          end
        end
      end
    end
  end
end;Fi[	I"?data//nokogiri_proj/nokogiri/xml/processing_instruction.rb;Ti
I"x    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	I"/data//nokogiri_proj/nokogiri/xml/reader.rb;TieI"~      def function(arglist)
        while var = self.read do
          yield(var)
        end
      end
    end
  end
end;Fi[	@xifI"b        while var = self.read do
          yield(var)
        end
      end
    end
  end
end;Fi[	I"5data//nokogiri_proj/nokogiri/xml/sax/document.rb;TinI"ê        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@}ioI"a        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"3data//nokogiri_proj/nokogiri/xml/sax/parser.rb;Ti`I"æ          var.upcase!
          unless ENCODINGS[var] then
            raise(ArgumentError.new("'#{encoding}' is not a valid encoding"))
          end
        end
      end
    end
  end
end;Fi[	@ÇiaI"®          unless ENCODINGS[var] then
            raise(ArgumentError.new("'#{encoding}' is not a valid encoding"))
          end
        end
      end
    end
  end
end;Fi[	@ÇibI"É            raise(ArgumentError.new("'#{encoding}' is not a valid encoding"))
          end
        end
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/xml/sax/parser_context.rb;TiI"à            io(var, Parser::ENCODINGS[var])
          else
            memory(var)
          end
        end
      end
    end
  end
end;Fi[	@âiI"a          else
            memory(var)
          end
        end
      end
    end
  end
end;Fi[	@âiI"R            memory(var)
          end
        end
      end
    end
  end
end;Fi[	I"8data//nokogiri_proj/nokogiri/xml/sax/push_parser.rb;Ti%I"°        # Nokogiri::XML::SAX::Document#end_document to be called.
        def function(arglist)
          write("", true)
        end
      end
    end
  end
end;Fi[	@êi&I"d        def function(arglist)
          write("", true)
        end
      end
    end
  end
end;Fi[	I"/data//nokogiri_proj/nokogiri/xml/schema.rb;Ti-I"n      # file.
      def function(arglist)
        (validate(var).length == 0)
      end
    end
  end
end;Fi[	I"5data//nokogiri_proj/nokogiri/xml/syntax_error.rb;Ti6I"W      
      def function(arglist)
        super.chomp
      end
    end
  end
end;Fi[	I"-data//nokogiri_proj/nokogiri/xml/text.rb;Ti
I"å    class Text < Nokogiri::XML::CharacterData
      def function(arglist)
        self.native_content = var.to_s
      end
    end
  end
end;Fi[	I";data//nokogiri_proj/nokogiri/xml/xpath/syntax_error.rb;TiI"°      class SyntaxError < XML::SyntaxError
        def function(arglist)
          [super.chomp, str1].compact.join(": ")
        end
      end
    end
  end
end;Fi[	@ûiI"{        def function(arglist)
          [super.chomp, str1].compact.join(": ")
        end
      end
    end
  end
end;Fi[	I"6data//nokogiri_proj/nokogiri/xml/xpath_context.rb;TiI"é        var.each do |arglist|
          var = var.to_s.gsub(/.*:/, "")
          register_ns(var, var)
        end
      end
    end
  end
end;Fi[	@£iI"u          var = var.to_s.gsub(/.*:/, "")
          register_ns(var, var)
        end
      end
    end
  end
end;Fi[	I"4data//nokogiri_proj/nokogiri/xslt/stylesheet.rb;TiI"Ç      # returns serialized document
      def function(arglist)
        serialize(transform(var, var))
      end
    end
  end
end;Fi[	I"*data//omni_proj/omniauth/auth_hash.rb;Ti3I"]        var = super
        var["name"] ||= name
        var
      end
    end
  end
end;Fi[	I"5data//omni_proj/omniauth/strategies/developer.rb;TiI"í        options.fields.inject({}) do |arglist|
          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	@ÆiI"h          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	I")data//omni_proj/omniauth/strategy.rb;Ti–I"f      var.inject({}) do |arglist|
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	I"5data//omni_proj/omniauth/test/strategy_macros.rb;TiI"÷      def function(arglist)
        it("sets the user_info to #{user_info}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["user_info"]).to(eq(var))
        end
      end
    end
  end
end;Fi[	@∂iI"∫        it("sets the user_info to #{user_info}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["user_info"]).to(eq(var))
        end
      end
    end
  end
end;Fi[	I"8data//omni_proj/omniauth/test/strategy_test_case.rb;Ti I"é      
      def function(arglist)
        raise(NotImplementedError.new("Including specs must define #strategy"))
      end
    end
  end
end;Fi[	I" data//omni_proj/omniauth.rb;TiI"d        end
      else
        (var.first + camelize(var)[(1..-1)])
      end
    end
  end
end;Fi[	I"0data//paperclip_proj/paperclip/callbacks.rb;TiI"p    module Running
      def function(arglist)
        run_callbacks(var, &var)
      end
    end
  end
end;Fi[	I"Bdata//paperclip_proj/paperclip/interpolations/plural_cache.rb;TiI"r      
      def function(arglist)
        @var[var] ||= var.underscore.pluralize
      end
    end
  end
end;Fi[	I"Jdata//paperclip_proj/paperclip/matchers/have_attached_file_matcher.rb;Ti7I"å        
        def function(arglist)
          @var.ancestors.include?(Paperclip::InstanceMethods)
        end
      end
    end
  end
end;Fi[	@«i8I"É        def function(arglist)
          @var.ancestors.include?(Paperclip::InstanceMethods)
        end
      end
    end
  end
end;Fi[	I"Xdata//paperclip_proj/paperclip/matchers/validate_attachment_content_type_matcher.rb;TiAI"                (var << "  #{@missing_allowed_types.join(", ")} were rejected.")
              else
                (var << "  All were accepted successfully.")
              end
            end
          end
        end
        
        def function(arglist);Fi[	@ÃiMI"                (var << "  #{@missing_rejected_types.join(", ")} were accepted.")
              else
                (var << "  All were rejected successfully.")
              end
            end
          end
        end
        
        def function(arglist);Fi[	@ÃidI"ö        def function(arglist)
          @var ||= @var.select { |arglist| type_allowed?(var) }
          @var.none?
        end
      end
    end
  end
end;Fi[	@ÃieI"|          @var ||= @var.select { |arglist| type_allowed?(var) }
          @var.none?
        end
      end
    end
  end
end;Fi[	I"Tdata//paperclip_proj/paperclip/matchers/validate_attachment_presence_matcher.rb;Ti6I"ç          @var.send(@var).assign(@var)
          @var.valid?
          @var.errors[:"#{@var}"].blank?
        end
      end
    end
  end
end;Fi[	@’i7I"k          @var.valid?
          @var.errors[:"#{@var}"].blank?
        end
      end
    end
  end
end;Fi[	I"Pdata//paperclip_proj/paperclip/matchers/validate_attachment_size_matcher.rb;TibI"∞        
        def function(arglist)
          (@var.nil? or ((@var == Float::INFINITY) or passes_validation_with_size((@var + 1)).!))
        end
      end
    end
  end
end;Fi[	@⁄icI"ß        def function(arglist)
          (@var.nil? or ((@var == Float::INFINITY) or passes_validation_with_size((@var + 1)).!))
        end
      end
    end
  end
end;Fi[	I".data//paperclip_proj/paperclip/railtie.rb;TiI"π      if defined? ActiveRecord then
        Paperclip.options[:logger] = ActiveRecord::Base.logger
        ActiveRecord::Base.send(:include, Paperclip::Glue)
      end
    end
  end
end;Fi[	I"-data//paperclip_proj/paperclip/schema.rb;TiHI"e      
      def function(arglist)
        [:remove_attachment, var]
      end
    end
  end
end;Fi[	I"9data//paperclip_proj/paperclip/storage/filesystem.rb;Ti=I"h      
      def function(arglist)
        FileUtils.cp(path(var), var)
      end
    end
  end
end;Fi[	I"2data//paperclip_proj/paperclip/storage/fog.rb;Ti¨I"Å          @var[:fog_directory]
        end
        @var ||= connection.directories.new(:key => (var))
      end
    end
  end
end;Fi[	I"1data//paperclip_proj/paperclip/storage/s3.rb;TiI"∑            var[$1.downcase] = var
          else
            var[var.to_s.downcase.sub(/^x-amz-/, "").tr("-", "_").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	@ÎiI"î          else
            var[var.to_s.downcase.sub(/^x-amz-/, "").tr("-", "_").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	@ÎiI"Ö            var[var.to_s.downcase.sub(/^x-amz-/, "").tr("-", "_").to_sym] = var
          end
        end
      end
    end
  end
end;Fi[	I",data//paperclip_proj/paperclip/style.rb;TimI"g        send("#{key}=".intern, var)
      else
        @var[var] = var
      end
    end
  end
end;Fi[	I"0data//paperclip_proj/paperclip/thumbnail.rb;TinI"Ÿ        end
      rescue Cocaine::CommandNotFoundError => var
        raise(Paperclip::Errors::CommandNotFoundError.new("Could not run the `identify` command. Please install ImageMagick."))
      end
    end
  end
end;Fi[	I"Sdata//paperclip_proj/paperclip/validators/attachment_content_type_validator.rb;TiLI"—      # name +[attachment]_content_type+ to be able to use this validator.
      def function(arglist)
        validates_with(AttachmentContentTypeValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Odata//paperclip_proj/paperclip/validators/attachment_presence_validator.rb;TiI"        [attributes].flatten.map do |arglist|
          if var.send(:read_attribute_for_validation, "#{attribute}_file_name").blank? then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module HelperMethods;Fi[	@˚iI"’      # * +unless+: Same as +if+ but validates if lambda or method returns false.
      def function(arglist)
        validates_with(AttachmentPresenceValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"Kdata//paperclip_proj/paperclip/validators/attachment_size_validator.rb;TiI"s            unless var.send(CHECKS[var], var) then
              var = options[:in] ? (:in_between) : (var)
              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist);Fi[	@ i\I"—      # * +unless+: Same as +if+ but validates if lambda or method returns false.
      def function(arglist)
        validates_with(AttachmentSizeValidator, _merge_attributes(var))
      end
    end
  end
end;Fi[	I"1data//paperclip_proj/paperclip/validators.rb;Ti)I"\          end
        end
        validates(*(var + [var]))
      end
    end
  end
end;Fi[	I"Zdata//redmine_proj/plugins/acts_as_activity_provider/lib/acts_as_activity_provider.rb;Ti>I"É              end
            end
            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	@i?I"v            end
            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	@i@I"f            var.all(var[:find_options].dup)
          end
        end
      end
    end
  end
end;Fi[	I"Ldata//redmine_proj/plugins/acts_as_attachable/lib/acts_as_attachable.rb;Ti]I"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@i^I"Q        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Pdata//redmine_proj/plugins/acts_as_customizable/lib/acts_as_customizable.rb;TiÖI"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@iÜI"Q        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Bdata//redmine_proj/plugins/acts_as_event/lib/acts_as_event.rb;Ti@I"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@iAI"Q        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"Kdata//redmine_proj/plugins/acts_as_list/lib/active_record/acts/list.rb;Ti⁄I"™          remove_from_list
          increment_positions_on_lower_items(var)
          self.update_attribute(position_column, var)
        end
      end
    end
  end
end;Fi[	@i€I"è          increment_positions_on_lower_items(var)
          self.update_attribute(position_column, var)
        end
      end
    end
  end
end;Fi[	I"Ldata//redmine_proj/plugins/acts_as_searchable/lib/acts_as_searchable.rb;Ti^I"{            end
            var = var.all
            [var, var]
          end
        end
      end
    end
  end
end;Fi[	@#i_I"k            var = var.all
            [var, var]
          end
        end
      end
    end
  end
end;Fi[	@#i`I"Q            [var, var]
          end
        end
      end
    end
  end
end;Fi[	I"Kdata//redmine_proj/plugins/acts_as_tree/lib/active_record/acts/tree.rb;TiPI"√        #   subchild1.self_and_siblings # => [subchild1, subchild2]
        def function(arglist)
          parent ? (parent.children) : (self.class.roots)
        end
      end
    end
  end
end;Fi[	@*iQI"        def function(arglist)
          parent ? (parent.children) : (self.class.roots)
        end
      end
    end
  end
end;Fi[	I"Hdata//redmine_proj/plugins/acts_as_versioned/test/migration_test.rb;Ti+I"‡      ActiveRecord::Migrator.down((File.dirname("(string)") + "/fixtures/migrations/"))
      assert_raises(ActiveRecord::StatementInvalid) do |arglist|
        Thing.create(:title => "blah blah")
      end
    end
  end
end;Fi[	I"Jdata//redmine_proj/plugins/acts_as_watchable/lib/acts_as_watchable.rb;TiTI"]        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@2iUI"Q        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	I"_data//redmine_proj/plugins/awesome_nested_set/lib/awesome_nested_set/awesome_nested_set.rb;TiƒI"£        
        def function(arglist)
          scope_column_names.collect { |arglist| connection.quote_column_name(var) }
        end
      end
    end
  end
end;Fi[	@7i≈I"ö        def function(arglist)
          scope_column_names.collect { |arglist| connection.quote_column_name(var) }
        end
      end
    end
  end
end;Fi[	I"Sdata//redmine_proj/plugins/awesome_nested_set/lib/awesome_nested_set/helper.rb;Ti(I"a            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	@<i)I"H          end
          var
        end
      end
    end
  end
end;Ti[	I"Ydata//redmine_proj/plugins/awesome_nested_set/test/awesome_nested_set/helper_test.rb;TiI"Å            "#{("-" * c.level)} #{c.name}"
          end
          assert_equal(var, var)
        end
      end
    end
  end
end;Fi[	@AiI"[          end
          assert_equal(var, var)
        end
      end
    end
  end
end;Fi[	I"8data//redmine_proj/plugins/gravatar/lib/gravatar.rb;Ti3I"r          end
        end
        (var << "?#{opts.join("&")}") unless var.empty?
      end
    end
  end
end;Fi[	I"\data//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication/request.rb;TiI"Â        parameters[:_method].to_sym
      else
        request_method_without_openid
      end
    end
  end
end
if defined? ActionController::Request then
  ActionController::Request.send(:include, OpenIdAuthentication::Request);Fi[	I"9data//redmine_proj/plugins/rfpdf/lib/fpdf/chinese.rb;Ti8I"Ä          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[	I":data//redmine_proj/plugins/rfpdf/lib/fpdf/japanese.rb;TiAI"Ä          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"8data//redmine_proj/plugins/rfpdf/lib/fpdf/korean.rb;Ti'I"Ä          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"7data//redmine_proj/plugins/rfpdf/lib/rfpdf/fpdf.rb;TiWI"»                var = [612, 1008]
              else
                raise(("Unknown page format: " + var))
              end
            end
          end
        end
      end
      @var, @var = var;Fi[	@UiXI"Ø              else
                raise(("Unknown page format: " + var))
              end
            end
          end
        end
      end
      @var, @var = var
    else;Fi[	@UiêI"ÿ          var = ("put" + var.downcase)
          self.Error(("Unsupported font type: " + var)) unless self.respond_to?(var)
          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist);Fi[	@UiÒI"ı        else
          if @var.kind_of?(String).! then
            out((("/OpenAction [3 0 R /XYZ null null " + (@var / 100)) + "]"))
          end
        end
      end
    end
    if (@var == "single") then
      out("/PageLayout /SinglePage");Fi[	@Ui
I"ô        else
          (var = freadshort(var)
          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist);Fi[	I"Sdata//redmine_proj/plugins/rfpdf/lib/rfpdf/template_handler/compile_support.rb;TiBI"Ò        var = options[:inline] ? ("inline") : ("attachment")
        var = options[:filename] ? ("filename=#{options[:filename]}") : (nil)
        @var.headers["Content-Disposition"] = [var, var].compact.join(";")
      end
    end
  end
end;Fi[	I"2data//redmine_proj/plugins/rfpdf/lib/tcpdf.rb;TizI"´              Error(("Unsupported font type: " + var))
            else
              self.send(var, var)
            end
          end
        end
      end
    end
  end;Fi[	@ci{I"|            else
              self.send(var, var)
            end
          end
        end
      end
    end
  end
  ;Fi[	@ci|I"~              self.send(var, var)
            end
          end
        end
      end
    end
  end
  
  def function(arglist);Fi[	@ci	I"Ú        else
          if @var.is_a?(String).! then
            out((("/OpenAction [3 0 R /XYZ null null " + (@var / 100)) + "]"))
          end
        end
      end
    end
    if (@var == "single") then
      out("/PageLayout /SinglePage");Fi[	@ci÷
I"∏                (var << 65533)
                var = []
                var = 1
              end
            end
          end
        end
      else
        if ((var >> 6) == 2) then;Fi[	@ci◊I"‹                var.gsub!(/[\t\r\n\f]/, "")
                var.gsub!(/&nbsp;/, " ")
                Write(@var, unhtmlentities(var), "", var)
              end
            end
          end
        end
      end
    end;Fi[	@ciÿI"ƒ                var.gsub!(/&nbsp;/, " ")
                Write(@var, unhtmlentities(var), "", var)
              end
            end
          end
        end
      end
    end
    Ln(@var) if var;Fi[	@ciŸI"°                Write(@var, unhtmlentities(var), "", var)
              end
            end
          end
        end
      end
    end
    Ln(@var) if var
  end;Fi[	@ci6I"ú        if (var == 2) then
          @var = var
          @var = var
        end
      end
    end
  end
  
  alias_method(:write_html_cell, :writeHTMLCell);Fi[	@ciMI"/        if (@var[var][var][var]["i0"] <= var) and (var <= @var[var][var][var]["i1"]) then
          if (@var[var][var][var]["j0"] <= var) and (var <= @var[var][var][var]["j1"]) then
            return ((@var[var][var][var]["i1"] - var) + 1)
          end
        end
      end
    end
    return 0
  end;Fi[	I"$data//redmine_proj/redcloth3.rb;TiWI"                next if (var == "src") and var =~ /^(?!http)\w+:/
                (var << "#{prop}=\"#{$1.gsub("\"", "\\\"")}\"")
                break
              end
            end
          end
        end
        "<#{raw[1]}#{pcs.join(" ")}>"
      else;Fi[	@xijI"o        "<#{$1}#{$3}"
      else
        "&lt;#{$1}#{"&gt;" unless $3.blank?}"
      end
    end
  end
end;Fi[	I"3data//redmine_proj/redmine/activity/fetcher.rb;TiOI"V      
      def function(arglist)
        @@var[var]
      end
    end
  end
end;Fi[	I"/data//redmine_proj/redmine/codeset_util.rb;TiÜI"s            var = (var + $!.success)
          end
          var = var
        end
      end
    end
  end
end;Fi[	@ÄiáI"N          end
          var = var
        end
      end
    end
  end
end;Fi[	I"9data//redmine_proj/redmine/core_ext/active_record.rb;Ti$I"∏    if var.is_a?(String) and var.present? then
      unless var =~ /\A\d{4}-\d{2}-\d{2}( 00:00:00)?\z/ and var then
        var.errors.add(var, :not_a_date)
      end
    end
  end
end;Fi[	I"=data//redmine_proj/redmine/core_ext/date/calculations.rb;TiI"ƒ        # Returns difference with specified date in weeks
        def function(arglist)
          (((var.year - self.year) * 52) + (var.cweek - self.cweek))
        end
      end
    end
  end
end;Fi[	@àiI"ä        def function(arglist)
          (((var.year - self.year) * 52) + (var.cweek - self.cweek))
        end
      end
    end
  end
end;Fi[	I">data//redmine_proj/redmine/core_ext/string/conversions.rb;TiI"ó          # Object#to_a removed in ruby1.9
          def function(arglist)
            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	@çiI"q          def function(arglist)
            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	@çiI"Q            [self.dup]
          end
        end
      end
    end
  end
end;Fi[	I">data//redmine_proj/redmine/core_ext/string/inflections.rb;TiI"í      module Inflections
        def function(arglist)
          starts_with?("/") ? (self) : ("/#{self}")
        end
      end
    end
  end
end;Fi[	@îiI"~        def function(arglist)
          starts_with?("/") ? (self) : ("/#{self}")
        end
      end
    end
  end
end;Fi[	I"-data//redmine_proj/redmine/export/pdf.rb;Ti/I"∫                  var[var] = var[var]
                  var[var] = 1
                  var = 0
                end
              end
            end
          end
        end
        var;Fi[	@ôi0I"û                  var[var] = 1
                  var = 0
                end
              end
            end
          end
        end
        var
      end;Fi[	@ôiØI"w            return var
          else
            return nil
          end
        end
      end
    end
  end
end;Fi[	@ôi∞I"`          else
            return nil
          end
        end
      end
    end
  end
end;Fi[	@ôi±I"Q            return nil
          end
        end
      end
    end
  end
end;Fi[	I"3data//redmine_proj/redmine/helpers/calendar.rb;TiBI"q      
      def function(arglist)
        @var ||= (((first_wday + 5) % 7) + 1)
      end
    end
  end
end;Fi[	I"/data//redmine_proj/redmine/helpers/diff.rb;Ti<I"Z          end
        end
        var.join(" ").html_safe
      end
    end
  end
end;Fi[	I"0data//redmine_proj/redmine/helpers/gantt.rb;TiVI";                  var[:bar_late_end] = ((var - self.date_from) + 1)
                else
                  var[:bar_late_end] = ((self.date_to - self.date_from) + 1)
                end
              end
            end
          end
        end
        var.keys.each { |arglist| var[var] = (var[var] * var).floor };Fi[	@™iWI"                else
                  var[:bar_late_end] = ((self.date_to - self.date_from) + 1)
                end
              end
            end
          end
        end
        var.keys.each { |arglist| var[var] = (var[var] * var).floor }
        var;Fi[	@™i6I"‘        if var[:label] then
          var[:image].fill("black")
          var[:image].text(((var[:subject_width] + (var[:bar_end] or 0)) + 5), (var[:top] + 1), var[:label])
        end
      end
    end
  end
end;Fi[	@™i7I"∏          var[:image].fill("black")
          var[:image].text(((var[:subject_width] + (var[:bar_end] or 0)) + 5), (var[:top] + 1), var[:label])
        end
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/helpers/time_report.rb;TiJI"§              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist);Fi[	@≥iXI"⁄          @var["cf_#{cf.id}"] = { :sql => ("#{cf.join_alias}.value"), :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[	I"-data//redmine_proj/redmine/pagination.rb;Ti∫I"ø          var = var.select { |arglist| ((var <= var) or (var == var)) }
        end
        (var.empty? or ((var.size == 1) and (var.first == var))) ? ([]) : (var)
      end
    end
  end
end;Fi[	I"+data//redmine_proj/redmine/platform.rb;Ti
I"¿    class << self
      def function(arglist)
        (RUBY_PLATFORM =~ /(:?mswin|mingw)/ or ((RUBY_PLATFORM == "java") and (ENV["OS"] or ENV["os"]) =~ /windows/i))
      end
    end
  end
end;Fi[	I"Bdata//redmine_proj/redmine/scm/adapters/filesystem_adapter.rb;TiWI"é            return "#{self.url}#{without_leading_slash(path)}"
          end
          return self.url
        end
      end
    end
  end
end;Fi[	@æiXI"T          end
          return self.url
        end
      end
    end
  end
end;Fi[	I"3data//redmine_proj/redmine/subclass_factory.rb;TiI"y      def function(arglist)
        var = get_subclass(var)
        var.new(*var) if var
      end
    end
  end
end;Fi[	I"=data//redmine_proj/redmine/views/api_template_handler.rb;Ti
I"„    class ApiTemplateHandler
      def self.call(arglist)
        "Redmine::Views::Builders.for(params[:format], request, response) do |api|; #{template.source}; self.output_buffer = api.output; end"
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/views/builders/json.rb;TiI"Ä            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end
end;Fi[	@…iI"H          end
          var
        end
      end
    end
  end
end;Fi[	I";data//redmine_proj/redmine/views/builders/structure.rb;Ti9I"≈                @var.last[var].merge!(var)
              else
                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist);Fi[	@Œi@I"ç        
        def function(arglist)
          raise("Need to implement #{self.class.name}#output")
        end
      end
    end
  end
end;Fi[	@ŒiAI"Ñ        def function(arglist)
          raise("Need to implement #{self.class.name}#output")
        end
      end
    end
  end
end;Fi[	I"5data//redmine_proj/redmine/views/builders/xml.rb;TiI"ë        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var)
        end
      end
    end
  end
end;Fi[	@’iI"à        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var)
        end
      end
    end
  end
end;Fi[	I"1data//redmine_proj/redmine/views/builders.rb;TiI"Ä          raise("No builder for format #{format}")
        end
        var ? (var.call(var)) : (var)
      end
    end
  end
end;Fi[	I"6data//redmine_proj/redmine/views/my_page/block.rb;TiI"¨            var = File.basename(var).split(".").first.gsub(/^_/, "")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	@›iI"l            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end
end;Fi[	@›iI"J            var
          end
        end
      end
    end
  end
end;Fi[	I">data//redmine_proj/redmine/views/other_formats_builder.rb;TiI"‘        var = (var.delete(:caption) or var)
        var = { :class => (var.to_s.downcase), :rel => "nofollow" }.merge(var)
        @var.content_tag("span", @var.link_to(var, var, var))
      end
    end
  end
end;Fi[	I"Ddata//redmine_proj/redmine/wiki_formatting/textile/formatter.rb;TiUI"                  end
                else
                  (var << var)
                end
              end
            end
          end
          var = [var.strip, var.strip, var.strip]
          var.each { |arglist| smooth_offtags_without_code_highlighting(var) };Fi[	@ÁisI"€                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end
  end;Fi[	@ÁitI"n              end
              var
            end
          end
        end
      end
    end
  end
end;Fi[	@ÁiuI"\              var
            end
          end
        end
      end
    end
  end
end;Fi[	@ÁivI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Adata//redmine_proj/redmine/wiki_formatting/textile/helper.rb;TiI"#              ((javascript_include_tag("jstoolbar/jstoolbar-textile.min") + javascript_include_tag("jstoolbar/lang/jstoolbar-#{current_language.to_s.downcase}")) + stylesheet_link_tag("jstoolbar"))
            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	@ÚiI"b            end
            @var = true
          end
        end
      end
    end
  end
end;Fi[	@ÚiI"R            @var = true
          end
        end
      end
    end
  end
end;Fi[	I"(data//redmine_proj/SVG/Graph/Bar.rb;TiBI"q            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	@˘iCI"T          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	I",data//redmine_proj/SVG/Graph/BarBase.rb;Ti5I"g      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end
    end
  end
end;Fi[	I"2data//redmine_proj/SVG/Graph/BarHorizontal.rb;TiBI"q            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	@iCI"T          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	I"*data//redmine_proj/SVG/Graph/Graph.rb;TiìI"Ï      
      def function(arglist)
        return "/* Copy from here for external style sheet */\n.svgBackground{\n  fill:#ffffff;\n}\n.graphBackground{\n  fill:#f0f0f0;\n}\n\n/* graphs titles */\n.mainTitle{\n  text-anchor: middle;\n  fill: #000000;\n  font-size: #{title_font_size}px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n.subTitle{\n  text-anchor: middle;\n  fill: #999999;\n  font-size: #{subtitle_font_size}px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n\n.axis{\n  stroke: #000000;\n  stroke-width: 1px;\n}\n\n.guideLines{\n  stroke: #666666;\n  stroke-width: 1px;\n  stroke-dasharray: 5 5;\n}\n\n.xAxisLabels{\n  text-anchor: middle;\n  fill: #000000;\n  font-size: #{x_label_font_size}px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n\n.yAxisLabels{\n  text-anchor: end;\n  fill: #000000;\n  font-size: #{y_label_font_size}px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n\n.xAxisTitle{\n  text-anchor: middle;\n  fill: #ff0000;\n  font-size: #{x_title_font_size}px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n\n.yAxisTitle{\n  fill: #ff0000;\n  text-anchor: middle;\n  font-size: #{y_title_font_size}px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n\n.dataPointLabel{\n  fill: #000000;\n  text-anchor:middle;\n  font-size: 10px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n\n.staggerGuideLine{\n  fill: none;\n  stroke: #000000;\n  stroke-width: 0.5px;  \n}\n\n#{get_css}\n\n.keyText{\n  fill: #000000;\n  text-anchor:start;\n  font-size: #{key_font_size}px;\n  font-family: \"Arial\", sans-serif;\n  font-weight: normal;\n}\n/* End copy for external style sheet */\n"
      end
    end
  end
end;Fi[	I")data//redmine_proj/SVG/Graph/Line.rb;TiéI"      
      def function(arglist)
        return "/* default line styles */\n.line1{\n\tfill: none;\n\tstroke: #ff0000;\n\tstroke-width: 1px;\t\n}\n.line2{\n\tfill: none;\n\tstroke: #0000ff;\n\tstroke-width: 1px;\t\n}\n.line3{\n\tfill: none;\n\tstroke: #00ff00;\n\tstroke-width: 1px;\t\n}\n.line4{\n\tfill: none;\n\tstroke: #ffcc00;\n\tstroke-width: 1px;\t\n}\n.line5{\n\tfill: none;\n\tstroke: #00ccff;\n\tstroke-width: 1px;\t\n}\n.line6{\n\tfill: none;\n\tstroke: #ff00ff;\n\tstroke-width: 1px;\t\n}\n.line7{\n\tfill: none;\n\tstroke: #00ffff;\n\tstroke-width: 1px;\t\n}\n.line8{\n\tfill: none;\n\tstroke: #ffff00;\n\tstroke-width: 1px;\t\n}\n.line9{\n\tfill: none;\n\tstroke: #ccc6666;\n\tstroke-width: 1px;\t\n}\n.line10{\n\tfill: none;\n\tstroke: #663399;\n\tstroke-width: 1px;\t\n}\n.line11{\n\tfill: none;\n\tstroke: #339900;\n\tstroke-width: 1px;\t\n}\n.line12{\n\tfill: none;\n\tstroke: #9966FF;\n\tstroke-width: 1px;\t\n}\n/* default fill styles */\n.fill1{\n\tfill: #cc0000;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill2{\n\tfill: #0000cc;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill3{\n\tfill: #00cc00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n/* default line styles */\n.key1,.dataPoint1{\n\tfill: #ff0000;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key2,.dataPoint2{\n\tfill: #0000ff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.dataPoint3{\n\tfill: #00ff00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.dataPoint4{\n\tfill: #ffcc00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.dataPoint5{\n\tfill: #00ccff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.dataPoint6{\n\tfill: #ff00ff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.dataPoint7{\n\tfill: #00ffff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.dataPoint8{\n\tfill: #ffff00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.dataPoint9{\n\tfill: #cc6666;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.dataPoint10{\n\tfill: #663399;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.dataPoint11{\n\tfill: #339900;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.dataPoint12{\n\tfill: #9966FF;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end
    end
  end
end;Fi[	I"(data//redmine_proj/SVG/Graph/Pie.rb;Ti»I"Ñ      
      def function(arglist)
        return ".dataPointLabel{\n	fill: #000000;\n	text-anchor:middle;\n	font-size: #{datapoint_font_size}px;\n	font-family: \"Arial\", sans-serif;\n	font-weight: normal;\n}\n\n/* key - MUST match fill styles */\n.key1,.fill1{\n	fill: #ff0000;\n	fill-opacity: 0.7;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key2,.fill2{\n	fill: #0000ff;\n	fill-opacity: 0.7;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key3,.fill3{\n	fill-opacity: 0.7;\n	fill: #00ff00;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key4,.fill4{\n	fill-opacity: 0.7;\n	fill: #ffcc00;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key5,.fill5{\n	fill-opacity: 0.7;\n	fill: #00ccff;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key6,.fill6{\n	fill-opacity: 0.7;\n	fill: #ff00ff;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key7,.fill7{\n	fill-opacity: 0.7;\n	fill: #00ff99;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key8,.fill8{\n	fill-opacity: 0.7;\n	fill: #ffff00;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key9,.fill9{\n	fill-opacity: 0.7;\n	fill: #cc6666;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key10,.fill10{\n	fill-opacity: 0.7;\n	fill: #663399;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key11,.fill11{\n	fill-opacity: 0.7;\n	fill: #339900;\n	stroke: none;\n	stroke-width: 1px;	\n}\n.key12,.fill12{\n	fill-opacity: 0.7;\n	fill: #9966FF;\n	stroke: none;\n	stroke-width: 1px;	\n}\n"
      end
    end
  end
end;Fi[	I")data//redmine_proj/SVG/Graph/Plot.rb;TiƒI"      
      def function(arglist)
        return "/* default line styles */\n.line1{\n\tfill: none;\n\tstroke: #ff0000;\n\tstroke-width: 1px;\t\n}\n.line2{\n\tfill: none;\n\tstroke: #0000ff;\n\tstroke-width: 1px;\t\n}\n.line3{\n\tfill: none;\n\tstroke: #00ff00;\n\tstroke-width: 1px;\t\n}\n.line4{\n\tfill: none;\n\tstroke: #ffcc00;\n\tstroke-width: 1px;\t\n}\n.line5{\n\tfill: none;\n\tstroke: #00ccff;\n\tstroke-width: 1px;\t\n}\n.line6{\n\tfill: none;\n\tstroke: #ff00ff;\n\tstroke-width: 1px;\t\n}\n.line7{\n\tfill: none;\n\tstroke: #00ffff;\n\tstroke-width: 1px;\t\n}\n.line8{\n\tfill: none;\n\tstroke: #ffff00;\n\tstroke-width: 1px;\t\n}\n.line9{\n\tfill: none;\n\tstroke: #ccc6666;\n\tstroke-width: 1px;\t\n}\n.line10{\n\tfill: none;\n\tstroke: #663399;\n\tstroke-width: 1px;\t\n}\n.line11{\n\tfill: none;\n\tstroke: #339900;\n\tstroke-width: 1px;\t\n}\n.line12{\n\tfill: none;\n\tstroke: #9966FF;\n\tstroke-width: 1px;\t\n}\n/* default fill styles */\n.fill1{\n\tfill: #cc0000;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill2{\n\tfill: #0000cc;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill3{\n\tfill: #00cc00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n/* default line styles */\n.key1,.dataPoint1{\n\tfill: #ff0000;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key2,.dataPoint2{\n\tfill: #0000ff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.dataPoint3{\n\tfill: #00ff00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.dataPoint4{\n\tfill: #ffcc00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.dataPoint5{\n\tfill: #00ccff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.dataPoint6{\n\tfill: #ff00ff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.dataPoint7{\n\tfill: #00ffff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.dataPoint8{\n\tfill: #ffff00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.dataPoint9{\n\tfill: #cc6666;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.dataPoint10{\n\tfill: #663399;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.dataPoint11{\n\tfill: #339900;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.dataPoint12{\n\tfill: #9966FF;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end
    end
  end
end;Fi[	I"-data//redmine_proj/SVG/Graph/Schedule.rb;Ti«I"u        end
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
    end
  end
end;Fi[	I"/data//redmine_proj/SVG/Graph/TimeSeries.rb;TiâI"u        end
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
    end
  end
end;Fi[	I"-data//rescue_proj/resque/failure/base.rb;Ti9I"[      
      def self.remove(arglist)
        # do nothing
      end
    end
  end
end;Fi[	I"1data//rescue_proj/resque/failure/multiple.rb;Ti0I"y      
      def self.remove(arglist)
        classes.each { |arglist| var.remove(var) }
      end
    end
  end
end;Fi[	I".data//rescue_proj/resque/failure/redis.rb;Ti1I"à      
      def function(arglist)
        var.take_while { |arglist| var.include?("/lib/resque/job.rb").! }
      end
    end
  end
end;Fi[	I"3data//rescue_proj/resque/failure/thoughtbot.rb;Ti!I"à        var = payload["class"].to_s
        var = var.underscore if var.respond_to?(:underscore)
        var
      end
    end
  end
end;Fi[	I"(data//rescue_proj/resque/failure.rb;TiBI"©      var = 0
      while var = Resque::Failure.all(var) do
        (var["queue"] == var) ? (Resque::Failure.remove(var)) : (var = (var + 1))
      end
    end
  end
end;Fi[	I"(data//rescue_proj/resque/helpers.rb;Ti>I"n            var
          end
          var.const_get(var, false)
        end
      end
    end
  end
end;Fi[	@'i?I"^          end
          var.const_get(var, false)
        end
      end
    end
  end
end;Fi[	I"$data//rescue_proj/resque/job.rb;TiWI"ø                  var = var.perform(*var)
                  var = true
                  var
                end
              end
            end
          end
          var.call
        end;Fi[	@,i£I"N        end)
      ensure
        @var = true
      end
    end
  end
end;Fi[	I"+data//rescue_proj/resque/json_coder.rb;TiI"ì        JSON.load(var)
      rescue JSON::ParserError => var
        raise(DecodeException, var.message, var.backtrace)
      end
    end
  end
end;Fi[	I",data//rescue_proj/resque/multi_queue.rb;TiNI"Z      else
        Kernel.sleep(var)
        # do nothing
      end
    end
  end
end;Fi[	I"&data//rescue_proj/resque/queue.rb;Ti9I"ˇ        synchronize do |arglist|
          Array(@var.lrange(@var, var, ((var + var) - 1))).map do |arglist|
            decode(var)
          end
        end
      end
    end
    
    # Pop an item off the queue.  This method will block until an item is;Fi[	I"3data//rescue_proj/resque/server/test_helper.rb;TiI"Ã      def self.should_respond_with_success(arglist)
        it("should respond with success") do |arglist|
          assert(last_response.ok?, last_response.errors)
        end
      end
    end
  end
end;Fi[	@:iI"ò        it("should respond with success") do |arglist|
          assert(last_response.ok?, last_response.errors)
        end
      end
    end
  end
end;Fi[	I">data//rescue_proj/resque/vendor/utf8_util/utf8_util_18.rb;Ti<I"x            end
          else
            var.pos -= 1
          end
        end
      end
    end
    false
  end;Fi[	I"?data//rspec_proj/spec/adapters/mock_frameworks/flexmock.rb;TiI"Z      
      def function(arglist)
        flexmock_close
      end
    end
  end
end;Fi[	I"<data//rspec_proj/spec/adapters/mock_frameworks/mocha.rb;TiI"Z      
      def function(arglist)
        mocha_teardown
      end
    end
  end
end;Fi[	I"9data//rspec_proj/spec/adapters/mock_frameworks/rr.rb;TiI"d      
      def function(arglist)
        RR::Space.instance.reset
      end
    end
  end
end;Fi[	I"<data//rspec_proj/spec/adapters/mock_frameworks/rspec.rb;TiI"t        
        def function(arglist)
          $rspec_mocks.reset_all
        end
      end
    end
  end
end;Fi[	@KiI"k        def function(arglist)
          $rspec_mocks.reset_all
        end
      end
    end
  end
end;Fi[	I"&data//rspec_proj/spec/dsl/main.rb;Ti_I"F          Object.const_set(var, Spec::Example::ExampleGroupFactory.create_shared_example_group(*var, &var)))
        rescue NameError => var
          raise(NameError.new((var.message + "\nThe first argument to share_as must be a legal name for a constant\n")))
        end
      end
    end
  end
end
include(Spec::DSL::Main);Fi[	@Pi`I"Ÿ        rescue NameError => var
          raise(NameError.new((var.message + "\nThe first argument to share_as must be a legal name for a constant\n")))
        end
      end
    end
  end
end
include(Spec::DSL::Main);Fi[	I"6data//rspec_proj/spec/example/args_and_options.rb;TiI"r      module WithOptions
        def function(arglist)
          last
        end
      end
    end
  end
end;Fi[	@UiI"Y        def function(arglist)
          last
        end
      end
    end
  end
end;Fi[	I",data//rspec_proj/spec/example/errors.rb;TiI"o      
      def function(arglist)
        super(self.class.message(var, var))
      end
    end
  end
end;Fi[	I";data//rspec_proj/spec/example/example_group_factory.rb;TiPI"µ              self[(($2 == "") ? (nil) : ($2.to_sym))]
            else
              self[nil]
            end
          end
        end
      end
      
      extend(ClassMethods);Fi[	I"=data//rspec_proj/spec/example/example_group_hierarchy.rb;Ti<I"e      
      def function(arglist)
        var.description_args.join
      end
    end
  end
end;Fi[	I"9data//rspec_proj/spec/example/example_group_proxy.rb;Ti9I"l      
      def function(arglist)
        (var.description == description)
      end
    end
  end
end;Fi[	I"5data//rspec_proj/spec/example/example_methods.rb;TiñI"n      
      def function(arglist)
        self.class.example_group_hierarchy
      end
    end
  end
end;Fi[	I"3data//rspec_proj/spec/example/example_proxy.rb;Ti'I"Ö      
      def function(arglist)
        (var.description == description).&((var.location == location))
      end
    end
  end
end;Fi[	I":data//rspec_proj/spec/example/module_reopening_fix.rb;TiI"ä      def function(arglist)
        super
        child_modules.each { |arglist| var.__send__(:include, var) }
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/example/pending.rb;TiI"Ì          raise(Spec::Example::PendingExampleFixedError.new("Expected pending '#{message}' to fail. No Error was raised."))
        else
          raise(Spec::Example::ExamplePendingError.new(var))
        end
      end
    end
  end
end;Fi[	@oiI"v        else
          raise(Spec::Example::ExamplePendingError.new(var))
        end
      end
    end
  end
end;Fi[	I"8data//rspec_proj/spec/example/predicate_matchers.rb;Ti-I"÷        predicate_matchers.each_pair do |arglist|
          define_method(var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
    end
  end
end;Fi[	@ti.I"§          define_method(var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
    end
  end
end;Fi[	@ti/I"            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
    end
  end
end;Fi[	I":data//rspec_proj/spec/example/shared_example_group.rb;Ti=I"b      
      def function(arglist)
        var.module_eval(&@var)
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/example/subject.rb;Ti{I"§            self.__should_not_for_example_group__(var)
          else
            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	@~i|I"r          else
            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	@~i}I"c            subject.should_not(var, var)
          end
        end
      end
    end
  end
end;Fi[	I"2data//rspec_proj/spec/expectations/handler.rb;Ti2I"∞          ::Spec::Expectations.fail_with(var, var.expected.first, var.actual)
        else
          ::Spec::Expectations.fail_with(var)
        end
      end
    end
  end
end;Fi[	@Öi3I"g        else
          ::Spec::Expectations.fail_with(var)
        end
      end
    end
  end
end;Fi[	I"6data//rspec_proj/spec/extensions/instance_exec.rb;Ti"I"À            return send(:__instance_exec, *var)
          ensure
            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	@äi#I"õ          ensure
            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	@äi$I"ä            var.module_eval { |arglist| remove_method(:__instance_exec) } rescue nil
          end
        end
      end
    end
  end
end;Fi[	I"8data//rspec_proj/spec/interop/test/unit/testcase.rb;Ti%I"S      
      def function(arglist)
        super()
      end
    end
  end
end;Fi[	I"Adata//rspec_proj/spec/interop/test/unit/testsuite_adapter.rb;Ti%I"[      
      def function(arglist)
        examples.empty?
      end
    end
  end
end;Fi[	I"Edata//rspec_proj/spec/interop/test/unit/ui/console/testrunner.rb;TiDI"Ñ          end
          
          alias_method(:setup_mediator, :setup_mediator_with_rspec)
        end
      end
    end
  end
end;Fi[	@óiEI"{          
          alias_method(:setup_mediator, :setup_mediator_with_rspec)
        end
      end
    end
  end
end;Fi[	I"/data//rspec_proj/spec/matchers/be_close.rb;TiI"¡          "expected #{_expected_} +/- (< #{_delta_}), got #{actual}"
        end
        description { |arglist| "be close to #{_expected_} (within +- #{_delta_})" }
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/matchers/change.rb;Ti4I"G                  "#{@message} should have been changed by at most #{@maximum.inspect}, but was changed by #{actual_delta.inspect}"
                else
                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end;Fi[	@üi5I"                 else
                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      ;Fi[	@üi6I"—                  "#{@message} should have changed, but is still #{@before.inspect}"
                end
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	I"4data//rspec_proj/spec/matchers/compatibility.rb;TiI"ú    end) then
      var.class_eval do |arglist|
        alias_method(:negative_failure_message, :failure_message_for_should_not)
      end
    end
  end
end;Fi[	I"*data//rspec_proj/spec/matchers/dsl.rb;TiI"≈      def function(arglist)
        Spec.deprecate("Spec::Matchers.create", "Spec::Matchers.define")
        define(var, &var)
      end
    end
  end
end
Spec::Matchers.extend(Spec::Matchers::DSL);Fi[	I"*data//rspec_proj/spec/matchers/eql.rb;TiI"Œ        end
        failure_message_for_should_not do |arglist|
          "\nexpected #{actual.inspect} not to equal #{_expected_.inspect}\n\n(compared using eql?)\n"
        end
      end
    end
  end
end;Fi[	@¨iI"¬        failure_message_for_should_not do |arglist|
          "\nexpected #{actual.inspect} not to equal #{_expected_.inspect}\n\n(compared using eql?)\n"
        end
      end
    end
  end
end;Fi[	I",data//rspec_proj/spec/matchers/equal.rb;TiI"        end
        failure_message_for_should_not do |arglist|
          "\nexpected not #{inspect_object(actual)}\n         got #{inspect_object(_expected_)}\n\nCompared using equal?, which compares object identity.\n\n"
        end
      end
    end
  end
end;Fi[	@±iI"˙        failure_message_for_should_not do |arglist|
          "\nexpected not #{inspect_object(actual)}\n         got #{inspect_object(_expected_)}\n\nCompared using equal?, which compares object identity.\n\n"
        end
      end
    end
  end
end;Fi[	I",data//rspec_proj/spec/matchers/exist.rb;TiI"ü    def function(arglist)
      Matcher.new(:exist) do |arglist|
        match { |arglist| var ? (var.exist?(var)) : (var.exist?) }
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/matchers/generated_descriptions.rb;TiI"∆        last_matcher.description
      else
        "When you call a matcher in an example without a String, like this:\n\nspecify { object.should matcher }\n\nor this:\n\nit { should matcher }\n\nRSpec expects the matcher to have a #description method. You should either\nadd a String to the example this matcher is being used in, or give it a\ndescription method. Then you won't have to suffer this lengthy warning again.\n"
      end
    end
  end
end;Fi[	I"*data//rspec_proj/spec/matchers/has.rb;Ti I"v      
      def function(arglist)
        "#{sym.to_s.sub("have_", "has_")}?".to_sym
      end
    end
  end
end;Fi[	I"+data//rspec_proj/spec/matchers/have.rb;Ti:I"ü          else
            if (@var == :at_least) then
              return "Isn't life confusing enough?\nInstead of having to figure out the meaning of this:\n  should_not have_at_least(#{@expected}).#{@collection_name}\nWe recommend that you use this instead:\n  should have_at_most(#{(@expected - 1)}).#{@collection_name}\n"
            end
          end
        end
      end
      
      def function(arglist);Fi[	I".data//rspec_proj/spec/matchers/include.rb;Ti'I"Y            end
          end
          true
        end
      end
    end
  end
end;Fi[	@¬i(I"I          end
          true
        end
      end
    end
  end
end;Fi[	I".data//rspec_proj/spec/matchers/matcher.rb;TiI"]      
      def function(arglist)
        to_sentence(@var)
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/matchers/pretty.rb;Ti(I"F          end
        end
        var
      end
    end
  end
end;Fi[	I"7data//rspec_proj/spec/matchers/wrap_expectation.rb;Ti8I"}      rescue Exception => var
        var.failure_message = var.message
        return false
      end
    end
  end
end;Fi[	I"5data//rspec_proj/spec/mocks/argument_matchers.rb;TiÁI"û        var = (var.last.class == Hash) ? (var.delete_at(-1)) : ({})
        var.each { |arglist| var[var] = anything }
        var
      end
    end
  end
end;Fi[	I"3data//rspec_proj/spec/mocks/error_generator.rb;Ti?I"∫              "<#{@target.inspect} (class)>"
            else
              @var ? (@var) : ("nil")
            end
          end
        end
      end
      
      def function(arglist);Fi[	@”i`I"Ñ        return "once" if (var == 1)
        return "twice" if (var == 2)
        return "#{count} times"
      end
    end
  end
end;Fi[	I"3data//rspec_proj/spec/mocks/example_methods.rb;Ti?I"≠      # prevent false-positives and to catch potential bugs early on.
      def function(arglist)
        Proxy.allow_message_expectations_on_nil
      end
    end
  end
end;Fi[	I"7data//rspec_proj/spec/mocks/message_expectation.rb;TiFI"`      
      def function(arglist)
        return (@var == var)
      end
    end
  end
end;Fi[	I"+data//rspec_proj/spec/mocks/methods.rb;Ti`I"Ü          @var ||= Proxy.new(self, @var, @var)
        else
          @var ||= Proxy.new(self)
        end
      end
    end
  end
end;Fi[	@ﬁiaI"\        else
          @var ||= Proxy.new(self)
        end
      end
    end
  end
end;Fi[	I"(data//rspec_proj/spec/mocks/mock.rb;TiBI"}      
      def function(arglist)
        var.each_pair { |arglist| stub!(var).and_return(var) }
      end
    end
  end
end;Fi[	I"/data//rspec_proj/spec/mocks/order_group.rb;TiI"ù        return unless @var.include?(var)
        return consume if ready_for?(var)
        @var.raise_out_of_order_error(var.sym)
      end
    end
  end
end;Fi[	I")data//rspec_proj/spec/mocks/proxy.rb;Ti|I"Ë                  @var.superclass.send(var, *var, &var)
                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end;Fi[	@Èi}I"∑                else
                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      ;Fi[	@Èi~I"æ                  @var.__send__(:method_missing, var, *var, &var)
                end
              end
            end
          end
        end
      end
      
      def function(arglist);Fi[	@ÈiªI"ò              "protected"
            else
              "public"
            end
          end
        end
      end
      
      def function(arglist);Fi[	@Èi˚I"Ü      
      def function(arglist)
        @var.find { |arglist| var.matches_name_but_not_args(var, var) }
      end
    end
  end
end;Fi[	I")data//rspec_proj/spec/mocks/space.rb;TiI"W      
      def function(arglist)
        @var ||= []
      end
    end
  end
end;Fi[	I"+data//rspec_proj/spec/rake/spectask.rb;Ti|I"0              unless system(var) then
                STDERR.puts(failure_message) if failure_message
                raise("Command #{cmd} failed") if fail_on_error
              end
            end
          end
        end
        if rcov then
          desc("Remove rcov products for #{actual_name}");Fi[	@˜i§I"Ø          var = (var + spec_files.to_a) if spec_files
          var = (var + FileList[pattern].to_a) if pattern
          FileList[var]
        end
      end
    end
  end
end;Fi[	@˜i•I"~          var = (var + FileList[pattern].to_a) if pattern
          FileList[var]
        end
      end
    end
  end
end;Fi[	I".data//rspec_proj/spec/rake/verify_rcov.rb;Ti4I"ˇ        end
        if (var > threshold) and require_exact_threshold then
          raise("Coverage has increased above the threshold of #{threshold}% to #{total_coverage}%. You should update your threshold value.")
        end
      end
    end
  end
end;Fi[	@˛i5I"Û        if (var > threshold) and require_exact_threshold then
          raise("Coverage has increased above the threshold of #{threshold}% to #{total_coverage}%. You should update your threshold value.")
        end
      end
    end
  end
end;Fi[	I""data//rspec_proj/spec/ruby.rb;Ti
I"c    class << self
      def function(arglist)
        RUBY_VERSION
      end
    end
  end
end;Fi[	I"6data//rspec_proj/spec/runner/backtrace_tweaker.rb;Ti>I"d      
      def function(arglist)
        (IGNORE_PATTERNS + @var)
      end
    end
  end
end;Fi[	I"?data//rspec_proj/spec/runner/class_and_arguments_parser.rb;TiI"|          [$1, var]
        else
          raise("Couldn't parse #{s.inspect}")
        end
      end
    end
  end
end;Fi[	@	iI"h        else
          raise("Couldn't parse #{s.inspect}")
        end
      end
    end
  end
end;Fi[	I"1data//rspec_proj/spec/runner/command_line.rb;TiI"w          var.run_examples)
        ensure
          Spec::Runner.use(var)
        end
      end
    end
  end
end;Fi[	@iI"[        ensure
          Spec::Runner.use(var)
        end
      end
    end
  end
end;Fi[	I"2data//rspec_proj/spec/runner/configuration.rb;Ti I"]      
      def function(arglist)
        (var[0] or :each)
      end
    end
  end
end;Fi[	I"4data//rspec_proj/spec/runner/differs/default.rb;TiOI"          
          def function(arglist)
            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	@iPI"y          def function(arglist)
            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	@iQI"Y            @var.context_lines
          end
        end
      end
    end
  end
end;Fi[	I"5data//rspec_proj/spec/runner/drb_command_line.rb;TiI"ê        rescue DRb::DRbConnError
          var.error_stream.puts("No server is running")
          false
        end
      end
    end
  end
end;Fi[	@iI"t          var.error_stream.puts("No server is running")
          false
        end
      end
    end
  end
end;Fi[	I"9data//rspec_proj/spec/runner/example_group_runner.rb;Ti3I"c      
      def function(arglist)
        @var.number_of_examples
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/runner/formatter/base_formatter.rb;TiëI"À        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@%iíI"a        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/base_text_formatter.rb;TiçI"é        def function(arglist)
          Spec.deprecate("BaseTextFormatter#magenta")
          red(var)
        end
      end
    end
  end
end;Fi[	@*iéI"u          Spec.deprecate("BaseTextFormatter#magenta")
          red(var)
        end
      end
    end
  end
end;Fi[	I"Odata//rspec_proj/spec/runner/formatter/failing_example_groups_formatter.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@/iI"a        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Idata//rspec_proj/spec/runner/formatter/failing_examples_formatter.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@4iI"a        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"=data//rspec_proj/spec/runner/formatter/html_formatter.rb;TiõI"Ÿ	        
        def function(arglist)
          "#rspec-header {\n  background: #65C400; color: #fff; height: 4em;\n}\n\n.rspec-report h1 {\n  margin: 0px 10px 0px 10px;\n  padding: 10px;\n  font-family: \"Lucida Grande\", Helvetica, sans-serif;\n  font-size: 1.8em;\n  position: absolute;\n}\n\n#summary {\n  margin: 0; padding: 5px 10px;\n  font-family: \"Lucida Grande\", Helvetica, sans-serif;\n  text-align: right;\n  top: 0px;\n  right: 0px;\n  float:right;\n}\n\n#summary p {\n  margin: 0 0 0 2px;\n}\n\n#summary #totals {\n  font-size: 1.2em;\n}\n\n.example_group {\n  margin: 0 10px 5px;\n  background: #fff;\n}\n\ndl {\n  margin: 0; padding: 0 0 5px;\n  font: normal 11px \"Lucida Grande\", Helvetica, sans-serif;\n}\n\ndt {\n  padding: 3px;\n  background: #65C400;\n  color: #fff;\n  font-weight: bold;\n}\n\ndd {\n  margin: 5px 0 5px 5px;\n  padding: 3px 3px 3px 18px;\n}\n\ndd.spec.passed {\n  border-left: 5px solid #65C400;\n  border-bottom: 1px solid #65C400;\n  background: #DBFFB4; color: #3D7700;\n}\n\ndd.spec.failed {\n  border-left: 5px solid #C20000;\n  border-bottom: 1px solid #C20000;\n  color: #C20000; background: #FFFBD3;\n}\n\ndd.spec.not_implemented {\n  border-left: 5px solid #FAF834;\n  border-bottom: 1px solid #FAF834;\n  background: #FCFB98; color: #131313;\n}\n\ndd.spec.pending_fixed {\n  border-left: 5px solid #0000C2;\n  border-bottom: 1px solid #0000C2;\n  color: #0000C2; background: #D3FBFF;\n}\n\n.backtrace {\n  color: #000;\n  font-size: 12px;\n}\n\na {\n  color: #BE5C00;\n}\n\n/* Ruby code, style similar to vibrant ink */\n.ruby {\n  font-size: 12px;\n  font-family: monospace;\n  color: white;\n  background-color: black;\n  padding: 0.1em 0 0.2em 0;\n}\n\n.ruby .keyword { color: #FF6600; }\n.ruby .constant { color: #339999; }\n.ruby .attribute { color: white; }\n.ruby .global { color: white; }\n.ruby .module { color: white; }\n.ruby .class { color: white; }\n.ruby .string { color: #66FF00; }\n.ruby .ident { color: white; }\n.ruby .method { color: #FFCC00; }\n.ruby .number { color: white; }\n.ruby .char { color: white; }\n.ruby .comment { color: #9933CC; }\n.ruby .symbol { color: white; }\n.ruby .regex { color: #44B4CC; }\n.ruby .punct { color: white; }\n.ruby .escape { color: white; }\n.ruby .interp { color: white; }\n.ruby .expr { color: white; }\n\n.ruby .offending { background-color: gray; }\n.ruby .linenum {\n  width: 75px;\n  padding: 0.1em 1em 0.2em 0;\n  color: #000000;\n  background-color: #FFFBD3;\n}\n"
        end
      end
    end
  end
end;Fi[	@9iúI"–	        def function(arglist)
          "#rspec-header {\n  background: #65C400; color: #fff; height: 4em;\n}\n\n.rspec-report h1 {\n  margin: 0px 10px 0px 10px;\n  padding: 10px;\n  font-family: \"Lucida Grande\", Helvetica, sans-serif;\n  font-size: 1.8em;\n  position: absolute;\n}\n\n#summary {\n  margin: 0; padding: 5px 10px;\n  font-family: \"Lucida Grande\", Helvetica, sans-serif;\n  text-align: right;\n  top: 0px;\n  right: 0px;\n  float:right;\n}\n\n#summary p {\n  margin: 0 0 0 2px;\n}\n\n#summary #totals {\n  font-size: 1.2em;\n}\n\n.example_group {\n  margin: 0 10px 5px;\n  background: #fff;\n}\n\ndl {\n  margin: 0; padding: 0 0 5px;\n  font: normal 11px \"Lucida Grande\", Helvetica, sans-serif;\n}\n\ndt {\n  padding: 3px;\n  background: #65C400;\n  color: #fff;\n  font-weight: bold;\n}\n\ndd {\n  margin: 5px 0 5px 5px;\n  padding: 3px 3px 3px 18px;\n}\n\ndd.spec.passed {\n  border-left: 5px solid #65C400;\n  border-bottom: 1px solid #65C400;\n  background: #DBFFB4; color: #3D7700;\n}\n\ndd.spec.failed {\n  border-left: 5px solid #C20000;\n  border-bottom: 1px solid #C20000;\n  color: #C20000; background: #FFFBD3;\n}\n\ndd.spec.not_implemented {\n  border-left: 5px solid #FAF834;\n  border-bottom: 1px solid #FAF834;\n  background: #FCFB98; color: #131313;\n}\n\ndd.spec.pending_fixed {\n  border-left: 5px solid #0000C2;\n  border-bottom: 1px solid #0000C2;\n  color: #0000C2; background: #D3FBFF;\n}\n\n.backtrace {\n  color: #000;\n  font-size: 12px;\n}\n\na {\n  color: #BE5C00;\n}\n\n/* Ruby code, style similar to vibrant ink */\n.ruby {\n  font-size: 12px;\n  font-family: monospace;\n  color: white;\n  background-color: black;\n  padding: 0.1em 0 0.2em 0;\n}\n\n.ruby .keyword { color: #FF6600; }\n.ruby .constant { color: #339999; }\n.ruby .attribute { color: white; }\n.ruby .global { color: white; }\n.ruby .module { color: white; }\n.ruby .class { color: white; }\n.ruby .string { color: #66FF00; }\n.ruby .ident { color: white; }\n.ruby .method { color: #FFCC00; }\n.ruby .number { color: white; }\n.ruby .char { color: white; }\n.ruby .comment { color: #9933CC; }\n.ruby .symbol { color: white; }\n.ruby .regex { color: #44B4CC; }\n.ruby .punct { color: white; }\n.ruby .escape { color: white; }\n.ruby .interp { color: white; }\n.ruby .expr { color: white; }\n\n.ruby .offending { background-color: gray; }\n.ruby .linenum {\n  width: 75px;\n  padding: 0.1em 1em 0.2em 0;\n  color: #000000;\n  background-color: #FFFBD3;\n}\n"
        end
      end
    end
  end
end;Fi[	I"Ddata//rspec_proj/spec/runner/formatter/nested_text_formatter.rb;Ti.I"t        
        def function(arglist)
          (INDENT * @var.length)
        end
      end
    end
  end
end;Fi[	@>i/I"k        def function(arglist)
          (INDENT * @var.length)
        end
      end
    end
  end
end;Fi[	I"Cdata//rspec_proj/spec/runner/formatter/no_op_method_missing.rb;TiI"j        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@CiI"a        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/profile_formatter.rb;Ti%I"~            @var.puts(" #{description} #{example}")
          end
          @var.flush
        end
      end
    end
  end
end;Fi[	@Hi&I"O          end
          @var.flush
        end
      end
    end
  end
end;Fi[	I"Edata//rspec_proj/spec/runner/formatter/progress_bar_formatter.rb;Ti I"s        def function(arglist)
          @var.puts
          @var.flush
        end
      end
    end
  end
end;Fi[	@Mi!I"U          @var.puts
          @var.flush
        end
      end
    end
  end
end;Fi[	I"?data//rspec_proj/spec/runner/formatter/silent_formatter.rb;Ti
I"q  module Runner
    module Formatter
      class SilentFormatter < BaseFormatter
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/snippet_extractor.rb;Ti?I"l            (var << var)
          end
          var.join("\n")
        end
      end
    end
  end
end;Fi[	@Ui@I"S          end
          var.join("\n")
        end
      end
    end
  end
end;Fi[	I"@data//rspec_proj/spec/runner/formatter/specdoc_formatter.rb;Ti I"û          super
          output.puts(yellow("- #{example.description} (PENDING: #{message})"))
          output.flush
        end
      end
    end
  end
end;Fi[	@Zi!I"é          output.puts(yellow("- #{example.description} (PENDING: #{message})"))
          output.flush
        end
      end
    end
  end
end;Fi[	I"Bdata//rspec_proj/spec/runner/formatter/text_mate_formatter.rb;TiI"Ì        def function(arglist)
          var.gsub(/([^:]*\.rb):(\d*)/) do |arglist|
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          end
        end
      end
    end
  end
end;Fi[	@_iI"œ          var.gsub(/([^:]*\.rb):(\d*)/) do |arglist|
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          end
        end
      end
    end
  end
end;Fi[	@_iI"ö            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          end
        end
      end
    end
  end
end;Fi[	I"2data//rspec_proj/spec/runner/heckle_runner.rb;TiEI"o        
        def function(arglist)
          @var.run_examples
        end
      end
    end
  end
end;Fi[	@fiFI"f        def function(arglist)
          @var.run_examples
        end
      end
    end
  end
end;Fi[	I">data//rspec_proj/spec/runner/heckle_runner_unsupported.rb;Ti
I"é    class HeckleRunner
      def function(arglist)
        raise("Heckle is not supported on Windows or Ruby 1.9")
      end
    end
  end
end;Fi[	I"6data//rspec_proj/spec/runner/line_number_query.rb;TiKI"{      def function(arglist)
        var =~ /(.*)\:(\d*)(\:|$)/
        return [$1, Integer($2)]
      end
    end
  end
end;Fi[	I",data//rspec_proj/spec/runner/options.rb;TieI"]      
      def function(arglist)
        (@var == $stderr)
      end
    end
  end
end;Fi[	I"-data//rspec_proj/spec/runner/reporter.rb;TiôI"u      
      def function(arglist)
        (var.method(:example_pending).arity == 3)
      end
    end
  end
end;Fi[	I"&data//SiriProxy_proj/siriproxy.rb;TiI"…          raise("Cannot start the server on port #{$APP_CONFIG.port} - are you root, or have another process on this port already?")
        else
          raise
        end
      end
    end
  end
end;Fi[	@wiI"I        else
          raise
        end
      end
    end
  end
end;Fi[	I"9data//state_machine_proj/state_machine/assertions.rb;Ti'I"¨      var = var.&(var.keys)
      unless (var.length <= 1) then
        raise(ArgumentError, "Conflicting keys: #{conflicting_keys.join(", ")}")
      end
    end
  end
end;Fi[	I";data//state_machine_proj/state_machine/eval_helpers.rb;TiNI"        eval(var, var.instance_eval { |arglist| binding }, &var)
      else
        raise(ArgumentError, "Methods must be a symbol denoting the method to call, a block to be invoked, or a string to be evaluated")
      end
    end
  end
end;Fi[	I"4data//state_machine_proj/state_machine/event.rb;Ti‰I"÷      end
      machine.define_helper(:instance, "#{qualified_name}!") do |arglist|
        (var.send(qualified_name, *var) or raise(StateMachine::InvalidTransition.new(var, var, name)))
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/active_model/observer.rb;TiI"∫        def function(arglist)
          var = var.method
          send(var, *var.args) if respond_to?(var)
        end
      end
    end
  end
end
if defined? ActiveModel::Observer then;Fi[	@ÖiI"Ã          var = var.method
          send(var, *var.args) if respond_to?(var)
        end
      end
    end
  end
end
if defined? ActiveModel::Observer then
  ActiveModel::Observer.class_eval do |arglist|;Fi[	I"Xdata//state_machine_proj/state_machine/integrations/active_model/observer_update.rb;Ti%I"ñ        # get access to the enabled / disabled observers.
        def function(arglist)
          object.class
        end
      end
    end
  end
end;Fi[	@äi&I"a        def function(arglist)
          object.class
        end
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/active_model/versions.rb;TiI"™        def function(arglist)
          owner_class.set_callback(:validation, :after, "value", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	@èiI"å          owner_class.set_callback(:validation, :after, "value", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	I"Hdata//state_machine_proj/state_machine/integrations/active_model.rb;TiÂI"÷        var.class.changed if var.class.respond_to?(:changed)
        var.class.notify_observers("update_with_transition", ObserverUpdate.new("#{type}_transition", var, var))
        true
      end
    end
  end
end;Fi[	I"Rdata//state_machine_proj/state_machine/integrations/active_record/versions.rb;TiCI"O          unless (::ActiveRecord::Observer < StateMachine::Integrations::ActiveModel::Observer) then
            ::ActiveRecord::Observer.class_eval do |arglist|
              include(StateMachine::Integrations::ActiveModel::Observer)
            end
          end
        end
      end
      
      version("2.0 - 2.2.x") do |arglist|;Fi[	@óilI"ñ            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	@óimI"J          end
          super
        end
      end
    end
  end
end;Fi[	I"Idata//state_machine_proj/state_machine/integrations/active_record.rb;TimI"ª      # the existence of query attribute methods.
      def function(arglist)
        (var == :instance) and (var == "#{attribute}?") ? (owner_class) : (super)
      end
    end
  end
end;Fi[	I"@data//state_machine_proj/state_machine/integrations/base.rb;Ti`I"}      
      def self.included(arglist)
        var.class_eval { |arglist| extend(ClassMethods) }
      end
    end
  end
end;Fi[	I"Pdata//state_machine_proj/state_machine/integrations/data_mapper/observer.rb;Ti¢I"º                var.state_machines.values
              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end;Fi[	@§i£I"ñ              end
              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end;Fi[	@§i§I"ø              var.each { |arglist| var.send(var, *var, &var) }
            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|;Fi[	@§i•I"º            end
          end
        end
      end
    end
  end
end
DataMapper::Observer::ClassMethods.class_eval do |arglist|
  include(StateMachine::Integrations::DataMapper::Observer);Fi[	I"Pdata//state_machine_proj/state_machine/integrations/data_mapper/versions.rb;Ti/I"          else
            ::Extlib::Inflection
          end).pluralize(var.to_s)
        end
      end
    end
  end
end;Fi[	@≠i0I"p            ::Extlib::Inflection
          end).pluralize(var.to_s)
        end
      end
    end
  end
end;Fi[	I"Gdata//state_machine_proj/state_machine/integrations/data_mapper.rb;TiáI"n      def function(arglist)
        var[:bind_to_object] = true
        super
      end
    end
  end
end;Fi[	I"Qdata//state_machine_proj/state_machine/integrations/mongo_mapper/versions.rb;TiTI"ñ            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	@µiUI"J          end
          super
        end
      end
    end
  end
end;Fi[	I"Hdata//state_machine_proj/state_machine/integrations/mongo_mapper.rb;TiTI"Æ      # Defines a new scope with the given name
      def function(arglist)
        lambda { |arglist| var.query.merge(var.query(var.call(var))) }
      end
    end
  end
end;Fi[	I"Ldata//state_machine_proj/state_machine/integrations/mongoid/versions.rb;Ti$I"ô            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[	@Ωi%I"H          end
          var
        end
      end
    end
  end
end;Fi[	I"Cdata//state_machine_proj/state_machine/integrations/mongoid.rb;TiTI"¶      # Defines a new scope with the given name
      def function(arglist)
        lambda { |arglist| var.criteria.where(var.call(var)) }
      end
    end
  end
end;Fi[	I"Kdata//state_machine_proj/state_machine/integrations/sequel/versions.rb;TiEI"|        end
        def function(arglist)
          "raise_hook_failure(:save)"
        end
      end
    end
  end
end;Fi[	@≈iFI"p        def function(arglist)
          "raise_hook_failure(:save)"
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/integrations/sequel.rb;Ti•I"ï        var[:bind_to_object] = true
        var[:terminator] = @var ||= lambda { |arglist| (var == false) }
        super
      end
    end
  end
end;Fi[	I"3data//state_machine_proj/state_machine/path.rb;Ti{I"∑      else
        machine.events.transitions_for(object, :from => (to_name), :guard => (@var)).select do |arglist|
          can_walk_to?(var)
        end
      end
    end
  end
end;Fi[	@Õi|I"¨        machine.events.transitions_for(object, :from => (to_name), :guard => (@var)).select do |arglist|
          can_walk_to?(var)
        end
      end
    end
  end
end;Fi[	I">data//state_machine_proj/state_machine/path_collection.rb;TiYI"¢      (self << var) if var.complete?
      unless to_name and (var.complete? and @var.!) then
        var.walk { |arglist| walk(var) }
      end
    end
  end
end;Fi[	I"4data//state_machine_proj/state_machine/state.rb;TiI"¶    def function(arglist)
      machine.define_helper(:instance, "#{qualified_name}?") do |arglist|
        var.states.matches?(var, name)
      end
    end
  end
end;Fi[	I"Ddata//state_machine_proj/state_machine/transition_collection.rb;Ti·I"ä      super
      each do |arglist|
        var.machine.write(object, :event, var.event) unless var.transient?
      end
    end
  end
end;Fi[	I"Adata//state_machine_proj/state_machine/yard/handlers/base.rb;TiI"è          else
            var = extract_node_name(var)
            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	@€i I"Ä            var = extract_node_name(var)
            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	@€i!I"\            var ? ([var]) : (var)
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/event.rb;TiI"‹            var.each do |arglist|
              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end;Fi[	@‚iI"¿              owner.event(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end;Fi[	@‚iI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@‚iI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	@‚iI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Ddata//state_machine_proj/state_machine/yard/handlers/machine.rb;Ti∆I"W            end
            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "#{state.qualified_name}?")))
            var.docstring = ["Checks whether #{state.name.inspect} is the current state.", "@return [Boolean] +true+ if this is the current state, otherwise +false+"]
          end
        end
      end
    end
  end
end;Fi[	@Ìi«I"G            register((var = ::YARD::CodeObjects::MethodObject.new(namespace, "#{state.qualified_name}?")))
            var.docstring = ["Checks whether #{state.name.inspect} is the current state.", "@return [Boolean] +true+ if this is the current state, otherwise +false+"]
          end
        end
      end
    end
  end
end;Fi[	@Ìi»I"‹            var.docstring = ["Checks whether #{state.name.inspect} is the current state.", "@return [Boolean] +true+ if this is the current state, otherwise +false+"]
          end
        end
      end
    end
  end
end;Fi[	I"Bdata//state_machine_proj/state_machine/yard/handlers/state.rb;TiI"‹            var.each do |arglist|
              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end;Fi[	@ÙiI"¿              owner.state(var) do |arglist|
                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end;Fi[	@ÙiI"ò                var.parse_block(var.last.last, :owner => (self))
              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÙiI"\              end
            end
          end
        end
      end
    end
  end
end;Fi[	@ÙiI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"Gdata//state_machine_proj/state_machine/yard/handlers/transition.rb;Ti+I"r            end
          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ˇi,I"b          else
            # do nothing
          end
        end
      end
    end
  end
end;Fi[	@ˇi-I"S            # do nothing
          end
        end
      end
    end
  end
end;Fi[	I"Vdata//state_machine_proj/state_machine/yard/templates/default/class/html/setup.rb;TiI"Ô    var.each do |arglist|
      if var[:image] then
        serializer.serialize(state_machine_image_path(var), var[:image])
      end
    end
  end
end
# Generates the image path for the given machine's visualization
def function(arglist);Fi[	I"2data//twitter_proj/twitter/action/favorite.rb;TiI"∑      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::Tweet.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I"0data//twitter_proj/twitter/action/follow.rb;TiI"µ      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I";data//twitter_proj/twitter/action/list_member_added.rb;Ti#I"µ      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/action/mention.rb;Ti*I"µ      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I"/data//twitter_proj/twitter/action/reply.rb;TiI"∑      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::Tweet.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/action/retweet.rb;TiI"µ      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	I"0data//twitter_proj/twitter/api/arguments.rb;TiI"É      def function(arglist)
        @var = var.last.is_a?(::Hash) ? (var.pop) : ({})
        super(var)
      end
    end
  end
end;Fi[	I"+data//twitter_proj/twitter/api/help.rb;Ti?I"Å      #   Twitter.tos
      def function(arglist)
        get("/1.1/help/tos.json", var)[:body][:tos]
      end
    end
  end
end;Fi[	I",data//twitter_proj/twitter/api/lists.rb;TiYI"¢        merge_user!(var, var, "owner")
        var[:owner_id] = var.delete(:owner_user_id) unless var[:owner_user_id].nil?
        var
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/api/places_and_geo.rb;TizI"Ø      # @return [Array]
      def function(arglist)
        objects_from_array(Twitter::Place, send(var.to_sym, var, var)[:body][:result][:places])
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/api/saved_searches.rb;Ti_I"˜        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "/1.1/saved_searches/destroy/#{id}.json", var.options)
        end
      end
    end
  end
end;Fi[	@'i`I"»        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "/1.1/saved_searches/destroy/#{id}.json", var.options)
        end
      end
    end
  end
end;Fi[	I"-data//twitter_proj/twitter/api/search.rb;Ti$I"…      #   Twitter.search('twitter')
      def function(arglist)
        object_from_response(Twitter::SearchResults, :get, "/1.1/search/tweets.json", var.merge(:q => (var)))
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/api/spam_reporting.rb;TiI"Õ      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        threaded_user_objects_from_response(:post, "/1.1/users/report_spam.json", var)
      end
    end
  end
end;Fi[	I"6data//twitter_proj/twitter/api/suggested_users.rb;Ti6I"Ã      #   Twitter.suggest_users("art-design")
      def function(arglist)
        objects_from_response(Twitter::User, :get, "/1.1/users/suggestions/#{slug}/members.json", var)
      end
    end
  end
end;Fi[	I"0data//twitter_proj/twitter/api/timelines.rb;Ti–I"s      # @return [Array]
      def function(arglist)
        var.select(&:retweet?)
      end
    end
  end
end;Fi[	I"-data//twitter_proj/twitter/api/trends.rb;TiAI"≠      #   Twitter.trends_closest
      def function(arglist)
        objects_from_response(Twitter::Place, :get, "/1.1/trends/closest.json", var)
      end
    end
  end
end;Fi[	I"-data//twitter_proj/twitter/api/tweets.rb;TiI"≤        var[:body] = var[:body].delete(:retweeted_status)
        var[:body][:retweeted_status] = var[:body]
        Twitter::Tweet.from_response(var)
      end
    end
  end
end;Fi[	I"3data//twitter_proj/twitter/api/undocumented.rb;TipI"∑      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map { |arglist| status_activity(var, var.options) }
      end
    end
  end
end;Fi[	I",data//twitter_proj/twitter/api/users.rb;Ti∂I"Œ          merge_user!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::ProfileBanner, :get, "/1.1/users/profile_banner.json", var.options)
      end
    end
  end
end;Fi[	I",data//twitter_proj/twitter/api/utils.rb;Ti∂I"õ        var[:user_id] = var.join(",") unless var.empty?
        var[:screen_name] = var.join(",") unless var.empty?
        var
      end
    end
  end
end;Fi[	I"/data//twitter_proj/twitter/configurable.rb;TiGI"Ò        next if var.nil?
        unless (var.is_a?(String) or var.is_a?(Symbol)) then
          raise(Error::ConfigurationError, "Invalid #{credential} specified: #{value} must be a string or symbol.")
        end
      end
    end
  end
end;Fi[	@GiHI"ÿ        unless (var.is_a?(String) or var.is_a?(Symbol)) then
          raise(Error::ConfigurationError, "Invalid #{credential} specified: #{value} must be a string or symbol.")
        end
      end
    end
  end
end;Fi[	I"0data//twitter_proj/twitter/configuration.rb;TiI"õ      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	I"2data//twitter_proj/twitter/core_ext/kernel.rb;TiI"[    def function(arglist)
      class << self
        self
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/error/client_error.rb;TiI"◊            if var[:errors] then
              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end;Fi[	@RiI"∫              var = Array(var[:errors]).first
              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	@RiI"å              var.kind_of?(Hash) ? (var[:message].chomp) : (var.chomp)
            end
          end
        end
      end
    end
  end
end;Fi[	@RiI"J            end
          end
        end
      end
    end
  end
end;Fi[	I"5data//twitter_proj/twitter/error/server_error.rb;TiI"°      # @return [Twitter::Error::ServerError]
      def function(arglist)
        super((var or self.class.const_get(:MESSAGE)), var)
      end
    end
  end
end;Fi[	I"*data//twitter_proj/twitter/factory.rb;TiI"ú        var.const_get(var.to_sym).fetch_or_new(var)
      else
        raise(ArgumentError, "argument must have :#{method} key")
      end
    end
  end
end;Fi[	I".data//twitter_proj/twitter/media/photo.rb;TiI"ß        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	@aiI"o          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	I"1data//twitter_proj/twitter/profile_banner.rb;TiI"ï      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	I">data//twitter_proj/twitter/request/multipart_with_file.rb;Ti"I"t          "image/png"
        else
          "application/octet-stream"
        end
      end
    end
  end
end;Fi[	@ii#I"^        else
          "application/octet-stream"
        end
      end
    end
  end
end;Fi[	I"6data//twitter_proj/twitter/response/parse_json.rb;TiI"∆        if respond_to?(:parse) then
          unless [204, 301, 302, 304].include?(var[:status]) then
            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	@niI"¢          unless [204, 301, 302, 304].include?(var[:status]) then
            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	@niI"e            var[:body] = parse(var[:body])
          end
        end
      end
    end
  end
end;Fi[	I"7data//twitter_proj/twitter/response/raise_error.rb;TiI"b      def function(arglist)
        @var = var
        super(var)
      end
    end
  end
end;Fi[	I"*data//twitter_proj/twitter/version.rb;TiI"Ö      # @return [String]
      def function(arglist)
        [MAJOR, MINOR, PATCH, PRE].compact.join(".")
      end
    end
  end
end;Fi[	I"7data//whenever_proj/whenever/capistrano/recipes.rb;Ti,I"Ë      if whenever_servers.any? then
        var = { :command => (fetch(:whenever_command)), :flags => (fetch(:whenever_clear_flags)), :path => (fetch(:latest_release)) }
        whenever_run_commands(var)
      end
    end
  end
end;Fi[	I"7data//whenever_proj/whenever/capistrano/support.rb;Ti I"            var = var.empty? ? ("") : (" --roles #{roles.join(",")}")
            var = "cd #{args[:path]} && #{args[:command]} #{args[:flags]}#{roles_arg}"
            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[	@~i!I"             var = "cd #{args[:path]} && #{args[:command]} #{args[:flags]}#{roles_arg}"
            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[	@~i"I"x            run(var, whenever_options.merge(:hosts => (var)))
          end
        end
      end
    end
  end
end;Fi[	I")data//whenever_proj/whenever/cron.rb;TiïI"à        var = (var.to_f / var.to_f).round
        var = (var + 1) if var.zero?
        var[0, var].join(",")
      end
    end
  end
end;Fi[	I"-data//whenever_proj/whenever/job_list.rb;TiiI"œ              var[var][var] += ("," + var[var][var])
              var.delete_at(var)
              break
            end
          end
        end
      end
      var.map { |arglist| var.join(" ") }
    end;Fi[	I"7data//whenever_proj/whenever/output_redirection.rb;Ti=I"`      
      def function(arglist)
        ">> #{@output} 2>&1"
      end
    end
  end
end;Fi[@'@(I" ;FI"def function(arglist);FiË[Ë[	@KiJI"Ò            else
              self.class::Attribute.new(var, @var, var)
            end
          end
        end
        
        def function(arglist)
          require("builder") unless defined? ::Builder
          options[:indent] ||= 2;Fi[	@KimI"á          serializable_collection.each do |arglist|
            var = ActiveSupport::XmlMini.rename_key(var.name, options)
            ActiveSupport::XmlMini.to_tag(var, var.value, options.merge(var.decorations))
          end
        end
        
        def function(arglist)
          @var.send(:serializable_add_includes, options) do |arglist|
            add_associations(var, var, var);Fi[	@KiëI"-            var[:root] = var.to_s
            var[:type] = var.class.name unless (var.class.to_s.underscore == var.to_s)
            var.to_xml(var)
          end
        end
        
        def function(arglist)
          if var = options.delete(:procs) then
            Array(var).each do |arglist|;Fi[	@SiI"i      def function(arglist)
        unless (var == options[:accept]) then
          var.errors.add(var, :accepted, options.except(:accept, :allow_nil))
        end
      end
      
      def function(arglist)
        var = attributes.reject { |arglist| var.attribute_method?(var) }
        var = attributes.reject { |arglist| var.attribute_method?("#{name}=") };Fi[	@\iI"Æ        if var = var.send("#{attribute}_confirmation") and var.!=(var) then
          var = var.class.human_attribute_name(var)
          var.errors.add(:"#{var}_confirmation", :confirmation, options.merge(:attribute => (var)))
        end
      end
      
      def function(arglist)
        var.send(:attr_accessor, *attributes.map do |arglist|
          :"#{var}_confirmation" unless var.method_defined?(:"#{var}_confirmation");Fi[	@biI"^            var = option_call(var, :without)
            record_error(var, var, :without, var) if var.to_s.=~(var)
          end
        end
      end
      
      def function(arglist)
        unless options.include?(:with).^(options.include?(:without)) then
          raise(ArgumentError, "Either :with or :without must be supplied (but not both)");Fi[	I">data//activemodel_proj/active_model/validations/length.rb;Ti%I"Z          unless ((var.is_a?(Integer) and (var >= 0)) or (var == Float::INFINITY)) then
            raise(ArgumentError, ":#{key} must be a nonnegative Integer or Infinity")
          end
        end
      end
      
      def function(arglist)
        var = tokenize(var)
        var = var.respond_to?(:length) ? (var.length) : (var.to_s.length);Fi[	@jiI"f        options.slice(*var).each do |arglist|
          next if (var.is_a?(Numeric) or (var.is_a?(Proc) or var.is_a?(Symbol)))
          raise(ArgumentError, ":#{option} must be a number, a symbol or a proc")
        end
      end
      
      def function(arglist)
        var = :"#{var}_before_type_cast"
        var = var.send(var) if var.respond_to?(var);Fi[	@ji?I"π          rescue ArgumentError, TypeError
            nil
          end
        end
      end
      
      def function(arglist)
        var.to_i if var.to_s =~ /\A[+-]?\d+\Z/
      end;Fi[	I"+data//activemodel_proj/active_model.rb;Ti7I"•    eager_autoload do |arglist|
      autoload(:JSON)
      autoload(:Xml)
    end
  end
  
  def function(arglist)
    super
    ActiveModel::Serializer.eager_load!;Fi[	@xiTI"≈            @var[var] = var
          end
          @var[var]
        end
      end
      
      def function(arglist)
        define_method("#{name}=") do |arglist|
          var = var.constantize;Fi[	@}iI"‰          target)
        rescue ActiveRecord::RecordNotFound
          reset
        end
      end
      
      def function(arglist)
        var.respond_to?(:to_proc) ? (owner.send(:instance_exec, var, &var)) : (var)
      end;Fi[	@Öi0I"          owner[reflection.foreign_key]
        else
          var.id.!=(owner[reflection.foreign_key])
        end
      end
      
      def function(arglist)
        if var then
          owner[reflection.foreign_key] = var[reflection.association_primary_key(var.class)];Fi[	@Öi8I"           owner[reflection.foreign_key] = var[reflection.association_primary_key(var.class)]
        else
          owner[reflection.foreign_key] = nil
        end
      end
      
      def function(arglist)
        owner[reflection.foreign_key]
      end;Fi[	@ÖiKI"Û          owner.send(reflection.name).try(:id)
        else
          owner[reflection.foreign_key]
        end
      end
      
      def function(arglist)
        owner[reflection.foreign_key] and owner[reflection.foreign_key].to_s
      end;Fi[	I"Ndata//activerecord_proj/active_record/associations/builder/association.rb;Ti#I"œ      if @var and (@var.arity == 0) then
        var = @var
        @var = proc { |arglist| instance_exec(&var) }
      end
    end
    
    def function(arglist)
      @var.generated_feature_methods
    end;Fi[	I"Ydata//activerecord_proj/active_record/associations/builder/collection_association.rb;Ti&I"A        if options.include?(var) then
          ActiveSupport::Deprecation.warn("The :#{name} association option is deprecated. Please find an alternative (such as using scopes).")
        end
      end
    end
    
    def function(arglist)
      if block_extension then
        @var = var = Module.new(&block_extension);Fi[	@µi5I"◊        else
          @var = proc { |arglist| extending(var) }
        end
      end
    end
    
    def function(arglist)
      @var ||= "#{model.name.demodulize}#{name.to_s.camelize}AssociationExtension"
    end;Fi[	I"Zdata//activerecord_proj/active_record/associations/builder/has_and_belongs_to_many.rb;TiI"E        if options.include?(var) then
          ActiveSupport::Deprecation.warn("The :#{name} association option is deprecated. Please find an alternative (such as using has_many :through).")
        end
      end
    end
    
    def function(arglist)
      var = self.name
      model.send(:include, Module.new do |arglist|;Fi[	@ãi.I"Ù          load_target.select.each { |arglist| yield(var) }
        else
          scope.select(var)
        end
      end
      
      def function(arglist)
        if block_given? then
          load_target.find(*var) { |arglist| yield(*var) };Fi[	@ãi6I"˘          load_target.find(*var) { |arglist| yield(*var) }
        else
          options[:finder_sql] ? (find_by_scan(*var)) : (scope.find(*var))
        end
      end
      
      def function(arglist)
        first_or_last(:first, *var)
      end;Fi[	@ãiFI"˘          var.collect { |arglist| build(var, &var) }
        else
          add_to_target(build_record(var)) { |arglist| yield(var) if block_given? }
        end
      end
      
      def function(arglist)
        create_record(var, &var)
      end;Fi[	@ãi¸I"ı          replace_records(var, var)
        else
          transaction { |arglist| replace_records(var, var) }
        end
      end
      
      def function(arglist)
        if var.is_a?(reflection.klass) then
          if var.new_record? then;Fi[	@ãi	I"∫          end
        else
          false
        end
      end
      
      def function(arglist)
        @var = merge_target_lists(find_target, target) if find_target?
        loaded!;Fi[	@ãi4I"ı            var = "*" if (var.blank? or (var =~ /,/ or var =~ /\.\*/))
            "SELECT #{$1}COUNT(#{count_with}) FROM"
          end
        end
      end
      
      def function(arglist)
        interpolate(options[:finder_sql])
      end;Fi[	@ãiÄI"          remove_records(var, var, var)
        else
          transaction { |arglist| remove_records(var, var, var) }
        end
      end
      
      def function(arglist)
        var.each { |arglist| callback(:before_remove, var) }
        delete_records(var, var) if var.any?;Fi[	@ãiÆI"‡          else
            var.send(var, owner, var)
          end
        end
      end
      
      def function(arglist)
        var = "#{callback_name}_for_#{reflection.name}"
        (owner.class.send(var.to_sym) or []);Fi[	@ãi∆I"ï          true
        else
          (loaded? or (owner.new_record? or (options[:finder_sql] or (target.any? { |arglist| (var.new_record? or var.changed?) } or var.first.kind_of?(Integer))))).!
        end
      end
      
      def function(arglist)
        if reflection.is_a?(ActiveRecord::Reflection::ThroughReflection) then
          (owner.send(reflection.through_reflection.name).any? do |arglist|;Fi[	@ói1I"            var = var.and(var[reflection.association_foreign_key].in(var.map { |arglist| var.id }.compact))
          end
          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end;Fi[	@öiI"            load_target.each(&:mark_for_destruction)
          end
          delete_all)
        end
      end
      
      def function(arglist)
        set_owner_attributes(var)
        var ? (var.save!(:validate => (var))) : (var.save(:validate => (var)));Fi[	@öiqI"Ò          else
            update_counter(-var.update_all(reflection.foreign_key => (nil)))
          end
        end
      end
      
      def function(arglist)
        owner.attribute_present?(reflection.association_primary_key)
      end;Fi[	@ùiI"          owner.send(:read_attribute, cached_counter_attribute_name)
        else
          loaded? ? (target.size) : (count)
        end
      end
      
      def function(arglist)
        unless owner.new_record? then
          var.flatten.each do |arglist|;Fi[	@ùiPI"ﬂ          var = through_association.build
          var.send("#{source_reflection.name}=", var)
          var)
        end
      end
      
      def function(arglist)
        begin
          build_through_record(var).save!;Fi[	@ùiXI"…          build_through_record(var).save!
        ensure
          @var.delete(var.object_id)
        end
      end
      
      def function(arglist)
        ensure_not_nested
        var = super(var);Fi[	@ùiwI"©          false
        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested
        var = load_target if (var == :all);Fi[	@ùiûI"–            end
          end
          @var.delete(var.object_id)
        end
      end
      
      def function(arglist)
        return [] unless target_reflection_has_associated_record?
        scope.to_a;Fi[	@†iI"£          end
        else
          delete
        end
      end
      
      def function(arglist)
        raise_on_type_mismatch(var) if var
        load_target;Fi[	@†iRI"M            set_owner_attributes(target)
            raise(RecordNotSaved, ("Failed to remove the existing associated #{reflection.name}. " + "The record failed to save after its foreign key was set to nil."))
          end)
        end
      end
      
      def function(arglist)
        var[reflection.foreign_key] = nil
      end;Fi[	@ΩizI"ﬁ          end
        else
          raise(ConfigurationError, var.inspect)
        end
      end
      
      def function(arglist)
        var = var.to_sym if String.===(var)
        join_associations.detect do |arglist|;Fi[	@Ωi|I"5        var = var.to_sym if String.===(var)
        join_associations.detect do |arglist|
          (var.reflection == var) and (var.parent == var)
        end
      end
      
      def function(arglist)
        if var and var.collection? then
          var.each { |arglist| var.send(var.name).target.uniq! };Fi[	@ΩiÇI"Û      def function(arglist)
        if var and var.collection? then
          var.each { |arglist| var.send(var.name).target.uniq! }
        end
      end
      
      def function(arglist)
        JoinAssociation.new(var, self, var)
      end;Fi[	@ΩiúI"Ë          end
        else
          raise(ConfigurationError, var.inspect)
        end
      end
      
      def function(arglist)
        return if var.id.to_s.!=(var.parent.record_id(var).to_s)
        var = var.reflection.macro;Fi[	@√i?I"ﬁ          @var ||= owners.group_by do |arglist|
            var = var[owner_key_name]
            (var and var.to_s)
          end
        end
        
        def function(arglist)
          reflection.options
        end;Fi[	@√i^I"Ó            klass.unscoped.instance_exec(nil, &reflection.scope)
          else
            klass.unscoped
          end
        end
        
        def function(arglist)
          var = klass.unscoped
          var.default_scoped = true;Fi[	@‘i,I"          var = {}
          super.each do |arglist|
            var.map! { |arglist| var[var[klass.primary_key]] ||= klass.instantiate(var) }
          end
        end
        
        def function(arglist)
          super.joins(join).select(join_select)
        end;Fi[	@˜iQI"          preload_one(var.to_sym)
        else
          raise(ArgumentError, "#{association.inspect} was not recognised for preload")
        end
      end
      
      def function(arglist)
        var.each do |arglist|
          Preloader.new(records, var, preload_scope).run;Fi[	@˜igI",          var.each do |arglist|
            preloader_for(var).new(var, var, var, preload_scope).run
          end
        end
      end
      
      def function(arglist)
        Hash[records_by_reflection(var).map do |arglist|
          [var, var.group_by { |arglist| association_klass(var, var) }];Fi[	@˜iwI"L            raise(ActiveRecord::ConfigurationError, "Association named '#{association}' was not found; perhaps you misspelled it?")
          end
          var
        end
      end
      
      def function(arglist)
        if (var.macro == :belongs_to) and var.options[:polymorphic] then
          var = var.send(var.foreign_type);Fi[	@˜i{I"∞          (var and var.constantize)
        else
          var.klass
        end
      end
      
      def function(arglist)
        case var.macro
        when :has_many then;Fi[	@ˇi6I"Z      def function(arglist)
        if (through_reflection.macro == :belongs_to) then
          owner[through_reflection.foreign_key] and owner[through_reflection.foreign_key].to_s
        end
      end
      
      def function(arglist)
        (through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].nil?.!
      end;Fi[	@ˇi@I"d      def function(arglist)
        if source_reflection.macro.!=(:belongs_to) then
          raise(HasManyThroughCantAssociateThroughHasOneOrManyReflection.new(owner, reflection))
        end
      end
      
      def function(arglist)
        if reflection.nested? then
          raise(HasManyThroughNestedAssociationsAreReadonly.new(owner, reflection));Fi[	@iOI"G      unless var.empty? then
        var = var.map { |arglist| var.message }.join(",")
        raise(MultiparameterAssignmentErrors.new(var), "#{errors.size} error(s) on assignment of multiparameter attributes [#{error_descriptions}]")
      end
    end
    
    def function(arglist)
      var = {}
      var.each do |arglist|;Fi[	@i{I"          Time.zone.local(*var)
        else
          Time.send(object.class.default_timezone, *var)
        end
      end
      
      def function(arglist)
        if (column.type == :time) then
          { 1 => 1970, 2 => 1, 3 => 1 }.each { |arglist| values[var] ||= var };Fi[	@iíI"‘          Date.new(*var)
        rescue ArgumentError
          instantiate_time_object(var).to_date
        end
      end
      
      def function(arglist)
        var = extract_max_param
        var = (1..var);Fi[	@i©I"      def function(arglist)
        if var = var.detect { |arglist| values.key?(var).! } then
          raise(ArgumentError.new("Missing Parameter - #{name}(#{missing_parameter})"))
        end
      end
      
      def function(arglist)
        [values.keys.max, var].min
      end;Fi[	@iNI"            self.primary_key = get_primary_key(base_class.name)
          else
            self.primary_key = base_class.primary_key
          end
        end
        
        def function(arglist)
          return "id" if var.blank?
          case primary_key_prefix_type;Fi[	@i*I"[            Coders::YAMLColumn.new(var)
          end
          self.serialized_attributes = serialized_attributes.merge(var.to_s => (var))
        end
      end
      
      def function(arglist)
        var = "Instance level serialized_attributes method is deprecated, please use class level method."
        ActiveSupport::Deprecation.warn(var);Fi[	@idI"*              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized);Fi[	@ilI"Û            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist)
          self.class.serialized_attributes.include?(var) ? (var.!=(var)) : (super)
        end;Fi[	@ixI"Ó            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist)
          super.dup.tap do |arglist|
            self.class.serialized_attributes.each_key do |arglist|;Fi[	@i{I"A            self.class.serialized_attributes.each_key do |arglist|
              var[var] = var[var].unserialized_value if var.key?(var)
            end
          end
        end
        
        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value;Fi[	I"?data//activerecord_proj/active_record/attribute_methods.rb;Ti#I"◊          superclass.define_attribute_methods unless (self == base_class)
          super(column_names)
          @var = true
        end
      end
      
      def function(arglist)
        @var ||= false
      end;Fi[	@i~I"r      else
        self.class.define_attribute_methods
        respond_to_without_attributes?(var) ? (send(var, *var, &var)) : (super)
      end
    end
    
    def function(arglist)
      if self.class.columns_hash[var.attr_name] then
        ActiveSupport::Deprecation.warn("The method `#{match.method_name}', matching the attribute `#{match.attr_name}' has dispatched through method_missing. This shouldn't happen, because `#{match.attr_name}' is a column of the table. If this error has happened through normal usage of Active Record (rather than through your own code or external libraries), please report it as a bug.");Fi[	@i/I"◊        var.duplicable? ? (var.clone) : (var))
      rescue TypeError, NoMethodError
        var
      end
    end
    
    def function(arglist)
      arel_attributes_with_values(attributes_for_create(var))
    end;Fi[	@iUI"Ï    def function(arglist)
      var.select do |arglist|
        column_for_attribute(var) and (pk_attribute?(var) and id.nil?).!
      end
    end
    
    def function(arglist)
      self.class.readonly_attributes.include?(var)
    end;Fi[	@(iÒI"”          @var.delete_if { |arglist| var.requires_reloading? }
          @var.clear
          @var.each { |arglist| @var.add(var) }
        end
      end
      
      def function(arglist)
        reap
      end;Fi[	@(iBI"˚          var
        else
          (@var.size < @var) ? (checkout_new_connection) : (@var.poll(@var))
        end
      end
      
      def function(arglist)
        var = if (@var[current_connection_id] == var) then
          current_connection_id;Fi[	@(ilI"Ë        end
        @var = ThreadSafe::Cache.new(:initial_capacity => 2) do |arglist|
          var[var] = ThreadSafe::Cache.new
        end
      end
      
      def function(arglist)
        owner_to_pool.values.compact
      end;Fi[	@(i‘I"ÿ          else
            owner_to_pool[var.name] = nil
          end
        end
      end
      
      def function(arglist)
        var = @var.values.find { |arglist| var[var.name] }
        var and var[var.name];Fi[	@0iŒI"∫          end)
        rescue ActiveRecord::Rollback
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (var = begin_transaction(var);Fi[	@>i'I"Ê              (var << var)
            end
          end
        end
      end
      
      def function(arglist)
        if var = native_database_types[var.to_sym] then
          var = (var.is_a?(Hash) ? (var[:name]) : (var)).dup;Fi[	@>i>I"€          var
        else
          var
        end
      end
      
      def function(arglist)
        if options_include_default?(var) then
          (var << " DEFAULT #{quote(options[:default], options[:column])}");Fi[	@CiFI"√          parent.begin
        else
          SavepointTransaction.new(connection, self, var)
        end
      end
      
      def function(arglist)
        @var = true
        perform_rollback;Fi[	@Ci`I"‚          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        records.uniq.each do |arglist|
          begin;Fi[	@CijI"√          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false
      end;Fi[	@Ci}I"È          var.begin_isolated_db_transaction(var[:isolation])
        else
          var.begin_db_transaction
        end
      end
      
      def function(arglist)
        connection.rollback_db_transaction
        rollback_records;Fi[	@FiXI"´            @var = true
            @var = Time.now
          end
        end
      end
      
      def function(arglist)
        var.connection = self
        @var = var;Fi[	@Fi&I"‡          var = translate_exception(var, var)
          var.set_backtrace(var.backtrace)
          raise(var)
        end
      end
      
      def function(arglist)
        ActiveRecord::StatementInvalid.new(var)
      end;Fi[	@IiI"È            end
          else
            missing_default_forged_as_empty_string?(var) ? (nil) : (super)
          end
        end
        
        def function(arglist)
          return false if blob_or_text_column?
          super;Fi[	@Ii?I"©            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var
          when /blob|text/i then;Fi[	@Ii√I"Ÿ          "x'#{s}'"
        else
          var.kind_of?(BigDecimal) ? (var.to_s("F")) : (super)
        end
      end
      
      def function(arglist)
        @var[var] ||= "`#{name.to_s.gsub("`", "``")}`"
      end;Fi[	@IiI"Ó          execute("BEGIN")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (execute("SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}");Fi[	@IiI"Ω          execute("ROLLBACK")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@Ii7I"™        else
          var.table(var.source)
          var.wheres = var.constraints
        end
      end
      
      def function(arglist)
        "VALUES ()"
      end;Fi[	@IiI"        (var << "LIKE #{quote(like)}") if var
        execute_and_free(var, "SCHEMA") do |arglist|
          var.collect { |arglist| var.first }
        end
      end
      
      def function(arglist)
        return false unless var
        return true if tables(nil, nil, var).any?;Fi[	@IißI"$          each_hash(var).map do |arglist|
            new_column(var[:Field], var[:Default], var[:Type], (var[:Null] == "YES"), var[:Collation])
          end
        end
      end
      
      def function(arglist)
        super(var, var.reverse_merge(:options => "ENGINE=InnoDB"))
      end;Fi[	@IiI"õ          end
        else
          super
        end
      end
      
      def function(arglist)
        if var[:first] then
          (var << " FIRST");Fi[	@IigI"'          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
        add_column_options!(var, var);Fi[	@Qi0I"          var.each(:as => :hash, :symbolize_keys => (true)) { |arglist| yield(var) }
        else
          to_enum(:each_hash, var)
        end
      end
      
      def function(arglist)
        Column.new(var, var, var, var, var, strict_mode?)
      end;Fi[	@QiwI"G              var = ([var] + var.rows.map { |arglist| var[var].nil? ? ("NULL") : (var[var].to_s) })
              (var << var.map(&:length).max)
            end
          end
        end
        
        def function(arglist)
          var = 1
          (("+" + var.map { |arglist| ("-" * (var + (var * 2))) }.join("+")) + "+");Fi[	@VixI"‡        
        def function(arglist)
          @var[Process.pid]
        end
      end
      
      def function(arglist)
        super
        @var = StatementPool.new(@var, var.fetch(:statement_limit) { |arglist| 1000 });Fi[	@ViåI"∫          end
        else
          to_enum(:each_hash, var)
        end
      end
      
      def function(arglist)
        Column.new(var, var, var, var, var, strict_mode?)
      end;Fi[	@Vi®I"»          @var.respond_to?(:errno) ? (@var.errno.zero?) : (true))
        rescue Mysql::Error
          false
        end
      end
      
      def function(arglist)
        super
        disconnect!;Fi[	@Vi\I"Ê          TYPES.key?(var)
        end.each do |arglist|
          register_type(var, Fields::Identity.new)
        end
      end
      
      def function(arglist)
        log(var, var) do |arglist|
          var = @var.query(var);Fi[	@VirI"«            var = ActiveRecord::Result.new([], [])
          end
          [var, var]
        end
      end
      
      def function(arglist)
        var = execute(var, var)
        var = yield(var);Fi[	@Vi∞I"Ï          var.free_result
          var.close if var.empty?
          [var, var]
        end
      end
      
      def function(arglist)
        var = @var[:encoding]
        @var.options(Mysql::SET_CHARSET_NAME, var) rescue nil if var;Fi[	@[iI"Ë          # collected. pg_array_parser has a C and Java extension
          def function(arglist)
            parse_data(var, 0)
          end
        end
        
        def function(arglist)
          var = var
          var = [];Fi[	@biI"            super(("-" + var.sub(/ BC$/, "")))
          else
            super
          end
        end
        
        def function(arglist)
          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",");Fi[	@biI"·            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",")
          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil;Fi[	@bi0I"√            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var)
        end;Fi[	@biSI"            "#{object.to_s}/#{object.instance_variable_get(:@mask_addr).to_s(2).count("1")}"
          else
            var
          end
        end
        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end;Fi[	@biiI"°                var
              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil;Fi[	@biÜI"Ë            "NULL"
          else
            (var == "") ? ("\"\"") : (("\"%s\"" % var.to_s.gsub(/(["\\])/, "\\\\\\1")))
          end
        end
        
        def function(arglist)
          case var
          when "NULL" then;Fi[	@ki3I"ò            else
              super
            end
          end
        end
        
        def function(arglist)
          super.insert
        end;Fi[	@kitI"1            var = ActiveRecord::Result.new(var.fields, var.values, var)
            var.clear
            return var
          end
        end
        
        def function(arglist)
          log(var, var, var) do |arglist|
            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var));Fi[	@uiSI"∞            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var
          case var;Fi[	@Éi¥I"M            var.split(".").last)
          rescue ActiveRecord::StatementInvalid
            "#{table_name}_#{(pk or "id")}_seq"
          end
        end
        
        def function(arglist)
          var = exec_query("            SELECT pg_get_serial_sequence('#{table}', '#{column}')\n", "SCHEMA")
          var.rows.first.first;Fi[	@çi»I"ë          "x'#{s}'"
        else
          super
        end
      end
      
      def function(arglist)
        @var.class.quote(var)
      end;Fi[	@çi⁄I"‰          "#{super}.#{sprintf("%06d", value.usec)}"
        else
          super
        end
      end
      
      def function(arglist)
        return var.to_f if BigDecimal.===(var)
        return super unless String.===(var);Fi[	@çi˙I"Ï        #
        def function(arglist)
          (var.rows.map { |arglist| var.join("|") }.join("\n") + "\n")
        end
      end
      
      def function(arglist)
        log(var, var, var) do |arglist|
          if var.empty? then;Fi[	@çiI"ˆ            var.bind_params(var.map { |arglist| type_cast(var, var) })
          end
          ActiveRecord::Result.new(var, var.to_a)
        end
      end
      
      def function(arglist)
        exec_query(var, var, var)
        @var.changes;Fi[	@çiqI"T          IndexDefinition.new(var, var["name"], var["unique"].!=(0), exec_query("PRAGMA index_info('#{row["name"]}')", "SCHEMA").map do |arglist|
            var["name"]
          end)
        end
      end
      
      def function(arglist)
        var = table_structure(var).find { |arglist| (var["pk"] == 1) }
        var and var["name"];Fi[	@çiêI"˙          super(var, var, var, var)
        else
          alter_table(var) { |arglist| var.column(var, var, var) }
        end
      end
      
      def function(arglist)
        alter_table(var) { |arglist| var.columns.delete(var[var]) }
      end;Fi[	@çi≠I"y            self.precision = var[:precision] if var.include?(:precision)
            self.scale = var[:scale] if var.include?(:scale)
          end
        end
      end
      
      def function(arglist)
        unless columns(var).detect { |arglist| (var.name == var.to_s) } then
          raise(ActiveRecord::ActiveRecordError, "Missing column #{table_name}.#{column_name}");Fi[	@çiÀI"˛        transaction do |arglist|
          move_table(var, var, var.merge(:temporary => (true)))
          move_table(var, var, &var)
        end
      end
      
      def function(arglist)
        copy_table(var, var, var, &var)
        drop_table(var);Fi[	@çi˘I"            var[:unique] = true if var.unique
            add_index(var, var, var)
          end
        end
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, var] }]
        var.each { |arglist| var[var.last] = var.first };Fi[	@çiI"          (var << (var.map { |arglist| quote(var[var[var]]) } * ", "))
          (var << ")")
          exec_query(var)
        end
      end
      
      def function(arglist)
        @var ||= SQLite3Adapter::Version.new(select_value("select sqlite_version(*)"))
      end;Fi[	@çiI"Ù          "INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL"
        else
          "INTEGER PRIMARY KEY NOT NULL"
        end
      end
      
      def function(arglist)
        case var.message
        when /column(s)? .* (is|are) not unique/ then;Fi[	@ûiÂI"Ø            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "#{@path}.yml"
    end;Fi[	@ûiSI"k          if ActiveRecord::Base.logger then
            ActiveRecord::Base.logger.warn("Unable to load #{file_name}, underlying cause #{e.message} \n\n #{e.backtrace.join("\n")}")
          end
        end
      end
      
      def function(arglist)
        var ? (var = var.map { |arglist| var.to_s }) : (var = fixture_table_names)
        var.each do |arglist|;Fi[	@ûi[I"         var.each do |arglist|
          var = var.singularize if ActiveRecord::Base.pluralize_table_names
          try_to_load_dependency(var)
        end
      end
      
      def function(arglist)
        var = Array((var or fixture_table_names))
        var = Module.new do |arglist|;Fi[	@ûiÄI"Ï      def function(arglist)
        @var = [] unless defined? @var
        @var.include?(var.to_s)
      end
    end
    
    def function(arglist)
      use_transactional_fixtures and self.class.uses_transaction?(method_name).!
    end;Fi[	@ûi I"Ô        @var.each_value do |arglist|
          ActiveRecord::FixtureSet.instantiate_fixtures(self, var, load_instances?)
        end
      end
    end
    
    def function(arglist)
      use_instantiated_fixtures.!=(:no_instances)
    end;Fi[	@•i&I"          else
            ((superclass == Base) or columns_hash.include?(inheritance_column).!)
          end
        end
      end
      
      def function(arglist)
        (:true == (@var ||= descends_from_active_record? ? (:false) : (:true)))
      end;Fi[	@•i~I"Ë          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column)
      end;Fi[	@•iéI"ç          end
        rescue NameError
          raise(SubclassNotFound, ((("The single-table inheritance mechanism failed to locate the subclass: '#{type_name}'. " + "This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. ") + "Please rename this column if you didn't intend it to be used for storing the inheritance class ") + "or overwrite #{name}.inheritance_column to use another column for that information."))
        end
      end
      
      def function(arglist)
        var = var[inheritance_column.to_sym]
        var = ([self] + descendants).map { |arglist| var.sti_name };Fi[	@´i,I"≈        rescue Exception
          send((var + "="), var)
          raise
        end
      end
      
      def function(arglist)
        var = super
        if locking_enabled? and var.!=(1) then;Fi[	I"<data//activerecord_proj/active_record/log_subscriber.rb;Ti!I"±        [var.name, var]
      else
        [nil, var]
      end
    end
    
    def function(arglist)
      self.class.runtime += var.duration
      return unless logger.debug?;Fi[	@¬iÒI"        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      raise(RecordNotFound, "Couldn't find #{self.class.reflect_on_association(association_name).klass.name} with ID=#{record_id} for #{self.class.name} with ID=#{id}")
    end;Fi[	I"9data//activerecord_proj/active_record/query_cache.rb;TiI"È      # If it's not, it will execute the given block.
      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end;Fi[	@⁄iI"ß          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super
        if ActiveRecord::Base.connected? then;Fi[	I"Adata//activerecord_proj/active_record/readonly_attributes.rb;TiI"I      # Returns an array of all the attributes that have been specified as readonly.
      def function(arglist)
        self._attr_readonly
      end
    end
    
    def function(arglist)
      var = "Instance level _attr_readonly method is deprecated, please use class level method."
      ActiveSupport::Deprecation.warn(var);Fi[	@ﬂi I"          "#{active_record.name.demodulize.underscore.pluralize}_count"
        else
          options[:counter_cache].to_s if options[:counter_cache]
        end
      end
      
      def function(arglist)
        @var ||= klass.connection.columns(var)
      end;Fi[	@ﬂiŸI"X        check_validity_of_inverse!
        if has_and_belongs_to_many? and (association_foreign_key == foreign_key) then
          raise(HasAndBelongsToManyAssociationForeignKeyNeeded.new(self))
        end
      end
      
      def function(arglist)
        unless options[:polymorphic] then
          if has_inverse? and inverse_of.nil? then;Fi[	@ﬂi·I"◊          if has_inverse? and inverse_of.nil? then
            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@ﬂiDI"ó          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic)
      end;Fi[	@ﬂiXI";          "#{name}_id"
        else
          options[:as] ? ("#{options[:as]}_id") : (active_record.name.foreign_key)
        end
      end
      
      def function(arglist)
        [active_record.table_name, klass.table_name].sort.join("\x00").gsub(/^(.*_)(.+)\0\1(.+)/, "\\1\\2_\\3").gsub("\x00", "_")
      end;Fi[	@ﬂi…I"      def function(arglist)
        @var ||= (options[:source] ? ([options[:source]]) : ([name.to_s.singularize, name])).collect do |arglist|
          var.to_sym
        end
      end
      
      def function(arglist)
        source_reflection.options
      end;Fi[	I"Cdata//activerecord_proj/active_record/relation/calculations.rb;Ti…I"	        execute_grouped_calculation(var, var, var)
      else
        execute_simple_calculation(var, var, var)
      end
    end
    
    def function(arglist)
      if @var.column_names.include?(var.to_s) then
        Arel::Attribute.new(@var.unscoped.table, var);Fi[	@Øi—I"Ï        Arel::Attribute.new(@var.unscoped.table, var)
      else
        Arel.sql(((var == :all) ? ("*") : (var.to_s)))
      end
    end
    
    def function(arglist)
      (var == "count") ? (var.count(var)) : (var.send(var))
    end;Fi[	@Øi7I"…        var.respond_to?(:to_d) ? (var.to_d) : (var)
      else
        type_cast_using_column(var, var)
      end
    end
    
    def function(arglist)
      var ? (var.type_cast(var)) : (var)
    end;Fi[	@ØiBI"Ì      if select_values.present? then
        var = select_values.join(", ")
        var unless var =~ /[,*]/
      end
    end
    
    def function(arglist)
      var = Arel.sql("count_column")
      var = Arel.sql("subquery_for_count");Fi[	@‚i!I"x            else
              module_eval("                def #{method}(*args, &block)\n                  scoping { @klass.send(#{method.inspect}, *args, &block) }\n                end\n", "(string)", (46 + 1))
            end
          end
        end
        
        def function(arglist)
          @var.synchronize do |arglist|
            return if method_defined?(var);Fi[	@‚i^I"ﬁ        else
          ActiveRecord::Relation
        end
      end
    end
    
    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))))
    end;Fi[	I"Edata//activerecord_proj/active_record/relation/finder_methods.rb;TiªI"Ì        var.instantiate(var))
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = (eager_load_values + includes_values).uniq
      ActiveRecord::Associations::JoinDependency.new(@var, var, []);Fi[	@ºiÔI"»        var ? ([var]) : (var)
      else
        find_some(var)
      end
    end
    
    def function(arglist)
      var = var.id if ActiveRecord::Base.===(var)
      var = columns_hash[primary_key];Fi[	@ºiI"W        var = "Couldn't find all #{@klass.name.pluralize} with IDs "
        (var << "(#{ids.join(", ")})#{conditions} (found #{result.size} results, but was looking for #{expected_size})")
        raise(RecordNotFound, var)
      end
    end
    
    def function(arglist)
      loaded? ? (@var.first) : (@var ||= limit(1).to_a.first)
    end;Fi[	@ºiI"è        else
          limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      if loaded? then
        @var.last;Fi[	@ºi+I"´        else
          reverse_order.limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      var.none? { |arglist| var.collection? }
    end;Fi[	@ÎiUI"i        relation.reverse_order_value = values[:reverse_order]
        unless values[:create_with].blank? then
          relation.create_with_value = (relation.create_with_value or {}).merge(values[:create_with])
        end
      end
      
      def function(arglist)
        if values[:bind] then
          (relation.bind_values + values[:bind]).uniq(&:first);Fi[	@Îi]I"˚          (relation.bind_values + values[:bind]).uniq(&:first)
        else
          relation.bind_values
        end
      end
      
      def function(arglist)
        if values[:where] then
          var = (relation.where_values + values[:where]);Fi[	@Ûi¥I"⁄      else
        raise(ArgumentError, "Call this with at least one field") if var.empty?
        spawn.select!(*var)
      end
    end
    
    def function(arglist)
      self.select_values += var.flatten
      self;Fi[	@ÛiøI"‡          # do nothing
        end
        var.create_string_join(var)
      end
    end
    
    def function(arglist)
      var = var.grep(Arel::Nodes::Equality)
      var.where(Arel::Nodes::And.new(var)) unless var.empty?;Fi[	@Ûi»I"‚      (var - var).each do |arglist|
        var = Arel.sql(var) if String.===(var)
        var.where(Arel::Nodes::Grouping.new(var))
      end
    end
    
    def function(arglist)
      case var
      when String, Array then;Fi[	@Ûi‘I"∞        PredicateBuilder.build_from_hash(klass, var, table)
      else
        [var]
      end
    end
    
    def function(arglist)
      var, var = from_value
      case var;Fi[	@ÛiﬂI"ú        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist)
      var = var.group_by do |arglist|
        case var;Fi[	@ÛiI"◊      else
        @var = false
        var.project(*var)
      end
    end
    
    def function(arglist)
      var = ["#{quoted_table_name}.#{quoted_primary_key} ASC"] if var.empty?
      var.flat_map do |arglist|;Fi[	@ÛiI"£        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) }
    end;Fi[	I"6data//activerecord_proj/active_record/relation.rb;Ti·I"Ü        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      var.pp(self.to_a)
    end;Ti[	@Ÿi.I"‹        else
          false
        end
      end
    end
    
    def function(arglist)
      return [] if var.blank?
      (var.scan(/([a-zA-Z_][.\w]+).?\./).flatten.map { |arglist| var.downcase }.uniq - ["raw_sql_"]);Ti[	@¯iòI"1              raise(PreparedStatementInvalid, "missing value for :#{match} in #{statement}")
            end
          end
        end
      end
      
      def function(arglist)
        if var.respond_to?(:map) and var.acts_like?(:string).! then
          if var.respond_to?(:empty?) and var.empty? then;Fi[	@¯i§I"          end
        else
          var.quote(var)
        end
      end
      
      def function(arglist)
        unless (var == var) then
          raise(PreparedStatementInvalid, "wrong number of bind variables (#{provided} for #{expected}) in: #{statement}");Fi[	I";data//activerecord_proj/active_record/schema_dumper.rb;Ti>I"ç          next
        end
        table(var, var)
      end
    end
    
    def function(arglist)
      var = @var.columns(var)
      begin;Fi[	@‚iÅI"Ì        end
        var.puts(var.sort.join("\n"))
        var.puts
      end
    end
    
    def function(arglist)
      var.gsub(/^(#{ActiveRecord::Base.table_name_prefix})(.+)(#{ActiveRecord::Base.table_name_suffix})$/, "\\2")
    end;Fi[	I">data//activerecord_proj/active_record/schema_migration.rb;TiI"È      if connection.table_exists?(table_name) then
        connection.remove_index(table_name, :name => (index_name))
        connection.drop_table(table_name)
      end
    end
    
    def function(arglist)
      super.to_i
    end;Fi[	@˝iuI"ª                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["#{self}_ignore_default_scope"]
        end;Fi[	@iI"Ó      
      def function(arglist)
        Thread.current["#{self}_current_scope"] = var
      end
    end
    
    def function(arglist)
      return unless self.class.scope_attributes?
      self.class.scope_attributes.each do |arglist|;Fi[	@i@I"‘          var
        else
          ActiveRecord::Coders::YAMLColumn.new((var or Object))
        end
      end
      
      def function(arglist)
        @var.dump(self.class.as_indifferent_hash(var))
      end;Fi[	@i&I"∑          else
            ActiveRecord::Base.configurations[var[:env]]
          end
        end
      end
      
      def function(arglist)
        begin
          (var = var.first;Fi[	@i2I"        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("Couldn't create database for #{configuration.inspect}")
        end
      end
      
      def function(arglist)
        each_local_configuration { |arglist| create(var) }
      end;Fi[	@iII"        rescue Exception => var
          $stderr.puts(var, *var.backtrace)
          $stderr.puts("Couldn't drop #{configuration["database"]}")
        end
      end
      
      def function(arglist)
        each_local_configuration { |arglist| drop(var) }
      end;Fi[	@ièI"          else
            $stderr.puts("This task only modifies local databases. #{configuration["database"]} is on a remote host.")
          end
        end
      end
      
      def function(arglist)
        (var["host"].blank? or LOCAL_HOSTS.include?(var["host"]))
      end;Fi[	@i,I"'              $stderr.puts("(If you set the charset manually, make sure you have a matching collation)")
            end
          end
        end
      end
      
      def function(arglist)
        establish_connection(configuration)
        connection.drop_database(configuration["database"]);Fi[	@ibI"N          end
          var[:charset] ||= DEFAULT_CHARSET unless var[:collation]
          var[:collation] ||= DEFAULT_COLLATION if (var[:charset] == DEFAULT_CHARSET)
        end
      end
      
      def function(arglist)
        if configuration["adapter"] =~ /jdbc/ then
          require("active_record/railties/jdbcmysql_error");Fi[	@ioI"R          else
            defined? Mysql ? (Mysql::Error) : (StandardError)
          end
        end
      end
      
      def function(arglist)
        "GRANT ALL PRIVILEGES ON #{configuration["database"]}.*\n  TO '#{configuration["username"]}'@'localhost'\nIDENTIFIED BY '#{configuration["password"]}' WITH GRANT OPTION;\n"
      end;Fi[	@!iI"«          else
            raise
          end
        end
      end
      
      def function(arglist)
        establish_master_connection
        connection.drop_database(configuration["database"]);Fi[	@!i>I"c        raise("Error dumping database") unless Kernel.system(var)
        File.open(var, "a") do |arglist|
          (var << "SET search_path TO #{ActiveRecord::Base.connection.schema_search_path};\n\n")
        end
      end
      
      def function(arglist)
        set_psql_env
        Kernel.system("psql -f #{filename} #{configuration["database"]}");Fi[	@$i4I"$    def function(arglist)
      timestamp_attributes_for_create.select do |arglist|
        self.class.column_names.include?(var.to_s)
      end
    end
    
    def function(arglist)
      timestamp_attributes_for_update.select do |arglist|
        self.class.column_names.include?(var.to_s);Fi[	@$i:I"    def function(arglist)
      timestamp_attributes_for_update.select do |arglist|
        self.class.column_names.include?(var.to_s)
      end
    end
    
    def function(arglist)
      (timestamp_attributes_for_create_in_model + timestamp_attributes_for_update_in_model)
    end;Fi[	@'i=I"ê          assert_valid_transaction_action(var[:on])
          var[:if] = Array(var[:if])
          (var[:if] << "transaction_include_action?(:#{options[:on]})")
        end
      end
      
      def function(arglist)
        unless ACTIONS.include?(var.to_sym) then
          raise(ArgumentError, ":on conditions for after_commit and after_rollback callbacks have to be one of #{ACTIONS.join(",")}");Fi[	@'iTI"˝    def function(arglist)
      rollback_active_record_state! do |arglist|
        with_transaction_returning_status { |arglist| super }
      end
    end
    
    def function(arglist)
      with_transaction_returning_status { |arglist| super }
    end;Fi[	@2i=I"        else
          var = var.connection.case_sensitive_modifier(var) unless var.nil?
          var[var].eq(var)
        end
      end
      
      def function(arglist)
        Array(options[:scope]).each do |arglist|
          if var = var.class.reflect_on_association(var) then;Fi[	@5i"I"¯          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|
          var.index_name = [var, attributes[(var - 1)]].map { |arglist| index_name_for(var) };Fi[	@5i(I"@      def function(arglist)
        attributes.each_with_index do |arglist|
          var.index_name = [var, attributes[(var - 1)]].map { |arglist| index_name_for(var) }
        end
      end
      
      def function(arglist)
        (var.foreign_key? ? (var.name) : (var.name.singularize.foreign_key)).to_sym
      end;Fi[	@:i'I"7        return if regular_class_path.empty?
        if (behavior == :invoke) then
          template("module.rb", File.join("app/models", "#{class_path.join("/")}.rb"))
        end
      end
      
      def function(arglist)
        attributes.select { |arglist| var.reference?.! and var.has_index? }
      end;Fi[	I"(data//backup_proj/backup/package.rb;Ti(I"ø        [basename]
      else
        chunk_suffixes.map { |arglist| "#{basename}-#{suffix}" }
      end
    end
    
    def function(arglist)
      "#{time}.#{trigger}.#{extension}"
    end;Fi[	@öi7I"Ë        Logger.warn(stderr_messages) if success? and stderr_messages)
      rescue Exception => var
        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end;Fi[	@˝iΩI"‹      Bundler.settings[:cache_all] = options[:all] if options.key?("all")
      if Bundler.definition.sources.any? { |arglist| var.is_a?(Source::Rubygems).! } and Bundler.settings[:cache_all].! then
        Bundler.ui.warn("Your Gemfile contains path and git dependencies. If you want to package them as well, please pass the --all flag. This will be the default on Bundler 2.0.")
      end
    end
    
    def function(arglist)
      `which groff` rescue "".empty?.!
    end;Fi[	@ iNI"        if var = @var.find { |arglist| (var.name == var.name) } then
          var.instance_variable_set(:@type, var.type)
        end
      end
    end
    
    def function(arglist)
      raise("Specs already loaded") if @var
      @var.each { |arglist| var.cached! };Fi[	@ iéI"˙          var[var.name] = var.source.specs
        end
        var.merge(Resolver.resolve(expanded_dependencies, index, var, var))
      end
    end
    
    def function(arglist)
      @var ||= Index.build do |arglist|
        var = (@var.dup or []);Fi[	@ i®I"˚      @var ||= Index.build do |arglist|
        var = @var.find { |arglist| var.is_a?(Source::Rubygems) }
        var.add_source(var.specs)
      end
    end
    
    def function(arglist)
      (@var.length == 1) and @var.first.remotes.empty?
    end;Fi[	@ iøI"á        File.open(var, "wb") { |arglist| var.puts(var) })
      rescue Errno::EACCES
        raise(Bundler::InstallError, "There was an error while trying to write to Gemfile.lock. It is likely that \nyou need to allow write permissions for the file at path: \n#{File.expand_path(file)}")
      end
    end
    
    def function(arglist)
      var = ""
      sorted_sources.each do |arglist|;Fi[	@ iHI"˙        (var or specs_changed?(var) do |arglist|
          var.class.===(var.class) and (var.uri == var.uri)
        end)
      end
    end
    
    def function(arglist)
      @var.any? do |arglist|
        next unless var.instance_of?(Source::Path);Fi[	@ iQI"Û        specs_changed?(var) do |arglist|
          (var.class == var.class) and (var.path == var.path)
        end
      end
    end
    
    def function(arglist)
      var = false
      var = @var.find { |arglist| Source::Rubygems.===(var) };Fi[	@ iùI"Û    def function(arglist)
      @var.any? do |arglist|
        var.satisfies?(var) and (var.source.! or (var.source == var.source))
      end
    end
    
    def function(arglist)
      @var ||= expand_dependencies(dependencies, @var)
    end;Fi[	@ i¥I"    def function(arglist)
      @var.sort_by do |arglist|
        [var.is_a?(Source::Rubygems) ? (1) : (0), var.to_s]
      end
    end
    
    def function(arglist)
      var = (self.groups - Bundler.settings.without)
      var.map! { |arglist| var.to_sym };Fi[	I"-data//bundler_proj/bundler/dependency.rb;Ti4I"´        end
      else
        ENV[@var.to_s]
      end
    end
    
    def function(arglist)
      return true if @var.empty?
      @var.any? { |arglist| send("#{p}?") };Fi[	@
i*I"j        var.backtrace[0] = "#{e.backtrace[0]}: #{e.message} (#{e.class})"
        Bundler.ui.warn(var.backtrace.join("\n       "))
        raise(GemfileError, "There was an error in your Gemfile, and Bundler cannot continue.")
      end
    end
    
    def function(arglist)
      var = ((var and var[:path]) or ".")
      var = ((var and var[:name]) or "{,*}");Fi[	@
iCI"Ñ        raise(InvalidOption, "There are no gemspecs at #{path}.")
      else
        raise(InvalidOption, "There are multiple gemspecs at #{path}. Please use the :name option to specify which one.")
      end
    end
    
    def function(arglist)
      if var.is_a?(Symbol) then
        raise(GemfileError, "You need to specify gem names as Strings. Use 'gem \"#{name.to_s}\"' instead.");Fi[	@
iyI"‘          return @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      source(Source::Path.new(_normalize_hash(var).merge("path" => (Pathname.new(var)))), var, &var)
    end;Fi[	@
iéI"ö        yield)
      ensure
        var.each { |arglist| @var.pop }
      end
    end
    
    def function(arglist)
      begin
        (@var.concat(var);Fi[	@
i¢I"        yield)
      ensure
        @var = var
      end
    end
    
    def function(arglist)
      var = caller[0].split(":")[(0..1)].join(":")
      raise(GemfileError, "Undefined local variable or method `#{name}' for Gemfile\n        from #{location}");Fi[	I"9data//bundler_proj/bundler/endpoint_specification.rb;Ti9I"        @var.post_install_message
      else
        _local_specification.post_install_message if _local_specification
      end
    end
    
    def function(arglist)
      if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path));Fi[	@6i?I"”    def function(arglist)
      if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end;Fi[	@i2I"∆          end
          var = var
        end
      end
    end
    
    def function(arglist)
      var = Hash.new { |arglist| var[var] = Set.new }
      @var.current_dependencies.each do |arglist|;Fi[	@iwI"o          var.edge[:weight] = 2
          var.edge[:fontname] = var.node[:fontname] = "Arial, Helvetica, SansSerif"
          var.edge[:fontsize] = 12
        end
      end
      
      def function(arglist)
        @var.each do |arglist|
          g.add_nodes(var, { :style => "filled", :fillcolor => "#B9B9D5", :shape => "box3d", :fontsize => 16 }.merge(@var[var]));Fi[	I"(data//bundler_proj/bundler/index.rb;TiCI"”        search_by_dependency(var, var)
      else
        raise("You can't search for a #{query.inspect}.")
      end
    end
    
    def function(arglist)
      sources.map { |arglist| var.class }.uniq
    end;Fi[	@?iuI"Ô      all? do |arglist|
        var = var[var].first
        (var.dependencies.&(var.dependencies).empty? and (var.source == var.source))
      end
    end
    
    def function(arglist)
      if var.is_a?(Index) then
        (@var << var);Fi[	@?iìI"a        var.sort_by do |arglist|
          [var.version, (var.platform.to_s == "ruby") ? ("\x00") : (var.platform.to_s)]
        end)
      end
    end
    
    def function(arglist)
      specs_by_name(var.name).select do |arglist|
        same_version?(var.version, var.version) and (Gem::Platform.new(var.platform) == Gem::Platform.new(var.platform));Fi[	@?i§I"Ã    else
      def function(arglist)
        (var == var)
      end
    end
    
    def function(arglist)
      return false unless var.name.===(var.name)
      var.requirement.satisfied_by?(var.version);Fi[	@ikI"+        (var << " #{spec.name} -v '#{spec.version}'` succeeds before bundling.")
        Bundler.ui.debug(var.backtrace.join("\n"))
        raise(Bundler::InstallError, var)
      end
    end
    
    def function(arglist)
      if var[:binstubs_cmd] and var.executables.empty? then
        var = {};Fi[	@i§I"        File.open("#{bin_path}/#{executable}", "w", 493) do |arglist|
          var.puts(ERB.new(var, nil, "-").result(binding))
        end
      end
    end
    
    def function(arglist)
      var = Bundler.settings[:path]
      var = File.join(var, "bundler");Fi[	I"5data//bundler_proj/bundler/lazy_specification.rb;TiI"≤        "#{@name}-#{@version}"
      else
        "#{@name}-#{@version}-#{platform}"
      end
    end
    
    def function(arglist)
      (identifier == var.identifier)
    end;Fi[	I"2data//bundler_proj/bundler/lockfile_parser.rb;Ti]I"±          end
        end
        (@var << var)
      end
    end
    
    def function(arglist)
      if var.=~(NAME_VERSION_4) then
        var, var = $1, Gem::Version.new($2);Fi[	@OinI"“          var = Gem::Dependency.new(var, var)
          (@var.dependencies << var)
        end
      end
    end
    
    def function(arglist)
      (@var << Gem::Platform.new($1)) if var =~ /^  (.*)$/
    end;Fi[	@%i$I"‚        @var = {}
        ALL.each do |arglist|
          @var[var] = reverse.find { |arglist| var.match_platform(var) }
        end
      end
      
      def function(arglist)
        super
        @var = var.required_by.dup;Fi[	@%iI"Ÿ        var = yield
        var = var.inspect unless var.is_a?(String)
        $stderr.puts(var)
      end
    end
    
    def function(arglist)
      var.values.map { |arglist| var.to_specs }.flatten.compact
    end;Fi[	@%iÓI"®            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by)
      (var.required_by << var);Fi[	@%i/I"¨        else
          var = []
        end)
      end
    end
    
    def function(arglist)
      if var.to_s.include?(">= 0") then
        var.to_s.gsub(/ \(.*?\)$/, "");Fi[	@%i7I"⁄        var.to_s.gsub(/ \(.*?\)$/, "")
      else
        var.to_s.gsub(/\, (runtime|development)\)$/, ")")
      end
    end
    
    def function(arglist)
      VersionConflict.new(errors.keys, error_message)
    end;Fi[	I"/data//bundler_proj/bundler/rubygems_ext.rb;TiI"Ù        Pathname.new(loaded_from).dirname.expand_path(Bundler.root).to_s
      else
        rg_full_gem_path
      end
    end
    
    def function(arglist)
      if relative_loaded_from then
        source.path.join(relative_loaded_from).to_s;Fi[	@^i!I"˘        source.path.join(relative_loaded_from).to_s
      else
        rg_loaded_from
      end
    end
    
    def function(arglist)
      require_paths.map do |arglist|
        var.include?(full_gem_path) ? (var) : (File.join(full_gem_path, var));Fi[	@^i9I"E      if @var and File.exist?(File.join(full_gem_path, ".git")) then
        var = Dir.chdir(full_gem_path) { |arglist| `git rev-parse HEAD`.strip }
        " #{sha[(0..6)]}"
      end
    end
    
    def function(arglist)
      var = "source :gemcutter\n"
      (var << dependencies_to_gemfile(nondevelopment_dependencies));Fi[	@^ieI"    def function(arglist)
      to_yaml_properties.each do |arglist|
        var[var.to_s.sub(/^@/, "")] = instance_variable_get(var)
      end
    end
    
    def function(arglist)
      instance_variables.reject do |arglist|
        ["@source", "@groups"].include?(var.to_s);Fi[	@^ikI"˝    def function(arglist)
      instance_variables.reject do |arglist|
        ["@source", "@groups"].include?(var.to_s)
      end
    end
    
    def function(arglist)
      var = "  #{name}"
      unless (requirement == Gem::Requirement.default) then;Fi[	@3iwI"ö        yield)
      ensure
        self.build_args = var
      end
    end
    
    def function(arglist)
      begin
        (require("rubygems/format");Fi[	@3i{I"(        Gem::Format.from_file_by_path(var).spec)
      rescue Gem::Package::FormatError
        raise(Bundler::GemspecError, "Could not read gem at #{path}. It may be corrupted.")
      end
    end
    
    def function(arglist)
      require("rubygems/builder")
      Gem::Builder.new(var).build;Fi[	@3iíI"Ò          (alias :require :gem_original_require)
        end
        undef :gem
      end
    end
    
    def function(arglist)
      var = var.map { |arglist| var.executables }.flatten
      ::Kernel.send(:define_method, :gem) do |arglist|;Fi[	@3i¥I"ä          end
        end
        true
      end
    end
    
    def function(arglist)
      var = class << Gem::SourceIndex
        self;Fi[	@3i¡I"        var.spec_dirs = *var
        var.add_specs(*var)
        var
      end
    end
    
    def function(arglist)
      Gem::SourceIndex.send(:alias_method, :old_initialize, :initialize)
      Gem::SourceIndex.send(:define_method, :initialize) do |arglist|;Fi[	@3iI"E      Gem::Specification.send(:define_method, :base_dir) do |arglist|
        return Gem.dir unless loaded_from
        File.dirname(File.dirname(loaded_from))
      end
    end
    
    def function(arglist)
      Gem::Specification.send(:define_method, :cache_dir) do |arglist|
        @var ||= File.join(base_dir, "cache");Fi[	@3iI"9      end
      Gem::Specification.send(:define_method, :cache_file) do |arglist|
        @var ||= File.join(cache_dir, "#{full_name}.gem")
      end
    end
    
    def function(arglist)
      Gem::Specification.send(:define_method, :spec_dir) do |arglist|
        @var ||= File.join(base_dir, "specifications");Fi[	@3iàI"          Gem::Package.new(var).spec
        rescue Gem::Package::FormatError
          raise(Bundler::GemspecError, "Could not read gem at #{path}. It may be corrupted.")
        end
      end
      
      def function(arglist)
        Gem::Package.build(var)
      end;Fi[	@8iAI"à            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then
        dependencies;Fi[	@8iÃI"Ê          Bundler.ui.info("  * #{File.basename(path)}")
          File.delete(var)
        end
      end
    end
    
    def function(arglist)
      var = Dir["#{cache_path}/*/.bundlecache"]
      var = var.delete_if do |arglist|;Fi[	@8iﬂI"ª          Bundler.ui.info("  * #{File.basename(path)}")
          FileUtils.rm_rf(var)
        end
      end
    end
    
    def function(arglist)
      root.join("vendor/cache")
    end;Fi[	@=i]I"Æ        "#{path}/#{Bundler.ruby_scope}"
      else
        Bundler.rubygems.gem_dir
      end
    end
    
    def function(arglist)
      @var.key?(key_for(:path)).!
    end;Fi[	@@i1I"        var = File.join(var, "Gemfile")
        return var if File.file?(var)
        var, var = File.expand_path("..", var), var)
      end
    end
    
    def function(arglist)
      if defined? ::Gem then
        var = File.expand_path("../../", "(string)");Fi[	@Ci!I"          allowed_in_path do |arglist|
            var = git_null("branch --contains #{commit}")
            (($? == 0) and var =~ /^\* (.*)$/)
          end
        end
        
        def function(arglist)
          if path.exist? then
            return if has_revision_cached?;Fi[	@Ci1I"A            var = "clone #{uri_escaped} \"#{path}\" --bare --no-hardlinks"
            var = "#{clone_command} --quiet" if Bundler.ui.quiet?
            git(var)
          end
        end
        
        def function(arglist)
          unless File.exist?(var.join(".git")) then
            FileUtils.mkdir_p(var.dirname);Fi[	@CiNI"‘            git("#{command} 2>/dev/null", false)
          else
            git(var, false)
          end
        end
        
        def function(arglist)
          if allow? then
            var = `git #{var}`;Fi[	@Ci^I"·            var
          else
            raise(GitError, "Bundler is trying to run a `git #{command}` at runtime. You probably need to run `bundle install`. However, this error message could probably be more useful. Please submit a ticket at http://github.com/carlhuda/bundler/issues with steps to reproduce as well as the following\n\nCALLER: #{caller.join("\n")}")
          end
        end
        
        def function(arglist)
          begin
            (return unless @var;Fi[	@CiqI"Ò            (("\"" + uri.gsub("\"") { |arglist| "\"\"" }) + "\"")
          else
            (("'" + uri.gsub("'") { |arglist| "'\\''" }) + "'")
          end
        end
        
        def function(arglist)
          @var.call
        end;Fi[	@XiØI"ˇ          if var and var then
            Dir.chdir(var) { |arglist| FileUtils.rm_rf(var) if File.exist?(var) }
          end
        end
      end
      
      def function(arglist)
        var = "#{type}_hooks"
        return unless Gem.respond_to?(var);Fi[	@ôi8I"˚        if @var and @var.is_a?(Array).! then
          raise(ArgumentError, "An argument cannot have an enum other than an array.")
        end
      end
    end
    
    def function(arglist)
      self.class::VALID_TYPES.include?(var.to_sym)
    end;Fi[	@úi"I"§        else
          (@var << var) if var.required?
        end
      end
    end
    
    def function(arglist)
      @var = var.dup
      @var.each do |arglist|;Fi[	I"<data//bundler_proj/bundler/vendor/thor/parser/option.rb;TiMI"ﬁ    def function(arglist)
      if boolean? and required? then
        raise(ArgumentError, "An option cannot be boolean and required.")
      end
    end
    
    def function(arglist)
      (name.index("-") == 0)
    end;Fi[	@üiBI"|        super
      else
        var
      end
    end
    
    def function(arglist)
      @var = var.dup
      @var = true;Fi[	@üiàI"‰        [true, $1.split("").any? { |arglist| switch?("-#{f}") }]
      else
        [false, false]
      end
    end
    
    def function(arglist)
      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then;Fi[	@üiëI"ã        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super)
    end;Fi[	@§iI"Á          var.write(var)
          var.rewind
          system("#{diff_cmd} \"#{destination}\" \"#{temp.path}\"")
        end
      end
      
      def function(arglist)
        (mute? or (base and base.options[:quiet]))
      end;Fi[	@§i=I"…          ensure
            $KCODE = var
          end
        end
      end
      
      def function(arglist)
        say("#{statement} ", var)
        stdin.gets.tap { |arglist| var.strip! if var };Fi[	@ßivI"–          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "-" then;Fi[	@¨idI"–          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action
        when "-" then;Fi[	I"(data//cancan_proj/cancan/ability.rb;TiI"      rules.reverse.select do |arglist|
        var.expanded_actions = expand_actions(var.actions)
        var.relevant?(var, var)
      end
    end
    
    def function(arglist)
      relevant_rules(var, var).each do |arglist|
        if var.only_raw_sql? then;Fi[	@§iI"c        if var.only_raw_sql? then
          raise(Error, "The can? and cannot? call cannot be used with a raw sql 'can' definition. The checking code cannot be determined for #{action.inspect} #{subject.inspect}")
        end
      end
    end
    
    def function(arglist)
      relevant_rules(var, var).each do |arglist|
        if var.only_block? then;Fi[	@§iI"Y        if var.only_block? then
          raise(Error, "The accessible_by call cannot be used with a block 'can' definition. The SQL cannot be determined for #{action.inspect} #{subject.inspect}")
        end
      end
    end
    
    def function(arglist)
      { :read => ([:index, :show]), :create => ([:new]), :update => ([:edit]) }
    end;Fi[	I"5data//cancan_proj/cancan/controller_additions.rb;Ti
I"Y      def function(arglist)
        self.before_filter(*var) do |arglist|
          var.instance_variable_set(:@_authorized, true)
        end
      end
      
      def function(arglist)
        raise(ImplementationRemoved, "The CanCan skip_authorization method has been renamed to skip_authorization_check. Please update your code.")
      end;Fi[	@´iI"ø          InheritedResource
        else
          ControllerResource
        end
      end
      
      def function(arglist)
        @var ||= { :authorize => ({}), :load => ({}) }
      end;Fi[	@πiI"\      var = var.delete(:prepend) ? (:prepend_before_filter) : (:before_filter)
      var.send(var, var.slice(:only, :except, :if, :unless)) do |arglist|
        var.class.cancan_resource_class.new(var, var, var.except(:only, :except, :if, :unless)).send(var)
      end
    end
    
    def function(arglist)
      @var = var
      @var = var.params;Fi[	@πiI"      end
      if @var[:resource] then
        raise(CanCan::ImplementationRemoved, "The :resource option has been renamed back to :class, use false if no class.")
      end
    end
    
    def function(arglist)
      load_resource
      authorize_resource;Fi[	@πi,I"        else
          self.collection_instance ||= load_collection if load_collection?
        end
      end
    end
    
    def function(arglist)
      unless skip?(:authorize) then
        @var.authorize!(authorization_action, (resource_instance or resource_class_with_parent));Fi[	@πi2I"
    def function(arglist)
      unless skip?(:authorize) then
        @var.authorize!(authorization_action, (resource_instance or resource_class_with_parent))
      end
    end
    
    def function(arglist)
      if @var.has_key?(:parent) then
        @var[:parent];Fi[	@πi:I"œ        @var[:parent]
      else
        @var and @var.!=(name_from_controller.to_sym)
      end
    end
    
    def function(arglist)
      var = @var.class.cancan_skipper[var][@var]
      if var.nil? then;Fi[	@πiUI"¥        build_resource
      else
        find_resource if (id_param or @var[:singleton])
      end
    end
    
    def function(arglist)
      (parent? or member_action?)
    end;Fi[	@πitI"N    def function(arglist)
      current_ability.attributes_for(@var[:action].to_sym, resource_class).delete_if do |arglist|
        resource_params and resource_params.include?(var)
      end
    end
    
    def function(arglist)
      if @var[:singleton] and parent_resource.respond_to?(name) then
        parent_resource.send(name);Fi[	@πiI"ƒ        else
          adapter.find(resource_base, id_param)
        end
      end
    end
    
    def function(arglist)
      ModelAdapters::AbstractAdapter.adapter_class(resource_class)
    end;Fi[	@πièI">        @var[@var[:id_param]]
      else
        @var[(parent? ? (:"#{name}_id") : (:id))]
      end
    end
    
    def function(arglist)
      (new_actions.include?(@var[:action].to_sym) or (@var[:singleton] or ((@var[:id] or @var[@var[:id_param]]) and collection_actions.include?(@var[:action].to_sym).!)))
    end;Fi[	@πi£I"ø        @var[:class].constantize
      else
        @var[:class]
      end
    end
    
    def function(arglist)
      if parent_resource then
        { parent_resource => (resource_class) };Fi[	@πi´I"≈        { parent_resource => (resource_class) }
      else
        resource_class
      end
    end
    
    def function(arglist)
      @var.instance_variable_set("@#{instance_name}", var)
    end;Fi[	@πi”I"ø        end
      else
        resource_class
      end
    end
    
    def function(arglist)
      @var[:through] and [@var[:through]].flatten.detect { |arglist| fetch_parent(var) }
    end;Fi[	@πi‰I"         @var.instance_variable_get("@#{name}")
      else
        @var.send(var) if @var.respond_to?(var, true)
      end
    end
    
    def function(arglist)
      @var.send(:current_ability)
    end;Fi[	@πiI"         [namespace, name.camelize].join("::").singularize.camelize.constantize
      rescue NameError
        name
      end
    end
    
    def function(arglist)
      @var[:controller].sub("Controller", "").underscore.split("/").last.singularize
    end;Fi[	I"3data//cancan_proj/cancan/inherited_resource.rb;TiI"õ        else
          @var.send(:resource)
        end
      end
    end
    
    def function(arglist)
      @var.send(:end_of_association_chain)
    end;Fi[	@øiRI",          @var.reverse.inject(false_sql) do |arglist|
            merge_conditions(var, tableized_conditions(var.conditions).dup, var.base_behavior)
          end
        end
      end
      
      def function(arglist)
        return var unless var.kind_of?(Hash)
        var.inject({}) do |arglist|;Fi[	@øiÅI"î            var = @var.detect { |arglist| var.conditions.kind_of?(ActiveRecord::Relation) }
            raise(Error, "Unable to merge an Active Record scope with other conditions. Instead use a hash or SQL for #{rule.actions.first} #{rule.subjects.first} ability.")
          end
        end
      end
      
      def function(arglist)
        if var.blank? then
          var ? (true_sql) : (false_sql);Fi[	@øiïI"º              "not (#{conditions}) AND (#{sql})"
            end
          end
        end
      end
      
      def function(arglist)
        sanitize_sql(["?=?", true, false])
      end;Fi[	@“i3I"ä            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!
    end;Fi[	@“iÑI"«            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first
      matches_conditions_hash?(var, (@var[var.class.name.downcase.to_sym] or {}));Fi[	@“iëI"ˇ        @var.call(var, var, nil, *var)
      else
        @var.call(var, var.class, var, *var)
      end
    end
    
    def function(arglist)
      CanCan::ModelAdapters::AbstractAdapter.adapter_class((subject_class?(var) ? (var) : (var.class)))
    end;Fi[	@„i)I"˘          var)
        rescue Exception => var
          handle_error(var)
        end
      end
      
      def function(arglist)
        Array(options[:vars]).each { |arglist| var.set(var, var) }
        Array(options[:actions]).each do |arglist|;Fi[	@„i0I"s        Array(options[:vars]).each { |arglist| var.set(var, var) }
        Array(options[:actions]).each do |arglist|
          var.find_and_execute_task(var, :before => :start, :after => :finish)
        end
      end
      
      def function(arglist)
        var.set(:password, options[:password])
        Array(options[:pre_vars]).each { |arglist| var.set(var, var) };Fi[	@ËiI"Ã          else
            execute_requested_actions_without_help(var)
          end
        end
      end
      
      def function(arglist)
        var = options[:tool]
        if var.is_a?(String) then;Fi[	@ËiKI"            puts("Extended help may be available for these tasks.")
            puts("Type `#{File.basename($0)} -e taskname' to view it.")
          end
        end
      end
      
      def function(arglist)
        var = var.find_task(var)
        if var.nil? then;Fi[	@Îi≤I"Â          options[var].keys.each do |arglist|
            options[var][var] = coerce_variable(options[var][var])
          end
        end
      end
      
      def function(arglist)
        case var
        when /^"(.*)"$/ then;Fi[	@˜iTI"¢                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var;Fi[	@˜icI"ª        
        def function(arglist)
          "#{condition.inspect} :: #{command.inspect}"
        end
      end
      
      def function(arglist)
        @var = var
        @var = [];Fi[	@˜iÌI"        var.request_pty { |arglist| yield(var, var) }
      else
        yield(var, true)
      end
    end
    
    def function(arglist)
      var = (@var.configuration and @var.configuration.role_names_for_host(var[:server]))
      var = var.gsub(/\$CAPISTRANO:HOST\$/, var[:host]);Fi[	@˛i I"ˇ          if var then
            var = var.is_a?(Numeric) ? (var.to_s(8)) : (var.to_s)
            run("chmod #{mode} #{to}", var)
          end
        end
        
        def function(arglist)
          transfer(:down, var, var, var, &var)
        end;Fi[	@
iI"          else
            var.each { |arglist| var.skip! unless continue_execution_for_branch(var) }
            var.any? { |arglist| var.skip?.! }
          end
        end
        
        def function(arglist)
          case Capistrano::CLI.debug_prompt(var)
          when "y" then;Fi[	@i0I"]              @var[:logger].debug("Creating gateway using #{[*gateway].join(", ")}")
            end
            @var[:default] = add_gateway(var)
          end
        end
        
        def function(arglist)
          var = [*var].collect { |arglist| ServerDefinition.new(var) }
          var = SSH.connection_strategy(var[0], @var) do |arglist|;Fi[	@i>I"5            SSH.connection_strategy(var, @var) do |arglist|
              Net::SSH::Gateway.new(var, var, var)
            end
          end
        end
        
        def function(arglist)
          if @var[:logger] then
            @var[:logger].debug("establishing connection to `#{server}' via gateway");Fi[	@ i}I"ø          ensure
            pop_task_call_frame
          end
        end
      end
      
      def function(arglist)
        var = TaskCallFrame.new(var)
        task_call_frames.push(var);Fi[	@.iI"Ì          var.each { |arglist| Capistrano::Logger.add_formatter(var) }
        else
          Capistrano::Logger.add_formatter(var)
        end
      end
      
      def function(arglist)
        @var.disable_formatters = true
      end;Fi[	@4iQI"„            end.flatten
            var.select { |arglist| var.include?(var) }
          end
        end
      end
      
      def function(arglist)
        var = var.split(/,/) if String.===(var)
        var = build_list(var);Fi[	@4iYI"        var = build_list(var)
        var.map do |arglist|
          String.===(var) ? (ServerDefinition.new(var.strip)) : (var)
        end
      end
      
      def function(arglist)
        var = var.split(/,/) if String.===(var)
        var = build_list(var);Fi[	@4ibI"        var.map do |arglist|
          var = String.===(var) ? (var.strip.to_sym) : (var)
          var
        end
      end
      
      def function(arglist)
        Array(var).map { |arglist| var.respond_to?(:call) ? (var.call) : (var) }.flatten
      end;Fi[	@ñiI"Ô            distribute!)
          ensure
            rollback_changes
          end
        end
        
        def function(arglist)
          if build_script then
            execute("running build script on #{directory}") do |arglist|;Fi[	@ñi I"H            execute("running build script on #{directory}") do |arglist|
              Dir.chdir(var) { |arglist| system(build_script) }
            end
          end
        end
        
        def function(arglist)
          super.check do |arglist|
            var.local.command(source.local.command) if source.local.command;Fi[	@ñiRI"y        def function(arglist)
          execute("refreshing local cache to revision #{revision} at #{copy_cache}") do |arglist|
            system(source.sync(revision, copy_cache))
          end
        end
        
        def function(arglist)
          execute("preparing local cache at #{copy_cache}") do |arglist|
            system(source.checkout(revision, copy_cache));Fi[	@ñiXI"?        def function(arglist)
          execute("preparing local cache at #{copy_cache}") do |arglist|
            system(source.checkout(revision, copy_cache))
          end
        end
        
        def function(arglist)
          raise(Capistrano::Error, "shell command failed with return code #{$?}")
        end;Fi[	@ñigI"6          execute("copying cache to deployment staging area #{destination}") do |arglist|
            create_destination
            Dir.chdir(copy_cache) { |arglist| copy_files(queue_files) }
          end
        end
        
        def function(arglist)
          FileUtils.mkdir_p(destination)
        end;Fi[	@ñiáI"        def function(arglist)
          Dir.glob(pattern_for(var), File::FNM_DOTMATCH).reject! do |arglist|
            excluded_files_contain?(var)
          end
        end
        
        def function(arglist)
          var.nil?.! ? ("#{directory}/*") : ("*")
        end;Fi[	@ñiïI"        def function(arglist)
          execute("getting (via #{copy_strategy}) revision #{revision} to #{destination}") do |arglist|
            copy_repository_via_strategy
          end
        end
        
        def function(arglist)
          system(command)
        end;Fi[	@ñi¢I"W            var = Dir.glob(File.join(destination, var), File::FNM_DOTMATCH)
            var.delete_if { |arglist| var =~ /\/\.\.$/ }
            FileUtils.rm_rf(var.compact)
          end
        end
        
        def function(arglist)
          File.open(File.join(destination, "REVISION"), "w") do |arglist|
            var.puts(revision);Fi[	@ñi®I"@        def function(arglist)
          File.open(File.join(destination, "REVISION"), "w") do |arglist|
            var.puts(revision)
          end
        end
        
        def function(arglist)
          execute("Compressing #{destination} to #{filename}") do |arglist|
            Dir.chdir(copy_dir) do |arglist|;Fi[	@ñi∞I"9            Dir.chdir(copy_dir) do |arglist|
              system(compress(File.basename(destination), File.basename(filename)).join(" "))
            end
          end
        end
        
        def function(arglist)
          FileUtils.rm(filename) rescue nil
          FileUtils.rm_rf(destination) rescue nil;Fi[	@•i+I"Y          else
            var = copy_exclude.map { |arglist| "--exclude=\"#{e}\"" }.join(" ")
            run("rsync -lrpt #{exclusions} #{repository_cache}/ #{configuration[:release_path]} && #{mark}")
          end
        end
        
        def function(arglist)
          @var ||= Array(configuration.fetch(:copy_exclude, []))
        end;Fi[	I"8data//capistrano_proj/capistrano/task_definition.rb;TiI"        namespace.fully_qualified_name
      else
        [namespace.fully_qualified_name, name].compact.join(":")
      end
    end
    
    def function(arglist)
      if var.respond_to?(:to_sym).! then
        raise(ArgumentError, "expected a valid task name");Fi[	@¬ieI"        else
          raise(ArgumentError, "unsupported transport type: #{transport.inspect}")
        end
      end
    end
    
    def function(arglist)
      var = (callback or Proc.new do |arglist|
        logger.trace("[#{channel[:host]}] #{name}") if logger and (var == 0);Fi[	@¬iâI"ª      
      def function(arglist)
        @var.abort!
      end
    end
    
    def function(arglist)
      SFTPTransferWrapper.new(var) do |arglist|
        var = Proc.new do |arglist|;Fi[	@¬i£I"˙        else
          raise(ArgumentError, "unsupported transfer direction: #{direction.inspect}")
        end
      end
    end
    
    def function(arglist)
      if var.is_a?(String) then
        var.gsub(/\$CAPISTRANO:HOST\$/, var.xserver.host);Fi[	@¬i≤I"¬        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("expected a file to upload")
      var = session_map[var.session];Fi[	I"*data//compass_proj/compass/actions.rb;Ti>I"˚        var = "w"
        (var << "b") if var
        open(var, var) { |arglist| var.write(var) }
      end
    end
    
    def function(arglist)
      var = Object.new.instance_eval("binding") unless var.is_a?(Binding)
      ERB.new(var).result(var);Fi[	@iPI"Ã          File.unlink(var)
          log_action(:remove, basename(var), options)
        end
      end
    end
    
    def function(arglist)
      relativize(var) { |arglist| File.basename(var) }
    end;Fi[	@Õi%I"             Compass.configuration.serialize)
          ensure
            Compass.configuration.project_path = var
          end
        end
        
        def function(arglist)
          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files;Fi[	@Õi+I"Ó        def function(arglist)
          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@Õi:I"Y          if manifest.has_stylesheet? and manifest.welcome_message_options[:replace].! then
            puts("\nTo import your new stylesheets add the following lines of HTML (or equivalent) to your webpage:")
            puts(stylesheet_links)
          end
        end
        
        def function(arglist)
          @var.compile?
        end;Fi[	I"2data//compass_proj/compass/app_integration.rb;TiI"“          raise(Compass::Error, "No application integration exists for #{type}")
        else
          eval(@var[var])
        end
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	I"2data//compass_proj/compass/browser_support.rb;Ti5I"˙          next
        end
        SIMPLE_FUNCTIONS[var.to_s].reject! { |arglist| (var == var.to_s) }
      end
    end
    
    def function(arglist)
      SIMPLE_FUNCTIONS.has_key?(var.to_s) and SIMPLE_FUNCTIONS[var.to_s].include?(var.to_s)
    end;Fi[	@ÿiI"          Compass::Installers::BareInstaller.new(*installer_args)
        else
          app.installer(*installer_args)
        end
      end
      
      def function(arglist)
        [template_directory((options[:pattern] or "project")), project_directory, options]
      end;Fi[	@€i*I"¯        end
        Compass.add_project_configuration(options[:configuration_file], :defaults => (var)) do |arglist|
          options[:project_type]
        end
      end
      
      def function(arglist)
        Compass.projectize(var)
      end;Fi[	@€iRI"           File.basename(strip_trailing_separator(var[:project_name]))
        else
          File.basename(var)
        end
      end
      
      def function(arglist)
        if var[:project_name] then
          if absolute_path?(var[:project_name]) then;Fi[	@€i^I"∞          end
        else
          var
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end;Fi[	@ﬁi!I"Â            raise(Compass::Error, "Command not found: #{name}")
          end
        end
      end
    end
    
    def function(arglist)
      var = /^#{Regexp.escape(var)}/
      @var.keys.detect { |arglist| var.to_s.=~(var) };Fi[	I"+data//compass_proj/compass/compiler.rb;Ti.I"'        var[((from.length + 1)..-6)].sub(/\.css$/, "")
      else
        raise(Compass::Error, "You must compile individual stylesheets from the project directory.")
      end
    end
    
    def function(arglist)
      @var ||= sass_files.map { |arglist| corresponding_css_file(var) }
    end;Fi[	@9iwI"ƒ        compile(var, var)
      else
        logger.record(:unchanged, basename(var)) unless options[:quiet]
      end
    end
    
    def function(arglist)
      var = Time.now
      var = yield;Fi[	@·i-I"¥          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end;Fi[	@‰iI"˛          ""
        else
          "# Set this to the root of your project when deployed:\nhttp_path = #{top_level.http_path.to_s.inspect}\n"
        end
      end
      
      def function(arglist)
        if top_level.relative_assets then
          "";Fi[	@‰iI"x          ""
        else
          "# To enable relative paths to assets via compass helper functions. Uncomment:\n# relative_assets = true\n"
        end
      end
      
      def function(arglist)
        if top_level.line_comments then
          "# To disable debugging comments that display the original location of your selectors. Uncomment:\n# line_comments = false\n";Fi[	@‰iI"          "# To disable debugging comments that display the original location of your selectors. Uncomment:\n# line_comments = false\n"
        else
          ""
        end
      end
      
      def function(arglist)
        if top_level.output_style_without_default then
          "";Fi[	@‰i%I"u          ""
        else
          "# You can select your preferred output style here (can be overridden via the command line):\n# output_style = :expanded or :nested or :compact or :compressed\n"
        end
      end
      
      def function(arglist)
        if (top_level.preferred_syntax == :scss) and top_level.sass_dir then
          "\n# If you prefer the indented syntax, you might want to regenerate this\n# project again passing --syntax sass, or you can uncomment this:\n# preferred_syntax = :sass\n# and then run:\n# sass-convert -R --from scss --to sass #{top_level.sass_dir} scss && rm -rf sass && mv scss sass\n";Fi[	@ÈiÇI"ô              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= []
        (@var << [var, var]);Fi[	@Ùi/I"5      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then
          Compass.projectize(var, var);Fi[	@Ùi5I"7      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then
          Compass.projectize(var, var);Fi[	@Ùi;I"D      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.generated_images_dir then
          Compass.projectize(var, var);Fi[	@ÙiCI"          Compass.projectize(var, var)
        else
          top_level.images_path
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.javascripts_dir then
          Compass.projectize(var, var);Fi[	@ÙiII"C      def function(arglist)
        if var = top_level.project_path and var = top_level.javascripts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then
          Compass.projectize(var, var);Fi[	@ÙiOI"=      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then
          Compass.projectize(var, var);Fi[	@ÙiUI"8      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then
          Compass.projectize(var, var);Fi[	@Ùi[I"Ì      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        top_level.images_dir
      end;Fi[	@Ùi~I"∆          var
        else
          "#{top_level.http_stylesheets_dir}/fonts"
        end
      end
      
      def function(arglist)
        http_root_relative(top_level.http_fonts_dir)
      end;Fi[	@˙iWI"‹            Compass.configuration.run_stylesheet_error(var, var.message)
          end
          @var = true
        end
      end
      
      def function(arglist)
        configuration.to_sass_engine_options
      end;Fi[	@˙ipI"p          add_configuration(var)
        else
          add_configuration((var[:project_type] or (configuration.project_type_without_default or (yield if block_given? or :stand_alone))))
        end
      end
      
      def function(arglist)
        Compass.shared_extension_paths.each do |arglist|
          Compass::Frameworks.discover(var) if File.directory?(var);Fi[	@iI"§          var.each do |arglist|
            var = (44 + 1)
            class_eval("\n              def raw_#{attribute}                         # def raw_css_dir\n                @#{attribute}                              #   @css_dir\n              end                                          # end\n              def #{attribute}_without_default             # def css_dir_without_default\n                read_without_default(#{attribute.inspect}) #  read_without_default(:css_dir)\n              end                                          # end\n              def #{attribute}                             # def css_dir\n                read(#{attribute.inspect})                 #  read(:css_dir)\n              end                                          # end\n            ", "(string)", var)
          end
        end
        
        def function(arglist)
          inherited_reader(*var)
          inherited_writer(*var);Fi[	@iFI"G                var.each { |arglist| (var << "#{prop} >> #{r.inspect}\n") }
              end
              (var[(-1..-1)] == "\n") ? (var[(0..-2)]) : (var)
            end
          end
          
          def function(arglist)
            var = to_ary
            var.respond_to?(var) ? (var.send(var, *var, &var)) : (super);Fi[	@iLI"          def function(arglist)
            var = to_ary
            var.respond_to?(var) ? (var.send(var, *var, &var)) : (super)
          end
        end
        
        def function(arglist)
          inherited_reader(*var)
          inherited_writer(*var);Fi[	@iUI"
          var.each do |arglist|
            var = (116 + 1)
            class_eval("\n              def #{attr}                                          # def sprite_load_paths\n                ArrayProxy.new(self, #{attr.inspect})              #   ArrayProxy.new(self, :sprite_load_paths)\n              end                                                  # end\n              def #{attr}=(value)                                  # def sprite_load_paths=(value)\n                @set_attributes ||= {}                             #   @set_attributes ||= {}\n                @set_attributes[#{attr.inspect}] = true            #   @set_attributes[:sprite_load_paths] = true\n                @#{attr} = Array(value)                            #   @sprite_load_paths = Array(value)\n                @added_to_#{attr} = []                             #   @added_to_sprite_load_paths = []\n                @removed_from_#{attr} = []                         #   @removed_from_sprite_load_paths = []\n              end                                                  # end\n              def read_inherited_#{attr}_array                     # def read_inherited_sprite_load_paths_array\n                if #{attr}_set?                                    #  if sprite_load_paths_set?\n                  @#{attr}                                         #    Array(@#{attr})\n                else                                               #  else\n                  value = if inherited_data                        #    value = Array(read(:sprite_load_paths))\n                    Array(inherited_data.#{attr})\n                  else\n                    Array(read(#{attr.inspect}))\n                  end\n                  value -= Array(@removed_from_#{attr})            #    value -= Array(@removed_from_sprite_load_paths)\n                  Array(@added_to_#{attr}) + value                 #    Array(@added_to_sprite_load_paths) + value\n                end                                                #  end\n              end                                                  # end\n              def add_to_#{attr}(v)                                # def add_to_sprite_load_paths(v)\n                if #{attr}_set?                                    #   if sprite_load_paths_set?\n                  raw_#{attr} << v                                 #     raw_sprite_load_paths << v\n                else                                               #   else\n                  (@added_to_#{attr} ||= []) << v                  #     (@added_to_sprite_load_paths ||= []) << v\n                end                                                #   end\n              end                                                  # end\n              def remove_from_#{attr}(v)                           # def remove_from_sprite_load_paths(v)\n                if #{attr}_set?                                    #   if sprite_load_paths_set?\n                  raw_#{attr}.reject!{|e| e == v}                  #     raw_sprite_load_path.reject!{|e| e == v}s\n                else                                               #   else\n                  (@removed_from_#{attr} ||= []) << v              #     (@removed_from_sprite_load_paths ||= []) << v\n                end                                                #   end\n              end                                                  # end\n            ", "(string)", var)
          end
        end
        
        def function(arglist)
          var = (160 + 1)
          class_eval("\n            alias_method :_chained_#{method}, method\n            def #{method}(*args, &block)\n              _chained_#{method}(*args, &block)\n              if inherited_data\n                inherited_data.#{method}(*args, &block)\n              end\n            end\n          ", "(string)", var);Fi[	@igI"-          self.top_level = var
          if self.inherited_data.respond_to?(:set_top_level) then
            self.inherited_data.set_top_level(var)
          end
        end
        
        def function(arglist)
          if self.inherited_data then
            self.inherited_data.inherit_from!(var);Fi[	@i´I"ÿ            var
          else
            top_level.default_for(var)
          end
        end
        
        def function(arglist)
          if inherited_data then
            inherited_data.send(var, *var, &var);Fi[	@i≥I"‘            inherited_data.send(var, *var, &var)
          else
            raise(NoMethodError, var.to_s)
          end
        end
        
        def function(arglist)
          if super then
            true;Fi[	@iªI"Î            true
          else
            inherited_data ? (inherited_data.respond_to?(var)) : (false)
          end
        end
        
        def function(arglist)
          var = [self]
          while var.last.inherited_data do;Fi[	@
iII"9          (var.serialize_to_config(var) + "\n")
        else
          "#{prop} = #{value.inspect}\n"
        end
      end
      
      def function(arglist)
        if (http_images_path == :relative) then
          $stderr.puts("DEPRECATION WARNING: Please set relative_assets = true to enable relative paths.");Fi[	I"/data//compass_proj/compass/exec/helpers.rb;TiI"˜        var.backtrace[(1..-1)].each { |arglist| $stderr.puts("  #{t}") }
      else
        $stderr.puts("Run with --trace to see the full backtrace")
      end
    end
    
    def function(arglist)
      var.backtrace[0].split(/:/, 2)[0]
    end;Fi[	I">data//compass_proj/compass/exec/project_options_parser.rb;TiI"@      self.options[:"#{var}_path"] = var.tr("\\", "/")
    else
      self.options[:"#{var}_dir"] = var.tr("\\", "/")
    end
  end
  
  def function(arglist)
    var.on("-c", "--config CONFIG_FILE", "Specify the location of the configuration file explicitly.") do |arglist|
      self.options[:configuration_file] = var;Fi[	I"1data//compass_proj/compass/exec/switch_ui.rb;TiI":      end
      var.on("--boring", :NONE, "Turn off colorized output.") do |arglist|
        self.options[:color_output] = false
      end
    end
    
    def function(arglist)
      var = var.to_s.split(/_/).map { |arglist| var.capitalize }.join("")
      var = eval("::Compass::Commands::#{command_class_name}");Fi[	I"-data//compass_proj/compass/frameworks.rb;Ti%I"™          end
        else
          []
        end
      end
      
      def function(arglist)
        File.join(templates_directory, var.to_s, "manifest.rb")
      end;Fi[	@{i/I"“      def function(arglist)
        var[:pattern_name] ||= var
        Compass::Installers::Manifest.new(manifest_file(var), var)
      end
    end
    
    def function(arglist)
      begin
        (@var = nil;Fi[	@{i9I"≠        @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      @var = Framework.new(var, *var)
      if var = ALL.index(self[var]) then;Fi[	@{iBI"¨        ALL[var] = @var
      else
        (ALL << @var)
      end
    end
    
    def function(arglist)
      ALL.detect { |arglist| (var.name.to_s == var.to_s) }
    end;Fi[	@{ioI"»        else
          "          No Usage!\n".gsub(/^ {8}/, "")
        end
      end
    end
    
    def function(arglist)
      var = ""
      var = Compass::Frameworks::ALL.inject(0) do |arglist|;Fi[	@i I"O          Compass.configuration.serialize)
        ensure
          Compass.configuration.project_path = var
        end
      end
      
      def function(arglist)
        puts("\n*********************************************************************\nCongratulations! Your compass project has been created.\n\nYou may now add sass stylesheets to the #{Compass.configuration.sass_dir} subdirectory of your project.\n\nSass files beginning with an underscore are called partials and won't be\ncompiled to CSS, but they can be imported into other sass stylesheets.\n\nYou can configure your project by editing the config.rb configuration file.\n\nYou must compile your sass stylesheets into CSS when they change.\nThis can be done in one of the following ways:\n  1. To compile on demand:\n     compass compile [path/to/project]\n  2. To monitor your project for changes and automatically recompile:\n     compass watch [path/to/project]\n\nMore Resources:\n  * Website: http://compass-style.org/\n  * Sass: http://sass-lang.com\n  * Community: http://groups.google.com/group/compass-users/\n")
      end;Fi[	@iGI"¸          var = :file if var.nil?
          var = :directory if File.directory?(var)
          send(var, var, var) if ((var == :all) or (var == var))
        end
      end
      
      def function(arglist)
        var ? (@var = var) : (@var)
      end;Fi[	@iVI"à          @var = var
        else
          @var
        end
      end
      
      def function(arglist)
        (@var or {})
      end;Fi[	@iÅI"®          else
            eval("discover :all", instance_binding, var)
          end
        end
      end
      
      def function(arglist)
        binding
      end;Fi[	@i&I"      def function(arglist)
        manifest.each do |arglist|
          send("install_#{entry.type}", var.from, var.to, var.options)
        end
      end
      
      def function(arglist)
        var = "<head>\n"
        manifest.each_stylesheet do |arglist|;Fi[	@iI"“          define_method(var) do |arglist|
            (config.send(var) or config.default_for(var))
          end
        end
      end
      
      def function(arglist)
        Compass.configuration
      end;Fi[	I")data//compass_proj/compass/logger.rb;Ti'I"º      ensure
        ($stderr.write(color(:clear))
        $stdout.write(color(:clear)))
      end
    end
    
    def function(arglist)
      begin
        ($stderr.write(color(:yellow));Fi[	@íi2I"-      ensure
        ($stderr.write(color(:clear))
        $stdout.write(color(:clear)))
      end
    end
    
    def function(arglist)
      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("") : ("[#{COLORS[c.to_sym]}m");Fi[	@íi:I"®        defined? $boring and $boring ? ("") : ("[#{COLORS[c.to_sym]}m")
      else
        ""
      end
    end
    
    def function(arglist)
      print(var)
    end;Fi[	@!iCI"{          var
        end
      end
    end
  end
  
  def function(arglist)
    CSS2FallbackValue.new(var, var)
  end;Fi[	@$i7I""    module ClassMethods
      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end
    end
    
    def function(arglist)
      to_s
    end;Fi[	@$ihI"        var.div(Sass::Script::Number.new(1, var.numerator_units, var.denominator_units))
      else
        var ? (var) : (var)
      end
    end
    
    def function(arglist)
      var, var = *grad_point(var).value
      var, var = *grad_point(opposite_position(var)).value;Fi[	@$i¢I"        Sass::Script::List.new(var, var.separator)
      else
        var.class.new(*var)
      end
    end
    
    def function(arglist)
      return ColorStop.new(var) if var.is_a?(Sass::Script::Color)
      return nil unless var.is_a?(Sass::Script::String);Fi[	@$iƒI"“        end
      else
        var.all? { |arglist| color_stop?(var) } ? (var) : (nil) if var.is_a?(Array)
      end
    end
    
    def function(arglist)
      var = ""
      if angle?(position_or_angle) then;Fi[	I"Idata//compass_proj/compass/sass_extensions/functions/inline_image.rb;Ti=I"!      "image/#{Regexp.last_match(1).downcase}"
    else
      raise(Compass::Error, "A mime type could not be determined for #{path}, please specify one explicitly.")
    end
  end
  
  def function(arglist)
    if File.readable?(var) then
      File.open(var, "rb") { |arglist| var.read };Fi[	I"Ddata//compass_proj/compass/sass_extensions/functions/sprites.rb;Ti¡I"ø      Sass::Script::Color::HTML4_COLORS_REVERSE
    else
      Sass::Script::Color::COLOR_NAMES_REVERSE
    end
  end
  
  def function(arglist)
    case var
    when Sass::Script::Color then;Fi[	@¶iÃI"∆      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then
      missing_sprite!(var);Fi[	@¶i“I"|  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then
      missing_sprite!(var)
    end
  end
  
  def function(arglist)
    unless var.is_a?(Sass::Script::String) then
      raise(Sass::SyntaxError, "The second argument to sprite() must be a sprite name. See http://beta.compass-style.org/help/tutorials/spriting/ for more information.");Fi[	@¶iÿI"º  def function(arglist)
    unless var.is_a?(Sass::Script::String) then
      raise(Sass::SyntaxError, "The second argument to sprite() must be a sprite name. See http://beta.compass-style.org/help/tutorials/spriting/ for more information.")
    end
  end
  
  def function(arglist)
    raise(Sass::SyntaxError, "No sprite called #{sprite} found in sprite map #{map.path}/#{map.name}. Did you mean one of: #{map.sprite_names.join(", ")}")
  end;Fi[	I"Adata//compass_proj/compass/sass_extensions/functions/urls.rb;TiI"      if var.respond_to?(:declare) then
        var.declare(:stylesheet_url, [:path])
        var.declare(:stylesheet_url, [:path, :only_path])
      end
    end
    
    def function(arglist)
      var = if relative? then
        compute_relative_path(Compass.configuration.css_path);Fi[	@Øi3I"      if var.respond_to?(:declare) then
        var.declare(:font_url, [:path])
        var.declare(:font_url, [:path, :only_path])
      end
    end
    
    def function(arglist)
      var = var.value
      return Sass::Script::String.new("url(#{path})") if absolute_path?(var);Fi[	@ØiMI"?        var.declare(:image_url, [:path])
        var.declare(:image_url, [:path, :only_path])
        var.declare(:image_url, [:path, :only_path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_images_path)}\/(.*)/ then;Fi[	@ØiI"D      if var.respond_to?(:declare) then
        var.declare(:generated_image_url, [:path])
        var.declare(:generated_image_url, [:path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_generated_images_path)}\/(.*)/ then;Fi[	@ØiªI"¯  def function(arglist)
    if var = options[:css_filename] then
      Pathname.new(var).relative_path_from(Pathname.new(File.dirname(var))).to_s
    end
  end
  
  def function(arglist)
    var = compute_cache_buster(var, var)
    if var.nil? then;Fi[	@Øi’I"◊      Compass.configuration.asset_cache_buster.call(*var)
    else
      default_cache_buster(var, var) if var
    end
  end
  
  def function(arglist)
    if File.readable?(var) then
      File.mtime(var).to_i.to_s;Fi[	I"Qdata//compass_proj/compass/sass_extensions/monkey_patches/browser_support.rb;TiI")      return true if Compass::BrowserSupport.supports?(name, var)
      children.any? do |arglist|
        var.respond_to?(:supports?) and var.supports?(var)
      end
    end
    
    def function(arglist)
      var ||= self.children
      return true if Compass::BrowserSupport.has_aspect?(name);Fi[	@ºi;I"ﬁ    else
      def function(arglist)
        Script::String.new("#{name}(#{args.join(", ")})")
      end
    end
    
    def function(arglist)
      if has_aspect?(var) then
        CrossBrowserFunctionCall.new(name, var);Fi[	@ºiKI"    def function(arglist)
      children.any? do |arglist|
        var.respond_to?(:supports?) and var.supports?(var)
      end
    end
    
    def function(arglist)
      children.any? { |arglist| var.respond_to?(:has_aspect?) and var.has_aspect? }
    end;Fi[	@.iI"=          images.each do |arglist|
            var = ChunkyPNG::Image.from_file(var.file)
            canvas.replace!(var, var.left, var.top)
          end
        end
        
        def function(arglist)
          construct_sprite if canvas.nil?
          canvas.save(var, Compass.configuration.chunky_png_options);Fi[	@GiAI"<              calculate_repeat_extra_width!
              tile_images_that_repeat
            end)
          end
        end
        
        def function(arglist)
          @var.map { |arglist| var if var.repeat_x? }.compact.each do |arglist|
            var = (var.left - ((var.left / var.width).ceil * var.width));Fi[	@GiNI"
              (@var << var)
              var = (var + var.width)
            end
          end
        end
        
        def function(arglist)
          require("rational")
          var = @var.inject(1) { |arglist| var.repeat_x? ? (var.lcm(var.width)) : (var) };Fi[	@GiyI"            var.top = (var.top - var.height)
            var.left = (var.left + var.width)
            var = var
          end
        end
        
        def function(arglist)
          @var.each_with_index do |arglist|
            var.top = if (var.position.unit_str == "%") then;Fi[	@GiÅI"=            next if (var == 0)
            var = @var[(var - 1)]
            var.left = ((var.left + var.width) + [var.spacing, var.spacing].max)
          end
        end
        
        def function(arglist)
          @var.each_with_index do |arglist|
            var.left = (if (var.position.unit_str == "%") then;Fi[	@GiéI"            next if (var == 0)
            var = @var[(var - 1)]
            var.top = ((var.top + var.height) + [var.spacing, var.spacing].max)
          end
        end
        
        def function(arglist)
          var = @var.last
          (var.top + var.height);Fi[	@Wi I"          Compass.configuration.sprite_load_path.each do |arglist|
            var = File.expand_path(var)
            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var;Fi[	@\i)I"            unless var =~ /\A#{Sass::SCSS::RX::IDENT}\Z/ then
              raise(Sass::SyntaxError, "#{sprite_name} must be a legal css identifier")
            end
          end
        end
        
        def function(arglist)
          "#{path}-s#{uniqueness_hash}.png"
        end;Fi[	@\iBI"            save!
          else
            log(:unchanged, filename)
          end
        end
        
        def function(arglist)
          Dir[File.join(Compass.configuration.generated_images_path, "#{path}-s*.png")].each do |arglist|
            log(:remove, var);Fi[	I"2data//compass_proj/compass/sprite_importer.rb;Ti5I".    def function(arglist)
      self.class.files(var).sort.inject(Time.at(0)) do |arglist|
        ((var = File.mtime(var)) > var) ? (var) : (var)
      end
    end
    
    def function(arglist)
      [((self.class.name + ":sprite:") + File.dirname(File.expand_path(var))), File.basename(var)]
    end;Fi[	@ii#I"©        else
          @var = true
          @var.dup(var)
        end
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init;Fi[	@ii1I"          var.visit_steps(@var)
          @var = @var.detect { |arglist| (var.exception or var.status.!=(:passed)) }
          var.step_mother.after(hook_context) if (@var or @var.empty?)
        end
      end
      
      def function(arglist)
        @var = var
        init;Fi[	@ii;I"º          var.with_visitor(var) { |arglist| yield }
        else
          yield
        end
      end
      
      def function(arglist)
        init
        if hook_context.!=(self) then;Fi[	@iiDI"           hook_context.accept_hook?(var)
        else
          @var.accept_hook?(var)
        end
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
      end;Fi[	@ui!I"ß        @var.each do |arglist|
          var.init
          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@xi1I"‡              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("U*").length)
            end
          end
        end
      end
      
      def function(arglist)
        var.detect { |arglist| var.=~(name) }
      end;Fi[	@ÉixI"!              @var.each { |arglist| var.visit_table_cell(var) }
              var.visit_exception(@var, :failed) if @var
            end
          end
        end
        
        def function(arglist)
          unless header? then
            var.step_mother.with_hooks(self) do |arglist|;Fi[	@ÉiÄI"∫                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end;Fi[	@äiI"˜        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist)
        @var = (var or EmptyBackground.new)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var;Fi[	@êiiI"˝          var = (var + 1)
          var = delimited(var.value)
          (@var.index(var) or (@var and @var.has_text?(var)))
        end
      end
      
      def function(arglist)
        var.inject({}) do |arglist|
          var[delimited(var)] = var;Fi[	@êipI"©        var.inject({}) do |arglist|
          var[delimited(var)] = var
          var
        end
      end
      
      def function(arglist)
        "<#{s}>"
      end;Fi[	@ñi[I",      def function(arglist)
        unless raw[0].include?(var) then
          raise("The column named \"#{column_name}\" does not exist")
        end
      end
      
      def function(arglist)
        unless (raw[0].size == var) then
          raise("The table must have exactly #{width} columns");Fi[	@ñiaI"ˇ      def function(arglist)
        unless (raw[0].size == var) then
          raise("The table must have exactly #{width} columns")
        end
      end
      
      def function(arglist)
        var = raw.map do |arglist|
          var.map do |arglist|;Fi[	@ñiØI"ø            var.inspect!
            var.inspect!
          end
        end
      end
      
      def function(arglist)
        @var = var.map do |arglist|
          var = var.line rescue -1;Fi[	@ñi∂I"%        @var = var.map do |arglist|
          var = var.line rescue -1
          var.map { |arglist| new_cell(var, var) }
        end
      end
      
      def function(arglist)
        @var.each { |arglist| verify_column(var) if var[:strict] }
        cell_matrix.transpose.each do |arglist|;Fi[	@ñiøI"Ú          var = var[0].value
          var = @var[var][:proc]
          var[(1..-1)].each { |arglist| var.value = var.call(var.value) }
        end
      end
      
      def function(arglist)
        var = cell_matrix[0]
        if @var then;Fi[	@ñi⁄I"›        rescue LoadError => var
          (var.message << "\n Please gem install diff-lcs\n")
          raise(var)
        end
      end
      
      def function(arglist)
        @var = @var = @var = @var = nil
      end;Fi[	@ûi\I"ˇ          visit_step_name(var, var, var, var, var, var)
          visit_multiline_arg(var) if var
          visit_exception(var, var) if var
        end
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end;Fi[	@§iVI"È          constantize(var[0])
        else
          constantize(var)
        end
      end
      
      def function(arglist)
        var = @var[:require].empty? ? (require_dirs) : (@var[:require])
        var = var.map do |arglist|;Fi[	@§i∑I"◊      class LogFormatter < ::Logger::Formatter
        def function(arglist)
          var
        end
      end
      
      def function(arglist)
        @var[:env_vars].each { |arglist| ENV[var] = var }
      end;Fi[	@§iƒI"P        var = @var[:formats].map { |arglist| var }
        if var.!=(var.uniq) then
          raise("All but one formatter must use --out, only one can print to each stream (or STDOUT)")
        end
      end
      
      def function(arglist)
        var.reject! { |arglist| @var[:excludes].detect { |arglist| var.=~(var) } }
      end;Fi[	@ßiI"¨      class << self
        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var;Fi[	@ßi2I"˛        rescue ProfilesNotDefinedError, YmlLoadError, ProfileNotFound => var
          @var.puts(var.message)
          true
        end
      end
      
      def function(arglist)
        return @var if @var
        @var = Configuration.new(@var, @var);Fi[	@ßiFI"          true)
        rescue DRbClientError => var
          @var.puts("WARNING: #{e.message} Running features locally:")
        end
      end
      
      def function(arglist)
        trap("INT") do |arglist|
          exit!(1) if Cucumber.wants_to_quit;Fi[	@¨i˜I"Q        @var.each do |arglist|
          var = profile_loader.args_from(var)
          reverse_merge(Options.parse(var, @var, @var, :skip_profile_information => (true)))
        end
      end
      
      def function(arglist)
        @var.empty? and (profile_loader.cucumber_yml_defined? and profile_loader.has_profile?(@var))
      end;Fi[	@≤i2I"ˇ      rescue Gherkin::Lexer::LexingError, Gherkin::Parser::ParseError => var
        var.message.insert(0, "#{@path}: ")
        raise(var)
      end
    end
    
    def function(arglist)
      @var ||= if @var =~ /^http/ then
        require("open-uri");Fi[	@∏i8I"          end
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        @var = step_mother.scenarios(:failed).select do |arglist|
          (var.is_a?(Cucumber::Ast::Scenario) or var.is_a?(Cucumber::Ast::OutlineTable::ExampleRow));Fi[	@∏iÖI"          print_elements(var, :passed, "scenarios")
        else
          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@∏ióI"Ó            var.each { |arglist| @var.puts(format_string(var, :tag)) }
            @var.flush
          end
        end
      end
      
      def function(arglist)
        @var.each { |arglist| print_message(var) }
        empty_messages;Fi[	@¡i#I"          @var.scenario_outline(var.gherkin_statement)
        else
          raise("Bad type: #{feature_element.class}")
        end
      end
      
      def function(arglist)
        @var.step(var.gherkin_statement)
        if @var then;Fi[	@¡i/I"            var = Gherkin::Formatter::Model::Match.new([], nil)
          end
          @var.match(var)
        end
      end
      
      def function(arglist)
        var = var.step_arguments.map do |arglist|
          Gherkin::Formatter::Argument.new(var.offset, var.val);Fi[	@¡i@I"‡        end
        unless @var then
          @var.result(Gherkin::Formatter::Model::Result.new(var, nil, var))
        end
      end
      
      def function(arglist)
        @var.examples(var.gherkin_statement)
      end;Fi[	@«i'I"µ          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "img_#{@img_id}"
        @var = (@var + 1);Fi[	@«i/I"3        @var = (@var + 1)
        @var.span(:class => "embed") do |arglist|
          (var << "<a href=\"\" onclick=\"img=document.getElementById('#{id}'); img.style.display = (img.style.display == 'none' ? 'block' : 'none');return false\">#{label}</a><br>&nbsp;\n          <img id=\"#{id}\" style=\"display: none\" src=\"#{src}\"/>")
        end
      end
      
      def function(arglist)
        @var = get_step_count(var)
        @var.declare!(:DOCTYPE, :html, :PUBLIC, "-//W3C//DTD XHTML 1.0 Strict//EN", "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");Fi[	@«iII"√              @var.p("Collapse All", :id => "collapser")
            end
          end
        end
      end
      
      def function(arglist)
        print_stats(var)
        (@var << "</div>");Fi[	@«i|I"ø            @var.text!(var.strip)
            @var.br
          end
        end
      end
      
      def function(arglist)
        @var = true
        (@var << "<div class=\"background\">");Fi[	@«iäI"Ÿ          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = (@var + 1)
        @var = false;Fi[	@«i†I"ﬂ          @var.span((var + ":"), :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = 0
        (@var << "<table>");Fi[	@«i∫I"Õ          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        (@var << "<ol>")
      end;Fi[	@«iI"€        return if @var
        @var.pre(:class => "val") do |arglist|
          (@var << h(var).gsub("\n", "&#x000A;"))
        end
      end
      
      def function(arglist)
        @var = var.dom_id
        @var = 0;Fi[	@«ipI"          @var = true
          @var.text!("makeRed('scenario_#{@scenario_number}');") unless @var
          @var = true
        end
      end
      
      def function(arglist)
        @var.script do |arglist|
          @var.text!("makeYellow('cucumber-header');") unless @var;Fi[	@«iwI"1        @var.script do |arglist|
          @var.text!("makeYellow('cucumber-header');") unless @var
          @var.text!("makeYellow('scenario_#{@scenario_number}');") unless @var
        end
      end
      
      def function(arglist)
        var = 0
        var = var.instance_variable_get("@features");Fi[	@«i™I"        end
        @var.div(:class => "step_file") do |arglist|
          @var.span { |arglist| (@var << var) }
        end
      end
      
      def function(arglist)
        @var.__send__(var, var) do |arglist|
          @var.div { |arglist| @var.span(var, :class => "step param") };Fi[	@«i∞I"J      def function(arglist)
        @var.__send__(var, var) do |arglist|
          @var.div { |arglist| @var.span(var, :class => "step param") }
        end
      end
      
      def function(arglist)
        @var.style(:type => "text/css") do |arglist|
          (@var << File.read((File.dirname("(string)") + "/cucumber.css")));Fi[	@«i∂I"4      def function(arglist)
        @var.style(:type => "text/css") do |arglist|
          (@var << File.read((File.dirname("(string)") + "/cucumber.css")))
        end
      end
      
      def function(arglist)
        @var.script(:type => "text/javascript") do |arglist|
          (@var << inline_jquery);Fi[	@«iΩI"        @var.script(:type => "text/javascript") do |arglist|
          (@var << inline_jquery)
          (@var << inline_js_content)
        end
      end
      
      def function(arglist)
        File.read((File.dirname("(string)") + "/jquery-min.js"))
      end;Fi[	@«i›I"≥          else
            var
          end
        end
      end
      
      def function(arglist)
        (@var << "<script type=\"text/javascript\">document.getElementById('duration').innerHTML = \"Finished in <strong>#{format_duration(features.duration)} seconds</strong>\";</script>")
        (@var << "<script type=\"text/javascript\">document.getElementById('totals').innerHTML = \"#{print_stat_string(features)}\";</script>");Fi[	@«iI"	            [lines_around(var, var), var]
          else
            ["# Couldn't get snippet for #{error_line}", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("\n");Fi[	@«i,I"Ò            var[(var..var)].join("\n")
          else
            "# Couldn't get snippet for #{file}"
          end
        end
        
        def function(arglist)
          var = []
          var.split("\n").each_with_index do |arglist|;Fi[	@ﬁiI"K      class UnNamedFeatureError < StandardError
        def function(arglist)
          super("The feature in '#{feature_file}' does not have a name. The JUnit XML format requires a name for the testsuite element.")
        end
      end
      
      def function(arglist)
        @var = ensure_dir(var, "junit")
        @var = var;Fi[	@Êi,I"          var = File.dirname(var)
          mkdir_p(var) unless File.directory?(var)
          @var = ensure_file(var, "pretty")
        end
      end
      
      def function(arglist)
        @var.puts(var.indent(@var))
        @var.flush;Fi[	@Êi8I"…        if (@var == 1) then
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        var = format_string(var, :tag).indent(@var)
        @var.print(var);Fi[	@ÊiªI"˚        @var.puts
        if var.exception and @var.include?(var.exception).! then
          print_exception(var.exception, var.status, @var)
        end
      end
      
      def function(arglist)
        return unless @var
        @var = (@var + 1);Fi[	@ÏiI"ÿ          after_first_time { |arglist| @var.print(" ") }
          @var.print("#{@file}:#{@lines.join(":")}")
          @var.flush
        end
      end
      
      def function(arglist)
        @var.close
      end;Fi[	@Ïi*I"$      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then
          (@var << var.line)
        end
      end
      
      def function(arglist)
        return unless @var and Cucumber::Ast::OutlineTable::ExampleRow.===(var)
        unless @var then;Fi[	@Úi*I"Ê          var[var.file] ||= []
          (var[var.file] << [var.file_colon_line, var.regexp_source])
          var
        end
      end
      
      def function(arglist)
        (var.map { |arglist| var.size }.max + 1)
      end;Fi[	@˝iVI"”            @var.print(format_string(var, :comment))
          end
          @var.puts
        end
      end
      
      def function(arglist)
        [max_stepdef_length, max_step_length].compact.max
      end;Fi[	@˝iqI"?            var = var.inject(0) { |arglist| (var[:duration] + var) }
            var.mean_duration = (var / var.length)
          end
        end
      end
      
      def function(arglist)
        @var.unmatched_step_definitions.each do |arglist|
          var = StepDefKey.new(var.regexp_source, var.file_colon_line);Fi[	@
iI"      def function(arglist)
        hooks[:after_configuration].each do |arglist|
          var.invoke("AfterConfiguration", var)
        end
      end
      
      def function(arglist)
        hooks_for(:after_step, var).each do |arglist|
          invoke(var, "AfterStep", var, false);Fi[	@
i!I"      def function(arglist)
        hooks_for(:after_step, var).each do |arglist|
          invoke(var, "AfterStep", var, false)
        end
      end
      
      def function(arglist)
        var.map do |arglist|
          var = transforms.detect { |arglist| var.match(var) };Fi[	@
i(I"Ì        var.map do |arglist|
          var = transforms.detect { |arglist| var.match(var) }
          var ? (var.invoke(var)) : (var)
        end
      end
      
      def function(arglist)
        (hooks[var.to_sym] << var)
        var;Fi[	@
ijI"Í      def function(arglist)
        hooks_for(:after, var).reverse_each do |arglist|
          invoke(var, "After", var, true)
        end
      end
      
      def function(arglist)
        begin
          var.invoke(var, var, &var);Fi[	@i4I"‡          var = RubyPython.import(var)
        rescue RubyPython::PythonError => var
          raise(var)
        end
      end
      
      def function(arglist)
        var = File.expand_path(var)
        @var.unshift(var);Fi[	@i?I"             File.exist?("./Gemfile") and gem_available?("bundler")
          else
            @var
          end
        end
        
        def function(arglist)
          (gem_available_new_rubygems?(var) or gem_available_old_rubygems?(var))
        end;Fi[	@iSI"7            [Cucumber::RUBY_BINARY, "-S", "bundle", "exec", "cucumber", @var, @var].flatten
          else
            [Cucumber::RUBY_BINARY, "-I", load_path(@var), quoted_binary(@var), @var, @var].flatten
          end
        end
        
        def function(arglist)
          sh(cmd.join(" "))
        end;Fi[	@i@I"‚          rescue LoadError => var
            @var = Module.new { |arglist| }
          end
        end
      end
      
      def function(arglist)
        @var.map do |arglist|
          if var = var.arguments_from(var) then;Fi[	@iéI"∏          check_nil(@var, @var)
        else
          @var = Object.new
        end
      end
      
      def function(arglist)
        @var.extend(RbWorld)
        @var.extend(@var);Fi[	@"iI"9      class MissingProc < StandardError
        def function(arglist)
          "Transforms must always have a proc with at least one argument"
        end
      end
      
      def function(arglist)
        raise(MissingProc) if (var.nil? or (var.arity < 1))
        @var, @var, @var = var, Regexp.new(var), var;Fi[	@"iI",        if var = match(var) then
          var = var.captures.empty? ? ([var]) : (var.captures)
          @var.current_world.cucumber_instance_exec(true, @var.inspect, *var, &@var)
        end
      end
      
      def function(arglist)
        convert_captures(strip_anchors(@var.source))
      end;Fi[	@8iI"÷        unless @var.has_key?(var) then
          @var[var] = var
          steps.push(var)
        end
      end
      
      def function(arglist)
        var = var.object_id
        unless @var.has_key?(var) then;Fi[	@8iI"Ú        unless @var.has_key?(var) then
          @var[var] = var
          scenarios.push(var)
        end
      end
      
      def function(arglist)
        @var ||= []
        var ? (@var.select { |arglist| (var.status == var) }) : (@var);Fi[	@=ióI"æ          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then
          log.debug("  * #{file}\n");Fi[	@=i†I"æ          var.load_code_file(var)
        else
          log.debug("  * #{file} [NOT SUPPORTED]\n")
        end
      end
      
      def function(arglist)
        Cucumber.logger
      end;Fi[	@Bi<I"˜          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var
          nil
        end
      end
      
      def function(arglist)
        var = nil
        var = java.lang.Thread.new { |arglist| var = STDIN.gets };Fi[	@EiQI"     def function(arglist)
      around(var, var) do |arglist|
        before_and_after(var, var) { |arglist| yield(var) }
      end
    end
    
    def function(arglist)
      if var then
        yield;Fi[	@KiI"	          var = var.backtrace
          var.shift
          raise(Timeout::Error, "Timed out calling wire server with message '#{message}'", var)
        end
      end
      
      def function(arglist)
        WireException.new(var, @var.host, @var.port)
      end;Fi[	@SiI"î          else
            var["backtrace"]
          end
        end
      end
      
      def function(arglist)
        (@var or super)
      end;Fi[	I",data//devise_proj/devise/failure_app.rb;TiI"©        ApplicationController.default_url_options(*var)
      else
        {}
      end
    end
    
    def function(arglist)
      if http_auth? then
        http_auth;Fi[	@ri&I"Ω        http_auth
      else
        warden_options[:recall] ? (recall) : (redirect)
      end
    end
    
    def function(arglist)
      self.status = 401
      if http_auth_header? then;Fi[	@riKI"        I18n.t(:"#{scope}.#{var}", :resource_name => (scope), :scope => "devise.failure", :default => ([var]))
      else
        var.to_s
      end
    end
    
    def function(arglist)
      if (warden_message == :timeout) then
        flash[:timedout] = true;Fi[	@riTI"≠        (attempted_path or scope_path)
      else
        scope_path
      end
    end
    
    def function(arglist)
      var = {}
      var = :"new_#{scope}_session_path";Fi[	@ribI"Õ        var.send(var, var)
      else
        respond_to?(:root_path) ? (root_path(var)) : ("/")
      end
    end
    
    def function(arglist)
      ["html", "*/*"].include?(request_format.to_s)
    end;Fi[	@riÖI"≥        else
          i18n_message
        end
      end
    end
    
    def function(arglist)
      var, var = var.split("#")
      var = ActiveSupport::Inflector.camelize(var);Fi[	@ri™I"    def function(arglist)
      if request.get? and http_auth?.! then
        session["#{scope}_return_to"] = attempted_path
      end
    end
    
    def function(arglist)
      Devise.navigational_formats.include?(request_format)
    end;Fi[	@{i;I"∆          else
            Devise.mailer_sender
          end
        end
      end
      
      def function(arglist)
        var = [self.class.mailer_name]
        if self.class.scoped_views? then;Fi[	@~iWI"
      if @var.is_a?(String) then
        var = Devise.ref(@var)
        @var = lambda { |arglist| var.get.call(var) }
      end
    end
    
    def function(arglist)
      var = (var[:module] or "devise")
      @var = Hash.new { |arglist| var[var] = "#{mod}/#{k}" };Fi[	@~i{I"Ó        else
          @var = (self.routes - Array(var[:skip]).map(&var))
        end
      end
    end
    
    def function(arglist)
      var = lambda { |arglist| var.to_s.singularize.to_sym }
      if (var[:skip_helpers] == true) then;Fi[	@ÉigI";      def function(arglist)
        self.class.case_insensitive_keys.each do |arglist|
          apply_to_attribute_or_variable(var, :downcase!)
        end
      end
      
      def function(arglist)
        self.class.strip_whitespace_keys.each do |arglist|
          apply_to_attribute_or_variable(var, :strip!);Fi[	@ÉimI"$      def function(arglist)
        self.class.strip_whitespace_keys.each do |arglist|
          apply_to_attribute_or_variable(var, :strip!)
        end
      end
      
      def function(arglist)
        self[var] ? (self[var].try(var)) : (send(var).try(var) if respond_to?(var))
      end;Fi[	@ÉiÄI"            params_authenticatable.include?(var)
          else
            params_authenticatable
          end
        end
        
        def function(arglist)
          if http_authenticatable.is_a?(Array) then
            http_authenticatable.include?(var);Fi[	@íiTI"≠            save(:validate => (false))
          end
          false
        end
      end
      
      def function(arglist)
        if Devise.paranoid then
          super;Fi[	@†i9I"ú          else
            raise("authenticable_salt returned nil for the #{self.class.name} model. In order to use rememberable, you must ensure a password is always set or have a remember_token column in your model or implement your own rememberable_value in the model with custom logic.")
          end
        end
      end
      
      def function(arglist)
        self.class.rememberable_options
      end;Fi[	@Øi#I"p      def function(arglist)
        ::OmniAuth.strategies.find do |arglist|
          (var.to_s =~ /#{::OmniAuth::Utils.camelize(strategy_name)}$/ or (var.default_options[:name] == strategy_name))
        end
      end
      
      def function(arglist)
        var = ::OmniAuth::Utils.camelize(provider.to_s)
        if ::OmniAuth::Strategies.const_defined?(var) then;Fi[	@∑iBI"≤        get(:new, :path => (var.path_names[:sign_in]), :as => "new")
        post(:create, :path => (var.path_names[:sign_in]))
        match(:destroy, :path => (var.path_names[:sign_out]), :as => "destroy", :via => (var.sign_out_via))
      end
    end
    
    def function(arglist)
      resource(:password, :only => ([:new, :create, :edit, :update]), :path => (var.path_names[:password]), :controller => (var[:passwords]))
    end;Fi[	@∑iPI"    def function(arglist)
      if var.to.unlock_strategy_enabled?(:email) then
        resource(:unlock, :only => ([:new, :create, :show]), :path => (var.path_names[:unlock]), :controller => (var[:unlocks]))
      end
    end
    
    def function(arglist)
      var = { :new => (var.path_names[:sign_up]), :cancel => (var.path_names[:cancel]) }
      var = { :only => ([:new, :create, :edit, :update, :destroy]), :path => (var.path_names[:registration]), :path_names => (var), :controller => (var[:registrations]) };Fi[	@∑irI"        yield)
      ensure
        @var.merge!(var)
      end
    end
    
    def function(arglist)
      if ::OmniAuth.config.path_prefix and ::OmniAuth.config.path_prefix.!=(var) then
        raise("Wrong OmniAuth configuration. If you are getting this exception, it means that either:\n\n1) You are manually setting OmniAuth.config.path_prefix and it doesn't match the Devise one\n2) You are setting :omniauthable in more than one model\n3) You changed your Devise routes/OmniAuth setting and haven't restarted your server");Fi[	@∑izI"Ò        raise("Wrong OmniAuth configuration. If you are getting this exception, it means that either:\n\n1) You are manually setting OmniAuth.config.path_prefix and it doesn't match the Devise one\n2) You are setting :omniauthable in more than one model\n3) You changed your Devise routes/OmniAuth setting and haven't restarted your server")
      else
        ::OmniAuth.config.path_prefix = var
      end
    end
    
    def function(arglist)
      raise("#{klass} does not respond to 'devise' method. This usually means you haven't loaded your ORM file or it's being loaded too late. To fix it, be sure to require 'devise/orm/YOUR_ORM' inside 'config/initializers/devise.rb' or before your application definition in 'config/application.rb'")
    end;Fi[	@Õi!I"‡        super
        if var.respond_to?(:extend_remember_period=) then
          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end;Fi[	I"-data//devise_proj/devise/test_helpers.rb;TiPI"¥        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist)
      var[:action] ||= :unauthenticated
      var = var["warden"];Fi[	@”iI"          migration_template("migration_existing.rb", "db/migrate/add_devise_to_#{table_name}")
        else
          migration_template("migration.rb", "db/migrate/devise_create_#{table_name}")
        end
      end
      
      def function(arglist)
        unless model_exists? and (behavior == :invoke) then
          invoke("active_record:model", [name], :migration => (false));Fi[	@”iI"–      def function(arglist)
        unless model_exists? and (behavior == :invoke) then
          invoke("active_record:model", [name], :migration => (false))
        end
      end
      
      def function(arglist)
        var = (model_contents + "  # Setup accessible (or protected) attributes for your model\n  attr_accessible :email, :password, :password_confirmation, :remember_me\n")
        var = namespaced? ? (class_name.to_s.split("::")) : ([class_name]);Fi[	I";data//devise_proj/generators/devise/views_generator.rb;TiI"ı      module ClassMethods
        def function(arglist)
          Rails::Generators.hide_namespace(self.namespace)
        end
      end
      
      def function(arglist)
        view_directory(:confirmations)
        view_directory(:passwords);Fi[	@ﬂiI"8      def function(arglist)
        unless model_exists? and (behavior == :invoke) then
          invoke("mongoid:model", [name])
        end
      end
      
      def function(arglist)
        if model_exists? then
          inject_into_file(model_path, migration_data, :after => "include Mongoid::Document\n");Fi[	@ﬂiI"P      def function(arglist)
        if model_exists? then
          inject_into_file(model_path, migration_data, :after => "include Mongoid::Document\n")
        end
      end
      
      def function(arglist)
        if model_exists? then
          inject_into_file(model_path, model_contents, :after => "include Mongoid::Document\n");Fi[	@ﬂiI"â      def function(arglist)
        if model_exists? then
          inject_into_file(model_path, model_contents, :after => "include Mongoid::Document\n")
        end
      end
      
      def function(arglist)
        "  ## Database authenticatable\n  field :email,              :type => String, :default => \"\"\n  field :encrypted_password, :type => String, :default => \"\"\n  \n  ## Recoverable\n  field :reset_password_token,   :type => String\n  field :reset_password_sent_at, :type => Time\n\n  ## Rememberable\n  field :remember_created_at, :type => Time\n\n  ## Trackable\n  field :sign_in_count,      :type => Integer, :default => 0\n  field :current_sign_in_at, :type => Time\n  field :last_sign_in_at,    :type => Time\n  field :current_sign_in_ip, :type => String\n  field :last_sign_in_ip,    :type => String\n\n  ## Confirmable\n  # field :confirmation_token,   :type => String\n  # field :confirmed_at,         :type => Time\n  # field :confirmation_sent_at, :type => Time\n  # field :unconfirmed_email,    :type => String # Only if using reconfirmable\n\n  ## Lockable\n  # field :failed_attempts, :type => Integer, :default => 0 # Only if lock strategy is :failed_attempts\n  # field :unlock_token,    :type => String # Only if unlock strategy is :email or :both\n  # field :locked_at,       :type => Time\n\n  ## Token authenticatable\n  # field :authentication_token, :type => String\n"
      end;Fi[	I"9data//diaspora_proj/controllers/admins_controller.rb;Ti/I"      @var = ""
    else
      @var = "#{@created_users_by_week[params[:week]].count}"
    end
  end
  
  def function(arglist)
    @var = ActsAsTaggableOn::Tagging.joins(:tag).limit(50).count(:group => :tag, :order => "count(taggings.id) DESC")
    case params[:range];Fi[	@‚i$I"Ö      root_path
    else
      new_user_session_path
    end
  end
  
  def function(arglist)
    @var ||= current_user.aspects
  end;Fi[	@‚iHI"·      if AppConfig.git_revision.present? then
        headers["X-Git-Revision"] = AppConfig.git_revision
      end
    end
  end
  
  def function(arglist)
    if user_signed_in? then
      I18n.locale = current_user.language;Fi[	@‚iSI"      var ||= request.compatible_language_from(AVAILABLE_LANGUAGE_CODES)
      var ||= DEFAULT_LANGUAGE
      I18n.locale = var
    end
  end
  
  def function(arglist)
    unless current_user.admin? then
      redirect_to(stream_url, :notice => "you need to be an admin to do that");Fi[	@‚iZI"6    unless current_user.admin? then
      redirect_to(stream_url, :notice => "you need to be an admin to do that")
      return
    end
  end
  
  def function(arglist)
    if user_signed_in? and I18n.inflector.inflected_locale? then
      var = current_user.gender.to_s.tr("!()[]\"'`*=|/\\#.,-:", "").downcase;Fi[	@‚ilI"i          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil)
  end;Fi[	@‚izI"Ã      request.format = :mobile
    else
      request.format = :html if request.format.tablet?
    end
  end
  
  def function(arglist)
    (stored_location_for(:user) or current_user_redirect_path)
  end;Fi[	I"Edata//diaspora_proj/controllers/aspect_memberships_controller.rb;Ti#I"        var.js { |arglist| render(:text => (var), :status => 403) }
        var.html { |arglist| redirect_to(:back) }
      end
    end
  end
  
  def function(arglist)
    @var = Person.find(params[:person_id])
    @var = current_user.aspects.where(:id => (params[:aspect_id])).first;Fi[	@Ái"I"è          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist)
    @var = Aspect.new
    @var = params[:person_id];Fi[	@Ái8I"Ù      redirect_to(contacts_path)
    else
      redirect_to(aspects_path)
    end
  end
  
  def function(arglist)
    if @var = current_user.aspects.where(:id => (params[:id])).first then
      redirect_to(aspects_path("a_ids[]" => (@var.id)));Fi[	@Ái@I"_      redirect_to(aspects_path("a_ids[]" => (@var.id)))
    else
      redirect_to(aspects_path)
    end
  end
  
  def function(arglist)
    @var = current_user.aspects.where(:id => (params[:id])).includes(:contacts => ({ :person => :profile })).first
    @var = @var.contacts.includes(:aspect_memberships, :person => :profile).all.sort! do |arglist|;Fi[	@ÁiYI"1      render(:layout => (false))
    else
      render(:file => (Rails.root.join("public", "404.html").to_s), :layout => (false), :status => 404)
    end
  end
  
  def function(arglist)
    @var = current_user.aspects.where(:id => (params[:id])).first
    if @var.update_attributes!(params[:aspect]) then;Fi[	I"9data//diaspora_proj/controllers/blocks_controller.rb;TiI"5    respond_with do |arglist|
      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  def function(arglist)
    if current_user.blocks.find(params[:id]).delete then
      var = { :notice => (t("blocks.destroy.success")) };Fi[	I";data//diaspora_proj/controllers/comments_controller.rb;TiI"€      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id])
    if (current_user.owns?(@var) or current_user.owns?(@var.parent)) then;Fi[	@ i0I"‡        var.mobile { |arglist| redirect_to(:back) }
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    render(:layout => (false))
  end;Fi[	I";data//diaspora_proj/controllers/contacts_controller.rb;TiI"        @var = Person.all_from_aspects(var, current_user).for_json
        render(:json => (@var.to_json))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.contacts.sharing.includes(:aspect_memberships)
    render(:layout => (false));Fi[	@ÍiI"    respond_with do |arglist|
      var.html
      var.json { |arglist| render(:json => (@var), :status => 200) }
    end
  end
  
  def function(arglist)
    var = Contact.where(:id => (params[:contact_ids].split(","))).map! do |arglist|
      var.person_id;Fi[	@Íi,I"⁄      redirect_to(person_path(params[:profile]))
    else
      redirect_to(conversations_path(:conversation_id => (@var.id)))
    end
  end
  
  def function(arglist)
    if @var = Conversation.joins(:conversation_visibilities).where(:id => (params[:id]), :conversation_visibilities => ({ :person_id => (current_user.person_id) })).first then
      if @var = ConversationVisibility.where(:conversation_id => (params[:id]), :person_id => (current_user.person.id)).first then;Fi[	@Íi>I"Æ      end
    else
      redirect_to(conversations_path)
    end
  end
  
  def function(arglist)
    var = Contact.connection.select_rows(current_user.contacts.where(:sharing => (true)).joins(:person => :profile).select("contacts.id, profiles.first_name, profiles.last_name, people.diaspora_handle").to_sql).map do |arglist|
      { :value => (var[0]), :name => (Person.name_from_attrs(var[1], var[2], var[3]).gsub(/(")/, "'")) };Fi[	I"7data//diaspora_proj/controllers/home_controller.rb;TiI"∞      else
        render(:show, :layout => "post")
      end
    end
  end
  
  def function(arglist)
    if session[:mobile_view].nil? then
      session[:mobile_view] = true;Fi[	I">data//diaspora_proj/controllers/invitations_controller.rb;Ti&I"    else
      flash[:error] = t("invitations.check_token.not_found")
      redirect_to(root_url)
    end
  end
  
  def function(arglist)
    var = params[:email_inviter][:emails].split(",").map(&:strip).uniq
    var, var = var.partition { |arglist| valid_email?(var) };Fi[	@ÌiI"⁄      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id)
    current_user.retract(@var);Fi[	I"@data//diaspora_proj/controllers/notifications_controller.rb;TiI"ﬂ      end
    else
      respond_to { |arglist| var.json { |arglist| render(:json => ({}.to_json)) } }
    end
  end
  
  def function(arglist)
    var = { :recipient_id => (current_user.id) }
    var = (params[:page] or 1);Fi[	@‡i)I"$      var.html
      var.xml { |arglist| render(:xml => (@var.to_xml)) }
      var.json { |arglist| render(:json => (@var.to_json)) }
    end
  end
  
  def function(arglist)
    Notification.where(:recipient_id => (current_user.id)).update_all(:unread => (false))
    respond_to do |arglist|;Fi[	I"9data//diaspora_proj/controllers/people_controller.rb;Ti5I"ˇ        @var = @var.paginate(:page => (params[:page]), :per_page => 15)
        @var = hashes_for_people(@var, @var)
      end
    end
  end
  
  def function(arglist)
    @var = :search
    @var = Person.where(:diaspora_handle => (search_query.downcase));Fi[	@ÂiyI"T        redirect_to(:action => "show", :id => (params[:person_id]))
      end
      var.json { |arglist| render(:json => (HovercardPresenter.new(@var))) }
    end
  end
  
  def function(arglist)
    @var = Person.find_from_guid_or_username(params)
    var = Post.visible_from_author(@var, current_user).order("posts.created_at DESC").first;Fi[	@ÂiÉI"«      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id])
    if @var then;Fi[	@ÂiíI"Ë    else
      flash[:error] = I18n.t("people.show.does_not_exist")
      redirect_to(people_path)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id])
    if (@var == current_user.person) then;Fi[	@ÂiúI"A    else
      @var = (current_user.contact_for(@var) or Contact.new)
      render(:partial => "aspect_membership_dropdown", :locals => ({ :contact => (@var), :person => (@var), :hang => "left" }))
    end
  end
  
  def function(arglist)
    if search_query.starts_with?("#") then
      if (search_query.length > 1) then;Fi[	@Âi¥I"À    end
    var.map do |arglist|
      { :person => (var), :contact => (var[var.id]), :aspects => (var) }
    end
  end
  
  def function(arglist)
    @var ||= (params[:q] or (params[:term] or ""))
  end;Fi[	I"9data//diaspora_proj/controllers/photos_controller.rb;Ti%I"÷    else
      flash[:error] = I18n.t("people.show.does_not_exist")
      redirect_to(people_path)
    end
  end
  
  def function(arglist)
    rescuing_photo_errors do |arglist|
      if remotipart_submitted? then;Fi[	@Úi8I"¬      else
        legacy_create
      end
    end
  end
  
  def function(arglist)
    var = current_user.person_id
    @var = Photo.where(:id => (params[:photo_id]), :author_id => (var)).first;Fi[	@ÚiKI"º      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first
    if var then;Fi[	@Úi_I"Ì      end
    else
      respond_with(var, :location => (person_photos_path(current_user.person)))
    end
  end
  
  def function(arglist)
    if @var = current_user.photos.where(:id => (params[:id])).first then
      respond_with(@var);Fi[	@ÚigI"’      respond_with(@var)
    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first
    if var then;Fi[	@ÚiëI"Z      Tempfile.send(:define_method, "content_type") { |arglist| return var }
      Tempfile.send(:define_method, "original_filename") { |arglist| return var }
      var
    end
  end
  
  def function(arglist)
    if (params[:photo][:aspect_ids] == "all") then
      params[:photo][:aspect_ids] = current_user.aspects.collect { |arglist| var.id };Fi[	@Úi≤I"õ      end
    else
      respond_with(@var, :location => (photos_path), :error => (message))
    end
  end
  
  def function(arglist)
    begin
      yield;Fi[	I"8data//diaspora_proj/controllers/posts_controller.rb;TiI"Á      var.all do |arglist|
        render(:template => "errors/not_public", :status => 404)
      end
    end
  end
  
  def function(arglist)
    mark_corresponding_notifications_read if user_signed_in?
    respond_to do |arglist|;Fi[	@i'I"›      var.json do |arglist|
        render(:json => (PostPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    render(:text => (post_iframe_url(params[:id])), :layout => (false))
  end;Fi[	@i6I"Â      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).newer(@var)
    respond_to do |arglist|;Fi[	@i@I"Ù      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).older(@var)
    respond_to do |arglist|;Fi[	@iJI"◊      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    respond_with(PostInteractionPresenter.new(@var, current_user))
  end;Fi[	@iXI"B      var.js { |arglist| render("destroy", :layout => (false), :format => :js) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
      var.any { |arglist| redirect_to(stream_path) }
    end
  end
  
  def function(arglist)
    find_current_user_post(params[:id])
    @var.favorite = @var.favorite.!;Fi[	@ÚiI"»      var.json do |arglist|
        render(:json => (PersonPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.person
    @var = :person_edit;Fi[	@ÚiI"ÿ    @var = []
    @var.each do |arglist|
      (@var << { :name => (("#" + var.name)), :value => (("#" + var.name)) })
    end
  end
  
  def function(arglist)
    @var = (params[:profile] or {})
    munge_tag_string;Fi[	I":data//diaspora_proj/controllers/publics_controller.rb;Ti%I"∆      render("publics/hcard")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    render("host_meta", :content_type => "application/xrd+xml")
  end;Fi[	I"@data//diaspora_proj/controllers/registrations_controller.rb;TiI"¸      flash[:error] = @var.errors.full_messages.join(" - ")
      Rails.logger.info("event=registration status=failure errors='#{@user.errors.full_messages.join(", ")}'")
      redirect_to(:back)
    end
  end
  
  def function(arglist)
    super
  end;Fi[	@i,I"$    unless AppConfig.settings.enable_registrations? then
      flash[:error] = t("registrations.closed")
      redirect_to(new_user_session_path)
    end
  end
  
  def function(arglist)
    if params[:invite].present? then
      @var ||= InvitationCode.find_by_token(params[:invite][:token]);Fi[	I";data//diaspora_proj/controllers/services_controller.rb;Ti.I"      render(:text => "<script>window.close()</script>")
    else
      redirect_to(request.env["omniauth.origin"])
    end
  end
  
  def function(arglist)
    Rails.logger.info("error in oauth #{params.inspect}")
    flash[:error] = t("services.failure.error");Fi[	I"Bdata//diaspora_proj/controllers/status_messages_controller.rb;TiI"–      @var = :all
      @var = current_user.aspects
      @var = @var.map { |arglist| var.id }
    end
  end
  
  def function(arglist)
    @var = current_user.aspects
    @var = @var.map { |arglist| var.id };Fi[	@iLI"¿      current_user.aspect_ids
    else
      params[:aspect_ids]
    end
  end
  
  def function(arglist)
    t("status_messages.create.success", :names => (@var.mentioned_people_names))
  end;Fi[	I":data//diaspora_proj/controllers/streams_controller.rb;TiDI"’          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist)
    session[:a_ids] = params[:a_ids] if params[:a_ids].present?
  end;Fi[	I"Adata//diaspora_proj/controllers/tag_followings_controller.rb;Ti'I"      respond_to do |arglist|
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    respond_to do |arglist|
      var.json { |arglist| render(:json => (tags.to_json), :status => 200) };Fi[	I"7data//diaspora_proj/controllers/tags_controller.rb;Ti I"b        var.json { |arglist| render(:nothing => (true), :status => 422) }
        var.html { |arglist| redirect_to(tag_path("partytimeexcellent")) }
      end
    end
  end
  
  def function(arglist)
    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]));Fi[	@ıi^I";      var.all do |arglist|
        redirect_to((var ? (new_user_session_path) : (edit_user_path)))
      end
    end
  end
  
  def function(arglist)
    if params[:user] and (params[:user][:current_password] and current_user.valid_password?(params[:user][:current_password])) then
      current_user.close_account!;Fi[	@ıimI"‹        flash[:error] = t("users.destroy.no_password")
      end
      redirect_to(:back)
    end
  end
  
  def function(arglist)
    if @var = User.find_by_username(params[:username]) then
      respond_to do |arglist|;Fi[	@ıizI"„      end
    else
      redirect_to(stream_path, :error => (I18n.t("users.public.does_not_exist", :username => (params[:username]))))
    end
  end
  
  def function(arglist)
    @var = :getting_started
    @var = current_user;Fi[	@ıióI"      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    if current_user.confirm_email(params[:token]) then
      flash[:notice] = I18n.t("users.confirm_email.email_confirmed", :email => (current_user.email));Fi[	I"4data//diaspora_proj/helpers/analytics_helper.rb;TiI"£      javascript_tag do |arglist|
        "          (function(d,c){var a,b,g,e;a=d.createElement('script');a.type='text/javascript';a.async=!0;a.src=('https:'===d.location.protocol?'https:':'http:')+'//api.mixpanel.com/site_media/js/api/mixpanel.2.js';b=d.getElementsByTagName('script')[0];b.parentNode.insertBefore(a,b);c._i=[];c.init=function(a,d,f){var b=c;'undefined'!==typeof f?b=c[f]=[]:f='mixpanel';g='disable track track_pageview track_links track_forms register register_once unregister identify name_tag set_config'.split(' ');\n          for(e=0;e<g.length;e++)(function(a){b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,0)))}})(g[e]);c._i.push([a,d,f])};window.mixpanel=c})(document,[]);\n          mixpanel.init(\"#{AppConfig.privacy.mixpanel_uid}\");\n".html_safe
      end
    end
  end
  
  def function(arglist)
    return unless current_user
    include_analytics("mixpanel") do |arglist|;Fi[	@3iI"	      javascript_tag do |arglist|
        "          mixpanel.name_tag(\"#{current_user.guid}\");\n".html_safe
      end
    end
  end
  
  def function(arglist)
    return unless configured?("chartbeat")
    javascript_tag("var _sf_startpt=(new Date()).getTime()");Fi[	I"6data//diaspora_proj/helpers/application_helper.rb;TiI"µ      AppConfig.settings.pod_name
    else
      "DIASPORA*"
    end
  end
  
  def function(arglist)
    AppConfig.version.number.present? ? (AppConfig.version.number) : ("")
  end;Fi[	@8i,I"±      contacts_path
    else
      community_spotlight_path
    end
  end
  
  def function(arglist)
    (current_user.services.size == AppConfig.configured_services.size)
  end;Fi[	I"3data//diaspora_proj/helpers/contacts_helper.rb;TiI"ë      link_to(image_tag("icons/monotone_close_exit_delete.png", :height => 20, :width => 20), { :controller => "aspect_memberships", :action => "destroy", :id => 42, :aspect_id => (@var.id), :person_id => (var.person_id) }, :title => (t("contacts.index.remove_person_from_aspect", :person_name => (var.person_first_name), :aspect_name => (@var.name))), :method => "delete")
    else
      render(:partial => "people/relationship_action", :locals => ({ :person => (var.person), :contact => (var), :current_user => (current_user) }))
    end
  end
  
  def function(arglist)
    var = 16
    var = { :class => "button conversation_button", :rel => "facebox" };Fi[	I":data//diaspora_proj/helpers/getting_started_helper.rb;TiI">      link_to("##{tag_name}", tag_followings_path(var), :method => :delete, :class => "featured_tag followed")
    else
      link_to("##{tag_name}", tag_tag_followings_path(var), :method => :post, :class => "featured_tag")
    end
  end
  
  def function(arglist)
    tags.detect { |arglist| (var.name == var) }
  end;Fi[	I"Cdata//diaspora_proj/helpers/interim_stream_hackiness_helper.rb;TiI"π      params[:prefill]
    else
      defined? @var ? (@var.publisher.text) : (nil)
    end
  end
  
  def function(arglist)
    if params[:prefill].present? then
      params[:prefill];Fi[	@CiI"ﬂ      params[:prefill]
    else
      defined? @var ? (@var.publisher.prefill) : (nil)
    end
  end
  
  def function(arglist)
    if defined? @var and (params[:controller] == "multis") then
      @var.post_from_group(var);Fi[	@Ci%I"ï      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist)
    defined? @var ? (@var.publisher.open?) : (false)
  end;Fi[	I"1data//diaspora_proj/helpers/layout_helper.rb;TiI"÷    var = (AppConfig.environment.assets.host.to_s + "/assets/")
    content_tag(:script) do |arglist|
      "        if(window.app) app.baseImageUrl(\"#{path}\")\n".html_safe
    end
  end
  
  def function(arglist)
    content_tag(:script) do |arglist|
      "        Diaspora.I18n.loadLocale(#{get_javascript_strings_for(I18n.locale).to_json}, \"#{I18n.locale}\");\n        Diaspora.Page = \"#{params[:controller].camelcase}#{params[:action].camelcase}\";\n".html_safe;Fi[	@JiI"É  def function(arglist)
    content_tag(:script) do |arglist|
      "        Diaspora.I18n.loadLocale(#{get_javascript_strings_for(I18n.locale).to_json}, \"#{I18n.locale}\");\n        Diaspora.Page = \"#{params[:controller].camelcase}#{params[:action].camelcase}\";\n".html_safe
    end
  end
  
  def function(arglist)
    return unless user_signed_in?
    var = (session[:a_ids] or []);Fi[	@Ji%I"ı    var = UserPresenter.new(current_user, var).to_json
    content_tag(:script) do |arglist|
      "        window.current_user_attributes = #{user}\n".html_safe
    end
  end
  
  def function(arglist)
    return
    return unless @var.present?;Fi[	@Ji2I"(    return if (Rails.env == "production")
    content_tag(:style) do |arglist|
      "        .translation_missing { color: purple; background-color: red; }\n"
    end
  end
  
  def function(arglist)
    if (var or (@var == :getting_started)) then
      stylesheet_link_tag("bootstrap-complete");Fi[	@Ji:I"       stylesheet_link_tag("bootstrap-complete")
    else
      stylesheet_link_tag("blueprint", :media => "screen")
    end
  end
  
  def function(arglist)
    content_tag(:script) do |arglist|
      "        if(Array.isArray === undefined) {\n          Array.isArray = function (arg) {\n            return Object.prototype.toString.call(arg) == '[object Array]';\n          };\n        }\n        if ((window.history) && (window.history.pushState === undefined)) {\n          window.history.pushState = function() { };\n        }\n".html_safe;Fi[	@Ji@I"  def function(arglist)
    content_tag(:script) do |arglist|
      "        if(Array.isArray === undefined) {\n          Array.isArray = function (arg) {\n            return Object.prototype.toString.call(arg) == '[object Array]';\n          };\n        }\n        if ((window.history) && (window.history.pushState === undefined)) {\n          window.history.pushState = function() { };\n        }\n".html_safe
    end
  end
  
  def function(arglist)
    flash.map do |arglist|
      content_tag(:div, :id => ("flash_#{name}")) do |arglist|;Fi[	I"1data//diaspora_proj/helpers/mobile_helper.rb;TiI"ÿ        var = var.present? ? ("active") : ("inactive")
        link_to("", reshares_path(:root_guid => (var.guid)), :title => (t("reshares.reshare.reshare_confirmation", :author => (var.author_name))), :class => ("image_link reshare_action #{klass}"))
      end
    end
  end
  
  def function(arglist)
    if current_user and current_user.liked?(var) then
      link_to("", post_like_path(var.id, current_user.like_for(var).id), :class => "image_link like_action active");Fi[	@WiI"_      link_to("", post_like_path(var.id, current_user.like_for(var).id), :class => "image_link like_action active")
    else
      link_to("", post_likes_path(var.id), :class => "image_link like_action inactive")
    end
  end
  
  def function(arglist)
    link_to("", new_post_comment_path(var), :class => "image_link comment_action inactive")
  end;Fi[	I"8data//diaspora_proj/helpers/notifications_helper.rb;TiI"       else
        translation(var, :actors => (var), :count => (var))
      end
    end
  end
  
  def function(arglist)
    { :post_author => (nil) }.merge!(var)
    t("#{target_type}", var).html_safe;Fi[	I"1data//diaspora_proj/helpers/people_helper.rb;TiI":      content_tag(:h2, :id => "search_title") do |arglist|
        ((t("people.index.results_for").html_safe + " ") + content_tag(:span, search_query, :class => "term"))
      end
    end
  end
  
  def function(arglist)
    if search_query then
      I18n.t("people.helper.results_for", :params => (search_query));Fi[	@_iI"      I18n.t("people.helper.results_for", :params => (search_query))
    else
      I18n.t("people.helper.people_on_pod_are_aware_of")
    end
  end
  
  def function(arglist)
    if (var.year == 1000) then
      I18n.l(var, :format => (I18n.t("date.formats.birthday")));Fi[	@_iI".      I18n.l(var, :format => (I18n.t("date.formats.birthday")))
    else
      I18n.l(var, :format => (I18n.t("date.formats.birthday_with_year")))
    end
  end
  
  def function(arglist)
    var[:class] ||= ""
    if defined? user_signed_in? and (user_signed_in? and (current_user.person == var)) then;Fi[	@_i.I"P  def function(arglist)
    unless Post.visible_from_author(var, var).empty? then
      link_to(t("people.last_post"), last_post_person_path(var.to_param))
    end
  end
  
  def function(arglist)
    image_tag(var.profile.image_url(var), :alt => (var.name), :class => "avatar", :title => (var.name), "data-person_id" => (var.id))
  end;Fi[	@_i;I"x      link_to(person_image_tag(var, var[:size]), person_photos_path(var))
    else
      "<a #{person_href(person)} class='#{opts[:class]}' #{("target=" + opts[:target]) if opts[:target]}>\n      #{person_image_tag(person, opts[:size])}\n      </a>".html_safe
    end
  end
  
  def function(arglist)
    "href=\"#{local_or_remote_person_path(person, opts)}\"".html_safe
  end;Fi[	@iI"}          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516
    var[:height] ||= 315;Fi[	@iI"u          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare)
  end;Fi[	I"/data//diaspora_proj/helpers/tags_helper.rb;TiI"€      content_tag("small") do |arglist|
        t("people.index.looking_for", :tag_link => (tag_link)).html_safe
      end
    end
  end
  
  def function(arglist)
    ActsAsTaggableOn::Tag.normalize(search_query)
  end;Fi[	I"Gdata//diaspora_proj/mailers/notification_mailers/also_commented.rb;TiI"J        @var[:from] = "\"#{@comment.author_name} (Diaspora*)\" <#{AppConfig.mail.sender_address}>"
        @var[:subject] = truncate(@var.comment_email_subject, :length => (TRUNCATION_LEN))
        @var[:subject] = "Re: #{@headers[:subject]}"
      end
    end
    
    def function(arglist)
      @var and (@var and @var)
    end;Fi[	I",data//diaspora_proj/mailers/notifier.rb;Ti"I"    mail(var) do |arglist|
      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var;Fi[	@ti0I"⁄        var.text { |arglist| render(:layout => (nil)) }
        var.html { |arglist| render(:layout => (nil)) }
      end
    end
  end
  
  def function(arglist)
    send_notification(:started_sharing, var, var)
  end;Fi[	@ti\I"é        var.text
        var.html
      end
    end
  end
  
  def function(arglist)
    I18n.with_locale(@var.recipient.language, &var)
  end;Fi[	I"2data//diaspora_proj/models/account_deleter.rb;Ti6I"  def function(arglist)
    normal_ar_user_associates_to_delete.each do |arglist|
      self.user.send(var).each { |arglist| var.delete }
    end
  end
  
  def function(arglist)
    normal_ar_person_associates_to_delete.each do |arglist|
      self.person.send(var).delete_all;Fi[	@{i<I"Ô  def function(arglist)
    normal_ar_person_associates_to_delete.each do |arglist|
      self.person.send(var).delete_all
    end
  end
  
  def function(arglist)
    user.invitations_from_me.each { |arglist| var.convert_to_admin! }
  end;Fi[	I"*data//diaspora_proj/models/comment.rb;TiHI"f      else
        return false
      end
    end
  end
  
  def function(arglist)
    Post
  end;Fi[	I"*data//diaspora_proj/models/contact.rb;TiZI"  def function(arglist)
    if person_id and person.closed_account? then
      (errors[:base] << "Cannot be in contact with a closed account")
    end
  end
  
  def function(arglist)
    if person_id and (person.owner == user) then
      (errors[:base] << "Cannot create self-contact");Fi[	@Éi`I".  def function(arglist)
    if person_id and (person.owner == user) then
      (errors[:base] << "Cannot create self-contact")
    end
  end
  
  def function(arglist)
    if user and user.blocks.where(:person_id => (person_id)).exists? then
      (errors[:base] << "Cannot connect to an ignored user");Fi[	I"/data//diaspora_proj/models/conversation.rb;Ti=I"€  def function(arglist)
    var.split(";").each do |arglist|
      (self.participants << Webfinger.new(var).fetch)
    end
  end
  
  def function(arglist)
    self.messages.last.author if (self.messages.size > 0)
  end;Fi[	@i{I"ˆ  def function(arglist)
    if self.sender_id.!=(self.aspect.user_id) then
      (errors[:base] << "You do not own that aspect.")
    end
  end
  
  def function(arglist)
    return true if self.recipient.nil?
    if self.recipient.username? then;Fi[	I"*data//diaspora_proj/models/message.rb;Ti>I"¨  def function(arglist)
    if var = Conversation.find_by_guid(var) then
      self.conversation_id = var.id
    end
  end
  
  def function(arglist)
    Conversation
  end;Fi[	@çiQI"    if var = ConversationVisibility.where(:conversation_id => (self.conversation_id), :person_id => (var.person.id)).first then
      var.unread += 1
      var.save
    end
  end
  
  def function(arglist)
    Notifications::PrivateMessage unless (var.person == var)
  end;Fi[	@9i'I"          nil
        end
      end
    end
  end
  
  def function(arglist)
    super(var.merge(:methods => :note_html))
  end;Fi[	I"0data//diaspora_proj/models/o_embed_cache.rb;Ti"I"”      (self.data = var.fields
      self.data["trusted_endpoint_url"] = var.provider.endpoint
      self.save)
    end
  end
  
  def function(arglist)
    self.from_trusted? and self.data.has_key?("html")
  end;Fi[	I")data//diaspora_proj/models/person.rb;Ti™I"      var
    else
      "#{first_name.to_s.strip} #{last_name.to_s.strip}".strip
    end
  end
  
  def function(arglist)
    @var ||= if (profile.nil? or (profile.first_name.nil? or profile.first_name.blank?)) then
      self.diaspora_handle.split("@").first;Fi[	@óiµI"ú      var = var[(0...-1)].join(" ")
      var = var[0] if var.blank?
      var
    end
  end
  
  def function(arglist)
    (self.id == var.author_id)
  end;Fi[	I"(data//diaspora_proj/models/photo.rb;TiAI"       self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist)
    var = StatusMessage.find_by_guid(self.status_message_guid)
    if self.status_message_guid and var then;Fi[	@úivI"      ((remote_photo_path + var.to_s) + remote_photo_name)
    else
      processed? ? (processed_image.url(var)) : (unprocessed_image.url(var))
    end
  end
  
  def function(arglist)
    var = Profile.where(:image_url => (url(:thumb_large)))
    var.each do |arglist|;Fi[	@úi~I"°    var.each do |arglist|
      var.image_url = nil
      var.save
    end
  end
  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end;Fi[	I"*data//diaspora_proj/models/profile.rb;TirI"¡      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@£i{I"¡      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then;Fi[	@£iI"‹      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["month", "day"].all? { |arglist| var[var].present? } then
      var["year"] = "1000" if var["year"].blank?;Fi[	@£iéI"ﬂ      if ["year", "month", "day"].all? { |arglist| var[var].blank? } then
        self.birthday = nil
      end
    end
  end
  
  def function(arglist)
    birthday.to_s(:long).gsub(", 1000", "") if birthday.present?
  end;Fi[	@£i∂I"›  def function(arglist)
    if (self.tag_string.count("#") > 5) then
      (errors[:base] << "Profile cannot have more than five tags")
    end
  end
  
  def function(arglist)
    if @var then
      errors.add(:birthday);Fi[	I"7data//diaspora_proj/models/relayable_retraction.rb;Ti*I"º    if (self.parent_author_signature.nil?.! or self.parent.author.remote?) then
      self.target.destroy
      Rails.logger.info("event=relayable_retraction status =complete target_type=#{self.target_type} guid =#{self.target_guid}")
    end
  end
  
  def function(arglist)
    if self.target.nil? then
      Rails.logger.info("event=retraction status=abort reason='no post found' sender=#{sender.diaspora_handle} target_guid=#{target_guid}");Fi[	I"1data//diaspora_proj/models/status_message.rb;TieI"⁄      self.mentions.includes(:person => :profile).map { |arglist| var.person }
    else
      mentioned_people_from_string
    end
  end
  
  def function(arglist)
    self.mentioned_people.map(&:name).join(", ")
  end;Fi[	@±ioI"‘  def function(arglist)
    mentioned_people_from_string.each do |arglist|
      self.mentions.find_or_create_by_person_id(var.id)
    end
  end
  
  def function(arglist)
    mentioned_people.include?(var)
  end;Fi[	@±iàI"£        end
      end
      self.photos.update_all(:pending => (false))
    end
  end
  
  def function(arglist)
    formatted_message(:plain_text => (true))
  end;Fi[	I"2data//diaspora_proj/models/user/connecting.rb;Ti,I"Ó      var.destroy
    else
      var.update_attributes(:receiving => (false))
    end
  end
  
  def function(arglist)
    var = var.person
    Rails.logger.info("event=disconnect user=#{diaspora_handle} target=#{person.diaspora_handle}");Fi[	I"'data//diaspora_proj/models/user.rb;TilI"¥      self.invitations_to_me.first.sender.invitation_code
    rescue Exception => var
      nil
    end
  end
  
  def function(arglist)
    self.invited_by = var.user
    var.use!;Fi[	@ªiÑI"Ù  def function(arglist)
    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].delete(var)
    end
  end
  
  def function(arglist)
    var = var.class.base_class.name
    if self.hidden_shareables.has_key?(var) then;Fi[	@ªiçI"Ø      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist)
    var = var.id.to_s
    var = var.class.base_class.to_s;Fi[	@ªiõI"¥      self.add_hidden_shareable(var, var)
      self.save
      true
    end
  end
  
  def function(arglist)
    var = var.base_class.to_s
    self.hidden_shareables[var].present?;Fi[	@ªi∑I"«        var = self.user_preferences.where(:email_type => (var)).first
        var.destroy if var
      end
    end
  end
  
  def function(arglist)
    if username.present? then
      username.strip!;Fi[	@ªiæI"«    if username.present? then
      username.strip!
      username.downcase!
    end
  end
  
  def function(arglist)
    self.update_attribute(:getting_started, false) if self.getting_started?
  end;Fi[	@ªiÒI"    if self.owns?(var) then
      var.update_attributes(var)
      self.dispatch_post(var)
    end
  end
  
  def function(arglist)
    return unless self.contact_for(var.author) and var.respond_to?(:mentions?)
    var.notify_person(self.person) if var.mentions?(self.person);Fi[	@ªiI"Ω      self.aspects
    else
      aspects.where(:id => (var))
    end
  end
  
  def function(arglist)
    Salmon::EncryptedSlap.create_by_user_and_activity(self, var.to_diaspora_xml)
  end;Fi[	@ªi(I"@    var = var.to_s.gsub("Jobs::Mail::", "").underscore
    if (self.disable_mail == false) and self.user_preferences.exists?(:email_type => (var)).! then
      Resque.enqueue(var, *var)
    end
  end
  
  def function(arglist)
    return false if unconfirmed_email.blank?
    Resque.enqueue(Jobs::Mail::ConfirmEmail, id);Fi[	@ªiãI"—    end
    if unconfirmed_email_changed? then
      self.confirm_email_token = unconfirmed_email ? (SecureRandom.hex(15)) : (nil)
    end
  end
  
  def function(arglist)
    var = 0
    var.each do |arglist|;Fi[	@ªiÆI"!    var = "#{self.username}#{User.diaspora_id_host}"
    if self.username_changed? and Person.exists?(:diaspora_handle => (var)) then
      (errors[:base] << "That username has already been taken")
    end
  end
  
  def function(arglist)
    self.person.lock_access!
    self.lock_access!;Fi[	I"5data//diaspora_proj/presenters/post_presenter.rb;Ti.I"  def function(arglist)
    if @var.respond_to?(:absolute_root) and @var.absolute_root.present? then
      PostPresenter.new(@var.absolute_root, current_user).as_json
    end
  end
  
  def function(arglist)
    @var.like_for(@var).try(:as_api_response, :backbone)
  end;Fi[	@<i*I"        var = Encoding.find(@var[:encoding])
        return @var.force_encoding(var) if (var == Encoding::BINARY)
        return @var.encode(var)
      end
    end
    
    def function(arglist)
      ((precompiled + ";") + precompiled_method_return_value)
    end;Fi[	@<i^I"V        true
      else
        var.parent ? (nuke_inner_whitespace?(var.parent)) : (false)
      end
    end
    
    def function(arglist)
      push_script(@var.value[:text], { :preserve_script => (@var.value[:preserve]), :escape_html => (@var.value[:escape_html]), :nuke_inner_whitespace => (nuke_inner_whitespace?(@var)) }, &var)
    end;Fi[	@<iyI"¢            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@<i…I"&      if var then
        push_script(var, var.merge(:in_tag => (true)))
        concat_merged_text(("</#{t[:name]}>" + (var[:nuke_outer_whitespace] ? ("") : ("\n"))))
      end
    end
    
    def function(arglist)
      var = "<!--#{@node.value[:conditional]}"
      unless block_given? then;Fi[	@<irI"g      (@var << "_hamlout.buffer << #{no_format ? ("haml_temp.to_s;") : ("#{static_method}(haml_temp);")}")
      unless (var[:in_tag] or (var[:nuke_inner_whitespace] or @var[:ugly])) then
        concat_merged_text("\n")
      end
    end
    
    def function(arglist)
      (@var << [:script, (resolve_newlines + var)])
      @var = (@var + var.count("\n"));Fi[	@<i¡I"ó        var, var = var
        var = (var == "") ? (var) : ([var, var].join(var))
        var.merge!(flatten_data_attributes(var, var, var, var))
      end
    end
    
    def function(arglist)
      var = Compiler.build_attributes(@var.html?, @var[:attr_wrapper], @var[:escape_attrs], @var[:hyphenate_data_attrs], var)
      "<#{name}#{attributes_string}#{self_close and @options.xhtml? ? (" /") : ("")}>";Fi[	I"#data//haml_proj/haml/engine.rb;TiÿI"9    else
      def function(arglist)
        @var.encoding = (Encoding.default_internal or @var.encoding) unless var
      end
    end
    
    def function(arglist)
      var.send(:instance_variable_set, "@_haml_locals", var)
      var = var.keys.map { |arglist| "#{k} = @_haml_locals[#{k.inspect}]" }.join("\n");Fi[	I"#data//haml_proj/haml/parser.rb;TiﬂI"æ        push(plain(var[(1..-1)]))
      else
        push(plain(var))
      end
    end
    
    def function(arglist)
      unless var = var.scan(BLOCK_KEYWORD_REGEX)[0] then
        return;Fi[	@‰i(I"Û        @var.push([var.to_sym, @var.tabs])
        (@var.last << false) if (var == "case")
        @var = true
      end
    end
    
    def function(arglist)
      @var = block_opened?
      ParseNode.new(:haml_comment, @var, :text => (var));Fi[	@‰i£I"÷      @var = (@var - 1)
      if respond_to?("close_#{node.type}", :include_private) then
        send("close_#{node.type}", var)
      end
    end
    
    def function(arglist)
      @var = false
      @var = nil;Fi[	@Xi%I"ã  def function(arglist)
    if keg and keg.completion_installed?(:bash) then
      "      Bash completion has been installed to:\n        #{HOMEBREW_PREFIX}/etc/bash_completion.d\n".undent
    end
  end
  
  def function(arglist)
    if keg and keg.completion_installed?(:zsh) then
      "      zsh completion has been installed to:\n        #{HOMEBREW_PREFIX}/share/zsh/site-functions\n".undent;Fi[	@Xi+I"+  def function(arglist)
    if keg and keg.completion_installed?(:zsh) then
      "      zsh completion has been installed to:\n        #{HOMEBREW_PREFIX}/share/zsh/site-functions\n".undent
    end
  end
  
  def function(arglist)
    var = []
    if (f.plist or (keg and keg.plist_installed?)) then;Fi[	I"(data//homebrew_proj/cmd/--config.rb;Ti,I"Ñ        end
        @var
      end
    end
  end
  
  def function(arglist)
    if instance_variable_defined?(:@clt) then
      @var;Fi[	@Ôi6I"      if MacOS::CLT.installed? and (MacOS::Xcode.version.to_f >= 4.3) then
        @var = MacOS::CLT.version
      end
    end
  end
  
  def function(arglist)
    var = HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-parse --verify -q HEAD 2>/dev/null`.chomp;Fi[	@ÔiàI"π      Homebrew.dump_build_config)
    ensure
      $stdout = var
    end
  end
  
  def function(arglist)
    puts("HOMEBREW_VERSION: #{HOMEBREW_VERSION}")
    puts("ORIGIN: #{origin}");Fi[	I"%data//homebrew_proj/cmd/--env.rb;TiI"Ë    else
      var = ((build_env_keys(ENV) << "HOMEBREW_BREW_FILE") << "HOMEBREW_SDKROOT")
      var.each { |arglist| puts("export #{key}=\"#{ENV[key]}\"") }
    end
  end
  
  def function(arglist)
    ["CC", "CXX", "LD", "CFLAGS", "CXXFLAGS", "CPPFLAGS", "LDFLAGS", "SDKROOT", "MAKEFLAGS", "CMAKE_PREFIX_PATH", "CMAKE_INCLUDE_PATH", "CMAKE_LIBRARY_PATH", "CMAKE_FRAMEWORK_PATH", "MACOSX_DEPLOYMENT_TARGET", "PKG_CONFIG_PATH", "HOMEBREW_BUILD_FROM_SOURCE", "HOMEBREW_DEBUG", "HOMEBREW_MAKE_JOBS", "HOMEBREW_VERBOSE", "HOMEBREW_USE_CLANG", "HOMEBREW_USE_GCC", "HOMEBREW_USE_LLVM", "HOMEBREW_SVN", "HOMEBREW_GIT", "HOMEBREW_SDKROOT", "MAKE", "GIT", "CPP", "ACLOCAL_PATH", "OBJC", "PATH"].select do |arglist|
      var.fetch(var) if var.key?(var);Fi[	@ˆiI"°  def function(arglist)
    ["CC", "CXX", "LD", "CFLAGS", "CXXFLAGS", "CPPFLAGS", "LDFLAGS", "SDKROOT", "MAKEFLAGS", "CMAKE_PREFIX_PATH", "CMAKE_INCLUDE_PATH", "CMAKE_LIBRARY_PATH", "CMAKE_FRAMEWORK_PATH", "MACOSX_DEPLOYMENT_TARGET", "PKG_CONFIG_PATH", "HOMEBREW_BUILD_FROM_SOURCE", "HOMEBREW_DEBUG", "HOMEBREW_MAKE_JOBS", "HOMEBREW_VERBOSE", "HOMEBREW_USE_CLANG", "HOMEBREW_USE_GCC", "HOMEBREW_USE_LLVM", "HOMEBREW_SVN", "HOMEBREW_GIT", "HOMEBREW_SDKROOT", "MAKE", "GIT", "CPP", "ACLOCAL_PATH", "OBJC", "PATH"].select do |arglist|
      var.fetch(var) if var.key?(var)
    end
  end
  
  def function(arglist)
    build_env_keys(var).each do |arglist|
      var = var[var];Fi[	@dirI"‚      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|
      var = Formula.factory(var.formula) rescue problem("Can't find conflicting formula \"#{req.formula}\".");Fi[	@dixI"<  def function(arglist)
    f.conflicts.each do |arglist|
      var = Formula.factory(var.formula) rescue problem("Can't find conflicting formula \"#{req.formula}\".")
    end
  end
  
  def function(arglist)
    unless f.homepage =~ /^https?:\/\// then
      problem("The homepage should start with http or https.");Fi[	@diìI"    end
    if var.any? { |arglist| var =~ /^git:\/\/github\.com\// } then
      problem("Use https:// URLs for accessing GitHub repositories.")
    end
  end
  
  def function(arglist)
    problem("Head-only (no stable download)") if f.head_only?
    [:stable, :devel].each do |arglist|;Fi[	@di¿I"Í          problem("#{cksum.hash_type} should be lowercase")
        end
      end
    end
  end
  
  def function(arglist)
    ENV.setup_build_environment
    Patches.new(f.patches).select { |arglist| var.external? }.each do |arglist|;Fi[	@di–I"ı      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then
      problem("Use a space in class inheritance: class Foo < #{$1}");Fi[	@di#I"«    end
    if text =~ /skip_clean\s+:all/ then
      problem("`skip_clean :all` is deprecated; brew no longer strips symbols")
    end
  end
  
  def function(arglist)
    audit_file
    audit_specs;Fi[	I"&data//homebrew_proj/cmd/bottle.rb;TiI"      puts("  version #{bottle_version}") if (var > 0)
      puts("  sha1 '#{(directory / filename).sha1}' => :#{MacOS.cat}")
      puts("end")
    end
  end
  
  def function(arglist)
    ARGV.formulae.each { |arglist| bottle_formula(Formula.factory(var)) }
  end;Fi[	@giI"…      end
    else
      ARGV.formulae.each { |arglist| cleanup_formula(var) }
    end
  end
  
  def function(arglist)
    var = Formula.factory(var)
    if var.installed? and var.rack.directory? then;Fi[	@gi:I"      if (var.rack.children.length > 1) then
        opoo("Skipping #{f.name}: most recent version #{f.version} not installed")
      end
    end
  end
  
  def function(arglist)
    return unless HOMEBREW_CACHE.directory?
    HOMEBREW_CACHE.children.each do |arglist|;Fi[	@giOI"ê          end
        end
      end
    end
  end
  
  def function(arglist)
    system("find #{HOMEBREW_PREFIX} -name .DS_Store -delete")
  end;Fi[	@ti#I"¥        end
      end
      exec_editor(*var)
    end
  end
  
  def function(arglist)
    Dir["#{HOMEBREW_REPOSITORY}/Library/*"].reject do |arglist|
      case File.basename(var);Fi[	I"$data//homebrew_proj/cmd/info.rb;Ti I"ÿ      else
        ARGV.formulae.each { |arglist| info_formula(var) }
      end
    end
  end
  
  def function(arglist)
    require("vendor/multi_json")
    var = ARGV.include?("--all") ? (Formula) : (ARGV.formulae);Fi[	@i+I"&      puts(MultiJson.encode(var.pop))
    else
      puts(MultiJson.encode(var))
    end
  end
  
  def function(arglist)
    if which("git") and (HOMEBREW_REPOSITORY / ".git").directory? then
      if `git remote -v` =~ /origin\s+(https?:\/\/|git(?:@|:\/\/))github.com[:\/](.+)\/homebrew/ then;Fi[	@i3I"      if `git remote -v` =~ /origin\s+(https?:\/\/|git(?:@|:\/\/))github.com[:\/](.+)\/homebrew/ then
        $2
      end
    end
  end
  
  def function(arglist)
    var = var.path.realpath
    if var.to_s =~ /#{HOMEBREW_REPOSITORY}\/Library\/Taps\/(\w+)-(\w+)\/(.*)/ then;Fi[	I"'data//homebrew_proj/cmd/install.rb;Ti$I"h      abort("        Sorry, Homebrew does not support your computer's CPU architecture.\n        For PPC support, see: https://github.com/mistydemeo/tigerbrew\n".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    if HOMEBREW_CELLAR.exist? and HOMEBREW_CELLAR.writable_real?.! then
      raise("Cannot write to #{HOMEBREW_CELLAR}");Fi[	@i-I"Ï    end
    unless (HOMEBREW_PREFIX.writable_real? or (HOMEBREW_PREFIX.to_s == "/usr/local")) then
      raise("Cannot write to #{HOMEBREW_PREFIX}")
    end
  end
  
  def function(arglist)
    require("cmd/doctor")
    var = Checks.new;Fi[	@i6I"    ["check_for_latest_xcode", "check_xcode_license_approved"].each do |arglist|
      var = var.send(var)
      opoo(var) unless var.nil?
    end
  end
  
  def function(arglist)
    unless MacOS.macports_or_fink.empty? then
      opoo("It appears you have MacPorts or Fink installed.");Fi[	@i>I"Ú      opoo("It appears you have MacPorts or Fink installed.")
      puts("Software installed with other package managers causes known problems for")
      puts("Homebrew. If a formula fails to build, uninstall MacPorts/Fink and try again.")
    end
  end
  
  def function(arglist)
    FileUtils.mkdir_p(HOMEBREW_CELLAR) if File.exist?(HOMEBREW_CELLAR).! rescue raise("      Could not create #{HOMEBREW_CELLAR}\n      Check you have permission to write to #{HOMEBREW_CELLAR.parent}\n".undent)
  end;Fi[	@iRI"∆    unless var.empty? then
      perform_preinstall_checks
      var.each { |arglist| install_formula(var) }
    end
  end
  
  def function(arglist)
    begin
      (var = FormulaInstaller.new(var);Fi[	@ziLI"¢          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = []
    var = [];Fi[	I"'data//homebrew_proj/cmd/options.rb;Ti!I"™        dump_options_for_formula(var)
        puts
      end
    end
  end
  
  def function(arglist)
    var.build.sort_by(&:flag).each do |arglist|
      puts(var.flag);Fi[	I"(data//homebrew_proj/cmd/outdated.rb;TiI"∑      else
        puts(var.name)
      end
    end
  end
  
  def function(arglist)
    Formula.installed.map do |arglist|
      var = var.rack.subdirs.map { |arglist| Keg.new(var) };Fi[	@i6I"≤          end
        end
      end
    end
  end
  
  def function(arglist)
    (if (HOMEBREW_LIBRARY / "Taps/#{user.downcase}-#{repo.downcase}").directory? then
      return [];Fi[	I"#data//homebrew_proj/cmd/tap.rb;TiI"Ó      end
    else
      (ARGV.first == "--repair") ? (repair_taps) : (install_tap(*tap_args))
    end
  end
  
  def function(arglist)
    raise("brew install git") unless which("git")
    var = (var == "homebrew") ? ("Homebrew") : (var);Fi[	I")data//homebrew_proj/cmd/uninstall.rb;Ti*I"˛    rescue MultipleVersionsInstalledError => var
      ofail(var)
      puts("Use `brew remove --force #{e.name}` to remove all versions.")
    end
  end
  
  def function(arglist)
    var = ((HOMEBREW_PREFIX / :opt) / var)
    var.unlink if var.symlink?;Fi[	@ài7I"  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-list --abbrev-commit HEAD -- Library/Formula/#{name}.rb`.split
    end
  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      `git cat-file blob #{var}:Library/Formula/#{name}.rb`;Fi[	@ài=I"Ë  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      `git cat-file blob #{var}:Library/Formula/#{name}.rb`
    end
  end
  
  def function(arglist)
    rev_list.find { |arglist| (var == version_for_sha(var)) }
  end;Fi[	I"%data//homebrew_proj/compilers.rb;Ti=I"ê      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist)
    (@var.to_sym == var.to_sym)
  end;Fi[	@îiI"¶      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var.each_with_index do |arglist|
      if var.is_a?(Hash) then;Fi[	@îiUI"Õ      puts("Trying a mirror...")
      @var = @var.shift
      retry
    end
  end
  
  def function(arglist)
    if @var.to_s.match(bottle_regex) then
      ohai("Pouring #{File.basename(@tarball_path)}");Fi[	@îi{I"∆      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var = /https?:\/\/(www\.)?github\.com\/.*\/(zip|tar)ball\//
    if var.match(@var) then;Fi[	@îiœI"£      else
        fetch_repo(@var, @var)
      end
    end
  end
  
  def function(arglist)
    quiet_safe_system(@@var, "export", "--force", @var, Dir.pwd)
  end;Fi[	@îiﬁI"
    `'#{shell_quote(svn)}' propget svn:externals '#{shell_quote(@var)}'`.chomp.each_line do |arglist|
      var, var = var.split(/\s+/)
      yield(var, var)
    end
  end
  
  def function(arglist)
    var = var.exist? ? ("up") : ("checkout")
    var = [@@var, var];Fi[	@îi?I"ù      end
      ((var << @var) << @var)
      safe_system(*var)
    end
  end
  
  def function(arglist)
    var = Dir.getwd
    Dir.chdir(@var) do |arglist|;Fi[	@îitI"˚        safe_system("/usr/bin/cvs", "-d", var, "login")
        safe_system("/usr/bin/cvs", "-d", var, "checkout", "-d", @var, var)
      end
    end
  end
  
  def function(arglist)
    FileUtils.cp_r(Dir[(@var + "{.}")], Dir.pwd)
    require("find");Fi[	@îióI")  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install mercurial") unless hgpath
    ohai("Cloning #{@url}");Fi[	@îi¶I"π    else
      var = @var.sub(/^hg:\/\//, "")
      safe_system(hgpath, "clone", var, @var)
    end
  end
  
  def function(arglist)
    var = Dir.getwd
    Dir.chdir(@var) do |arglist|;Fi[	@îi¡I"  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install bazaar") unless bzrpath
    ohai("Cloning #{@url}");Fi[	@îiÕI"¯    else
      var = @var.sub(/^bzr:\/\//, "")
      safe_system(bzrpath, "checkout", "--lightweight", var, @var)
    end
  end
  
  def function(arglist)
    FileUtils.cp_r(Dir[(@var + "{.}")], Dir.pwd)
    FileUtils.rm_r(Dir[(Dir.pwd + "/.bzr")]);Fi[	@îi·I"  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install fossil") unless fossilpath
    ohai("Cloning #{@url}");Fi[	@îiÌI"–    else
      var = @var.sub(/^fossil:\/\//, "")
      safe_system(fossilpath, "clone", var, @var)
    end
  end
  
  def function(arglist)
    safe_system(fossilpath, "open", @var)
    if @var and @var then;Fi[	I"&data//homebrew_proj/exceptions.rb;Ti+I"      "      No available formula for #{$3} #{dependent_s}\n      Please tap it and then try again: brew tap #{$1}/#{$2}\n".undent
    else
      "No available formula for #{name} #{dependent_s}"
    end
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@£iãI"Ü        raise
      end
      false
    end
  end
  
  def function(arglist)
    require("fileutils")
    FileUtils.chmod_R(var, to_s);Fi[	@£iøI"î      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("r") { |arglist| var.read(1024) })
  end;Fi[	@£iI"j          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s)
  end;Fi[	@£iI"¿      yield)
    ensure
      chmod(var) if var
    end
  end
  
  def function(arglist)
    unless self.symlink? then
      raise("Cannot install info entry for unbrewed info file '#{self}'");Fi[	@£i3I"¸    end
    children.each do |arglist|
      var.all_formula(var) { |arglist| yield(var) } if var.directory?
    end
  end
  
  def function(arglist)
    if (self == (HOMEBREW_LIBRARY / "Taps/adamv-alt")) then
      all_formula { |arglist| yield(var) };Fi[	@®i=I"N    rescue FormulaUnavailableError => var
      var.dependent = f.name
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? then
      raise(CannotInstallFormulaError, "        #{f}-#{f.linked_keg.realpath.basename} already installed\n        To install this version, first `brew unlink #{f}'\n".undent);Fi[	@®izI"¬      var.finish)
    ensure
      var.link if var and var.installed?.! rescue nil
    end
  end
  
  def function(arglist)
    if f.keg_only?.! and ARGV.homebrew_developer? then
      audit_bin;Fi[	@®iÑI"∫    unless var.empty? then
      @var = true
      ohai("Caveats", var.caveats)
    end
  end
  
  def function(arglist)
    ohai("Finishing up") if ARGV.verbose?
    if f.keg_only? then;Fi[	@®i¢I"‰  def function(arglist)
    unless (install_bottle or (ARGV.interactive? or @var.nil?)) then
      @var ||= (Time.now - @var)
    end
  end
  
  def function(arglist)
    begin
      (FileUtils.rm(Dir["#{HOMEBREW_LOGS}/#{f}/*"]);Fi[	@®i…I"Ô        f.rack.rmdir_if_possible
      end
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? and (f.linked_keg.realpath == f.prefix) then
      opoo("This keg was marked linked already, continuing anyway");Fi[	@®i‹I"‚      @var = true
      ignore_interrupts { |arglist| var.unlink }
      raise unless var.kind_of?(RuntimeError)
    end
  end
  
  def function(arglist)
    return unless f.plist
    f.plist_path.unlink if f.plist_path.exist?;Fi[	@®iÔI"Ω      puts("formula against it.")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    begin
      (ohai("Cleaning") if ARGV.verbose?;Fi[	@®iI"      puts("Still, the installation was successful, so we will link it into your prefix")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    var, var = f.fetch
    f.verify_download_integrity(var) unless var.local_bottle_path;Fi[	@®iI"µ          @var = true
        end
      end
    end
  end
  
  def function(arglist)
    if (f.prefix + "man").directory? then
      opoo("A top-level \"man\" directory was found.");Fi[	@®i!I"2      puts("Homebrew requires that man pages live under share.")
      puts("This can often be fixed by passing \"--mandir=\#{man}\" to configure.")
      @var = true
    end
  end
  
  def function(arglist)
    if (f.prefix + "info").directory? then
      opoo("A top-level \"info\" directory was found.");Fi[	@®i*I"8      puts("Homebrew suggests that info pages live under share.")
      puts("This can often be fixed by passing \"--infodir=\#{info}\" to configure.")
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?
    var = f.lib.children.select { |arglist| var.to_s =~ /\.jar$/ };Fi[	@®i9I"˙      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?
    var = [".a", ".dylib", ".framework", ".jnilib", ".la", ".o", ".so", ".jar", ".prl", ".pm", ".sh"];Fi[	@®iII"Ë      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?
    var = f.bin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@®iUI"Í      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?
    var = f.sbin.children.select { |arglist| (var.directory? or var.executable?.!) };Fi[	@®iaI"ò      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars
    check_non_libraries;Fi[	I"+data//homebrew_proj/formula_support.rb;Ti-I"ö    unless var.nil? then
      @var = var.delete(:using)
      @var = var
    end
  end
  
  def function(arglist)
    @var ||= case var
    when nil then;Fi[	@Äi:I"}      var.new(var)
    else
      Version.new(var)
    end
  end
  
  def function(arglist)
    @var ||= []
    (@var << var);Fi[	@´i¶I"ª      opoo("Could not link #{fname}. Unlinking...")
      unlink
      raise
    end
  end
  
  def function(arglist)
    var = ((HOMEBREW_PREFIX / :opt) / fname)
    if var.symlink? then;Fi[	@´i¬I")      if ARGV.verbose? then
        puts("Won't resolve conflicts for symlink #{dst} as it doesn't resolve into the Cellar")
      end
    end
  end
  
  def function(arglist)
    if var.exist? and (var.realpath == var.realpath) then
      puts("Skipping; already exists: #{dst}") if ARGV.verbose?;Fi[	@∂i=I"Õ  def function(arglist)
    join("lib").find do |arglist|
      break var if (var.basename == Pathname.new(var))
    end
  end
  
  def function(arglist)
    var = []
    var = ["bin", "lib", "Frameworks"];Fi[	I" data//homebrew_proj/mach.rb;TiKI"x      archs.first
    else
      :universal
    end
  end
  
  def function(arglist)
    (arch == :universal)
  end;Fi[	I"'data//homebrew_proj/macos/xcode.rb;Ti(I"ﬂ      else
        raise("Mac OS X `#{MacOS.version}' is invalid")
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new(folder)
    if var.absolute? and (var / "usr/bin/make").executable? then;Fi[	@éiyI"w        else
          "4.5"
        end
      end
  end
  
  def function(arglist)
    (version.to_f < 4.3)
  end;Fi[	I")data//homebrew_proj/macos/xquartz.rb;Ti;I"Ω      if Pathname.new("/usr/X11/lib/libpng.dylib").exist? then
        Pathname.new("/usr/X11")
      end
    end
  end
  
  def function(arglist)
    version.nil?.! and prefix.nil?.!
  end;Fi[	@¡iI"Ê          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist)
    (@var ||= {}).fetch(var.to_s) do |arglist|
      @var[var.to_s] = if File.executable?("/usr/bin/#{tool}") then;Fi[	@¡i*I"Y        var = ["#{xcrun_path}", "#{dev_tools_path}/#{tool}", "#{xctoolchain_path}/usr/bin/#{tool}"]
        var.map { |arglist| Pathname.new(var) }.find { |arglist| var.executable? }
      end
    end
  end
  
  def function(arglist)
    @var ||= if File.exist?("/usr/bin/cc") and File.exist?("/usr/bin/make") then
      Pathname.new("/usr/bin");Fi[	@¡i8I"ﬂ          Pathname.new("#{Xcode.prefix}/usr/bin")
        end
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new("#{Xcode.prefix}/Toolchains/XcodeDefault.xctoolchain")
    var if var.exist?);Fi[	@¡iII"S      (var << "#{Xcode.prefix}/Platforms/MacOSX.platform/Developer/SDKs/MacOSX#{v}.sdk")
      (var << "/Developer/SDKs/MacOSX#{v}.sdk")
      var.map { |arglist| Pathname.new(var) }.detect { |arglist| var.directory? })
    end
  end
  
  def function(arglist)
    var = locate("cc")
    Pathname.new(var).realpath.basename.to_s rescue nil;Fi[	@¡i_I"”      else
        (Xcode.version >= "4.2") ? (:llvm) : (:gcc)
      end
    end
  end
  
  def function(arglist)
    @var ||= if locate("gcc-4.0") then
      `#{locate("gcc-4.0")} --version` =~ /build (\d{4,})/;Fi[	@¡ifI"4    @var ||= if locate("gcc-4.0") then
      `#{locate("gcc-4.0")} --version` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("gcc-4.2") and locate("gcc-4.2").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("gcc-4.2")} --version` =~ /build (\d{4,})/;Fi[	@¡imI";    @var ||= if locate("gcc-4.2") and locate("gcc-4.2").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("gcc-4.2")} --version` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("llvm-gcc") then
      `#{locate("llvm-gcc")} --version` =~ /LLVM build (\d{4,})/;Fi[	@¡itI"    @var ||= if locate("llvm-gcc") then
      `#{locate("llvm-gcc")} --version` =~ /LLVM build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("clang") then
      `#{locate("clang")} --version` =~ /clang version (\d\.\d)/;Fi[	@¡i{I"    @var ||= if locate("clang") then
      `#{locate("clang")} --version` =~ /clang version (\d\.\d)/
      $1
    end
  end
  
  def function(arglist)
    @var ||= if locate("clang") then
      `#{locate("clang")} --version` =~ /tags\/Apple\/clang-(\d{2,})/;Fi[	@¡i¢I"›    end
    STANDARD_COMPILERS[var].all? do |arglist|
      (MacOS.send(:"#{var}_version") == var)
    end
  end
  
  def function(arglist)
    var = mdfind(var).first
    Pathname.new(var) unless (var.nil? or var.empty?);Fi[	I"#data//homebrew_proj/patches.rb;TiI"¥        (@var << Patch.new(var, ("%03d-homebrew.diff" % var), var))
        var = (var + 1)
      end
    end
  end
  
  def function(arglist)
    external_curl_args.empty?.!
  end;Fi[	@™i[I"~      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    @var.nil?.!
  end;Fi[	I"(data//homebrew_proj/requirements.rb;Ti*I"∑      ["/usr/bin/env", "rbx", "-rubygems", "-e", "require '#{@import_name}'"]
    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var
    when :chicken then;Fi[	I",data//homebrew_proj/test/test_bucket.rb;TiLI"û        Homebrew.info_formula(var)
        Homebrew.prune
      end
    end
  end
  
  def function(arglist)
    require("cmd/cleanup")
    var = TestBall.new;Fi[	@≤iáI"¿        HOMEBREW_CACHE.chmod_R(511)
        var.unlink
      end
    end
  end
  
  def function(arglist)
    var = (HOMEBREW_CACHE / "foo-0.1.tar.gz")
    assert_equal(".tar.gz", var.extname);Fi[	I"/data//homebrew_proj/test/test_checksums.rb;TiI"  def function(arglist)
    assert_nothing_raised do |arglist|
      nostdout { |arglist| var.brew { |arglist| } }
    end
  end
  
  def function(arglist)
    assert_raises(ChecksumMismatchError) do |arglist|
      nostdout { |arglist| var.brew { |arglist| } };Fi[	@∑iI"Î  def function(arglist)
    assert_raises(ChecksumMismatchError) do |arglist|
      nostdout { |arglist| var.brew { |arglist| } }
    end
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|;Fi[	I"/data//homebrew_proj/test/test_compilers.rb;TiI"◊  def function(arglist)
    ["HOMEBREW_USE_CLANG", "HOMEBREW_USE_LLVM", "HOMEBREW_USE_GCC"].each do |arglist|
      ENV.delete(var)
    end
  end
  
  def function(arglist)
    ENV.send(MacOS.default_compiler)
  end;Fi[	I"-data//homebrew_proj/test/test_formula.rb;TiI",        assert_equal(File.expand_path(var.prefix), ((HOMEBREW_CELLAR + var.name) + "0.1").to_s)
        assert_kind_of(Pathname, var.prefix)
      end
    end
  end
  
  def function(arglist)
    assert_equal("ShellFm", Formula.class_s("shell.fm"))
    assert_equal("Fooxx", Formula.class_s("foo++"));Fi[	@øi$I"^  def function(arglist)
    assert_raises(RuntimeError) do |arglist|
      eval("      class TestBallOverrideBrew < Formula\n        def initialize\n          super \"foo\"\n        end\n        def brew\n        end\n      end\n")
    end
  end
  
  def function(arglist)
    var = MostlyAbstractFormula.new
    assert_equal("__UNKNOWN__", var.name);Fi[	@øi5I"2      var, var = var.fetch
      assert_equal(var.url, "file:///#{TEST_FOLDER}/bad_url/testball-0.1.tbz")
      assert_equal(var.url, "file:///#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    end
  end
  
  def function(arglist)
    var = SpecTestBall.new
    assert_equal("http://example.com", var.homepage);Fi[	@øi©I"«      assert_version_equal("0.1", var.bottle.version)
    else
      assert_nil(var.bottle)
    end
  end
  
  def function(arglist)
    var = AncientBottleSpecTestBall.new
    assert_nil(var.bottle);Fi[	I"5data//homebrew_proj/test/test_formula_install.rb;Ti;I"      assert_equal(3, HOMEBREW_PREFIX.children.length)
      assert((HOMEBREW_PREFIX + "bin").directory?)
      assert_equal(3, (HOMEBREW_PREFIX + "bin").children.length)
    end
  end
  
  def function(arglist)
    var = TestScriptFileFormula.new
    temporary_install(var) do |arglist|;Fi[	@∆i'I"        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|;Fi[	@∆i1I"        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|;Fi[	@∆i;I"        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|;Fi[	I"6data//homebrew_proj/test/test_pathname_install.rb;TiI"      (TEMP_FOLDER + "a.txt").write("This is sample file a.")
      (TEMP_FOLDER + "b.txt").write("This is sample file b.")
      yield
    end
  end
  
  def function(arglist)
    assert_raises(RuntimeError) do |arglist|
      Pathname.getwd.install("non_existant_file");Fi[	@—iI"Ê  def function(arglist)
    assert_raises(RuntimeError) do |arglist|
      Pathname.getwd.install("non_existant_file")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt");Fi[	@—i!I"/      TARGET_FOLDER.install("a.txt")
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(["a.txt", "b.txt"]);Fi[	@—i)I"2      TARGET_FOLDER.install(["a.txt", "b.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(Dir["*.txt"]);Fi[	@—i1I"!      TARGET_FOLDER.install(Dir["*.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("bin");Fi[	@—i;I"3      TARGET_FOLDER.install("bin")
      assert((TARGET_FOLDER + "bin/a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "bin/b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt" => "c.txt");Fi[	@—iDI"w      assert((TARGET_FOLDER + "c.txt").exist?, "c.txt not installed.")
      assert((TARGET_FOLDER + "a.txt").exist?.!, "a.txt was installed but not renamed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt" => "c.txt", "b.txt" => "d.txt");Fi[	@—iNI"b      assert((TARGET_FOLDER + "d.txt").exist?, "d.txt not installed.")
      assert((TARGET_FOLDER + "a.txt").exist?.!, "a.txt was installed but not renamed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed but not renamed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("bin");Fi[	I"-data//homebrew_proj/test/test_updater.rb;Ti>I"Ô      var.merge!(var.report)
      assert(var.expectations_met?)
      assert(var.empty?)
    end
  end
  
  def function(arglist)
    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|;Fi[	@‚iRI"      assert(var.select_formula(:M).empty?)
      assert(var.select_formula(:A).empty?)
      assert(var.select_formula(:R).empty?)
    end
  end
  
  def function(arglist)
    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|;Fi[	I";data//homebrew_proj/vendor/multi_json/vendor/okjson.rb;TidI"        var, var = valparse(var)
        (var << var)
        return [var, var[(1..-1)]] if (var[0][0] == "]")
      end
    end
    
    def function(arglist)
      raise(Error, "expected #{typ} (got #{ts[0].inspect})") if var[0][0].!=(var)
      var[(1..-1)];Fi[	@Ái°I"π        [:space, var[0, 1], var[0, 1]]
      else
        numtok(var)
      end
    end
    
    def function(arglist)
      (var[0, 4] == "null") ? ([:val, "null", nil]) : ([])
    end;Fi[	@ÁiæI"ﬁ        end
      else
        []
      end
    end
    
    def function(arglist)
      var = /"([^"\\]|\\["\/\\bfnrt]|\\u[0-9a-fA-F]{4})*"/.match(var)
      raise(Error, "invalid string literal at #{abbrev(s)}") if var.!;Fi[	@Ái&I";        var[(var + 2)] = Utagx.|((var >> 6).&(Umaskx)).chr
        var[(var + 3)] = Utagx.|(var.&(Umaskx)).chr
        4)
      end
    end
    
    def function(arglist)
      raise(Error, "short") if var.length.!=(4)
      (nibble(var[0]) << 12).|((nibble(var[1]) << 8)).|((nibble(var[2]) << 4)).|(nibble(var[3]));Fi[	@ÁiWI"±        arrenc(var)
      else
        raise(Error, "root value must be an Array or a Hash")
      end
    end
    
    def function(arglist)
      case var
      when Hash then;Fi[	@ÁipI"Ï        else
          raise(Error, "cannot encode #{x.class}: #{x.inspect}")
        end
      end
    end
    
    def function(arglist)
      (("{" + var.map { |arglist| ((keyenc(var) + ":") + valenc(var)) }.join(",")) + "}")
    end;Fi[	@ÁiÅI"º        strenc(var)
      else
        raise(Error, "Hash key is not a string: #{k.inspect}")
      end
    end
    
    def function(arglist)
      var = StringIO.new
      var.putc("\"");Fi[	I"#data//homebrew_proj/version.rb;TiI"†      var.to_i
    else
      var
    end
  end
  
  def function(arglist)
    return unless var.is_a?(VersionElement)
    return -1 if string? and var.numeric?;Fi[	I"3data//jekyll_proj/jekyll/converters/textile.rb;TiI"m        STDERR.puts("You are missing a library required for Textile. Please run:")
        STDERR.puts("  $ [sudo] gem install RedCloth")
        raise(FatalException.new("Missing dependency: RedCloth"))
      end
    end
    
    def function(arglist)
      var = (("(" + @var["textile_ext"].gsub(",", "|")) + ")")
      var.=~(Regexp.new(var, Regexp::IGNORECASE));Fi[	I"%data//jekyll_proj/jekyll/post.rb;TiÈI"—        self.site.posts[(var + 1)]
      else
        nil
      end
    end
    
    def function(arglist)
      var = self.site.posts.index(self)
      var and (var > 0) ? (self.site.posts[(var - 1)]) : (nil);Fi[	I"/data//jekyll_proj/jekyll/tags/highlight.rb;TiI"         end
      else
        raise(SyntaxError.new("Syntax Error in 'highlight' - Valid syntax: highlight <lang> [linenos]"))
      end
    end
    
    def function(arglist)
      if var.registers[:site].pygments then
        render_pygments(var, super);Fi[	@ˇi'I"	        render_pygments(var, super)
      else
        render_codehighlighter(var, super)
      end
    end
    
    def function(arglist)
      @var[:encoding] = "utf-8"
      var = add_code_tags(Pygments.highlight(var, :lexer => (@var), :options => (@var)), @var);Fi[	@ói(I"€        send(var).inject({}) do |arglist|
          var[var] = var
          var
        end
      end
      
      def function(arglist)
        var = var.new(klass.aliased_fields, klass.fields)
        var.merge!(var);Fi[	@i0I"Ò        else
          (var = (["."] + var.value[(1..-1)])
          "#{node.value.first}#{args.join(", ")})")
        end
      end
      
      def function(arglist)
        var = var.value.first
        if (:ELEMENT_NAME == var.type) then;Fi[	@i9I"÷          "not(self::#{child.accept(self)})"
        else
          "not(#{child.accept(self)})"
        end
      end
      
      def function(arglist)
        var.value.first =~ /^#(.*)$/
        "@id = '#{$1}'";Fi[	@i]I"è          ("substring(#{attribute}, string-length(#{attribute}) - " + "string-length(#{value}) + 1, string-length(#{value})) = #{value}")
        else
          ((var + " #{node.value[1]} ") + "#{value}")
        end
      end
      
      def function(arglist)
        if var.value.first.is_a?(Nokogiri::CSS::Node) and (var.value.first.type == :FUNCTION) then
          var.value.first.accept(self);Fi[	@izI"À          else
            (var.value.first + "(.)")
          end
        end
      end
      
      def function(arglist)
        "contains(concat(' ', @class, ' '), ' #{node.value.first} ')"
      end;Fi[	@iÆI"¿            end)
          rescue Nokogiri::SyntaxError, RuntimeError
            nil
          end
        end
        
        def function(arglist)
          @var = var
          @var = nil;Fi[	I",data//nokogiri_proj/nokogiri/version.rb;Ti%I"ˆ        ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end
    
    def function(arglist)
      var = {}
      var["warnings"] = [];Fi[	I"(data//omni_proj/omniauth/builder.rb;TiI"£        @var = var
        super(&var)
        (@var << @var)
      end
    end
    
    def function(arglist)
      (Rack.release.split(".")[1].to_i >= 4)
    end;Fi[	@≥i€I"‡        options.request_path.call(env)
      else
        on_path?(request_path)
      end
    end
    
    def function(arglist)
      if options.callback_path.respond_to?(:call) then
        options.callback_path.call(env);Fi[	@≥i„I"≤        options.callback_path.call(env)
      else
        on_path?(callback_path)
      end
    end
    
    def function(arglist)
      (current_path.casecmp(var) == 0)
    end;Fi[	@≥ifI"Æ        var
      else
        options[var]
      end
    end
    
    def function(arglist)
      if options[:request_path].is_a?(String) then
        options[:request_path];Fi[	@≥inI"œ        options[:request_path]
      else
        "#{path_prefix}/#{name}"
      end
    end
    
    def function(arglist)
      if options[:callback_path].is_a?(String) then
        options[:callback_path];Fi[	@≥ivI"Ï        options[:callback_path]
      else
        (custom_path(:request_path) or "#{path_prefix}/#{name}/callback")
      end
    end
    
    def function(arglist)
      (options[:setup_path] or "#{path_prefix}/#{name}/setup")
    end;Fi[	@≥iïI"“        var.query = nil
        var.scheme = "https" if request.ssl?
        var.to_s)
      end
    end
    
    def function(arglist)
      (((full_host + script_name) + callback_path) + query_string)
    end;Fi[	@∂iI"Z      def function(arglist)
        it("sets an auth hash") do |arglist|
          expect(last_request.env["omniauth.auth"]).to(be_kind_of(Hash))
        end
      end
      
      def function(arglist)
        it("sets the provider to #{provider}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["provider"]).to(eq(var));Fi[	@∂iI"e      def function(arglist)
        it("sets the provider to #{provider}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["provider"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("sets the UID to #{uid}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["uid"]).to(eq(var));Fi[	@∂iI"h      def function(arglist)
        it("sets the UID to #{uid}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["uid"]).to(eq(var))
        end
      end
      
      def function(arglist)
        it("sets the user_info to #{user_info}") do |arglist|
          expect((last_request.env["omniauth.auth"] or {})["user_info"]).to(eq(var));Fi[	I"1data//paperclip_proj/paperclip/attachment.rb;Ti>I"8        unless @var.respond_to?("#{name}_#{field}") and @var.respond_to?("#{name}_#{field}=") then
          raise(Paperclip::Error.new("#{@instance.class} model missing required attr_accessor for '#{name}_#{field}'"))
        end
      end
    end
    
    def function(arglist)
      Paperclip.log(var)
    end;Fi[	@(inI"4        instance.run_paperclip_callbacks(:"#{name}_post_process") do |arglist|
          post_process_styles(*var)
        end
      end
    end
    
    def function(arglist)
      if styles.include?(:original) and process_style?(:original, var) then
        post_process_style(:original, styles[:original]);Fi[	@(iwI"ı      end
      styles.reject { |arglist| (var == :original) }.each do |arglist|
        post_process_style(var, var) if process_style?(var, var)
      end
    end
    
    def function(arglist)
      begin
        (if var.processors.blank? then;Fi[	@(iÜI"      rescue Paperclip::Error => var
        log("An error was received while processing: #{e.inspect}")
        ((@var[:processing] ||= []) << var.message) if @var[:whiny]
      end
    end
    
    def function(arglist)
      (var.empty? or var.include?(var))
    end;Fi[	@(iØI"        if var.respond_to?(:unlink) and (var.path.present? and File.exist?(var.path)) then
          var.unlink
        end
      end
    end
    
    def function(arglist)
      if @var[:restricted_characters] then
        var.gsub(@var[:restricted_characters], "_");Fi[	I"/data//paperclip_proj/paperclip/geometry.rb;TiÖI"        [("%dx" % var.width), var.width]
      else
        [("x%d" % var.height), var.height]
      end
    end
    
    def function(arglist)
      if (var.horizontal? or var.square?) then
        ("%dx%d+%d+%d" % [var.width, var.height, 0, (((self.height * var) - var.height) / 2)]);Fi[	I"@data//paperclip_proj/paperclip/geometry_detector_factory.rb;TiI"‘        ""
      rescue Cocaine::CommandNotFoundError => var
        raise_because_imagemagick_missing
      end
    end
    
    def function(arglist)
      @var.respond_to?(:path) ? (@var.path) : (@var)
    end;Fi[	@6i&I"R    def function(arglist)
      if path.blank? then
        raise(Errors::NotIdentifiedByImageMagickError.new("Cannot find the geometry of a file with a blank name"))
      end
    end
    
    def function(arglist)
      raise(Errors::CommandNotFoundError.new("Could not run the `identify` command. Please install ImageMagick."))
    end;Fi[	I".data//paperclip_proj/paperclip/helpers.rb;Ti+I"    def function(arglist)
      class_for(var).unscoped.where("#{name}_file_name IS NOT NULL").find_each do |arglist|
        yield(var)
      end
    end
    
    def function(arglist)
      var.split("::").inject(Object) do |arglist|
        if var.const_defined?(var) then;Fi[	@;i5I"≥        else
          var.const_missing(var)
        end
      end
    end
    
    def function(arglist)
      @var ||= {}
      var = (var or Attachment.default_options[:path]);Fi[	I"7data//paperclip_proj/paperclip/instance_methods.rb;TiI"    def function(arglist)
      self.attachment_definitions.each do |arglist|
        yield(var, attachment_for(var))
      end
    end
    
    def function(arglist)
      Paperclip.log("Saving attachments.")
      each_attachment { |arglist| var.send(:save) };Fi[	@Ãi1I">            (var << accepted_types_and_failures)
            (var << "\n\n") if @var.present? and @var.present?
            (var << rejected_types_and_failures)
          end
        end
        
        def function(arglist)
          "validate the content types allowed on attachment #{@attachment_name}"
        end;Fi[	@ÃiCI"                (var << "  All were accepted successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          if @var.present? then
            "Reject content types: #{@rejected_types.join(", ")}\n".tap do |arglist|;Fi[	@ÃiOI"◊                (var << "  All were rejected successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          "Expected #{@attachment_name}:\n"
        end;Fi[	@⁄iCI"—            self
          end.class_eval do |arglist|
            define_method(var, &var)
          end
        end
        
        def function(arglist)
          begin
            (var = StringIO.new(".");Fi[	@⁄iQI"	            @var.errors[:"#{@var}_file_size"].blank?)
          ensure
            @var.send(@var).post_processing = true
          end
        end
        
        def function(arglist)
          (@var.nil? or passes_validation_with_size((@var - 1)).!)
        end;Fi[	I"0data//paperclip_proj/paperclip/processor.rb;Ti.I"Q        load_processor(var) unless Paperclip.const_defined?(var)
        var = Paperclip.const_get(var)
        @var[var.to_s] = var
      end
    end
    
    def function(arglist)
      if defined? Rails.root and Rails.root then
        require(File.expand_path(Rails.root.join("lib", "paperclip_processors", "#{name.underscore}.rb")));Fi[	@Mi4I"    def function(arglist)
      if defined? Rails.root and Rails.root then
        require(File.expand_path(Rails.root.join("lib", "paperclip_processors", "#{name.underscore}.rb")))
      end
    end
    
    def function(arglist)
      @var.try(:clear)
    end;Fi[	@‚iI"C          COLUMNS.each_pair do |arglist|
            add_column(var, "#{attachment_name}_#{column_name}", var)
          end
        end
      end
      
      def function(arglist)
        if var.empty? then
          raise(ArgumentError, "Please specify attachment name in your remove_attachment call in your migration.");Fi[	@‚i'I"l          COLUMNS.each_pair do |arglist|
            remove_column(var, "#{attachment_name}_#{column_name}")
          end
        end
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("Method `drop_attached_file` in the migration has been deprecated and will be replaced by `remove_attachment`.")
        remove_attachment(*var);Fi[	@‚i6I"Z          COLUMNS.each_pair do |arglist|
            column("#{attachment_name}_#{column_name}", var)
          end
        end
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("Method `t.has_attached_file` in the migration has been deprecated and will be replaced by `t.attachment`.")
        attachment(*var);Fi[	@Ëi6I"™          end
        else
          true
        end
      end
      
      def function(arglist)
        for var, var in @var do
          (log("saving #{path(style)}");Fi[	@Ëi]I"          else
            directory.files.new(:key => (path(var))).public_url
          end
        end
      end
      
      def function(arglist)
        if directory.files.respond_to?(:get_http_url) then
          var = directory.files.get_http_url(path(var), var);Fi[	@ËiÖI"          else
            @var[:fog_host]
          end
        end
      end
      
      def function(arglist)
        if @var[:fog_directory].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then
          "#{@options[:fog_directory]}.s3.amazonaws.com";Fi[	@ËiçI"ﬂ          "#{@options[:fog_directory]}.s3.amazonaws.com"
        else
          "s3.amazonaws.com/#{@options[:fog_directory]}"
        end
      end
      
      def function(arglist)
        case var
        when File then;Fi[	@ËiûI"Ë          else
            raise(ArgumentError, "Credentials are not a path, file, hash or proc.")
          end
        end
      end
      
      def function(arglist)
        @var ||= ::Fog::Storage.new(fog_credentials)
      end;Fi[	@ÎiNI"          Paperclip.interpolates(:asset_host) do |arglist|
            "#{attachment.path(style).gsub(/^\//, "")}"
          end
        end
      end
      
      def function(arglist)
        if path then
          var = { :expires => (var), :secure => (use_secure_protocol?(var)) };Fi[	@ÎiUI"'        if path then
          var = { :expires => (var), :secure => (use_secure_protocol?(var)) }
          s3_object(var).url_for(:read, var.merge(s3_url_options)).to_s
        end
      end
      
      def function(arglist)
        @var ||= parse_credentials(@var[:s3_credentials])
      end;Fi[	@Îi≥I"          original_filename ? (s3_object(var).exists?) : (false)
        rescue AWS::Errors::Base => var
          false
        end
      end
      
      def function(arglist)
        var = (@var[var] or @var[:default])
        var = var.call(self, var) if var.respond_to?(:call);Fi[	@ÎiI"÷          var
        else
          raise(ArgumentError, "Credentials are not a path, file, proc, or hash.")
        end
      end
      
      def function(arglist)
        (s3_protocol(var) == "https")
      end;Fi[	@Úi?I"Î        @var.call(attachment.instance)
      else
        (@var or attachment.send(:extra_options_for, name))
      end
    end
    
    def function(arglist)
      if @var.respond_to?(:call) then
        @var.call(attachment.instance);Fi[	@ÚieI"        send(var)
      else
        @var[var] if defined? @var[var]
      end
    end
    
    def function(arglist)
      if [:name, :convert_options, :whiny, :processors, :geometry, :format, :animated, :source_file_options].include?(var) then
        send("#{key}=".intern, var);Fi[	I"4data//paperclip_proj/paperclip/url_generator.rb;TiI"Ø        else
          @var[:default_url]
        end
      end
    end
    
    def function(arglist)
      @var.original_filename.nil? ? (default_url) : (@var[:url])
    end;Fi[	@ni*I"–        "#{url}#{delimiter_char}#{@attachment.updated_at.to_s}"
      else
        var
      end
    end
    
    def function(arglist)
      @var.respond_to?(:updated_at) and @var.updated_at.present?
    end;Fi[	@¯iI"m      def function(arglist)
        if allowed_types.present? and allowed_types.none? { |arglist| var.===(var) } then
          mark_invalid(var, var, allowed_types)
        end
      end
      
      def function(arglist)
        if forbidden_types.present? and forbidden_types.any? { |arglist| var.===(var) } then
          mark_invalid(var, var, forbidden_types);Fi[	@¯i I">      def function(arglist)
        if forbidden_types.present? and forbidden_types.any? { |arglist| var.===(var) } then
          mark_invalid(var, var, forbidden_types)
        end
      end
      
      def function(arglist)
        var.errors.add(var, :invalid, options.merge(:types => (var.join(", "))))
      end;Fi[	@ iI"…              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator");Fi[	@ i0I"            var[:less_than_or_equal_to] = var
            var[:greater_than_or_equal_to] = var
          end
        end
      end
      
      def function(arglist)
        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min);Fi[	@ i8I"™          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist)
        var = I18n.translate(:"number.human.storage_units.format", :locale => (options[:locale]), :raise => (true))
        var = I18n.translate(:"number.human.storage_units.units.byte", :locale => (options[:locale]), :count => (var.to_i), :raise => (true));Fi[	I"data//redmine_proj/diff.rb;TirI"Ø        @var = []
        makediff(var, var)
        @var = var.class
      end
    end
    
    def function(arglist)
      @var.push(@var) unless @var.empty?
      @var = [];Fi[	I"Ydata//redmine_proj/generators/redmine_plugin_model/redmine_plugin_model_generator.rb;Ti+I"  def function(arglist)
    attributes.select do |arglist|
      (var.has_index? or (var.reference? and options[:indexes]))
    end
  end
  
  def function(arglist)
    var = Dir.glob("#{plugin_path}/db/migrate/*.rb").map do |arglist|
      File.basename(var).split("_").first.to_i;Fi[	@iQI"¡              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist)
          custom_field_values.select(&:visible?)
        end;Fi[	@iiI"        def function(arglist)
          if (new_record? or custom_field_values_changed?) then
            custom_field_values.each(&:validate_value)
          end
        end
        
        def function(arglist)
          var = []
          custom_field_values.each do |arglist|;Fi[	I">data//redmine_proj/plugins/acts_as_list/test/list_test.rb;TiªI"–    setup_db
    (1..4).each do |arglist|
      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end;Fi[	I"Fdata//redmine_proj/plugins/acts_as_tree/test/acts_as_tree_test.rb;TiI"ƒ      yield)
    ensure
      assert_equal(var, $query_count, "#{$query_count} instead of #{num} queries were executed.")
    end
  end
  
  def function(arglist)
    assert_queries(0, &var)
  end;Fi[	@äi§I"j      assert_equal(2, var[0].children.size)
      assert_equal(0, var[1].children.size)
      assert_equal(0, var[2].children.size)
    end
  end
  
  def function(arglist)
    var = RecursivelyCascadedTreeMixin.find(:first, :include => ({ :children => ({ :children => :children }) }), :order => "mixins.id")
    assert_equal(@var, assert_no_queries do |arglist|;Fi[	I"Hdata//redmine_proj/plugins/acts_as_versioned/test/versioned_test.rb;Ti8I"    assert_nothing_raised { |arglist| locked_pages(:welcome).hello_world }
    assert_nothing_raised do |arglist|
      locked_pages(:welcome).versions.first.hello_world
    end
  end
  
  def function(arglist)
    var = pages(:welcome)
    assert_equal(24, var.version);Fi[	@èi{I"·    assert_raises(ActiveRecord::StaleObjectError) do |arglist|
      var.title = "stale title"
      var.save
    end
  end
  
  def function(arglist)
    var = Page.create!(:title => "title")
    assert_equal(1, var.version);Fi[	@èi¥I"'    5.times do |arglist|
      assert_page_title(var, var, :lock_version)
      assert((var.versions(true).size <= 2), "locked version can only store 2 versions")
    end
  end
  
  def function(arglist)
    assert(Page.track_altered_attributes.!)
    assert(LockedPage.track_altered_attributes);Fi[	@èiÚI"    end
    assert_raise(ActiveRecord::RecordNotFound) do |arglist|
      Page.find_version(0, 23)
    end
  end
  
  def function(arglist)
    assert_equal("widgets_seq", Widget.versioned_class.sequence_name)
    3.times { |arglist| Widget.create!(:name => "new widget") };Fi[	@7iKI"Õ              end
            else
              each_root_valid?(roots)
            end
          end
          
          def function(arglist)
            var = var = 0
            var.all? do |arglist|;Fi[	I"Rdata//redmine_proj/plugins/awesome_nested_set/test/awesome_nested_set_test.rb;TiDI"ˆ  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.lft = 1
    end
  end
  
  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.rgt = 1;Fi[	@öiJI"¸  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.rgt = 1
    end
  end
  
  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.parent_id = 1;Fi[	@öiPI"˜  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.parent_id = 1
    end
  end
  
  def function(arglist)
    var = Category.new(:lft => 1, :rgt => 2, :parent_id => 3)
    assert_nil(var.lft);Fi[	@öiìI"&    assert_nothing_raised do |arglist|
      var = [categories(:top_level), categories(:top_level_2)]
      assert_equal(var, categories(:top_level).self_and_siblings)
    end
  end
  
  def function(arglist)
    var = categories(:child_2)
    var = [categories(:child_1), categories(:child_3)];Fi[	@öi—I"b    categories(:top_level).descendants.each do |arglist|
      assert(categories(:top_level).move_possible?(var).!)
      assert(var.move_possible?(categories(:top_level)))
    end
  end
  
  def function(arglist)
    [:child_1, :child_2, :child_2_1, :child_3].each do |arglist|
      assert(categories(:top_level).is_or_is_ancestor_of?(categories(var)));Fi[	I"ddata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication/mem_cache_store.rb;TiI"÷        return if var.nil?
        var = var[var.keys.sort.last]
        @var.read(var)
      end
    end
    
    def function(arglist)
      var = association_server_key(var)
      var = association_key(var, var);Fi[	I"Sdata//redmine_proj/plugins/open_id_authentication/test/mem_cache_store_test.rb;Ti_I"‚      assert_equal(var, var)
      assert_equal(var.handle, var.handle)
      assert_equal(var.secret, var.secret)
    end
  end
  
  def function(arglist)
    var = @var.remove_association(var, var)
    assert_equal(var, var);Fi[	I"Mdata//redmine_proj/plugins/open_id_authentication/test/normalize_test.rb;TiI"Á  def function(arglist)
    NORMALIZATIONS.each do |arglist|
      assert_equal(var, normalize_identifier(var))
    end
  end
  
  def function(arglist)
    assert_raises(InvalidOpenId) { |arglist| normalize_identifier(nil) }
  end;Fi[	I"Zdata//redmine_proj/plugins/open_id_authentication/test/open_id_authentication_test.rb;TiI"j    @var.send(:authenticate_with_open_id, "http://someone.example.com") do |arglist|
      assert(var.missing?)
      assert_equal("Sorry, the OpenID server couldn't be found", var.message)
    end
  end
  
  def function(arglist)
    @var.send(:authenticate_with_open_id, "!") do |arglist|
      assert(var.invalid?, "Result expected to be invalid but was not");Fi[	@ÆiI"d    @var.send(:authenticate_with_open_id, "!") do |arglist|
      assert(var.invalid?, "Result expected to be invalid but was not")
      assert_equal("Sorry, but this does not appear to be a valid OpenID", var.message)
    end
  end
  
  def function(arglist)
    var = mock
    var.expects(:begin).raises(Timeout::Error, "Identity Server took too long.");Fi[	@Æi*I"^    @var.send(:authenticate_with_open_id, "http://someone.example.com") do |arglist|
      assert(var.missing?)
      assert_equal("Sorry, the OpenID server couldn't be found", var.message)
    end
  end
  
  def function(arglist)
    @var.expects(:begin_open_id_authentication)
    @var.send(:authenticate_with_open_id, "http://someone.example.com");Fi[	@Li;I"ç      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[	@LiUI"≥      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@Li°I"¶      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var);Fi[	@Li©I"©      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[	@Li:I"∞          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@Oi+I"è      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[	@OiJI"µ      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@OiúI"®      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var);Fi[	@Oi§I"´      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[	@OiCI"∞          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	@Ri*I"ç      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"];Fi[	@RiDI"≥      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var;Fi[	@RiêI"¶      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var);Fi[	@RiòI"©      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var);Fi[	@Ri)I"∞          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));Fi[	I"Ddata//redmine_proj/plugins/rfpdf/lib/rfpdf/action_controller.rb;TiI"Æ      def function(arglist)
        var = var.dup
        var
      end
    end
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!(var);Fi[	@Ui•I"†      @var = var
    else
      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@UiÈI"}      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var;Fi[	@Ui,I"Ø      @var = @var if (var == 1)
    else
      @var = (@var + var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@UiƒI"Ã    end
    if var.!=(var) then
      self.Cell(((var / 1000.0) * @var), var, var[var, var], 0, 0, "", 0, var)
    end
  end
  
  def function(arglist)
    if @var.has_key?(var) then
      var = @var[var];Fi[	@UiíI"©          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist)
    var = @var ? ("/Filter /FlateDecode ") : ("")
    @var.each do |arglist|;Fi[	@UiπI"«        putstream(var)
        out("endobj")
      end
    end
  end
  
  def function(arglist)
    @var.each_value do |arglist|
      out((((("/I" + var["i"].to_s) + " ") + var["n"].to_s) + " 0 R"));Fi[	@UiøI"ı  def function(arglist)
    @var.each_value do |arglist|
      out((((("/I" + var["i"].to_s) + " ") + var["n"].to_s) + " 0 R"))
    end
  end
  
  def function(arglist)
    out("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]")
    out("/Font <<");Fi[	@Ui˝I"ö      else
        out("/PageLayout /TwoColumnLeft") if (@var == "two")
      end
    end
  end
  
  def function(arglist)
    out(("%PDF-" + @var))
  end;Fi[	@UiCI"v      end
      @var = (@var - @var)
      @var = var
    end
  end
  
  def function(arglist)
    @var = 1
  end;Fi[	@UiI"´          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist)
    while true do
      while (var = freadbyte(var)).!=(255) do;Fi[	@`i7I"          @var.headers["Cache-Control"] = "maxage=1"
        else
          @var.headers["Cache-Control"] ||= ie_request? ? ("no-cache, must-revalidate") : ("")
        end
      end
      
      def function(arglist)
        @var.response.content_type ||= Mime::PDF
      end;Fi[	@ci~I"u          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj
    out("<</Type /Font");Fi[	@xièI"Â      var, var, var, var = $~[(1..4)]
      var = " lang=\"#{lang}\"" if var
      rip_offtags("#{before}<code#{lang}>#{code}</code>#{after}", false)
    end
  end
  
  def function(arglist)
    var =~ /\#$/ ? ("o") : ("u")
  end;Fi[	@xiáI"∆      var, var = $~[(2..3)]
      @var[var.downcase] = [var, nil]
      # do nothing
    end
  end
  
  def function(arglist)
    var.gsub!(MARKDOWN_REFS_RE) do |arglist|
      var, var = $~[(2..3)];Fi[	@xiêI"Ø      var = $~[6]
      @var[var.downcase] = [var, var]
      # do nothing
    end
  end
  
  def function(arglist)
    var = @var[var.downcase] if var
    (var or [var, nil]);Fi[	@xi≥I"à        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist)
    (@var << var)
    " :redsh##{@shelf.length}:";Fi[	@xi€I"»        end
      end
      var.gsub!(/^ {#{var}}/, "") if var.nonzero?
    end
  end
  
  def function(arglist)
    var.gsub!(/\b\[([0-9]+?)\](\s)?/, "<sup><a href=\"#fn\\1\">\\1</a></sup>\\2")
  end;Fi[	@xiI"â    else
      pgl(var)
      footnote_ref(var)
    end
  end
  
  def function(arglist)
    if var =~ /<.*>/ then
      var, var = 0, {};Fi[	@xi5I"’  def function(arglist)
    [/^inline_/, /^glyphs_/].each do |arglist|
      @var.each { |arglist| method(var).call(var) if var.to_s.match(var) }
    end
  end
  
  def function(arglist)
    H_ALGN_VALS[var]
  end;Fi[	@ÖiI"        var.map { |arglist| var["id"].to_i })
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = except(:includes, :eager_load, :preload, :select).select("#{table_name}.id")
      apply_join_dependency(var, var);Fi[	@ôiWI"Á            return var
          else
            return (("(" + escape(var)) + ")")
          end
        end
        
        def function(arglist)
          RDMPdfEncoding.rdm_from_utf8(var, l(:general_pdf_encoding))
        end;Fi[	@ôijI"˘            var.encode("UTF-16BE")
          else
            Iconv.conv("UTF-16BE", "UTF-8", var)
          end
        end
        
        def function(arglist)
          Cell(var, var, fix_text_encoding(var), var, var, var, var, var)
        end;Fi[	@ôi{I"∫            return var.diskfile
          else
            return nil
          end
        end
        
        def function(arglist)
          SetFont(@var, "I", 8)
          SetY(-15);Fi[	@ôiàI"4            write_wiki_page(var, var)
            write_page_hierarchy(var, var, var.id, (var + 1)) if var[var.id]
          end
        end
      end
      
      def function(arglist)
        var.RDMwriteHTMLCell(190, 5, 0, 0, var.content.text.to_s, var.attachments, 0)
        if var.attachments.any? then;Fi[	@§i=I"Ï          @var ||= (((7 - 1) % 7) + 1)
        else
          @var ||= (((l(:general_first_day_of_week).to_i - 1) % 7) + 1)
        end
      end
      
      def function(arglist)
        @var ||= (((first_wday + 5) % 7) + 1)
      end;Fi[	@™iDI"          @var = var[:max_rows]
        else
          @var = Setting.gantt_items_limit.blank? ? (nil) : (Setting.gantt_items_limit.to_i)
        end
      end
      
      def function(arglist)
        { :controller => "gantts", :action => "show", :project_id => (@var) }
      end;Fi[	@™i’I"Ì          var[:indent] += var[:indent_increment]
          render_issues(var, var)
          var[:indent] -= var[:indent_increment]
        end
      end
      
      def function(arglist)
        case var[:format]
        when :pdf then;Fi[	@™iﬁI"“          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@™iÒI"Â          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Project) and (var.start_date and var.due_date) then
          var[:zoom] ||= 1;Fi[	@™iI"í          end
        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then;Fi[	@™i I"Ú          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Version) and (var.due_date and var.start_date) then
          var[:zoom] ||= 1;Fi[	@™i8I"µ          end
        else
          ""
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do
          @var.pop;Fi[	@™i◊I"˙          var.draw(var)
          var.format = var
          var.to_blob
        end
      end
      
      def function(arglist)
        var = ::Redmine::Export::PDF::ITCPDF.new(current_language)
        var.SetTitle("#{l(:label_gantt)} #{project}");Fi[	@™inI"æ          (var.lft <=> var.lft)
        else
          (var.root_id <=> var.root_id)
        end
      end
      
      def function(arglist)
        @var ? ((@var - @var)) : (nil)
      end;Fi[	@™iI">          var[:pdf].AddPage("L")
          var[:top] = 15
          var[:pdf].Line(15, (var[:top] - 0.1), PDF::TotalWidth, (var[:top] - 0.1))
        end
      end
      
      def function(arglist)
        var = "position: absolute;top:#{params[:top]}px;left:#{params[:indent]}px;"
        if var[:subject_width] then;Fi[	@™iI"%        if var[:label] then
          var[:pdf].SetX(((var[:subject_width] + (var[:bar_end] or 0)) + 5))
          var[:pdf].RDMCell(30, 2, var[:label])
        end
      end
      
      def function(arglist)
        var = (var[:height] or 6)
        if var[:bar_start] and var[:bar_end] then;Fi[	@≥iLI"b              # do nothing
            end
          end
        end
      end
      
      def function(arglist)
        @var = { "project" => ({ :sql => ("#{TimeEntry.table_name}.project_id"), :klass => (Project), :label => :label_project }), "status" => ({ :sql => ("#{Issue.table_name}.status_id"), :klass => (IssueStatus), :label => :field_status }), "version" => ({ :sql => ("#{Issue.table_name}.fixed_version_id"), :klass => (Version), :label => :label_version }), "category" => ({ :sql => ("#{Issue.table_name}.category_id"), :klass => (IssueCategory), :label => :field_category }), "user" => ({ :sql => ("#{TimeEntry.table_name}.user_id"), :klass => (User), :label => :label_user }), "tracker" => ({ :sql => ("#{Issue.table_name}.tracker_id"), :klass => (Tracker), :label => :label_tracker }), "activity" => ({ :sql => ("#{TimeEntry.table_name}.activity_id"), :klass => (TimeEntryActivity), :label => :label_activity }), "issue" => ({ :sql => ("#{TimeEntry.table_name}.issue_id"), :klass => (Issue), :label => :label_issue }) }
        var = @var.nil? ? (IssueCustomField.for_all) : (@var.all_issue_custom_fields);Fi[	I"'data//redmine_proj/redmine/i18n.rb;TiI"Ò        end
      else
        raise("Translation string with multiple values: #{args.first}")
      end
    end
    
    def function(arglist)
      var = "#{options[:prefix]}#{s}".to_sym
      ::I18n.t(var, :default => (var.to_s.humanize));Fi[	@ iZI"Ê        end.sort do |arglist|
          (var.first <=> var.first)
        end
      end
    end
    
    def function(arglist)
      @@languages_lookup = valid_languages.inject({}) do |arglist|
        var[var.to_s.downcase] = var;Fi[	@ ihI"©    def function(arglist)
      if var = find_language(var) then
        ::I18n.locale = var
      end
    end
    
    def function(arglist)
      ::I18n.locale
    end;Fi[	@∏i¨I"„            end
          end
          l(:label_display_per_page, var.join(", ")).html_safe
        end
      end
      
      def function(arglist)
        var = Setting.per_page_options_array
        if var and var.any? then;Fi[	@æiI"‚        class << self
          def function(arglist)
            true
          end
        end
        
        def function(arglist)
          @var = with_trailling_slash(var)
          @var = var.blank? ? ("UTF-8") : (var);Fi[	@æi#I"∂            var)
          rescue CommandFailed
            return nil
          end
        end
        
        def function(arglist)
          begin
            (var = Entries.new;Fi[	@æiAI"          rescue => var
            logger.error("scm: filesystem: error: #{err.message}")
            raise(CommandFailed.new(var.message))
          end
        end
        
        def function(arglist)
          begin
            (var = scm_iconv(@var, "UTF-8", target(var));Fi[	@…iI"/          var = (var.params[:callback] or var.params[:jsonp])
          if var and Setting.jsonp_enabled? then
            self.jsonp = var.to_s.gsub(/[^a-zA-Z0-9_]/, "")
          end
        end
        
        def function(arglist)
          var = @var.first.to_json
          if jsonp.present? then;Fi[	@Œi;I"“                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist)
          raise("Need to implement #{self.class.name}#output")
        end;Fi[	@’iI"Â            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var)
        end;Fi[	@i˛I"⁄          else
            var.attributes["transform"] = "rotate( 90, #{x}, #{y} )"
          end
        end
      end
      
      def function(arglist)
        return @var.collect { |arglist| var[:title] }
      end;Fi[	@iPI"Ê            var = (var + var.attributes["style"]) if var.attributes["style"]
            var.attributes["style"] = var
          end
        end
      end
      
      def function(arglist)
        var = get_style
        var = {};Fi[	@	iâI"[          end
          var = var.dup
          var = (var - 1))
        end
      end
      
      def function(arglist)
        return "/* default line styles */\n.line1{\n\tfill: none;\n\tstroke: #ff0000;\n\tstroke-width: 1px;\t\n}\n.line2{\n\tfill: none;\n\tstroke: #0000ff;\n\tstroke-width: 1px;\t\n}\n.line3{\n\tfill: none;\n\tstroke: #00ff00;\n\tstroke-width: 1px;\t\n}\n.line4{\n\tfill: none;\n\tstroke: #ffcc00;\n\tstroke-width: 1px;\t\n}\n.line5{\n\tfill: none;\n\tstroke: #00ccff;\n\tstroke-width: 1px;\t\n}\n.line6{\n\tfill: none;\n\tstroke: #ff00ff;\n\tstroke-width: 1px;\t\n}\n.line7{\n\tfill: none;\n\tstroke: #00ffff;\n\tstroke-width: 1px;\t\n}\n.line8{\n\tfill: none;\n\tstroke: #ffff00;\n\tstroke-width: 1px;\t\n}\n.line9{\n\tfill: none;\n\tstroke: #ccc6666;\n\tstroke-width: 1px;\t\n}\n.line10{\n\tfill: none;\n\tstroke: #663399;\n\tstroke-width: 1px;\t\n}\n.line11{\n\tfill: none;\n\tstroke: #339900;\n\tstroke-width: 1px;\t\n}\n.line12{\n\tfill: none;\n\tstroke: #9966FF;\n\tstroke-width: 1px;\t\n}\n/* default fill styles */\n.fill1{\n\tfill: #cc0000;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill2{\n\tfill: #0000cc;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill3{\n\tfill: #00cc00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.2;\n\tstroke: none;\n}\n/* default line styles */\n.key1,.dataPoint1{\n\tfill: #ff0000;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key2,.dataPoint2{\n\tfill: #0000ff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.dataPoint3{\n\tfill: #00ff00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.dataPoint4{\n\tfill: #ffcc00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.dataPoint5{\n\tfill: #00ccff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.dataPoint6{\n\tfill: #ff00ff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.dataPoint7{\n\tfill: #00ffff;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.dataPoint8{\n\tfill: #ffff00;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.dataPoint9{\n\tfill: #cc6666;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.dataPoint10{\n\tfill: #663399;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.dataPoint11{\n\tfill: #339900;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.dataPoint12{\n\tfill: #9966FF;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end;Fi[	@iæI"            @var.add_element("text", "x" => (var.to_s), "y" => (var.to_s), "class" => "dataPointLabel").text = var.to_s
          end
          var = (var + var)
        end
      end
      
      def function(arglist)
        var = (10 ** var.to_f)
        ((var * var).to_i / var);Fi[	@iªI"º            end
          end
          var = (var + 1))
        end
      end
      
      def function(arglist)
        "(#{((x * 100).to_i / 100)}, #{((y * 100).to_i / 100)})"
      end;Fi[	@iÅI"R          var = ((var * var) - (var * var))
          @var.add_element("rect", "x" => (var.to_s), "y" => (var.to_s), "width" => (var.to_s), "height" => (var.to_s), "class" => ("fill#{(field_count + 1)}"))
          var = (var + 1)
        end
      end
      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end;Fi[	@!iI"O        
        def function(arglist)
          Stat[:failed]
        end
      end
      
      def function(arglist)
        self.class.klass.notify_or_ignore(exception, :parameters => ({ :payload_class => (payload["class"].to_s), :payload_args => (payload["args"].inspect) }), :component => "resque", :action => (action))
      end;Fi[	@1iI"›        JSON.dump(var)
      rescue Encoding::UndefinedConversionError => var
        raise(EncodeException, var.message, var.backtrace)
      end
    end
    
    def function(arglist)
      return unless var
      begin;Fi[	I"'data//rescue_proj/resque/server.rb;TiuI"          var = "<a href='#{u(request.path_info)}.poll' rel='poll'>Live Poll</a>"
        end
        "<p class='poll'>#{text}</p>"
      end
    end
    
    def function(arglist)
      response["Cache-Control"] = "max-age=0, private, must-revalidate"
      begin;Fi[	@Ei~I".        erb(var.to_sym, { :layout => (var) }, :resque => (Resque))
      rescue Errno::ECONNREFUSED
        erb(:error, { :layout => (false) }, :error => ("Can't connect to Redis! (#{Resque.redis_id})"))
      end
    end
    
    def function(arglist)
      content_type("text/html")
      @var = true;Fi[	I"'data//rspec_proj/autotest/rspec.rb;Ti&I"˝      ""
    else
      "#{ruby} #{SPEC_PROGRAM} --autospec #{normalize(files_to_test).keys.flatten.join(" ")} #{add_options_if_present}"
    end
  end
  
  def function(arglist)
    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = [];Fi[	@ZiI"Ë      class << self
        def function(arglist)
          "No description supplied for #{kind} declared on #{location}"
        end
      end
      
      def function(arglist)
        super(self.class.message(var, var))
      end;Fi[	@]iI"        def function(arglist)
          example_group_creation_listeners.each do |arglist|
            var.register_example_group(var)
          end
        end
        
        def function(arglist)
          ::Spec::Example::SharedExampleGroup.register(*var, &var)
        end;Fi[	@`iI"'        if var.respond_to?(:superclass) and var.superclass.respond_to?(:example_group_hierarchy) then
          unshift(var.superclass.example_group_hierarchy)
          flatten!
        end
      end
      
      def function(arglist)
        var.eval_each_fail_fast(before_all_parts)
      end;Fi[	@fibI"         instance_variables.inject({}) do |arglist|
          var[var] = instance_variable_get(var)
          var
        end
      end
      
      def function(arglist)
        var.each do |arglist|
          unless ["@_proxy", "@_implementation", "@method_name"].include?(var.to_s) then;Fi[	@fiâI"π          verify_mocks_for_rspec)
        ensure
          teardown_mocks_for_rspec
        end
      end
      
      def function(arglist)
        self.class.described_class
      end;Fi[	@~i/I">          while var.respond_to?(:explicit_subject_block) do
            return var.explicit_subject_block if var.explicit_subject_block
            var = var.superclass
          end
        end
        
        def function(arglist)
          if described_class then
            proc { |arglist| described_class.new };Fi[	I")data//rspec_proj/spec/matchers/be.rb;TisI"          return @var = var.__send__(present_tense_predicate, *@var, &@var)
        rescue NameError
          raise(var)
        end
      end
      
      def function(arglist)
        "expected #{predicate}#{args_to_s} to return true, got #{@result.inspect}"
      end;Fi[	@üi8I"à              end
            end
          end
        end
      end
      
      def function(arglist)
        (@var - @var)
      end;Fi[	@øi<I"≠              return "Isn't life confusing enough?\nInstead of having to figure out the meaning of this:\n  should_not have_at_least(#{@expected}).#{@collection_name}\nWe recommend that you use this instead:\n  should have_at_most(#{(@expected - 1)}).#{@collection_name}\n"
            end
          end
        end
      end
      
      def function(arglist)
        "have #{relative_expectation} #{@collection_name}"
      end;Fi[	@ iI"Â          " #{words[0]} and #{words[1]}"
        else
          " #{words[(0...-1)].join(", ")}, and #{words[-1]}"
        end
      end
      
      def function(arglist)
        var = ""
        var.each_with_index do |arglist|;Fi[	I"6data//rspec_proj/spec/matchers/raise_exception.rb;TiI"µ          @var, @var = Exception, var
        else
          @var, @var = var, var
        end
      end
      
      def function(arglist)
        @var = false
        @var = false;Fi[	@bi+I"¨          @var = true)
        rescue Exception => var
          @var = var
        end
      end
      
      def function(arglist)
        case @var
        when nil then;Fi[	@bi6I"≤          @var.=~(@var.message)
        else
          (@var == @var.message)
        end
      end
      
      def function(arglist)
        if @var then
          @var.message;Fi[	@bi>I"·          @var.message
        else
          "expected #{expected_exception}#{given_exception}"
        end
      end
      
      def function(arglist)
        "expected no #{expected_exception}#{given_exception}"
      end;Fi[	@biSI"          "#{@expected_exception} with message matching #{@expected_message.inspect}"
        else
          "#{@expected_exception} with #{@expected_message.inspect}"
        end
      end
      
      def function(arglist)
        if @var.nil? then
          " but nothing was raised";Fi[	@bi[I"·          " but nothing was raised"
        else
          ", got #{@actual_exception.inspect}"
        end
      end
      
      def function(arglist)
        caller.first(3).find { |arglist| var =~ /should_not/ }
      end;Fi[	I"1data//rspec_proj/spec/matchers/respond_to.rb;Ti8I"ı          ""
        else
          " with #{@expected_arity} argument#{(@expected_arity == 1) ? ("") : ("s")}"
        end
      end
      
      def function(arglist)
        (@var.length == 1) ? ("##{@names.first}") : (@var.inspect)
      end;Fi[	I"5data//rspec_proj/spec/matchers/simple_matcher.rb;TiI"ß          @var.call(@var, self)
        else
          @var.call(@var)
        end
      end
      
      def function(arglist)
        (@var or explanation)
      end;Fi[	I"3data//rspec_proj/spec/matchers/throw_symbol.rb;Ti#I"¸          @var.nil?.!
        else
          @var.nil? ? ((@var == @var)) : ((@var == @var).&((@var == @var)))
        end
      end
      
      def function(arglist)
        if @var then
          "expected #{expected}, got #{@caught_symbol.inspect}";Fi[	@ui+I"          "expected #{expected}, got #{@caught_symbol.inspect}"
        else
          "expected #{expected} but nothing was thrown"
        end
      end
      
      def function(arglist)
        if @var then
          "expected #{expected} not to be thrown";Fi[	@ui3I"‘          "expected #{expected} not to be thrown"
        else
          "expected no Symbol, got :#{@caught_symbol}"
        end
      end
      
      def function(arglist)
        "throw #{expected}"
      end;Fi[	I"8data//rspec_proj/spec/mocks/argument_expectation.rb;TiI"-          else
            @var = var.collect { |arglist| matcher_for(var) }
          end
        end
      end
      
      def function(arglist)
        return ArgumentMatchers::MatcherMatcher.new(var) if is_matcher?(var)
        return ArgumentMatchers::RegexpMatcher.new(var) if var.is_a?(Regexp);Fi[	@–iDI"Ï            true)
          rescue NoMethodError => var
            return false
          end
        end
        
        def function(arglist)
          "hash_including(#{@expected.inspect.sub(/^\{/, "").sub(/\}$/, "")})"
        end;Fi[	@–iYI"            true)
          rescue NoMethodError => var
            return false
          end
        end
        
        def function(arglist)
          "hash_not_including(#{@expected.inspect.sub(/^\{/, "").sub(/\}$/, "")})"
        end;Fi[	@”iAI"Ò              @var ? (@var) : ("nil")
            end
          end
        end
      end
      
      def function(arglist)
        var = opts[:message] unless opts[:message].nil?
        Kernel.raise(Spec::Mocks::MockExpectationError, var);Fi[	@€iÉI"∂          end)
        ensure
          @var = (@var + 1)
        end
      end
      
      def function(arglist)
        @var.!=(:any) and ((@var > 0) and (@var >= @var))
      end;Fi[	@€iñI"Ó          @var.call(*var)
        rescue => var
          @var.raise_block_failed_error(@var, var.message)
        end
      end
      
      def function(arglist)
        @var.raise_missing_block_error(@var) if var.nil?
        var = nil;Fi[	@€i«I"(        rescue Spec::Mocks::MockExpectationError => var
          var.backtrace.insert(0, @var)
          Kernel.raise(var)
        end
      end
      
      def function(arglist)
        (ignoring_args? or (matches_exact_count? or (matches_at_least_count? or matches_at_most_count?)))
      end;Fi[	@€iÎI"	          @var.raise_expectation_error(@var, @var, @var, *@var.args)
        else
          @var.raise_unexpected_message_args_error(self, *@var)
        end
      end
      
      def function(arglist)
        @var = ArgumentExpectation.new(var, &var)
        self;Fi[	@€i7I"É          2
        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0
      end;Fi[	@„i2I"Ù          super(var, *var, &var))
        rescue NameError
          __mock_proxy.raise_unexpected_message_error(var, *var)
        end
      end
      
      def function(arglist)
        var = {}
        extract_option(var, var, :null_object);Fi[	@ÈiPI"§          verify_expectations
        ensure
          reset
        end
      end
      
      def function(arglist)
        clear_expectations
        clear_stubs;Fi[	@ÈiÄI"Æ              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var)
      end;Fi[	@ÈiôI"n      def function(arglist)
        if proxy_for_nil_class?.&(@@var) then
          Kernel.warn("An expectation of :#{sym} was set on nil. Called from #{caller[2]}. Use allow_message_expectations_on_nil to disable warnings.")
        end
      end
      
      def function(arglist)
        unless @var.include?(var) then
          var = "#{visibility(sym)} :#{sym}";Fi[	@ÈißI"¨            (@var << var)
          end
          target_metaclass.class_eval("            def #{sym}(*args, &block)\n              __mock_proxy.message_received :#{sym}, *args, &block\n            end\n            #{visibility_string}\n", "(string)", 167)
        end
      end
      
      def function(arglist)
        return @var.__send__(munge(:respond_to?), var) if @var
        return @var = true if (var == :respond_to?);Fi[	@ÈiΩI"ö              "public"
            end
          end
        end
      end
      
      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end;Fi[	@Èi”I"¿      def function(arglist)
        class << @var
          self
        end
      end
      
      def function(arglist)
        @var.each { |arglist| var.verify_messages_received }
      end;Fi[	@ÈiÊI"§            alias_method(var, var)
            remove_method(var)
          end
        end
      end
      
      def function(arglist)
        @var.nil?
      end;Fi[	@i≤I"%          var.each do |arglist|
            Spec::Example::ExampleGroupFactory[var].__send__(var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = scope_and_options(*var)
        var = Spec::Example::ExampleGroupFactory[get_type_from_options(var)];Fi[	@*i|I"≥            @var.tty?
          rescue NoMethodError
            false
          end
        end
        
        def function(arglist)
          colour(var, "\e[32m")
        end;Fi[	@/iI"“            @var.puts(@var.description.gsub(/ \(druby.*\)/, ""))
            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@Ui'I"	            [lines_around(var, var), var]
          else
            ["# Couldn't get snippet for #{error_line}", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("\n");Fi[	@Ui4I"Ò            var[(var..var)].join("\n")
          else
            "# Couldn't get snippet for #{file}"
          end
        end
        
        def function(arglist)
          var = []
          var.split("\n").each_with_index do |arglist|;Fi[	@fiI"‡            heckle_class_method($1, $2)
          else
            heckle_class_or_module(@var)
          end
        end
        
        def function(arglist)
          heckle_method(var, "self.#{method_name}")
        end;Fi[	@fi5I"              var = @var.new(var.name, var, Spec::Runner.options)
              var.validate
            end
          end
        end
        
        def function(arglist)
          var.to_class rescue raise("Heckling failed - \"#{name}\" is not a known class or module")
        end;Fi[	@niI"¢          end
        else
          nil
        end
      end
      
      def function(arglist)
        determine_best_match(var, var)
        best_match[:line];Fi[	@ni.I"          var.examples.each do |arglist|
            consider_example_for_best_match(var, var, var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = parse_location(var.location)
        if is_best_match?(var, var, var, var) then;Fi[	@ni7I"          best_match.clear
          best_match[:example_group] = var
          best_match[:line] = var
        end
      end
      
      def function(arglist)
        var, var = parse_location(var.location)
        if is_best_match?(var, var, var, var) then;Fi[	@niAI"          best_match[:example_group] = var
          best_match[:example] = var
          best_match[:line] = var
        end
      end
      
      def function(arglist)
        (var == File.expand_path(var)) and ((var <= var) and (var > best_match[:line].to_i))
      end;Fi[	@qiQI"      def function(arglist)
        Pathname(File.expand_path(".")).ascend do |arglist|
          return var if File.exists?(File.join(var, "spec"))
        end
      end
      
      def function(arglist)
        return if project_root.nil?
        var = File.join(project_root, var);Fi[	@qixI"˜          after_suite_parts.each do |arglist|
            (var.arity < 1) ? (var.call) : (var.call(var))
          end
        end
      end
      
      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.before_suite_parts
      end;Fi[	@qiîI"Ï            warn("You must 'gem install win32console' to use colour on Windows")
            @var = false
          end
        end
      end
      
      def function(arglist)
        case var
        when :context, "context", "c" then;Fi[	@qi¢I"˝        else
          (@var = :custom
          self.differ_class = load_class(var, "differ", "--diff"))
        end
      end
      
      def function(arglist)
        if File.file?(var) then
          @var = [File.open(var).read.split("\n")].flatten;Fi[	@qi™I"Â          @var = [File.open(var).read.split("\n")].flatten
        else
          @var = [var]
        end
      end
      
      def function(arglist)
        var, var = ClassAndArgumentsParser.parse(var)
        unless var then;Fi[	@qi»I"            load_class(var, "formatter", "--format")
          end
          var.new(formatter_options, var)
        end
      end
      
      def function(arglist)
        @var ||= OpenStruct.new(:colour => (colour), :autospec => (autospec), :dry_run => (dry_run))
      end;Fi[	@qi‘I"Ê          "spec/runner/heckle_runner_unsupported"
        else
          "spec/runner/heckle_runner"
        end
      end
      
      def function(arglist)
        @var ||= [["silent", @var]]
        require(which_heckle_runner);Fi[	@qiI"          Spec::Example::ExampleMethods.__send__(:define_method, var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
      
      def function(arglist)
        case mock_framework
        when Module then;Fi[	@qiI"!        else
          (require(mock_framework)
          Spec::Example::ExampleMethods.__send__(:include, Spec::Adapters::MockFramework))
        end
      end
      
      def function(arglist)
        @var.ignore_patterns(Spec::Runner.configuration.ignored_backtrace_patterns)
      end;Fi[	@qi.I"k          @var.puts("Couldn't find #{kind} class #{name}")
          @var.puts("Make sure the --require option is specified *before* #{option}")
          $_spec_spec ? (raise(var)) : (exit(1))
        end
      end
      
      def function(arglist)
        return nil unless custom_runner?
        var, var = ClassAndArgumentsParser.parse(user_input_for_runner);Fi[	@qi`I"ÿ        else
          error_stream.puts("You cannot use --example and specify a line number")
          exit(4) if stderr?
        end
      end
      
      def function(arglist)
        (@var == $stderr)
      end;Fi[	@ti'I"Î          else
            example_failed(var, var)
          end
        end
      end
      
      def function(arglist)
        backtrace_tweaker.tweak_backtrace(var)
        var = Failure.new(@var.description, var.description, var);Fi[	@ticI"Í            else
              "#{@exception.class.name} in '#{@example_name}'"
            end
          end
        end
        
        def function(arglist)
          @var.is_a?(Spec::Example::PendingExampleFixedError)
        end;Fi[	@ti~I"Ù        @var.inject(1) do |arglist|
          formatters.each { |arglist| var.dump_failure(var, var) }
          (var + 1)
        end
      end
      
      def function(arglist)
        formatters.each { |arglist| var.dump_pending }
      end;Fi[	@tiîI"ª          else
            var.example_pending(var, var)
          end
        end
      end
      
      def function(arglist)
        (var.method(:example_pending).arity == 3)
      end;Fi[	I"3data//SiriProxy_proj/siriproxy/command_line.rb;Ti!I"o      usage
    else
      usage
    end
  end
  
  def function(arglist)
    load_code
    $LOG_LEVEL = 0;Fi[	@”ivI"™      end
      puts("=== SUCCESS ===") if ($?.exitstatus == 0)
      exit($?.exitstatus)
    end
  end
  
  def function(arglist)
    puts("\n#{@option_parser}\n")
  end;Fi[	I"1data//SiriProxy_proj/siriproxy/connection.rb;TiI"√    @var = var
    if other_connection.last_ref_id.!=(var) then
      self.other_connection.last_ref_id = var
    end
  end
  
  def function(arglist)
    super
    self.processed_headers = false;Fi[	@ÿi'I"ˆ    self.ssled = true
    if ($LOG_LEVEL > 1) then
      puts("[Info - #{self.name}] SSL completed for #{self.name}")
    end
  end
  
  def function(arglist)
    puts("[Header - #{self.name}] #{line}") if ($LOG_LEVEL > 2)
    if (var == "") then;Fi[	@ÿiLI"$      if ($LOG_LEVEL > 5) then
        puts("[Debug - #{self.name}] Buffering some data for later (#{self.output_buffer.length} bytes buffered)")
      end
    end
  end
  
  def function(arglist)
    (self.unzipped_input << unzip_stream.inflate(self.input_buffer))
    self.input_buffer = "";Fi[	@ÿi_I"Ù        var = prep_received_object(var)
        inject_object_to_output_stream(var) if var.!=(nil)
      end
    end
  end
  
  def function(arglist)
    return false if unzipped_input.empty?
    var = unzipped_input[(0...5)].unpack("H*").first;Fi[	@!i#I"Ù          true)
        rescue Twitter::Error::NotFound, Twitter::Error::Forbidden
          false
        end
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop);Fi[	@;iI"?        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::Tweet, var, (var + "/#{id}.json"), var.options)
        end
      end
      
      def function(arglist)
        var = post("/1.1/statuses/retweet/#{id}.json", var)
        var = var.dup;Fi[	@niI"Ù          nil
        else
          MultiJson.decode(var, :symbolize_keys => (true))
        end
      end
      
      def function(arglist)
        if respond_to?(:parse) then
          unless [204, 301, 302, 304].include?(var[:status]) then;Fi[	I"'data//twitter_proj/twitter/user.rb;TiUI"Â    def function(arglist)
      if profile_image_url? then
        resize_profile_image_url(@var[:profile_image_url_https], var)
      end
    end
    
    def function(arglist)
      @var[:profile_image_url_https].nil?.!
    end;Fi[	I"1data//whenever_proj/whenever/command_line.rb;TiTI"√        warn("[fail] Couldn't write crontab; try running `whenever' with no options to ensure your schedule file is valid.")
        var.close!
        exit(1)
      end
    end
    
    def function(arglist)
      if read_crontab.=~(Regexp.new("^#{comment_open} *$")) and read_crontab.=~(Regexp.new("^#{comment_close} *$")).nil? then
        warn("[fail] Unclosed indentifier; Your crontab file contains '#{comment_open}', but no '#{comment_close}'");Fi[	@Öi%I"ı          enumerate(var.at, false).each do |arglist|
            yield(new(var, var.output, var).output)
          end
        end
      end
      
      def function(arglist)
        [time_in_cron_syntax, task].compact.join(" ").strip
      end;Fi[	@Öi^I"£          else
            parse_as_string
          end
        end
      end
      
      def function(arglist)
        var = Array.new(5, "*")
        case @var;Fi[	I"(data//whenever_proj/whenever/job.rb;Ti/I"–        else
          var.all? { |arglist| (var == "\"") } ? (escape_double_quotes(var)) : (var)
        end
      end
    end
    
    def function(arglist)
      var.gsub(/'/) { |arglist| "'\\''" }
    end;Fi[	@ài3I"ﬂ          @var[@var] ||= []
          (@var[@var] << Whenever::Job.new(@var.merge(@var).merge(var)))
        end
      end
    end
    
    def function(arglist)
      [environment_variables, cron_jobs].compact.join
    end;Fi[	@àiLI"ü          set(var, var.strip)
          @var[var] = var
        end
      end
    end
    
    def function(arglist)
      return if @var.empty?
      var = [];Fi[	@ãi8I"í          ">> #{stdout}"
        else
          ""
        end
      end
      
      def function(arglist)
        ">> #{@output} 2>&1"
      end;Fi[@'@(@)I" ;FiÌ[Ì[	I"=data//activemodel_proj/active_model/attribute_methods.rb;TiXI"        
        def function(arglist)
          prefix.empty? and suffix.empty?
        end
      end
    end
    
    # Allows access to the object attributes, which are held in the
    # <tt>@attributes</tt> hash, as though they were first-class methods. So a;Fi[	@˝iÖI"Ö          false
        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    ;Fi[	I"2data//activemodel_proj/active_model/errors.rb;TinI"|        var.call
      else
        var
      end
    end
  end
  
  class StrictValidationFailed < StandardError
  end;Fi[	I"2data//activemodel_proj/active_model/naming.rb;TiÁI"∑          var.to_model.class.model_name
        else
          var.class.model_name
        end
      end
    end
    
    private_class_method(:model_name_from_record_or_class)
  end;Fi[	@<iAI"          def self.attributes_protected_by_default(arglist)
            (super + ["password_digest"])
          end
        end
      end
    end
    
    module InstanceMethodsOnActivation
      # Returns +self+ if the password is correct, otherwise +false+.;Fi[	@KiII"              self.class::MethodAttribute.new(var, @var, var)
            else
              self.class::Attribute.new(var, @var, var)
            end
          end
        end
        
        def function(arglist)
          require("builder") unless defined? ::Builder;Fi[	@KiôI"            Array(var).each do |arglist|
              (var.arity == 1) ? (var.call(options)) : (var.call(options, @var))
            end
          end
        end
      end
      
      # Returns XML representing the model. Configuration can be
      # passed through +options+.;Fi[	@_iI""      def function(arglist)
        if include?(var, var) then
          var.errors.add(var, :exclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates that the value of the specified attribute is not in a;Fi[	@biI"'          if options[:without] then
            var = option_call(var, :without)
            record_error(var, var, :without, var) if var.to_s.=~(var)
          end
        end
      end
      
      def function(arglist)
        unless options.include?(:with).^(options.include?(:without)) then;Fi[	@bi3I"Ì          if var and (var.is_a?(Regexp) and (regexp_using_multiline_anchors?(var) and var[:multiline].!=(true))) then
            raise(ArgumentError, "The provided regular expression is using multiline anchors (^ or $), which may present a security risk. Did you mean to use \\A and \\z, or forgot to add the :multiline => true option?")
          end
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is of the correct;Fi[	@giI"/      def function(arglist)
        unless include?(var, var) then
          var.errors.add(var, :inclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is available in a;Fi[	@ûi$I"-          var = options[var]
          unless ((var.is_a?(Integer) and (var >= 0)) or (var == Float::INFINITY)) then
            raise(ArgumentError, ":#{key} must be a nonnegative Integer or Infinity")
          end
        end
      end
      
      def function(arglist)
        var = tokenize(var);Fi[	@ji/I"⁄            unless var.send(CHECKS[var], var) then
              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      ;Fi[	@ji>I"Õ            Kernel.Float(var)
          rescue ArgumentError, TypeError
            nil
          end
        end
      end
      
      def function(arglist)
        var.to_i if var.to_s =~ /\A[+-]?\d+\Z/;Fi[	@ui_I"˜            (_validators[nil] << var)
          end
          validate(var, var)
        end
      end
    end
    
    # Passes the record off to the class or classes specified and allows them
    # to add errors based on more complex conditions.;Fi[	@i#I"ü            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      
      private
      ;Fi[	@µi%I"C      [:finder_sql, :counter_sql].each do |arglist|
        if options.include?(var) then
          ActiveSupport::Deprecation.warn("The :#{name} association option is deprecated. Please find an alternative (such as using scopes).")
        end
      end
    end
    
    def function(arglist)
      if block_extension then;Fi[	@µi4I"          @var = proc { |arglist| instance_exec(var, &var).extending(var) }
        else
          @var = proc { |arglist| extending(var) }
        end
      end
    end
    
    def function(arglist)
      @var ||= "#{model.name.demodulize}#{name.to_s.camelize}AssociationExtension";Fi[	@∫iI"E      [:delete_sql, :insert_sql].each do |arglist|
        if options.include?(var) then
          ActiveSupport::Deprecation.warn("The :#{name} association option is deprecated. Please find an alternative (such as using has_many :through).")
        end
      end
    end
    
    def function(arglist)
      var = self.name;Fi[	@ãi…I"∏            else
              count_records
            end
          end
        end
      end
      
      # Returns the size of the collection calling +size+ on the target.
      #;Fi[	@ãi3I"            var = $2.to_s
            var = "*" if (var.blank? or (var =~ /,/ or var =~ /\.\*/))
            "SELECT #{$1}COUNT(#{count_with}) FROM"
          end
        end
      end
      
      def function(arglist)
        interpolate(options[:finder_sql]);Fi[	@ãikI"              yield(var) if block_given?
              insert_record(var, true, var)
            end
          end
        end
      end
      
      # Do the relevant stuff to insert the given record into the association collection.
      def function(arglist);Fi[	@ãi≠I"‘            var.call(owner, var)
          else
            var.send(var, owner, var)
          end
        end
      end
      
      def function(arglist)
        var = "#{callback_name}_for_#{reflection.name}";Fi[	@öipI"            update_counter(-var.delete_all)
          else
            update_counter(-var.update_all(reflection.foreign_key => (nil)))
          end
        end
      end
      
      def function(arglist)
        owner.attribute_present?(reflection.association_primary_key);Fi[	@†i8I"™            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private
      ;Fi[	@˜ifI"        grouped_records(var).each do |arglist|
          var.each do |arglist|
            preloader_for(var).new(var, var, var, preload_scope).run
          end
        end
      end
      
      def function(arglist)
        Hash[records_by_reflection(var).map do |arglist|;Fi[	@i0I"          raise
        else
          raise(UnknownAttributeError, "unknown attribute: #{k}")
        end
      end
    end
    
    # Assign any deferred nested attributes after the base attributes have been set.
    def function(arglist);Fi[	@i]I"“              connection.schema_cache.primary_keys[table_name]
            else
              "id"
            end
          end
        end
        
        # Sets the name of the primary key column.
        #;Fi[	@iDI"T            serialized_attributes.include?(var.name).!
          else
            attribute_types_cached_by_default.include?(var.type)
          end
        end
      end
      
      # Returns the value of the attribute identified by <tt>attr_name</tt> after
      # it has been typecast (for example, "2004-12-12" in a data column is cast;Fi[	@iI"?          super.dup.tap do |arglist|
            self.class.serialized_attributes.each_key do |arglist|
              var[var] = var[var].unserialized_value if var.key?(var)
            end
          end
        end
        
        def function(arglist)
          if self.class.serialized_attributes.include?(var) then;Fi[	@i◊I"          "\"#{value.to_s(:db)}\""
        else
          var.inspect
        end
      end
    end
    
    # Returns +true+ if the specified +attribute+ has been set by the user or by a
    # database load and is neither +nil+ nor <tt>empty?</tt> (the latter only applies;Fi[	@(iyI"§            end)
          ensure
            @var = (@var - 1)
          end
        end
      end
      
      class Reaper
        attr_reader(:pool, :frequency);Fi[	@(iáI"ç              sleep(var)
              var.reap
            end
          end
        end
      end
      
      include(MonitorMixin)
      ;Fi[	@(i0I"·          var = (Time.now - @var)
          connections.dup.each do |arglist|
            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      ;Fi[	@(i”I"Í            establish_connection(var, var.spec)
          else
            owner_to_pool[var.name] = nil
          end
        end
      end
      
      def function(arglist)
        var = @var.values.find { |arglist| var[var.name] };Fi[	@0iﬁI"õ          rescue Exception
            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      ;Fi[	@0iNI"]            Arel.sql(var.to_s.split(",").map { |arglist| Integer(var) }.join(","))
          else
            Integer(var)
          end
        end
      end
      
      # The default strategy for an UPDATE with joins is to use a subquery. This doesn't work
      # on mysql (even when aliasing the tables), but mysql allows using JOIN directly in;Fi[	@6i˘I"=          column("#{col}_type", :string, (var.is_a?(Hash) ? (var) : (var))) if var
          if var then
            index((var ? (["id", "type"].map { |arglist| "#{col}_#{t}" }) : ("#{col}_id")), (var.is_a?(Hash) ? (var) : (nil)))
          end
        end
      end
      
      alias :belongs_to :references
      ;Fi[	@>i&I"Ù              execute("INSERT INTO #{sm_table} (version) VALUES ('#{v}')")
              (var << var)
            end
          end
        end
      end
      
      def function(arglist)
        if var = native_database_types[var.to_sym] then;Fi[	@Ci_I"˛            var.rolledback!(parent.closed?)
          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        records.uniq.each do |arglist|;Fi[	@CiiI"‘            var.committed!
          rescue => var
            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false;Fi[	@FiWI"µ          unless in_use then
            @var = true
            @var = Time.now
          end
        end
      end
      
      def function(arglist)
        var.connection = self;Fi[	@IiÔI"W            raise(ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.")
          else
            raise
          end
        end
      end
      
      # MysqlAdapter has to free a result after using it, so we use this method to write
      # stuff in an abstract way without concerning ourselves about whether it needs to be;Fi[	@Ii¶I"O        execute_and_free(var, "SCHEMA") do |arglist|
          each_hash(var).map do |arglist|
            new_column(var[:Field], var[:Default], var[:Type], (var[:Null] == "YES"), var[:Collation])
          end
        end
      end
      
      def function(arglist)
        super(var, var.reverse_merge(:options => "ENGINE=InnoDB"));Fi[	@Ii"I"À            (var.length == 1) ? ([var.first, nil]) : (nil)
          else
            nil
          end
        end
      end
      
      # Returns just a table's primary key
      def function(arglist);Fi[	@QivI"(            var.columns.each_with_index do |arglist|
              var = ([var] + var.rows.map { |arglist| var[var].nil? ? ("NULL") : (var[var].to_s) })
              (var << var.map(&:length).max)
            end
          end
        end
        
        def function(arglist)
          var = 1;Fi[	@bi/I"               end]
            else
              var
            end
          end
        end
        
        def function(arglist)
          Hash.===(var) ? (ActiveSupport::JSON.encode(var)) : (var);Fi[	@bihI"§              else
                var
              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then;Fi[	@bi|I"Ä              end
            else
              var
            end
          end
        end
        
        private
        ;Fi[	@ki2I"Ÿ              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist)
          super.insert;Fi[	@kiRI"·              else
                # do nothing
              end
            end
          end
        end
        
        # Queries the database and returns the results in an Array-like object
        def function(arglist);Fi[	@riNI"‡              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        
        class Integer < Type
          def function(arglist);Fi[	@çi"I"∏            var = var.force_encoding(Encoding::ASCII_8BIT)
          end
          var
        end
      end
    end
    
    class SQLite3Adapter < AbstractAdapter
      class Version;Fi[	@çi¨I"S            self.null = var[:null] if var.include?(:null)
            self.precision = var[:precision] if var.include?(:precision)
            self.scale = var[:scale] if var.include?(:scale)
          end
        end
      end
      
      def function(arglist)
        unless columns(var).detect { |arglist| (var.name == var.to_s) } then;Fi[	@çi¯I"            var = { :name => (var.gsub(/(^|_)(#{var})_/, "\1#{to}_")) }
            var[:unique] = true if var.unique
            add_index(var, var, var)
          end
        end
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, var] }];Fi[	@ïi>I"ı            else
              "#{super}(Table doesn't exist)"
            end
          end
        end
      end
      
      # Overwrite the default class equality method to provide support for association proxies.
      def function(arglist);Fi[	@ïibI"i          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
    # attributes but not yet saved (pass a hash with key names matching the associated table column names).;Fi[	@ûiEI"Œ          rescue FixtureClassNotFound
            nil
          end
        end
      end
    end
    
    def self.instantiate_all_loaded_fixtures(arglist)
      all_loaded_fixtures.each_value do |arglist|;Fi[	@ûi‰I"«          var.each do |arglist|
            fixtures[var] = ActiveRecord::Fixture.new(var, model_class)
          end
        end
      end
    end
    
    def function(arglist)
      "#{@path}.yml";Fi[	@ûiRI"m        rescue LoadError => var
          if ActiveRecord::Base.logger then
            ActiveRecord::Base.logger.warn("Unable to load #{file_name}, underlying cause #{e.message} \n\n #{e.backtrace.join("\n")}")
          end
        end
      end
      
      def function(arglist)
        var ? (var = var.map { |arglist| var.to_s }) : (var = fixture_table_names);Fi[	@ûi…I"Û        end
        @var.each_value do |arglist|
          ActiveRecord::FixtureSet.instantiate_fixtures(self, var, load_instances?)
        end
      end
    end
    
    def function(arglist)
      use_instantiated_fixtures.!=(:no_instances);Fi[	@•i%I"+            superclass.descends_from_active_record?
          else
            ((superclass == Base) or columns_hash.include?(inheritance_column).!)
          end
        end
      end
      
      def function(arglist)
        (:true == (@var ||= descends_from_active_record? ? (:false) : (:true)));Fi[	@µiSI"π        { :transaction => :transaction, :execute_block => :execute_block, :create_table => :drop_table, :create_join_table => :drop_join_table, :add_column => :remove_column, :add_timestamps => :remove_timestamps, :add_reference => :remove_reference }.each do |arglist|
          [[var, var], [var, var]].uniq.each do |arglist|
            class_eval("              def invert_#{method}(args, &block)    # def invert_create_table(args, &block)\n                [:#{inverse}, args, block]          #   [:drop_table, args, block]\n              end                                   # end\n", "(string)", (111 + 1))
          end
        end
      end
      
      include(StraightReversions)
      ;Fi[	@ΩiuI"Ω            (superclass.table_name or compute_table_name)
          else
            compute_table_name
          end
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@¬iUI"I          else
            raise(ArgumentError, "No association found for name `#{association_name}'. Has it been defined yet?")
          end
        end
      end
    end
    
    # Returns ActiveRecord::AutosaveAssociation::marked_for_destruction? It's
    # used in conjunction with fields_for to build a form element for the;Fi[	@¬iÉI"              raise(ArgumentError, "Cannot build association `#{association_name}'. Are you trying to build a polymorphic one-to-one association?")
            end
          end
        end
      end
    end
    
    # Assigns the given attributes to the collection association.
    #;Fi[	@¬i—I"          else
            raise_nested_attributes_record_not_found(var, var["id"])
          end
        end
      end
    end
    
    # Updates a record with the +attributes+ or marks it for destruction if
    # +allow_destroy+ is +true+ and has_destroy_flag? returns +true+.;Fi[	@—iHI"≈              end
            end
          end
        end
      end
    end
    
    initializer("active_record.set_configs") do |arglist|
      ActiveSupport.on_load(:active_record) do |arglist|;Fi[	@—i|I"˝            ActiveRecord::Base.clear_reloadable_connections!
            ActiveRecord::Base.clear_cache!
          end
        end
      end
    end
    
    initializer("active_record.add_watchable_files") do |arglist|
      var = var.paths["db"].first;Fi[	@ﬂi‡I"˜        unless options[:polymorphic] then
          if has_inverse? and inverse_of.nil? then
            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing;Fi[	@ﬂiI"∞            var
          else
            raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      ;Fi[	I">data//activerecord_proj/active_record/relation/batches.rb;TiLI"√          var = var.where(table[primary_key].gt(var)).to_a
        else
          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    ;Fi[	@‚i I"              module_eval("                def #{method}(*args, &block)\n                  scoping { @klass.#{method}(*args, &block) }\n                end\n", "(string)", (39 + 1))
            else
              module_eval("                def #{method}(*args, &block)\n                  scoping { @klass.send(#{method.inspect}, *args, &block) }\n                end\n", "(string)", (46 + 1))
            end
          end
        end
        
        def function(arglist)
          @var.synchronize do |arglist|;Fi[	@‚i(I"¶          @var.synchronize do |arglist|
            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      ;Fi[	@‚i>I"Ø              super
            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2);Fi[	@‚i]I"‰          end
        else
          ActiveRecord::Relation
        end
      end
    end
    
    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))));Fi[	@ºiI"æ          order(arel_table[primary_key].asc).limit(1).to_a.first
        else
          limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      if loaded? then;Fi[	@ºi*I"∑          to_a.last
        else
          reverse_order.limit(1).to_a.first
        end
      end
    end
    
    def function(arglist)
      var.none? { |arglist| var.collection? };Fi[	@ÛiI"©          end
        else
          var
        end
      end
    end
    
    def function(arglist)
      var.is_a?(Array) and var.all? { |arglist| var.is_a?(String) };Fi[	@Ÿi-I"Ü          true
        else
          false
        end
      end
    end
    
    def function(arglist)
      return [] if var.blank?;Ti[	@¯iÄI"‹            else
              (var % var.collect { |arglist| connection.quote_string(var.to_s) })
            end
          end
        end
      end
      
      alias_method(:sanitize_conditions, :sanitize_sql)
      ;Fi[	@¯ióI"            else
              raise(PreparedStatementInvalid, "missing value for :#{match} in #{statement}")
            end
          end
        end
      end
      
      def function(arglist)
        if var.respond_to?(:map) and var.acts_like?(:string).! then;Fi[	@¯i™I"      def function(arglist)
        unless (var == var) then
          raise(PreparedStatementInvalid, "wrong number of bind variables (#{provided} for #{expected}) in: #{statement}")
        end
      end
    end
    
    # TODO: Deprecate this
    def function(arglist);Fi[	@˝itI"≈                  end
                end
              end
            end
          end
        end
        
        def function(arglist)
          Thread.current["#{self}_ignore_default_scope"];Fi[	@i%I"º            database_url_config
          else
            ActiveRecord::Base.configurations[var[:env]]
          end
        end
      end
      
      def function(arglist)
        begin;Fi[	@iéI"%            yield(var)
          else
            $stderr.puts("This task only modifies local databases. #{configuration["database"]} is on a remote host.")
          end
        end
      end
      
      def function(arglist)
        (var["host"].blank? or LOCAL_HOSTS.include?(var["host"]));Fi[	@i+I"            if configuration["encoding"] then
              $stderr.puts("(If you set the charset manually, make sure you have a matching collation)")
            end
          end
        end
      end
      
      def function(arglist)
        establish_connection(configuration);Fi[	@inI"b            Mysql2::Error
          else
            defined? Mysql ? (Mysql::Error) : (StandardError)
          end
        end
      end
      
      def function(arglist)
        "GRANT ALL PRIVILEGES ON #{configuration["database"]}.*\n  TO '#{configuration["username"]}'@'localhost'\nIDENTIFIED BY '#{configuration["password"]}' WITH GRANT OPTION;\n";Fi[	@!iI"¥            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist)
        establish_master_connection;Fi[	@'iCI"^      def function(arglist)
        unless ACTIONS.include?(var.to_sym) then
          raise(ArgumentError, ":on conditions for after_commit and after_rollback callbacks have to be one of #{ACTIONS.join(",")}")
        end
      end
    end
    
    # See ActiveRecord::Transactions::ClassMethods for detailed documentation.
    def function(arglist);Fi[	@'i∏I"ı          end
          @var.freeze if var
          @var.clear
        end
      end
    end
    
    # Determine if a record was created or destroyed in a transaction. State should be one of :new_record or :destroyed.
    def function(arglist);Fi[	@*iI"0          (var.marked_for_destruction? or var.valid?(var.validation_context))
        end.any?) then
          var.errors.add(var, :invalid, options.merge(:value => (var)))
        end
      end
    end
    
    module ClassMethods
      # Validates whether the associated object or objects are all valid;Fi[	@-iI"          if var.present? and var.all? { |arglist| var.marked_for_destruction? } then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods
      # Validates that the specified attributes are not blank (as defined by;Fi[	I"9data//activerecord_proj/active_record/validations.rb;Ti!I"          yield(var) if block_given?
          var.save!
          var
        end
      end
    end
    
    # The validation process on save can be skipped by passing <tt>validate: false</tt>.
    # The regular Base#save method is replaced with this when the validations;Fi[	@oi.I"›          @var.compressor.compress_with do |arglist|
            run("#{command} -c #{backup_file} > #{(backup_file + ext)}")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      ;Fi[	@†i5I"Y          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.;Fi[	@•iWI"L          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.;Fi[	@™iAI"\          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.;Fi[	@∂i=I"N          Logger.message("#{storage_name} started transferring '#{local_file}'.")
          File.open(File.join(local_path, var), "r") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.;Fi[	@æi8I"s          Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to bucket '#{bucket}'."))
          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.;Fi[	@√i5I"d          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.;Fi[	@»i3I"`          files_to_transfer_for(@var) do |arglist|
            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.;Fi[	@“iüI"π                  end
                end
              end
            end
          end
        end
        
        class LocalFile
          attr_reader(:path, :relative_path, :md5);Fi[	I")data//backup_proj/backup/template.rb;TiI"÷          @var = Backup::Binder.new(var).get_binding
        else
          @var = nil
        end
      end
    end
    
    ##
    # Renders the provided file (in the context of the binding if any) to the console;Fi[	@˝iI"ˆ        else
          Bundler.load.lock unless options[:"dry-run"]
          Bundler.ui.info("The Gemfile's dependencies are satisfied")
        end
      end
    end
    
    desc("install", "Install the current environment to the system")
    ;Fi[	@˝iI"Î          Bundler.load.specs.sort_by { |arglist| var.name }.each do |arglist|
            Bundler.ui.info("  * #{s.name} (#{s.version}#{s.git_version})")
          end
        end
      end
    end
    
    map(["list"] => "show")
    ;Fi[	@˝iI"“          Bundler.ui.warn("#{gem_name}: Unknown")
        else
          Bundler.ui.info("#{gem_name}: #{license}")
        end
      end
    end
    
    desc("viz", "Generates a visual dependency graph")
    ;Fi[	@˝i6I"⁄          Bundler.ui.warn("The ruby graphviz gem requires GraphViz to be installed")
        else
          raise
        end
      end
    end
    
    desc("gem GEM", "Creates a skeleton for creating a rubygem")
    ;Fi[	@ iMI"       @var.each do |arglist|
        if var = @var.find { |arglist| (var.name == var.name) } then
          var.instance_variable_set(:@type, var.type)
        end
      end
    end
    
    def function(arglist)
      raise("Specs already loaded") if @var;Fi[	@ iûI"˙            var = (var + var.unmet_dependency_names)
            var.add_source(var)
          end
        end
      end
    end
    
    # used when frozen is enabled so we can find the bundler
    # spec, even if (say) a git gem is not checked out.;Fi[	@ iPI"Ë        next unless var.instance_of?(Source::Path)
        specs_changed?(var) do |arglist|
          (var.class == var.class) and (var.path == var.path)
        end
      end
    end
    
    def function(arglist)
      var = false;Fi[	I",data//bundler_proj/bundler/deprecate.rb;TiI"µ      Deprecate = Gem::Deprecate
    else
      class Deprecate
      end
    end
  end
  
  unless Deprecate.respond_to?(:skip_during) then
    def (Deprecate).skip_during(arglist);Fi[	@i1I"§            end
          end
          var = var
        end
      end
    end
    
    def function(arglist)
      var = Hash.new { |arglist| var[var] = Set.new };Fi[	@ibI"Î          end
          var.reject! { |arglist| Gem::Platform.match(var.platform).! } if var
          var = var.sort_by { |arglist| var.sort_obj }
        end
      end
    end
    
    class GraphVizClient
      def function(arglist);Fi[	@i£I"?        var = var = Pathname(var.full_gem_path).join(var.bindir, var).relative_path_from(var)
        File.open("#{bin_path}/#{executable}", "w", 493) do |arglist|
          var.puts(ERB.new(var, nil, "-").result(binding))
        end
      end
    end
    
    def function(arglist)
      var = Bundler.settings[:path];Fi[	@OimI"          var = var.split(",").map { |arglist| var.strip } if var
          var = Gem::Dependency.new(var, var)
          (@var.dependencies << var)
        end
      end
    end
    
    def function(arglist)
      (@var << Gem::Platform.new($1)) if var =~ /^  (.*)$/;Fi[	@%iÌI"¢              throw(var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      var.required_by.replace(var.required_by);Fi[	@,i-I"Ü            nil
          end
        end
      end
    end
  end
  
  class SystemRubyVersion < RubyVersion
    def function(arglist);Fi[	@^i}I"‚        return false unless name.===(var.name)
        return true if requirement.none?
        requirement.satisfied_by?(var.version)
      end
    end
  end
  
  class Requirement
    unless allocate.respond_to?(:none?) then;Fi[	@^iÅI"Â      # Backport of performance enhancement added to Rubygems 1.4
      def function(arglist)
        @var ||= (to_s == ">= 0")
      end
    end
  end
  
  class Platform
    JAVA = Gem::Platform.new("java") unless defined? JAVA;Fi[	@3iÀI"
        Deprecate.skip_during do |arglist|
          self.spec_dirs = *var
          add_specs(*var)
        end
      end
    end
    
    # Used to make bin stubs that are not created by bundler work
    # under bundler. The new Gem.bin_path only considers gems in;Fi[	@3iI"      Gem::Version.send(:define_method, :segments) do |arglist|
        @var ||= @var.scan(/[0-9]+|[a-z]+/i).map do |arglist|
          /^\d+$/ =~ var ? (var.to_i) : (var)
        end
      end
    end
    
    # This backport fixes the marshaling of @segments.
    def function(arglist);Fi[	@3içI"“      
      def function(arglist)
        Gem::Package.build(var)
      end
    end
  end
  
  if (Gem::Version.new(Gem::VERSION) >= Gem::Version.new("1.99.99")) then
    @var = RubygemsIntegration::Future.new;Fi[	@3i£I"ì            @var = RubygemsIntegration::Ancient.new
          end
        end
      end
    end
  end
  
  class << self
    attr_reader(:rubygems);Fi[	@8i@I"ò              raise(var) if var.nil?
            end
          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then;Fi[	@8iÀI"›        var.each do |arglist|
          Bundler.ui.info("  * #{File.basename(path)}")
          File.delete(var)
        end
      end
    end
    
    def function(arglist)
      var = Dir["#{cache_path}/*/.bundlecache"];Fi[	@8iﬁI"’          var = File.dirname(var)
          Bundler.ui.info("  * #{File.basename(path)}")
          FileUtils.rm_rf(var)
        end
      end
    end
    
    def function(arglist)
      root.join("vendor/cache");Fi[	@XiÆI"„        ensure
          if var and var then
            Dir.chdir(var) { |arglist| FileUtils.rm_rf(var) if File.exist?(var) }
          end
        end
      end
      
      def function(arglist)
        var = "#{type}_hooks";Fi[	@oi%I"ò          finish(var, var)
          var.delete(var.object_id) if var
        end
      end
    end
  end
  
  ##
  # Creates a new connection for +uri+;Fi[	@oiëI"î        Net::HTTP
      else
        Net::HTTP::Persistent::SSLReuse
      end
    end
  end
  
  ##
  # Returns the HTTP protocol version for +uri+;Fi[	@ri[I"˜          else
            say_status(:conflict, :red)
            force_or_skip_or_conflict(force_on_collision?, true, &var)
          end
        end
      end
      
      # Shows the file collision menu to the user and gets the result.
      #;Fi[	@isI"            raise(Thor::PrivateMethodEncodedError, "Method #{base.class}##{sym} should be public, not private")
          else
            nil
          end
        end
      end
      
      # Receives a hash of options and just execute the block if some
      # conditions are met.;Fi[	I"9data//bundler_proj/bundler/vendor/thor/invocation.rb;TiI"Á          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    
    # Make initializer aware of invocations and the initialization args.
    def function(arglist);Ti[	@ôi7I"˛      else
        if @var and @var.is_a?(Array).! then
          raise(ArgumentError, "An argument cannot have an enum other than an array.")
        end
      end
    end
    
    def function(arglist)
      self.class::VALID_TYPES.include?(var.to_sym);Fi[	@úi!I"¥          @var[var.human_name] = var.default
        else
          (@var << var) if var.required?
        end
      end
    end
    
    def function(arglist)
      @var = var.dup;Fi[	I"5data//bundler_proj/bundler/vendor/thor/runner.rb;Ti√I"k    thorfiles(var, var).each do |arglist|
      unless Thor::Base.subclass_files.keys.include?(File.expand_path(var)) then
        Thor::Util.load_thorfile(var, nil, options[:debug])
      end
    end
  end
  
  # Finds Thorfiles by traversing from your current directory down to the root
  # directory of your system. If at any time we find a Thor file, we stop.;Fi[	@§iuI"ß            stdout.puts(var)
          else
            stdout.printf("%-#{colwidth}s", var)
          end
        end
      end
      
      # Prints a table.
      #;Fi[	@§i–I"Ó            say("Retrying...")
          else
            say(file_collision_help)
          end
        end
      end
      
      # This code was copied from Rake, available under MIT-LICENSE
      # Copyright (c) 2003, 2004 Jim Weirich;Fi[	@§i<I"•            yield)
          ensure
            $KCODE = var
          end
        end
      end
      
      def function(arglist)
        say("#{statement} ", var);Fi[	I"4data//bundler_proj/bundler/vendor/thor/shell.rb;TiI"ó          Thor::Shell::Basic
        else
          Thor::Shell::Color
        end
      end
    end
    
    def self.shell=(arglist)
      @var = var;Fi[	@±i4I"Ï          var.class.handle_no_task_error(name)
        else
          raise(var)
        end
      end
    end
    
    # Returns the formatted usage by injecting given required arguments
    # and required options into the given usage.;Fi[	@¥i\I"Â              File.expand_path("~") rescue File::ALT_SEPARATOR ? ("C:/") : ("/")
            end
          end
        end
      end
    end
    
    def self.thor_root(arglist)
      File.join(user_home, ".thor").gsub(/\\/, "/");Fi[	@§iI"t      relevant_rules(var, var).each do |arglist|
        if var.only_raw_sql? then
          raise(Error, "The can? and cannot? call cannot be used with a raw sql 'can' definition. The checking code cannot be determined for #{action.inspect} #{subject.inspect}")
        end
      end
    end
    
    def function(arglist)
      relevant_rules(var, var).each do |arglist|;Fi[	@§iI"Ç      relevant_rules(var, var).each do |arglist|
        if var.only_block? then
          raise(Error, "The accessible_by call cannot be used with a block 'can' definition. The SQL cannot be determined for #{action.inspect} #{subject.inspect}")
        end
      end
    end
    
    def function(arglist)
      { :read => ([:index, :show]), :create => ([:new]), :update => ([:edit]) };Fi[	@πi+I"Ù          self.resource_instance ||= load_resource_instance
        else
          self.collection_instance ||= load_collection if load_collection?
        end
      end
    end
    
    def function(arglist)
      unless skip?(:authorize) then;Fi[	@πiJI"ö          else
            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    ;Fi[	@πi~I"           end
        else
          adapter.find(resource_base, id_param)
        end
      end
    end
    
    def function(arglist)
      ModelAdapters::AbstractAdapter.adapter_class(resource_class);Fi[	@ÃiI"¥          assign_attributes(var)
        else
          @var.send(:resource)
        end
      end
    end
    
    def function(arglist)
      @var.send(:end_of_association_chain);Fi[	@øiI"ø            end
          else
            meta_where_match?(var, var.method, var)
          end
        end
      end
      
      def self.meta_where_match?(arglist)
        case var.to_sym;Fi[	@øiQI"        else
          @var.reverse.inject(false_sql) do |arglist|
            merge_conditions(var, tableized_conditions(var.conditions).dup, var.base_behavior)
          end
        end
      end
      
      def function(arglist)
        return var unless var.kind_of?(Hash);Fi[	@øiwI"¶            end
          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      ;Fi[	@øiÄI"z          else
            var = @var.detect { |arglist| var.conditions.kind_of?(ActiveRecord::Relation) }
            raise(Error, "Unable to merge an Active Record scope with other conditions. Instead use a hash or SQL for #{rule.actions.first} #{rule.subjects.first} ability.")
          end
        end
      end
      
      def function(arglist)
        if var.blank? then;Fi[	@øiîI"√            else
              "not (#{conditions}) AND (#{sql})"
            end
          end
        end
      end
      
      def function(arglist)
        sanitize_sql(["?=?", true, false]);Fi[	@øi´I"Ë            merge_joins(var[var], var) unless var.empty?
          else
            var[var] = var
          end
        end
      end
      
      # Removes empty hashes and moves everything into arrays.
      def function(arglist);Fi[	@“i2I"Æ              @var.empty? ? (true) : (@var)
            end
          end
        end
      end
    end
    
    def function(arglist)
      conditions_empty? and @var.nil?.!;Fi[	@“iÉI"á              end
            end
          end
        end
      end
    end
    
    def function(arglist)
      var, var = var.first;Fi[	@‡iI"É        else
          return true
        end
      end
    end
  end
  
  class ProcCallback < Callback
    def function(arglist);Fi[	@ËiI"€            explain_task(var, options[:explain])
          else
            execute_requested_actions_without_help(var)
          end
        end
      end
      
      def function(arglist)
        var = options[:tool];Fi[	@ËiJI"            puts
            puts("Extended help may be available for these tasks.")
            puts("Type `#{File.basename($0)} -e taskname' to view it.")
          end
        end
      end
      
      def function(arglist)
        var = var.find_task(var);Fi[	@ÎifI"Q          end
          var.on("-x", "--skip-user-config", "Don't load the user config file (.caprc)") do |arglist|
            options.delete(:dotfile)
          end
        end
      end
      
      # If the arguments to the command are empty, this will print the
      # allowed options and exit. Otherwise, it will parse the command;Fi[	@Îi±I"ı        [:pre_vars, :vars].each do |arglist|
          options[var].keys.each do |arglist|
            options[var][var] = coerce_variable(options[var][var])
          end
        end
      end
      
      def function(arglist)
        case var;Fi[	@˜iSI"†              else
                super
              end
            end
          end
        end
        
        def function(arglist)
          @var = var;Fi[	@
iÎI"A              var.send_data("#{self[:password]}\n")
            else
              var.call(var, var, var) if var
            end
          end
        end
        
        # Merges the various default command options into the options hash and
        # returns the result. The default command options that are understand;Fi[	@irI"c              var[:except] = filter_deprecated_tasks(var[:except])
              callbacks[var].concat(var.map { |arglist| TaskCallback.new(self, var, var) })
            end
          end
        end
      end
      
      # Filters the given task name or names and attempts to replace deprecated tasks with their equivalents.
      def function(arglist);Fi[	@i=I"Y            var = ServerDefinition.new("127.0.0.1", :user => (var.user), :port => (var.open(var.host, (var.port or 22))))
            SSH.connection_strategy(var, @var) do |arglist|
              Net::SSH::Gateway.new(var, var, var)
            end
          end
        end
        
        def function(arglist)
          if @var[:logger] then;Fi[	@ièI"            sessions.delete(var).close
          rescue IOError
            # do nothing
          end
        end
      end
      
      # Determines the set of servers within the current task's scope and
      # establishes connections to them, and then yields that list of;Fi[	@ i|I"            logger.info("exception while rolling back: #{e.class}, #{e.message}", var.task.fully_qualified_name)
          ensure
            pop_task_call_frame
          end
        end
      end
      
      def function(arglist)
        var = TaskCallFrame.new(var);Fi[	@#imI"                end
              end
            end
          end
        end
      end
      
      # Require another file. This is identical to the standard require method,
      # with the exception that it sets the receiver as the "current" configuration;Fi[	@4iPI"              var.is_a?(Array) ? (roles[var.to_sym]) : (roles[var.to_sym].servers)
            end.flatten
            var.select { |arglist| var.include?(var) }
          end
        end
      end
      
      def function(arglist)
        var = var.split(/,/) if String.===(var);Fi[	@7iAI"˝            true
          else
            false
          end
        end
      end
      
      # Access a named variable. If the value of the variable responds_to? :call,
      # #call will be invoked (without parameters) and the return value cached;Fi[	@ñiI"          if build_script then
            execute("running build script on #{directory}") do |arglist|
              Dir.chdir(var) { |arglist| system(build_script) }
            end
          end
        end
        
        def function(arglist)
          super.check do |arglist|;Fi[	@ñiØI"S          execute("Compressing #{destination} to #{filename}") do |arglist|
            Dir.chdir(copy_dir) do |arglist|
              system(compress(File.basename(destination), File.basename(filename)).join(" "))
            end
          end
        end
        
        def function(arglist)
          FileUtils.rm(filename) rescue nil;Fi[	I"-data//capistrano_proj/capistrano/role.rb;TiI"∫          (@var << DynamicServerList.new(var, var))
        else
          (@var << self.class.wrap_server(var, var))
        end
      end
    end
    
    alias_method(:<<, :push)
    ;Fi[	I".data//capistrano_proj/capistrano/shell.rb;TiMI"π        unless var.empty? then
          (reader::HISTORY << var)
          return var
        end
      end
    end
    
    # Display a verbose help message.
    def function(arglist);Fi[	@bi¶I"·        loop do |arglist|
          var = @var.synchronize { |arglist| process_iteration(var) }
          sleep(var) if var.!
        end
      end
    end
    
    # Set the given option to +value+.
    def function(arglist);Fi[	@¬idI"˘          prepare_scp_transfer(var, var, var)
        else
          raise(ArgumentError, "unsupported transport type: #{transport.inspect}")
        end
      end
    end
    
    def function(arglist)
      var = (callback or Proc.new do |arglist|;Fi[	@¬i¢I"Ï          var.download(var, var, var, &var)
        else
          raise(ArgumentError, "unsupported transfer direction: #{direction.inspect}")
        end
      end
    end
    
    def function(arglist)
      if var.is_a?(String) then;Fi[	@¬i±I"´          var
        else
          var
        end
      end
    end
    
    def function(arglist)
      raise(var) if var.message.include?("expected a file to upload");Fi[	@iI"˚        else
          log_action(:directory, separate("#{basename(dir)}/"), var)
          FileUtils.mkdir_p(var) unless var[:dry_run]
        end
      end
    end
    
    # Write a file given the file contents as a string
    def function(arglist);Fi[	@iOI"Ê        if File.exists?(var) then
          File.unlink(var)
          log_action(:remove, basename(var), options)
        end
      end
    end
    
    def function(arglist)
      relativize(var) { |arglist| File.basename(var) };Fi[	@,i!I"        unless supports?(var, var) then
          SIMPLE_FUNCTIONS[var.to_s] ||= []
          (SIMPLE_FUNCTIONS[var.to_s] << var.to_s)
        end
      end
    end
    
    # Removes support for one or more aspects for the given simple function
    # Example:;Fi[	@€iGI"—        else
          if File.directory?(project_directory).! then
            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      ;Fi[	@ﬁi I"æ          else
            raise(Compass::Error, "Command not found: #{name}")
          end
        end
      end
    end
    
    def function(arglist)
      var = /^#{Regexp.escape(var)}/;Fi[	@·i,I"”            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1));Fi[	@Èi`I"N            @var
          else
            inherited_data.asset_host if inherited_data.respond_to?(:asset_host)
          end
        end
      end
      
      # When called with a block, defines the cache buster strategy to be used.
      # If the block returns nil or a string, then it is appended to the url as a query parameter.;Fi[	@ÈiÅI"Æ                inherited_data.asset_cache_buster
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var ||= [];Fi[	@˙i5I"ô                end
              end
            end
          end
        end
      end
      
      # Support for testing.
      def function(arglist);Fi[	@˙iëI"Æ      
      def function(arglist)
        Compass::Compiler.new(*Compass.configuration.to_compiler_arguments)
      end
    end
  end
  
  extend(Configuration::Helpers)
end;Fi[	@iöI"              else
                inherited_data.send(var) if inherited_data.respond_to?(var)
              end
            end
          end
        end
        
        # Reads the raw value that was set on this object.
        # you generally should call raw_<attribute>() instead.;Fi[	@{inI"ö          var
        else
          "          No Usage!\n".gsub(/^ {8}/, "")
        end
      end
    end
    
    def function(arglist)
      var = "";Fi[	@iYI"·              var = process_erb(var, var)
            end
            write_file(var, var)
          end
        end
      end
      
      installer(:stylesheet) do |arglist|
        "#{sass_dir}/#{pattern_name_as_dir}#{to}";Fi[	@iÄI"Ë            open(var) { |arglist| eval(var.read, instance_binding, var) }
          else
            eval("discover :all", instance_binding, var)
          end
        end
      end
      
      def function(arglist)
        binding;Fi[	@iI"         unless instance_methods.include?(var.to_s) then
          define_method(var) do |arglist|
            (config.send(var) or config.default_for(var))
          end
        end
      end
      
      def function(arglist)
        Compass.configuration;Fi[	@!iBI"}        else
          var
        end
      end
    end
  end
  
  def function(arglist)
    CSS2FallbackValue.new(var, var);Fi[	I"Bdata//compass_proj/compass/sass_extensions/functions/lists.rb;Ti\I"]        var.value.first
      else
        var
      end
    end
  end
  
  protected
  ;Fi[	@Øi*I"û        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl
    def self.included(arglist);Fi[	@ØiCI"ü        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl
    def self.included(arglist);Fi[	@ØivI"®        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl
    def self.included(arglist);Fi[	@ºiCI"£        CrossBrowserFunctionCall.new(name, var)
      else
        sass_to_literal(var)
      end
    end
  end
  
  class List < Literal
    def function(arglist);Fi[	@GiMI"“              var.left = var.to_i
              (@var << var)
              var = (var + var.width)
            end
          end
        end
        
        def function(arglist)
          require("rational");Fi[	@\i(I"7          for var in sprite_names do
            unless var =~ /\A#{Sass::SCSS::RX::IDENT}\Z/ then
              raise(Sass::SyntaxError, "#{sprite_name} must be a legal css identifier")
            end
          end
        end
        
        def function(arglist)
          "#{path}-s#{uniqueness_hash}.png";Fi[	@fiLI"∫          var = var.split(/;/).size
          self.selector_count += var
          self.prop_count += var
        end
      end
    end
    
    class SassFile
      attr_accessor(:path);Fi[	I"*data//compass_proj/compass/version.rb;Ti+I"¬    def function(arglist)
      if File.exists?(scope(".git/HEAD")) then
        Dir.chdir(scope(".")) { |arglist| `git rev-parse HEAD` }
      end
    end
  end
  
  extend(Compass::Version)
  ;Fi[	@xi0I"Á            else
              ((Ast::Step::INDENT + Ast::Step::INDENT) + var.unpack("U*").length)
            end
          end
        end
      end
      
      def function(arglist)
        var.detect { |arglist| var.=~(name) };Fi[	@ÉiwI"˘              end
              @var.each { |arglist| var.visit_table_cell(var) }
              var.visit_exception(@var, :failed) if @var
            end
          end
        end
        
        def function(arglist)
          unless header? then;Fi[	@ÉiI"ﬁ                @var ||= var.reported_exception
                var.visit_step_result(var)
              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var);Fi[	@ñiÆI"Ì          if var.value.!=(var.value) and (var.value.to_s == var.value.to_s) then
            var.inspect!
            var.inspect!
          end
        end
      end
      
      def function(arglist)
        @var = var.map do |arglist|;Fi[	@§i∞I"ı          rescue Exception => var
            (var.message << "\nError creating formatter: #{format}")
            raise(var)
          end
        end
      end
      
      class LogFormatter < ::Logger::Formatter
        def function(arglist);Fi[	@¨iËI"´          if var =~ /^(\w+)=(.*)$/ then
            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      ;Fi[	I";data//cucumber_prok/cucumber/core_ext/instance_exec.rb;Ti0I"e        end
      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  ;Fi[	@≤iKI"o            exit(1)
          end
          raise(var)
        end
      end
    end
    
    private
    ;Fi[	@µiDI"±            (alias :grey :white)
          else
            define_real_grey
          end
        end
      end
      
      def self.define_real_grey(arglist)
        #:nodoc:;Fi[	@∏iñI"Ì            @var.puts
            var.each { |arglist| @var.puts(format_string(var, :tag)) }
            @var.flush
          end
        end
      end
      
      def function(arglist)
        @var.each { |arglist| print_message(var) };Fi[	@«iHI"ﬁ              @var.p("Expand All", :id => "expander")
              @var.p("Collapse All", :id => "collapser")
            end
          end
        end
      end
      
      def function(arglist)
        print_stats(var);Fi[	@«i{I"π          var[(1..-1)].each do |arglist|
            @var.text!(var.strip)
            @var.br
          end
        end
      end
      
      def function(arglist)
        @var = true;Fi[	@«i‹I"à            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      
      def function(arglist)
        (@var << "<script type=\"text/javascript\">document.getElementById('duration').innerHTML = \"Finished in <strong>#{format_duration(features.duration)} seconds</strong>\";</script>");Fi[	@¯iFI"ë                cucumber_puts(*var)
              end
            end
          end
        end
      end
      
      Kernel.extend(self)
      ;Fi[	@˝ipI"V            var.status = Ast::StepInvocation.worst_status(var.map { |arglist| var[:status] })
            var = var.inject(0) { |arglist| (var[:duration] + var) }
            var.mean_duration = (var / var.length)
          end
        end
      end
      
      def function(arglist)
        @var.unmatched_step_definitions.each do |arglist|;Fi[	@ifI"{            [Cucumber::RUBY_BINARY, "-S", "bundle", "exec", "rcov", @var, quoted_binary(@var), "--", @var, @var].flatten
          else
            [Cucumber::RUBY_BINARY, "-I", load_path(@var), "-S", "rcov", @var, quoted_binary(@var), "--", @var, @var].flatten
          end
        end
      end
      
      LIB = File.expand_path((File.dirname("(string)") + "/../.."))
      ;Fi[	@i¥I"ˆ            ForkedCucumberRunner.new(libs, binary, var, bundler, feature_files)
          else
            InProcessCucumberRunner.new(libs, var, feature_files)
          end
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@i?I"◊            @var = ::Spec::Matchers)
          rescue LoadError => var
            @var = Module.new { |arglist| }
          end
        end
      end
      
      def function(arglist)
        @var.map do |arglist|;Fi[	@=iñI"©            end
          else
            var
          end
        end
      end
      
      def function(arglist)
        if var = programming_language_for(var) then;Fi[	@EiçI"        FileUtils.mkdir_p(@var.dotcucumber) if File.directory?(@var.dotcucumber).!
        File.open(File.join(@var.dotcucumber, "stepdefs.json"), "w") do |arglist|
          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    ;Fi[	@Hi+I"À            var.gsub(COLORED_REGEXP, "")
          else
            respond_to?(:to_str) ? (to_str.gsub(COLORED_REGEXP, "")) : ("")
          end
        end
      end
      
      module_function
      ;Fi[	@SiI"≥            var["backtrace"].split("\n")
          else
            var["backtrace"]
          end
        end
      end
      
      def function(arglist)
        (@var or super);Fi[	@iiSI"4            true
          else
            warden.set_user(var, var.merge!(:scope => (var)))
          end
        end
      end
      
      # Sign out a given user or scope. This helper is useful for signing out a user
      # after deleting accounts. Returns true if there was a logout and false if there;Fi[	@viI"‡              var = "#{action}#{module_name}_#{path_or_url}"
              class_eval("                def #{method}(resource_or_scope, *args)\n                  scope = Devise::Mapping.find_scope!(resource_or_scope)\n                  _devise_route_context.send(\"#{action}#{scope}_#{module_name}_#{path_or_url}\", *args)\n                end\n", "(string)", (53 + 1))
            end
          end
        end
      end
      
      generate_helpers!(Devise::URL_HELPERS)
      ;Fi[	@riÑI"±          { :error => (i18n_message) }.send(var)
        else
          i18n_message
        end
      end
    end
    
    def function(arglist)
      var, var = var.split("#");Fi[	@{i:I"Õ            Devise.mailer_sender.call(var.name)
          else
            Devise.mailer_sender
          end
        end
      end
      
      def function(arglist)
        var = [self.class.mailer_name];Fi[	@~izI"◊          @var = []
        else
          @var = (self.routes - Array(var[:skip]).map(&var))
        end
      end
    end
    
    def function(arglist)
      var = lambda { |arglist| var.to_s.singularize.to_sym };Fi[	@äi+I"÷            save(:validate => (true))
          else
            save(:validate => (false))
          end
        end
      end
      
      # Verifies whether a user is confirmed or not
      def function(arglist);Fi[	@íi_I"{            :locked
          else
            super
          end
        end
      end
      
      protected
      ;Fi[	@†i8I"¢            var
          else
            raise("authenticable_salt returned nil for the #{self.class.name} model. In order to use rememberable, you must ensure a password is always set or have a remember_token column in your model or implement your own rememberable_value in the model with custom logic.")
          end
        end
      end
      
      def function(arglist)
        self.class.rememberable_options;Fi[	@∑i◊I"M          with_devise_exclusive_scope(var.fullpath, var.name, var) do |arglist|
            var.each { |arglist| send("devise_#{mod}", var, var.controllers) }
          end
        end
      end
    end
    
    # Allow you to add authentication request from the router.
    # Takes an optional scope and block to provide constraints;Fi[	@Ωi#I"£        require("mongoid/version")
        if (Mongoid::VERSION.to_f < 2.1) then
          puts("\n[DEVISE] Please note that Mongoid versions prior to 2.1 handle dirty model object attributes in such a way that the Devise `validatable` module will not apply its usual uniqueness and format validations for the email field. It is recommended that you upgrade to Mongoid 2.1+ for this and other fixes, but if for some reason you are unable to do so, you should add these validations manually.\n")
        end
      end
    end
    
    initializer("devise.fix_routes_proxy_missing_respond_to_bug") do |arglist|
      ActionDispatch::Routing::RoutesProxy.class_eval do |arglist|;Fi[	@‚iGI"¡      end
      if AppConfig.git_revision.present? then
        headers["X-Git-Revision"] = AppConfig.git_revision
      end
    end
  end
  
  def function(arglist)
    if user_signed_in? then;Fi[	@‚ikI"u            break
          end
        end
      end
    end
  end
  
  def function(arglist)
    (@var or nil);Fi[	@ºi"I"Ò      respond_to do |arglist|
        var.js { |arglist| render(:text => (var), :status => 403) }
        var.html { |arglist| redirect_to(:back) }
      end
    end
  end
  
  def function(arglist)
    @var = Person.find(params[:person_id]);Fi[	@Ái!I"¨          flash[:error] = I18n.t("aspects.create.failure")
          redirect_to(:back)
        end
      end
    end
  end
  
  def function(arglist)
    @var = Aspect.new;Fi[	@ i/I"¯      respond_to do |arglist|
        var.mobile { |arglist| redirect_to(:back) }
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    render(:layout => (false));Fi[	@œiI"*        var = (params[:aspect_ids] or current_user.aspects.map(&:id))
        @var = Person.all_from_aspects(var, current_user).for_json
        render(:json => (@var.to_json))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.contacts.sharing.includes(:aspect_memberships);Fi[	@ÿiI"ô        end
      else
        render(:show, :layout => "post")
      end
    end
  end
  
  def function(arglist)
    if session[:mobile_view].nil? then;Fi[	@Âi4I"∆        end
        @var = @var.paginate(:page => (params[:page]), :per_page => 15)
        @var = hashes_for_people(@var, @var)
      end
    end
  end
  
  def function(arglist)
    @var = :search;Fi[	@ÂikI"0        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display
  # it next to the avatar image in a nice box;Fi[	@Âi¶I"ó      else
        flash[:error] = I18n.t("tags.show.none", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  ;Fi[	@Úi7I"Ä        end
      else
        legacy_create
      end
    end
  end
  
  def function(arglist)
    var = current_user.person_id;Fi[	@iI"Á    respond_to do |arglist|
      var.all do |arglist|
        render(:template => "errors/not_public", :status => 404)
      end
    end
  end
  
  def function(arglist)
    mark_corresponding_notifications_read if user_signed_in?;Fi[	@i&I"%      var.mobile { |arglist| render("posts/show", :layout => "application") }
      var.json do |arglist|
        render(:json => (PostPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    render(:text => (post_iframe_url(params[:id])), :layout => (false));Fi[	@i?I"      var.html { |arglist| redirect_to(post_path(var)) }
      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).older(@var);Fi[	@iII"
      var.html { |arglist| redirect_to(post_path(var)) }
      var.json do |arglist|
        render(:json => (PostPresenter.new(var, current_user)))
      end
    end
  end
  
  def function(arglist)
    respond_with(PostInteractionPresenter.new(@var, current_user));Fi[	@ÚiI"Ã    respond_to do |arglist|
      var.json do |arglist|
        render(:json => (PersonPresenter.new(@var, current_user)))
      end
    end
  end
  
  def function(arglist)
    @var = current_user.person;Fi[	@Úi8I"n        else
          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  ;Fi[	@iAI"›        var.html { |arglist| redirect_to(:back) }
        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  ;Fi[	@"iCI"        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist)
    session[:a_ids] = params[:a_ids] if params[:a_ids].present?;Fi[	@%iI"Œ        render(:json => (@var.to_json), :status => 201)
      else
        render(:nothing => (true), :status => 403)
      end
    end
  end
  
  # DELETE /tag_followings/1
  # DELETE /tag_followings/1.xml;Fi[	@%i&I"     else
      respond_to do |arglist|
        var.any(:js, :json) { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  def function(arglist)
    respond_to do |arglist|;Fi[	@(iI"      respond_to do |arglist|
        var.json { |arglist| render(:nothing => (true), :status => 422) }
        var.html { |arglist| redirect_to(tag_path("partytimeexcellent")) }
      end
    end
  end
  
  def function(arglist)
    gon.tagFollowings = tags if user_signed_in?;Fi[	@(i+I"¿        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  ;Fi[	@ıi]I"_      var.js { |arglist| render(:nothing => (true), :status => 204) }
      var.all do |arglist|
        redirect_to((var ? (new_user_session_path) : (edit_user_path)))
      end
    end
  end
  
  def function(arglist)
    if params[:user] and (params[:user][:current_password] and current_user.valid_password?(params[:user][:current_password])) then;Fi[	@3i
I"£    include_analytics("mixpanel") do |arglist|
      javascript_tag do |arglist|
        "          (function(d,c){var a,b,g,e;a=d.createElement('script');a.type='text/javascript';a.async=!0;a.src=('https:'===d.location.protocol?'https:':'http:')+'//api.mixpanel.com/site_media/js/api/mixpanel.2.js';b=d.getElementsByTagName('script')[0];b.parentNode.insertBefore(a,b);c._i=[];c.init=function(a,d,f){var b=c;'undefined'!==typeof f?b=c[f]=[]:f='mixpanel';g='disable track track_pageview track_links track_forms register register_once unregister identify name_tag set_config'.split(' ');\n          for(e=0;e<g.length;e++)(function(a){b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,0)))}})(g[e]);c._i.push([a,d,f])};window.mixpanel=c})(document,[]);\n          mixpanel.init(\"#{AppConfig.privacy.mixpanel_uid}\");\n".html_safe
      end
    end
  end
  
  def function(arglist)
    return unless current_user;Fi[	@3iI"˚    include_analytics("mixpanel") do |arglist|
      javascript_tag do |arglist|
        "          mixpanel.name_tag(\"#{current_user.guid}\");\n".html_safe
      end
    end
  end
  
  def function(arglist)
    return unless configured?("chartbeat");Fi[	@3i I"C    include_analytics("chartbeat") do |arglist|
      javascript_tag do |arglist|
        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  ;Fi[	I"9data//diaspora_proj/helpers/error_messages_helper.rb;TiI"H      content_tag(:div, :class => "error_messages") do |arglist|
        var = var.map { |arglist| content_tag(:li, var) }
        ((content_tag(:h2, var[:header_message]) + content_tag(:p, var[:message])) + content_tag(:ul, var.join.html_safe))
      end
    end
  end
  
  module FormBuilderAdditions
    def function(arglist);Fi[	@WiI"»        var = Reshare.where(:author_id => (current_user.person_id), :root_guid => (var.guid)).first
        var = var.present? ? ("active") : ("inactive")
        link_to("", reshares_path(:root_guid => (var.guid)), :title => (t("reshares.reshare.reshare_confirmation", :author => (var.author_name))), :class => ("image_link reshare_action #{klass}"))
      end
    end
  end
  
  def function(arglist)
    if current_user and current_user.liked?(var) then;Fi[	@\iI"Ø        end
      else
        translation(var, :actors => (var), :count => (var))
      end
    end
  end
  
  def function(arglist)
    { :post_author => (nil) }.merge!(var);Fi[	@_iI"˛    else
      content_tag(:h2, :id => "search_title") do |arglist|
        ((t("people.index.results_for").html_safe + " ") + content_tag(:span, search_query, :class => "term"))
      end
    end
  end
  
  def function(arglist)
    if search_query then;Fi[	@iI"             I18n.t("posts.show.photos_by", :count => (var.photos.size), :author => (var.author_name))
          end
        end
      end
    end
  end
  
  def function(arglist)
    var[:width] ||= 516;Fi[	@iI"⁄            raise("in order to use pagination for this new controller, update next_page_path in stream helper")
          end
        end
      end
    end
  end
  
  def function(arglist)
    var.instance_of?(Reshare);Fi[	@niI"¯    content_tag("h4") do |arglist|
      content_tag("small") do |arglist|
        t("people.index.looking_for", :tag_link => (tag_link)).html_safe
      end
    end
  end
  
  def function(arglist)
    ActsAsTaggableOn::Tag.normalize(search_query);Fi[	@ti/I"Ò      mail(var) do |arglist|
        var.text { |arglist| render(:layout => (nil)) }
        var.html { |arglist| render(:layout => (nil)) }
      end
    end
  end
  
  def function(arglist)
    send_notification(:started_sharing, var, var);Fi[	@ti[I"Æ      mail(@var.headers) do |arglist|
        var.text
        var.html
      end
    end
  end
  
  def function(arglist)
    I18n.with_locale(@var.recipient.language, &var);Fi[	@ÄiGI"á        return Notifications::AlsoCommented
      else
        return false
      end
    end
  end
  
  def function(arglist)
    Post;Fi[	@ÉiQI"Ω        aspects.detect { |arglist| (var.id == var.id) }
      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  ;Fi[	@9i&I"Ü        else
          nil
        end
      end
    end
  end
  
  def function(arglist)
    super(var.merge(:methods => :note_html));Fi[	@£içI"‚    else
      if ["year", "month", "day"].all? { |arglist| var[var].blank? } then
        self.birthday = nil
      end
    end
  end
  
  def function(arglist)
    birthday.to_s(:long).gsub(", 1000", "") if birthday.present?;Fi[	@ªi∂I"º      else
        var = self.user_preferences.where(:email_type => (var)).first
        var.destroy if var
      end
    end
  end
  
  def function(arglist)
    if username.present? then;Fi[	@<ixI"◊            @var = @var.parent.value[:dont_indent_next_line]
            @var = @var.parent.value[:dont_tab_up_next_text]
          end
        end
      end
    end
    
    def function(arglist)
      # do nothing;Fi[	@<iI"              "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"
            end
          end
        end
      end
    end
    
    # Evaluates `text` in the context of the scope object, but
    # does not output the result.;Fi[	@HiâI"Ø          else
            push_text(var.rstrip.gsub("\n", "\n#{("  " * @output_tabs)}"))
          end
        end
      end
    end
    
    module Plain
      include(Base);Fi[	@Hi⁄I"ñ        return if var.options[:suppress_eval]
        var.instance_eval do |arglist|
          push_silent((("            begin\n              haml_io = StringIO.new(_hamlout.buffer, 'a')\n".gsub("\n", ";") + var) + "            ensure\n              haml_io.close\n              haml_io = nil\n            end\n".gsub("\n", ";")))
        end
      end
    end
    
    module Preserve
      include(Base);Fi[	I";data//haml_proj/haml/helpers/action_view_extensions.rb;Ti6I"          yield)
        ensure
          @var = var
        end
      end
    end
    
    include(ActionViewExtensions)
  end;Fi[	@‰iïI"t          break (@var + 1) if flat? and var =~ /^#{@var}/
          var = Error.message(:inconsistent_indentation, Haml::Util.human_indentation(var), Haml::Util.human_indentation(@var))
          raise(SyntaxError.new(var, var.index))
        end
      end
    end
    
    class ParseNode < Struct.new(:type, :line, :value, :parent, :children)
      def function(arglist);Fi[	@[iI"´      if var.children.empty? and var.skip_clean?(var).! then
        puts("rmdir: #{d} (empty)") if ARGV.verbose?
        var.rmdir
      end
    end
  end
  
  private
  ;Fi[	@Ôi+I"∞          @var = (@var + " => #{MacOS::Xcode.prefix}")
        end
        @var
      end
    end
  end
  
  def function(arglist)
    if instance_variable_defined?(:@clt) then;Fi[	@Ôi5I"÷    else
      if MacOS::CLT.installed? and (MacOS::Xcode.version.to_f >= 4.3) then
        @var = MacOS::CLT.version
      end
    end
  end
  
  def function(arglist)
    var = HOMEBREW_REPOSITORY.cd do |arglist|;Fi[	@diqI"á        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    f.conflicts.each do |arglist|;Fi[	@diøI"ÿ        unless (var.hexdigest == var.hexdigest.downcase) then
          problem("#{cksum.hash_type} should be lowercase")
        end
      end
    end
  end
  
  def function(arglist)
    ENV.setup_build_environment;Fi[	@diœI"
        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    if text =~ /<(Formula|AmazonWebServicesFormula|ScriptFileFormula|GithubGistFormula)/ then;Fi[	@gi9I"Á    else
      if (var.rack.children.length > 1) then
        opoo("Skipping #{f.name}: most recent version #{f.version} not installed")
      end
    end
  end
  
  def function(arglist)
    return unless HOMEBREW_CACHE.directory?;Fi[	@giNI"û            rm(var)
          end
        end
      end
    end
  end
  
  def function(arglist)
    system("find #{HOMEBREW_PREFIX} -name .DS_Store -delete");Fi[	@iI"À        info_formula(Formula.factory(ARGV.shift))
      else
        ARGV.formulae.each { |arglist| info_formula(var) }
      end
    end
  end
  
  def function(arglist)
    require("vendor/multi_json");Fi[	@i2I"    if which("git") and (HOMEBREW_REPOSITORY / ".git").directory? then
      if `git remote -v` =~ /origin\s+(https?:\/\/|git(?:@|:\/\/))github.com[:\/](.+)\/homebrew/ then
        $2
      end
    end
  end
  
  def function(arglist)
    var = var.path.realpath;Fi[	@ixI"û        var.children.each { |arglist| puts("#{keg} (#{keg.abv})") }
      else
        raise("No such formula or keg")
      end
    end
  end
  
  private
  ;Fi[	I"$data//homebrew_proj/cmd/link.rb;Ti"I"ì      end
      print("Linking #{keg}... ") do |arglist|
        puts("#{keg.link(mode)} symlinks created")
      end
    end
  end
  
  private
  ;Fi[	@ziI"~        else
          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  ;Fi[	@ziKI"¢        else
          puts(var) if FORMULA_META_FILES.should_list?(var.basename.to_s)
        end
      end
    end
  end
  
  def function(arglist)
    var = [];Fi[	@&i I"ø        puts(var.name) if (ff.length > 1)
        dump_options_for_formula(var)
        puts
      end
    end
  end
  
  def function(arglist)
    var.build.sort_by(&:flag).each do |arglist|;Fi[	@)iI"ª        puts("#{f.name} (#{(versions * ", ")} < #{f.version})")
      else
        puts(var.name)
      end
    end
  end
  
  def function(arglist)
    Formula.installed.map do |arglist|;Fi[	@i5I"Â            GitHub.find_pull_requests(var) { |arglist| puts(var) }
          end
        end
      end
    end
  end
  
  def function(arglist)
    (if (HOMEBREW_LIBRARY / "Taps/#{user.downcase}-#{repo.downcase}").directory? then;Fi[	@îiŒI"        get_externals { |arglist| fetch_repo((@var + var), var, @var[var], true) }
      else
        fetch_repo(@var, @var)
      end
    end
  end
  
  def function(arglist)
    quiet_safe_system(@@var, "export", "--force", @var, Dir.pwd);Fi[	@îisI"      Dir.chdir(HOMEBREW_CACHE) do |arglist|
        safe_system("/usr/bin/cvs", "-d", var, "login")
        safe_system("/usr/bin/cvs", "-d", var, "checkout", "-d", @var, var)
      end
    end
  end
  
  def function(arglist)
    FileUtils.cp_r(Dir[(@var + "{.}")], Dir.pwd);Fi[	@îi~I"∞      if FileTest.directory?(var) and (File.basename(var) == "CVS") then
        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  ;Fi[	I"'data//homebrew_proj/extend/ARGV.rb;Ti;I"Q        raise("        Multiple kegs installed to #{rack}\n        However we don't know which one you refer to.\n        Please delete (with rm -rf!) all but one and then try again.\n        Sorry, we know this is lame.\n".undent)
      else
        raise
      end
    end
  end
  
  # self documenting perhaps?
  def function(arglist);Fi[	@£iæI"ù        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist)
    /^#!\s*\S+/.===(open("r") { |arglist| var.read(1024) });Fi[	@£i
I"	            raise("            Could not symlink file: #{src.expand_path}\n            #{self} may already exist.\n            #{dirname} may not be writable.\n".undent)
          end
        end
      end
    end
  end
  
  def function(arglist)
    join(var.to_s);Fi[	@£iAI"π          yield(var) if var.to_s =~ /.rb$/
        end
        break
      end
    end
  end
  
  # Writes an exec script in this folder for each target pathname
  def function(arglist);Fi[	@®iI"√          puts("You can amend this by altering your ~/.bashrc file")
          @var = true
        end
      end
    end
  end
  
  def function(arglist)
    if (f.prefix + "man").directory? then;Fi[	@´i¡I"    rescue NotAKegError
      if ARGV.verbose? then
        puts("Won't resolve conflicts for symlink #{dst} as it doesn't resolve into the Cellar")
      end
    end
  end
  
  def function(arglist)
    if var.exist? and (var.realpath == var.realpath) then;Fi[	@´i‘I"‚          var.delete if var.overwrite and var.exist?
          var.make_relative_symlink(var)
        end
      end
    end
  end
  
  # symlinks the contents of self+foo recursively into /usr/local/foo
  def function(arglist);Fi[	@∂iI"V            end
          end
        end
      end
    end
  end
  
  private
  ;Fi[	@éi'I"Æ        "4.5.2"
      else
        raise("Mac OS X `#{MacOS.version}' is invalid")
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new(folder);Fi[	@éixI"|          "4.5"
        else
          "4.5"
        end
      end
  end
  
  def function(arglist)
    (version.to_f < 4.3);Fi[	@ìi:I"¿    else
      if Pathname.new("/usr/X11/lib/libpng.dylib").exist? then
        Pathname.new("/usr/X11")
      end
    end
  end
  
  def function(arglist)
    version.nil?.! and prefix.nil?.!;Fi[	@¡iI"Ø        else
          (version == :leopard) ? (:leopard) : (nil)
        end
      end
    end
  end
  
  def function(arglist)
    (@var ||= {}).fetch(var.to_s) do |arglist|;Fi[	@¡i)I"F        end
        var = ["#{xcrun_path}", "#{dev_tools_path}/#{tool}", "#{xctoolchain_path}/usr/bin/#{tool}"]
        var.map { |arglist| Pathname.new(var) }.find { |arglist| var.executable? }
      end
    end
  end
  
  def function(arglist)
    @var ||= if File.exist?("/usr/bin/cc") and File.exist?("/usr/bin/make") then;Fi[	@¡i7I"        if File.exist?("#{Xcode.prefix}/usr/bin/make") then
          Pathname.new("#{Xcode.prefix}/usr/bin")
        end
      end
    end
  end
  
  def function(arglist)
    @var ||= (var = Pathname.new("#{Xcode.prefix}/Toolchains/XcodeDefault.xctoolchain");Fi[	@¡i^I"ß        :clang
      else
        (Xcode.version >= "4.2") ? (:llvm) : (:gcc)
      end
    end
  end
  
  def function(arglist)
    @var ||= if locate("gcc-4.0") then;Fi[	@™iI"       var.each do |arglist|
        (@var << Patch.new(var, ("%03d-homebrew.diff" % var), var))
        var = (var + 1)
      end
    end
  end
  
  def function(arglist)
    external_curl_args.empty?.!;Fi[	@™isI"À      if var.exist? then
        @var = var.compression_type
        @var ||= :none
      end
    end
  end
  
  # Write the given file object (DATA) out to a local file for patch
  def function(arglist);Fi[	I"data//homebrew_proj/tab.rb;TiI"i        self.dummy_tab(Formula.factory(var.parent.basename))
      rescue FormulaUnavailableError
        Tab.new(:used_options => ([]), :unused_options => ([]), :built_as_bottle => (false), :tapped_from => "", :time => (nil), :HEAD => (nil))
      end
    end
  end
  
  def self.for_formula(arglist)
    var = Formula.factory(var) unless var.kind_of?(Formula);Fi[	@≤iKI"Æ        var = TestBallWithRealPath.new
        Homebrew.info_formula(var)
        Homebrew.prune
      end
    end
  end
  
  def function(arglist)
    require("cmd/cleanup");Fi[	@≤iÜI"≤        assert(var.exist?)
        HOMEBREW_CACHE.chmod_R(511)
        var.unlink
      end
    end
  end
  
  def function(arglist)
    var = (HOMEBREW_CACHE / "foo-0.1.tar.gz");Fi[	@øiI"      TestBall.new.brew do |arglist|
        assert_equal(File.expand_path(var.prefix), ((HOMEBREW_CELLAR + var.name) + "0.1").to_s)
        assert_kind_of(Pathname, var.prefix)
      end
    end
  end
  
  def function(arglist)
    assert_equal("ShellFm", Formula.class_s("shell.fm"));Fi[	@∆i&I"˙        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@∆i0I"˙        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@∆i:I"˙        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|;Fi[	@ÁioI"˙          var.to_json
        else
          raise(Error, "cannot encode #{x.class}: #{x.inspect}")
        end
      end
    end
    
    def function(arglist)
      (("{" + var.map { |arglist| ((keyenc(var) + ":") + valenc(var)) }.join(",")) + "}");Fi[	@ˆi¶I"è        detect_from_symbol
      else
        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  ;Fi[	I"6data//jekyll_proj/jekyll/generators/pagination.rb;Ti/I"|          (var.pages << var)
        else
          var.pager = var
        end
      end
    end
    
    private
    ;Fi[	@i I"æ          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
    
    def self.suffix(arglist)
      if (var.nil? or var.include?("markdown")) then;Fi[	I"1data//jekyll_proj/jekyll/migrators/tumblr.rb;Ti&I"        var[:name] = truncate_post_name(var[:name]) if (var[:name].size > 255)
        File.open("_posts/tumblr/#{post[:name]}", "w") do |arglist|
          var.puts(((var[:header].to_yaml + "---\n") + var[:content]))
        end
      end
    end
    
    private
    ;Fi[	@!i~I"              (static_files << StaticFile.new(self, self.source, var, var))
            end
          end
        end
      end
    end
    
    # Read all the files in <source>/<dir>/_posts and create a new Post
    # object with each one.;Fi[	@!iI"?      var.reject do |arglist|
        unless self.include.glob_include?(var) then
          ([".", "_", "#"].include?(var[(0..0)]) or ((var[(-1..-1)] == "~") or (self.exclude.glob_include?(var) or File.symlink?(var))))
        end
      end
    end
    
    # Get the implementation class for the given Converter.
    #;Fi[	@-iI"Û            var.each { |arglist| add_to_sets[var]["$each"].push(var) }
          else
            add_to_sets[var] = { "$each" => (var) }
          end
        end
      end
      
      # Adds pull all modifiers to the modifiers hash.
      #;Fi[	@Hi¶I"˘            var.nested_builder(var, {}).build(self, mass_assignment_options)
          else
            send("#{name}=", var)
          end
        end
      end
      
      # Execute the block with the provided mass assignment options set.
      #;Fi[	@RiI"∂          end
          var ? ((attributes[var] ||= {}).merge!(var)) : (attributes[var] = var)
          var
        end
      end
    end
    
    (alias :[]= :write_attribute)
    ;Fi[	I"-data//mongoid_proj/lib/mongoid/config.rb;TiÀI"Œ        var.each_pair do |arglist|
          Validators::Option.validate(var)
          send("#{option}=", var)
        end
      end
    end
    
    # Get the session configuration or an empty hash.
    #;Fi[	@ãiéI"¸            var, var = var[var], var[var]
            var = compare(var.__sortable__, var.__sortable__)
            (var[var] < 0) ? ((var * -1)) : (var)
          end
        end
      end
      
      # Prepare the document for batch removal.
      #;Fi[	@éiqI"‘            (@var > 0)
          else
            query.dup.select(:_id => 1).limit(1).entries.first.nil?.!
          end
        end
      end
      
      # Update the documents for the provided method.
      #;Fi[	@éiI"Ê            var
          else
            query
          end
        end
      end
      
      # If we are limiting results, we need to set the field limitations on a
      # thread local to avoid overriding the default values.;Fi[	@§i1I"        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed_from_default?") do |arglist|
            attribute_changed_from_default?(var)
          end
        end
      end
      
      # Creates the dirty change previous value accessor.
      #;Fi[	@§iQI"ı        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_will_change!") do |arglist|
            attribute_will_change!(var)
          end
        end
      end
      
      # Creates the dirty change reset.
      #;Fi[	@è	i*I"∞            end
          else
            var[var] = var.attributes[var] if var.!=(var)
          end
        end
      end
      
      # Is this field a foreign key?
      #;Fi[	I"3data//mongoid_proj/lib/mongoid/identity_map.rb;Ti(I"«          var.map { |arglist| (var[var] or return nil) }
        else
          documents_for(var)[var]
        end
      end
    end
    
    # Get many documents from the map via the selector
    #;Fi[	@®	i4I"ˆ          var.each_pair do |arglist|
            unless VALID_OPTIONS.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var))
            end
          end
        end
        
        # Validates the index spec.
        #;Fi[	@‡	i6I"´            Matchers::And.new(var, var)
          else
            Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      ;Fi[	@Â	iI"˚        
        def function(arglist)
          @var = var
        end
      end
    end
    
    # Process the provided attributes casting them to their proper values if a
    # field exists for them on the document. This will be limited to only the;Fi[	@
iyI"              document.remove_change(fields)
            else
              document.remove_change(field)
            end
          end
        end
        
        # Appends items to an array and executes the corresponding $push or
        # $pushAll operation.;Fi[	@â
i“I"            var = new(var, var, &var)
            var.save
            var
          end
        end
      end
      
      # Create a new document. This will instantiate a new document and
      # insert it in a single call. Will always return the document;Fi[	@â
iÚI"N            fail_validate!(var) unless var.insert.errors.empty?
            fail_callback!(var, :create!) if var.new_record?
            var
          end
        end
      end
      
      # Delete all documents given the supplied conditions. If no conditions
      # are passed, the entire collection will be dropped for performance;Fi[	@å
i,I".            handle_configuration_error(var)
          rescue ::Mongoid::Errors::NoSessionHosts => var
            handle_configuration_error(var)
          end
        end
      end
      
      initializer("warn when configuration is missing") do |arglist|
        config.after_initialize do |arglist|;Fi[	@å
i5I"ë          unless (Rails.root.join("config", "mongoid.yml").file? or ::Mongoid.configured?) then
            puts("\nMongoid config not found. Create a config file at: config/mongoid.yml")
            puts("to generate one run: rails generate mongoid:config\n\n")
          end
        end
      end
      
      initializer("load http errors") do |arglist|
        config.after_initialize do |arglist|;Fi[	@å
i=I"Z        config.after_initialize do |arglist|
          unless config.action_dispatch.rescue_responses then
            ActionDispatch::ShowExceptions.rescue_responses.update(Railtie.rescue_responses)
          end
        end
      end
      
      initializer("preload all application models") do |arglist|
        config.to_prepare do |arglist|;Fi[	@å
iGI"            ::Rails::Mongoid.load_models(var)
          else
            ::Rails::Mongoid.preload_models(var)
          end
        end
      end
      
      initializer("include the identity map") do |arglist|
        var.config.middleware.use("Rack::Mongoid::Middleware::IdentityMap");Fi[	@å
iTI":          ::Mongoid.instantiate_observers
          ActionDispatch::Reloader.to_prepare do |arglist|
            ::Mongoid.instantiate_observers
          end
        end
      end
      
      initializer("reconnect to master if application is preloaded") do |arglist|
        config.after_initialize do |arglist|;Fi[	@å
iaI"            PhusionPassenger.on_event(:starting_worker_process) do |arglist|
              ::Mongoid.default_session.disconnect if var
            end
          end
        end
      end
      
      # Exposes Mongoid's configuration to the Rails application configuration.
      #;Fi[	@ñ
iHI"•                end
                exit_autosave
              end
            end
          end
        end
        
        # Can the autosave be added?
        #;Fi[	@ù
iõI"Ë            if var = var.inverse_of_field_setter then
              var.you_must(var, var)
            end
          end
        end
      end
      
      # Bind the provided document with the base from the parent relation.
      #;Fi[	@¢
i"I"J                target.do_or_do_not(metadata.inverse(target)).push(base)
              else
                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.;Fi[	@≠
iI"            binding do |arglist|
              unless metadata.versioned? then
                var.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbind a single document.
          #;Fi[	@Ω
i#I"                    target.do_or_do_not(metadata.inverse_setter(target), base)
                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.;Fi[	@i"I"                process_attributes(var, var, var)
              else
                process_attributes(var, var[1], var)
              end
            end
          end
          
          # Create the new builder for nested attributes on one-to-many
          # relations.;Fi[	@iqI"Z            else
              unless destroyable?(var) then
                existing.push(Factory.build(metadata.klass, var, var))
              end
            end
          end
          
          # Destroy the child document, needs to do some checking for embedded
          # relations and delay the destroy in case parent validation fails.;Fi[	@
i'I"?                var.send(metadata.setter, Factory.build(metadata.klass, attributes, var))
              else
                var.send(metadata.setter, nil) if delete?
              end
            end
          end
          
          # Create the new builder for nested attributes on one-to-one
          # relations.;Fi[	@Pi!I"˝              var = var.cascade_strategy
              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods
        # Attempt to add the cascading information for the document to know how;Fi[	@oi(I"·              else
                index({ var => 1 }, :background => (true))
              end
            end
          end
        end
        
        # Handle common behaviour for referenced 1-1 relation setup.
        #;Fi[	@|i∫I"1        klass.relations.each_pair do |arglist|
          if var =~ /#{var.singularize}|#{var.pluralize}/ and var.relation.!=(relation) then
            return var.to_sym
          end
        end
      end
      
      # Determine the value for the relation's foreign key. Performance
      # improvement.;Fi[	@|i—I"˜            "#{self[:as]}#{suffix}"
          else
            inverse_of ? ("#{inverse_of}#{suffix}") : (inverse_class_name.foreign_key)
          end
        end
      end
      
      # Determine the inverse foreign key of the relation.
      #;Fi[	@|iI"˘        if var = self[:foreign_key] then
          relations_metadata.detect do |arglist|
            (var == var.foreign_key) if var.stores_foreign_key?
          end
        end
      end
      
      # Get the inverse relation candidates.
      #;Fi[	@ñiZI"
          end
          unless var.empty? then
            var.criteria(var, self.class).without_options.pull(var.inverse_foreign_key, id)
          end
        end
      end
      
      module ClassMethods
        # Set up the syncing of many to many foreign keys.;Fi[	@õi÷I"÷            @var = var.inject({}) do |arglist|
              var[var.id] = var
              var
            end
          end
        end
        
        # Does the target include the provided document?
        #;Fi[	@•iêI"
          if (_parent.nil? or instance_variable_get("@#{name}").!=(_parent)) then
            remove_instance_variable("@#{name}")
          end
        end
      end
    end
    
    module ClassMethods
      # This is convenience for librarys still on the old API.;Fi[	@≠i‰I"?            if Mongoid.logger then
              Mongoid.logger.warn(("Creating scope :#{name}. " + "Overwriting existing method #{self.name}.#{name}."))
            end
          end
        end
      end
      
      # Checks if the intended scope is a valid object, either a criteria or
      # proc with a criteria.;Fi[	@¥iVI"·          var[var] = read_attribute(var)
        else
          var[var] = send(var)
        end
      end
    end
    
    # For each of the provided include options, get the relation needed and
    # provide it in the hash.;Fi[	@¥inI"N        var = relations[var.to_s]
        if var and var = send(var.name) then
          var[var.name.to_s] = var.serializable_hash(relation_options(var, var, var))
        end
      end
    end
    
    # Since the inclusions can be a hash, symbol, or array of symbols, this is
    # provided as a convenience to parse out the names.;Fi[	@Èi!I"§            end
          else
            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      ;Fi[	@Òi,I"§            validate_embedded(var, var, var)
          else
            validate_root(var, var, var)
          end
        end
      end
      
      private
      ;Fi[	@iI"Ï        # as per: https://github.com/mongoid/mongoid/issues/744
        def function(arglist)
          yield if var
        end
      end
    end
    
    class ActiveModel < ::Rails::Generators::ActiveModel
      def self.all(arglist);Fi[	I",data//mongoid_proj/lib/rails/mongoid.rb;TiqI"ˇ        end
        var.sort.each do |arglist|
          load_model(var.gsub("#{path}/", "").gsub(".rb", ""))
        end
      end
    end
    
    # Conditionally calls `Rails::Mongoid.load_models(app)` if the
    # `::Mongoid.preload_models` is `true`.;Fi[	@iyI"ﬁ            "not(parent::*)"
          else
            (var.value.first + "(.)")
          end
        end
      end
      
      def function(arglist)
        "contains(concat(' ', @class, ' '), ' #{node.value.first} ')";Fi[	@ïi$I"            validate_file(var)
          else
            raise(ArgumentError, "Must provide Nokogiri::Xml::Document or the name of an existing file")
          end
        end
      end
      
      ###
      # Returns true if +thing+ is a valid Nokogiri::XML::Document or;Fi[	@≥i¬I"æ            end
          end
          request_phase
        end
      end
    end
    
    # Performs the steps necessary to run the callback phase of a strategy.
    def function(arglist);Fi[	@≥iI"}          log(:info, "Calling through to underlying application for setup.")
          var = env.merge("PATH_INFO" => (setup_path), "REQUEST_METHOD" => "GET")
          call_app!(var)
        end
      end
    end
    
    # @abstract This method is called when the user is on the request path. You should
    # perform any information gathering you need to be able to authenticate;Fi[	@(i=I"V      ["file_name"].each do |arglist|
        unless @var.respond_to?("#{name}_#{field}") and @var.respond_to?("#{name}_#{field}=") then
          raise(Paperclip::Error.new("#{@instance.class} model missing required attr_accessor for '#{name}_#{field}'"))
        end
      end
    end
    
    def function(arglist)
      Paperclip.log(var);Fi[	@(imI">      instance.run_paperclip_callbacks(:post_process) do |arglist|
        instance.run_paperclip_callbacks(:"#{name}_post_process") do |arglist|
          post_process_styles(*var)
        end
      end
    end
    
    def function(arglist)
      if styles.include?(:original) and process_style?(:original, var) then;Fi[	@(iÆI"¸        var.close unless var.closed?
        if var.respond_to?(:unlink) and (var.path.present? and File.exist?(var.path)) then
          var.unlink
        end
      end
    end
    
    def function(arglist)
      if @var[:restricted_characters] then;Fi[	@¡iI"”        define_callbacks(*[var, { :terminator => "result == false" }].flatten)
        var.each do |arglist|
          eval("            def before_#{callback}(*args, &blk)\n              set_callback(:#{callback}, :before, *args, &blk)\n            end\n            def after_#{callback}(*args, &blk)\n              set_callback(:#{callback}, :after, *args, &blk)\n            end\n")
        end
      end
    end
    
    module Running
      def function(arglist);Fi[	@;i4I"†          var.const_get(var, false)
        else
          var.const_missing(var)
        end
      end
    end
    
    def function(arglist)
      @var ||= {};Fi[	I"5data//paperclip_proj/paperclip/interpolations.rb;TirI"œ          var
        else
          var.empty?.! ? (var.first) : (/\/([^\/]*)$/.match(var.content_type)[1])
        end
      end
    end
    
    # Returns the id of the instance.
    def function(arglist);Fi[	@ÃiBI"“              else
                (var << "  All were accepted successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          if @var.present? then;Fi[	@ÃiNI"ﬁ              else
                (var << "  All were rejected successfully.")
              end
            end
          end
        end
        
        def function(arglist)
          "Expected #{@attachment_name}:\n";Fi[	@‚iI"Ó        var.each do |arglist|
          COLUMNS.each_pair do |arglist|
            add_column(var, "#{attachment_name}_#{column_name}", var)
          end
        end
      end
      
      def function(arglist)
        if var.empty? then;Fi[	@‚i&I"j        var.each do |arglist|
          COLUMNS.each_pair do |arglist|
            remove_column(var, "#{attachment_name}_#{column_name}")
          end
        end
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("Method `drop_attached_file` in the migration has been deprecated and will be replaced by `remove_attachment`.");Fi[	@‚i5I"_        var.each do |arglist|
          COLUMNS.each_pair do |arglist|
            column("#{attachment_name}_#{column_name}", var)
          end
        end
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("Method `t.has_attached_file` in the migration has been deprecated and will be replaced by `t.attachment`.");Fi[	@ËiI"o          end
          unless Paperclip::Interpolations.respond_to?(:fog_public_url) then
            Paperclip.interpolates(:fog_public_url) { |arglist| var.public_url(var) }
          end
        end
      end
      
      AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX = /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
      ;Fi[	@Ëi\I"            "https://#{host_name_for_directory}/#{path(style)}"
          else
            directory.files.new(:key => (path(var))).public_url
          end
        end
      end
      
      def function(arglist)
        if directory.files.respond_to?(:get_http_url) then;Fi[	@ËiÑI"ˇ            (@var[:fog_host] % (path(var).hash % 4))
          else
            @var[:fog_host]
          end
        end
      end
      
      def function(arglist)
        if @var[:fog_directory].to_s.=~(Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX) then;Fi[	@ËiùI"˘            var.call(self)
          else
            raise(ArgumentError, "Credentials are not a path, file, hash or proc.")
          end
        end
      end
      
      def function(arglist)
        @var ||= ::Fog::Storage.new(fog_credentials);Fi[	@ÎiMI"        unless Paperclip::Interpolations.respond_to?(:asset_host) then
          Paperclip.interpolates(:asset_host) do |arglist|
            "#{attachment.path(style).gsub(/^\//, "")}"
          end
        end
      end
      
      def function(arglist)
        if path then;Fi[	I"/data//paperclip_proj/paperclip/tempfile.rb;TiI"È        var = "#{prefix}#{t}-#{$$}-#{rand(4294967296).to_s(36)}-#{n}#{suffix}"
      else
        super
      end
    end
  end
  
  module TempfileEncoding
    # This overrides Tempfile#binmode to make sure that the extenal encoding;Fi[	@niI"ÿ          @var.instance.send(@var[:default_url])
        else
          @var[:default_url]
        end
      end
    end
    
    def function(arglist)
      @var.original_filename.nil? ? (default_url) : (@var[:url]);Fi[	@¯i2I"V      def function(arglist)
        unless (options.has_key?(:content_type) or options.has_key?(:not)) then
          raise(ArgumentError, "You must pass in either :content_type or :not to the validator")
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the content type of the file;Fi[	@˚iI"          if var.send(:read_attribute_for_validation, "#{attribute}_file_name").blank? then
            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the presence of a file.;Fi[	@ iI"ò              var = options[:in] ? (:in_between) : (var)
              var.errors.add(var, var, filtered_options(var).merge(:min => (min_value_in_human_size(var)), :max => (max_value_in_human_size(var)), :count => (human_size(var))))
            end
          end
        end
      end
      
      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then;Fi[	@ i/I"’          else
            var[:less_than_or_equal_to] = var
            var[:greater_than_or_equal_to] = var
          end
        end
      end
      
      def function(arglist)
        if var.is_a?(Range) then;Fi[	@i4I"              var.merge(var)
            else
              var.is_a?(Symbol) ? (send(var).merge(var)) : (var)
            end
          end
        end
        
        # Returns the mail adresses of users that should be notified
        def function(arglist);Fi[	@idI"ó          acts_as_list_class.where(scope_condition).reorder("#{position_column} ASC, id ASC").each_with_index do |arglist|
            unless (var.send(position_column) == (var + 1)) then
              acts_as_list_class.update_all({ position_column => ((var + 1)) }, :id => (var.id))
            end
          end
        end
        
        # Removes the item from the list.
        def function(arglist);Fi[	@7iTI"<              ((var.left > var) and (var.right > var)).tap do |arglist|
                var = var.left
                var = var.right
              end
            end
          end
          
          # Rebuilds the left & rights if unset or invalid.
          # Also very useful for converting from acts_as_tree.;Fi[	@7iÉI".                end
              end
              yield(var, (var.length - 1))
            end
          end
        end
        
        # Any instance method that returns a collection makes use of Rails 2.1's named_scope (which is bundled for Rails 2.0), so it can be treated as a finder.
        #;Fi[	@7i°I"π            end
            var.reload_nested_set if var
            self.reload_nested_set
          end
        end
      end
      
      module Columns
        def function(arglist);Fi[	@Li†I"ü        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@Li9I"ç          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@OiõI"ü        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@OiBI"ç          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@RièI"ü        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@Ri(I"ç          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0");Fi[	@UiëI"„          self.Error(("Unsupported font type: " + var)) unless self.respond_to?(var)
          self.send(var, var)
        end
      end
    end
  end
  
  def function(arglist)
    var = @var ? ("/Filter /FlateDecode ") : ("");Fi[	@Ui∏I"∆        out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
        putstream(var)
        out("endobj")
      end
    end
  end
  
  def function(arglist)
    @var.each_value do |arglist|;Fi[	@Ui¸I"∫        out("/PageLayout /OneColumn")
      else
        out("/PageLayout /TwoColumnLeft") if (@var == "two")
      end
    end
  end
  
  def function(arglist)
    out(("%PDF-" + @var));Fi[	@UiI"û          (var = freadshort(var)
          var.seek((var - 2), IO::SEEK_CUR))
        end
      end
    end
  end
  
  def function(arglist)
    while true do;Fi[	@ciÕI"„        @var[var[:file]] = { "length1" => (var[:originalsize]) }
      else
        @var[var[:file]] = { "length1" => (var[:size1]), "length2" => (var[:size2]) }
      end
    end
  end
  
  alias_method(:add_font, :AddFont)
  ;Fi[	@ciÑI"å        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell)
  ;Fi[	@ciZI"t      else
        @var = (@var + 1)
        @var = @var
      end
    end
  end
  
  alias_method(:ln, :Ln)
  ;Fi[	@ci}I"l            end
          end
        end
      end
    end
  end
  
  def function(arglist)
    newobj;Fi[	@ci I"•        out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
        putstream(var)
        out("endobj")
      end
    end
  end
  
  #
  	# putxobjectdict;Fi[	@ci"	I"ú        out("/PageLayout /OneColumn")
      else
        out("/PageLayout /TwoColumnLeft") if (@var == "two")
      end
    end
  end
  
  #
  	# puttrailer;Fi[	@ci7I"Ñ          @var = var
          @var = var
        end
      end
    end
  end
  
  alias_method(:write_html_cell, :writeHTMLCell)
  ;Fi[	@xi3I"        var = pba(var)
        var = shelve(var) if var
        "#{sta}#{oqs}<#{ht}#{atts}>#{content}</#{ht}>#{oqa}"
      end
    end
  end
  
  LINK_RE = /\n            (\n            ([\s\[{(]|[#{PUNCT}])?     # $pre\n            "                          # start\n            (#{C})                     # $atts\n            ([^"\n]+?)                 # $text\n            \s?\n            (?:\(([^)]+?)\)(?="))?     # $title\n            ":\n            (                          # $url\n            (\/|[a-zA-Z]+:\/\/|www\.|mailto:)  # $proto\n            [[:alnum:]_\/]\S+?\n            )               \n            (\/)?                      # $slash\n            ([^[:alnum:]_\=\/;\(\)]*?)         # $post\n            )\n            (?=<|\s|$)\n        /x
  ;Fi[	@xiLI"¸        var = shelve(var) if var
        var = var =~ /^https?:\/\// ? (" class=\"external\"") : ("")
        "#{pre}<a#{atts}#{external}>#{text}</a>#{post}"
      end
    end
  end
  
  MARKDOWN_REFLINK_RE = /
              \[([^\[\]]+)\]      # $text;Fi[	@xi^I"í        "<#{raw[1]}#{pcs.join(" ")}>"
      else
        " "
      end
    end
  end
  
  ALLOWED_TAGS = ["redpre", "pre", "code", "notextile"]
  ;Fi[	@ôi»I"‹          if (@var.size > 0) then
            out("/Outlines #{@outlineRoot} 0 R")
            out("/PageMode /UseOutlines")
          end
        end
      end
      
      # fetch row values
      def function(arglist);Fi[	@ôiáI"8            var.Bookmark(var.title, var)
            write_wiki_page(var, var)
            write_page_hierarchy(var, var, var.id, (var + 1)) if var[var.id]
          end
        end
      end
      
      def function(arglist)
        var.RDMwriteHTMLCell(190, 5, 0, 0, var.content.text.to_s, var.attachments, 0);Fi[	@ôiôI"            var.RDMCell(25, 5, format_date(var.created_on), 0, 0, "R")
            var.RDMCell(65, 5, var.author.name, 0, 0, "R")
            var.Ln)
          end
        end
      end
      
      class RDMPdfEncoding
        def self.rdm_from_utf8(arglist);Fi[	@≥iKI"            else
              # do nothing
            end
          end
        end
      end
      
      def function(arglist)
        @var = { "project" => ({ :sql => ("#{TimeEntry.table_name}.project_id"), :klass => (Project), :label => :label_project }), "status" => ({ :sql => ("#{Issue.table_name}.status_id"), :klass => (IssueStatus), :label => :field_status }), "version" => ({ :sql => ("#{Issue.table_name}.fixed_version_id"), :klass => (Version), :label => :label_version }), "category" => ({ :sql => ("#{Issue.table_name}.category_id"), :klass => (IssueCategory), :label => :field_category }), "user" => ({ :sql => ("#{TimeEntry.table_name}.user_id"), :klass => (User), :label => :label_user }), "tracker" => ({ :sql => ("#{Issue.table_name}.tracker_id"), :klass => (Tracker), :label => :label_tracker }), "activity" => ({ :sql => ("#{TimeEntry.table_name}.activity_id"), :klass => (TimeEntryActivity), :label => :label_activity }), "issue" => ({ :sql => ("#{TimeEntry.table_name}.issue_id"), :klass => (Issue), :label => :label_issue }) };Fi[	@ iYI"¯          [ll(var.to_s, :general_lang_name), var.to_s]
        end.sort do |arglist|
          (var.first <=> var.first)
        end
      end
    end
    
    def function(arglist)
      @@languages_lookup = valid_languages.inject({}) do |arglist|;Fi[	@ i®I"∂              var = resolve(var, var, var, var.merge(:scope => (nil)))
            end
            var
          end
        end
      end
      
      include(Implementation)
      ;Fi[	@∏i}I"            yield(var, var, var)
          else
            link_to(var, params.merge(var), var)
          end
        end
      end
      
      # Yields the given block with the text and parameters
      # for each pagination link and returns a string that represents the links;Fi[	I"2data//redmine_proj/redmine/safe_attributes.rb;TiI"“        else
          var = var.last.is_a?(Hash) ? (var.pop) : ({})
          (@var << [var, var])
        end
      end
    end
    
    # Returns an array that can be safely set by user or current user
    #;Fi[	I")data//redmine_proj/redmine/themes.rb;TiRI"û          end
        else
          Dir.glob("#{path}/#{dir}/*").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    ;Fi[	@Œi:I"Ÿ              else
                @var.last[var] = var
              end
            end
          end
        end
        
        def function(arglist)
          raise("Need to implement #{self.class.name}#output");Fi[	@i§I"             end
            draw_x_guidelines(var, var) if show_x_guidelines
            var = (var + 1))
          end
        end
      end
      
      # Where in the Y area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.;Fi[	@i–I"‘            end
            draw_y_guidelines(var, var) if show_y_guidelines
            var = (var + 1))
          end
        end
      end
      
      # Draws the X axis guidelines
      def function(arglist);Fi[	@i˝I"            var.attributes["transform"] = "rotate( -90, #{x}, #{y} )"
          else
            var.attributes["transform"] = "rotate( 90, #{x}, #{y} )"
          end
        end
      end
      
      def function(arglist)
        return @var.collect { |arglist| var[:title] };Fi[	@iOI"            var = var[var]
            var = (var + var.attributes["style"]) if var.attributes["style"]
            var.attributes["style"] = var
          end
        end
      end
      
      def function(arglist)
        var = get_style;Fi[	@4i:I"î          end
        else
          Kernel.sleep
        end
      end
    end
    
    # Retrieves data from the queue head, and removes it.
    #;Fi[	I"'data//rescue_proj/resque/plugin.rb;TiI"–      failure_hooks(var).each do |arglist|
        if var.to_s.end_with?("failure") then
          raise(LintError, "#{plugin}.#{hook} is not namespaced")
        end
      end
    end
    
    @var = {}
    ;Fi[	@7i:I"Ô          Array(@var.lrange(@var, var, ((var + var) - 1))).map do |arglist|
            decode(var)
          end
        end
      end
    end
    
    # Pop an item off the queue.  This method will block until an item is
    # available.;Fi[	@7iPI"≠            var = @var.blpop(@var, 1)
          end
          decode(var.last)
        end
      end
    end
    
    # Get the length of the queue
    def function(arglist);Fi[	I"'data//rescue_proj/resque/worker.rb;Ti‘I"        else
          Resque.logger.info("Error reconnecting to Redis; quitting")
          raise
        end
      end
    end
    
    # Returns a list of queues to use when searching for a job.
    # A splat ("*") means you want every queue (in alpha order) - this;Fi[	I" data//rescue_proj/resque.rb;TiRI"ë        redis.nodes.map { |arglist| var.id }.join(", ")
      else
        redis.client.id
      end
    end
  end
  
  attr_accessor(:logger)
  ;Fi[	@ûiI"”    else
      Array(redis.lrange(var, var, ((var + var) - 1))).map do |arglist|
        decode(var)
      end
    end
  end
  
  # Returns an array of all known Resque queues as strings.
  def function(arglist);Fi[	@]iQI"Ö            else
              self[nil]
            end
          end
        end
      end
      
      extend(ClassMethods)
      ;Fi[	@fiiI"#        var.each do |arglist|
          unless ["@_proxy", "@_implementation", "@method_name"].include?(var.to_s) then
            instance_variable_set(var, var)
          end
        end
      end
      
      # Run all the before(:each) blocks for this example
      def function(arglist);Fi[	@~i!I"‰                define_method(:subject) { |arglist| super().send(var) }
              end
              instance_eval(&var)
            end
          end
        end
        
        attr_reader(:explicit_subject_block)
        ;Fi[	@~i7I"˚            proc { |arglist| described_class.new }
          else
            proc { |arglist| description_args.first }
          end
        end
      end
      
      module ExampleMethods
        alias_method(:__should_for_example_group__, :should);Fi[	@ÖiI"˜          ::Spec::Expectations.fail_with(var, var.expected.first, var.actual)
        else
          ::Spec::Expectations.fail_with(var)
        end
      end
    end
    
    class NegativeExpectationHandler
      def self.handle_matcher(arglist);Fi[	@üi7I"í                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        (@var - @var);Fi[	@øi;I"À            if (@var == :at_least) then
              return "Isn't life confusing enough?\nInstead of having to figure out the meaning of this:\n  should_not have_at_least(#{@expected}).#{@collection_name}\nWe recommend that you use this instead:\n  should have_at_most(#{(@expected - 1)}).#{@collection_name}\n"
            end
          end
        end
      end
      
      def function(arglist)
        "have #{relative_expectation} #{@collection_name}";Fi[	@«i-I"’            instance_exec(var, &@var)
          rescue Spec::Expectations::ExpectationNotMetError
            false
          end
        end
      end
      
      # See Spec::Matchers
      def function(arglist);Fi[	@«iXI"ï          define_method(var) do |arglist|
            var.call(*var)
            self
          end
        end
      end
      
      private
      ;Fi[	@|iI"ˆ            @var = []
          else
            @var = var.collect { |arglist| matcher_for(var) }
          end
        end
      end
      
      def function(arglist)
        return ArgumentMatchers::MatcherMatcher.new(var) if is_matcher?(var);Fi[	@”i@I"≈            else
              @var ? (@var) : ("nil")
            end
          end
        end
      end
      
      def function(arglist)
        var = opts[:message] unless opts[:message].nil?;Fi[	@ÈiI"∏                end
              end
            end
          end
        end
      end
      
      def function(arglist)
        @var.raise_unexpected_message_args_error(var, *var);Fi[	@ÈiºI"°            else
              "public"
            end
          end
        end
      end
      
      def function(arglist)
        "proxied_by_rspec__#{sym}";Fi[	@ÈiÂI"¡          if method_defined?(var) then
            alias_method(var, var)
            remove_method(var)
          end
        end
      end
      
      def function(arglist)
        @var.nil?;Fi[	@i±I"˙          var = var.to_sym if var
          var.each do |arglist|
            Spec::Example::ExampleGroupFactory[var].__send__(var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = scope_and_options(*var);Fi[	@fi4I"K            var.instance_methods(false).each do |arglist|
              var = @var.new(var.name, var, Spec::Runner.options)
              var.validate
            end
          end
        end
        
        def function(arglist)
          var.to_class rescue raise("Heckling failed - \"#{name}\" is not a known class or module");Fi[	@ni-I"          consider_example_group_for_best_match(var, var, var)
          var.examples.each do |arglist|
            consider_example_for_best_match(var, var, var, var)
          end
        end
      end
      
      def function(arglist)
        var, var = parse_location(var.location);Fi[	@qiwI"¸        ensure
          after_suite_parts.each do |arglist|
            (var.arity < 1) ? (var.call) : (var.call(var))
          end
        end
      end
      
      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.before_suite_parts;Fi[	@qiìI"‹          rescue LoadError
            warn("You must 'gem install win32console' to use colour on Windows")
            @var = false
          end
        end
      end
      
      def function(arglist)
        case var;Fi[	@qiI"G        Spec::Runner.configuration.predicate_matchers.each_pair do |arglist|
          Spec::Example::ExampleMethods.__send__(:define_method, var) do |arglist|
            eval("be_#{method_on_object.to_s.gsub("?", "")}(*args)")
          end
        end
      end
      
      def function(arglist)
        case mock_framework;Fi[	@ti&I"Â            example_pending(var, var.location, var.message)
          else
            example_failed(var, var)
          end
        end
      end
      
      def function(arglist)
        backtrace_tweaker.tweak_backtrace(var);Fi[	@tibI"              "'#{@example_name}' FIXED"
            else
              "#{@exception.class.name} in '#{@example_name}'"
            end
          end
        end
        
        def function(arglist)
          @var.is_a?(Spec::Example::PendingExampleFixedError);Fi[	@tiìI"È            var.example_pending(var, var, var.location)
          else
            var.example_pending(var, var)
          end
        end
      end
      
      def function(arglist)
        (var.method(:example_pending).arity == 3);Fi[	I"1data//sinatra_proj/sinatra/showexceptions.rb;Ti6I"„)          "system"
        else
          "app"
        end
      end
    end
    
    TEMPLATE = "<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n  <title><%=h exception.class %> at <%=h path %></title>\n\n  <script type=\"text/javascript\">\n  //<!--\n  function toggle(id) {\n    var pre  = document.getElementById(\"pre-\" + id);\n    var post = document.getElementById(\"post-\" + id);\n    var context = document.getElementById(\"context-\" + id);\n\n    if (pre.style.display == 'block') {\n      pre.style.display = 'none';\n      post.style.display = 'none';\n      context.style.background = \"none\";\n    } else {\n      pre.style.display = 'block';\n      post.style.display = 'block';\n      context.style.background = \"#fffed9\";\n    }\n  }\n\n  function toggleBacktrace(){\n    var bt = document.getElementById(\"backtrace\");\n    var toggler = document.getElementById(\"expando\");\n\n    if (bt.className == 'condensed') {\n      bt.className = 'expanded';\n      toggler.innerHTML = \"(condense)\";\n    } else {\n      bt.className = 'condensed';\n      toggler.innerHTML = \"(expand)\";\n    }\n  }\n  //-->\n  </script>\n\n<style type=\"text/css\" media=\"screen\">\n  *                   {margin: 0; padding: 0; border: 0; outline: 0;}\n  div.clear           {clear: both;}\n  body                {background: #EEEEEE; margin: 0; padding: 0;\n                       font-family: 'Lucida Grande', 'Lucida Sans Unicode',\n                       'Garuda';}\n  code                {font-family: 'Lucida Console', monospace;\n                       font-size: 12px;}\n  li                  {height: 18px;}\n  ul                  {list-style: none; margin: 0; padding: 0;}\n  ol:hover            {cursor: pointer;}\n  ol li               {white-space: pre;}\n  #explanation        {font-size: 12px; color: #666666;\n                       margin: 20px 0 0 100px;}\n/* WRAP */\n  #wrap               {width: 1000px; background: #FFFFFF; margin: 0 auto;\n                       padding: 30px 50px 20px 50px;\n                       border-left: 1px solid #DDDDDD;\n                       border-right: 1px solid #DDDDDD;}\n/* HEADER */\n  #header             {margin: 0 auto 25px auto;}\n  #header img         {float: left;}\n  #header #summary    {float: left; margin: 12px 0 0 20px; width:660px;\n                       font-family: 'Lucida Grande', 'Lucida Sans Unicode';}\n  h1                  {margin: 0; font-size: 36px; color: #981919;}\n  h2                  {margin: 0; font-size: 22px; color: #333333;}\n  #header ul          {margin: 0; font-size: 12px; color: #666666;}\n  #header ul li strong{color: #444444;}\n  #header ul li       {display: inline; padding: 0 10px;}\n  #header ul li.first {padding-left: 0;}\n  #header ul li.last  {border: 0; padding-right: 0;}\n/* BODY */\n  #backtrace,\n  #get,\n  #post,\n  #cookies,\n  #rack               {width: 980px; margin: 0 auto 10px auto;}\n  p#nav               {float: right; font-size: 14px;}\n/* BACKTRACE */\n  a#expando           {float: left; padding-left: 5px; color: #666666;\n                      font-size: 14px; text-decoration: none; cursor: pointer;}\n  a#expando:hover     {text-decoration: underline;}\n  h3                  {float: left; width: 100px; margin-bottom: 10px;\n                       color: #981919; font-size: 14px; font-weight: bold;}\n  #nav a              {color: #666666; text-decoration: none; padding: 0 5px;}\n  #backtrace li.frame-info {background: #f7f7f7; padding-left: 10px;\n                           font-size: 12px; color: #333333;}\n  #backtrace ul       {list-style-position: outside; border: 1px solid #E9E9E9;\n                       border-bottom: 0;}\n  #backtrace ol       {width: 920px; margin-left: 50px;\n                       font: 10px 'Lucida Console', monospace; color: #666666;}\n  #backtrace ol li    {border: 0; border-left: 1px solid #E9E9E9;\n                       padding: 2px 0;}\n  #backtrace ol code  {font-size: 10px; color: #555555; padding-left: 5px;}\n  #backtrace-ul li    {border-bottom: 1px solid #E9E9E9; height: auto;\n                       padding: 3px 0;}\n  #backtrace-ul .code {padding: 6px 0 4px 0;}\n  #backtrace.condensed .system,\n  #backtrace.condensed .framework {display:none;}\n/* REQUEST DATA */\n  p.no-data           {padding-top: 2px; font-size: 12px; color: #666666;}\n  table.req           {width: 980px; text-align: left; font-size: 12px;\n                       color: #666666; padding: 0; border-spacing: 0;\n                       border: 1px solid #EEEEEE; border-bottom: 0;\n                       border-left: 0;\n                       clear:both}\n  table.req tr th     {padding: 2px 10px; font-weight: bold;\n                       background: #F7F7F7; border-bottom: 1px solid #EEEEEE;\n                       border-left: 1px solid #EEEEEE;}\n  table.req tr td     {padding: 2px 20px 2px 10px;\n                       border-bottom: 1px solid #EEEEEE;\n                       border-left: 1px solid #EEEEEE;}\n/* HIDE PRE/POST CODE AT START */\n  .pre-context,\n  .post-context       {display: none;}\n\n  table td.code       {width:750px}\n  table td.code div   {width:750px;overflow:hidden}\n</style>\n</head>\n<body>\n  <div id=\"wrap\">\n    <div id=\"header\">\n      <img src=\"<%= env['SCRIPT_NAME'] %>/__sinatra__/500.png\" alt=\"application error\" height=\"161\" width=\"313\" />\n      <div id=\"summary\">\n        <h1><strong><%=h exception.class %></strong> at <strong><%=h path %>\n          </strong></h1>\n        <h2><%=h exception.message %></h2>\n        <ul>\n          <li class=\"first\"><strong>file:</strong> <code>\n            <%=h frames.first.filename.split(\"/\").last %></code></li>\n          <li><strong>location:</strong> <code><%=h frames.first.function %>\n            </code></li>\n          <li class=\"last\"><strong>line:\n            </strong> <%=h frames.first.lineno %></li>\n        </ul>\n      </div>\n      <div class=\"clear\"></div>\n    </div>\n\n    <div id=\"backtrace\" class='condensed'>\n      <h3>BACKTRACE</h3>\n      <p><a href=\"#\" id=\"expando\"\n            onclick=\"toggleBacktrace(); return false\">(expand)</a></p>\n      <p id=\"nav\"><strong>JUMP TO:</strong>\n         <a href=\"#get-info\">GET</a>\n         <a href=\"#post-info\">POST</a>\n         <a href=\"#cookie-info\">COOKIES</a>\n         <a href=\"#env-info\">ENV</a>\n      </p>\n      <div class=\"clear\"></div>\n\n      <ul id=\"backtrace-ul\">\n\n      <% id = 1 %>\n      <% frames.each do |frame| %>\n          <% if frame.context_line && frame.context_line != \"#\" %>\n\n            <li class=\"frame-info <%= frame_class(frame) %>\">\n              <code><%=h frame.filename %></code> in\n                <code><strong><%=h frame.function %></strong></code>\n            </li>\n\n            <li class=\"code <%= frame_class(frame) %>\">\n              <% if frame.pre_context %>\n              <ol start=\"<%=h frame.pre_context_lineno + 1 %>\"\n                  class=\"pre-context\" id=\"pre-<%= id %>\"\n                  onclick=\"toggle(<%= id %>);\">\n                <% frame.pre_context.each do |line| %>\n                <li class=\"pre-context-line\"><code><%=h line %></code></li>\n                <% end %>\n              </ol>\n              <% end %>\n\n              <ol start=\"<%= frame.lineno %>\" class=\"context\" id=\"<%= id %>\"\n                  onclick=\"toggle(<%= id %>);\">\n                <li class=\"context-line\" id=\"context-<%= id %>\"><code><%=\n                  h frame.context_line %></code></li>\n              </ol>\n\n              <% if frame.post_context %>\n              <ol start=\"<%=h frame.lineno + 1 %>\" class=\"post-context\"\n                  id=\"post-<%= id %>\" onclick=\"toggle(<%= id %>);\">\n                <% frame.post_context.each do |line| %>\n                <li class=\"post-context-line\"><code><%=h line %></code></li>\n                <% end %>\n              </ol>\n              <% end %>\n              <div class=\"clear\"></div>\n            </li>\n\n          <% end %>\n\n        <% id += 1 %>\n      <% end %>\n\n      </ul>\n    </div> <!-- /BACKTRACE -->\n\n    <div id=\"get\">\n      <h3 id=\"get-info\">GET</h3>\n      <% if req.GET and not req.GET.empty? %>\n        <table class=\"req\">\n          <tr>\n            <th>Variable</th>\n            <th>Value</th>\n          </tr>\n           <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %>\n          <tr>\n            <td><%=h key %></td>\n            <td class=\"code\"><div><%=h val.inspect %></div></td>\n          </tr>\n          <% } %>\n        </table>\n      <% else %>\n        <p class=\"no-data\">No GET data.</p>\n      <% end %>\n      <div class=\"clear\"></div>\n    </div> <!-- /GET -->\n\n    <div id=\"post\">\n      <h3 id=\"post-info\">POST</h3>\n      <% if req.POST and not req.POST.empty? %>\n        <table class=\"req\">\n          <tr>\n            <th>Variable</th>\n            <th>Value</th>\n          </tr>\n          <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %>\n          <tr>\n            <td><%=h key %></td>\n            <td class=\"code\"><div><%=h val.inspect %></div></td>\n          </tr>\n          <% } %>\n        </table>\n      <% else %>\n        <p class=\"no-data\">No POST data.</p>\n      <% end %>\n      <div class=\"clear\"></div>\n    </div> <!-- /POST -->\n\n    <div id=\"cookies\">\n      <h3 id=\"cookie-info\">COOKIES</h3>\n      <% unless req.cookies.empty? %>\n        <table class=\"req\">\n          <tr>\n            <th>Variable</th>\n            <th>Value</th>\n          </tr>\n          <% req.cookies.each { |key, val| %>\n            <tr>\n              <td><%=h key %></td>\n              <td class=\"code\"><div><%=h val.inspect %></div></td>\n            </tr>\n          <% } %>\n        </table>\n      <% else %>\n        <p class=\"no-data\">No cookie data.</p>\n      <% end %>\n      <div class=\"clear\"></div>\n    </div> <!-- /COOKIES -->\n\n    <div id=\"rack\">\n      <h3 id=\"env-info\">Rack ENV</h3>\n      <table class=\"req\">\n        <tr>\n          <th>Variable</th>\n          <th>Value</th>\n        </tr>\n         <% env.sort_by { |k, v| k.to_s }.each { |key, val| %>\n         <tr>\n           <td><%=h key %></td>\n           <td class=\"code\"><div><%=h val %></div></td>\n         </tr>\n         <% } %>\n      </table>\n      <div class=\"clear\"></div>\n    </div> <!-- /RACK ENV -->\n\n    <p id=\"explanation\">You're seeing this error because you have\nenabled the <code>show_exceptions</code> setting.</p>\n  </div> <!-- /WRAP -->\n  </body>\n</html>\n"
  end;Fi[	@ÿiKI"    else
      if ($LOG_LEVEL > 5) then
        puts("[Debug - #{self.name}] Buffering some data for later (#{self.output_buffer.length} bytes buffered)")
      end
    end
  end
  
  def function(arglist)
    (self.unzipped_input << unzip_stream.inflate(self.input_buffer));Fi[	@ÿi^I"Ÿ      if var.!=(nil) then
        var = prep_received_object(var)
        inject_object_to_output_stream(var) if var.!=(nil)
      end
    end
  end
  
  def function(arglist)
    return false if unzipped_input.empty?;Fi[	I"5data//state_machine_proj/state_machine/branch.rb;TiûI"          BlacklistMatcher.new(var[var])
        else
          AllMatcher.instance
        end
      end
    end
    
    # Verifies that all configured requirements (event and state) match the
    # given query.  If a match is found, then a hash containing the;Fi[	@îiìI"D          owner_class.validates_each(attribute) do |arglist|
            var = var.class.state_machine(var)
            var.invalidate(var, :state, :invalid) unless var.states.match(var)
          end
        end
      end
      
      # Adds hooks into validation for automatically firing events
      def function(arglist);Fi[	@óiDI"            ::ActiveRecord::Observer.class_eval do |arglist|
              include(StateMachine::Integrations::ActiveModel::Observer)
            end
          end
        end
      end
      
      version("2.0 - 2.2.x") do |arglist|
        def self.active?(arglist);Fi[	@≤icI"T          owner_class.validates_with_block(attribute) do |arglist|
            var = self.class.state_machine(var)
            var.states.match(self) ? (true) : ([false, var.generate_message(:invalid)])
          end
        end
      end
      
      # Adds hooks into validation for automatically firing events
      def function(arglist);Fi[	@’iOI"\          warn("State #{qualified_name.inspect} for #{machine.name.inspect} is already defined in #{other_machine.name.inspect}")
        else
          add_predicate if var.empty?
        end
      end
    end
    
    # Creates a copy of this state in addition to the list of associated
    # methods to prevent conflicts across different states.;Fi[	I"9data//state_machine_proj/state_machine/transition.rb;TiMI"        callcc do |arglist|
          @var = var
          throw(:halt, true)
        end
      end
    end
    
    # Resumes the execution of a previously paused callback execution.  Once
    # the paused callbacks complete, the current execution will continue.;Fi[	@ÿiêI"            skip_actions.! and results[var] = object.send(var)
          end
          results.values.all?
        end
      end
    end
    
    # Rolls back changes made to the object's states via each transition
    def function(arglist);Fi[	@ÿiØI"ñ        end
      else
        yield
      end
    end
  end
  
  class AttributeTransitionCollection < TransitionCollection
    def function(arglist);Fi[	I"0data//twitter_proj/twitter/api/favorites.rb;TiI"C            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)))
          rescue Twitter::Error::Forbidden => var
            handle_forbidden_error(Twitter::Error::AlreadyFavorited, var)
          end
        end
      end
      
      (alias :fav! :favorite!)
      ;Fi[	I"(data//twitter_proj/twitter/tweet.rb;TiúI"‡      else
        warn("#{Kernel.caller.first}: To get #{key.to_s.tr("_", " ")}, you must pass `:include_entities => true` when requesting the #{self.class.name}.")
        []
      end
    end
  end
  
  Status = Tweet
end;Fi[	@Íi,I"          puts("## [message] Above is your schedule file converted to cron syntax; your crontab file was not updated.")
          puts("## [message] Run `whenever --help' for more options.")
          exit(0)
        end
      end
    end
    
    protected
    ;Fi[	@Öi$I"        enumerate(var).each do |arglist|
          enumerate(var.at, false).each do |arglist|
            yield(new(var, var.output, var).output)
          end
        end
      end
      
      def function(arglist)
        [time_in_cron_syntax, task].compact.join(" ").strip;Fi[	@Öi]I"°            end
          else
            parse_as_string
          end
        end
      end
      
      def function(arglist)
        var = Array.new(5, "*");Fi[	@Òi.I"Ï          escape_single_quotes(var)
        else
          var.all? { |arglist| (var == "\"") } ? (escape_double_quotes(var)) : (var)
        end
      end
    end
    
    def function(arglist)
      var.gsub(/'/) { |arglist| "'\\''" };Fi[	@ài2I""          var[:output] = @var if defined? @var and var.has_key?(:output).!
          @var[@var] ||= []
          (@var[@var] << Whenever::Job.new(@var.merge(@var).merge(var)))
        end
      end
    end
    
    def function(arglist)
      [environment_variables, cron_jobs].compact.join;Fi[	@àiKI"±          var = var.strip.to_sym
          set(var, var.strip)
          @var[var] = var
        end
      end
    end
    
    def function(arglist)
      return if @var.empty?;Fi[@'I" ;FI"private;FI" ;Fi√[√[	@˝iI"      
      def function(arglist)
        generated_attribute_methods.method_defined?(var)
      end
      
      private
      
      # The methods +method_missing+ and +respond_to?+ of this module are
      # invoked often in a typical rails, both of which invoke the method;Fi[	@˝içI"	    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var)
    end
    
    private
    
    # Returns a struct representing the matching attribute method.
    # The struct's attributes are prefix, base and suffix.;Fi[	I"5data//activemodel_proj/active_model/callbacks.rb;Ti5I"d        define_callbacks(var, var)
        var.each { |arglist| send("_define_#{type}_model_callback", self, var) }
      end
    end
    
    private
    
    def function(arglist)
      var.class_eval("        def self.before_#{callback}(*args, &block)\n          set_callback(:#{callback}, :before, *args, &block)\n        end\n", "(string)", (126 + 1));Fi[	@3i8I"”    #   person.changed_attributes # => {"name" => "bob"}
    def function(arglist)
      @var ||= {}
    end
    
    private
    
    # Handle <tt>*_changed?</tt> for +method_missing+.
    def function(arglist);Fi[	@iaI"`      var = var.!=(:base) ? (@var.send(:read_attribute_for_validation, var)) : (nil)
      var = { :default => (var), :model => (@var.class.model_name.human), :attribute => (@var.class.human_attribute_name(var)), :value => (var) }.merge!(var)
      I18n.translate(var, var)
    end
    
    private
    
    def function(arglist)
      var ||= :invalid;Fi[	@9iWI"Y      def function(arglist)
        assert(model.respond_to?(:errors), "The model should respond to errors")
        assert(model.errors[:hello].is_a?(Array), "errors#[] should return an Array")
      end
      
      private
      
      def function(arglist)
        assert(@var.respond_to?(:to_model), "The object should respond_to to_model");Fi[	@i´I"       (var << @var)
      var = { :scope => ([@var.i18n_scope, :models]), :count => 1, :default => (var) }.merge!(var.except(:default))
      I18n.translate(var.shift, var)
    end
    
    private
    
    def function(arglist)
      ActiveSupport::Inflector.underscore(var).tr("/", var);Fi[	@Ci8I"{        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send)
    ;Fi[	@KiaI"Æ            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing;Fi[	@YiI")        unless (delimiter.respond_to?(:include?) or (delimiter.respond_to?(:call) or delimiter.respond_to?(:to_sym))) then
          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist)
        var = if delimiter.respond_to?(:call) then;Fi[	@biI"…        end
        check_options_validity(options, :with)
        check_options_validity(options, :without)
      end
      
      private
      
      def function(arglist)
        var = options[var];Fi[	@ûi6I"‰          var[:message] ||= var if var
          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist)
        (if options[:tokenizer] and var.kind_of?(String) then;Fi[	I"5data//activemodel_proj/active_model/validator.rb;TiPI"ç    def function(arglist)
      @var = var
      super
    end
    
    private
    
    def function(arglist)
      @var.call(var, var, var);Fi[	@xiDI"        reader_method(var, var, var, var, var)
        writer_method(var, var, var, var, var)
        create_reflection(:composed_of, var, nil, var, self)
      end
      
      private
      
      def function(arglist)
        define_method(var) do |arglist|;Fi[	@i%I"ú            var
          end
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins);Fi[	@}içI"        var, var = var
        var.each { |arglist| instance_variable_set(var, var) }
        @var = @var.class.reflect_on_association(var)
      end
      
      private
      
      def function(arglist)
        loaded?.! and ((owner.new_record?.! or foreign_key_present?) and klass);Fi[	@ÇiI"        var = klass.unscoped
        var.merge!(eval_scope(klass, reflection.scope)) if reflection.scope
        add_constraints(var)
      end
      
      private
      
      def function(arglist)
        var = alias_tracker.connection.schema_cache.columns_hash[var];Fi[	@àiI"¡      def function(arglist)
        var = owner[reflection.foreign_type]
        var.presence and var.constantize
      end
      
      private
      
      def function(arglist)
        super;Fi[	@ãi'I"ø      
      def function(arglist)
        owner.new_record? and foreign_key_present?.!
      end
      
      private
      
      def function(arglist)
        if options[:counter_sql] then;Fi[	@óiI"ô          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size;Fi[	@öiI"Ù      def function(arglist)
        set_owner_attributes(var)
        var ? (var.save!(:validate => (var))) : (var.save(:validate => (var)))
      end
      
      private
      
      # Returns the number of records in this collection.
      #;Fi[	@ùi;I"ƒ        save_through_record(var)
        update_counter(1)
        var
      end
      
      private
      
      def function(arglist)
        @var ||= owner.association(through_reflection.name);Fi[	@†i:I"            # do nothing
          end
        end
      end
      
      private
      
      # The reason that the save param for replace is false, if for create (not just build),
      # is because the setting of the foreign keys is actually handled by the scoping when;Fi[	@•iI"¥      def function(arglist)
        create_through_record(var)
        self.target = var
      end
      
      private
      
      def function(arglist)
        ensure_not_nested;Fi[	@¿i
I"ú    module JoinHelper
      def function(arglist)
        Arel::InnerJoin
      end
      
      private
      
      def function(arglist)
        var = [];Fi[	@√iDI"≠        
        def function(arglist)
          reflection.options
        end
        
        private
        
        def function(arglist)
          var = owners_by_key;Fi[	@‘i!I"7        
        def function(arglist)
          join_table[reflection.foreign_key]
        end
        
        private
        
        # Once we have used the join table column (in super), we manually instantiate the
        # actual records, ensuring that we don't create more than one instances of the same;Fi[	@„iI"˙        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        private
        
        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]));Fi[	@ÚiI"            var.map! { |arglist| var.send(source_reflection.name) }.flatten!
            var.compact!
          end
        end
        
        private
        
        def function(arglist)
          Preloader.new(owners, through_reflection.name, through_scope).run;Fi[	@˜iCI"¿      
      def function(arglist)
        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var;Fi[	@¸i#I"‘        yield(var) if block_given?
        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist)
        scope.scope_for_create.stringify_keys.except(klass.primary_key);Fi[	@ˇiI"d          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      
      # Construct attributes for :through pointing to owner and associate. This is used by the
      # methods which create and delete records on the association.;Fi[	@i´I"“        association_instance_set(var, var)
      end
      var
    end
    
    private
    
    # Returns the specified association instance if it responds to :loaded?, nil otherwise.
    def function(arglist);Fi[	@iwI"Ì        else
          (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist)
        if object.class.send(:create_time_zone_conversion_attribute?, name, column) then;Fi[	@i6I"∫          @var.clear
          @var.clear
        end
      end
      
      private
      
      # Wrap write_attribute to remember original attribute value.
      def function(arglist);Fi[	@i"I"ª            var.number? ? (var.zero?.!) : (var.blank?.!)
          end)
        end
      end
      
      private
      
      # Handle *? for method_missing.
      def function(arglist);Fi[	@i;I"@        def function(arglist)
          var = var.unpack("h*").first
          generated_attribute_methods.module_eval("            def __temp__#{safe_name}\n              read_attribute(AttrNames::ATTR_#{safe_name}) { |n| missing_attribute(n, caller) }\n            end\n            alias_method #{name.inspect}, :__temp__#{safe_name}\n            undef_method :__temp__#{safe_name}\n", "(string)", (59 + 1))
        end
        
        private
        
        def function(arglist)
          if (attribute_types_cached_by_default == ATTRIBUTE_TYPES_CACHED_BY_DEFAULT) then;Fi[	@i\I"ó            var.type_cast(var)
          end
        end)
      end
      
      private
      
      def function(arglist)
        read_attribute(var);Fi[	@"i,I"          else
            super
          end
        end
        
        private
        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type));Fi[	@"i3I"0        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist)
        var.change(:usec => 0) if var;Fi[	@i<I"Û    
    def function(arglist)
      defined? @var and @var.include?(var)
    end
    
    private
    
    # Returns a Hash of the Arel::Attributes and attribute values that have been
    # type casted for use in an Arel insert/update method.;Fi[	I"7data//activerecord_proj/active_record/callbacks.rb;TiI"ì    
    def function(arglist)
      run_callbacks(:touch) { |arglist| super }
    end
    
    private
    
    #:nodoc:
    def function(arglist);Fi[	@(iFI"„          synchronize do |arglist|
            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist)
          @var.synchronize(&var);Fi[	@(i2I"            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      
      # Acquire a connection by one of 1) immediately removing one
      # from the queue of available connections, 2) creating a new;Fi[	@(i¡I"û          end
          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist)
        @var[Process.pid];Fi[	@6iI"        var[:default] = default unless default.nil?
        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist)
        base.add_column_options!(var, var.merge(:column => (self)));Fi[	@6iI"˘      # to generate the final SQL to create the table.
      def function(arglist)
        (@var.map { |arglist| var.to_sql } * ", ")
      end
      
      private
      
      def function(arglist)
        var = ColumnDefinition.new(var, var, var);Fi[	@6iûI"ï      
      ["string", "text", "integer", "float", "decimal", "datetime", "timestamp", "time", "date", "binary", "boolean"].each do |arglist|
        class_eval("          def #{column_type}(*args)                                          # def string(*args)\n            options = args.extract_options!                                  #   options = args.extract_options!\n            args.each do |name|                                              #   column_names.each do |name|\n              @base.add_column(@table_name, name, :#{column_type}, options)  #     @base.add_column(@table_name, name, :string, options)\n            end                                                              #   end\n          end                                                                # end\n", "(string)", (499 + 1))
      end
      
      private
      
      # Adds a column or columns of a specified type
      #;Fi[	@9i(I"’      # Lists the valid migration options
      def function(arglist)
        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var;Fi[	@>i¶I"#          raise(ArgumentError.new("You must specify at least one column name. Example: remove_columns(:people, :first_name)"))
        end
        var.map { |arglist| quote_column_name(var) }
      end
      
      private
      
      def function(arglist)
        TableDefinition.new(self);Fi[	@Ii.I"Ù        
        def function(arglist)
          collation and collation.match(/_ci$/).!
        end
        
        private
        
        def function(arglist)
          if adapter.emulate_booleans and var.downcase.index("tinyint(1)") then;Fi[	@Ii°I"—      
      def function(arglist)
        [remove_column_sql(var, :updated_at), remove_column_sql(var, :created_at)]
      end
      
      private
      
      def function(arglist)
        (version[0] >= 5);Fi[	@Li'I"’          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) };Fi[	@QimI"ÿ          (var << var)
          (var << build_footer(var.rows.length, var))
          (var.join("\n") + "\n")
        end
        
        private
        
        def function(arglist)
          [].tap do |arglist|;Fi[	@Qi“I"°      
      def function(arglist)
        @var.last_id
      end
      
      private
      
      def function(arglist)
        @var = Mysql2::Client.new(@var);Fi[	@VirI"÷        def function(arglist)
          cache.values.each { |arglist| var[:stmt].close }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[Process.pid];Fi[	@ViíI"ë        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {};Fi[	@bi~I"÷              var
            end
          end
        end
        
        private
        
        HstorePair = (var = /"[^"\\]*(?:\\.[^"\\]*)*"/
        var = /(?:\\.|[^\s,])[^\s=,\\]*(?:\\.[^\s=,\\]*|=[^,>])*/;Fi[	@àiMI"˚      def function(arglist)
        @var, @var, @var, @var, @var = var
        prepare_default_proc
      end
      
      private
      
      def function(arglist)
        @var.default_proc = Proc.new { |arglist| var[var] = connection.columns(var) };Fi[	@çiSI"–        def function(arglist)
          cache.values.each { |arglist| dealloc(var[:stmt]) }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[$$];Fi[	@ïiWI"ä        else
          superclass.arel_engine
        end
      end
      
      private
      
      #:nodoc:
      def function(arglist);Fi[	@ïiI"£    # Returns a hash of the given methods with their names as keys and returned values as values.
    def function(arglist)
      Hash[var.map { |arglist| [var, public_send(var)] }].with_indifferent_access
    end
    
    private
    
    # Under Ruby 1.9, Array#flatten will call #to_ary (recursively) on each of the elements
    # of the array, and then rescues from the possible NoMethodError. If those elements are;Fi[	@ûi≈I"ê        var
      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key);Fi[	@ûi≠I"    
    def function(arglist)
      ActiveRecord::Base.connection_handler.connection_pool_list.map(&:connection)
    end
    
    private
    
    def function(arglist)
      var = ActiveRecord::FixtureSet.create_fixtures(fixture_path, fixture_table_names, fixture_class_names);Fi[	@•iwI"          end
          raise(NameError, "uninitialized constant #{candidates.first}")
        end
      end
      
      private
      
      # Called by +instantiate+ to decide which class to use for a new
      # record instance. For single-table inheritance, we check the record;Fi[	@•i£I"≈        end
        var
      end
    end
    
    private
    
    # Sets the attribute used for single table inheritance to this class name if this is not the
    # ActiveRecord::Base descendant.;Fi[	@´iI"∞      
      def function(arglist)
        self.class.locking_enabled?
      end
      
      private
      
      def function(arglist)
        var = self.class.locking_column;Fi[	@µiII"⁄      # irreversible methods need to be here too
      def function(arglist)
        yield(ConnectionAdapters::Table.new(var, self))
      end
      
      private
      
      module StraightReversions
        private;Fi[	@Ωi"I"›      # serialization)
      def function(arglist)
        var
      end
      
      private
      
      # Guesses the table name, but does not decorate it with prefix and suffix information.
      def function(arglist);Fi[	@¬i`I"     # See ActionView::Helpers::FormHelper::fields_for for more info.
    def function(arglist)
      marked_for_destruction?
    end
    
    private
    
    UNASSIGNABLE_KEYS = ["id", "_destroy"]
    ;Fi[	@Ài;I"-        var = discriminate_class_for_record(var)
        var = var.decorate_columns(var)
        var.allocate.init_with("attributes" => (var), "column_types" => (var))
      end
      
      private
      
      # Called by +instantiate+ to decide which class to use for a new
      # record instance.;Fi[	@ÀimI"È        var = self.class.primary_key
        (self.class.unscoped.where(var => (self[var])).update_all(var) == 1)
      end
    end
    
    private
    
    # A hook to be overridden by association modules.
    def function(arglist);Fi[	@õi'I"∞        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    
    def function(arglist)
      ActiveRecord::Base.connection_id = var;Fi[	@ﬂi|I">      # and +other_aggregation+ has an options hash assigned to it.
      def function(arglist)
        (super or (var.kind_of?(self.class) and ((name == var.name) and (var.options and (active_record == var.active_record)))))
      end
      
      private
      
      def function(arglist)
        name.to_s.camelize;Fi[	@ﬂiII"®      
      def function(arglist)
        options.key?(:polymorphic)
      end
      
      private
      
      def function(arglist)
        var = name.to_s.camelize;Fi[	@ﬂiËI"          raise(HasOneThroughCantAssociateThroughCollection.new(active_record.name, self, through_reflection))
        end
        check_validity_of_inverse!
      end
      
      private
      
      def function(arglist)
        (options[:source_type] or source_reflection.class_name);Fi[	@éiNI"Ã          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    
    def function(arglist)
      "#{quoted_table_name}.#{quoted_primary_key} ASC";Fi[	@Øi¥I"H    #   Person.joins(:companies).ids # SELECT people.id FROM people INNER JOIN companies ON companies.person_id = people.id
    def function(arglist)
      pluck(primary_key)
    end
    
    private
    
    def function(arglist)
      (eager_loading? or (includes_values.present? and (var or references_eager_loaded_tables?)));Fi[	@‚iOI"M      # called exactly once for a given const name.
      def function(arglist)
        const_set(var, Class.new(self) { |arglist| include(ClassSpecificRelation) })
      end
      
      private
      
      # Cache the constants in @@subclasses because looking them up via const_get
      # make instantiation significantly slower.;Fi[	@Îi@I"∑        merge_multi_values
        merge_single_values
        relation
      end
      
      private
      
      def function(arglist)
        relation.where_values = merged_wheres;Fi[	@i4I"°          var.split(".").first.to_sym if var.include?(".")
        end
      end.compact
    end
    
    private
    
    def self.build(arglist)
      case var;Fi[	@Ûi≠I"√      var.from(build_from) if from_value
      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist)
      var = var.reject { |arglist| var.blank? };Fi[	I"Ddata//activerecord_proj/active_record/relation/spawn_methods.rb;Ti;I"Ú    #   Post.order('id asc').only(:where, :order) # uses the specified order
    def function(arglist)
      relation_with(values.slice(*var))
    end
    
    private
    
    def function(arglist)
      var = Relation.new(klass, table, var);Fi[	@Ÿi I"˚      var = to_a.take([limit_value, 11].compact.min).map!(&:inspect)
      var[10] = "..." if (var.size == 11)
      "#<#{self.class.name} [#{entries.join(", ")}]>"
    end
    
    private
    
    def function(arglist)
      var = with_default_scope;Ti[	I"4data//activerecord_proj/active_record/result.rb;Ti3I"≥      @var = columns.dup
      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist)
      @var ||= (var = @var.map { |arglist| var.dup.freeze };Fi[	@‚iI"|      tables(var)
      trailer(var)
      var
    end
    
    private
    
    def function(arglist)
      @var = var;Fi[	@i-I"ì        send(:"#{var}_will_change!")
        var[var] = var
      end
    end
    
    private
    
    def function(arglist)
      var = send(var);Fi[	@ixI"?        var = var.first
        var = var.delete_at(1)
        class_for_adapter(var["adapter"]).new(*var).structure_load(var)
      end
      
      private
      
      def function(arglist)
        @var ||= ConnectionAdapters::ConnectionSpecification::Resolver.new(ENV["DATABASE_URL"], {}).spec.config.stringify_keys;Fi[	@iNI"        var.concat(["--execute", "SET FOREIGN_KEY_CHECKS = 0; SOURCE #{filename}; SET FOREIGN_KEY_CHECKS = 1"])
        var.concat(["--database", "#{configuration["database"]}"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      ;Fi[	@!iDI"√      def function(arglist)
        set_psql_env
        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      ;Fi[	I"Idata//activerecord_proj/active_record/tasks/sqlite_database_tasks.rb;Ti)I"∞      def function(arglist)
        var = configuration["database"]
        `sqlite3 #{var} < "#{var}"`
      end
      
      private
      
      attr_reader :function
      ;Fi[	@$iI"£    def function(arglist)
      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist)
      if self.record_timestamps then;Fi[	@'i3I"–      def function(arglist)
        set_options_for_callbacks!(var)
        set_callback(:rollback, :after, *var, &var)
      end
      
      private
      
      def function(arglist)
        var = var.last;Fi[	@5i-I"Ë      
      def function(arglist)
        (var.foreign_key? ? (var.name) : (var.name.singularize.foreign_key)).to_sym
      end
      
      private
      
      def function(arglist)
        unless file_name =~ /^[_a-z0-9]+$/ then;Fi[	I"(data//backup_proj/backup/archive.rb;TiVI"Í      else
        raise(Errors::Archive::PipelineError, ("Failed to Create Backup Archive\n" + var.error_messages))
      end
    end
    
    private
    
    ##
    # Returns a "tar-ready" string of all the specified paths combined;Fi[	@Ci◊I"      # Returns the current version of the Backup gem
      def function(arglist)
        puts("Backup #{Backup::Version.current}")
      end
      
      private
      
      ##
      # Helper method for asking the user if he/she wants to overwrite the file;Fi[	@FiI"≥      def function(arglist)
        log!
        yield(@var, @var)
      end
      
      private
      
      ##
      # Return the compressor name, with Backup namespace removed;Fi[	@IiI"œ        instance_eval(&var) if block_given?
        @var = "#{utility(:bzip2)}#{options}"
        @var = ".bz2"
      end
      
      private
      
      def function(arglist)
        " -#{@level}" if @var;Fi[	@LiI"Ω        instance_eval(&var) if block_given?
        @var = set_cmd
        @var = set_ext
      end
      
      private
      
      ##
      # Return the command line using the full path.;Fi[	@OiI"Õ        instance_eval(&var) if block_given?
        @var = "#{utility(:gzip)}#{options}"
        @var = ".gz"
      end
      
      private
      
      def function(arglist)
        " -#{@level}" if @var;Fi[	@Ri"I"£      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Lzma is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        (" --best" if @var or " --fast" if @var);Fi[	@Ui(I"´      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Pbzip2 is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        var = (" --best" if @var or " --fast" if @var);Fi[	@Xi?I"—        def function(arglist)
          deprecations[var] = { :version => (nil), :message => (nil), :action => (nil) }.merge(var)
        end
      end
      
      private
      
      # ClassMethods
      ##;Fi[	I".data//backup_proj/backup/configuration.rb;TiI"¶      var = eval(self.to_s.sub("Configuration::", ""))
      Logger.warn(Errors::ConfigurationError.new("        [DEPRECATION WARNING]\n        #{self}.defaults is being deprecated.\n        To set pre-configured defaults for #{klass}, use:\n        #{klass}.defaults\n"))
      var.defaults(&var)
    end
    
    private
    
    def function(arglist)
      const_set(var, Module.new { |arglist| extend(Configuration) });Fi[	@`iI"¨      def function(arglist)
        prepare!
        log!
      end
      
      private
      
      ##
      # Defines the @dump_path and ensures it exists by creating it;Fi[	@ciLI"™          (unlock_database if @var
          package! unless var)
        end
      end
      
      private
      
      ##
      # Builds and runs the mongodump command;Fi[	@fiHI"Û        else
          raise(Errors::Database::PipelineError, ("#{database_name} Dump Failed!\n" + var.error_messages))
        end
      end
      
      private
      
      ##
      # Builds the full mysqldump string based on all attributes;Fi[	@li8I"¶        super
        invoke_save! if invoke_save
        copy!
      end
      
      private
      
      ##
      # Tells Redis to persist the current state of the;Fi[	@oi0I"™            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes;Fi[	@uiI"©      
      def function(arglist)
        load_defaults!
      end
      
      private
      
      ##
      # Return the encryptor name, with Backup namespace removed;Fi[	@xieI"¶        ensure
          cleanup
        end
      end
      
      private
      
      ##
      # Remove any temporary directories and reset all instance variables.;Fi[	@{i-I"—      def function(arglist)
        log!
        yield("#{utility(:openssl)} #{options}", ".enc")
      end
      
      private
      
      ##
      # Uses the 256bit AES encryption cipher, which is what the;Fi[	@~i*I"π          end
        end
        @var = var ? ((msg_prefix + var)) : (class_name)
      end
      
      private
      
      def function(arglist)
        @var ||= (class_name + ": ");Fi[	@Åi@I"†          log!
          notify!(var)
        end
      end
      
      private
      
      ##
      # Return the notifier name, with Backup namespace removed;Fi[	@ÑiI"¬      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@ÑikI"        # Wrapper method for the #send_message (private) method
        def function(arglist)
          send_message(var)
        end
        
        private
        
        ##
        # Takes a "message" as argument, the "type" defaults to "Textmessage".;Fi[	@âi0I"«        @var ||= "yellow"
        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@éioI"¬      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@ëiI"¬      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@îi I"¬      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@óiI"¬      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.;Fi[	@öiFI"o    # Each error is wrapped by Backup::Errors to provide formatting.
    def function(arglist)
      @var ||= (((stderr_messages or "") + "The following system errors were returned:\n") + @var.map { |arglist| Errors::Error.wrap(var).message }.join("\n"))
    end
    
    private
    
    ##
    # Each command is added as part of the pipeline, grouped with an `echo`;Fi[	I")data//backup_proj/backup/splitter.rb;TiI"≠      before_packaging
      yield(@var)
      after_packaging
    end
    
    private
    
    ##
    # The `split` command reads from $stdin and will store it's output in;Fi[	@ùi%I"µ        @var = @var.package
        transfer!
        cycle!
      end
      
      private
      
      ##
      # Provider defaults to false. Overridden when using a service-based;Fi[	@†iI"”        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage;Fi[	@•i%I"⁄        @var ||= "backups"
        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # The initial connection to Dropbox will provide the user with an;Fi[	@™i"I"Ã        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@±iI"        @var ||= File.join(File.expand_path((ENV["HOME"] or "")), "backups")
        instance_eval(&var) if block_given?
        @var = File.expand_path(@var)
      end
      
      private
      
      ##
      # Transfers the archived file to the specified path;Fi[	@∂iI"—        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage;Fi[	@ªi$I"ﬂ        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored;Fi[	@æiI"À        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage;Fi[	@√iI"–        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@»iI"–        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server;Fi[	@œi&I"Õ      # Adds a path to the @directories array
      def function(arglist)
        (@var << var)
      end
      
      private
      
      def function(arglist)
        self.class.to_s.sub("Backup::", "");Fi[	@“i5I"6            SyncContext.new(File.expand_path(var), repository_object, @var).sync!(@var, @var, @var)
          end
          Logger.message("#{syncer_name} Syncing Complete!")
        end
        
        private
        
        class SyncContext
          attr_reader(:directory, :bucket, :path, :remote_base);Fi[	@“iSI"!            else
              raise(Errors::Syncer::Cloud::ConfigurationError, "Unknown concurrency_type setting: #{concurrency_type.inspect}")
            end
          end
          
          private
          
          ##
          # Gathers all the relative paths to the local files;Fi[	@ﬂi,I"Ê          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for CloudFiles.;Fi[	@‰i#I"ﬁ          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for S3.;Fi[	@ÈiI"≈        def function(arglist)
          super
          @var ||= Array.new
        end
        
        private
        
        ##
        # Returns the @directories as a space-delimited string of;Fi[	@ÓiI"A        def function(arglist)
          Logger.message(("#{syncer_name} started syncing the following directories:\n  " + @var.join("\n  ")))
          run(("#{utility(:rsync)} #{options} " + "#{directories_option} '#{dest_path}'"))
        end
        
        private
        
        ##
        # Return expanded @path;Fi[	@ÛiI"≥          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return expanded @path, since this path is local;Fi[	@¯i6I"±          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return @path with any preceeding "~/" removed;Fi[	@–i$I"$    # Returns a String object containing the contents of the file (in the context of the binding if any)
    def function(arglist)
      ERB.new(file_contents(var), nil, "<>").result(binding)
    end
    
    private
    
    ##
    # Reads and returns the contents of the provided file path,;Fi[	@˝iµI"Ω    
    def function(arglist)
      Env.new.write($stdout)
    end
    
    private
    
    def function(arglist)
      Bundler.settings[:cache_all] = options[:all] if options.key?("all");Fi[	@ iI"¥        end
        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist)
      @var.! and (@var.! and (@var.! and (@var.! and @var.!)));Fi[	I",data//bundler_proj/bundler/dep_proxy.rb;Ti%I"õ    
    def function(arglist)
      "#{name} (#{requirement}) #{__platform}"
    end
    
    private
    
    def function(arglist)
      @var.send(*var);Fi[	@)i@I"ò      var = super
      (var << "!") if source
      (var << "\n")
    end
    
    private
    
    def function(arglist)
      RUBY_VERSION =~ /^1\.8/;Fi[	@
i®I"    def function(arglist)
      var = caller[0].split(":")[(0..1)].join(":")
      raise(GemfileError, "Undefined local variable or method `#{name}' for Gemfile\n        from #{location}")
    end
    
    private
    
    def function(arglist)
      var.keys.each do |arglist|;Fi[	@6iDI"ü    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "#{base_dir}/specifications/#{full_name}.gemspec";Fi[	@i&I"¨      ((var << "\n\n") << "Gemfile.lock\n")
      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist)
      begin;Fi[	@iI"£    
    def function(arglist)
      GraphVizClient.new(self).run
    end
    
    private
    
    def function(arglist)
      var = _groups.values.to_set.flatten;Fi[	@?iI"®      else
        raise(ArgumentError, "Source must be an index, not #{index.class}")
      end
    end
    
    private
    
    def function(arglist)
      @var[var];Fi[	@i"I"À      ensure
        Bundler.settings[:frozen] = "1" if var
      end
    end
    
    private
    
    def function(arglist)
      @var.map { |arglist| "gem '#{d.name}', '#{d.requirement}'" }.join("\n");Fi[	@iïI"∫        end
        Bundler.ui.warn("If you want to overwrite skipped stubs, use --force.")
      end
    end
    
    private
    
    def function(arglist)
      var = Bundler.bin_path;Fi[	@LiCI"≠    
    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing;Fi[	@Oi&I"         end
      end
      @var = @var.values
    end
    
    private
    
    TYPES = { "GIT" => (Bundler::Source::Git), "GEM" => (Bundler::Source::Rubygems), "PATH" => (Bundler::Source::Path) }
    ;Fi[	@"i)I"´    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      @var ||= @var.fetch_spec([@var, @var, @var]);Fi[	@%iUI"û      
      def function(arglist)
        "#{name} (#{version})"
      end
      
      private
      
      def function(arglist)
        @var ||= (var = {};Fi[	@^iHI"ï    
    def function(arglist)
      (dependencies - development_dependencies)
    end
    
    private
    
    def function(arglist)
      var = "";Fi[	@8i∫I"õ        end
        ENV["RUBYOPT"] = var.join(" ")
      end
    end
    
    private
    
    def function(arglist)
      var = Dir["#{cache_path}/*.gem"];Fi[	@=ifI"£    
    def function(arglist)
      ENV["BUNDLE_IGNORE_CONFIG"]
    end
    
    private
    
    def function(arglist)
      var = var.to_s.sub(".", "__").upcase;Fi[	@@i!I"ã    
    def function(arglist)
      find_gemfile
    end
    
    private
    
    def function(arglist)
      var = ENV["BUNDLE_GEMFILE"];Fi[	@Ci@I"            git("reset --hard #{@revision}")
            git("submodule update --init --recursive") if var
          end
        end
        
        private
        
        # TODO: Do not rely on /dev/null.
        # Given that open3 is not cross platform until Ruby 1.9.3,;Fi[	@JiûI"√      
      def function(arglist)
        "#{base_name}-#{shortref_for_path((cached_revision or revision))}"
      end
      
      private
      
      def function(arglist)
        @var = true;Fi[	@Xi_I"¨      
      def function(arglist)
        name
      end
      
      private
      
      def function(arglist)
        @var ||= Bundler.app_cache.join(app_cache_dirname);Fi[	@_i|I"⁄        @var = []
        var.remotes.each { |arglist| add_remote(var.to_s) }
        true
      end
      
      private
      
      def function(arglist)
        var = @var.map { |arglist| "#{p}/#{spec.file_name}" };Fi[	@dipI"¶        (var << var)
      end
      SpecSet.new(var)
    end
    
    private
    
    def function(arglist)
      var = @var.find { |arglist| (var.name == "rake") };Fi[	@giXI"ù        else
          STDERR.puts("#{msg}#{newline}") if @var
        end
      end
      
      private
      
      # valimism
      def function(arglist);Fi[	@iñI"Ÿ      (options[:all] or (var.group == var)) and var.namespace.=~(var)
    end
    display_klasses(false, false, var)
  end
  
  private
  
  def self.banner(arglist)
    ("thor " + var.formatted_usage(self, var, var));Fi[	@§i·I"¿    def function(arglist)
      var.send(:rules).each { |arglist| (rules << var.dup) }
      self
    end
    
    private
    
    def function(arglist)
      unless var.kind_of?(Symbol) then;Fi[	@πiI"Æ    
    def function(arglist)
      ([:new, :create] + [@var[:new]].flatten)
    end
    
    private
    
    def function(arglist)
      var.to_s.underscore.gsub("/", "_");Fi[	@øiyI"–            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact;Fi[	@“iVI"õ        end
      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class;Fi[	@˜iπI"»    # associated with this command.
    def function(arglist)
      @var.each { |arglist| var.close unless var[:closed] }
    end
    
    private
    
    def function(arglist)
      options[:logger];Fi[	@i≈I"          end
          teardown_connections_to(var) if var
        end
      end
      
      private
      
      # We establish the connection by creating a thread in a new method--this
      # prevents problems with the thread's scope seeing the wrong 'server';Fi[	@#i†I"Ù          (self.class.instance = var
          self.class.current_feature = var)
        end
      end
      
      private
      
      # Load a recipe from the named file. If +name+ is given, the file will
      # be reported using that name.;Fi[	@Ji_I"ö        var = @var.dup
        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin;Fi[	@OiMI"\          var = "#{from.stream}-capistrano-diff-from"
          var = "#{to.stream}-capistrano-diff-to"
          [change_or_create_stream(var, var), change_or_create_stream(var, var), scm(:diff, "-v", var, "-V", var, "-a")].join(" && ")
        end
        
        private
        
        def function(arglist)
          repository.split("/")[0];Fi[	@ViãI",        # with the scm command prefixed onto it.
        def function(arglist)
          [command, *var].compact.join(" ")
        end
        
        private
        
        # A helper for accessing variable values, which takes into
        # consideration the current mode ("normal" vs. "local").;Fi[	@[iEI"        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        
        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("-r #{revision}".chomp);Fi[	@`iVI"∂          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option
        def function(arglist);Fi[	@eiOI"•          else
            return var
          end
        end
        
        private
        
        def function(arglist)
          case variable(:scm_verbose);Fi[	@liêI"‡          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the
        # command-line switch for "quiet" ("-q").;Fi[	@qiLI"´          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands
        def function(arglist);Fi[	@{iNI"–          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.
        def function(arglist);Fi[	@ÇiYI"˙          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line
        # switches for that. Note that we don't need to return the password;Fi[	@åiCI"
          end
          logger.trace("command finished in #{(elapsed * 1000).round}ms")
          var
        end
        
        private
        
        def function(arglist)
          @var ||= (configuration.logger or Capistrano::Logger.new(:output => (STDOUT)));Fi[	@ñi5I"ﬁ          else
            File.expand_path(configuration[:copy_cache], Dir.pwd)
          end rescue nil
        end
        
        private
        
        def function(arglist)
          copy_repository_to_local_cache;Fi[	@•iI"            var.remote.command("rsync") unless copy_exclude.empty?
            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist)
          File.join(shared_path, (configuration[:repository_cache] or "cached-copy"));Fi[	@™iI"      class UnsharedRemoteCache < RemoteCache
        def function(arglist)
          super.check { |arglist| var.remote.writable(repository_cache) }
        end
        
        private
        
        def function(arglist)
          configuration[:repository_cache];Fi[	@bi9I"‡        raise("eh?")
      end
      return true
    end
    
    private
    
    # Present the prompt and read a single line from the console. It also
    # detects ^D and returns "exit" in that case. Adds the input to the;Fi[	@¬iRI"î    
    def function(arglist)
      to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    ;Fi[	@€iII"Ã            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then;Fi[	@Èi•I"‹      
      def function(arglist)
        (relative_assets or (http_images_path == :relative))
      end
      
      private
      
      def function(arglist)
        var = ((var.keys - ATTRIBUTES) - ARRAY_ATTRIBUTES);Fi[	I"Cdata//compass_proj/compass/sass_extensions/functions/colors.rb;Ti;I"ﬁ    var = (var.alpha * 255).round
    var = var.to_s(16).rjust(2, "0")
    Sass::Script::String.new("##{alphastr}#{color.send(:hex_str)[(1..-1)]}".upcase)
  end
  
  private
  
  def function(arglist)
    if (var > 0) then;Fi[	@$iyI"P      var = color_stops_in_percentages(var)
      var = radial_svg(var, var, var, var)
      inline_image_string(var.gsub(/\s+/, " "), "image/svg+xml")
    end
    
    private
    
    def function(arglist)
      (var.is_a?(ColorStop) or ((var.is_a?(Sass::Script::List) and ColorStop.new(*var.value)) or ColorStop.new(var))) rescue nil;Fi[	@£i I"     var = [var].flatten.pack("m").gsub("\n", "")
    var = "url('data:#{mime_type};base64,#{data}')"
    Sass::Script::String.new(var)
  end
  
  private
  
  def function(arglist)
    return var if var;Fi[	@Øi°I"≈      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      clean_url(var)
    end
  end
  
  private
  
  # Emits a path, taking off any leading "./"
  def function(arglist);Fi[	@8ièI"¯            PARENT.match(name)
            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size;Fi[	@Li*I"        
        def function(arglist)
          (@var.inject(0) { |arglist| var = (var + var.efficiency) } ** @var.length)
        end
        
        private
        
        def function(arglist)
          var = Compass::SassExtensions::Sprites::ImageRow.new(width);Fi[	@WiDI"!        
        def function(arglist)
          @var.respond_to?(var) ? (@var.send(var, *var, &var)) : (super)
        end
        
        private
        
        def function(arglist)
          @var ||= Compass.configuration.sprite_engine.to_s.scan(/([^_.]+)/).flatten.map do |arglist|;Fi[	@Éi™I"°        
        def function(arglist)
          @var.language
        end
        
        private
        
        def function(arglist)
          (index == 0);Fi[	@äinI"î        @var = var
        yield
        @var = nil
      end
      
      private
      
      def function(arglist)
        (@var.failed? or @var);Fi[	@êi^I"ƒ      
      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "_").gsub(/\./, "_").gsub(/:/, "_")
      end
      
      private
      
      def function(arglist)
        var = 0;Fi[	@ñiñI"±        var.rewind
        var = (("\n" + var.read) + (" " * (var[:indent] - 2)))
        var
      end
      
      private
      
      TO_S_PREFIXES = Hash.new("    ")
      ;Fi[	@ñiLI"•        
        def function(arglist)
          "row_#{line}"
        end
        
        private
        
        def function(arglist)
          @var.index(self);Fi[	@ûiI"⁄      # For most formatters this is a no-op.
      def function(arglist)
        broadcast(var, var, var)
      end
      
      private
      
      def function(arglist)
        var = extract_method_name_from(caller);Fi[	@§iûI"ƒ      
      def function(arglist)
        @var[:paths].empty? ? (["features"]) : (@var[:paths])
      end
      
      private
      
      def function(arglist)
        if @var[:autoformat] then;Fi[	@ßi;I"ô        @var.parse!(@var)
        Cucumber.logger = @var.log
        @var
      end
      
      private
      
      def function(arglist)
        begin;Fi[	@Øi.I"Ú      
      def function(arglist)
        cucumber_file and File.exist?(cucumber_file)
      end
      
      private
      
      # Loads the profile, processing it through ERB and YAML, and returns it as a hash.
      def function(arglist);Fi[	I"2data//cucumber_prok/cucumber/configuration.rb;Ti*I"Õ    
    def function(arglist)
      @var[:autoload_code_paths]
    end
    
    private
    
    def function(arglist)
      { :autoload_code_paths => (["features/support", "features/step_definitions"]) };Fi[	@≠i2I"z        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity;Fi[	@≤iMI"          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING;Fi[	@∏i≠I"ô      
      def function(arglist)
        @var = []
      end
      
      private
      
      def function(arglist)
        var = var.join("_").to_sym;Fi[	@ªiI"ﬂ        @var = (@var - 2) if var.to_s =~ /^after/
        print(var)
        @var = (@var + 2) if var.to_s =~ /^before/
      end
      
      private
      
      def function(arglist)
        @var.puts("#{indent}#{text}");Fi[	@ﬁioI"ƒ          build_testcase(var, var.status, var.exception, var)
        end
        @var = false if @var
      end
      
      private
      
      def function(arglist)
        @var = (@var + var);Fi[	@ÊiÃI"        var = cell_prefix(var)
        @var.print(((" " + format_string("#{prefix}#{padded}", var)) + ::Cucumber::Term::ANSIColor.reset(" |")))
        @var.flush
      end
      
      private
      
      def function(arglist)
        @var.puts if (@var == 6);Fi[	@ÈiAI"ñ      
      def function(arglist)
        @var = true
      end
      
      private
      
      def function(arglist)
        print_steps(:pending);Fi[	@ÏiGI"º      
      def function(arglist)
        @var = true if [:failed, :pending, :undefined].index(var)
      end
      
      private
      
      def function(arglist)
        yield if @var;Fi[	@ÚiI"ä      
      def function(arglist)
        print_summary
      end
      
      private
      
      def function(arglist)
        var = 0;Fi[	@ıiI"0      def function(arglist)
        var = lambda { |arglist| var.steps(var) }
        (dump_count(var.steps.length, "step") + dump_status_counts(var, &var))
      end
      
      private
      
      def function(arglist)
        var = [:failed, :skipped, :undefined, :pending, :passed].map do |arglist|;Fi[	@iúI"∞      
      def function(arglist)
        @var.invoke_steps(var, @var, var)
      end
      
      private
      
      def function(arglist)
        var = @var.features_paths;Fi[	@
iGI"∆      
      def function(arglist)
        invoked_step_definition_hash[StepDefinitionLight.new(var, var)] = nil
      end
      
      private
      
      def function(arglist)
        @var ||= {};Fi[	@iCI"ñ      
      def function(arglist)
        # do nothing
      end
      
      private
      
      def function(arglist)
        var.map do |arglist|;Fi[	@i*I"       
      def function(arglist)
        @var.step_matches(var, var)
      end
      
      private
      
      def function(arglist)
        var = File.basename(var)[(0...-File.extname(var).length)];Fi[	@iÑI"å      
      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist)
        if @var then;Fi[	@"i I"¿      
      def function(arglist)
        convert_captures(strip_anchors(@var.source))
      end
      
      private
      
      def function(arglist)
        var.gsub(/(\()(?!\?:)/, "(?:");Fi[	@2iI"£      def function(arglist)
        load unless @var
        @var
      end
      
      private
      
      def function(arglist)
        var = Ast::Features.new;Fi[	@=i~I"        var = best_matches(var, var) if (var.size > 1) and guess_step_matches?
        raise(Ambiguous.new(var, var, guess_step_matches?)) if (var.size > 1)
        var[0]
      end
      
      private
      
      def function(arglist)
        @var.guess?;Fi[	@Bi3I"ï      #
      def function(arglist)
        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin;Fi[	@EièI"à          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    
    #:nodoc
    def function(arglist);Fi[	@Ki"I"È      
      def function(arglist)
        WireException.new(var, @var.host, @var.port)
      end
      
      private
      
      def function(arglist)
        Timeout.timeout(@var.timeout("connect")) { |arglist| socket.puts(var) };Fi[	@PiI"ê      
      def function(arglist)
        # do nothing
      end
      
      private
      
      # Props to Rails
      def function(arglist);Fi[	@fiI"Á      def function(arglist)
        var = var.map { |arglist| prepare(var) }
        @var.invoke(@var, var)
      end
      
      private
      
      def function(arglist)
        return var unless var.is_a?(Cucumber::Ast::Table);Fi[	@ii·I"À      
      def function(arglist)
        Devise.navigational_formats.include?(request_format)
      end
      
      private
      
      def function(arglist)
        Devise.mappings.each do |arglist|;Fi[	@~iNI"    
    def self.add_module(arglist)
      class_eval("        def #{m}?\n          self.modules.include?(:#{m})\n        end\n", "(string)", (113 + 1))
    end
    
    private
    
    def function(arglist)
      @var = (var[:failure_app] or Devise::FailureApp);Fi[	@£iI"¿      
      def function(arglist)
        self.class.timeout_in
      end
      
      private
      
      def function(arglist)
        return false unless respond_to?(:remember_created_at);Fi[	I"-data//devise_proj/devise/param_filter.rb;Ti!I"      var.each do |arglist|
        var[var] = var.to_s if param_requires_string_conversion?(var)
      end
    end
    
    private
    
    # Determine which values should be transformed to string or passed as-is to the query builder underneath
    def function(arglist);Fi[	@¬iI"/      
      def function(arglist)
        (valid_for_params_auth? or valid_for_http_auth?)
      end
      
      private
      
      # Receives a resource and check if it is valid by calling valid_for_authentication?
      # An optional block that will be triggered while validating can be optionally;Fi[	@ÕiI"ò          return pass
        end
        success!(var) if validate(var)
      end
      
      private
      
      def function(arglist)
        super;Fi[	@–iI"Ì          var.after_token_authentication
          success!(var)
        end
      end
      
      private
      
      # Token Authenticatable can be authenticated with params in any controller and any verb.
      def function(arglist);Fi[	@≠iLI"µ  
  def function(arglist)
    @var = Statistics.new.generate_correlations
  end
  
  private
  
  def function(arglist)
    sprintf("%0.02f", (((var - var) / var.to_f) * 100)).to_f;Fi[	@ÁinI"Ç      @var.contacts_visible = true
    end
    @var.save
  end
  
  private
  
  def function(arglist)
    @var = Person.find(var);Fi[	@«i"I"‚      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist)
    if var = current_user.contact_for(var) then;Fi[	@ iAI"ï      end
      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist)
    if user_signed_in? then;Fi[	@œiI"ò  def function(arglist)
    @var = true
    @var = Person.community_spotlight
  end
  
  private
  
  def function(arglist)
    @var = case params[:set];Fi[	I"Cdata//diaspora_proj/controllers/invitation_codes_controller.rb;TiI"¯  def function(arglist)
    sign_out(current_user) if user_signed_in?
    redirect_to(new_user_registration_path(:invite => ({ :token => (params[:id]) })))
  end
  
  private
  
  def function(arglist)
    InvitationCode.find_by_token!(params[:id]);Fi[	@€iII"≥      flash[:error] = I18n.t("invitations.create.no_more")
      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist)
    User.email_regexp.match(var).present?;Fi[	@Ìi,I"‚      var.all { |arglist| render(:layout => (false)) }
      var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist)
    @var ||= if params[:post_id] then;Fi[	@Âi®I"Å        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id };Fi[	@Úi|I"≠    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist)
    if request.params[:qqfile].is_a?(String).! then;Fi[	@Úi:I"º        end
      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("profiles.edit.your_tags_placeholder"))) then;Fi[	@iKI"    FEDERATION_LOGGER.info("recieved a private message for user:#{@user.id}")
    Resque.enqueue(Jobs::ReceiveEncryptedSalmon, @var.id, CGI.unescape(params[:xml]))
    render(:nothing => (true), :status => 202)
  end
  
  private
  
  def function(arglist)
    if params[:xml].nil? then;Fi[	@iI"é  
  def function(arglist)
    super
  end
  
  private
  
  def function(arglist)
    return true if AppConfig.settings.enable_registrations?;Fi[	I"Edata//diaspora_proj/controllers/share_visibilities_controller.rb;TiI"E    params[:shareable_type] ||= "Post"
    var = current_user.toggle_hidden_shareable(accessible_post)
    render(:nothing => (true), :status => 200)
  end
  
  private
  
  def function(arglist)
    @var ||= params[:shareable_type].constantize.where(:id => (params[:post_id])).select("id, guid, author_id, created_at").first;Fi[	@iCI"˘        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "all_aspects")) then;Fi[	@"i6I"ÿ  def function(arglist)
    gon.tagFollowings = tags
    stream_responder(Stream::FollowedTag)
  end
  
  private
  
  def function(arglist)
    @var ||= var.new(current_user, :max_time => (max_time)) if var.present?;Fi[	@(i-I"é        end))
      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name]);Fi[	@3i"I",        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var);Fi[	I"5data//diaspora_proj/helpers/open_graph_helper.rb;Ti7I"√  
  def function(arglist)
    content_tag(:meta, "", :property => (var), :content => (var))
  end
  
  private
  
  # This method compensates for hosting assets off of s3
  def function(arglist);Fi[	@iI"ä  
  def function(arglist)
    var.instance_of?(Reshare)
  end
  
  private
  
  def function(arglist)
    if var.stream_posts.empty? then;Fi[	I"=data//diaspora_proj/mailers/notification_mailers/base.rb;TiI"      var = Mail::Address.new(var)
      var.display_name = var
      var.format
    end
    
    private
    
    def function(arglist)
      var = { :from => (AppConfig.mail.sender_address.get), :host => ("#{AppConfig.pod_uri.host}"), :to => (name_and_address(@var.name, @var.email)) };Fi[	@tiQI"π  
  def function(arglist)
    send_notification(:confirm_email, var)
  end
  
  private
  
  def function(arglist)
    @var = NotificationMailers.const_get(var.to_s.camelize).new(*var);Fi[	@ÉiSI"√        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist)
    if person_id and person.closed_account? then;Fi[	@çiZI"”  
  def function(arglist)
    var[:plain_text] ? (self.text) : (ERB::Util.h(self.text))
  end
  
  private
  
  def function(arglist)
    if self.parent and self.parent.participants.include?(self.author).! then;Fi[	@9i@I"ï    else
      self.target
    end
  end
  
  private
  
  def self.concatenate_or_create(arglist)
    return nil if suppress_notification?(var, var);Fi[	I"@data//diaspora_proj/models/notifications/started_sharing.rb;TiI"ñ  
  def function(arglist)
    super(var.sender, var)
  end
  
  private
  
  def self.make_notification(arglist)
    super(var, var.sender, var, var);Fi[	@ói>I"Ì      self.url = ("http://" + self.url) unless self.url.match(/https?:\/\//)
      self.url = (self.url + "/") if self.url[-1, 1].!=("/")
    end
  end
  
  private
  
  def function(arglist)
    Webfinger.new(self.diaspora_handle).fetch;Fi[	@£iæI"œ      errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["created_at", "updated_at", "person_id"]);Fi[	I"*data//diaspora_proj/models/request.rb;TiVI"€      var.share_with(var, var.auto_follow_back_aspect)
    end
    self
  end
  
  private
  
  # Checks if a [Contact] does not already exist between the requesting [User] and receiving [Person]
  def function(arglist);Fi[	I"*data//diaspora_proj/models/reshare.rb;TiPI"{      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch;Fi[	I"3data//diaspora_proj/models/services/twitter.rb;TiI"˘  
  def function(arglist)
    client.user(nickname).profile_image_url_https("original")
  end
  
  private
  
  def function(arglist)
    @var ||= Twitter::Client.new(:oauth_token => (self.access_token), :oauth_token_secret => (self.access_secret));Fi[	I"3data//diaspora_proj/models/share_visibility.rb;Ti I"Ô      var = var.map { |arglist| [var, var.id, var.class.base_class.to_s] }
      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist)
    if shareable.public? then;Fi[	@±ißI"˜    unless text_and_photos_blank? then
      (errors[:base] << "Cannot destory a StatusMessage with text and/or photos present")
    end
  end
  
  private
  
  def self.tag_stream(arglist)
    joins(:taggings).where("taggings.tag_id IN (?)", var);Fi[	@ªi¡I"i    self.password = var
    self.password_confirmation = var
    self.save(:validate => (false))
  end
  
  private
  
  def function(arglist)
    (self.attributes.keys - ["id", "username", "encrypted_password", "created_at", "updated_at", "locked_at", "serialized_private_key", "getting_started", "disable_mail", "show_community_spotlight_in_stream", "email"]);Fi[	I"#data//haml_proj/haml/buffer.rb;TiöI"∑      var = var.merge(var)
      var["data"] = var unless var.empty?
      var.merge!(var)
    end
    
    private
    
    if (RUBY_VERSION < "1.9") then
      def function(arglist);Fi[	@<i:I"n      var = "begin\nextend Haml::Helpers\n_hamlout = @haml_buffer = Haml::Buffer.new(haml_buffer, #{options.for_buffer.inspect})\n_erbout = _hamlout.buffer\n@output_buffer = output_buffer ||= ActionView::OutputBuffer.new rescue nil\n".gsub("\n", ";")
      var = "#{precompiled_method_return_value}\nensure\n@haml_buffer = @haml_buffer.upper if @haml_buffer\nend\n".gsub("\n", ";")
      (((var + locals_code(var)) + precompiled) + var)
    end
    
    private
    
    # Returns the string used as the return value of the precompiled method.
    # This method exists so it can be monkeypatched to return modified values.;Fi[	@·iÕI"C    def function(arglist)
      var = var.is_a?(Module) ? (:module_eval) : (:instance_eval)
      var.send(var, "def #{name}(_haml_locals = {}); #{compiler.precompiled_with_ambles(local_names)}; end", @var[:filename], @var[:line])
    end
    
    private
    
    if (RUBY_VERSION < "1.9") then
      def function(arglist);Fi[	@EiåI"#        raise("[BUG] Unrecognized color #{color}") unless COLORS[var]
        return var if (ENV["TERM"].nil? or (ENV["TERM"].empty? or STDOUT.tty?.!))
        return "[#{COLORS[color]}m#{str}[0m"
      end
      
      private
      
      def function(arglist)
        return if var.nil?;Fi[	I"-data//haml_proj/haml/helpers/xss_mods.rb;TiQI")      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(escape_once_without_haml_xss(*var))
      end
      
      private
      
      # Escapes the HTML in the text if and only if
      # Rails XSS protection is enabled *and* the `:escape_html` option is set.;Fi[	I"$data//haml_proj/haml/helpers.rb;Ti*I"!    # @return [Boolean] Whether or not `block` is defined directly in a Haml template
    def function(arglist)
      eval("!!defined?(_hamlout)", var.binding)
    end
    
    private
    
    # Parses the tag name used for \{#haml\_tag}
    # and merges it with the Ruby attributes hash.;Fi[	I"$data//haml_proj/haml/options.rb;TiÊI"Ñ        var[var] = send(var)
        var
      end
    end
    
    private
    
    def function(arglist)
      self.class.defaults;Fi[	@‰i|I"        var.backtrace.unshift("#{@options[:filename]}:#{(((e.line ? ((e.line + 1)) : (@index)) + @options[:line]) - 1)}")
        raise
      end
    end
    
    private
    
    class Line < Struct.new(:text, :unstripped, :full, :index, :compiler, :eod)
      alias_method(:eod?, :eod);Fi[	@UiBI"Ω        end
      end
      (var + var)
    end
    
    private
    
    # Parses a magic comment at the beginning of a Haml file.
    # The parsing rules are basically the same as Ruby's.;Fi[	@XiI"†  
  def function(arglist)
    caveats.empty?
  end
  
  private
  
  def function(arglist)
    @var ||= [f.prefix, f.opt_prefix, f.linked_keg].map do |arglist|;Fi[	@[iI"â        var.rmdir
      end
    end
  end
  
  private
  
  # Set permissions for executables and non-executables
  def function(arglist);Fi[	@di.I"y    audit_conflicts
    audit_patches
    audit_text
  end
  
  private
  
  def function(arglist)
    (@var << var);Fi[	@izI"∆        raise("No such formula or keg")
      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "http://") or ((var[(0..7)] == "https://") or (var[(0..5)] == "ftp://")));Fi[	@Xi$I"Â        puts("#{keg.link(mode)} symlinks created")
      end
    end
  end
  
  private
  
  # Allows us to ensure a puts happens before the block exits so that if say,
  # an exception is thrown, its output starts on a new line.;Fi[	@ziI"£        end
      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|;Fi[	@.iUI"≤      var = (var + link_tap_formula(var))
    end
    puts("Tapped #{count} formula")
  end
  
  private
  
  def function(arglist)
    ARGV.first =~ /^(\S+)\/(homebrew-)?(\w+)$/;Fi[	I"&data//homebrew_proj/cmd/update.rb;Ti,I"»      puts("Updated Homebrew from #{master_updater.initial_revision[0, 8]} to #{master_updater.current_revision[0, 8]}.")
      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin;Fi[	@aibI"w      end
    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp;Fi[	@ài0I"†    else
      "#{HOMEBREW_REPOSITORY}/Library/Formula/#{name}.rb"
    end
  end
  
  private
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|;Fi[	@îisI"    else
      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist)
    var = Dir["*"];Fi[	@îiÄI"ö        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "").split(/:/);Fi[	@îiˇI"§    else
      var.is_a?(Symbol) ? (detect_from_symbol(var)) : (detect_from_url(var))
    end
  end
  
  private
  
  def self.detect_from_url(arglist)
    case var;Fi[	@ki≠I"®    ensure
      replace(var)
    end
  end
  
  private
  
  def function(arglist)
    @var ||= named.map { |arglist| var.include?("/") ? (var) : (var.downcase) }.uniq;Fi[	@∂iI"è        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/
  ;Fi[	@ìi`I"ú  
  def function(arglist)
    (prefix / "share")
  end
  
  private
  
  def function(arglist)
    ((prefix.to_s == "/opt/X11") or MacOS::CLT.installed?).!;Fi[	I"%data//homebrew_proj/metafiles.rb;TiI"¥  def function(arglist)
    return false if [".DS_Store", "INSTALL_RECEIPT.json"].include?(var)
    include?(var).!
  end
  
  private
  
  def function(arglist)
    var = var.to_s;Fi[	@™i'I"Œ    return unless external_patches?
    curl(*external_curl_args)
    external_patches.each { |arglist| var.stage! }
  end
  
  private
  
  def function(arglist)
    @var.select { |arglist| var.external? };Fi[	@™ihI"ñ  
  def function(arglist)
    [@var, "-o", @var]
  end
  
  private
  
  # Detect compression type from the downloaded patch.
  def function(arglist);Fi[	@ˆidI"‘  
  def function(arglist)
    @var ||= @var.scan(/\d+|[a-zA-Z]+/).map { |arglist| VersionElement.new(var) }
  end
  
  private
  
  def self._parse(arglist)
    var = Pathname.new(var) unless var.is_a?(Pathname);Fi[	@ˆi®I"ø        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  
  def function(arglist)
    raise("Unknown version scheme #{@scheme} was requested.");Fi[	@°i1I"è          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["paginate_path"];Fi[	@¶i(I"“          var.puts(((var[:header].to_yaml + "---\n") + var[:content]))
        end
      end
    end
    
    private
    
    def self.truncate_post_name(arglist)
      var = var.match(/^(.+)\.(.+)$/).captures;Fi[	@-icI"Ú      # @since 2.2.0
      def function(arglist)
        var.each { |arglist| unsets.update(var => (true)) }
      end
      
      private
      
      # Add the operation to the modifications, either appending or creating a
      # new one.;Fi[	@>i8I"        # @since 3.1.0
        def function(arglist)
          positionally_operable? ? (position.sub(/\.\d/, ".$")) : (position)
        end
        
        private
        
        def function(arglist)
          document.persisted? and document._id_changed?;Fi[	I"-data//mongoid_proj/lib/mongoid/atomic.rb;TinI"ó      ensure
        self.updates_requested = false
      end
    end
    
    private
    
    # Get the atomic paths utility for this document.
    #;Fi[	@Hi"I"π          yield(self) if block_given?
          process_pending
        end
      end
      
      private
      
      # Get the current mass assignment options for this model.
      #;Fi[	@giI"÷            validate_session_hosts(var, var)
            validate_session_uri(var, var)
          end
        end
        
        private
        
        # Validate that the session config has database.
        #;Fi[	@liWI"—          else
            (count > 0) ? (super(0) { |arglist| var.send(var) }) : (0)
          end
        end
        
        private
        
        # Aggregate by the provided field and method.
        #;Fi[	@qilI"÷        # @since 3.0.0
        def function(arglist)
          block_given? ? (super()) : ((aggregates(var)["sum"] or 0))
        end
        
        private
        
        # Get the finalize function.
        #;Fi[	@Åi/I"√      # @since 3.0.0
      def function(arglist)
        query.modify(update, options)
      end
      
      private
      
      # Apply criteria specific options - query, sort, fields.
      #;Fi[	@Üi⁄I"õ      # @since 3.1.0
      def function(arglist)
        "#<Mongoid::Contextual::MapReduce\n  selector: #{criteria.selector.inspect}\n  class:    #{criteria.klass}\n  map:      #{command[:map]}\n  reduce:   #{command[:reduce]}\n  finalize: #{command[:finalize]}\n  out:      #{command[:out].inspect}>\n"
      end
      
      private
      
      # Apply criteria specific options - query, sort, limit.
      #;Fi[	@ãi˘I"¿      # @since 3.0.0
      def function(arglist)
        update_documents(var, entries)
      end
      
      private
      
      # Update the provided documents with the attributes.
      #;Fi[	@éi[I"¿      # @since 3.0.0
      def function(arglist)
        update_documents(var, :update_all)
      end
      
      private
      
      # Checks if any documents exist in the database.
      #;Fi[	I"1data//mongoid_proj/lib/mongoid/contextual.rb;Ti!I"Á    # @since 3.0.0
    def function(arglist)
      @var ||= create_context
    end
    
    private
    
    # Create the context for the queries to execute. Will be memory for
    # embedded documents and mongo for root documents.;Fi[	I"/data//mongoid_proj/lib/mongoid/criteria.rb;Ti≥I"”    # @since 3.1.0
    def function(arglist)
      js_query(Moped::BSON::Code.new(var, var))
    end
    
    private
    
    # Are documents in the query missing, and are we configured to raise an
    # error?;Fi[	@ëi`I"‚        var = mongoize_ids(var)
        var = from_identity_map(var)
        var.empty? ? (var) : ((var + from_database(var)))
      end
      
      private
      
      # Get the finder used to generate the id query.
      #;Fi[	@ói I"˚        @var, @var, @var, @var, @var, @var = var
        @var = load_hash(Origin::Selector, var)
        @var = load_hash(Origin::Options, var)
      end
      
      private
      
      def function(arglist)
        send(var).inject({}) do |arglist|;Fi[	@öi~I"ﬂ      # @since 3.1.0
      def function(arglist)
        first_or(:new, var, &var)
      end
      
      private
      
      # Create a document given the provided method and attributes from the
      # existing selector.;Fi[	@ùiâI"ô          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|;Fi[	@§iîI"        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.
    #;Fi[	@©iI"•        return "#{model_key}/#{id}-#{updated_at.utc.to_s(:number)}"
      end
      "#{model_key}/#{id}"
    end
    
    private
    
    # Returns the logger
    #;Fi[	@µiI"Q        end
        @var, @var = var, var
        super(compose_message(message_key(var), :klass => (var.name), :searched => (searched(var)), :attributes => (var), :total => (total(var)), :missing => (missing(var))))
      end
      
      private
      
      # Get the string to display the document params that were unmatched.
      #;Fi[	@∆iI"B      # @param [ Symbol ] name The method name.
      def function(arglist)
        super(compose_message("invalid_field", :name => (var), :origin => (origin(var, var)), :file => (location(var, var)[0]), :line => (location(var, var)[1])))
      end
      
      private
      
      # Get the origin of the method.
      #;Fi[	@iI"5        @var = summary(var, var)
        @var = resolution(var, var)
        (("\nProblem:\n  #{@problem}" + "\nSummary:\n  #{@summary}") + "\nResolution:\n  #{@resolution}")
      end
      
      private
      
      # Given the key of the specific error and the options hash, translate the
      # message.;Fi[	@L	iêI"Â        var = Criteria.new((delete(:klass) or delete("klass")))
        each_pair { |arglist| var = var.__send__(var, var) }
        var
      end
      
      private
      
      # Mongoize for the klass, key and value.
      #;Fi[	@s	iéI"≠      # @since 2.2.1
      def function(arglist)
        @var ||= false
      end
      
      private
      
      # If the string is a legal object id, convert it.
      #;Fi[	@è	i{I"’      # @since 3.0.2
      def function(arglist)
        type.resizable?
      end
      
      private
      
      # Evaluate the default proc. In some cases we need to instance exec,
      # in others we don't.;Fi[	@í	i/I"»      # @since 2.3.0
      def function(arglist)
        { ::I18n.locale.to_s => (type.mongoize(var)) }
      end
      
      private
      
      # Lookup the value from the provided object.
      #;Fi[	@ó	i´I"‰      # @since 2.1.0
      def function(arglist)
        @var ||= options[:versioned].nil? ? (true) : (options[:versioned])
      end
      
      private
      
      # Get the name of the default method for this field.
      #;Fi[	@ö	iI"Í        def function(arglist)
          validate_name(var, var)
          validate_options(var, var, var)
        end
        
        private
        
        # Determine if the field name is allowed, if not raise an error.
        #;Fi[	@¬iwI"º    # @since 2.2.0
    def function(arglist)
      documents_for(var.class)[var] = var
    end
    
    private
    
    # Get the documents in the identity map for a specific class.
    #;Fi[	@®	iI"Ÿ        def function(arglist)
          validate_spec(var, var, var)
          validate_options(var, var, var)
        end
        
        private
        
        # Validates the options of the index spec.
        #;Fi[	@±	iXI"
      def function(arglist)
        Validators::Options.validate(self, var, (var or {}))
        index_options[normalize_spec(var)] = normalize_index_options(var)
      end
      
      private
      
      # Normalize the index options, if any are provided.
      #;Fi[	@¥	iI"Ï      var = []
      var.concat(inspect_fields).concat(inspect_dynamic_fields)
      "#<#{self.class.name} _id: #{id}, #{(inspection * ", ")}>"
    end
    
    private
    
    # Get an array of inspected fields for the document.
    #;Fi[	I"/data//mongoid_proj/lib/mongoid/loggable.rb;Ti#I"ë    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    
    # Gets the default Mongoid logger - stdout.
    #;Fi[	@‡	i8I"             Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      
      # Extract the attribute from the key, being smarter about dot notation.
      #;Fi[	I"/data//mongoid_proj/lib/mongoid/paranoia.rb;TiaI"˚    # Returns a string representing the documents's key suitable for use in URLs.
    def function(arglist)
      new_record? ? (nil) : (to_key.join("-"))
    end
    
    private
    
    # Get the collection to be used for paranoid operations.
    #;Fi[	@ 
iI"∂            execute("$inc")
            document[field]
          end
        end
        
        private
        
        # In case we need to cast going to the database.
        #;Fi[	@
iVI"¿          var = yield(document)
          Threaded.clear_options!
          var
        end
        
        private
        
        # In case we need to cast going to the database.
        #;Fi[	@ë
iWI"	      # @since 2.0.0.rc.1
      def function(arglist)
        instance_variable_set("@#{name}", var)
      end
      
      private
      
      # Get the relation. Extracted out from the getter method to avoid
      # infinite recursion when overriding the getter.;Fi[	@ù
i&I"‹      # @since 3.0.0
      def function(arglist)
        _binding { |arglist| yield(self) if block_given? } unless _binding?
      end
      
      private
      
      # Check if the inverse is properly defined.
      #;Fi[	@i7I"Ω            end
            @var = var
            @var = var
          end
          
          private
          
          # Can the existing relation potentially be deleted?
          #;Fi[	@
i;I"˝            @var = var
            @var = var
            @var = @var.delete(:_destroy)
          end
          
          private
          
          # Is the id in the attribtues acceptable for allowing an update to
          # the existing relation?;Fi[	@ciAI"M        def function(arglist)
          embeds_one(cyclic_child_name(false), var.merge(:class_name => (self.name), :cyclic => (true)))
          embedded_in(cyclic_parent_name, :class_name => (self.name), :cyclic => (true))
        end
        
        private
        
        # Determines the parent name given the class.
        #;Fi[	@hiTI"Œ            var = execute_batch_insert(var, "$set")
            add_atomic_sets(var)
          end
        end
        
        private
        
        # Add the atomic sets to the base document.
        #;Fi[	@oi⁄I"        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var)
        end
        
        private
        
        # Create the metadata for the relation.
        #;Fi[	@vi≥I"Õ      # @since 2.4.0
      def function(arglist)
        criteria.unscoped
      end
      
      private
      
      # Find the first object given the supplied attributes or create/initialize it.
      #;Fi[	@|i=I"√      # @since 3.1.0
      def function(arglist)
        { :_type => ({ "$in" => (klass._types) }) }
      end
      
      private
      
      # Returns the class name for the relation.
      #;Fi[	@ñilI"Ã            synced_save(var)
            synced_destroy(var)
          end
        end
        
        private
        
        # Set up the sync of inverse keys that needs to happen on a save.
        #;Fi[	@õi©I"ø        # @since 2.1.0
        def function(arglist)
          entries.uniq
        end
        
        private
        
        def function(arglist)
          entries.send(var, *var, &var);Fi[	@™i I"      run_callbacks(:find) unless _find_callbacks.empty?
      run_callbacks(:initialize) unless _initialize_callbacks.empty?
      self
    end
    
    private
    
    # Reload the document, determining if it's embedded or not and what
    # behaviour to use.;Fi[	@≠iÀI"Ã        ensure
          Threaded.exit_execution("without_default_scope")
        end
      end
      
      private
      
      # Warns or raises exception if overriding another scope or method.
      #;Fi[	@¥i&I"ß      end
      serialize_relations(var, var) if var[:include]
      var
    end
    
    private
    
    # Get the names of all fields that will be serialized.
    #;Fi[	@∑i.I"≈      # @since 3.0.0
      def function(arglist)
        create_session(Mongoid.sessions[:default])
      end
      
      private
      
      # Create the session for the provided config.
      #;Fi[	@ΩiI"          if (var.is_a?(::Hash).! or valid_keys?(var).!) then
            raise(Errors::InvalidStorageOptions.new(var, var))
          end
        end
        
        private
        
        # Determine if all keys in the options hash are valid.
        #;Fi[	@Èi#I"ÿ            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      
      # Returns true if the relation is blank or the foreign key is blank.
      #;Fi[	@Òi.I"ó            validate_root(var, var, var)
          end
        end
      end
      
      private
      
      # Add the error to the document.
      #;Fi[	@Ùi–I"√          end
        end
        super
      end
      
      private
      
      # Adds an associated validator for the relation if the validate option
      # was not provided or set to true.;Fi[	@˜igI"      var = yield(self) if block_given?
      @var = false
      (var or self)
    end
    
    private
    
    # Find the previous version of this document in the database, or if the
    # document had been saved without versioning return the persisted one.;Fi[	@	i{I"    # @param [ Application ] app The rails application.
    def function(arglist)
      load_models(var) if ::Mongoid.preload_models
    end
    
    private
    
    # I don't want to mock out kernel for unit testing purposes, so added this
    # method as a convenience.;Fi[	@iäI"ß      
      def function(arglist)
        var.accept(self)
      end
      
      private
      
      def function(arglist)
        unless (var.value.size == 4) then;Fi[	@CisI"ö          end
          insert(var, &var)
        end
      end
      
      private
      
      ###
      # Insert +node+ as a child of the current Node;Fi[	@Ki€I"¡      def function(arglist)
        raise("JRuby only method") unless Nokogiri.jruby?
        return toJavaDocument
      end
      
      private
      
      def function(arglist)
        "/";Fi[	@NiYI"∞        def function(arglist)
          self.new(XML::Document.new, var)
        end
      end
      
      private
      
      # fix for issue 770
      def function(arglist);Fi[	@ci2I"          var = var.is_a?(XML::Node) ? (var) : (var)
          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist)
        var = (var == :next) ? (:add_next_sibling_node) : (:add_previous_sibling_node);Fi[	@ÇiXI"œ          var = ParserContext.memory(var)
          yield(var) if block_given?
          var.parse_with(self)
        end
        
        private
        
        def function(arglist)
          var.upcase!;Fi[	@(i1I"ı    def function(arglist)
      var = :"#{name}_#{var}"
      instance.send(var) if instance.respond_to?(var)
    end
    
    private
    
    def function(arglist)
      @var[:path].respond_to?(:call) ? (@var[:path].call(self)) : (@var[:path]);Fi[	I"<data//paperclip_proj/paperclip/content_type_detector.rb;TiI"ï          end
        end
      end).to_s
    end
    
    private
    
    def function(arglist)
      File.exists?(@var) and (File.size(@var) == 0);Fi[	I"Idata//paperclip_proj/paperclip/file_command_content_type_detector.rb;TiI"Ö    
    def function(arglist)
      type_from_file_command
    end
    
    private
    
    def function(arglist)
      var = begin;Fi[	@3i|I"ë      else
        scale_to(var)
      end
    end
    
    private
    
    def function(arglist)
      if (var.horizontal? or var.square?) then;Fi[	@6iI"⁄    def function(arglist)
      var = GeometryParser.new(geometry_string.strip).make
      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin;Fi[	I">data//paperclip_proj/paperclip/geometry_parser_factory.rb;TiI"Ó      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist)
      if var = (@var and @var.match(FORMAT)) then;Fi[	I"Cdata//paperclip_proj/paperclip/io_adapters/abstract_adapter.rb;TiI"     
    def function(arglist)
      @var = var.gsub(OS_RESTRICTED_CHARACTERS, "_")
    end
    
    private
    
    def function(arglist)
      @var ||= TempfileFactory.new.generate(original_filename);Fi[	I"Edata//paperclip_proj/paperclip/io_adapters/attachment_adapter.rb;TiI"ï        # do nothing
      end
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename;Fi[	I"?data//paperclip_proj/paperclip/io_adapters/file_adapter.rb;Ti
I"…    def function(arglist)
      @var = var
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename if @var.respond_to?(:original_filename);Fi[	I"Hdata//paperclip_proj/paperclip/io_adapters/uploaded_file_adapter.rb;TiI"û    
    class << self
      attr_accessor(:content_type_detector)
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename;Fi[	@‚iBI"ø    module CommandRecorder
      def function(arglist)
        record(:add_attachment, var)
      end
      
      private
      
      def function(arglist)
        [:remove_attachment, var];Fi[	@Ëi}I"Â          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        if @var[:fog_host].respond_to?(:call) then;Fi[	@Îi˙I"√          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist)
        case var;Fi[	@niI"˚    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var)
    end
    
    private
    
    # This method is all over the place.
    def function(arglist);Fi[	@ i#I".        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator")
        end
      end
      
      private
      
      def function(arglist)
        if var = var[:in] then;Fi[	@iíI"Ê        # Test if this record is in a list
        def function(arglist)
          send(position_column).nil?.!
        end
        
        private
        
        def function(arglist)
          increment_positions_on_all_items;Fi[	@•i2I"#      return false if ((var - Time.now.to_i).abs > OpenID::Nonce.skew)
      @var.write(nonce_key(var, var), var, :expires_in => (OpenID::Nonce.skew))
      return true
    end
    
    private
    
    def function(arglist)
      "openid_association_#{digest(server_url)}_#{digest(handle)}";Fi[	I"Tdata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication.rb;TimI"©    else
      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist)
    (params[:openid_identifier] or params[:openid_url]);Fi[	@®iMI"ﬁ      var = OpenID::Nonce.mk_nonce(3600)
      assert_nonce(var, false, var, "Old nonce #{old_nonce.inspect} passed")
    end
  end
  
  private
  
  def function(arglist)
    var = OpenID::CryptUtil.random_string(20, nil);Fi[	@LiÎI"∞    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@OiÙI"∞    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@Ri⁄I"∞    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@”iI"       def function(arglist)
        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var)
      end
      
      private
      
      def function(arglist)
        var = var.dup;Fi[	@”iI"∫    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!(var)
    end
    
    private
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup;Fi[	@UiI"Å    else
      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var;Fi[	@xiàI"*    clean_html(var) if filter_html
    var.strip!
    var
  end
  
  private
  
  TEXTILE_TAGS = [[128, 8364], [129, 0], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [141, 0], [142, 0], [143, 0], [144, 0], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [157, 0], [158, 0], [159, 376]].collect! do |arglist|
    [var.chr, ((var.zero? and "") or "&#{b};")];Fi[	@}iII"„        var.sort! { |arglist| (var.event_datetime <=> var.event_datetime) }
        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist)
        @@var[var];Fi[	@Öi	I"ï  module FinderMethods
    def function(arglist)
      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin;Fi[	@™i2I"4        var = { :top => (var), :zoom => (var), :subject_width => (var), :g_width => (var), :indent => 0, :indent_increment => 5, :top_increment => 5, :format => :pdf, :pdf => (var) }
        render(var)
        var.Output
      end
      
      private
      
      def function(arglist)
        var ||= @var;Fi[	@≥iI"Æ      
      def function(arglist)
        (@var or load_available_criteria)
      end
      
      private
      
      def function(arglist)
        unless @var.empty? then;Fi[	@æiLI"3            logger.error("scm: filesystem: error: #{err.message}")
            raise(CommandFailed.new(var.message))
          end
        end
        
        private
        
        # AbstractAdapter::target is implicitly made to quote paths.
        # Here we do not shell-out, so we do not want quotes.;Fi[	@ÖiGI"ß      
      def function(arglist)
        "/themes/#{dir}/javascripts/#{source}"
      end
      
      private
      
      def function(arglist)
        if var then;Fi[	@ÖiTI"Ô          Dir.glob("#{path}/#{dir}/*").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    
    def self.scan_themes(arglist)
      var = Dir.glob("#{Rails.public_path}/themes/*").select do |arglist|;Fi[	@Ái\I"õ          var = [var.strip, var.strip, var.strip]
          var.each { |arglist| smooth_offtags_without_code_highlighting(var) }
          var
        end
        
        private
        
        # Patch for RedCloth.  Fixed in RedCloth r128 but _why hasn't released it yet.
        # <a href="http://code.whytheluckystiff.net/redcloth/changeset/128">http://code.whytheluckystiff.net/redcloth/changeset/128</a>;Fi[	@i'I"ƒ          end
          var.attributes["transform"] = "translate(#{x_offset} #{y_offset})"
        end
      end
      
      private
      
      def function(arglist)
        if (var < var) then;Fi[	@iÜI"∫      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end
      
      private
      
      def function(arglist)
        var = [@var[0][-1], @var[1].max].max;Fi[	@iYI"∆      
      def function(arglist)
        get_x_values.collect { |arglist| Time.at(var).strftime(x_label_format) }
      end
      
      private
      
      def function(arglist)
        var = [];Fi[	@?iAI"x      end
    end
    false
  end
  
  private
  
  def self.check_next_sequence(arglist)
    var = var.get_byte[0];Fi[	@ûiüI"C  # is O(N) for the keyspace, so be careful - this can be slow for big databases.
  def function(arglist)
    redis.keys("*").map { |arglist| var.sub("#{redis.namespace}:", "") }
  end
  
  private
  
  # Register a new proc as a hook. If the block is nil this is the
  # equivalent of removing all hooks of the given name.;Fi[	@fi{I"Ä        @var = var
        @var = var
        @var = caller
      end
      
      private
      
      include(Matchers)
      ;Fi[	@{iI"Ø        
        def function(arglist)
          shared_example_groups.length
        end
        
        private
        
        def function(arglist)
          @var ||= [];Fi[	@Yi+I"	      
      [:==, :<, :<=, :>=, :>, :===].each do |arglist|
        define_method(var) { |arglist| BeComparedTo.new(var, var) }
      end
      
      private
      
      def function(arglist)
        @var.empty? ? ("") : (parenthesize(inspected_args.join(", ")));Fi[	@Yi{I"Õ      
      def function(arglist)
        "#{prefix_to_sentence}#{expected_to_sentence}#{args_to_sentence}"
      end
      
      private
      
      def function(arglist)
        "#{@expected}?".to_sym;Fi[	@πiI"	    def self.generated_description(arglist)
      return nil if last_should.nil?
      "#{last_should.to_s.gsub("_", " ")} #{last_description}"
    end
    
    private
    
    def self.last_description(arglist)
      if last_matcher.respond_to?(:description) then;Fi[	@ºiI"æ      
      def function(arglist)
        "have key #{@args[0].inspect}"
      end
      
      private
      
      def function(arglist)
        "#{sym.to_s.sub("have_", "has_")}?".to_sym;Fi[	@øiEI"†      
      def function(arglist)
        (@var.respond_to?(var) or super)
      end
      
      private
      
      def function(arglist)
        @var = var;Fi[	I"2data//rspec_proj/spec/matchers/match_array.rb;Ti'I"‰      
      def function(arglist)
        "contain exactly #{_pretty_print(@expected)}"
      end
      
      private
      
      def function(arglist)
        var.all? { |arglist| var.respond_to?(:<=>) } ? (var.sort) : (var);Fi[	@«iZI"™            self
          end
        end
      end
      
      private
      
      # :nodoc:
      # Our home-grown instance_exec in ruby 1.8.6 results in any methods;Fi[	@biGI"ú      
      def function(arglist)
        "raise #{expected_exception}"
      end
      
      private
      
      def function(arglist)
        case @var;Fi[	@ui8I"       
      def function(arglist)
        "throw #{expected}"
      end
      
      private
      
      def function(arglist)
        @var.nil? ? ("a Symbol") : ("#{@expected_symbol.inspect}#{args}");Fi[	@”i0I"€      
      def function(arglist)
        __raise("#{intro} yielded |#{arg_list(*args_to_yield)}| to block with arity of #{arity}")
      end
      
      private
      
      def function(arglist)
        if @var then;Fi[	@ﬁiWI"¶      #:nodoc:
      def function(arglist)
        __mock_proxy.reset
      end
      
      private
      
      def function(arglist)
        if Mock.===(self) then;Fi[	@„i'I"Œ      
      def function(arglist)
        inspect.gsub("<", "[").gsub(">", "]")
      end
      
      private
      
      def function(arglist)
        __mock_proxy.record_message_received(var, var, var);Fi[	@ÈiçI"“      
      def function(arglist)
        @var.find { |arglist| var.matches(var, var) }
      end
      
      private
      
      def function(arglist)
        $rspec_mocks.add(@var) unless $rspec_mocks.nil?;Fi[	@ÙiI"∂      def function(arglist)
        mocks.each { |arglist| var.rspec_reset }
        mocks.clear
      end
      
      private
      
      def function(arglist)
        @var ||= [];Fi[	@ißI"•      
      def function(arglist)
        @var ||= false
      end
      
      private
      
      def function(arglist)
        var, var = args_and_options(*var);Fi[	@CiI"’          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing;Fi[	@timI"ƒ        def function(arglist)
          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist)
        @var.formatters;Fi[	@—i&I"a        var["rack.errors"] = var
        [500, { "Content-Type" => (var), "Content-Length" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist)
      (Request.new(var).preferred_type("text/plain", "text/html") == "text/html").! and [/curl/].index { |arglist| var.=~(var["HTTP_USER_AGENT"]) };Fi[	@”i{I"»  
  def function(arglist)
    puts("\n#{@option_parser}\n")
  end
  
  private
  
  def function(arglist)
    $APP_CONFIG = OpenStruct.new(YAML.load_file(File.expand_path("~/.siriproxy/config.yml")));Fi[	I"?data//state_machine_proj/state_machine/event_collection.rb;TiÄI"ï        end
      end)
      var
    end
    
    private
    
    def function(arglist)
      var and var[:on] ? ([fetch(var.delete(:on))]) : (self);Fi[	@§içI"Z        # requirements in these callbacks.  You may only define event requirements.
        def function(arglist)
          add_transition_callback(:after_failure, *var, &var)
        end
        
        private
        
        # Adds the transition callback to a specific machine or all of the
        # state machines for each observed class.;Fi[	@ÕiWI"Ï    #   state
    def function(arglist)
      empty?.! and @var ? ((to_name == @var)) : (transitions.empty?)
    end
    
    private
    
    # Calculates the number of times the given state has been walked to
    def function(arglist);Fi[	@“iFI"È    #   paths.events  # => [:park, :ignite, :shift_up, ...]
    def function(arglist)
      map { |arglist| var.events }.flatten.uniq
    end
    
    private
    
    # Gets the initial set of paths to walk
    def function(arglist);Fi[	@’iÂI"    def function(arglist)
      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "#<#{self.class} #{(attributes.map { |attr, value| "#{attr}=#{value.inspect}" } * " ")}>"
    end
    
    private
    
    attr_reader :function
    ;Fi[	I"?data//state_machine_proj/state_machine/state_collection.rb;TihI"±      var.uniq!
      var.map! { |arglist| self[var] }
      var
    end
    
    private
    
    # Gets the value for the given attribute on the node
    def function(arglist);Fi[	@„i+I"T      "#<#{self.class} #{(["attribute", "event", "from", "from_name", "to", "to_name"].map do |attr|
        "#{attr}=#{send(attr).inspect}"
      end * " ")}>"
    end
    
    private
    
    # Runs a block that may get paused.  If the block doesn't pause, then
    # execution will continue as normal.  If the block gets paused, then it;Fi[	@ÿi∂I":  class AttributeTransitionCollection < TransitionCollection
    def function(arglist)
      super(var, { :transaction => (false), :actions => (false) }.merge(var))
    end
    
    private
    
    # Hooks into running transition callbacks so that event / event transition
    # attributes can be properly updated;Fi[	@ˇiI"Ã            end
            owner.transition(var)
          end
        end
        
        private
        
        # Extracts the statement requirement from the given node
        def function(arglist);Fi[	@!i˝I",      #     Twitter.list_remove_members(7505382, 8863586, [813286, 18755393])
      def function(arglist)
        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String];Fi[	@$ipI"ò      #   Twitter.place_create(:name => "@sferik's Apartment", :token => "22ff5b1f7159032cf69218c4d8bb78bc", :contained_within => "41bcb736f84a799e", :lat => "37.783699", :long => "-122.393581")
      def function(arglist)
        object_from_response(Twitter::Place, :post, "/1.1/geo/place.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String];Fi[	@5i•I"      #   Twitter.retweets_of_me
      def function(arglist)
        objects_from_response(Twitter::Tweet, :get, "/1.1/statuses/retweets_of_me.json", var)
      end
      
      private
      
      # @param collection [Array]
      # @param max_id [Integer, NilClass];Fi[	@;i˚I"        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String];Fi[	I")data//twitter_proj/twitter/client.rb;TiZI"ù    # Perform an HTTP PUT request
    def function(arglist)
      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin;Fi[	I",data//twitter_proj/twitter/creatable.rb;TiI"æ    # @return [Time]
    def function(arglist)
      @var ||= Time.parse(@var[:created_at]) if created?
    end
    
    private
    
    def function(arglist)
      @var[:created_at].nil?.!;Fi[	@RiI"Ï    class ClientError < Twitter::Error
      def self.from_response(arglist)
        new(parse_error(var[:body]), var[:response_headers])
      end
      
      private
      
      def self.parse_error(arglist)
        if var.nil? then;Fi[	@iiI"É          end
        end
        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var;Fi[	@ÌiêI"ä    
    def function(arglist)
      @var[:user].nil?.!
    end
    
    private
    
    # @param klass [Class]
    # @param key [Symbol];Fi[	@ÁieI"í    
    def function(arglist)
      @var[:status].nil?.!
    end
    
    private
    
    def function(arglist)
      var.sub(/^https/i, "http");Fi[	@ài8I"¡    
    def function(arglist)
      [environment_variables, cron_jobs].compact.join
    end
    
    private
    
    #
    # Takes a string like: "variable1=something&variable2=somethingelse";Fi[I" ;FI"private;FI" ;FI"def function(arglist);Fi[[	@i6I"I        var.each { |arglist| send("_define_#{type}_model_callback", self, var) }
      end
    end
    
    private
    
    def function(arglist)
      var.class_eval("        def self.before_#{callback}(*args, &block)\n          set_callback(:#{callback}, :before, *args, &block)\n        end\n", "(string)", (126 + 1))
    end;Fi[	@ibI"      var = { :default => (var), :model => (@var.class.model_name.human), :attribute => (@var.class.human_attribute_name(var)), :value => (var) }.merge!(var)
      I18n.translate(var, var)
    end
    
    private
    
    def function(arglist)
      var ||= :invalid
      case var;Fi[	@9iXI"S        assert(model.respond_to?(:errors), "The model should respond to errors")
        assert(model.errors[:hello].is_a?(Array), "errors#[] should return an Array")
      end
      
      private
      
      def function(arglist)
        assert(@var.respond_to?(:to_model), "The object should respond_to to_model")
        @var.to_model;Fi[	@i¨I"      var = { :scope => ([@var.i18n_scope, :models]), :count => 1, :default => (var) }.merge!(var.except(:default))
      I18n.translate(var.shift, var)
    end
    
    private
    
    def function(arglist)
      ActiveSupport::Inflector.underscore(var).tr("/", var)
    end;Fi[	@KibI"§            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	@YiI"Ã          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist)
        var = if delimiter.respond_to?(:call) then
          delimiter.call(var);Fi[	@biI"ˆ        check_options_validity(options, :with)
        check_options_validity(options, :without)
      end
      
      private
      
      def function(arglist)
        var = options[var]
        var.respond_to?(:call) ? (var.call(var)) : (var);Fi[	@ûi7I"Â          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist)
        (if options[:tokenizer] and var.kind_of?(String) then
          options[:tokenizer].call(var);Fi[	@iQI"{      @var = var
      super
    end
    
    private
    
    def function(arglist)
      @var.call(var, var, var)
    end;Fi[	@xiEI"=        writer_method(var, var, var, var, var)
        create_reflection(:composed_of, var, nil, var, self)
      end
      
      private
      
      def function(arglist)
        define_method(var) do |arglist|
          if @var[var].nil? and (var.! or var.any? { |arglist| read_attribute(var.first).nil?.! }) then;Fi[	@i&I"ƒ          end
        end
      end
      
      private
      
      def function(arglist)
        return 0 if Arel::Table.===(table_joins)
        var = connection.quote_table_name(var).downcase;Fi[	@}iéI"        var.each { |arglist| instance_variable_set(var, var) }
        @var = @var.class.reflect_on_association(var)
      end
      
      private
      
      def function(arglist)
        loaded?.! and ((owner.new_record?.! or foreign_key_present?) and klass)
      end;Fi[	@ÇiI"        var.merge!(eval_scope(klass, reflection.scope)) if reflection.scope
        add_constraints(var)
      end
      
      private
      
      def function(arglist)
        var = alias_tracker.connection.schema_cache.columns_hash[var]
        var[var];Fi[	@ÖiI"•      end
      
      attr_reader :function
      
      private
      
      def function(arglist)
        loaded?.! and (foreign_key_present? and klass)
      end;Fi[	@àiI"Ú        var = owner[reflection.foreign_type]
        var.presence and var.constantize
      end
      
      private
      
      def function(arglist)
        super
        owner[reflection.foreign_type] = (var and var.class.base_class.name);Fi[	@ãi(I"Â      def function(arglist)
        owner.new_record? and foreign_key_present?.!
      end
      
      private
      
      def function(arglist)
        if options[:counter_sql] then
          interpolate(options[:counter_sql]);Fi[	@óiI"|        end
        var
      end
      
      private
      
      def function(arglist)
        load_target.size
      end;Fi[	@ùi<I"≠        update_counter(1)
        var
      end
      
      private
      
      def function(arglist)
        @var ||= owner.association(through_reflection.name)
      end;Fi[	@•iI"—        create_through_record(var)
        self.target = var
      end
      
      private
      
      def function(arglist)
        ensure_not_nested
        var = owner.association(through_reflection.name);Fi[	@¿iI"¶      def function(arglist)
        Arel::InnerJoin
      end
      
      private
      
      def function(arglist)
        var = []
        chain.each do |arglist|;Fi[	@√iEI"≈        def function(arglist)
          reflection.options
        end
        
        private
        
        def function(arglist)
          var = owners_by_key
          var = var.keys.compact;Fi[	@„iI"˝        def function(arglist)
          reflection.active_record_primary_key
        end
        
        private
        
        def function(arglist)
          super.order((preload_scope.values[:order] or reflection_scope.values[:order]))
        end;Fi[	@ÚiI"Â            var.compact!
          end
        end
        
        private
        
        def function(arglist)
          Preloader.new(owners, through_reflection.name, through_scope).run
          Hash[owners.map do |arglist|;Fi[	@˜iDI"–      def function(arglist)
        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var
        when Hash then;Fi[	@¸i$I"ª        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist)
        scope.scope_for_create.stringify_keys.except(klass.primary_key)
      end;Fi[	@i%I"ñ    end
    
    (alias :attributes= :assign_attributes)
    
    private
    
    def function(arglist)
      begin
        public_send("#{k}=", var);Fi[	@ixI"           (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist)
        if object.class.send(:create_time_zone_conversion_attribute?, name, column) then
          Time.zone.local(*var);Fi[	@i<I"Y          var = var.unpack("h*").first
          generated_attribute_methods.module_eval("            def __temp__#{safe_name}\n              read_attribute(AttrNames::ATTR_#{safe_name}) { |n| missing_attribute(n, caller) }\n            end\n            alias_method #{name.inspect}, :__temp__#{safe_name}\n            undef_method :__temp__#{safe_name}\n", "(string)", (59 + 1))
        end
        
        private
        
        def function(arglist)
          if (attribute_types_cached_by_default == ATTRIBUTE_TYPES_CACHED_BY_DEFAULT) then
            serialized_attributes.include?(var.name).!;Fi[	@i]I"Ç          end
        end)
      end
      
      private
      
      def function(arglist)
        read_attribute(var)
      end;Fi[	@"i-I"            super
          end
        end
        
        private
        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end;Fi[	@"i4I"          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist)
        var.change(:usec => 0) if var
      end;Fi[	@(iGI"Ã            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist)
          @var.synchronize(&var)
        end;Fi[	@(i¬I"ö          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist)
        @var[Process.pid]
      end;Fi[	@6iI"Ê        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist)
        base.add_column_options!(var, var.merge(:column => (self)))
      end;Fi[	@6iI"ÿ      def function(arglist)
        (@var.map { |arglist| var.to_sql } * ", ")
      end
      
      private
      
      def function(arglist)
        var = ColumnDefinition.new(var, var, var)
        (@var << var);Fi[	@9i)I"»      def function(arglist)
        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var
        when BigDecimal then;Fi[	@>ißI"Æ        end
        var.map { |arglist| quote_column_name(var) }
      end
      
      private
      
      def function(arglist)
        TableDefinition.new(self)
      end;Fi[	@Ii/I"        def function(arglist)
          collation and collation.match(/_ci$/).!
        end
        
        private
        
        def function(arglist)
          if adapter.emulate_booleans and var.downcase.index("tinyint(1)") then
            return :boolean;Fi[	@Ii¢I"‘      def function(arglist)
        [remove_column_sql(var, :updated_at), remove_column_sql(var, :created_at)]
      end
      
      private
      
      def function(arglist)
        (version[0] >= 5)
      end;Fi[	@Li(I"            # do nothing
          end
        end
        
        private
        
        def function(arglist)
          var = configurations.fetch(var) { |arglist| connection_url_to_hash(var) }
          raise(AdapterNotSpecified, "#{spec} database is not configured") unless var;Fi[	@QinI"ˆ          (var << build_footer(var.rows.length, var))
          (var.join("\n") + "\n")
        end
        
        private
        
        def function(arglist)
          [].tap do |arglist|
            var.columns.each_with_index do |arglist|;Fi[	@Qi”I"∑      def function(arglist)
        @var.last_id
      end
      
      private
      
      def function(arglist)
        @var = Mysql2::Client.new(@var)
        configure_connection;Fi[	@VisI"ƒ          cache.values.each { |arglist| var[:stmt].close }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[Process.pid]
        end;Fi[	@ViìI"ù          # do nothing
        end
      end
      
      private
      
      def function(arglist)
        var = {}
        log(var, var, var) do |arglist|;Fi[	@àiNI"        @var, @var, @var, @var, @var = var
        prepare_default_proc
      end
      
      private
      
      def function(arglist)
        @var.default_proc = Proc.new { |arglist| var[var] = connection.columns(var) }
        @var.default_proc = Proc.new do |arglist|;Fi[	@çiTI"æ          cache.values.each { |arglist| dealloc(var[:stmt]) }
          cache.clear
        end
        
        private
        
        def function(arglist)
          @var[$$]
        end;Fi[	@ûi∆I"å      end
      var
    end
    
    private
    
    def function(arglist)
      @var ||= (model_class and model_class.primary_key)
    end;Fi[	@ûiÆI"C    def function(arglist)
      ActiveRecord::Base.connection_handler.connection_pool_list.map(&:connection)
    end
    
    private
    
    def function(arglist)
      var = ActiveRecord::FixtureSet.create_fixtures(fixture_path, fixture_table_names, fixture_class_names)
      Hash[var.map { |arglist| [var.name, var] }];Fi[	@´iI"∆      def function(arglist)
        self.class.locking_enabled?
      end
      
      private
      
      def function(arglist)
        var = self.class.locking_column
        var = send(var).to_i;Fi[	@õi(I"∑        raise(var)
      end
    end
    
    private
    
    def function(arglist)
      ActiveRecord::Base.connection_id = var
      ActiveRecord::Base.connection.clear_query_cache;Fi[	@ﬂi}I"      def function(arglist)
        (super or (var.kind_of?(self.class) and ((name == var.name) and (var.options and (active_record == var.active_record)))))
      end
      
      private
      
      def function(arglist)
        name.to_s.camelize
      end;Fi[	@ﬂiJI"Œ      def function(arglist)
        options.key?(:polymorphic)
      end
      
      private
      
      def function(arglist)
        var = name.to_s.camelize
        var = var.singularize if collection?;Fi[	@ﬂiÈI"∫        end
        check_validity_of_inverse!
      end
      
      private
      
      def function(arglist)
        (options[:source_type] or source_reflection.class_name)
      end;Fi[	@éiOI"å        end
      end
    end
    
    private
    
    def function(arglist)
      "#{quoted_table_name}.#{quoted_primary_key} ASC"
    end;Fi[	@ØiµI"‘    def function(arglist)
      pluck(primary_key)
    end
    
    private
    
    def function(arglist)
      (eager_loading? or (includes_values.present? and (var or references_eager_loaded_tables?)))
    end;Fi[	@ÎiAI"»        merge_single_values
        relation
      end
      
      private
      
      def function(arglist)
        relation.where_values = merged_wheres
        relation.bind_values = merged_binds;Fi[	@ÛiÆI"∏      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist)
      var = var.reject { |arglist| var.blank? }
      return [] if var.empty?;Fi[	@®i<I"œ    def function(arglist)
      relation_with(values.slice(*var))
    end
    
    private
    
    def function(arglist)
      var = Relation.new(klass, table, var)
      var.default_scoped = default_scoped;Fi[	@ŸiI"’      var[10] = "..." if (var.size == 11)
      "#<#{self.class.name} [#{entries.join(", ")}]>"
    end
    
    private
    
    def function(arglist)
      var = with_default_scope
      if var.equal?(self) then;Ti[	@≠i4I"À      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist)
      @var ||= (var = @var.map { |arglist| var.dup.freeze }
      @var.map { |arglist| Hash[var.zip(var)] });Fi[	@‚iI"ç      trailer(var)
      var
    end
    
    private
    
    def function(arglist)
      @var = var
      @var = @var.native_database_types;Fi[	@i.I"¥        var[var] = var
      end
    end
    
    private
    
    def function(arglist)
      var = send(var)
      unless var.is_a?(ActiveSupport::HashWithIndifferentAccess) then;Fi[	@iyI"1        var = var.delete_at(1)
        class_for_adapter(var["adapter"]).new(*var).structure_load(var)
      end
      
      private
      
      def function(arglist)
        @var ||= ConnectionAdapters::ConnectionSpecification::Resolver.new(ENV["DATABASE_URL"], {}).spec.config.stringify_keys
      end;Fi[	@$iI"π      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist)
      if self.record_timestamps then
        var = current_time_from_proper_timezone;Fi[	@'i4I"·        set_options_for_callbacks!(var)
        set_callback(:rollback, :after, *var, &var)
      end
      
      private
      
      def function(arglist)
        var = var.last
        if var.is_a?(Hash) and var[:on] then;Fi[	@5i.I"      def function(arglist)
        (var.foreign_key? ? (var.name) : (var.name.singularize.foreign_key)).to_sym
      end
      
      private
      
      def function(arglist)
        unless file_name =~ /^[_a-z0-9]+$/ then
          raise(IllegalMigrationNameError.new(file_name));Fi[	@Ii I"≠        @var = "#{utility(:bzip2)}#{options}"
        @var = ".bz2"
      end
      
      private
      
      def function(arglist)
        " -#{@level}" if @var
      end;Fi[	@Oi I"´        @var = "#{utility(:gzip)}#{options}"
        @var = ".gz"
      end
      
      private
      
      def function(arglist)
        " -#{@level}" if @var
      end;Fi[	@Ri#I"ë        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Lzma is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        (" --best" if @var or " --fast" if @var)
      end;Fi[	@Ui)I"π        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Pbzip2 is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist)
        var = (" --best" if @var or " --fast" if @var)
        var = " -p#{@processors}" if @var;Fi[	@÷iI"w      Logger.warn(Errors::ConfigurationError.new("        [DEPRECATION WARNING]\n        #{self}.defaults is being deprecated.\n        To set pre-configured defaults for #{klass}, use:\n        #{klass}.defaults\n"))
      var.defaults(&var)
    end
    
    private
    
    def function(arglist)
      const_set(var, Module.new { |arglist| extend(Configuration) })
    end;Fi[	@~i+I"µ        end
        @var = var ? ((msg_prefix + var)) : (class_name)
      end
      
      private
      
      def function(arglist)
        @var ||= (class_name + ": ")
      end;Fi[	@œi'I"©      def function(arglist)
        (@var << var)
      end
      
      private
      
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end;Fi[	@˝i∂I"5    def function(arglist)
      Env.new.write($stdout)
    end
    
    private
    
    def function(arglist)
      Bundler.settings[:cache_all] = options[:all] if options.key?("all")
      if Bundler.definition.sources.any? { |arglist| var.is_a?(Source::Rubygems).! } and Bundler.settings[:cache_all].! then;Fi[	@ iI"∞        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist)
      @var.! and (@var.! and (@var.! and (@var.! and @var.!)))
    end;Fi[	@,i&I"û    def function(arglist)
      "#{name} (#{requirement}) #{__platform}"
    end
    
    private
    
    def function(arglist)
      @var.send(*var)
    end;Fi[	@)iAI"é      (var << "!") if source
      (var << "\n")
    end
    
    private
    
    def function(arglist)
      RUBY_VERSION =~ /^1\.8/
    end;Fi[	@
i©I"      var = caller[0].split(":")[(0..1)].join(":")
      raise(GemfileError, "Undefined local variable or method `#{name}' for Gemfile\n        from #{location}")
    end
    
    private
    
    def function(arglist)
      var.keys.each do |arglist|
        next if String.===(var);Fi[	@6iEI"¢    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      "#{base_dir}/specifications/#{full_name}.gemspec"
    end;Fi[	@i'I"ù      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip;Fi[	@iI"≤    def function(arglist)
      GraphVizClient.new(self).run
    end
    
    private
    
    def function(arglist)
      var = _groups.values.to_set.flatten
      while true do;Fi[	@?i{I"•        raise(ArgumentError, "Source must be an index, not #{index.class}")
      end
    end
    
    private
    
    def function(arglist)
      @var[var]
    end;Fi[	@i#I"∆        Bundler.settings[:frozen] = "1" if var
      end
    end
    
    private
    
    def function(arglist)
      @var.map { |arglist| "gem '#{d.name}', '#{d.requirement}'" }.join("\n")
    end;Fi[	@iñI"        Bundler.ui.warn("If you want to overwrite skipped stubs, use --force.")
      end
    end
    
    private
    
    def function(arglist)
      var = Bundler.bin_path
      var = File.read(File.expand_path("../templates/Executable.standalone", "(string)"));Fi[	@LiDI"∞    def function(arglist)
      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end;Fi[	@"i*I"ù    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist)
      @var ||= @var.fetch_spec([@var, @var, @var])
    end;Fi[	@%iVI"µ      def function(arglist)
        "#{name} (#{version})"
      end
      
      private
      
      def function(arglist)
        @var ||= (var = {}
        ALL.each do |arglist|;Fi[	@^iII"ß    def function(arglist)
      (dependencies - development_dependencies)
    end
    
    private
    
    def function(arglist)
      var = ""
      if var.any? then;Fi[	@8iªI"∂        ENV["RUBYOPT"] = var.join(" ")
      end
    end
    
    private
    
    def function(arglist)
      var = Dir["#{cache_path}/*.gem"]
      var = var.delete_if do |arglist|;Fi[	@=igI"¥    def function(arglist)
      ENV["BUNDLE_IGNORE_CONFIG"]
    end
    
    private
    
    def function(arglist)
      var = var.to_s.sub(".", "__").upcase
      "BUNDLE_#{key}";Fi[	@@i"I"Ø    def function(arglist)
      find_gemfile
    end
    
    private
    
    def function(arglist)
      var = ENV["BUNDLE_GEMFILE"]
      return var if var and var.empty?.!;Fi[	@JiüI"÷      def function(arglist)
        "#{base_name}-#{shortref_for_path((cached_revision or revision))}"
      end
      
      private
      
      def function(arglist)
        @var = true
        @var = @var = nil;Fi[	@Xi`I"Ø      def function(arglist)
        name
      end
      
      private
      
      def function(arglist)
        @var ||= Bundler.app_cache.join(app_cache_dirname)
      end;Fi[	@_i}I"˛        var.remotes.each { |arglist| add_remote(var.to_s) }
        true
      end
      
      private
      
      def function(arglist)
        var = @var.map { |arglist| "#{p}/#{spec.file_name}" }
        var = var.find { |arglist| File.exist?(var) };Fi[	@diqI"Ω      end
      SpecSet.new(var)
    end
    
    private
    
    def function(arglist)
      var = @var.find { |arglist| (var.name == "rake") }
      @var ||= ([var] + tsort).compact.uniq;Fi[	@ÇiI"ö    (alias :remove_dir :remove_file)
    
    attr_accessor(:output_buffer)
    
    private
    
    def function(arglist)
      @var.concat(var)
    end;Fi[	@úi1I"Ö    end
    
    attr_reader :function
    
    private
    
    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/
      $2;Fi[	@§i‚I"Ò      var.send(:rules).each { |arglist| (rules << var.dup) }
      self
    end
    
    private
    
    def function(arglist)
      unless var.kind_of?(Symbol) then
        var = ((var.class == Class) ? (var) : (var.class)).name.underscore;Fi[	@πiI"±    def function(arglist)
      ([:new, :create] + [@var[:new]].flatten)
    end
    
    private
    
    def function(arglist)
      var.to_s.underscore.gsub("/", "_")
    end;Fi[	@øizI"¯          end
        end
      end
      
      private
      
      def function(arglist)
        var = @var.map(&:conditions).compact
        if defined? ActiveRecord::Relation and var.any? { |arglist| var.kind_of?(ActiveRecord::Relation) } then;Fi[	@“iWI"π      end
      var
    end
    
    private
    
    def function(arglist)
      var = (var.kind_of?(Hash) ? (var.values.first) : (var)).class
      ((var == Class) or (var == Module));Fi[	@˜i∫I"¨    def function(arglist)
      @var.each { |arglist| var.close unless var[:closed] }
    end
    
    private
    
    def function(arglist)
      options[:logger]
    end;Fi[	@Ji`I"°        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var;Fi[	@OiNI"2          var = "#{to.stream}-capistrano-diff-to"
          [change_or_create_stream(var, var), change_or_create_stream(var, var), scm(:diff, "-v", var, "-V", var, "-a")].join(" && ")
        end
        
        private
        
        def function(arglist)
          repository.split("/")[0]
        end;Fi[	@[iFI"ÿ        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        
        def function(arglist)
          ((var == :head) or var.nil?) ? (nil) : ("-r #{revision}".chomp)
        end;Fi[	@eiPI"Æ            return var
          end
        end
        
        private
        
        def function(arglist)
          case variable(:scm_verbose)
          when nil then;Fi[	@åiDI"          logger.trace("command finished in #{(elapsed * 1000).round}ms")
          var
        end
        
        private
        
        def function(arglist)
          @var ||= (configuration.logger or Capistrano::Logger.new(:output => (STDOUT)))
        end;Fi[	@ñi6I"Î            File.expand_path(configuration[:copy_cache], Dir.pwd)
          end rescue nil
        end
        
        private
        
        def function(arglist)
          copy_repository_to_local_cache
          build(copy_cache);Fi[	@•iI"Ë            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist)
          File.join(shared_path, (configuration[:repository_cache] or "cached-copy"))
        end;Fi[	@™iI"Í        def function(arglist)
          super.check { |arglist| var.remote.writable(repository_cache) }
        end
        
        private
        
        def function(arglist)
          configuration[:repository_cache]
        end;Fi[	@€iJI"ƒ          end
        end
      end
      
      private
      
      def function(arglist)
        if var[:project_name] then
          File.basename(strip_trailing_separator(var[:project_name]));Fi[	@Èi¶I"ı      def function(arglist)
        (relative_assets or (http_images_path == :relative))
      end
      
      private
      
      def function(arglist)
        var = ((var.keys - ATTRIBUTES) - ARRAY_ATTRIBUTES)
        if (var.size == 1) then;Fi[	@èi<I"Ó    var = var.to_s(16).rjust(2, "0")
    Sass::Script::String.new("##{alphastr}#{color.send(:hex_str)[(1..-1)]}".upcase)
  end
  
  private
  
  def function(arglist)
    if (var > 0) then
      var = (var + ((100 - var) * (var / 100.0)));Fi[	@$izI",      var = radial_svg(var, var, var, var)
      inline_image_string(var.gsub(/\s+/, " "), "image/svg+xml")
    end
    
    private
    
    def function(arglist)
      (var.is_a?(ColorStop) or ((var.is_a?(Sass::Script::List) and ColorStop.new(*var.value)) or ColorStop.new(var))) rescue nil
    end;Fi[	@£i!I"¶    var = "url('data:#{mime_type};base64,#{data}')"
    Sass::Script::String.new(var)
  end
  
  private
  
  def function(arglist)
    return var if var
    case var;Fi[	I"Adata//compass_proj/compass/sass_extensions/functions/math.rb;TiFI"  end
  
  Sass::Script::Functions.declare(:pow, [:number, :exponent])
  
  private
  
  def function(arglist)
    if (var.numerator_units == ["deg"]) and (var.denominator_units == []) then
      Sass::Script::Number.new(Math.send(var, ((Math::PI * var.value) / 180)));Fi[	@8iêI"Â            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist)
          @var ||= Compass::SassExtensions::Functions::ImageSize::ImageProperties.new(file).size
        end;Fi[	@Li+I""        def function(arglist)
          (@var.inject(0) { |arglist| var = (var + var.efficiency) } ** @var.length)
        end
        
        private
        
        def function(arglist)
          var = Compass::SassExtensions::Sprites::ImageRow.new(width)
          var.add(var) if var;Fi[	@WiEI"N        def function(arglist)
          @var.respond_to?(var) ? (@var.send(var, *var, &var)) : (super)
        end
        
        private
        
        def function(arglist)
          @var ||= Compass.configuration.sprite_engine.to_s.scan(/([^_.]+)/).flatten.map do |arglist|
            "#{chunk[0].chr.upcase}#{chunk[(1..-1)]}";Fi[	@Éi´I"§        def function(arglist)
          @var.language
        end
        
        private
        
        def function(arglist)
          (index == 0)
        end;Fi[	@äioI"ã        yield
        @var = nil
      end
      
      private
      
      def function(arglist)
        (@var.failed? or @var)
      end;Fi[	@êi_I"›      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "_").gsub(/\./, "_").gsub(/:/, "_")
      end
      
      private
      
      def function(arglist)
        var = 0
        var.select do |arglist|;Fi[	@ñiMI"®        def function(arglist)
          "row_#{line}"
        end
        
        private
        
        def function(arglist)
          @var.index(self)
        end;Fi[	@ûiÄI"Õ      def function(arglist)
        broadcast(var, var, var)
      end
      
      private
      
      def function(arglist)
        var = extract_method_name_from(caller)
        var.gsub!("visit_", "");Fi[	@§iüI"Ï      def function(arglist)
        @var[:paths].empty? ? (["features"]) : (@var[:paths])
      end
      
      private
      
      def function(arglist)
        if @var[:autoformat] then
          require("cucumber/formatter/pretty");Fi[	@ßi<I"±        Cucumber.logger = @var.log
        @var
      end
      
      private
      
      def function(arglist)
        begin
          (return false unless configuration.drb?;Fi[	@¨iÿI"Ì      attr_reader(:options, :profiles, :expanded_args)
      
      protected(:options, :profiles, :expanded_args)
      
      private
      
      def function(arglist)
        @var[:formats].select { |arglist| var.!=(@var) }
      end;Fi[	@∞i+I"–    def function(arglist)
      @var[:autoload_code_paths]
    end
    
    private
    
    def function(arglist)
      { :autoload_code_paths => (["features/support", "features/step_definitions"]) }
    end;Fi[	@≠i3I"ê      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.arity
    Cucumber::RUBY_1_9 ? (var) : ((var == -1) ? (0) : (var));Fi[	@≤iNI"ã        end
      end
    end
    
    private
    
    def function(arglist)
      var = DEFAULT_ENCODING
      var.each_line do |arglist|;Fi[	@∏iÆI"≠      def function(arglist)
        @var = []
      end
      
      private
      
      def function(arglist)
        var = var.join("_").to_sym
        var = FORMATS[var];Fi[	@ªiI"∑        print(var)
        @var = (@var + 2) if var.to_s =~ /^before/
      end
      
      private
      
      def function(arglist)
        @var.puts("#{indent}#{text}")
      end;Fi[	@ﬁipI"ô        end
        @var = false if @var
      end
      
      private
      
      def function(arglist)
        @var = (@var + var)
        var = @var;Fi[	@ÊiÕI"        @var.print(((" " + format_string("#{prefix}#{padded}", var)) + ::Cucumber::Term::ANSIColor.reset(" |")))
        @var.flush
      end
      
      private
      
      def function(arglist)
        @var.puts if (@var == 6)
        var = var.empty? ? ([var]) : (var.split("\n"));Fi[	@ÈiBI"¨      def function(arglist)
        @var = true
      end
      
      private
      
      def function(arglist)
        print_steps(:pending)
        print_steps(:failed);Fi[	@ÏiHI"…      def function(arglist)
        @var = true if [:failed, :pending, :undefined].index(var)
      end
      
      private
      
      def function(arglist)
        yield if @var
        @var = true;Fi[	@ÚiI"¨      def function(arglist)
        print_summary
      end
      
      private
      
      def function(arglist)
        var = 0
        @var.keys.sort.each do |arglist|;Fi[	@ıiI"2        var = lambda { |arglist| var.steps(var) }
        (dump_count(var.steps.length, "step") + dump_status_counts(var, &var))
      end
      
      private
      
      def function(arglist)
        var = [:failed, :skipped, :undefined, :pending, :passed].map do |arglist|
          var = var.call(var);Fi[	@iùI"ƒ      def function(arglist)
        @var.invoke_steps(var, @var, var)
      end
      
      private
      
      def function(arglist)
        var = @var.features_paths
        if var.empty? then;Fi[	@
iHI"…      def function(arglist)
        invoked_step_definition_hash[StepDefinitionLight.new(var, var)] = nil
      end
      
      private
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@iDI"©      def function(arglist)
        # do nothing
      end
      
      private
      
      def function(arglist)
        var.map do |arglist|
          var = var.cells;Fi[	@i+I"—      def function(arglist)
        @var.step_matches(var, var)
      end
      
      private
      
      def function(arglist)
        var = File.basename(var)[(0...-File.extname(var).length)]
        begin;Fi[	@iÖI"†      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist)
        if @var then
          @var = @var.call;Fi[	@"i!I"√      def function(arglist)
        convert_captures(strip_anchors(@var.source))
      end
      
      private
      
      def function(arglist)
        var.gsub(/(\()(?!\?:)/, "(?:")
      end;Fi[	@2iI"ò        load unless @var
        @var
      end
      
      private
      
      def function(arglist)
        var = Ast::Features.new
        var = {};Fi[	@=iI"º        raise(Ambiguous.new(var, var, guess_step_matches?)) if (var.size > 1)
        var[0]
      end
      
      private
      
      def function(arglist)
        @var.guess?
      end;Fi[	@Bi4I"≈      def function(arglist)
        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin
          Timeout.timeout(var) { |arglist| STDIN.gets };Fi[	@Hi7I"ö      end
      
      extend(self)
      
      private
      
      def function(arglist)
        var = RUBY_VERSION.split(".")
        var.map!(&:to_i);Fi[	@Ki#I"Ï      def function(arglist)
        WireException.new(var, @var.host, @var.port)
      end
      
      private
      
      def function(arglist)
        Timeout.timeout(@var.timeout("connect")) { |arglist| socket.puts(var) }
      end;Fi[	@\iI"¯          end
          
          alias :handle_step_matches :handle_success
          
          private
          
          def function(arglist)
            var = WireStepDefinition.new(@var, var)
            var = var["args"].map do |arglist|;Fi[	@fiI"€        var = var.map { |arglist| prepare(var) }
        @var.invoke(@var, var)
      end
      
      private
      
      def function(arglist)
        return var unless var.is_a?(Cucumber::Ast::Table)
        var.raw;Fi[	@ii‚I"ˇ      def function(arglist)
        Devise.navigational_formats.include?(request_format)
      end
      
      private
      
      def function(arglist)
        Devise.mappings.each do |arglist|
          instance_variable_set("@current_#{m.name}", nil);Fi[	@viI"≥      end
      
      generate_helpers!(Devise::URL_HELPERS)
      
      private
      
      def function(arglist)
        @var ||= send(Devise.available_router_name)
      end;Fi[	@~iOI"$    def self.add_module(arglist)
      class_eval("        def #{m}?\n          self.modules.include?(:#{m})\n        end\n", "(string)", (113 + 1))
    end
    
    private
    
    def function(arglist)
      @var = (var[:failure_app] or Devise::FailureApp)
      if @var.is_a?(String) then;Fi[	@£iI"Ì      def function(arglist)
        self.class.timeout_in
      end
      
      private
      
      def function(arglist)
        return false unless respond_to?(:remember_created_at)
        remember_created_at and remember_expired?.!;Fi[	@ÕiI"º        end
        success!(var) if validate(var)
      end
      
      private
      
      def function(arglist)
        super
        if var.respond_to?(:extend_remember_period=) then;Fi[	@≠iMI"∏  def function(arglist)
    @var = Statistics.new.generate_correlations
  end
  
  private
  
  def function(arglist)
    sprintf("%0.02f", (((var - var) / var.to_f) * 100)).to_f
  end;Fi[	@‚iI"  inflection_method(:grammatical_gender => :gender)
  
  helper_method(:all_aspects, :all_contacts_count, :my_contacts_count, :only_sharing_count, :tag_followings, :tags, :open_publisher)
  
  private
  
  def function(arglist)
    request.env["HTTP_REFERER"] ||= "/"
  end;Fi[	@ÁioI"ë    end
    @var.save
  end
  
  private
  
  def function(arglist)
    @var = Person.find(var)
    if @var = current_user.contact_for(@var) then;Fi[	@«i#I"‚      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist)
    if var = current_user.contact_for(var) then
      current_user.disconnect(var, :force => (true));Fi[	@ iBI"⁄      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist)
    if user_signed_in? then
      @var = current_user.find_visible_shareable_by_id(Post, params[:post_id]);Fi[	@œiI"ù    @var = true
    @var = Person.community_spotlight
  end
  
  private
  
  def function(arglist)
    @var = case params[:set]
    when "only_sharing" then;Fi[	@˙iI"Ê    sign_out(current_user) if user_signed_in?
    redirect_to(new_user_registration_path(:invite => ({ :token => (params[:id]) })))
  end
  
  private
  
  def function(arglist)
    InvitationCode.find_by_token!(params[:id])
  end;Fi[	@€iJI"~      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist)
    User.email_regexp.match(var).present?
  end;Fi[	@Ìi-I"       var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist)
    @var ||= if params[:post_id] then
      (current_user.find_visible_shareable_by_id(Post, params[:post_id]) or raise(ActiveRecord::RecordNotFound.new));Fi[	@Âi©I"x      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.map { |arglist| var.id }
    var = {};Fi[	@Úi}I"∑      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist)
    if request.params[:qqfile].is_a?(String).! then
      var[:qqfile];Fi[	@Úi;I"Â      end
    end
  end
  
  private
  
  def function(arglist)
    unless (@var[:tag_string].nil? or (@var[:tag_string] == I18n.t("profiles.edit.your_tags_placeholder"))) then
      @var[:tag_string].split(" ").each do |arglist|;Fi[	@iLI"    Resque.enqueue(Jobs::ReceiveEncryptedSalmon, @var.id, CGI.unescape(params[:xml]))
    render(:nothing => (true), :status => 202)
  end
  
  private
  
  def function(arglist)
    if params[:xml].nil? then
      render(:nothing => (true), :status => 422);Fi[	@iI"Ω  def function(arglist)
    super
  end
  
  private
  
  def function(arglist)
    return true if AppConfig.settings.enable_registrations?
    return true if invite and invite.can_be_used?;Fi[	@iI"$    var = current_user.toggle_hidden_shareable(accessible_post)
    render(:nothing => (true), :status => 200)
  end
  
  private
  
  def function(arglist)
    @var ||= params[:shareable_type].constantize.where(:id => (params[:post_id])).select("id, guid, author_id, created_at").first
  end;Fi[	@iDI"Õ      end
    end
  end
  
  private
  
  def function(arglist)
    if (params[:status_message][:public] or (params[:status_message][:aspect_ids].first == "all_aspects")) then
      current_user.aspect_ids;Fi[	@"i7I"ﬁ    gon.tagFollowings = tags
    stream_responder(Stream::FollowedTag)
  end
  
  private
  
  def function(arglist)
    @var ||= var.new(current_user, :max_time => (max_time)) if var.present?
    respond_with do |arglist|;Fi[	@(i.I"Ü      end
    end
  end
  
  private
  
  def function(arglist)
    TagFollowing.user_is_following?(current_user, params[:name])
  end;Fi[	@3i#I"v      end
    end
  end
  
  private
  
  def function(arglist)
    return unless configured?(var)
    yield(var);Fi[	@iI"°  def function(arglist)
    var.instance_of?(Reshare)
  end
  
  private
  
  def function(arglist)
    if var.stream_posts.empty? then
      (Time.now + 1).to_i;Fi[	@i I"      var.display_name = var
      var.format
    end
    
    private
    
    def function(arglist)
      var = { :from => (AppConfig.mail.sender_address.get), :host => ("#{AppConfig.pod_uri.host}"), :to => (name_and_address(@var.name, @var.email)) }
      if @var.present? then;Fi[	@tiRI"›  def function(arglist)
    send_notification(:confirm_email, var)
  end
  
  private
  
  def function(arglist)
    @var = NotificationMailers.const_get(var.to_s.camelize).new(*var)
    with_recipient_locale do |arglist|;Fi[	@ÉiTI"∂      end
    end
  end
  
  private
  
  def function(arglist)
    if person_id and person.closed_account? then
      (errors[:base] << "Cannot be in contact with a closed account");Fi[	@çi[I"  def function(arglist)
    var[:plain_text] ? (self.text) : (ERB::Util.h(self.text))
  end
  
  private
  
  def function(arglist)
    if self.parent and self.parent.participants.include?(self.author).! then
      (errors[:base] << "Author is not participating in the conversation");Fi[	@ói?I"∞      self.url = (self.url + "/") if self.url[-1, 1].!=("/")
    end
  end
  
  private
  
  def function(arglist)
    Webfinger.new(self.diaspora_handle).fetch
    self.reload;Fi[	@£iøI"π      @var = nil
    end
  end
  
  private
  
  def function(arglist)
    ((self.attributes.keys - Profile.protected_attributes.to_a) - ["created_at", "updated_at", "person_id"])
  end;Fi[	@0iQI"Ö    end
    var
  end
  
  private
  
  def function(arglist)
    var = Webfinger.new(@var).fetch
    var.save! unless var.persisted?;Fi[	@3i I"¸  def function(arglist)
    client.user(nickname).profile_image_url_https("original")
  end
  
  private
  
  def function(arglist)
    @var ||= Twitter::Client.new(:oauth_token => (self.access_token), :oauth_token_secret => (self.access_secret))
  end;Fi[	@6i!I"Ï      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist)
    if shareable.public? then
      (errors[:base] << "Cannot create visibility for a public object");Fi[	@ªi¬I"W    self.password_confirmation = var
    self.save(:validate => (false))
  end
  
  private
  
  def function(arglist)
    (self.attributes.keys - ["id", "username", "encrypted_password", "created_at", "updated_at", "locked_at", "serialized_private_key", "getting_started", "disable_mail", "show_community_spotlight_in_stream", "email"])
  end;Fi[	@EiçI"        return var if (ENV["TERM"].nil? or (ENV["TERM"].empty? or STDOUT.tty?.!))
        return "[#{COLORS[color]}m#{str}[0m"
      end
      
      private
      
      def function(arglist)
        return if var.nil?
        var = "wb" if @var[:unix_newlines] and (var == "w");Fi[	@LiÁI"t        var
      end
    end
    
    private
    
    def function(arglist)
      self.class.defaults
    end;Fi[	@XiI"ƒ  def function(arglist)
    caveats.empty?
  end
  
  private
  
  def function(arglist)
    @var ||= [f.prefix, f.opt_prefix, f.linked_keg].map do |arglist|
      Keg.new(var.realpath) rescue nil;Fi[	@di/I"k    audit_patches
    audit_text
  end
  
  private
  
  def function(arglist)
    (@var << var)
  end;Fi[	@i{I"§      end
    end
  end
  
  private
  
  def function(arglist)
    ((var[(0..6)] == "http://") or ((var[(0..7)] == "https://") or (var[(0..5)] == "ftp://")))
  end;Fi[	@ziI"Ø      end
    end
  end
  
  private
  
  def function(arglist)
    var = HOMEBREW_PREFIX.children.select { |arglist| var.directory? }.map do |arglist|
      var.basename.to_s;Fi[	@.iVI"¥    end
    puts("Tapped #{count} formula")
  end
  
  private
  
  def function(arglist)
    ARGV.first =~ /^(\S+)\/(homebrew-)?(\w+)$/
    raise("Invalid usage") unless $1 and $3;Fi[	@ai-I"v      var.dump
    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir[".git/*"].empty? then;Fi[	@aicI"s    end
    var
  end
  
  private
  
  def function(arglist)
    `git rev-parse -q --verify HEAD`.chomp
  end;Fi[	@ài1I"Â      "#{HOMEBREW_REPOSITORY}/Library/Formula/#{name}.rb"
    end
  end
  
  private
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      `git rev-list --abbrev-commit HEAD -- Library/Formula/#{name}.rb`.split;Fi[	@îitI"ä      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist)
    var = Dir["*"]
    case var.length;Fi[	@îiÅI"      end
    end
  end
  
  private
  
  def function(arglist)
    var = var.sub(/^cvs:\/\//, "").split(/:/)
    var = var.pop;Fi[	@kiÆI"£      replace(var)
    end
  end
  
  private
  
  def function(arglist)
    @var ||= named.map { |arglist| var.include?("/") ? (var) : (var.downcase) }.uniq
  end;Fi[	@ìiaI"ü  def function(arglist)
    (prefix / "share")
  end
  
  private
  
  def function(arglist)
    ((prefix.to_s == "/opt/X11") or MacOS::CLT.installed?).!
  end;Fi[	@tiI"≥    return false if [".DS_Store", "INSTALL_RECEIPT.json"].include?(var)
    include?(var).!
  end
  
  private
  
  def function(arglist)
    var = var.to_s
    var = var.downcase;Fi[	@™i(I"∞    curl(*external_curl_args)
    external_patches.each { |arglist| var.stage! }
  end
  
  private
  
  def function(arglist)
    @var.select { |arglist| var.external? }
  end;Fi[	@ˆi©I"É      end
    end
  end
  
  private
  
  def function(arglist)
    raise("Unknown version scheme #{@scheme} was requested.")
  end;Fi[	@°i2I"ï        end
      end
    end
    
    private
    
    def function(arglist)
      var = var.config["paginate_path"]
      var.sub(":num", var.to_s);Fi[	@>i9I"˙        def function(arglist)
          positionally_operable? ? (position.sub(/\.\d/, ".$")) : (position)
        end
        
        private
        
        def function(arglist)
          document.persisted? and document._id_changed?
        end;Fi[	@ói!I"„        @var = load_hash(Origin::Selector, var)
        @var = load_hash(Origin::Options, var)
      end
      
      private
      
      def function(arglist)
        send(var).inject({}) do |arglist|
          var[var] = var;Fi[	@ùiäI"†        end
        var
      end
      
      private
      
      def function(arglist)
        var.each do |arglist|
          send(var).reject! do |arglist|;Fi[	@õi™I"¥        def function(arglist)
          entries.uniq
        end
        
        private
        
        def function(arglist)
          entries.send(var, *var, &var)
        end;Fi[	@iãI"      def function(arglist)
        var.accept(self)
      end
      
      private
      
      def function(arglist)
        unless (var.value.size == 4) then
          raise(ArgumentError, "expected an+b node to contain 4 tokens, but is #{node.value.inspect}");Fi[	@=iI"•      alias :to_s :content
      
      alias :content= :value=
      
      private
      
      def function(arglist)
        [:name, :namespace, :value]
      end;Fi[	@Ki‹I"Ø        raise("JRuby only method") unless Nokogiri.jruby?
        return toJavaDocument
      end
      
      private
      
      def function(arglist)
        "/"
      end;Fi[	@]iI"•      include(Nokogiri::XML::PP::Node)
      
      attr_reader(:document)
      
      private
      
      def function(arglist)
        [:prefix, :href]
      end;Fi[	@ci3I"          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist)
        var = (var == :next) ? (:add_next_sibling_node) : (:add_previous_sibling_node)
        var = (var == :next) ? (:reverse_each) : (:each);Fi[	@ÇiYI"           yield(var) if block_given?
          var.parse_with(self)
        end
        
        private
        
        def function(arglist)
          var.upcase!
          unless ENCODINGS[var] then;Fi[	@(i2I"„      var = :"#{name}_#{var}"
      instance.send(var) if instance.respond_to?(var)
    end
    
    private
    
    def function(arglist)
      @var[:path].respond_to?(:call) ? (@var[:path].call(self)) : (@var[:path])
    end;Fi[	@
 iI"è        end
      end).to_s
    end
    
    private
    
    def function(arglist)
      File.exists?(@var) and (File.size(@var) == 0)
    end;Fi[	@ iI"¬    def function(arglist)
      type_from_file_command
    end
    
    private
    
    def function(arglist)
      var = begin
        Paperclip.run("file", "-b --mime :file", :file => (@var));Fi[	@3i}I"Ø        scale_to(var)
      end
    end
    
    private
    
    def function(arglist)
      if (var.horizontal? or var.square?) then
        [("%dx" % var.width), var.width];Fi[	@6iI"Ï      var = GeometryParser.new(geometry_string.strip).make
      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin
        silence_stream(STDERR) do |arglist|;Fi[	@ iI"        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist)
      if var = (@var and @var.match(FORMAT)) then
        @var = var[1];Fi[	@ iI"Õ    def function(arglist)
      @var = var.gsub(OS_RESTRICTED_CHARACTERS, "_")
    end
    
    private
    
    def function(arglist)
      @var ||= TempfileFactory.new.generate(original_filename)
    end;Fi[	@ iI"ü      end
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename
      @var = @var.content_type;Fi[	@ iI"◊      @var = var
      cache_current_values
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename if @var.respond_to?(:original_filename)
      @var ||= File.basename(@var.path);Fi[	I"Cdata//paperclip_proj/paperclip/io_adapters/stringio_adapter.rb;TiI"≈    end
    
    attr_writer(:content_type)
    
    private
    
    def function(arglist)
      @var = @var.original_filename if @var.respond_to?(:original_filename)
      @var ||= "stringio.txt";Fi[	@  iI"Ω    class << self
      attr_accessor(:content_type_detector)
    end
    
    private
    
    def function(arglist)
      @var = @var.original_filename
      @var = determine_content_type;Fi[	I">data//paperclip_proj/paperclip/io_adapters/uri_adapter.rb;TiI"y    end
    
    attr_writer(:content_type)
    
    private
    
    def function(arglist)
      open(@var)
    end;Fi[	@‚iCI"Æ      def function(arglist)
        record(:add_attachment, var)
      end
      
      private
      
      def function(arglist)
        [:remove_attachment, var]
      end;Fi[	@Ëi~I"µ          false
        end
      end
      
      private
      
      def function(arglist)
        if @var[:fog_host].respond_to?(:call) then
          @var[:fog_host].call(self);Fi[	@Îi˚I"Ö          false
        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then;Fi[	@ i$I"          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator")
        end
      end
      
      private
      
      def function(arglist)
        if var = var[:in] then
          if var[:in].respond_to?(:call).! then;Fi[	@iìI"«        def function(arglist)
          send(position_column).nil?.!
        end
        
        private
        
        def function(arglist)
          increment_positions_on_all_items
        end;Fi[	@•i3I"‰      @var.write(nonce_key(var, var), var, :expires_in => (OpenID::Nonce.skew))
      return true
    end
    
    private
    
    def function(arglist)
      "openid_association_#{digest(server_url)}_#{digest(handle)}"
    end;Fi[	@1 inI"¶      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist)
    (params[:openid_identifier] or params[:openid_url])
  end;Fi[	@®iNI"Ù      assert_nonce(var, false, var, "Old nonce #{old_nonce.inspect} passed")
    end
  end
  
  private
  
  def function(arglist)
    var = OpenID::CryptUtil.random_string(20, nil)
    var = OpenID::CryptUtil.random_string(128, ALLOWED_HANDLE);Fi[	@LiÏI"≥      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	@OiıI"≥      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	@Ri€I"≥      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	@”iI"∫        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var)
      end
      
      private
      
      def function(arglist)
        var = var.dup
        var;Fi[	@”iI"ˆ      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!(var)
    end
    
    private
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!((self.class.read_inheritable_attribute(:rfpdf) or {})) do |arglist|;Fi[	@UiI"§      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "")) then;Fi[	@}iJI"°        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist)
        @@var[var]
      end;Fi[	@Öi
I"º    def function(arglist)
      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@™i3I"é        render(var)
        var.Output
      end
      
      private
      
      def function(arglist)
        var ||= @var
        var = {};Fi[	@≥iI"‡      def function(arglist)
        (@var or load_available_criteria)
      end
      
      private
      
      def function(arglist)
        unless @var.empty? then
          var = ["tyear", "tmonth", "tweek", "spent_on"];Fi[	@ÖiHI"„      def function(arglist)
        "/themes/#{dir}/javascripts/#{source}"
      end
      
      private
      
      def function(arglist)
        if var then
          Dir.glob("#{path}/#{dir}/*.#{ext}").collect do |arglist|;Fi[	@i(I"ﬂ          var.attributes["transform"] = "translate(#{x_offset} #{y_offset})"
        end
      end
      
      private
      
      def function(arglist)
        if (var < var) then
          var = partition(var, var, var);Fi[	@iáI"ﬂ      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end
      
      private
      
      def function(arglist)
        var = [@var[0][-1], @var[1].max].max
        var = [@var[0][0], @var[1].min].min;Fi[	@iZI"ﬂ      def function(arglist)
        get_x_values.collect { |arglist| Time.at(var).strftime(x_label_format) }
      end
      
      private
      
      def function(arglist)
        var = []
        var, var, var = x_range;Fi[	@{iI"≤        def function(arglist)
          shared_example_groups.length
        end
        
        private
        
        def function(arglist)
          @var ||= []
        end;Fi[	@Yi,I"      [:==, :<, :<=, :>=, :>, :===].each do |arglist|
        define_method(var) { |arglist| BeComparedTo.new(var, var) }
      end
      
      private
      
      def function(arglist)
        @var.empty? ? ("") : (parenthesize(inspected_args.join(", ")))
      end;Fi[	@Yi|I"–      def function(arglist)
        "#{prefix_to_sentence}#{expected_to_sentence}#{args_to_sentence}"
      end
      
      private
      
      def function(arglist)
        "#{@expected}?".to_sym
      end;Fi[	@ºiI"¡      def function(arglist)
        "have key #{@args[0].inspect}"
      end
      
      private
      
      def function(arglist)
        "#{sym.to_s.sub("have_", "has_")}?".to_sym
      end;Fi[	@øiFI"’      def function(arglist)
        (@var.respond_to?(var) or super)
      end
      
      private
      
      def function(arglist)
        @var = var
        if (var = if defined? ActiveSupport::Inflector then;Fi[	@l i(I"Á      def function(arglist)
        "contain exactly #{_pretty_print(@expected)}"
      end
      
      private
      
      def function(arglist)
        var.all? { |arglist| var.respond_to?(:<=>) } ? (var.sort) : (var)
      end;Fi[	@biHI"´      def function(arglist)
        "raise #{expected_exception}"
      end
      
      private
      
      def function(arglist)
        case @var
        when nil then;Fi[	@oi,I"≤      end
      
      alias :arguments :argument
      
      private
      
      def function(arglist)
        @var.nil? ? (true) : ((@var == var.method(var).arity))
      end;Fi[	@ui9I"Õ      def function(arglist)
        "throw #{expected}"
      end
      
      private
      
      def function(arglist)
        @var.nil? ? ("a Symbol") : ("#{@expected_symbol.inspect}#{args}")
      end;Fi[	@–i‡I"Ë      end
      
      alias_method(:a_kind_of, :kind_of)
      
      private
      
      def function(arglist)
        var = (var.last.class == Hash) ? (var.delete_at(-1)) : ({})
        var.each { |arglist| var[var] = anything };Fi[	@”i1I"      def function(arglist)
        __raise("#{intro} yielded |#{arg_list(*args_to_yield)}| to block with arity of #{arity}")
      end
      
      private
      
      def function(arglist)
        if @var then
          "#{@declared_as} #{@name.inspect}";Fi[	@ﬁiXI"∆      def function(arglist)
        __mock_proxy.reset
      end
      
      private
      
      def function(arglist)
        if Mock.===(self) then
          @var ||= Proxy.new(self, @var, @var);Fi[	@„i(I"’      def function(arglist)
        inspect.gsub("<", "[").gsub(">", "]")
      end
      
      private
      
      def function(arglist)
        __mock_proxy.record_message_received(var, var, var)
        begin;Fi[	@ÈiéI"Ô      def function(arglist)
        @var.find { |arglist| var.matches(var, var) }
      end
      
      private
      
      def function(arglist)
        $rspec_mocks.add(@var) unless $rspec_mocks.nil?
        define_expected_method(var);Fi[	@ÙiI"§        mocks.each { |arglist| var.rspec_reset }
        mocks.clear
      end
      
      private
      
      def function(arglist)
        @var ||= []
      end;Fi[	@i®I"›      def function(arglist)
        @var ||= false
      end
      
      private
      
      def function(arglist)
        var, var = args_and_options(*var)
        [get_type_from_options(var)].flatten.each do |arglist|;Fi[	@CiI"“            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end;Fi[	@tinI"∞          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist)
        @var.formatters
      end;Fi[	@—i'I"H        [500, { "Content-Type" => (var), "Content-Length" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist)
      (Request.new(var).preferred_type("text/plain", "text/html") == "text/html").! and [/curl/].index { |arglist| var.=~(var["HTTP_USER_AGENT"]) }
    end;Fi[	@”i|I"‘  def function(arglist)
    puts("\n#{@option_parser}\n")
  end
  
  private
  
  def function(arglist)
    $APP_CONFIG = OpenStruct.new(YAML.load_file(File.expand_path("~/.siriproxy/config.yml")))
    @var = nil;Fi[	@â iÅI"ë      end)
      var
    end
    
    private
    
    def function(arglist)
      var and var[:on] ? ([fetch(var.delete(:on))]) : (self)
    end;Fi[	@• i[I"∂    def function(arglist)
      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin
        connection.send(var.to_sym, var, var) do |arglist|;Fi[	@® iI"±    def function(arglist)
      @var ||= Time.parse(@var[:created_at]) if created?
    end
    
    private
    
    def function(arglist)
      @var[:created_at].nil?.!
    end;Fi[	@iiI"í        end
        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var
        when /\.jpe?g/i then;Fi[	@ÁifI"ï    def function(arglist)
      @var[:status].nil?.!
    end
    
    private
    
    def function(arglist)
      var.sub(/^https/i, "http")
    end;Fi[I"var;FI"end;FI" ;FI"def function(arglist);Fi”[”[	@Çi%I"      def function(arglist)
        var = alias_tracker.connection.substitute_at(var, var.bind_values.length)
        var.bind_values += [[var, var]]
        var
      end
      
      def function(arglist)
        var = column_for(var, var)
        bind_value(var, var, var);Fi[	@ÇiWI"•            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist)
        reflection.name
      end;Fi[	I"Mdata//activerecord_proj/active_record/associations/builder/belongs_to.rb;TiI"—      var = super
      add_counter_cache_callbacks(var) if options[:counter_cache]
      add_touch_callbacks(var) if options[:touch]
      var
    end
    
    def function(arglist)
      var = var.counter_cache_column
      mixin.class_eval("        def belongs_to_counter_cache_after_create_for_#{name}\n          record = #{name}\n          record.class.increment_counter(:#{cache_column}, record.id) unless record.nil?\n        end\n\n        def belongs_to_counter_cache_before_destroy_for_#{name}\n          unless marked_for_destruction?\n            record = #{name}\n            record.class.decrement_counter(:#{cache_column}, record.id) unless record.nil?\n          end\n        end\n", "(string)", (38 + 1));Fi[	@µiI"®      wrap_block_extension
      var = super
      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end;Fi[	@∫iI"µ    def function(arglist)
      var = super
      define_destroy_hook
      var
    end
    
    def function(arglist)
      super
      [:delete_sql, :insert_sql].each do |arglist|;Fi[	I"Jdata//activerecord_proj/active_record/associations/builder/has_one.rb;TiI"€    def function(arglist)
      var = (super + [:order, :as])
      var = (var + [:through, :source, :source_type]) if options[:through]
      var
    end
    
    def function(arglist)
      options[:through].!
    end;Fi[	@ãiI"›        end
        callback(:after_add, var)
        set_inverse_instance(var)
        var
      end
      
      def function(arglist)
        var = super()
        var.none! if var.fetch(:nullify, true) and null_scope?;Fi[	@ãi"I"Ë      def function(arglist)
        var = super()
        var.none! if var.fetch(:nullify, true) and null_scope?
        var
      end
      
      def function(arglist)
        owner.new_record? and foreign_key_present?.!
      end;Fi[	@ùi,I"Î        if owner.new_record? and var then
          var.flatten.each { |arglist| build_through_record(var) }
        end
        var
      end
      
      def function(arglist)
        ensure_not_nested
        if var.new_record? then;Fi[	@ùihI"”            end
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!
      end;Fi[	@Æi\I"¯            var.from(join(var, var))
            var, var = var, var.klass
          end
          var
        end
        
        def function(arglist)
          var = var[var].eq(var[var])
          if var.klass.finder_needs_type_condition? then;Fi[	@ÆidI"          if var.klass.finder_needs_type_condition? then
            var = var.create_and([var, var.klass.send(:type_condition, var)])
          end
          var
        end
        
        def function(arglist)
          self.join_type = Arel::OuterJoin
          var.joins(self);Fi[	@Ωi;I"≈          var
        end.uniq
        remove_duplicate_results!(active_record, var, @var)
        var
      end
      
      def function(arglist)
        case var
        when Symbol, String then;Fi[	@Ωi∂I"Ù            raise(ConfigurationError, "unknown macro: #{join_part.reflection.macro}")
          end
        end
        var
      end
      
      def function(arglist)
        var = var.association(var.reflection.name)
        var.target = var;Fi[	@¿iI"Ô            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist)
        var.table_name
      end;Fi[	@¿i I"Ù      def function(arglist)
        var = "#{reflection.plural_name}_#{alias_suffix}"
        (var << "_join") if var
        var
      end
      
      def function(arglist)
        var.create_join(var, var.create_on(var), join_type)
      end;Fi[	@√iVI"&            var = var[association_key_name].to_s
            var[var].each { |arglist| (var[var] << var) }
          end
          var
        end
        
        def function(arglist)
          @var ||= if reflection.scope then
            klass.unscoped.instance_exec(nil, &reflection.scope);Fi[	@iZI"        var = var.empty? ? (nil) : (type_cast_attribute_value(var, var))
        var[var][find_parameter_position(var)] ||= var
      end
      var
    end
    
    def function(arglist)
      var =~ /\([0-9]*([if])\)/ ? (var.send(("to_" + $1))) : (var)
    end;Fi[	@i&I"Õ    
    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) }
      var
    end
    
    def function(arglist)
      begin
        (var = send(var, var);Fi[	@(i\I"Œ        var = new_connection
        var.pool = self
        (@var << var)
        var
      end
      
      def function(arglist)
        var.run_callbacks(:checkout) { |arglist| var.verify! }
        var;Fi[	@6iI"    
    class ColumnDefinition < Struct.new(:base, :name, :type, :limit, :precision, :scale, :default, :null)
      def function(arglist)
        var
      end
      
      def function(arglist)
        base.type_to_sql(type.to_sym, limit, precision, scale)
      end;Fi[	@6iI"˜        var = ColumnDefinition.new(var, var, var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        var = columns.detect { |arglist| (var.type == :primary_key) }
        var and var.name;Fi[	@>iùI"i        unless index_name_exists?(var, var, true) then
          raise(ArgumentError, "Index name '#{index_name}' on table '#{table_name}' does not exist")
        end
        var
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("columns_for_remove is deprecated and will be removed in the future")
        if var.blank? then;Fi[	@Fi	I"ô      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var))
      end;Fi[	@Ii5I"ë      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true)
      end;Fi[	@IinI"s        var = "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end
      
      def function(arglist)
        var = column_for(var, var)
        var[:default] = var.default unless options_include_default?(var);Fi[	@IixI"ä        var = "CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end
      
      def function(arglist)
        var = {}
        if var = columns(var).find { |arglist| (var.name == var.to_s) } then;Fi[	@IiÜI"~        var = select_one("SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'", "SCHEMA")["Type"]
        var = "CHANGE #{quote_column_name(column_name)} #{quote_column_name(new_column_name)} #{current_type}"
        add_column_options!(var, var)
        var
      end
      
      def function(arglist)
        "DROP #{quote_column_name(column_name)}"
      end;Fi[	@Ii≠I"        unless var = columns(var).find { |arglist| (var.name == var.to_s) } then
          raise("No such column: #{table_name}.#{column_name}")
        end
        var
      end
      
      def function(arglist)
        var = (@var[:variables] or {})
        var[:sql_auto_is_null] = 0;Fi[	@ViﬂI"∂          var, var = exec_stmt(var, var, var)
        end
        yield(var) if block_given?
        var
      end
      
      def function(arglist)
        @var.insert_id
      end;Fi[	@ViyI"∫        var = execute(var, var)
        var = yield(var)
        var.free
        var
      end
      
      def function(arglist)
        super(var, var)
        (var or @var.insert_id);Fi[	@[i&I"¶            end
            var = (var + 1)
          end
          var
        end
        
        def function(arglist)
          var = false
          var = false;Fi[	@çi¬I"        if var.empty? then
          raise(ActiveRecord::StatementInvalid, "Could not find table '#{table_name}'")
        end
        var
      end
      
      def function(arglist)
        var = "altered_#{table_name}"
        var = lambda { |arglist| yield(var) if block_given? };Fi[	@´i4I"Ì        if locking_enabled? and var.!=(1) then
          raise(ActiveRecord::StaleObjectError.new(self, "destroy"))
        end
        var
      end
      
      def function(arglist)
        var = super
        if locking_enabled? then;Fi[	@ñiI"ù    
    def self.reset_runtime(arglist)
      var, self.runtime = runtime, 0
      var
    end
    
    def function(arglist)
      super
      @var = false;Fi[	@ÀiÄI"0      var = connection.substitute_at(var, 0)
      var = self.class.unscoped.where(self.class.arel_table[var].eq(var))
      var.bind_values = [[var, id]]
      var
    end
    
    def function(arglist)
      raise(ReadOnlyRecord) if readonly?
      var = new_record? ? (create_record) : (update_record);Fi[	@ﬂiPI"’      def function(arglist)
        var = name.to_s.camelize
        var = var.singularize if collection?
        var
      end
      
      def function(arglist)
        if belongs_to? then
          "#{name}_id";Fi[	@ºi◊I"        var = var.where(var)
      end
      var = var.except(:limit, :offset) unless var
      var
    end
    
    def function(arglist)
      var = var.order_values.map { |arglist| var.presence }.compact
      var = @var.connection.distinct("#{quoted_table_name}.#{primary_key}", var);Fi[	@ºi˛I"L        var = " [#{conditions}]" if var
        raise(RecordNotFound, "Couldn't find #{@klass.name} with #{primary_key}=#{id}#{conditions}")
      end
      var
    end
    
    def function(arglist)
      var = where(table[primary_key].in(var)).to_a
      var = limit_value and (var.size > limit_value) ? (limit_value) : (var.size);Fi[	@Ûi˚I"      @var = true unless var.empty? and var.empty?
      var.join_associations.each { |arglist| var.join_to(var) }
      var.join_sources.concat(var)
      var
    end
    
    def function(arglist)
      if var.empty? then
        var.project(@var.arel_table[Arel.star]);Fi[	@‚iI"ç    
    def self.dump(arglist)
      new(var).dump(var)
      var
    end
    
    def function(arglist)
      header(var)
      tables(var);Fi[	@‚isI"¿        var.puts("#   #{e.message}")
        var.puts
      end
      var
    end
    
    def function(arglist)
      if (var = @var.indexes(var)).any? then
        var = var.map do |arglist|;Fi[	@2iJI"ﬂ          end
          var = var.and(var[var].eq(var))
        end
        var
      end
      
      def function(arglist)
        var = var.class.serialized_attributes[var.to_s]
        var = var.dump(var) if var and var;Fi[	@∂i-I"˝      def function(arglist)
        var = connection.directories.get(var)
        var = connection.directories.create(:key => (var)) if var.nil? and var
        var
      end
      
      def function(arglist)
        super(var).sub(/^\//, "")
      end;Fi[	@˝i–I"      unless var then
        raise(GemNotFound, not_found_message(var, Bundler.load.dependencies))
      end
      var
    end
    
    def function(arglist)
      var = "Could not find gem '#{missing_gem_name}'."
      var = var.map { |arglist| var.name };Fi[	@˝iÿI"      var = var.map { |arglist| var.name }
      var = SimilarityDetector.new(var).similar_word_list(var)
      var = (var + "\nDid you mean #{suggestions}?") if var
      var
    end
    
    def function(arglist)
      (pager_environment_variable or available_pager_system)
    end;Fi[	@ iuI"˜    def function(arglist)
      var = []
      resolve.materialize(requested_dependencies, var)
      var
    end
    
    def function(arglist)
      @var ||= (var = (self.groups - Bundler.settings.without)
      var.map! { |arglist| var.to_sym };Fi[	@ i⁄I"1        (var << var.to_lock)
        (var << var.name)
      end
      var
    end
    
    def function(arglist)
      var = false
      var = "You are trying to install in deployment mode after changing\nyour Gemfile. Run `bundle install` elsewhere and add the\nupdated Gemfile.lock to version control.";Fi[	@ iaI"–          var = true
        end
      end
      var
    end
    
    def function(arglist)
      (@var + @var).each do |arglist|
        var.source = @var.find { |arglist| (var.source == var) } if var.source;Fi[	@ iìI"Ã          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist)
      var and (var.source == var.source)
    end;Fi[	@ iÆI"∞          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|
        [var.is_a?(Source::Rubygems) ? (1) : (0), var.to_s];Fi[	@)i%I"¨        next unless var.include?(var)
        var = var.|([var])
      end
      var
    end
    
    def function(arglist)
      current_env? and current_platform?
    end;Fi[	@
i≥I"$        var.delete(var)
        var[var.to_s] = var
      end
      var
    end
    
    def function(arglist)
      _normalize_hash(var)
      var = ["group", "groups", "git", "gist", "github", "path", "name", "branch", "ref", "tag", "require", "submodules", "platform", "platforms", "type"];Fi[	@i@I"à        end
      end
      @var = var.keys
      var
    end
    
    def function(arglist)
      case var.to_sym
      when :node then;Fi[	@?i6I"          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist)
      case var
      when Gem::Specification, RemoteSpecification, LazySpecification, EndpointSpecification then;Fi[	@?iRI"›        same_version?(var.version, var.version) and (var.platform == var.platform)
      end
      (var << var)
      var
    end
    
    def function(arglist)
      specs.values.each { |arglist| var.each(&var) }
    end;Fi[	@Li2I"ﬂ        next if (var.type == :development)
        (var << "    #{dep.to_lock}\n")
      end
      var
    end
    
    def function(arglist)
      @var = source.specs.search(Gem::Dependency.new(name, version)).last
    end;Fi[	@%i
I"¡      var = catch(var.name) { |arglist| resolve(var, var) }
      clear_search_cache
      @var.slice!((var..-1))
      var
    end
    
    def function(arglist)
      search(var).size
    end;Fi[	@,iI"!    def function(arglist)
      var = "ruby #{version}"
      (var << " (#{engine} #{engine_version})") unless (engine == "ruby")
      var
    end
    
    def function(arglist)
      (version == var.version) and ((engine == var.engine) and (engine_version == var.engine_version))
    end;Fi[	@^iCI"Ÿ        (var << "\n")
        (var << dependencies_to_gemfile(development_dependencies, :development))
      end
      var
    end
    
    def function(arglist)
      (dependencies - development_dependencies)
    end;Fi[	@3iÄI"’        end
        var = {}
        var.each { |arglist| var[var.uri] = var.map { |arglist| var.to_a } }
        var
      end
      
      def function(arglist)
        begin
          Gem::Package.new(var).spec;Fi[	@8i£I".        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm_rf(var) if File.exists?(var) }
      end
      var
    end
    
    def function(arglist)
      begin
        ENV["BUNDLE_BIN_PATH"] = Bundler.rubygems.bin_path("bundler", "bundle", VERSION);Fi[	@=i*I"«    def function(arglist)
      var = {}
      all.each { |arglist| var[$'] = self[var] if var =~ /^local\./ }
      var
    end
    
    def function(arglist)
      var = key_for(var)
      var = {};Fi[	@=i3I"‡      var[:local] = @var[var] if @var.key?(var)
      var[:env] = ENV[var] if ENV[var]
      var[:global] = @var[var] if @var.key?(var)
      var
    end
    
    def function(arglist)
      var = key_for(var)
      var = [];Fi[	@=iEI"Ê      if var.empty? then
        return ["You have not configured a value for `#{exposed_key}`"]
      end
      var
    end
    
    def function(arglist)
      self[:without] = var.empty? ? (nil) : (var.join(":")) if var
    end;Fi[	@=ixI"        require("bundler/psyched_yaml")
        File.open(var, "w") { |arglist| var.puts(var.to_yaml) }
      end
      var
    end
    
    def function(arglist)
      var = (ENV["BUNDLE_CONFIG"] or File.join(Bundler.rubygems.user_home, ".bundle/config"))
      Pathname.new(var);Fi[	@XiâI"            raise(PathError, "The path `#{expanded_path}` does not exist.")
          end
        end
        var
      end
      
      def function(arglist)
        if path.to_s.match(/^#{Regexp.escape(Bundler.root.to_s)}/) then
          return path.relative_path_from(Bundler.root);Fi[	@_i4I"      def self.from_lock(arglist)
        var = new(var)
        Array(var["remote"]).each { |arglist| var.add_remote(var) }
        var
      end
      
      def function(arglist)
        var = "GEM\n"
        (var << remotes.map { |arglist| "  remote: #{r}\n" }.join);Fi[	@_iÅI"˙        unless var then
          raise(Bundler::GemNotFound, "Could not find #{spec.file_name} for installation")
        end
        var
      end
      
      def function(arglist)
        var = var.to_s
        var = "#{uri}/" unless var =~ /\/$/;Fi[	@_iãI"(        unless var.absolute? then
          raise(ArgumentError, "The source must be an absolute URI")
        end
        var
      end
      
      def function(arglist)
        @var ? (var = remote_specs.dup) : (var = Index.new)
        var.use(cached_specs, :override_dupes) if (@var or @var);Fi[	@_iíI"        @var ? (var = remote_specs.dup) : (var = Index.new)
        var.use(cached_specs, :override_dupes) if (@var or @var)
        var.use(installed_specs, :override_dupes)
        var
      end
      
      def function(arglist)
        @var ||= (var = Index.new
        var = false;Fi[	@_iµI"™          var.source = self
          (var << var)
        end)
        var
      end
      
      def function(arglist)
        @var ||= begin
          (var = Index.new;Fi[	@diAI"~      (@var << var)
      @var = nil
      @var = nil
      var
    end
    
    def function(arglist)
      self
    end;Fi[	@îi&I"µ            end
          end
          @var[var] = var
          var
        end
        
        def function(arglist)
          if var = @var[var] then
            var = var.prev;Fi[	@îi4I"∂            var = var.value
          end
          @var.delete(var)
          var
        end
        
        def function(arglist)
          self.map { |arglist| var }
        end;Fi[	@îiMI"‚          var = self.class.new
          self.each { |arglist| var[var] = var }
          var.each { |arglist| var[var] = var }
          var
        end
        
        def function(arglist)
          @var.empty?
        end;Fi[	@üiuI"˜      check_requirement!
      var = Thor::CoreExt::HashWithIndifferentAccess.new(@var)
      var.freeze
      var
    end
    
    def function(arglist)
      var = @var.select { |arglist| var =~ /^--?(?:(?!--).)*$/ }
      unless var.empty? then;Fi[	@§i√I"Ó        var ||= unauthorized_message(var, var)
        raise(AccessDenied.new(var, var, var))
      end
      var
    end
    
    def function(arglist)
      var = unauthorized_message_keys(var, var)
      var = { :action => (var.to_s) };Fi[	@§i”I"Ì      relevant_rules(var, var).map do |arglist|
        var.merge!(var.attributes_from_conditions) if var.base_behavior
      end
      var
    end
    
    def function(arglist)
      relevant_rules(var, var).any?(&:only_block?)
    end;Fi[	@§iI"ø      aliased_actions.each do |arglist|
        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end;Fi[	@πinI"V        var.send("#{parent_name}=", parent_resource)
      end
      initial_attributes.each { |arglist| var.send("#{attr_name}=", var) }
      var
    end
    
    def function(arglist)
      current_ability.attributes_for(@var[:action].to_sym, resource_class).delete_if do |arglist|
        resource_params and resource_params.include?(var);Fi[	@“iKI"‚      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {}
      if @var.kind_of?(Hash) then;Fi[	@iHI"A          var = ServerDefinition.new("127.0.0.1", :user => (var.user), :port => (gateway_for(var).open(var.host, (var.port or 22))))
          var = SSH.connect(var, @var)
          var.xserver = var
          var
        end
        
        def function(arglist)
          (@var[var.host] or @var[:default])
        end;Fi[	@DiI"„      def function(arglist)
        var = RemoteDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        var = LocalDependency.new(configuration)
        (@var << var);Fi[	@Di"I"”      def function(arglist)
        var = LocalDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        @var.each { |arglist| yield(var) }
        self;Fi[	@ñiyI"        def function(arglist)
          var = File.ftype(var)
          var = "file" unless ["link", "directory"].include?(var)
          var
        end
        
        def function(arglist)
          FileUtils.ln_s(File.readlink(var), File.join(destination, var))
        end;Fi[	@·i#I"<        var[:load_paths] ||= []
        var[:load_paths] += var
        (var[:load_paths] << Compass::SpriteImporter.new)
        var
      end
      
      def function(arglist)
        (additional_import_paths or []).map do |arglist|
          if var.is_a?(String) and (project_path and absolute_path?(var).!) then;Fi[	@i√I"‡          while var.last.inherited_data do
            (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {}
          ATTRIBUTES.each do |arglist|;Fi[	@
iAI"˙            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist)
        if var.respond_to?(:serialize_to_config) then
          (var.serialize_to_config(var) + "\n");Fi[	@$i›I"©          var
        end
      end
      var
    end
    
    def function(arglist)
      Sass::Script::List.new(var.map do |arglist|
        if ColorStop.===(var) then;Fi[	@Li1I"˚        def function(arglist)
          var = Compass::SassExtensions::Sprites::ImageRow.new(width)
          var.add(var) if var
          var
        end
        
        def function(arglist)
          var = new_row
          @var.each do |arglist|;Fi[	@iiYI"√        var = (var + [var]) if var
        var = @var.to_sexp
        var = (var + var) if var.any?
        var
      end
      
      def function(arglist)
        @var = true
        @var = var;Fi[	@äigI"¿        var = (var + var) if var.any?
        var = @var.to_sexp
        var = (var + var) if var.any?
        var
      end
      
      def function(arglist)
        @var = var
        yield;Fi[	@ñiQI"      def function(arglist)
        var = Hash.new { |arglist| var[var.to_s] if var.is_a?(Symbol) }
        column_names.each_with_index { |arglist| var[var] = var.value(var) }
        var
      end
      
      def function(arglist)
        cells_rows.index(var)
      end;Fi[	@§i|I"È          end
        end.flatten.uniq
        remove_excluded_files_from(var)
        var
      end
      
      def function(arglist)
        paths.map { |arglist| File.directory?(var) ? (var) : (File.dirname(var)) }.uniq
      end;Fi[	@§iàI"˙        var.formatter = LogFormatter.new
        var.level = Logger::INFO
        var.level = Logger::DEBUG if self.verbose?
        var
      end
      
      def function(arglist)
        Gherkin::TagExpression.new(@var[:tag_expressions])
      end;Fi[	@Øi%I"        else
          raise(YmlLoadError, "The '#{profile}' profile in cucumber.yml was a #{args_from_yml.class}. It must be a String or Array")
        end
        var
      end
      
      def function(arglist)
        cucumber_yml.has_key?(var)
      end;Fi[	@∞iI"™    
    def self.parse(arglist)
      return new(var) if var.is_a?(Hash)
      var
    end
    
    def function(arglist)
      @var = default_options.merge(var)
    end;Fi[	@≤iZI"¢          break
        end
      end
      var
    end
    
    def function(arglist)
      if var.respond_to?(:encode) then
        var.encode(DEFAULT_ENCODING);Fi[	@«iœI"˚      def function(arglist)
        var = 100.0
        var = (((@var.to_f / @var.to_f) * 1000).to_i / 10.0) if @var.!=(0)
        var
      end
      
      def function(arglist)
        (["#{exception.message}"] + var.backtrace).join("\n")
      end;Fi[	@’iI"◊            var.close
          end
        end
        var
      end
      
      def function(arglist)
        unless String.===(var) then
          raise("You *must* specify --out FILE for the #{name} formatter");Fi[	@
i-I"õ      
      def function(arglist)
        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end;Fi[	@
i6I"       
      def function(arglist)
        transforms.unshift(var)
        var
      end
      
      def function(arglist)
        hooks[var.to_sym].select { |arglist| var.accept_hook?(var) }
      end;Fi[	@iqI"Ï      def function(arglist)
        var = RbStepDefinition.new(self, var, var, var)
        (@var << var)
        var
      end
      
      def function(arglist)
        if var then
          raise(MultipleWorld.new(@var, var)) if @var;Fi[	@=iOI"Õ        var = var.new(@var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        log.debug("Code:\n")
        var.each { |arglist| load_file(var) };Fi[	@{i'I"º          var.merge!(resource.headers_for(var))
        end
        @var = var[:to]
        var
      end
      
      def function(arglist)
        mailer_sender(var, :reply_to)
      end;Fi[	@äiµI"‰      def function(arglist)
        var = (self.class.reconfirmable and (email_changed? and @var.!))
        @var = nil
        var
      end
      
      def function(arglist)
        self.class.reconfirmable and @var
      end;Fi[	@çiNI"»        var.delete(:password_confirmation)
        var = update_attributes(var, *var)
        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@i\I"    var = ((var[:aspect_ids] and (var[:aspect_ids].first == "public")) or var[:public])
    var.to_s.match(/(true)|(on)/) ? (var = true) : (var = false)
    params[:status_message][:public] = var
    var
  end
  
  def function(arglist)
    current_user.disable_getting_started
  end;Fi[	I"3data//diaspora_proj/helpers/language_helper.rb;TiI"    end
    var["pluralization_rule"] = I18n.t("i18n.plural.js_rule", :locale => (var))
    var["pod_name"] = pod_name
    var
  end
  
  def function(arglist)
    return "" unless var.respond_to?(:cleaned_is_rtl?)
    var.cleaned_is_rtl? ? ("rtl") : ("ltr");Fi[	@i(I"‰      if @var.present? then
        var[:from] = "\"#{@sender.name} (Diaspora*)\" <#{AppConfig.mail.sender_address}>"
      end
      var
    end
    
    def function(arglist)
      I18n.with_locale(@var.language, &var)
    end;Fi[	@tiI"ó      var = single_admin(var, var, var.dup)
      (var << var)
    end
    var
  end
  
  def function(arglist)
    @var = var
    @var = var.html_safe;Fi[	@Éi3I"  def function(arglist)
    var = self.generate_request
    Postzord::Dispatcher.build(self.user, var).post
    var
  end
  
  def function(arglist)
    Request.diaspora_initialize(:from => (self.user.person), :to => (self.person), :into => (aspects.first))
  end;Fi[	I"2data//diaspora_proj/models/invitation_code.rb;Ti)I"«      var = User.find_by_username(AppConfig.admins.account.get)
    end
    var ||= var
    var
  end
  
  def function(arglist)
    self.count = (AppConfig["settings.invitations.count"] or 25)
  end;Fi[	@îiI"    var = OEmbedCache.find_or_initialize_by_url(var)
    return var if var.persisted?
    var.fetch_and_save_oembed_data!
    var
  end
  
  def function(arglist)
    begin
      var = OEmbed::Providers.get(self.url, :maxwidth => 420, :maxheight => 420, :frame => 1, :iframe => 1);Fi[	@óiÅI"ä      end
    end
    raise(ActiveRecord::RecordNotFound) unless var.present?
    var
  end
  
  def function(arglist)
    self.guid
  end;Fi[	@ói≈I"à    rescue => var
      var = @var["url"]
    end
    var
  end
  
  def function(arglist)
    "#{url}receive/users/#{self.guid}/"
  end;Fi[	@ói¸I"v    var.assign_new_profile_from_hcard(var)
    var.save!
    var.profile.save!
    var
  end
  
  def function(arglist)
    self.profile = Profile.new(:first_name => (var[:given_name]), :last_name => (var[:family_name]), :image_url => (var[:photo]), :image_url_medium => (var[:photo_medium]), :image_url_small => (var[:photo_small]), :searchable => (var[:searchable]))
  end;Fi[	@úi^I"}      end
    end
    var.update_remote_path
    var
  end
  
  def function(arglist)
    processed_image.path.present?
  end;Fi[	I"'data//diaspora_proj/models/post.rb;Ti`I"  def self.for_a_stream(arglist)
    var = self.for_visible_shareable_sql(var, var).includes_for_a_stream
    var = var.excluding_hidden_content(var) if var.present?
    var
  end
  
  def function(arglist)
    return unless var
    reshares.where(:author_id => (var.person.id)).first;Fi[	@ÆiI"    if defined? var.parent and (var.person == var.parent.author) then
      var.parent_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    return nil unless self.target.present?
    self.target.parent;Fi[	I"-data//diaspora_proj/models/retraction.rb;Ti(I"¿      var.object = var
    end
    var.diaspora_handle = var.diaspora_handle
    var
  end
  
  def function(arglist)
    @var ||= self.type.constantize.where(:guid => (post_guid)).first
  end;Fi[	I"4data//diaspora_proj/models/signed_retraction.rb;Ti7I"ı    if (var.person == var.author) then
      var.target_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    @var ||= self.target_type.constantize.where(:guid => (target_guid)).first
  end;Fi[	@±i\I"ê        end
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then
      create_mentions if self.mentions.empty?;Fi[	I"0data//diaspora_proj/models/user/querying.rb;TimI"¨    else
      var = var.where("people.owner_id IS NOT NULL") if (var[:type] == "local")
    end
    var
  end
  
  def function(arglist)
    contact_for(var).aspects
  end;Fi[	I"6data//diaspora_proj/models/user/social_actions.rb;TiI"     var = build_post(:reshare, :root_guid => (var.guid))
    var.save!
    Postzord::Dispatcher.defer_build_and_post(self, var)
    var
  end
  
  def function(arglist)
    Comment::Generator.new(self, var.delete(:post), var.delete(:text)).build(var)
  end;Fi[	@ªiVI"≠  def self.build(arglist)
    var = User.new(var)
    var.setup(var)
    var
  end
  
  def function(arglist)
    self.username = var[:username]
    self.email = var[:email];Fi[	@ªizI"œ      var = Webfinger.new("diasporahq@joindiaspora.com").fetch
      self.share_with(var, var) if var
    end
    var
  end
  
  def function(arglist)
    OpenSSL::PKey::RSA.new(serialized_private_key)
  end;Fi[	I"7data//diaspora_proj/presenters/person_presenter.rb;TiI"    if (is_own_profile or person_is_following_current_user) then
      var.merge!(:location => (@var.location), :birthday => (@var.formatted_birthday), :bio => (@var.bio))
    end
    var
  end
  
  def function(arglist)
    (@var.try(:person) == @var)
  end;Fi[	@‰iÕI"è          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var);Fi[	I"'data//homebrew_proj/cmd/missing.rb;TiI"„      var = Formula.factory(var.basename.to_s) rescue nil
      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {}
    var.each do |arglist|;Fi[	@Ù#iI"¡        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist)
    return unless HOMEBREW_CELLAR.exist?
    var = ARGV.named.empty? ? (installed_brews) : (ARGV.formulae);Fi[	@.iBI"·      end
    end
    HOMEBREW_LIBRARY.join("Formula/.gitignore").atomic_write(var.uniq.join("\n"))
    var
  end
  
  def function(arglist)
    var = 0
    Dir["#{HOMEBREW_REPOSITORY}/Library/Formula/*.rb"].each do |arglist|;Fi[	I"4data//jekyll_proj/jekyll/converters/identity.rb;TiI"n    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end;Fi[	@ˇi/I"v      var = add_code_tags(Pygments.highlight(var, :lexer => (@var), :options => (@var)), @var)
      var = (var["pygments_prefix"] + var) if var["pygments_prefix"]
      var = (var + var["pygments_suffix"]) if var["pygments_suffix"]
      var
    end
    
    def function(arglist)
      "<div>\n  <pre><code class='#{@lang}'>#{h(code).strip}</code></pre>\n</div>\n"
    end;Fi[	@
i1I"ø      # reduce 0 omitted
      def function(arglist)
        var = [var.first, var.last].flatten
        var
      end
      
      def function(arglist)
        var = var.flatten
        var;Fi[	@
i6I"õ      
      def function(arglist)
        var = var.flatten
        var
      end
      
      def function(arglist)
        var = var.flatten
        var;Fi[	@
i;I"©      
      def function(arglist)
        var = var.flatten
        var
      end
      
      def function(arglist)
        var = :DIRECT_ADJACENT_SELECTOR
        var;Fi[	@
i@I"≠      
      def function(arglist)
        var = :DIRECT_ADJACENT_SELECTOR
        var
      end
      
      def function(arglist)
        var = :CHILD_SELECTOR
        var;Fi[	@
iEI"ß      
      def function(arglist)
        var = :CHILD_SELECTOR
        var
      end
      
      def function(arglist)
        var = :FOLLOWING_SELECTOR
        var;Fi[	@
iJI"¨      
      def function(arglist)
        var = :FOLLOWING_SELECTOR
        var
      end
      
      def function(arglist)
        var = :DESCENDANT_SELECTOR
        var;Fi[	@
iOI"≠      
      def function(arglist)
        var = :DESCENDANT_SELECTOR
        var
      end
      
      def function(arglist)
        var = :DESCENDANT_SELECTOR
        var;Fi[	@
iTI"®      
      def function(arglist)
        var = :DESCENDANT_SELECTOR
        var
      end
      
      def function(arglist)
        var = :CHILD_SELECTOR
        var;Fi[	@
iYI"Ø      
      def function(arglist)
        var = :CHILD_SELECTOR
        var
      end
      
      def function(arglist)
        var = if var[1].nil? then
          var.first;Fi[	@
ibI"        else
          Node.new(:CONDITIONAL_SELECTOR, [var.first, var[1]])
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [var.first, Node.new(:COMBINATOR, [var[1], var.last])])
        var;Fi[	@
igI"       
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [var.first, Node.new(:COMBINATOR, [var[1], var.last])])
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var;Fi[	@
irI"‡      # reduce 13 omitted
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var;Fi[	@
iwI"      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [Node.new(:ELEMENT_NAME, ["*"]), Node.new(:COMBINATOR, var)])
        var;Fi[	@
i|I".      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [Node.new(:ELEMENT_NAME, ["*"]), Node.new(:COMBINATOR, var)])
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [Node.new(:ELEMENT_NAME, ["*"]), var.first])
        var;Fi[	@
i|I"ı      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [Node.new(:ELEMENT_NAME, ["*"]), var.first])
        var
      end
      
      def function(arglist)
        var = Node.new(var.first, [nil, var.last])
        var;Fi[	@
iÅI"–      
      def function(arglist)
        var = Node.new(var.first, [nil, var.last])
        var
      end
      
      def function(arglist)
        var = Node.new(var[1], [var.first, var.last])
        var;Fi[	@
iíI"ˆ      # reduce 22 omitted
      def function(arglist)
        var = Node.new(:ELEMENT_NAME, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:ELEMENT_NAME, [[var.first, var.last].compact.join(":")])
        var;Fi[	@
ióI"!      
      def function(arglist)
        var = Node.new(:ELEMENT_NAME, [[var.first, var.last].compact.join(":")])
        var
      end
      
      def function(arglist)
        var = @var.key?("xmlns") ? ("xmlns:#{val.first}") : (var.first)
        var = Node.new(:ELEMENT_NAME, [var]);Fi[	@
iùI"Í      def function(arglist)
        var = @var.key?("xmlns") ? ("xmlns:#{val.first}") : (var.first)
        var = Node.new(:ELEMENT_NAME, [var])
        var
      end
      
      def function(arglist)
        var = var[0]
        var;Fi[	@
i®I"      # reduce 27 omitted
      def function(arglist)
        var = Node.new(:ATTRIBUTE_CONDITION, ([var[1]] + (var[2] or [])))
        var
      end
      
      def function(arglist)
        var = Node.new(:ATTRIBUTE_CONDITION, ([var[1]] + (var[2] or [])))
        var;Fi[	@
i≠I"      
      def function(arglist)
        var = Node.new(:ATTRIBUTE_CONDITION, ([var[1]] + (var[2] or [])))
        var
      end
      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [Node.new(:FUNCTION, ["nth-child(", var[1]])])
        var;Fi[	@
i≤I"      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [Node.new(:FUNCTION, ["nth-child(", var[1]])])
        var
      end
      
      def function(arglist)
        var = Node.new(:ELEMENT_NAME, [[var.first, var.last].compact.join(":")])
        var;Fi[	@
i∑I"Î      
      def function(arglist)
        var = Node.new(:ELEMENT_NAME, [[var.first, var.last].compact.join(":")])
        var
      end
      
      def function(arglist)
        var = Node.new(:ELEMENT_NAME, [var.first])
        var;Fi[	@
iºI"œ      
      def function(arglist)
        var = Node.new(:ELEMENT_NAME, [var.first])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var;Fi[	@
i¡I"·      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@
i∆I"Ò      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@
iÀI"Ò      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@
i–I"Ò      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var;Fi[	@
i’I"–      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var;Fi[	@
i⁄I"Ø      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var;Fi[	@
iﬂI"Ø      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var;Fi[	@
iıI"≤            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then
          var = Node.new(:AN_PLUS_B, var);Fi[	@
i˛I"“        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end
      
      def function(arglist)
        if (var[0] == "n") then
          var.unshift("1");Fi[	@
iI"—            raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then
          (var << "+");Fi[	@
iI"”        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [var[1]])
        var;Fi[	@
iI"«      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [var[1]])
        var
      end
      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [var[1]])
        var;Fi[	@
i*I"Ã      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@
i/I"π      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@
i4I"π      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var;Fi[	@
iBI"Ω      # reduce 58 omitted
      def function(arglist)
        var = Node.new(:ID, var)
        var
      end
      
      def function(arglist)
        var = [var.first, var[1]]
        var;Fi[	@
iGI"´      
      def function(arglist)
        var = [var.first, var[1]]
        var
      end
      
      def function(arglist)
        var = [var.first, var[1]]
        var;Fi[	@
iRI"´      # reduce 62 omitted
      def function(arglist)
        var = :equal
        var
      end
      
      def function(arglist)
        var = :prefix_match
        var;Fi[	@
iWI"ü      
      def function(arglist)
        var = :prefix_match
        var
      end
      
      def function(arglist)
        var = :suffix_match
        var;Fi[	@
i\I"¢      
      def function(arglist)
        var = :suffix_match
        var
      end
      
      def function(arglist)
        var = :substring_match
        var;Fi[	@
iaI"ü      
      def function(arglist)
        var = :substring_match
        var
      end
      
      def function(arglist)
        var = :not_equal
        var;Fi[	@
ifI"ò      
      def function(arglist)
        var = :not_equal
        var
      end
      
      def function(arglist)
        var = :includes
        var;Fi[	@
ikI"ô      
      def function(arglist)
        var = :includes
        var
      end
      
      def function(arglist)
        var = :dash_match
        var;Fi[	@
ipI"®      
      def function(arglist)
        var = :dash_match
        var
      end
      
      def function(arglist)
        var = Node.new(:NOT, [var[1]])
        var;Fi[	@i2I"ÿ        return if @var.eos?
        until (var = _next_token or @var.eos?) do
        end
        var
      end
      
      def function(arglist)
        var = @var.peek(1)
        @var = (@var + 1) if (var == "\n");Fi[	@i>I"û          var["nekohtml"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin
        require("psych");Fi[	@ciFI"·        else
          send(var, var)
        end
        var
      end
      
      def function(arglist)
        if Nokogiri.uses_libxml? and ["2", "6"].===(LIBXML_VERSION.split(".")[(0..1)]) then
          return dump_html;Fi[	@cinI"ù        if (var.is_a?(Document) or (var.is_a?(XML::Attr) or var.is_a?(XML::Node).!)) then
          raise(ArgumentError, "Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.\n(You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)\n")
        end
        var
      end
      
      def function(arglist)
        "./"
      end;Fi[	I"%data//omni_proj/omniauth/form.rb;TiI"¯    def self.build(arglist)
      var = OmniAuth::Form.new(var)
      (var.arity > 0) ? (yield(var)) : (var.instance_eval(&var))
      var
    end
    
    def function(arglist)
      (@var << "\n<label for='#{target}'>#{text}:</label>")
      self;Fi[	@æirI"œ        end
        var[var] = var[var]
      end
      var
    end
    
    def function(arglist)
      if OmniAuth.config.camelizations[var.to_s] then
        return OmniAuth.config.camelizations[var.to_s];Fi[	@ÎikI"/      def function(arglist)
        var = (@var[:s3_url_options] or {})
        var = var.call(instance) if var.respond_to?(:call)
        var
      end
      
      def function(arglist)
        @var = (@var[:bucket] or s3_credentials[:bucket])
        @var = @var.call(self) if @var.respond_to?(:call);Fi[	@ÎiπI"      def function(arglist)
        var = (@var[var] or @var[:default])
        var = var.call(self, var) if var.respond_to?(:call)
        var
      end
      
      def function(arglist)
        var = @var
        var = var.call(var, self) if var.respond_to?(:call);Fi[	I"7data//paperclip_proj/paperclip/tempfile_factory.rb;TiI"§      @var = var
      var = Tempfile.new([basename, extension])
      var.binmode
      var
    end
    
    def function(arglist)
      File.extname(@var)
    end;Fi[	@xi+I"õ        var
      end
    end
    var
  end
  
  def function(arglist)
    var.gsub!(/<redpre#(\d+)>/) { |arglist| @var[$1.to_i] } unless @var.empty?
  end;Fi[	@ôi4I"´            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("B", 8)
        var.SetFillColor(230, 230, 230);Fi[	@™ibI"          (@var << var)
          var[:indent] += var[:indent_increment]
        end
        var
      end
      
      def function(arglist)
        if var.is_a?(Issue) and var.due_before then
          var = coordinates(var.start_date, var.due_before, var.done_ratio, var[:zoom]);Fi[	@™i\I"÷          end
        end
        var.keys.each { |arglist| var[var] = (var[var] * var).floor }
        var
      end
      
      def function(arglist)
        (var + (((var - var) + 1) * (var / 100.0)))
      end;Fi[	@™iâI"        end
        var = view.content_tag(:div, var, :class => (var[:css]), :style => (var), :title => (var[:title]), :id => (var[:id]))
        (@var << var)
        var
      end
      
      def function(arglist)
        var[:pdf].SetY(var[:top])
        var[:pdf].SetX(15);Fi[	@™i§I"÷            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = ""
        if var[:bar_start] and var[:bar_end] then;Fi[	@™iÏI"          (var << view.content_tag(:div, var.html_safe, :style => (var), :class => "tooltip"))
        end
        (@var << var)
        var
      end
      
      def function(arglist)
        var = (var[:height] or 2)
        if var[:bar_start] and var[:bar_end] then;Fi[	@i1I"           sort_multiple(var, var, (var - 1))
          sort_multiple(var, (var + 1), var)
        end
        var
      end
      
      def function(arglist)
        var = var[0][var]
        var = var;Fi[	@iDI"‡        var.each do |arglist|
          var[var], var[var], *s(:call, s(:lvar, :var), :[], s(:lvar, :var))
        end
        var
      end
      
      def function(arglist)
        if no_css then
          var = parse_css;Fi[	@{iI"        def function(arglist)
          var = new(*var, &var)
          (shared_example_groups << var) unless already_registered?(var)
          var
        end
        
        def function(arglist)
          shared_example_groups.find { |arglist| (var.description == var) }
        end;Fi[	@YiâI"»      
      def function(arglist)
        @var, var = prefix_and_expected(var)
        var
      end
      
      def function(arglist)
        var.to_s =~ /^(be_(an?_)?)(.*)/
        return [$1, $3];Fi[	@l iI"˚        unless @var.empty? then
          var = (var + "the extra elements were:        #{safe_sort(@extra_items).inspect}\n")
        end
        var
      end
      
      def function(arglist)
        "Matcher does not support should_not"
      end;Fi[	@€i2I"≥        var.opts = var
        var.error_generator = var
        var.clone_args_to_yield(@var)
        var
      end
      
      def function(arglist)
        @var.args
      end;Fi[	@€i¢I"∆          end
          var = eval_block(*var, &var)
        end
        var
      end
      
      def function(arglist)
        @var ? (@var.instance_exec(*var, &var)) : (var.call(*var))
      end;Fi[	@„i9I"        var = {}
        extract_option(var, var, :null_object)
        extract_option(var, var, :__declared_as, "Mock")
        var
      end
      
      def function(arglist)
        var[var] ? (var[var] = var.delete(var)) : (var[var] = var if var)
      end;Fi[	@9i{I"Ÿ          if @var.!=(0) then
            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@qiÒI"É            end
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true)
      end;Fi[	I")data//SiriProxy_proj/siri_objects.rb;Ti+I"”        var["properties"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist)
    self.extend(SiriRootObject)
    self.ref_id = (var or random_ref_id);Fi[	@ÿiÑI"   def function(arglist)
    var = CFPropertyList::List.new(:data => (var))
    var = CFPropertyList.native_types(var.value)
    var
  end
  
  def function(arglist)
    if var["refId"].!=(nil) and var["refId"].empty?.! then
      @var = false if @var and self.last_ref_id.!=(var["refId"]);Fi[@'I"var;FI"end;FI" ;Fi¨[¨[	@Ci6I"t        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    ;Fi[	@}iúI"Ò          if reflection.options[:as] then
            var[reflection.type] = owner.class.base_class.name
          end
        end
        var
      end
      
      # Sets the owner attributes on the given record
      def function(arglist);Fi[	@ÇiVI"             var.includes!(var.includes_values)
            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist)
        reflection.name;Fi[	@óiI"	        else
          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      ;Fi[	@ùi+I"ﬂ        var = super
        if owner.new_record? and var then
          var.flatten.each { |arglist| build_through_record(var) }
        end
        var
      end
      
      def function(arglist)
        ensure_not_nested;Fi[	@ùigI"              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!;Fi[	@Æi[I"œ            end
            var.from(join(var, var))
            var, var = var, var.klass
          end
          var
        end
        
        def function(arglist)
          var = var[var].eq(var[var]);Fi[	@ÆicI"&          var = var[var].eq(var[var])
          if var.klass.finder_needs_type_condition? then
            var = var.create_and([var, var.klass.send(:type_condition, var)])
          end
          var
        end
        
        def function(arglist)
          self.join_type = Arel::OuterJoin;Fi[	@ΩiµI"Í          else
            raise(ConfigurationError, "unknown macro: #{join_part.reflection.macro}")
          end
        end
        var
      end
      
      def function(arglist)
        var = var.association(var.reflection.name);Fi[	@¿iI"&          if (var.source_macro == :has_and_belongs_to_many) then
            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist)
        var.table_name;Fi[	@√iUI"          var.each do |arglist|
            var = var[association_key_name].to_s
            var[var].each { |arglist| (var[var] << var) }
          end
          var
        end
        
        def function(arglist)
          @var ||= if reflection.scope then;Fi[	@ˇiI"˛        var = super
        chain[(1..-1)].each do |arglist|
          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      ;Fi[	@i©I"ƒ        var = self.class.reflect_on_association(var)
        var = var.association_class.new(self, var)
        association_instance_set(var, var)
      end
      var
    end
    
    private
    ;Fi[	@iYI"        var[var] ||= {}
        var = var.empty? ? (nil) : (type_cast_attribute_value(var, var))
        var[var][find_parameter_position(var)] ||= var
      end
      var
    end
    
    def function(arglist)
      var =~ /\([0-9]*([if])\)/ ? (var.send(("to_" + $1))) : (var);Fi[	@i$I"È        if var = super then
          @var = changes
          @var.clear
        end
        var
      end
      
      # Attempts to <tt>save!</tt> the record and clears changed attributes if successful.
      def function(arglist);Fi[	@9iI"E        var = prepare_column_options(var, var)
        (var.keys - [:name, :type]).each do |arglist|
          var[var].insert(0, "#{k.to_s}: ")
        end
        var
      end
      
      # This can be overridden on a Adapter level basis to support other
      # extended datatypes (Example: Adding an array option in the;Fi[	@>iúI"q        var = index_name(var, var)
        unless index_name_exists?(var, var, true) then
          raise(ArgumentError, "Index name '#{index_name}' on table '#{table_name}' does not exist")
        end
        var
      end
      
      def function(arglist)
        ActiveSupport::Deprecation.warn("columns_for_remove is deprecated and will be removed in the future");Fi[	@IiúI"            (var.last.columns << var[:Column_name])
            (var.last.lengths << var[:Sub_part])
          end
        end
        var
      end
      
      # Returns an array of +Column+ objects for the table specified by +table_name+.
      def function(arglist);Fi[	@Ii¨I"      def function(arglist)
        unless var = columns(var).find { |arglist| (var.name == var.to_s) } then
          raise("No such column: #{table_name}.#{column_name}")
        end
        var
      end
      
      def function(arglist)
        var = (@var[:variables] or {});Fi[	@[i%I"´              # do nothing
            end
            var = (var + 1)
          end
          var
        end
        
        def function(arglist)
          var = false;Fi[	@çiÁI"            logger.error("Binary data inserted for `string` type on column `#{column.name}`")
          end
          var = var.encode(Encoding::UTF_8)
        end
        var
      end
      
      # DATABASE STATEMENTS ======================================
      def function(arglist);Fi[	@çi¡I">        var = exec_query("PRAGMA table_info(#{quote_table_name(table_name)})", "SCHEMA").to_hash
        if var.empty? then
          raise(ActiveRecord::StatementInvalid, "Could not find table '#{table_name}'")
        end
        var
      end
      
      def function(arglist)
        var = "altered_#{table_name}";Fi[	@õiFI"∞      end.join("\n"))
      def var.inspect(arglist)
        self
      end
      var
    end
    
    # Silences automatic EXPLAIN logging for the duration of the block.
    #;Fi[	@ûi√I"\          end
        end
        var
      end
      var
    end
    
    private
    ;Fi[	@´i3I"‡        var = super
        if locking_enabled? and var.!=(1) then
          raise(ActiveRecord::StaleObjectError.new(self, "destroy"))
        end
        var
      end
      
      def function(arglist)
        var = super;Fi[	@´i?I"+          var = connection.substitute_at(var, var.bind_values.length)
          var = var.where(self.class.arel_table[var].eq(var))
          (var.bind_values << [var, self[var].to_i])
        end
        var
      end
      
      module ClassMethods
        DEFAULT_LOCKING_COLUMN = "lock_version";Fi[	@ΩiŒI"V          if create_time_zone_conversion_attribute?(var, var) then
            var[var] = AttributeMethods::TimeZoneConversion::Type.new(var)
          end
        end
        var
      end
      
      # Returns a hash where the keys are column names and the values are
      # default values when instantiating the AR object for this table.;Fi[	@ÀiΩI"F      var = becomes(var)
      unless self.class.descends_from_active_record? then
        var.public_send("#{klass.inheritance_column}=", var.sti_name)
      end
      var
    end
    
    # Updates a single attribute and saves the record.
    # This is especially useful for boolean flags on existing records. Also note that;Fi[	@ºi˝I"        var = arel.where_sql
        var = " [#{conditions}]" if var
        raise(RecordNotFound, "Couldn't find #{@klass.name} with #{primary_key}=#{id}#{conditions}")
      end
      var
    end
    
    def function(arglist)
      var = where(table[primary_key].in(var)).to_a;Fi[	@iI"ó          end
          var.concat(expand(var, var, var, var))
        end
      end
      var
    end
    
    def self.expand(arglist)
      var = [];Fi[	@¯iPI"Â          else
            var[var] = var
          end
        end
        var
      end
      
      # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.
      #   { name: "foo'bar", group_id: 4 };Fi[	@‚irI"˘        var.puts("# Could not dump table #{table.inspect} because of following #{e.class}")
        var.puts("#   #{e.message}")
        var.puts
      end
      var
    end
    
    def function(arglist)
      if (var = @var.indexes(var)).any? then;Fi[	@i6I"Û      unless var.is_a?(ActiveSupport::HashWithIndifferentAccess) then
        var = IndifferentCoder.as_indifferent_hash(var)
        send(:"#{var}=", var)
      end
      var
    end
    
    class IndifferentCoder
      def function(arglist);Fi[	@'ièI"Ñ          var = nil
        end
        raise(ActiveRecord::Rollback) unless var
      end
      var
    end
    
    protected
    ;Fi[	I"9data//activerecord_proj/active_record/translation.rb;TiI"ﬁ      return var if (var == ActiveRecord::Base)
      while var.!=(var.base_class) do
        (var << (var = var.superclass))
      end
      var
    end
    
    # Set the i18n scope to overwrite ActiveModel.
    #:nodoc:;Fi[	@2iII"ﬁ            var = var.read_attribute(var)
          end
          var = var.and(var[var].eq(var))
        end
        var
      end
      
      def function(arglist)
        var = var.class.serialized_attributes[var.to_s];Fi[	@•iKI"J          rescue => var
            Logger.warn(Errors::Storage::Dropbox::CacheError.wrap(var, "              Could not read session data from cache.\n              Cache data might be corrupt.\n"))
          end
        end
        var
      end
      
      ##
      # Transfers the archived file to the specified Dropbox folder;Fi[	@“i´I"?            if var.invalid? then
              Logger.warn(("  [skipping] #{local_file.path}\n" + "  Path Contains Invalid UTF-8 byte sequences"))
              return nil
            end
            var
          end
          
          ##
          # Creates a new LocalFile object using the given directory and line;Fi[	@˝iœI"!      var = Bundler.load.dependencies.find { |arglist| (var.name == var) }
      unless var then
        raise(GemNotFound, not_found_message(var, Bundler.load.dependencies))
      end
      var
    end
    
    def function(arglist)
      var = "Could not find gem '#{missing_gem_name}'.";Fi[	@ iŸI"™        next if var.include?(var.name)
        (var << var.to_lock)
        (var << var.name)
      end
      var
    end
    
    def function(arglist)
      var = false;Fi[	@ i`I"ó          var.unlock!
          var = true
        end
      end
      var
    end
    
    def function(arglist)
      (@var + @var).each do |arglist|;Fi[	@ iíI"        unless var.any? { |arglist| (var.source == var) } then
          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist)
      var and (var.source == var.source);Fi[	@ i≠I"†            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist)
      @var.sort_by do |arglist|;Fi[	@)i$I"ƒ        var = PLATFORM_MAP[var]
        next unless var.include?(var)
        var = var.|([var])
      end
      var
    end
    
    def function(arglist)
      current_env? and current_platform?;Fi[	@
i≤I"†        var = var[var]
        var.delete(var)
        var[var.to_s] = var
      end
      var
    end
    
    def function(arglist)
      _normalize_hash(var);Fi[	@?i5I"‡          (var << var) unless var.include?([var.name, var.version, var.platform])
          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist)
      case var;Fi[	@Li1I"      dependencies.sort_by { |arglist| var.to_s }.each do |arglist|
        next if (var.type == :development)
        (var << "    #{dep.to_lock}\n")
      end
      var
    end
    
    def function(arglist)
      @var = source.specs.search(Gem::Dependency.new(name, version)).last;Fi[	@^iBI"      unless development_dependencies.empty? then
        (var << "\n")
        (var << dependencies_to_gemfile(development_dependencies, :development))
      end
      var
    end
    
    def function(arglist)
      (dependencies - development_dependencies);Fi[	@^isI"N      unless (requirement == Gem::Requirement.default) then
        var = requirement.requirements.map { |arglist| "#{o} #{v}" }.sort.reverse
        (var << " (#{reqs.join(", ")})")
      end
      var
    end
    
    unless allocate.respond_to?(:matches_spec?) then
      # Backport of performance enhancement added to Rubygems 1.4;Fi[	@8i¢I"        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm(var) if File.exists?(var) }
        var.each { |arglist| FileUtils.rm_rf(var) if File.exists?(var) }
      end
      var
    end
    
    def function(arglist)
      begin;Fi[	@=iDI"Ë      end
      if var.empty? then
        return ["You have not configured a value for `#{exposed_key}`"]
      end
      var
    end
    
    def function(arglist)
      self[:without] = var.empty? ? (nil) : (var.join(":")) if var;Fi[	@=iwI"'        FileUtils.mkdir_p(var.dirname)
        require("bundler/psyched_yaml")
        File.open(var, "w") { |arglist| var.puts(var.to_yaml) }
      end
      var
    end
    
    def function(arglist)
      var = (ENV["BUNDLE_CONFIG"] or File.join(Bundler.rubygems.user_home, ".bundle/config"));Fi[	@JihI"Ë        var = (cached_revision and cached_revision.!=(git_proxy.revision))
        if var and git_proxy.contains?(cached_revision).! then
          raise(GitError, "The Gemfile lock is pointing to revision #{shortref_for_display(cached_revision)} but the current branch in your local override for #{name} does not contain such commit. Please make sure your branch is up to date.")
        end
        var
      end
      
      # TODO: actually cache git specs
      def function(arglist);Fi[	@XiàI"ı          else
            raise(PathError, "The path `#{expanded_path}` does not exist.")
          end
        end
        var
      end
      
      def function(arglist)
        if path.to_s.match(/^#{Regexp.escape(Bundler.root.to_s)}/) then;Fi[	@_iÄI"        var = var.find { |arglist| File.exist?(var) }
        unless var then
          raise(Bundler::GemNotFound, "Could not find #{spec.file_name} for installation")
        end
        var
      end
      
      def function(arglist)
        var = var.to_s;Fi[	@_iäI"˛        var = URI(var)
        unless var.absolute? then
          raise(ArgumentError, "The source must be an absolute URI")
        end
        var
      end
      
      def function(arglist)
        @var ? (var = remote_specs.dup) : (var = Index.new);Fi[	@oi/I"    unless (var.user or var.password) then
      var.user = escape((ENV["http_proxy_user"] or ENV["HTTP_PROXY_USER"]))
      var.password = escape((ENV["http_proxy_pass"] or ENV["HTTP_PROXY_PASS"]))
    end
    var
  end
  
  ##
  # Returns true when proxy should by bypassed for host.;Fi[	@úi\I"      while current_is_value? and peek.include?(":") do
        var, var = shift.split(":", 2)
        var[var] = var
      end
      var
    end
    
    # Runs through the argument array getting all strings until no string is
    # found or a switch is found.;Fi[	@úinI"—      var = []
      while current_is_value? do
        (var << shift)
      end
      var
    end
    
    # Check if the peek is numeric format and return a Float or Integer.
    # Otherwise raises an error.;Fi[	@§i¬I"Ó      if cannot?(var, var, *var) then
        var ||= unauthorized_message(var, var)
        raise(AccessDenied.new(var, var, var))
      end
      var
    end
    
    def function(arglist)
      var = unauthorized_message_keys(var, var);Fi[	@§i“I"Ù      var = {}
      relevant_rules(var, var).map do |arglist|
        var.merge!(var.attributes_from_conditions) if var.base_behavior
      end
      var
    end
    
    def function(arglist)
      relevant_rules(var, var).any?(&:only_block?);Fi[	@§iI"…      var = [var]
      aliased_actions.each do |arglist|
        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= [];Fi[	@“iJI"œ      var = {}
      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {};Fi[	@“iTI"•        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    ;Fi[	@ËisI"∑          else
            (var << var.map { |arglist| "#{indentation}#{l}\n" }.join)
          end
        end
        var
      end
      
      #:nodoc:
      def function(arglist);Fi[	@i~I"              (var == "deploy:symlink") ? ("deploy:create_symlink") : (var)
            end
          end
        end
        var
      end
      
      # Trigger the named event for the named task. All associated callbacks
      # will be fired, in the order they were defined.;Fi[	@#iI"g          var = Thread.current[:capistrano_configuration]
          if var and var.nil? then
            raise(LoadError, "Please require this file from within a Capistrano recipe")
          end
          var
        end
        
        # Used internally by Capistrano to specify the current configuration
        # before loading a third-party task bundle.;Fi[	@`igI"˜          if var then
            var = var.split(/\//)
            (var << "-d #{dest_parts.pop}")
          end
          var
        end
        
        # attempts to guess what type of revision we're working with
        def function(arglist);Fi[	@bi_I"[      unless var.empty? then
        puts("[establishing connection(s) to #{needing_connections.join(", ")}]")
        configuration.establish_connections_to(var)
      end
      var
    end
    
    # Execute the given command. If the command is prefixed by an exclamation
    # mark, it is assumed to refer to another capistrano task, which will;Fi[	@i¬I"–          var = [self]
          while var.last.inherited_data do
            (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {};Fi[	@
i@I"Ÿ          else
            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist)
        if var.respond_to?(:serialize_to_config) then;Fi[	@$i‹I"ì        else
          var
        end
      end
      var
    end
    
    def function(arglist)
      Sass::Script::List.new(var.map do |arglist|;Fi[	@$iHI"÷            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    
    # returns the end position of the gradient from the color stop
    def function(arglist);Fi[	@Øi$I"          end
        else
          raise(YmlLoadError, "The '#{profile}' profile in cucumber.yml was a #{args_from_yml.class}. It must be a String or Array")
        end
        var
      end
      
      def function(arglist)
        cucumber_yml.has_key?(var);Fi[	@≤iYI"ê          var = $1
          break
        end
      end
      var
    end
    
    def function(arglist)
      if var.respond_to?(:encode) then;Fi[	@Œi1I"∂            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        
        def self.wrap(arglist)
          validate_pipe(var);Fi[	@’iI"¢            var.flush
            var.close
          end
        end
        var
      end
      
      def function(arglist)
        unless String.===(var) then;Fi[	@{iBI"1        var = [self.class.mailer_name]
        if self.class.scoped_views? then
          var.unshift("#{@devise_mapping.scoped_path}/mailer")
        end
        var
      end
      
      # Setup a subject doing an I18n lookup. At first, it attemps to set a subject
      # based on the current mapping:;Fi[	@Éi∏I"«              var.send("#{key}=", var)
              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected
        ;Fi[	@òirI"Î            else
              var.errors.add(:reset_password_token, :expired)
            end
          end
          var
        end
        
        Devise::Models.config(self, :reset_password_keys, :reset_password_within)
      end;Fi[	@ÁiI"Ë        var = var[var]
        next unless var.respond_to?(:strip)
        var[var] = var.strip
      end
      var
    end
    
    # Force keys to be string to avoid injection on mongoid related database.
    def function(arglist);Fi[	@i'I"s      var = { :from => (AppConfig.mail.sender_address.get), :host => ("#{AppConfig.pod_uri.host}"), :to => (name_and_address(@var.name, @var.email)) }
      if @var.present? then
        var[:from] = "\"#{@sender.name} (Diaspora*)\" <#{AppConfig.mail.sender_address}>"
      end
      var
    end
    
    def function(arglist)
      I18n.with_locale(@var.language, &var);Fi[	@tiI"ò    var.each do |arglist|
      var = single_admin(var, var, var.dup)
      (var << var)
    end
    var
  end
  
  def function(arglist)
    @var = var;Fi[	@i&I"˜    var.map! do |arglist|
      var = var.find { |arglist| (var.email == var) }
      Invitation.create(var.merge(:identifier => (var), :recipient => (var)))
    end
    var
  end
  
  # Downcases the incoming service identifier and assigns it
  #;Fi[	@óiƒI"õ      var = (var + "/"))
    rescue => var
      var = @var["url"]
    end
    var
  end
  
  def function(arglist)
    "#{url}receive/users/#{self.guid}/";Fi[	@óiI"≈    var = { :id => (self.id), :guid => (self.guid), :name => (self.name), :avatar => (self.profile.image_url(:thumb_medium)), :handle => (self.diaspora_handle), :url => (Rails.application.routes.url_helpers.person_path(self)) }
    if (var[:includes] == "tags") then
      var.merge!(:tags => (self.profile.tags.map { |arglist| "##{t.name}" }))
    end
    var
  end
  
  def self.url_batch_update(arglist)
    var.each { |arglist| var.update_url(var) };Fi[	@ÿ#iUI"    var = scoped
    if var.has_hidden_shareables_of_type? then
      var = var.where("posts.id NOT IN (?)", var.hidden_shareables["#{self.base_class}"])
    end
    var
  end
  
  def self.excluding_hidden_content(arglist)
    excluding_blocks(var).excluding_hidden_shareables(var);Fi[	@ÆiI"˚    var = super
    if defined? var.parent and (var.person == var.parent.author) then
      var.parent_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    return nil unless self.target.present?;Fi[	@0iNI"n    var = self
    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  ;Fi[	@‡#i6I"    var.target = var
    if (var.person == var.author) then
      var.target_author_signature = var.sign_with_key(var.encryption_key)
    end
    var
  end
  
  def function(arglist)
    @var ||= self.target_type.constantize.where(:guid => (target_guid)).first;Fi[	@±i[I"          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  
  def function(arglist)
    if self.persisted? then;Fi[	@Â#ilI"–      var = var.where(:owner_id => (nil))
    else
      var = var.where("people.owner_id IS NOT NULL") if (var[:type] == "local")
    end
    var
  end
  
  def function(arglist)
    contact_for(var).aspects;Fi[	@ªiyI"˚    if AppConfig.settings.follow_diasporahq? then
      var = Webfinger.new("diasporahq@joindiaspora.com").fetch
      self.share_with(var, var) if var
    end
    var
  end
  
  def function(arglist)
    OpenSSL::PKey::RSA.new(serialized_private_key);Fi[	@Ô#iI"Q    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile))
    if (is_own_profile or person_is_following_current_user) then
      var.merge!(:location => (@var.location), :birthday => (@var.formatted_birthday), :bio => (@var.bio))
    end
    var
  end
  
  def function(arglist)
    (@var.try(:person) == @var);Fi[	@Hi4I"3      end
      if var.has_key?(:alias) then
        [var[:alias]].flatten.each { |arglist| Filters.defined[var.to_s] = var }
      end
      var
    end
    
    # Removes a filter from Haml. If the filter was removed, it returns
    # the that was remove Module upon success, or nil on failure. If you try;Fi[	@‰iÃI"~        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist)
      var = {};Fi[	@‰iﬁI"˛        end
        return unless var.scan(/\s*(?:,|$)\s*/)
        var[eval(var).to_s] = eval(var).to_s)
      end
      var
    end
    
    # Parses a line into tag_name, attributes, attributes_hash, object_ref, action, value
    def function(arglist);Fi[	@Ù#iI"˜    HOMEBREW_CELLAR.subdirs.each do |arglist|
      var = Formula.factory(var.basename.to_s) rescue nil
      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {};Fi[	@Ù#iI"¨        yield(var.name, var) if block_given?
        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist)
    return unless HOMEBREW_CELLAR.exist?;Fi[	@ai`I"õ        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  ;Fi[	@ØißI"    (var << "This is because #{@opts[:because]}\n") if @var[:because]
    unless ARGV.force? then
      (var << "      Please `brew unlink #{@formula}` before continuing. Unlinking removes\n      the formula's symlinks from #{HOMEBREW_PREFIX}. You can link the\n      formula again after the install finishes. You can --force this install\n      but the build may fail or cause obscure side-effects in the end-binary.\n".undent)
    end
    var
  end
  
  satisfy(:build_env => (false)) do |arglist|
    var = Formula.factory(@var).prefix;Fi[	@ÁiuI"        raise(Error, "invalid character at #{s[0, 10].inspect}") if (var == nil)
        (var << [var, var, var]) if var.!=(:space)
        var = var[(var.length..-1)]
      end
      var
    end
    
    # Scans the first token in s and
    # returns a 3-element list, or nil;Fi[	I")data//jekyll_proj/jekyll/core_ext.rb;TiI"≈        next
      end
      var[var] = var[var]
    end
    var
  end
  
  # Read array from the supplied hash favouring the singular key
  # and then the plural key, and handling any nil entries.;Fi[	@¶iÄI"ﬂ      var.each do |arglist|
        var.gsub!(("$$" + var), ("<" + var))
        var.gsub!(("||" + var), ("</" + var))
      end
      var
    end
    
    def self.add_syntax_highlights(arglist)
      var = var.split("\n");Fi[	@ái∏I"æ          var.id
        end
        (var[var] = { "_id" => ({ "$in" => (var) }) } and var = nil)
      end
      var
    end
    
    # Get all the push attributes that need to occur.
    #;Fi[	@áiÒI"Ó        var = nil
        var.each { |arglist| var ||= var.flag_as_destroyed }
        var.push((var or var))
      end
      var
    end
    
    # Get the prefix for field names to indicate a location in the db for
    # atomic updates.;Fi[	@ãi4I"»        end
        unless var.empty? then
          collection.find(selector).update("$pullAll" => ({ path => (var) }))
        end
        var
      end
      
      alias :delete_all :delete
      ;Fi[	@ãiGI"•        each do |arglist|
          documents.delete_one(var)
          var.destroy
        end
        var
      end
      
      alias :destroy_all :destroy
      ;Fi[	@ëièI"        var.reject! do |arglist|
          var = IdentityMap.get(klass, var)
          var and var.matches?(var) ? (var.push(var)) : (false)
        end
        var
      end
      
      # Convert all the ids to their proper types.
      #;Fi[	@ùiSI"∑          var.scoping_options = false, true
          var.selector.clear
          var.options.clear
        end
        var
      end
      
      # Is the criteria unscoped?
      #;Fi[	@ùiáI"ª        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      ;Fi[	@§iFI"‘      changed.each do |arglist|
        var = attribute_change(var)
        var[var] = var if var
      end
      var
    end
    
    # Call this method after save, so the changes can be properly switched.
    #;Fi[	@§iíI"â            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private
    ;Fi[	@L	i1I"€          else
            (var["$set"] ||= {}).merge!(var => (mongoize_for(var, var, var)))
          end
        end
        var
      end
      
      # Check if the hash is part of a blank relation criteria.
      #;Fi[	@L	ijI"‡        var.each do |arglist|
          var = (var[var] or var[var.to_i])
          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.;Fi[	@}	i2I"@          var = var.getlocal unless Mongoid::Config.use_utc?
          if Mongoid::Config.use_activesupport_time_zone? then
            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@£	i.I"}            end
          end
        end
      end
      var
    end
    
    # Marks all children as being persisted.
    #;Fi[	@±	inI">        var[:bucketSize] = var.delete(:bucket_size) if var.has_key?(:bucket_size)
        if var.has_key?(:expire_after_seconds) then
          var[:expireAfterSeconds] = var.delete(:expire_after_seconds)
        end
        var
      end
      
      # Normalize the spec, in case aliased fields are provided.
      #;Fi[	@â
iµI"O      unless var then
        self.class.fail_validate!(self) unless errors.empty?
        self.class.fail_callback!(self, :update_attributes!)
      end
      var
    end
    
    # Perform an upsert of the document. If the document does not exist in the
    # database, then Mongo will insert a new one, otherwise the fields will get;Fi[	@hi~I"          if insertable? then
            collection.find(selector).update(var => ({ path => (var) }))
            post_process_batch_insert(var)
          end
          var
        end
        
        # Are we in a state to be able to batch insert?
        #;Fi[	@∫iRI"        var = { :database => (database), :hosts => (hosts) }
        if username and password then
          var.merge!(:username => (username), :password => (password))
        end
        var
      end
      
      # Get the username provided in the URI.
      #;Fi[	@ÒifI"„          var.selector.update(criterion(var, var, var))
        else
          var = var.where(criterion(var, var, var))
        end
        var
      end
      
      # Get the default criteria for checking uniqueness.
      #;Fi[	@Òi|I"        var = { var => (filter(var)) }
        if var.persisted? and var.embedded?.! then
          var.merge!(:_id => ({ "$ne" => (var.id) }))
        end
        var
      end
      
      # Filter the value based on whether the check is case sensitive or not.
      #;Fi[	@˜iõI"ﬂ      var = {}
      var.except("versions").each_pair do |arglist|
        add_versioned_attribute(var, var, var)
      end
      var
    end
    
    # Add the versioned attribute. Will work now for localized fields.
    #;Fi[	@iEI"ı        (var << self) if (to_type == var)
        @var.each do |arglist|
          var = (var + var.find_by_type(var)) if var.respond_to?(:find_by_type)
        end
        var
      end
      
      # Convert to_type
      def function(arglist);Fi[	@
iaI"
          var.first
        else
          Node.new(:CONDITIONAL_SELECTOR, [var.first, var[1]])
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [var.first, Node.new(:COMBINATOR, [var[1], var.last])]);Fi[	@
iÙI"ó          else
            var = var
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then;Fi[	@
i˝I"·          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end
      
      def function(arglist)
        if (var[0] == "n") then;Fi[	@
iI"…          else
            raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
          end
        end
        var
      end
      
      def function(arglist)
        if (var[1] == "n") then;Fi[	@
iI"Ò          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end
      
      def function(arglist)
        var = Node.new(:PSEUDO_CLASS, [var[1]]);Fi[	@i1I"…      def function(arglist)
        return if @var.eos?
        until (var = _next_token or @var.eos?) do
        end
        var
      end
      
      def function(arglist)
        var = @var.peek(1);Fi[	@i=I"∏          var["xerces"] = Nokogiri::XERCES_VERSION
          var["nekohtml"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist)
      begin;Fi[	@Ki>I"®          else
            var.content = var
          end
        end
        var
      end
      
      # Create a Text Node with +string+
      def function(arglist);Fi[	@ci˚I"∆          var.each { |arglist| add_child_node(var) }
        else
          add_child_node(var)
        end
        var
      end
      
      ###
      # Add +node_or_tags+ as a child of this Node.;Fi[	@ciYI"¬          var.each { |arglist| add_child_node(var) }
        else
          add_child_node(var)
        end
        var
      end
      
      ####
      # Replace this Node with +node_or_tags+.;Fi[	@ciqI"ó          unlink
        else
          replace_node(var)
        end
        var
      end
      
      ####
      # Swap this Node for +node_or_tags+;Fi[	@ciÁI"X        if var.empty? and ((document.errors.length > var) and var.recover?) then
          var = Nokogiri::HTML::DocumentFragment.parse(var)
          var = var.children
        end
        var
      end
      
      ####
      # Set the Node's content to a Text node containing +string+. The string gets XML escaped, not interpreted as markup.;Fi[	@ciEI"‰          var.unlink if text?
        else
          send(var, var)
        end
        var
      end
      
      def function(arglist)
        if Nokogiri.uses_libxml? and ["2", "6"].===(LIBXML_VERSION.split(".")[(0..1)]) then;Fi[	@cimI"Œ        return fragment(var).children if var.is_a?(String)
        if (var.is_a?(Document) or (var.is_a?(XML::Attr) or var.is_a?(XML::Node).!)) then
          raise(ArgumentError, "Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.\n(You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)\n")
        end
        var
      end
      
      def function(arglist)
        "./";Fi[	@æiqI"ß          next
        end
        var[var] = var[var]
      end
      var
    end
    
    def function(arglist)
      if OmniAuth.config.camelizations[var.to_s] then;Fi[	@ÚiZI"i      end
      [:processors, :geometry, :format, :whiny, :convert_options, :source_file_options].each do |arglist|
        var = send(var) and var[var] = var
      end
      var
    end
    
    # Supports getting and setting style properties with hash notation to ensure backwards-compatibility
    # eg. @attachment.styles[:large][:geometry]@ will still work;Fi[	@ıiMI"F        end
      rescue Cocaine::CommandNotFoundError => var
        raise(Paperclip::Errors::CommandNotFoundError.new("Could not run the `convert` command. Please install ImageMagick."))
      end
      var
    end
    
    # Returns the command ImageMagick's +convert+ needs to transform the image
    # into the thumbnail.;Fi[	@*i$I"≈          var, var = self, []
          while var.parent do
            (var << (var = var.parent))
          end
          var
        end
        
        # Returns list of descendants.
        #;Fi[	@*i0I"          var = children.dup
          unless (var == 1) then
            var = (var + children.collect { |arglist| var.descendants((var - 1)) }.flatten)
          end
          var
        end
        
        # Returns list of descendants and a reference to the current node.
        #;Fi[	@*i@I"æ          var = self
          while var.parent do
            var = var.parent
          end
          var
        end
        
        # Returns all siblings of the current node.
        #;Fi[	@xiÌI"Á      var.gsub!("'", "&#039;") if (var == :Quotes)
      var.gsub!("<", "&lt;")
      var.gsub!(">", "&gt;")
    end
    var
  end
  
  # Search and replace for Textile glyphs (quotes, dashes, other symbols)
  def function(arglist);Fi[	@xi*I"°        end
        var
      end
    end
    var
  end
  
  def function(arglist)
    var.gsub!(/<redpre#(\d+)>/) { |arglist| @var[$1.to_i] } unless @var.empty?;Fi[	@Äi!I"â          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8(arglist)
      return var if var.nil?;Fi[	@ÄiII"î          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8_by_setting(arglist)
      return var if var.nil?;Fi[	@ôi3I"ï              end
            end
          end
        end
        var
      end
      
      def function(arglist)
        var.SetFontStyle("B", 8);Fi[	@™iaI"ﬂ        unless var.leaf? then
          (@var << var)
          var[:indent] += var[:indent_increment]
        end
        var
      end
      
      def function(arglist)
        if var.is_a?(Issue) and var.due_before then;Fi[	@™i£I"“          relations[var.id].each do |arglist|
            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist)
        var = "";Fi[	@ÖiI"ƒ      if var.nil? and var[:rescan].!=(false) then
        rescan
        var = theme(var, :rescan => (false))
      end
      var
    end
    
    class Theme
      attr_reader(:path, :name, :dir);Fi[	I",data//redmine_proj/redmine/thumbnail.rb;TiI"€          logger.error("Creating thumbnail failed (#{$?}):\nCommand: #{cmd}")
          return nil
        end
      end
      var
    end
    
    def self.convert_available?(arglist)
      return @var if defined? @var;Fi[	@i0I"·          var = partition(var, var, var)
          sort_multiple(var, var, (var - 1))
          sort_multiple(var, (var + 1), var)
        end
        var
      end
      
      def function(arglist)
        var = var[0][var];Fi[	@iCI"“        end
        var.each do |arglist|
          var[var], var[var], *s(:call, s(:lvar, :var), :[], s(:lvar, :var))
        end
        var
      end
      
      def function(arglist)
        if no_css then;Fi[	@,i2I"—        end
      else
        var = (var + redis.lrem(var, 0, encode("class" => (var), "args" => (var))))
      end
      var
    end
    
    def self.reserve(arglist)
      unless var = Resque.pop(var) then;Fi[	@?iI"‚    while var.skip_until(HIGH_BIT_RANGE) do
      var = var.pos = (var.pos - 1)
      var[var] = REPLACEMENT_CHAR if sequence_length(var).!
    end
    var
  end
  
  def self.sequence_length(arglist)
    var = var.get_byte[0];Fi[	@õi.I"Ô        next unless var =~ /resque/i
        next if var =~ /resque-web/
        var.push(var.split(" ")[0])
      end
      var
    end
    
    # Given a string, sets the procline ($0) and logs.
    # Procline is always in the format of:;Fi[	@l iI"˝        end
        unless @var.empty? then
          var = (var + "the extra elements were:        #{safe_sort(@extra_items).inspect}\n")
        end
        var
      end
      
      def function(arglist)
        "Matcher does not support should_not";Fi[	@€i°I"ı            @var.raise_wrong_arity_error(var, var.arity)
          end
          var = eval_block(*var, &var)
        end
        var
      end
      
      def function(arglist)
        @var ? (@var.instance_exec(*var, &var)) : (var.call(*var));Fi[	@9izI"„          var = 100.0
          if @var.!=(0) then
            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing;Fi[	@qiI"µ              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      
      def function(arglist)
        (@var == true);Fi[	@ñ$i*I"µ      else
        var["properties"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist)
    self.extend(SiriRootObject);Fi[	@ÿiæI"∆      inject_object_to_output_stream(var)
      block_rest_of_session if plugin_manager.process(var)
      return nil
    end
    var
  end
  
  #Stub -- override in subclass
  def function(arglist);Fi[	@ iI"R        var = self.attribute.to_sym
        if ((var == :state) or ((var == :event) and var)) and (owner_class.columns.include?(var) and var.changed_columns.include?(var).!) then
          (var.changed_columns << var)
        end
        var
      end
      
      # Adds a validation error to the given object
      def function(arglist);Fi[	I"Adata//state_machine_proj/state_machine/machine_collection.rb;Ti-I"$            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    
    # Runs one or more events in parallel on the given object.  See
    # StateMachine::InstanceMethods#fire_events for more information.;Fi[	@’i{I"[      var = var ? (var.to_s) : (var.inspect)
      unless (name.to_s == @var.to_s) then
        (var << " (#{@value.is_a?(Proc) ? ("*") : (@value.inspect)})")
      end
      var
    end
    
    # The value that represents this state.  This will optionally evaluate the
    # original block if it's a lambda block.  Otherwise, the static value is;Fi[	@’iÿI"      var = var.add_node((name ? (name.to_s) : ("nil")), :label => (description(var)), :width => "1", :height => "1", :shape => (final? ? ("doublecircle") : ("ellipse")))
      if initial? then
        var.add_edge(var.add_node("starting_state", :shape => "point"), var)
      end
      var
    end
    
    # Generates a nicely formatted description of this state's contents.
    # ;Fi[	@!iLI"¿          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      
      # Take an owner and merge it into the hash with the correct key
      #;Fi[	@DiìI"Á          var[[var, "user_id"].compact.join("_").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      
      # Take a multiple users and merge them into the hash with the correct keys
      #;Fi[	@ÖiI"Õ        else
          var = var
          var = [var] unless var and var.respond_to?(:each)
        end
        var
      end
      
      def self.output(arglist)
        enumerate(var).each do |arglist|;Fi[@'@¸I"protected;FI" ;FiÜ[Ü[	@˝iI"‚      #:nodoc:
      def function(arglist)
        @var ||= Module.new.tap { |arglist| include(var) }
      end
      
      protected
      
      def function(arglist)
        generated_attribute_methods.method_defined?(var);Fi[	@˝iáI"—          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var);Fi[	@Ki&I"Ô            var[:type] = (type == :string) ? (nil) : (type)
            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist)
            return if value.nil?;Fi[	@ViWI"÷          end
          set_callback(:validation, :after, *(var << var), &var)
        end
      end
      
      protected
      
      # Overwrite run validations to include callbacks.
      def function(arglist);Fi[	@ji1I"            end)
          end
        end
      end
      
      protected
      
      def function(arglist)
        case var;Fi[	@piéI"'        var = var.extract_options!
        var[:strict] = true
        validates(*(var << var))
      end
      
      protected
      
      # When creating custom validators, it might be useful to be able to specify
      # additional default keys. This can be done by overwriting this method.;Fi[	@ΩiTI"Ñ        else
          # do nothing
        end
      end
      
      protected
      
      def function(arglist)
        var = [];Fi[	@i$I"¯      # Returns the primary key value before type cast.
      def function(arglist)
        read_attribute_before_type_cast(self.class.primary_key)
      end
      
      protected
      
      def function(arglist)
        ((var == "id") or super);Fi[	@i%I"J        # Returns +true+ if the provided attribute is being cached.
        def function(arglist)
          cached_attributes.include?(var)
        end
        
        protected
        
        # We want to generate the methods via module_eval rather than
        # define_method, because define_method is slower on dispatch and;Fi[	@i I"Ë    #   person[:age] # => Fixnum
    def function(arglist)
      write_attribute(var, var)
    end
    
    protected
    
    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) };Fi[	@0i^I"Î      def function(arglist)
        var = subquery_for(var, var)
        var.where(var.in(var))
      end
      
      protected
      
      # Return a subquery for the given key using the join information.
      def function(arglist);Fi[	@>i^I"Â      def function(arglist)
        remove_column(var, :updated_at)
        remove_column(var, :created_at)
      end
      
      protected
      
      def function(arglist)
        if var.is_a?(Hash) and var = var[:order] then;Fi[	@FiI"ƒ      # Check the connection back in to the connection pool
      def function(arglist)
        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin;Fi[	@Ii:I"      
      def function(arglist)
        @var.fetch(:strict, true)
      end
      
      protected
      
      # MySQL is too stupid to create a temporary table for use subquery, so we have
      # to give it some prompting in the form of a subsubquery. Ugh!;Fi[	@çiµI"          raise(ActiveRecord::ActiveRecordError, "Missing column #{table_name}.#{column_name}")
        end
        alter_table(var, :rename => ({ var.to_s => (var.to_s) }))
      end
      
      protected
      
      def function(arglist)
        exec_query(var, var, var);Fi[	@•i`I"<      
      def function(arglist)
        store_full_sti_class ? (name) : (name.demodulize)
      end
      
      protected
      
      # Returns the class type of the record using the current module as a prefix. So descendants of
      # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.;Fi[	@‚i*I"ï            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then;Fi[	@‚icI"Ë    
    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))))
    end
    
    protected
    
    def function(arglist)
      if @var.respond_to?(var) then;Fi[	@ºiØI"{      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist)
      begin;Fi[	@¯iI"_      # Used to sanitize objects before they're used in an SQL SELECT statement. Delegates to <tt>connection.quote</tt>.
      def function(arglist)
        connection.quote(var)
      end
      
      protected
      
      # Accepts an array, hash, or string of SQL conditions and sanitizes
      # them into a valid SQL fragment for a WHERE clause.;Fi[	@˝i0I"Í        #:nodoc:
        def function(arglist)
          self.current_scope = nil
        end
        
        protected
        
        # Use this macro in your model to set a default scope for all operations on
        # the model.;Fi[	@iI"≈        self.stored_attributes[var] ||= []
        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist)
      var = initialize_store_attribute(var);Fi[	@'iëI"ÿ        raise(ActiveRecord::Rollback) unless var
      end
      var
    end
    
    protected
    
    # Save the new record state and id of a record so it can be restored later if a transaction fails.
    #:nodoc:;Fi[	@2iI"	          var[:value] = var
          var.errors.add(var, :taken, var)
        end
      end
      
      protected
      
      # The check for an existing value should be run from a class that
      # isn't abstract. This means working down from the current class;Fi[	@ªi>I"√      var ||= new_record? ? (:create) : (:update)
      var = super(var)
      errors.empty? and var
    end
    
    protected
    
    def function(arglist)
      var = var[:validate].!=(false);Fi[	@5iI"·        set_local_assigns!
        validate_file_name!
        migration_template("migration.rb", "db/migrate/#{file_name}.rb")
      end
      
      protected
      
      attr_reader(:migration_action, :join_tables)
      ;Fi[	@Xi#I"Ö          var = ("#{self}##{name} has been deprecated as of " + "backup v.#{deprecation[:version]}")
          (var << "\n#{deprecation[:message]}") if var[:message]
          Logger.warn(Backup::Errors::ConfigurationError.new("            [DEPRECATION WARNING]\n            #{msg}\n"))
        end
        
        protected
        
        ##
        # Method to deprecate an attribute.;Fi[	I"6data//bundler_proj/bundler/similarity_detector.rb;TiI"·      else
        [var[(0..-2)].join(", "), var[-1]].join(" or ") if (var.length > 1)
      end
    end
    
    protected
    
    # http://www.informit.com/articles/article.aspx?p=683059&seqNum=36
    def function(arglist);Fi[	@ri>I"ﬁ          File.open(destination, "wb") { |arglist| var.write(render) }
        end
        given_destination
      end
      
      protected
      
      # Now on conflict we check if the file is identical or not.
      #;Fi[	@xiII"ü      
      def function(arglist)
        execute!
      end
      
      protected
      
      def function(arglist)
        var = Util.escape_globs(source);Fi[	@i6I"         say_status(:remove, :red)
        ::FileUtils.rm_rf(destination) if pretend?.! and exists?
        given_destination
      end
      
      protected
      
      # Shortcut for pretend.
      #;Fi[	@ÖiDI"—          /(#{Regexp.escape(replacement)})(.*)(#{flag})/m
        end
        replace!(var, var, true)
      end
      
      protected
      
      def function(arglist)
        var = if (var == :invoke) then;Fi[	@åiI"      var.push(Thor::Options.to_switches(var))
      var = var.join(" ").strip
      run(var, :with => :thor, :verbose => (var), :pretend => (var), :capture => (var))
    end
    
    protected
    
    # Allow current root to be shared between invocations.
    #;Fi[	@èi)I"·      # Convert to a Hash with String keys.
      def function(arglist)
        Hash.new(default).merge!(self)
      end
      
      protected
      
      def function(arglist)
        var.is_a?(Symbol) ? (var.to_s) : (var);Fi[	@iÄI"◊    # Invokes using shell padding.
    def function(arglist)
      with_padding { |arglist| invoke(*var) }
    end
    
    protected
    
    # Configuration values that are shared between invocations.
    #:nodoc:;Ti[	@ôi-I"â      else
        default
      end
    end
    
    protected
    
    def function(arglist)
      if required? and default.nil?.! then;Fi[	@ìiFI"¸    
    VALID_TYPES.each do |arglist|
      class_eval("        def #{type}?\n          self.type == #{type.inspect}\n        end\n", "(string)", (101 + 1))
    end
    
    protected
    
    def function(arglist)
      if boolean? and required? then;Fi[	@üi}I"›      unless var.empty? then
        raise(UnknownArgumentError, "Unknown switches '#{unknown.join(", ")}'")
      end
    end
    
    protected
    
    # Check if the current value in peek is a registered switch.
    #;Fi[	@§iÌI"ü      #
      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist)
        return var unless var.is_a?(Symbol);Fi[	@ßihI"·          var = var ? (BOLD) : ("")
          "#{bold}#{foreground}#{string}#{CLEAR}"
        end
      end
      
      protected
      
      # Overwrite show_diff to show diff with colors if Diff::LCS is
      # available.;Fi[	@¨iVI"      # TODO: Implement #ask for Thor::Shell::HTML
      def function(arglist)
        raise(NotImplementedError, "Implement #ask for Thor::Shell::HTML")
      end
      
      protected
      
      # Overwrite show_diff to show diff with colors if Diff::LCS is
      # available.;Fi[	@iMI"ã      ensure
        shell.padding -= 1
      end
    end
    
    protected
    
    # Allow shell to be shared between invocations.
    #;Fi[	@±iJI"ø      end))
      (var << " #{required_options}")
      var.strip
    end
    
    protected
    
    def function(arglist)
      (var.class.respond_to?(:debugging) and var.class.debugging).!;Fi[	@πiLI"§          end
        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then;Fi[	@ imI"⁄        var = execute_task(var)
        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist)
        return if Thread.current[:rollback_requests].nil?;Fi[	@4i@I">          var = var.reject { |arglist| var.any? { |arglist| (var.options[var] == var) } }
          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist)
        return var unless (ENV["HOSTFILTER"] or ENV["HOSTROLEFILTER"]);Fi[	@åi#I"⁄            var.remote.writable(configuration[:deploy_to]).or("You do not have permissions to write to `#{configuration[:deploy_to]}'.")
            var.remote.writable(configuration[:releases_path]).or("You do not have permissions to write to `#{configuration[:releases_path]}'.")
          end
        end
        
        protected
        
        # This is to allow helper methods like "run" and "put" to be more
        # easily accessible to strategy implementations.;Fi[	@†iI"        
        def function(arglist)
          super.check { |arglist| var.remote.command(source.command) }
        end
        
        protected
        
        # Runs the given command, filtering output back through the
        # #handle_data filter of the SCM implementation.;Fi[	@_i1I"í    
    def function(arglist)
      servers.include?(var)
    end
    
    protected
    
    class DynamicServerList
      def function(arglist);Fi[	@’i#I"∑      
      def function(arglist)
        @var = true
      end
      
      protected
      
      def function(arglist)
        unless Compass::Frameworks[options[:framework]] then;Fi[	@€iI"ñ      
      def function(arglist)
        super
      end
      
      protected
      
      def function(arglist)
        add_project_configuration;Fi[	@iI"q        end
        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin;Fi[	@xi"I"±        return 1
      end
      return 0
    end
    
    protected
    
    def function(arglist)
      options[:command] ? (do_command(options[:command])) : (puts(self.opts));Fi[	@£iI"≈      (var << "#{url} format('#{args.shift}')")
    end
    Sass::Script::String.new(var.join(", "))
  end
  
  protected
  
  def function(arglist)
    var = [var].flatten.pack("m").gsub("\n", "");Fi[	@çi^I"{        var
      end
    end
  end
  
  protected
  
  def function(arglist)
    unless var.is_a?(Sass::Script::List) then;Fi[	@¶i∏I"7  
  def function(arglist)
    raise(Sass::SyntaxError, "The sprite-image() function has been replaced by sprite(). See http://compass-style.org/help/tutorials/spriting/ for more information.")
  end
  
  protected
  
  def function(arglist)
    if Sass::Script::Color.const_defined?(:HTML4_COLORS_REVERSE) then;Fi[	@ûiI"    # This method swiped from Haml and then modified, some credit goes to Nathan Weizenbaum
    def function(arglist)
      defined? @var ? (@var) : (read_version)
    end
    
    protected
    
    def function(arglist)
      File.join(File.dirname("(string)"), "..", "..", var);Fi[	@¨i—I"‚        (@var.values_at(:name_regexps, :tag_expressions).select do |arglist|
          var.empty?.!
        end.first or [])
      end
      
      protected
      
      attr_reader(:options, :profiles, :expanded_args)
      ;Fi[	@«iGI"ê      
      def function(arglist)
        @var = []
      end
      
      protected
      
      def function(arglist)
        var = Array.new;Fi[	@iI"©      
      def function(arglist)
        load(File.expand_path(var))
      end
      
      protected
      
      def function(arglist)
        begin_rb_scenario(var);Fi[	@Vi%I"‡      
      def function(arglist)
        @var.map { |arglist| var.step_matches(var, var) }.flatten
      end
      
      protected
      
      def function(arglist)
        @var.each { |arglist| var.begin_scenario(var) };Fi[	@ni"I",        var = Devise::Mapping.find_scope!(var)
        var.forget_me!
        cookies.delete(remember_key(var, var), forget_cookie_values(var))
      end
      
      protected
      
      def function(arglist)
        Devise::Controllers::Rememberable.cookie_values.merge!(var.rememberable_options);Fi[	@riAI"¬        flash[:alert] = i18n_message
      end
      redirect_to(redirect_url)
    end
    
    protected
    
    def function(arglist)
      var = (warden_message or (var or :unauthenticated));Fi[	@{iI"Â      included do |arglist|
        include(Devise::Controllers::ScopedViews)
        attr_reader(:scope_name, :resource)
      end
      
      protected
      
      # Configure default email options
      def function(arglist);Fi[	@Éi8I"Í      
      var.each do |arglist|
        class_eval("          # Redefine to_xml and serializable_hash in models for more secure defaults.\n          # By default, it removes from the serializable model all attributes that\n          # are *not* accessible. You can remove this default by using :force_except\n          # and passing a new list of attributes you want to exempt. All attributes\n          # given to :except will simply add names to exempt to Devise internal list.\n          def #{method}(options=nil)\n            options ||= {}\n            options[:except] = Array(options[:except])\n\n            if options[:force_except]\n              options[:except].concat Array(options[:force_except])\n            else\n              options[:except].concat BLACKLIST_FOR_SERIALIZATION\n            end\n            super(options)\n          end\n", "(string)", 119)
      end
      
      protected
      
      # to_xml does not call serializable_hash on 3.1
      def function(arglist);Fi[	@Éi∫I"“            end
          end
          var
        end
        
        protected
        
        def function(arglist)
          @var ||= Devise::ParamFilter.new(case_insensitive_keys, strip_whitespace_keys);Fi[	@äi`I"˘      # to be generated, call skip_reconfirmation!
      def function(arglist)
        @var = true
      end
      
      protected
      
      # A callback method used to deliver confirmation
      # instructions on creation. This can be overriden;Fi[	@çiXI"      # A reliable way to expose the salt regardless of the implementation.
      def function(arglist)
        encrypted_password[0, 29] if encrypted_password
      end
      
      protected
      
      # Digests the password using bcrypt.
      def function(arglist);Fi[	@íiaI"¨            super
          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts);Fi[	@òi6I"      #
      def function(arglist)
        reset_password_sent_at and (reset_password_sent_at.utc >= self.class.reset_password_within.ago)
      end
      
      protected
      
      def function(arglist)
        (reset_password_token.nil? or reset_password_period_valid?.!);Fi[	@†i>I"…      
      def function(arglist)
        self.class.rememberable_options
      end
      
      protected
      
      def function(arglist)
        respond_to?(:remember_token) and remember_expired?;Fi[	@¨i I"â        unless var.empty? then
          raise(("Could not use :validatable module since #{base} does not respond " << "to the following methods: #{unavailable_validations.to_sentence}."))
        end
      end
      
      protected
      
      # Checks whether a password is needed or not. For validations only.
      # Passwords are always required if it's a new record, or if the password;Fi[	@ùi;I"]      @var.instance_variable_set(:"@current_#{var}", nil)
      var = warden.instance_variable_get(:@users).delete(var)
      warden.session_serializer.delete(var, var)
    end
    
    protected
    
    # Catch warden continuations and handle like the middleware would.
    # Returns nil when interrupted, otherwise the normal result of the block.;Fi[	@§iI"Ï        view_directory(:registrations)
        view_directory(:sessions)
        view_directory(:unlocks)
      end
      
      protected
      
      def function(arglist)
        directory(var.to_s, (var or "#{target_path}/#{name}"));Fi[	@i`I"∫    @var.favorite = @var.favorite.!
    @var.save
    render(:nothing => (true), :status => 202)
  end
  
  protected
  
  #checks whether current user can see it
  def function(arglist);Fi[	@ói5I"Å  def function(arglist)
    self.profile.tombstone!
    self
  end
  
  protected
  
  def function(arglist)
    if self.url then;Fi[	@£i™I"¡    clearable_fields.each { |arglist| self[var] = nil }
    self[:searchable] = false
    self.save
  end
  
  protected
  
  def function(arglist)
    self.first_name.strip! if self.first_name;Fi[	@±iüI"˚    require("uri")
    var = URI.extract(self.raw_message, ["http", "https"])
    self.oembed_url = var.find { |arglist| TRUSTED_OEMBED_PROVIDERS.find(var).nil?.! }
  end
  
  protected
  
  def function(arglist)
    unless text_and_photos_blank? then;Fi[	@Â#izI"®  
  def function(arglist)
    ::EvilQuery::ShareablesFromPerson.new(self, Photo, var).make_relation!
  end
  
  protected
  
  # @return [Hash]
  def function(arglist);Fi[	@Ô#iI"Ö  
  def function(arglist)
    (@var.try(:person) == @var)
  end
  
  protected
  
  def function(arglist)
    @var.shares_with(@var);Fi[	@“i7I"z  
  def function(arglist)
    @var.reshare_for(@var)
  end
  
  protected
  
  def function(arglist)
    @var.person;Fi[	@Ei1I"Ê      # @return [String] A description of the executable
      def function(arglist)
        @var.to_s
      end
      
      protected
      
      # Finds the line of the source template
      # on which an exception was raised.;Fi[	I"$data//homebrew_proj/hardware.rb;TiDI"á  
  def self.bits(arglist)
    Hardware.is_64_bit? ? (64) : (32)
  end
  
  protected
  
  def self.sysctl_bool(arglist)
    var = nil;Fi[	@´i±I"•      var.directory? ? (var.rmdir) : (var.delete if var.exist?)
    end
    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin;Fi[	@…iI"±      
      def function(arglist)
        var.to_json(process_options(var))
      end
      
      protected
      
      def function(arglist)
        return var if var.empty?;Fi[	@ˆiI"]  
  def function(arglist)
    @var.to_s
  end
  
  protected
  
  attr_reader(:elem)
  ;Fi[	@ˆi^I"‹  def self.parse(arglist)
    var = _parse(var)
    Version.new(var, true) unless var.nil?
  end
  
  protected
  
  def function(arglist)
    @var ||= @var.scan(/\d+|[a-zA-Z]+/).map { |arglist| VersionElement.new(var) };Fi[	@Ω	i'I"ß        else
          var.===(attribute)
        end
      end
      
      protected
      
      # Convenience method for getting the first value in a hash.
      #;Fi[	@Â	iFI"ê      else
        super
      end
    end
    
    protected
    
    def function(arglist)
      return nil if var.all? { |arglist| var.nil? };Fi[	@Â
iI"∑      # @since 2.0.0.rc.1
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      protected
      
      # Get the class from the metadata.
      #;Fi[	@h$iVI"À    def function(arglist)
      footer
      Rack::Response.new(@var).finish
    end
    
    protected
    
    def function(arglist)
      "\n<style type='text/css'>#{OmniAuth.config.form_css}</style>";Fi[	@≥i»I"â    end
    
    class Options < Hashie::Mash
    end
    
    protected
    
    def function(arglist)
      var.inject({}) do |arglist|;Fi[	I"Edata//paperclip_proj/generators/paperclip/paperclip_generator.rb;TiI"˜  
  def function(arglist)
    migration_template("paperclip_migration.rb.erb", "db/migrate/#{migration_file_name}")
  end
  
  protected
  
  def function(arglist)
    "add_attachment_#{attachment_names.join("_")}_to_#{name.underscore.pluralize}";Fi[	@«i(I"ﬂ        
        def function(arglist)
          "have an attachment named #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          var = @var.instance_methods.map(&:to_s);Fi[	@Ãi6I"Â        
        def function(arglist)
          "validate the content types allowed on attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          if @var.present? then;Fi[	@’i'I"Ÿ        
        def function(arglist)
          "require presence of attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          @var.send(@var).assign(nil);Fi[	@⁄i:I"À        
        def function(arglist)
          "validate the size of attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          class << var;Fi[	@ıi[I"¸      ((var << "-resize") << "\"#{scale}\"") unless (var.nil? or var.empty?)
      (((var << "-crop") << "\"#{crop}\"") << "+repage") if var
      var
    end
    
    protected
    
    # Return true if the format is animated
    def function(arglist);Fi[	@7iI"g          self_and_descendants.map do |arglist|
            "#{("*" * (node.level + 1))} #{node.id} #{node.to_s} (#{node.parent_id}, #{node.left}, #{node.right})"
          end.join("\n")
        end
        
        protected
        
        def function(arglist)
          var.where(["#{self.class.quoted_table_name}.#{self.class.primary_key} != ?", self]);Fi[	@1 iYI"º      end
    end
    return var
  end
  
  protected
  
  # The parameter name of "openid_identifier" is used rather than
  # the Rails convention "open_id_identifier" because that's what;Fi[	@ iâI"†          @var = nil
          @var = nil
          super
        end
        
        protected
        
        def function(arglist)
          var = var.to_s;Fi[	@˘iI"Æ      def function(arglist)
        super
        self.top_align = self.top_font = 1
      end
      
      protected
      
      def function(arglist)
        @var[:fields];Fi[	@iI"        super
        init_with(:rotate_y_labels => (true), :show_x_guidelines => (true), :show_y_guidelines => (false))
        self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = max_value;Fi[	@	i'I"7      def function(arglist)
        init_with(:show_data_points => (true), :show_data_values => (true), :stacked => (false), :area_fill => (false))
        self.top_align = self.top_font = self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = 0;Fi[	@iJI"ø        sort(var, var)
        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var.collect { |arglist| var[:title] };Fi[	@i\I"±        end
        sort(var, var, var)
        @var = [var, var, var]
      end
      
      protected
      
      def function(arglist)
        var = ParseDate.parsedate(var);Fi[	@iKI"ª        sort(var, var)
        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var = DateTime.parse(var).to_time;Fi[	@]iDI"´        
        def function(arglist)
          @var[var]
        end
        
        protected
        
        def function(arglist)
          if var = var[:type] then;Fi[	I"5data//rspec_proj/spec/example/example_matcher.rb;TiI"]        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist)
        var =~ /(^#{example_group_regex} #{example_regexp}$|^#{example_group_regex}$|^#{example_group_with_before_all_regexp}$|^#{example_regexp}$)/;Fi[	@€içI"Œ      def function(arglist)
        (var << var) unless var.nil?
        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin;Fi[	@€i'I"ù      
      def function(arglist)
        return false
      end
      
      protected
      
      def function(arglist)
        @var = (var == :at_least);Fi[	@iEI"Â            end
            (var << "\n")
            (var or var) ? ((var << diff_as_object(var, var))) : (var)
          end
          
          protected
          
          def function(arglist)
            @var.diff_format;Fi[	@"iI"Œ        example_groups.each { |arglist| var = var.&(var.run(@var)) }
        finish
        var
      end
      
      protected
      
      def function(arglist)
        reporter.start(number_of_examples);Fi[	@*iWI"‰        def function(arglist)
          return "" if var.nil?
          var.map { |arglist| backtrace_line(var) }.join("\n")
        end
        
        protected
        
        def function(arglist)
          @var.colour.!.!;Fi[	@ni!I"π      def function(arglist)
        determine_best_match(var, var)
        best_match[:line]
      end
      
      protected
      
      def function(arglist)
        best_match.clear;Fi[	@qi˙I"÷      
      def function(arglist)
        @var.to_i if defined? @var
      end
      
      protected
      
      def function(arglist)
        Spec::Runner.configuration.predicate_matchers.each_pair do |arglist|;Fi[	@ÿiéI"ÿ        end
        var
      end
    end
    
    protected
    
    # Builds a matcher strategy to use for the given options.  If neither a
    # whitelist nor a blacklist option is specified, then an AllMatcher is;Fi[	@Çi“I"ı        end * ", ")
      end
      "#<#{self.class} name=#{name.inspect} transitions=[#{(transitions * ", ")}]>"
    end
    
    protected
    
    # Add the various instance methods that can transition the object using
    # the current event;Fi[	I"9data//state_machine_proj/state_machine/extensions.rb;TiäI"=    def function(arglist)
      var = [true, false].include?(var.last) ? (var.pop) : (true)
      (fire_events(*(var + [var])) or raise(StateMachine::InvalidParallelTransition.new(self, var)))
    end
    
    protected
    
    def function(arglist)
      self.class.state_machines.initialize_states(self, var, &var);Fi[	@îi2I"9      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?
      end
      
      protected
      
      # Whether observers are supported in the integration.  Only true if
      # ActiveModel::Observer is available.;Fi[	@ûiI"ﬂ      def self.extended(arglist)
        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist);Fi[	@≤i/I"(      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?
      end
      
      protected
      
      # Initializes class-level extensions and defaults for this machine
      def function(arglist);Fi[	@∫iI"€      
      def self.matching_ancestors(arglist)
        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist);Fi[	@¬iI"Ÿ      def self.extended(arglist)
        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist);Fi[	@ i5I"¿      def function(arglist)
        load_inflector
        super
      end
      
      protected
      
      # Initializes class-level extensions for this machine
      def function(arglist);Fi[	I">data//state_machine_proj/state_machine/node_collection.rb;TiöI"K    #   collection['invalid', :value]   # => IndexError: "invalid" is an invalid value
    def function(arglist)
      (self[var, var] or raise(IndexError, "#{key.inspect} is an invalid #{index_name}"))
    end
    
    protected
    
    # Gets the given index.  If the index does not exist, then an ArgumentError
    # is raised.;Fi[	@ÿiHI"i      else
        success?
      end
    end
    
    protected
    
    attr_reader(:results)
    ;Fi[	@Ìi(I"–          define_macro_methods
          define_state_methods
          define_event_methods
        end
        
        protected
        
        # Extracts the machine name's
        def function(arglist);Fi[	I"'data//twitter_proj/twitter/base.rb;TiTI"ô    def function(arglist)
      @var.update(var)
      self
    end
    
    protected
    
    # @param attr [Symbol]
    # @param other [Twitter::Base];Fi[	I"'data//twitter_proj/twitter/size.rb;TiI"√    # @return [Boolean]
    def function(arglist)
      (super or (size_equal(var) or attrs_equal(var)))
    end
    
    protected
    
    # @param other [Twitter::Size]
    # @return [Boolean];Fi[	@Íi.I"Ö          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file]);Fi[	@Öi7I"‘        else
          parse_time
        end
      end
      
      protected
      
      def function(arglist)
        var = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];Fi[	@Òi"I"®    
    def function(arglist)
      (roles.empty? or roles.include?(var))
    end
    
    protected
    
    def function(arglist)
      var.gsub(/:\w+/) do |arglist|;Fi[	@ãiI"ò        else
          ""
        end
      end
      
      protected
      
      def function(arglist)
        return unless @var.has_key?(:standard);Fi[@'@(@éI"private;Fi[[	@i4I"—      var.each do |arglist|
        define_callbacks(var, var)
        var.each { |arglist| send("_define_#{type}_model_callback", self, var) }
      end
    end
    
    private
    
    def function(arglist);Fi[	@Ki`I"∂            add_extra_behavior
            add_procs
            yield(@var) if block_given?
          end
        end
        
        private
        
        def function(arglist);Fi[	@YiI"      def function(arglist)
        unless (delimiter.respond_to?(:include?) or (delimiter.respond_to?(:call) or delimiter.respond_to?(:to_sym))) then
          raise(ArgumentError, ERROR_MESSAGE)
        end
      end
      
      private
      
      def function(arglist);Fi[	@ûi5I"Õ          var = options[MESSAGES[var]]
          var[:message] ||= var if var
          var.errors.add(var, MESSAGES[var], var)
        end
      end
      
      private
      
      def function(arglist);Fi[	@i$I"          else
            var
          end
        end
      end
      
      private
      
      def function(arglist);Fi[	@†i9I"ƒ          else
            # do nothing
          end
        end
      end
      
      private
      
      # The reason that the save param for replace is false, if for create (not just build),;Fi[	@ÚiI"ﬂ          var.each do |arglist|
            var.map! { |arglist| var.send(source_reflection.name) }.flatten!
            var.compact!
          end
        end
        
        private
        
        def function(arglist);Fi[	@ivI"®          read_time
        else
          (var == Date) ? (read_date) : (read_other(var))
        end
      end
      
      private
      
      def function(arglist);Fi[	@i5I"Ω        super.tap do |arglist|
          @var.clear
          @var.clear
        end
      end
      
      private
      
      # Wrap write_attribute to remember original attribute value.;Fi[	@i!I"Æ          else
            var.number? ? (var.zero?.!) : (var.blank?.!)
          end)
        end
      end
      
      private
      
      # Handle *? for method_missing.;Fi[	@"i+I"ƒ            generated_attribute_methods.module_eval(var, "(string)", var)
          else
            super
          end
        end
        
        private
        
        def function(arglist);Fi[	@"i2I"        
        def function(arglist)
          time_zone_aware_attributes and (self.skip_time_zone_conversion_for_attributes.include?(var.to_sym).! and [:datetime, :timestamp].include?(var.type))
        end
      end
      
      private
      
      def function(arglist);Fi[	@(iEI"‡        def function(arglist)
          synchronize do |arglist|
            var ? ((no_wait_poll or wait_poll(var))) : (no_wait_poll)
          end
        end
        
        private
        
        def function(arglist);Fi[	@(i1I"          connections.dup.each do |arglist|
            remove(var) if var.in_use? and ((var > var.last_use) and var.active?.!)
          end
        end
      end
      
      private
      
      # Acquire a connection by one of 1) immediately removing one;Fi[	@(i¿I"¨            break unless (var <= Base))
          end
          class_to_pool[var.name] = var)
        end
      end
      
      private
      
      def function(arglist);Fi[	@Li&I"≠            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        
        def function(arglist);Fi[	@ViëI"û          exec_query("BEGIN")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      
      def function(arglist);Fi[	@bi}I"•            else
              var
            end
          end
        end
        
        private
        
        HstorePair = (var = /"[^"\\]*(?:\\.[^"\\]*)*"/;Fi[	@ïiVI"}          self
        else
          superclass.arel_engine
        end
      end
      
      private
      
      #:nodoc:;Fi[	@•ivI"ﬂ            end
          end
          raise(NameError, "uninitialized constant #{candidates.first}")
        end
      end
      
      private
      
      # Called by +instantiate+ to decide which class to use for a new;Fi[	@•i¢I",          raise(ActiveRecord::SubclassNotFound.new("Invalid single-table inheritance type: #{subclass_name} is not a subclass of #{name}"))
        end
        var
      end
    end
    
    private
    
    # Sets the attribute used for single table inheritance to this class name if this is not the;Fi[	@ÀilI"Ô        @var.except!(*var.keys)
        var = self.class.primary_key
        (self.class.unscoped.where(var => (self[var])).update_all(var) == 1)
      end
    end
    
    private
    
    # A hook to be overridden by association modules.;Fi[	@õi&I"°      rescue Exception => var
        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    
    def function(arglist);Fi[	@éiMI"¢        else
          raise("Primary key not included in the custom select clause")
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@i,I"ú      if var.!=(var[var]) then
        send(:"#{var}_will_change!")
        var[var] = var
      end
    end
    
    private
    
    def function(arglist);Fi[	@√iUI"’        Logger.message("#{self.class} Complete!")
      else
        raise(Errors::Archive::PipelineError, ("Failed to Create Backup Archive\n" + var.error_messages))
      end
    end
    
    private
    
    ##;Fi[	@Xi>I"“        #
        def function(arglist)
          deprecations[var] = { :version => (nil), :message => (nil), :action => (nil) }.merge(var)
        end
      end
      
      private
      
      # ClassMethods;Fi[	@ciKI"ã        ensure
          (unlock_database if @var
          package! unless var)
        end
      end
      
      private
      
      ##;Fi[	@fiGI"È          Logger.message("#{database_name} Complete!")
        else
          raise(Errors::Database::PipelineError, ("#{database_name} Dump Failed!\n" + var.error_messages))
        end
      end
      
      private
      
      ##;Fi[	@oi/I"±            run("#{command} -c #{backup_file} > #{(backup_file + ext)}")
            FileUtils.rm_f(var)
          end
        end
      end
      
      private
      
      ##;Fi[	@xidI"®          yield("#{utility(:gpg)} #{base_options} #{mode_options}", ".gpg"))
        ensure
          cleanup
        end
      end
      
      private
      
      ##;Fi[	@Åi?I"y        if var then
          log!
          notify!(var)
        end
      end
      
      private
      
      ##;Fi[	@“iRI"1              Parallel.each(all_file_names, { :in_processes => (var) }, &var)
            else
              raise(Errors::Syncer::Cloud::ConfigurationError, "Unknown concurrency_type setting: #{concurrency_type.inspect}")
            end
          end
          
          private
          
          ##;Fi[	@ÛiI"ä            end)
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##;Fi[	@¯i5I"È            run(("#{utility(:rsync)} #{options} #{directories_option} " + "'#{username}@#{ip}:#{dest_path}'")))
          ensure
            remove_password_file!
          end
        end
        
        private
        
        ##;Fi[	@ iI"å          # do nothing
        end
        raise(RubyVersionMismatch, var)
      end
    end
    
    private
    
    def function(arglist);Fi[	@?i~I"´        @var.uniq!
      else
        raise(ArgumentError, "Source must be an index, not #{index.class}")
      end
    end
    
    private
    
    def function(arglist);Fi[	@i!I"í        return @var)
      ensure
        Bundler.settings[:frozen] = "1" if var
      end
    end
    
    private
    
    def function(arglist);Fi[	@iîI"Ë          Bundler.ui.warn("Skipped #{skipped} since they already exist."))
        end
        Bundler.ui.warn("If you want to overwrite skipped stubs, use --force.")
      end
    end
    
    private
    
    def function(arglist);Fi[	@8iπI"∏          var.unshift("-I#{File.expand_path("../..", "(string)")}")
        end
        ENV["RUBYOPT"] = var.join(" ")
      end
    end
    
    private
    
    def function(arglist);Fi[	@Ci?I"            git("fetch --force --quiet --tags \"#{path}\"")
            git("reset --hard #{@revision}")
            git("submodule update --init --recursive") if var
          end
        end
        
        private
        
        # TODO: Do not rely on /dev/null.;Fi[	@giWI"¢          tell_me(var, nil, var)
        else
          STDERR.puts("#{msg}#{newline}") if @var
        end
      end
      
      private
      
      # valimism;Fi[	@øixI"≤          else
            @var.scoped(:conditions => (conditions), :joins => (joins))
          end
        end
      end
      
      private
      
      def function(arglist);Fi[	@iƒI"Ú            var.hosts.each { |arglist| failed!(var) }
          end
          teardown_connections_to(var) if var
        end
      end
      
      private
      
      # We establish the connection by creating a thread in a new method--this;Fi[	@#iüI"ﬁ        ensure
          (self.class.instance = var
          self.class.current_feature = var)
        end
      end
      
      private
      
      # Load a recipe from the named file. If +name+ is given, the file will;Fi[	@`iUI"¨            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Constructs the CVSROOT command-line option;Fi[	@eiNI"©            return var[/hash='(.*?)'/, 1]
          else
            return var
          end
        end
        
        private
        
        def function(arglist);Fi[	@lièI"¿            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If verbose output is requested, return nil, otherwise return the;Fi[	@qiKI"°            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        
        # Fine grained mercurial commands;Fi[	@{iMI"˘            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private
        
        # Builds the set of authentication switches that perforce understands.;Fi[	@ÇiXI"¿            "t\n"
          else
            # do nothing
          end
        end
        
        private
        
        # If a username is configured for the SCM, return the command-line;Fi[	@•iI"Ï          super.check do |arglist|
            var.remote.command("rsync") unless copy_exclude.empty?
            var.remote.writable(shared_path)
          end
        end
        
        private
        
        def function(arglist);Fi[	@€iHI"‡          if File.directory?(project_directory).! then
            raise(Compass::Error.new("#{project_directory} does not exist."))
          end
        end
      end
      
      private
      
      def function(arglist);Fi[	@Øi†I"∑      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      clean_url(var)
    end
  end
  
  private
  
  # Emits a path, taking off any leading "./";Fi[	@8iéI"…          if [hover?, target?, active?].any? then
            PARENT.match(name)
            base.image_for($1)
          end
        end
        
        private
        
        def function(arglist);Fi[	@≠i1I"q      else
        instance_exec(*var, &var)
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@≤iLI"u          end
          raise(var)
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@EiéI"¿        File.open(File.join(@var.dotcucumber, "stepdefs.json"), "w") do |arglist|
          var.write(JSON.pretty_generate(var))
        end
      end
    end
    
    private
    
    #:nodoc;Fi[	@Ái I"      return var unless var.is_a?(Hash)
      var.each do |arglist|
        var[var] = var.to_s if param_requires_string_conversion?(var)
      end
    end
    
    private
    
    # Determine which values should be transformed to string or passed as-is to the query builder underneath;Fi[	@–iI"Ô        if validate(var) then
          var.after_token_authentication
          success!(var)
        end
      end
      
      private
      
      # Token Authenticatable can be authenticated with params in any controller and any verb.;Fi[	@«i!I"–    respond_with do |arglist|
      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  
  def function(arglist);Fi[	@ i@I"…        render(:json => (CommentPresenter.as_collection(@var)), :status => 200)
      end
      var.mobile { |arglist| render(:layout => (false)) }
    end
  end
  
  private
  
  def function(arglist);Fi[	@€iHI"æ    unless AppConfig.settings.invitations.open? then
      flash[:error] = I18n.t("invitations.create.no_more")
      redirect_to(:back)
    end
  end
  
  private
  
  def function(arglist);Fi[	@Ìi+I"ÿ    respond_to do |arglist|
      var.all { |arglist| render(:layout => (false)) }
      var.json { |arglist| render(:json => (@var.as_api_response(:backbone))) }
    end
  end
  
  private
  
  def function(arglist);Fi[	@ÂißI"§        flash[:error] = I18n.t("tags.show.none", :name => (search_query))
        redirect_to(:back)
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@Úi{I"É      end
    else
      redirect_to(person_photos_path(current_user.person))
    end
  end
  
  private
  
  def function(arglist);Fi[	@Úi9I"y          redirect_to(edit_profile_path)
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@iBI"√        var.mobile { |arglist| redirect_to(stream_path) }
        var.json { |arglist| render(:nothing => (true), :status => 403) }
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@(i,I"ú          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@3i!I"+      javascript_tag do |arglist|
        "          var _sf_async_config = { uid: #{AppConfig.privacy.chartbeat_uid}, domain: \"#{AppConfig.pod_uri.host}\" };\n          (function() {\n            function loadChartbeat() {\n              window._sf_endpt = (new Date()).getTime();\n              var e = document.createElement('script');\n              e.setAttribute('language', 'javascript');\n              e.setAttribute('type', 'text/javascript');\n              e.setAttribute('src',\n                             (('https:' == document.location.protocol) ? 'https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/' : 'http://static.chartbeat.com/') +\n                                 'js/chartbeat.js');\n              document.body.appendChild(e);\n            };\n            var oldonload = window.onload;\n            window.onload = (typeof window.onload != 'function') ?\n                loadChartbeat : function() { oldonload(); loadChartbeat(); };\n          })();\n".html_safe
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ÉiRI"ù      else
        AspectMembership.exists?(:contact_id => (self.id), :aspect_id => (var.id))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@9i?I"~      self.target.post
    else
      self.target
    end
  end
  
  private
  
  def self.concatenate_or_create(arglist);Fi[	@ói=I"‘    if self.url then
      self.url = ("http://" + self.url) unless self.url.match(/https?:\/\//)
      self.url = (self.url + "/") if self.url[-1, 1].!=("/")
    end
  end
  
  private
  
  def function(arglist);Fi[	@£iΩI"x    if @var then
      errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  
  def function(arglist);Fi[	@6iI"⁄    else
      var = var.map { |arglist| [var, var.id, var.class.base_class.to_s] }
      ShareVisibility.import([:contact_id, :shareable_id, :shareable_type], var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@±i¶I"’  def function(arglist)
    unless text_and_photos_blank? then
      (errors[:base] << "Cannot destory a StatusMessage with text and/or photos present")
    end
  end
  
  private
  
  def self.tag_stream(arglist);Fi[	@LiÂI"¶      self.class.buffer_option_keys.inject({}) do |arglist|
        var[var] = send(var)
        var
      end
    end
    
    private
    
    def function(arglist);Fi[	@‰i{I"      rescue Haml::Error => var
        var.backtrace.unshift("#{@options[:filename]}:#{(((e.line ? ((e.line + 1)) : (@index)) + @options[:line]) - 1)}")
        raise
      end
    end
    
    private
    
    class Line < Struct.new(:text, :unstripped, :full, :index, :compiler, :eod);Fi[	@[iI"¶        puts("rmdir: #{d} (empty)") if ARGV.verbose?
        var.rmdir
      end
    end
  end
  
  private
  
  # Set permissions for executables and non-executables;Fi[	@iyI"w      else
        raise("No such formula or keg")
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@Xi#I"◊      print("Linking #{keg}... ") do |arglist|
        puts("#{keg.link(mode)} symlinks created")
      end
    end
  end
  
  private
  
  # Allows us to ensure a puts happens before the block exits so that if say,;Fi[	@ziI"â          ARGV.kegs.each { |arglist| PrettyListing.new(var) }
        end
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@ai+I"«    else
      puts("Updated Homebrew from #{master_updater.initial_revision[0, 8]} to #{master_updater.current_revision[0, 8]}.")
      var.dump
    end
  end
  
  private
  
  def function(arglist);Fi[	@ài/I"õ      "Library/Formula/#{name}.rb"
    else
      "#{HOMEBREW_REPOSITORY}/Library/Formula/#{name}.rb"
    end
  end
  
  private
  
  def function(arglist);Fi[	@îirI"ê      safe_system("7zr", "x", @var)
    else
      FileUtils.cp(@var, File.basename(@var))
    end
  end
  
  private
  
  def function(arglist);Fi[	@îiI"        Find.prune
        FileUtil.rm_r(var, :force => (true))
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@îi˛I"°      var
    else
      var.is_a?(Symbol) ? (detect_from_symbol(var)) : (detect_from_url(var))
    end
  end
  
  private
  
  def self.detect_from_url(arglist);Fi[	@ki¨I"e      yield)
    ensure
      replace(var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@∂iI"ö          end
        end
      end
    end
  end
  
  private
  
  OTOOL_RX = /\t(.*) \(compatibility version (\d+\.)*\d+, current version (\d+\.)*\d+\)/;Fi[	@ˆißI"å      else
        raise("Unknown version scheme #{@scheme} was requested.")
      end
    end
  end
  
  private
  
  def function(arglist);Fi[	@°i0I"y        else
          var.pager = var
        end
      end
    end
    
    private
    
    def function(arglist);Fi[	@¶i'I"Á        File.open("_posts/tumblr/#{post[:name]}", "w") do |arglist|
          var.puts(((var[:header].to_yaml + "---\n") + var[:content]))
        end
      end
    end
    
    private
    
    def self.truncate_post_name(arglist);Fi[	@áimI"∂        yield(self) if block_given?)
      ensure
        self.updates_requested = false
      end
    end
    
    private
    
    # Get the atomic paths utility for this document.;Fi[	@Hi!I"ø          end
          yield(self) if block_given?
          process_pending
        end
      end
      
      private
      
      # Get the current mass assignment options for this model.;Fi[	@giI"¸            validate_session_database(var, var)
            validate_session_hosts(var, var)
            validate_session_uri(var, var)
          end
        end
        
        private
        
        # Validate that the session config has database.;Fi[	@liVI"€            super()
          else
            (count > 0) ? (super(0) { |arglist| var.send(var) }) : (0)
          end
        end
        
        private
        
        # Aggregate by the provided field and method.;Fi[	@‡	i7I"—          else
            Default.new(extract_attribute(var, var))
          end
        end
      end
      
      private
      
      # Extract the attribute from the key, being smarter about dot notation.;Fi[	@ 
iI"ÿ            document[field] = (var + value)
            execute("$inc")
            document[field]
          end
        end
        
        private
        
        # In case we need to cast going to the database.;Fi[	@hiSI"Û            (target.clear and _unscoped.clear)
            var = execute_batch_insert(var, "$set")
            add_atomic_sets(var)
          end
        end
        
        private
        
        # Add the atomic sets to the base document.;Fi[	@ñikI"          unless var.forced_nil_inverse? then
            synced_save(var)
            synced_destroy(var)
          end
        end
        
        private
        
        # Set up the sync of inverse keys that needs to happen on a save.;Fi[	@≠i I"’          yield)
        ensure
          Threaded.exit_execution("without_default_scope")
        end
      end
      
      private
      
      # Warns or raises exception if overriding another scope or method.;Fi[	@ΩiI"        def function(arglist)
          if (var.is_a?(::Hash).! or valid_keys?(var).!) then
            raise(Errors::InvalidStorageOptions.new(var, var))
          end
        end
        
        private
        
        # Determine if all keys in the options hash are valid.;Fi[	@Èi"I"ﬂ          else
            var.errors.add(var, :blank, options) if not_present?(var)
          end
        end
      end
      
      private
      
      # Returns true if the relation is blank or the foreign key is blank.;Fi[	@Òi-I"û          else
            validate_root(var, var, var)
          end
        end
      end
      
      private
      
      # Add the error to the document.;Fi[	@CirI"z            end
          end
          insert(var, &var)
        end
      end
      
      private
      
      ###;Fi[	@NiXI"”        # Create a Nokogiri::XML::DocumentFragment from +tags+
        def function(arglist)
          self.new(XML::Document.new, var)
        end
      end
      
      private
      
      # fix for issue 770;Fi[	@ci1I"Ù        document.canonicalize(var, var, var) do |arglist|
          var = var.is_a?(XML::Node) ? (var) : (var)
          ((var == var) or var.ancestors.include?(var))
        end
      end
      
      private
      
      def function(arglist);Fi[	@3i{I"s        end
      else
        scale_to(var)
      end
    end
    
    private
    
    def function(arglist);Fi[	@ iI"÷    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var))
      end
    end
    
    private
    
    def function(arglist);Fi[	@Ëi|I"›        rescue ::Fog::Errors::Error => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist);Fi[	@Îi˘I"⁄        rescue AWS::Errors::Base => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      
      def function(arglist);Fi[	@ i"I"+      def function(arglist)
        unless (AVAILABLE_CHECKS + [:in]).any? { |arglist| options.has_key?(var) } then
          raise(ArgumentError, "You must pass either :less_than, :greater_than, or :in to the validator")
        end
      end
      
      private
      
      def function(arglist);Fi[	@1 ilI"ù      complete_open_id_authentication(&var)
    else
      begin_open_id_authentication(var, var, &var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@®iLI"˜      assert_nonce(var, false, var, "#{url}: nonce not allowed third time")
      var = OpenID::Nonce.mk_nonce(3600)
      assert_nonce(var, false, var, "Old nonce #{old_nonce.inspect} passed")
    end
  end
  
  private
  
  def function(arglist);Fi[	@LiÍI"©    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@OiÛI"©    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@RiŸI"©    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  
  def function(arglist);Fi[	@UiI"Ñ      return @var
    else
      open(var, "wb") { |arglist| var.write(@var) }
    end
  end
  
  private
  
  def function(arglist);Fi[	@æiKI"          rescue => var
            logger.error("scm: filesystem: error: #{err.message}")
            raise(CommandFailed.new(var.message))
          end
        end
        
        private
        
        # AbstractAdapter::target is implicitly made to quote paths.;Fi[	@ÖiSI"≤        else
          Dir.glob("#{path}/#{dir}/*").collect { |arglist| File.basename(var) }
        end
      end
    end
    
    private
    
    def self.scan_themes(arglist);Fi[	@i&I"¡            # do nothing
          end
          var.attributes["transform"] = "translate(#{x_offset} #{y_offset})"
        end
      end
      
      private
      
      def function(arglist);Fi[	@«iYI"{            var.call(*var)
            self
          end
        end
      end
      
      private
      
      # :nodoc:;Fi[	@CiI"œ            true
          else
            private_methods.any? { |arglist| [var.to_s, var.to_sym].include?(var) }.!
          end
        end
        
        private
        
        def function(arglist);Fi[	@tilI"µ        
        def function(arglist)
          @var.is_a?(Spec::Expectations::ExpectationNotMetError)
        end
      end
      
      private
      
      def function(arglist);Fi[	@—i%I"Ÿ        end
        var["rack.errors"] = var
        [500, { "Content-Type" => (var), "Content-Length" => (Rack::Utils.bytesize(var.join).to_s) }, var]
      end
    end
    
    private
    
    def function(arglist);Fi[	@ˇiI"˚              var[extract_requirement(var[0])] = extract_requirement(var[1])
            end
            owner.transition(var)
          end
        end
        
        private
        
        # Extracts the statement requirement from the given node;Fi[	@;i˙I"        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol];Fi[I"@var = var;FI"end;FI" ;FI"def function(arglist);Fiu[u[	@iI"1      def function(arglist)
        @var = Hash.new { |arglist| var[var] = initial_count_for(var) }
        @var = var
        @var = var
      end
      
      def function(arglist)
        var = aliased_name_for(var, var)
        (var == var) ? (Arel::Table.new(var)) : (Arel::Table.new(var).alias(var));Fi[	@µiI"£    
    def function(arglist)
      super(*var)
      @var = var
    end
    
    def function(arglist)
      show_deprecation_warnings
      wrap_block_extension;Fi[	@ikI"      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?
        @var = (object.class.reflect_on_aggregation(name.to_sym) or object.column_for_attribute(name));Fi[	@i5I"™      
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.unserialized_value
        end;Fi[	@"i
I"ı    module TimeZoneConversion
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var = @var.type_cast(var)
          var.acts_like?(:time) ? (var.in_time_zone) : (var);Fi[	@(i}I"ÿ        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency
          Thread.new(frequency, pool) do |arglist|;Fi[	@(iﬂI"¡    
    class ConnectionManagement
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (var = var.key?("rack.test")
        var = @var.call(var);Fi[	@6i0I"Ò        @var = []
        @var = {}
        @var = {}
        @var = var
      end
      
      def function(arglist)
        unless ["sqlite", "mysql", "mysql2"].include?(@var.adapter_name.downcase) then
          raise(NotImplementedError);Fi[	@Fi]I"ü      
      def function(arglist)
        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@LiI"±        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config
          when nil then;Fi[	@riFI"          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var);Fi[	@íiI"¢      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@ûi¸I"ï    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class
    end;Fi[	@õiI"´    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled;Fi[	@ÎiI"⁄      def function(arglist)
        var.assert_valid_keys(*Relation::VALUE_METHODS)
        @var = var
        @var = var
      end
      
      def function(arglist)
        Merger.new(relation, other).merge
      end;Fi[	@≠iI"†      @var = var
      @var = var
      @var = nil
      @var = var
    end
    
    def function(arglist)
      hash_rows.each { |arglist| yield(var) }
    end;Fi[	@iI"       delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database);Fi[	@!iI"      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var;Fi[	@2iI"      
      # Unfortunately, we have to tie Uniqueness validators to a class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = find_finder_class_for(var)
        var = var.arel_table;Fi[	@iI"ï    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then;Fi[	@%i|I"©      @var = var
      @var = {}
      @var = Hash.new(0)
      @var = var
    end
    
    def function(arglist)
      if ENV["DEBUG_RESOLVER"] then
        var = yield;Fi[	@ºi+I"Ë      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "This model adapter does not support fetching records from the database.")
      end;Fi[	@‡i(I"ü    
    def function(arglist)
      super(var, var)
      @var = var
    end
    
    def function(arglist)
      config.find_and_execute_task(source)
    end;Fi[	@˜i?I"·          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server)
          end;Fi[	@iI"æ      
      class DefaultConnectionFactory
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          SSH.connect(var, @var)
        end;Fi[	@OivI"ø          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "highest")
          end;Fi[	@ViI"Ê        
        class LocalProxy
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            @var.local { |arglist| return @var.send(var, *var, &var) }
          end;Fi[	@˙iI"Õ        var = configuration_for(var, var)
        var.inherit_from!(configuration)
        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil;Fi[	@iI"      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)))
      end;Fi[	@BiI"≈        
        def function(arglist)
          @var = []
          @var = var
        end
        
        def function(arglist)
          return false if will_fit?(var).!
          (@var << var);Fi[	@li	I"®  module Ast
    class Comment
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (@var.nil? or (@var == ""))
      end;Fi[	@uiVI"Î        if Cucumber::WINDOWS and (var and ENV["CUCUMBER_FORWARD_SLASH_PATHS"].!) then
          var = var.gsub(/\//, "\\")
        end
        @var = var
      end
      
      def function(arglist)
        "#{@file}:#{line}"
      end;Fi[	@ñiDI"õ        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        dup
      end;Fi[	I"0data//cucumber_prok/cucumber/broadcaster.rb;TiI"≤module Cucumber
  class Broadcaster
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      @var.map { |arglist| var.__send__(var, *var) }
    end;Fi[	I"+data//cucumber_prok/cucumber/errors.rb;TiI"†    
    def function(arglist)
      super("Undefined step: \"#{step_name}\"")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end;Fi[	@¡iI"◊    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.uri(var.file)
        @var.feature(var.gherkin_statement);Fi[	@«i»I"Ø      def function(arglist)
        @var = var.dom_id
        @var = (@var + 1)
        @var = var
      end
      
      def function(arglist)
        move_progress
      end;Fi[	@ﬁiI"√      
      def function(arglist)
        @var = ensure_dir(var, "junit")
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = @var = @var = @var = 0;Fi[	@ÊitI"ê      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
        @var = 4;Fi[	@ÊiçI"∞          @var = true
          return
        end
        @var = var
      end
      
      def function(arglist)
        return if @var
        var = nil unless @var[:source];Fi[	@Êi®I"Ø      
      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end;Fi[	@Èi.I"ï      
      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end;Fi[	@Èi2I"â      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end;Fi[	@i/I"À          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("\"%s\"" % @var.join(File::PATH_SEPARATOR))]
        end;Fi[	@i^I"[      class RCovCucumberRunner < ForkedCucumberRunner
        def function(arglist)
          super(var, var, var, var, var)
          @var = var
        end
        
        def function(arglist)
          if use_bundler then
            [Cucumber::RUBY_BINARY, "-S", "bundle", "exec", "rcov", @var, quoted_binary(@var), "--", @var, @var].flatten;Fi[	@iI"Â      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var)
      end;Fi[	@2i&I"        var = (Time.now - var)
        log.debug("Parsing feature files took #{format_duration(duration)}\n\n")
        check_tag_limits(var)
        @var = var
      end
      
      def function(arglist)
        var = []
        @var.limits.each do |arglist|;Fi[	@=iI"≤        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@KiI"≥      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = WirePacket.new(var, var)
        begin;Fi[	@Vi+I"„      
      def function(arglist)
        @var.each { |arglist| var.begin_scenario(var) }
        @var = var
      end
      
      def function(arglist)
        var = @var
        @var.each { |arglist| var.end_scenario(var) };Fi[	I"'data//devise_proj/devise/models.rb;Ti	I"ˇ  module Models
    class MissingAttribute < StandardError
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        "The following attribute(s) is (are) missing on your model: #{@attributes.join(", ")}"
      end;Fi[	I" data//devise_proj/devise.rb;TiˇI"ü  
  class Getter
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      ActiveSupport::Dependencies.constantize(@var)
    end;Fi[	@Ji
I"ß  
  def function(arglist)
    content_for(:title) { |arglist| var.to_s }
    @var = var
  end
  
  def function(arglist)
    return var unless var.blank?
    pod_name;Fi[	I"7data//diaspora_proj/presenters/aspect_presenter.rb;TiI"¢class AspectPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :name => (@var.name) }
  end;Fi[	I"8data//diaspora_proj/presenters/comment_presenter.rb;TiI"class CommentPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :guid => (@var.guid), :text => (@var.text), :author => (@var.author.as_api_response(:backbone)), :created_at => (@var.created_at) }
  end;Fi[	I"=data//diaspora_proj/presenters/extreme_post_presenter.rb;TiI"Ãclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = PostPresenter.new(@var, @var)
    var = PostInteractionPresenter.new(@var, @var);Fi[	I"Ddata//diaspora_proj/presenters/last_three_comments_decorator.rb;TiI"¯class LastThreeCommentsDecorator
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var.as_json.tap do |arglist|
      var[:interactions].merge!(:comments => (CommentPresenter.as_collection(@var.post.last_three_comments)));Fi[	I"8data//diaspora_proj/presenters/o_embed_presenter.rb;TiI"}  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json
  end;Fi[	@Ô#iI"class PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile))
    if (is_own_profile or person_is_following_current_user) then;Fi[	@“iFI"Uclass PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    { :likes => (as_api(@var.likes)), :reshares => (PostPresenter.collection_json(@var.reshares, @var)), :comments => (CommentPresenter.as_collection(@var.comments)), :participations => (as_api(@var.participations)) }
  end;Fi[	I"8data//diaspora_proj/presenters/service_presenter.rb;TiI"ôclass ServicePresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :provider => (@var.provider) }
  end;Fi[	@‰itI"÷        return next_line if var.text.empty?
        handle_multiline(var)
      end
      @var = var
    end
    
    def function(arglist)
      var and (var.text.empty?.! and (not var.full =~ /^#{@var}/))
    end;Fi[	@Xi	I"Ä  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = []
    (var << f.caveats);Fi[	@ØiüI"ˆ  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "#{@name.downcase} cannot be installed alongside #{@formula}.\n"
    (var << "This is because #{@opts[:because]}\n") if @var[:because];Fi[	@ˆiõI"µend
class VersionSchemeDetector
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    if @var.is_a?(Class) and @var.ancestors.include?(Version) then
      @var;Fi[	@CiÉI"∏      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end;Fi[	@i I"≥    
    def function(arglist)
      return (@var or {}) if (var == false)
      @var = var
    end
    
    def function(arglist)
      if var.is_a?(Class) then
        var = var;Fi[	I"1data//omni_proj/omniauth/failure_endpoint.rb;TiI"¥    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["RACK_ENV"].to_s == "development")
      redirect_to_failure;Fi[	I"3data//omni_proj/omniauth/test/phony_session.rb;TiI"≤class OmniAuth::Test::PhonySession
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var ||= (var["rack.session"] or {})
    var["rack.session"] = @var;Fi[	@
 iI"∑    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      (if blank? then
        SENSIBLE_DEFAULT;Fi[	@ i
I"≠    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      type_from_file_command
    end;Fi[	@ i
I"    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      if match then
        Geometry.new(:height => (@var), :width => (@var), :modifier => (@var), :orientation => (@var));Fi[	I"-data//paperclip_proj/paperclip/logger.rb;TiI"    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log]
    end;Fi[	@«iI"ÿ      
      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = @var.class unless Class.===(@var);Fi[	@’iI"‡      
      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = var.new if (var.class == Class);Fi[	@⁄iI"∫      
      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self;Fi[	@MiI"é    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@ni
I"˚  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var)
    end;Fi[	@UiÅI"ß    @var = var
    @var = var
    var = var if (var == -1)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var);Fi[	@UiäI"j  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@UiéI"s  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var;Fi[	@Ui©I"j  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Ui≠I"j  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Ui±I"j  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@UiµI"j  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@UiπI"j  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@UiΩI"j  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end;Fi[	@Ui¡I"}  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("FPDF error: " + var))
  end;Fi[	@‰i	I"  module Views
    class OtherFormatsBuilder
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = { :format => (var.to_s.downcase) }.merge((var.delete(:url) or {})).except("page")
        var = (var.delete(:caption) or var);Fi[	@€&i
I"     class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var));Fi[	@{i8I"©      
      def function(arglist)
        set_description(*var)
        @var = var
      end
      
      def function(arglist)
        var.module_eval(&@var)
      end;Fi[	@YiI"¨      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!;Fi[	@YieI"∏      def function(arglist)
        @var = parse_expected(var.shift)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var = var
        begin;Fi[	@YiôI"π    class BeSameAs < Be
      def function(arglist)
        @var = var.shift
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.equal?(@var);Fi[	@l iI"–      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var);Fi[	I".data//rspec_proj/spec/matchers/satisfy.rb;Ti	I"¨  module Matchers
    class Satisfy
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var if var
        @var = var;Fi[	@–i$I"’      
      class RegexpMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          return var.=~(@var) unless var.is_a?(Regexp)
          (var == @var);Fi[	@–i9I"¡      
      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|;Fi[	@–iNI"ƒ      
      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|;Fi[	@–icI"À      
      class DuckTypeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.all? { |arglist| var.respond_to?(var) }
        end;Fi[	@–imI"∞      
      class MatcherMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.matches?(var)
        end;Fi[	@–iwI"™      
      class EqualityProxy
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var == var)
        end;Fi[	@–i|I"∞      
      class InstanceOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.instance_of?(@var)
        end;Fi[	@–iÜI"®      
      class KindOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.kind_of?(@var)
        end;Fi[	@”iI"ª      def function(arglist)
        @var = (var[:__declared_as] or "Mock")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@€iTI"„      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end;Fi[	@€iXI"ñ      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then
          @var.clear;Fi[	@"i	I"„  module Runner
    class ExampleGroupRunner
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        $KCODE = "u" if (RUBY_VERSION.to_f < 1.9)
        var.each { |arglist| load(var) };Fi[	@*iI"Ê        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["#{@example_group.description} #{example.description}", var, var.location])
        end;Fi[	@fi@I"ƒ      class Heckler < Heckle
        def function(arglist)
          super(var, var)
          @var = var
        end
        
        def function(arglist)
          @var.run_examples
        end;Fi[	@niI"±      
      def function(arglist)
        @var = {}
        @var = var
      end
      
      def function(arglist)
        best_match.clear
        var = File.expand_path(var);Fi[	@ãi	I"∫  module Output
    class Redirection
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        return "" unless defined? @var
        case @var;Fi[I"def function(arglist);FI"# do nothing;FI"end;FI" ;Fit[t[	@KieI"Ω        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          serializable_collection.each do |arglist|;Fi[	@}iÀI"      # the target is stale.
      #
      # This is only relevant to certain associations, which is why it returns nil by default.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        reflection.build_association(var) do |arglist|;Fi[	@àiI"∑        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super;Fi[	@-i-I"¸      
      # Returns the maximum number of elements in an IN (x,y,z) clause.
      # nil means no limit.
      def function(arglist)
        # do nothing
      end
      
      # Returns the maximum length of an SQL query.
      def function(arglist);Fi[	@0i4I"È      
      # Returns an array of arrays containing the field values.
      # Order is the same as that returned by +columns+.
      def function(arglist)
        # do nothing
      end
      
      undef_method(:select_rows)
      ;Fi[	@0i;I"”      undef_method(:select_rows)
      
      # Executes the SQL statement in the context of this connection.
      def function(arglist)
        # do nothing
      end
      
      undef_method(:execute)
      ;Fi[	@0iDI"ä      # Executes +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        # do nothing
      end
      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@0iI"O      end
      
      # Begins the transaction (and turns off auto-committing).
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        { :read_uncommitted => "READ UNCOMMITTED", :read_committed => "READ COMMITTED", :repeatable_read => "REPEATABLE READ", :serializable => "SERIALIZABLE" };Fi[	@0iI")      end
      
      # Commits the transaction (and turns on auto-committing).
      def function(arglist)
        # do nothing
      end
      
      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.;Fi[	@0iI"      
      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@0iI"ƒ        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.
      def function(arglist);Fi[	@0i!I"       end
      
      # Set the sequence to the max value of the table's column.
      def function(arglist)
        # do nothing
      end
      
      # Inserts the given fixture into the table. Overridden in adapters that require
      # something beyond a simple insert (eg. Oracle).;Fi[	@0ikI"ÿ      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(arglist)
        # do nothing
      end
      
      undef_method(:select)
      ;Fi[	@>i9I"5      
      # Returns an array of Column objects for the table specified by +table_name+.
      # See the concrete implementation for details on the expected parameter values.
      def function(arglist)
        # do nothing
      end
      
      # Checks to see if a column exists in a given table.
      #;Fi[	@>iI"Û      
      # Returns a string of <tt>CREATE TABLE</tt> SQL statement(s) for recreating the
      # entire structure of the database.
      def function(arglist)
        # do nothing
      end
      
      #:nodoc:
      def function(arglist);Fi[	@Fi∑I"Ø      # Checks whether the connection to the database is still active. This includes
      # checking whether the database is actually capable of responding, i.e. whether
      # the connection isn't stale.
      def function(arglist)
        # do nothing
      end
      
      # Disconnects from the database if already connected, and establishes a
      # new connection with the database. Implementors should call super if they;Fi[	@Fi–I"      #
      # The default implementation does nothing; the implementation should be
      # overridden by concrete adapters.
      def function(arglist)
        # do nothing
      end
      
      ###
      # Clear any caching the database adapter may be doing, for example;Fi[	@Fi◊I"¶      ###
      # Clear any caching the database adapter may be doing, for example
      # clearing the prepared statement cache. This is database specific.
      def function(arglist)
        # do nothing
      end
      
      # Returns true if its required to reload the connection between requests for development mode.
      # This is not the case for Ruby/MySQL and it's not necessary for any adapters except SQLite.;Fi[	@Fi¸I"ü        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@Fi I"ò        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@FiI"è        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var;Fi[	@ViËI"Ø      
      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var;Fi[	@riI"”    class PostgreSQLAdapter < AbstractAdapter
      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var;Fi[	@ïiI"Í    #
    # See also http://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
    # :nodoc:
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = self.class.primary_key;Fi[	I"@data//activerecord_proj/active_record/explain_subscriber.rb;TiI"Ïrequire("active_support/notifications")
module ActiveRecord
  class ExplainSubscriber
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      if var = Thread.current[:available_queries_for_explain] then;Fi[	I";data//activerecord_proj/active_record/null_relation.rb;Ti;I"y      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	@ÀirI"¿    private
    
    # A hook to be overridden by association modules.
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      relation_for_destroy.delete_all;Fi[	@ﬂi‰I"è        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@ﬂiËI"‚        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in
      # ThroughReflection.;Fi[	@ùi2I"·      
      ##
      # Each subclass must define a +path+ where remote files will be stored
      def function(arglist)
        # do nothing
      end
      
      ##
      # Return the storage name, with optional storage_id;Fi[	@ªiOI"—      
      ##
      # Note: Storage::RSync doesn't cycle
      def function(arglist)
        # do nothing
      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote;Fi[	@LiGI"Ä    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      unless @var then;Fi[	@,i2I"ó  end
  
  class SystemRubyVersion < RubyVersion
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      RUBY_VERSION;Fi[	@giI"•require("rubygems/user_interaction")
module Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@giI"Ü      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@giI"Ü      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@giI"Ü      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@giI"Ü      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@giI"      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false;Fi[	@Õi.I"⁄          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then;Fi[	I"=data//compass_proj/compass/exec/command_option_parser.rb;TiI"´      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s;Fi[	@iI"¿module Compass
  module Installers
    class BareInstaller < Base
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        directory(targetize(""));Fi[	@iI"“        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("config.rb");Fi[	@i*I"      
      # The default prepare method -- it is a no-op.
      # Generally you would create required directories, etc.
      def function(arglist)
        # do nothing
      end
      
      # The install method override this to install
      def function(arglist);Fi[	@i5I"›      
      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false;Fi[	@íiRI"Ç  end
  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing;Fi[	@íiVI"      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield;Fi[	@’i"I"Ä      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name;Fi[	@fiI"≈        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@fi"I"ò        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false;Fi[	@çiCI"Ÿ        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! };Fi[	@∏iàI"¡        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to
      #activate this feature;Fi[	@ﬁiGI"Ω        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var);Fi[	@Ôi	I"•module Cucumber
  module Formatter
    class Stepdefs < Usage
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0;Fi[	@ivI"›        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language;Fi[	@i~I"®        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|;Fi[	@i=I"û        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing;Fi[	@iAI"|        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	@iI"º        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "python snippet: #{code_keyword}, #{step_name}";Fi[	@i$I"æ        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var);Fi[	@=iI"Ï          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)));Fi[	@PiI"ä        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      
      private
      ;Fi[	@ViI"•        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var);Fi[	@Éi.I"ç        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      
      var = ["serializable_hash"]
      ;Fi[	@çiQI"∆        var
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A reliable way to expose the salt regardless of the implementation.
      def function(arglist);Fi[	@òiQI"‰        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new;Fi[	@¶i%I"Œ      end
      
      # Hook called after token authentication.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        self.class.expire_auth_token_on_timeout;Fi[	@ÿ#i:I"r    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    "";Fi[	@<i|I"Å      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value;Fi[	I"9data//haml_proj/haml/helpers/safe_erubis_template.rb;TiI"ﬁmodule Haml
  class SafeErubisTemplate < Tilt::ErubisTemplate
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      @var.merge!(:engine_class => (ActionView::Template::Handlers::Erubis));Fi[	@©i'I"∂    # @return [ nil ] Always nil.
    #
    # @since 2.1.0
    def function(arglist)
      # do nothing
    end
    
    module ClassMethods
      # Performs class equality checking.;Fi[	@ciMI"Ô      # XInclude start type
      # XInclude end type
      # DOCB document node type
      def function(arglist)
        # do nothing
      end
      
      ###
      # Decorate this node with the decorators set up in this node's Document;Fi[	@}iI"◊      class Document
        ###
        # Called when an XML declaration is parsed
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document starts parsing;Fi[	@}iI"ƒ        
        ###
        # Called when document starts parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document ends parsing;Fi[	@}iI"∆        
        ###
        # Called when document ends parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element;Fi[	@}i I";        # * +name+ is the name of the tag
        # * +attrs+ are an assoc list of namespaces and attributes, e.g.:
        #     [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the end of an element;Fi[	@}i'I"‹        ###
        # Called at the end of an element
        # +name+ is the tag name
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element;Fi[	@}iHI"¯        # times given one contiguous string of characters.
        #
        # +string+ contains the character data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when comments are encountered;Fi[	@}iOI"„        ###
        # Called when comments are encountered
        # +string+ contains the comment data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document warnings;Fi[	@}iVI"”        ###
        # Called on document warnings
        # +string+ contains the warning
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document errors;Fi[	@}i]I"ÿ        ###
        # Called on document errors
        # +string+ contains the error
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when cdata blocks are found;Fi[	@}idI"Ù        ###
        # Called when cdata blocks are found
        # +string+ contains the cdata content
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when processing instructions are found;Fi[	@ªiI"™        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["rack.session"];Fi[	I">data//paperclip_proj/paperclip/io_adapters/nil_adapter.rb;TiI"ímodule Paperclip
  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      "";Fi[	@π)iI"{      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true;Fi[	@MiI"ê      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    
    def self.make(arglist)
      new(var, var, var).make;Fi[	@UiI"Ñ  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing;Fi[	@Ui	I"k    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  ;Fi[	@ciøI"ß  	# Convert to accessible file path
  	# @param string :attrname image file name
  	#
  def function(arglist)
    # do nothing
  end
  
  #
  	# Process opening tags.;Fi[	@xi I"  end
  
  # XXX TODO XXX
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    QTAGS.each do |arglist|;Fi[	@ilI"ª      end
      
      # Override and place code to add defs here
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = Document.new;Fi[	@i_I"õ      end
      
      # We don't need the graph
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        [""];Fi[	@iI"Ÿ      # and #save is called.
      #
      # This is where you POST or PUT or whatever to your Failure service.
      def function(arglist)
        # do nothing
      end
      
      def self.count(arglist)
        0;Fi[	@BiI"º    module MockFramework
      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        flexmock_verify;Fi[	@–iI"°      end
      
      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true;Fi[	@–i.I"…      end
      
      class BooleanMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          (TrueClass.===(var) or FalseClass.===(var));Fi[	@iI"ñ        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        [];Fi[	@%iI"z        #
        # ... the value of <tt>output</tt> will be progress_report.txt. If you
        # don't identify an output destination, the default is STDOUT.
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked before any examples are run, right after
        # they have all been collected. This can be useful for special;Fi[	@%i*I">        #
        # ==== Parameters
        # example_count:: the total number of examples to be run
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked at the beginning of the execution of each
        # example_group. The next method to be invoked after this is;Fi[	@%i4I"        #
        # ==== Parameters
        # example_group_proxy:: instance of Spec::Example::ExampleGroupProxy
        def function(arglist)
          # do nothing
        end
        
        # Deprecated - use example_group_started instead
        def function(arglist);Fi[	@%iDI"8        #
        # ==== Parameters
        # example_proxy:: instance of Spec::Example::ExampleProxy
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked when an +example+ passes.
        # +example_proxy+ is the same instance of Spec::Example::ExampleProxy;Fi[	@%iNI"F        #
        # ==== Parameters
        # example_proxy:: instance of Spec::Example::ExampleProxy
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked when an +example+ fails, i.e. an exception occurred
        # inside it (such as a failed should or other exception).;Fi[	@%i]I"o        # counter:: the sequential number of this failure
        #
        # failure:: instance of Spec::Runner::Reporter::Failure
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked when an example is not yet implemented (i.e. has not
        # been provided a block), or when an ExamplePendingError is raised.;Fi[	@%imI"^        #   the message passed to the pending message, or an internal
        #   default
        #
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked after all of the examples have executed. The next method
        # to be invoked after this one is #dump_failure (once for each failed example);Fi[	@%isI"π        
        # This method is invoked after all of the examples have executed. The next method
        # to be invoked after this one is #dump_failure (once for each failed example)
        def function(arglist)
          # do nothing
        end
        
        # Dumps detailed information about an example failure.
        # This method is invoked for each failed example after all examples have run. +counter+ is the sequence number;Fi[	@%iI"4        # ==== Parameters
        # counter:: the sequential number of this failure
        # failure:: instance of Spec::Runner::Reporter::Failure
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked after the dumping of examples and failures.
        #;Fi[	@%iÖI"I        # example_count:: the number of examples run
        # failure_count:: the number of examples that failed
        # pending_count:: the number of examples that are pending
        def function(arglist)
          # do nothing
        end
        
        # This gets invoked after the summary
        def function(arglist);Fi[	@%iäI"        end
        
        # This gets invoked after the summary
        def function(arglist)
          # do nothing
        end
        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist);Fi[	@/iI"°          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	@4iI"®          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing;Fi[	@9i~I"•          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then;Fi[@	)I"@var = var;FI"end;FI" ;Fip[p[	@i4I"®      end
      
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.unserialized_value;Fi[	@"i	I"“  module AttributeMethods
    module TimeZoneConversion
      class Type
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var = @var.type_cast(var);Fi[	@(iﬁI"¨    end
    
    class ConnectionManagement
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (var = var.key?("rack.test");Fi[	@riEI"Ÿ        class Array < Type
          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            if String.===(var) then;Fi[	@õiI"y      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	@ÛiI"Ú    extend(ActiveSupport::Concern)
    
    class WhereChain
      def function(arglist)
        @var = var
      end
      
      # Returns a new relation expressing WHERE + NOT condition
      # according to the conditions in the arguments.;Fi[	@iI"«      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin;Fi[	@!iI"„      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin;Fi[	@2iI"›      end
      
      # Unfortunately, we have to tie Uniqueness validators to a class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = find_finder_class_for(var);Fi[	@√i8I"‹    ##
    # Adds the given String of +options+ to the `tar` command.
    # e.g. '-h --xattrs'
    def function(arglist)
      @var = var
    end
    
    ##
    # Archives all the provided paths in to a single .tar file;Fi[	@6iBI"d      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@iI"Æ      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin;Fi[	@"i'I"    # Because Rubyforge cannot be trusted to provide valid specifications
    # once the remote gem is downloaded, the backend specification will
    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@6&i
I"
    SimilarityScore = Struct.new(:string, :distance)
    
    # initialize with an array of words to be matched against
    def function(arglist)
      @var = var
    end
    
    # return an array of words similar to 'word' from the corpus
    def function(arglist);Fi[	@i<I"    end
    
    # Sets the shell for this thor class.
    def function(arglist)
      @var = var
    end
    
    SHELL_DELEGATED_METHODS.each do |arglist|
      module_eval("        def #{method}(*args,&block)\n          shell.#{method}(*args,&block)\n        end\n", "(string)", 69);Fi[	@iI"º      end
      
      class DefaultConnectionFactory
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          SSH.connect(var, @var);Fi[	@ViI"‰        end
        
        class LocalProxy
          def function(arglist)
            @var = var
          end
          
          def function(arglist)
            @var.local { |arglist| return @var.send(var, *var, &var) };Fi[	@Vi!I"ö        # The options available for this SCM instance to reference. Should be
        # treated like a hash.
        # Creates a new SCM instance with the given configuration options.
        def function(arglist)
          @var = var
        end
        
        # Returns a proxy that wraps the SCM instance and forces it to operate
        # in "local" mode, which changes how variables are looked up in the;Fi[	@åiI"[        attr_reader(:configuration)
        
        # Instantiates a strategy with a reference to the given configuration.
        def function(arglist)
          @var = var
        end
        
        # Executes the necessary commands to deploy the revision of the source
        # code identified by the +revision+ variable. Additionally, this;Fi[	@biI"∫    end
    
    # Instantiate a new shell
    def function(arglist)
      @var = var
    end
    
    # Start the shell running. This method will block until the shell
    # terminates.;Fi[	@liI"Æmodule Cucumber
  module Ast
    class Comment
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        (@var.nil? or (@var == ""));Fi[	@ÉiãI"∆          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        
        # Returns true if one or more steps failed
        def function(arglist);Fi[	@](iI"™module Cucumber
  class Broadcaster
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      @var.map { |arglist| var.__send__(var, *var) };Fi[	@ÊisI"ê        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@Èi1I"í        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil;Fi[	@iVI"    end
    
    class JsArg
      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      ;Fi[	@=iI"æ      class StepInvoker
        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing;Fi[	@KiI"¨      
      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = WirePacket.new(var, var);Fi[	@Å(iI"module Devise
  module Models
    class MissingAttribute < StandardError
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        "The following attribute(s) is (are) missing on your model: #{@attributes.join(", ")}";Fi[	@Ñ(i˛I"ù  end
  
  class Getter
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      ActiveSupport::Dependencies.constantize(@var);Fi[	@â(iI"úclass AspectPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :name => (@var.name) };Fi[	@å(iI"
class CommentPresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :id => (@var.id), :guid => (@var.guid), :text => (@var.text), :author => (@var.author.as_api_response(:backbone)), :created_at => (@var.created_at) };Fi[	@í(iI"äclass LastThreeCommentsDecorator
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var.as_json.tap do |arglist|;Fi[	@ú(iI"ìclass ServicePresenter < BasePresenter
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    { :provider => (@var.provider) };Fi[	@Ui∞I"    
    class StaticConditionalContext
      # @param set [#include?] The set of variables that are defined for this context.
      def function(arglist)
        @var = var
      end
      
      # Checks whether or not a variable is defined for this context.
      #;Fi[	@XiI"|class Caveats
  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = [];Fi[	@ˆiöI"∞  end
end
class VersionSchemeDetector
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    if @var.is_a?(Class) and @var.ancestors.include?(Version) then;Fi[	I"*data//jekyll_proj/jekyll/converter.rb;TiI"™    # Initialize the converter.
    #
    # Returns an initialized Converter.
    def function(arglist)
      @var = var
    end
    
    # Get the pygments prefix.
    #;Fi[	@Hi8I",      # @return [ Hash ] The mass assignment options.
      #
      # @since 3.0.7
      def function(arglist)
        @var = var
      end
      
      # If the key provided is the name of a relation or a nested attribute, we
      # need to wait until all other attributes are set before processing;Fi[	@ãi.I"™      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Get the skiping value.
      #;Fi[	@ãiJI"™      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Apply criteria options.
      #;Fi[	@ùigI"æ    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Is the criteria for embedded documents?
    #;Fi[	@ùiÚI"    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Merges another object with this +Criteria+ and returns a new criteria.
    # The other object may be a +Criteria+ or a +Hash+. This is used to;Fi[	@∆i!I"ä    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    ;Fi[	@WiI"      # @param [ Metadata ] metadata The metadata of the relation.
      #
      # @since 2.0.0.rc.7
      def function(arglist)
        @var = var
      end
      
      # Convert the supplied object to the appropriate type to set as the
      # foreign key for a relation.;Fi[	@hiôI"Û        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Normalize the documents, in case they were provided as an array of
        # hashes.;Fi[	@hi–I"Á        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Get the selector for executing atomic operations on the collection.
        #;Fi[	@ÒiI"Ÿ      # @param [ Class ] klass The class getting validated.
      #
      # @since 1.0.0
      def function(arglist)
        @var = var
      end
      
      # Validate the document for uniqueness violations.
      #;Fi[	@˙iI"›        # @param [ Object ] app The application.
        #
        # @since 2.1.0
        def function(arglist)
          @var = var
        end
        
        # Make the request with the provided environment.
        #;Fi[	@`i4I"        # the default for XHTML document
        # Integer representation of the SaveOptions
        # Create a new SaveOptions object with +options+
        def function(arglist)
          @var = var
        end
        
        constants.each do |arglist|
          class_eval("\n            def #{constant.downcase}\n              @options |= #{constant}\n              self\n            end\n\n            def #{constant.downcase}?\n              #{constant} & @options == #{constant}\n            end\n          ");Fi[	@fiOI"2      # relax any hardcoded limit from the parser
      # the default options used for parsing XML documents
      # the default options used for parsing HTML documents
      def function(arglist)
        @var = var
      end
      
      constants.each do |arglist|
        next if (var.to_sym == :STRICT);Fi[	@´(iI"Æ      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      raise_out! if (ENV["RACK_ENV"].to_s == "development");Fi[	@Æ(iI"ìclass OmniAuth::Test::PhonySession
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var ||= (var["rack.session"] or {});Fi[	@
 iI"£    
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      (if blank? then;Fi[	@ i	I"Ã  class FileCommandContentTypeDetector
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      type_from_file_command;Fi[	@ i	I"æ  class GeometryParser
    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      if match then;Fi[	@∑(iI"¨      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      options[:log];Fi[	@«iI"Ø      end
      
      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var;Fi[	@’iI"π      end
      
      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var;Fi[	@⁄iI"µ      end
      
      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var;Fi[	@1 i3I"w      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@UiâI"ç    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@UiçI"s    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Ui®I"l    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Ui¨I"s    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Ui∞I"s    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Ui¥I"s    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Ui∏I"s    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@UiºI"s    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var;Fi[	@Ui¿I"Å    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    raise(("FPDF error: " + var));Fi[	@ciïI"î  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_image_scale, :SetImageScale)
  ;Fi[	@ci˚I"ƒ  	# @since 1.5
  	# @see SetLeftMargin(), SetRightMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_top_margin, :SetTopMargin)
  ;Fi[	@ciI"∆  	# @since 1.5
  	# @see SetLeftMargin(), SetTopMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_right_margin, :SetRightMargin)
  ;Fi[	@ciCI"Æ  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetSubject()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_title, :SetTitle)
  ;Fi[	@ciOI"∞  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_subject, :SetSubject)
  ;Fi[	@ci[I"Ø  	# @since 1.2
  	# @see SetCreator(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_author, :SetAuthor)
  ;Fi[	@cigI"±  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_keywords, :SetKeywords)
  ;Fi[	@cisI"∞  	# @since 1.2
  	# @see SetAuthor(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_creator, :SetCreator)
  ;Fi[	@ciCI"”  	# (minimum distance between header and top page margin)
  	# @param int :hm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_margin, :SetHeaderMargin)
  ;Fi[	@ciNI"÷  	# (minimum distance between footer and bottom page margin)
  	# @param int :fm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_margin, :SetFooterMargin)
  ;Fi[	@ciXI"Ï   	# Set a flag to print page header.
  	# @param boolean :val set to true to print the page header (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_header, :SetPrintHeader)
  ;Fi[	@cibI"Ó   	# Set a flag to print page footer.
  	# @param boolean :value set to true to print the page footer (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_footer, :SetPrintFooter)
  ;Fi[	@ci;I"ï  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_font, :SetHeaderFont)
  ;Fi[	@ciFI"ï  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_font, :SetFooterFont)
  ;Fi[	@ciQI"ö  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_language_array, :SetLanguageArray)
  ;Fi[	@ci[I"à   	# Set document barcode.
  	# @param string :bc barcode
  	#
  def function(arglist)
    @var = var
  end
  
  #
   	# Print Barcode.;Fi[	@‰iI"˜module Redmine
  module Views
    class OtherFormatsBuilder
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        var = { :format => (var.to_s.downcase) }.merge((var.delete(:url) or {})).except("page");Fi[	@YiI"®    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@l i
I"∞    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@«i2I"¢      end
      
      # See Spec::Matchers
      def function(arglist)
        @var = var
      end
      
      # See Spec::Matchers
      def function(arglist);Fi[	@Ê(iI"•module Spec
  module Matchers
    class Satisfy
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var if var;Fi[	@–i#I"«      end
      
      class RegexpMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          return var.=~(@var) unless var.is_a?(Regexp);Fi[	@–i8I"ß      end
      
      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin;Fi[	@–iMI"™      end
      
      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin;Fi[	@–ibI"…      end
      
      class DuckTypeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.all? { |arglist| var.respond_to?(var) };Fi[	@–ilI"Æ      end
      
      class MatcherMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var.matches?(var);Fi[	@–ivI"®      end
      
      class EqualityProxy
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var == var);Fi[	@–i{I"Æ      end
      
      class InstanceOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.instance_of?(@var);Fi[	@–iÖI"¶      end
      
      class KindOf
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          var.kind_of?(@var);Fi[	@€iSI"#      # raise an instance of it, creating it with +new+. If the exception
      # class initializer requires any parameters, you must pass in an
      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@€iWI"î        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then;Fi[	@iI")    module Differs
      unless defined? Spec::Expectations::Differs::Default then
        class Default
          def function(arglist)
            @var = var
          end
          
          # This is snagged from diff/lcs/ldiff.rb (which is a commandline tool)
          def function(arglist);Fi[	@"iI"∆module Spec
  module Runner
    class ExampleGroupRunner
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        $KCODE = "u" if (RUBY_VERSION.to_f < 1.9);Fi[	@*iI"Ó          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          (@var << ["#{@example_group.description} #{example.description}", var, var.location]);Fi[	@'i:I"∑    #
    # @param attrs [Hash]
    # @return [Twitter::Base]
    def function(arglist)
      @var = var
    end
    
    # Fetches an attribute of an object using hash notation
    #;Fi[	I"-data//twitter_proj/twitter/rate_limit.rb;TiI"´    alias :to_hash :attrs
    
    # @return [Twitter::RateLimit]
    def function(arglist)
      @var = var
    end
    
    # @return [Integer]
    def function(arglist);Fi[	@ãiI"∏module Whenever
  module Output
    class Redirection
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        return "" unless defined? @var;Fi[@‡"@·"I"end;FI"end;Fih[h[	@imI"Ü      when Proc then
        var.call
      else
        var
      end
    end
  end
  
  class StrictValidationFailed < StandardError;Fi[	@6iI"ß      if var.respond_to?(:permitted?) and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	@i"I"Ω          if (aliases[var] > 1) then
            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      
      private;Fi[	@√imI"√          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end
end;Fi[	@Úi3I"Ω            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end
end;Fi[	@¸i>I"ë        var = var.save
        set_new_record(var)
        raise(RecordInvalid.new(var)) if var.! and var
        var
      end
    end
  end
end;Fi[	@LiKI"º            var = Hash[var.query.split("&").map { |arglist| var.split("=") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end
end;Fi[	@bi.I"°                [var, var]
              end]
            else
              var
            end
          end
        end
        
        def function(arglist);Fi[	@bifI"“                var = (")" == var[5]) ? ((var[4].to_i - 1)) : (var[4].to_i)
                (var..var)
              else
                var
              end
            end
          end
        end
        ;Fi[	@bi{I"ã                end
              end
            else
              var
            end
          end
        end
        
        private;Fi[	@riMI"‰            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        
        class Integer < Type;Fi[	@uiòI"æ            var = "#{result}.#{sprintf("%06d", value.usec)}"
          end
          var = (var.sub(/^-/, "") + " BC") if (var.year < 0)
          var
        end
      end
    end
  end
end;Fi[	@çi!I"‹          if var.encoding.!=(Encoding::ASCII_8BIT) then
            var = var.force_encoding(Encoding::ASCII_8BIT)
          end
          var
        end
      end
    end
    
    class SQLite3Adapter < AbstractAdapter;Fi[	@ïiaI"*        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    
    # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with;Fi[	@⁄i,I"æ        def function(arglist)
          var, var = super, var[:db_runtime]
          (var << ("ActiveRecord: %.1fms" % var.to_f)) if var
          var
        end
      end
    end
  end
end;Fi[	@ÛiI"ù            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    
    def function(arglist);Fi[	@®iCI"Æ      var = Relation.new(klass, table, var)
      var.default_scoped = default_scoped
      var.extend(*extending_values) if extending_values.any?
      var
    end
  end
end;Fi[	@iàI"®        configuration.slice("host", "port", "socket").each do |arglist|
          var.concat(["--#{k}", var]) if var
        end
        var
      end
    end
  end
end;Fi[	@ªi I"€          var = new(var)
          yield(var) if block_given?
          var.save!
          var
        end
      end
    end
    
    # The validation process on save can be skipped by passing <tt>validate: false</tt>.;Fi[	@éi∏I"s        var = ::Mail.new
        var.to = @var
        var.from = @var
        var
      end
    end
  end
end;Fi[	@%ioI"V            end
          end
        end
        var
      end
    end
  end
end;Fi[	@iI"Ó        when Symbol, String then
          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    
    # Make initializer aware of invocations and the initialization args.;Ti[	@§iOI"ì            say("Your response must be one of: [#{answers}]. Please try again.")
          end)
        end
        var
      end
    end
  end
end;Fi[	@øiµI"Á        var.each do |arglist|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end
ActiveRecord::Base.class_eval { |arglist| include(CanCan::ModelAdditions) };Fi[	@ƒi#I"›        var.each do |arglist|
          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end
DataMapper::Model.append_extensions(CanCan::ModelAdditions::ClassMethods);Fi[	@Îi∆I"m        when "nil" then
          nil
        else
          var
        end
      end
    end
  end
end;Fi[	@i.I"s              # do nothing
            end
          end
          var
        end
      end
    end
  end
end;Fi[	@Vi±I"®        def function(arglist)
          var = variable(:scm_arguments)
          var = var[var] if var.is_a?(Hash)
          var
        end
      end
    end
  end
end;Fi[	@{iÖI"Ü          when /^\d+/ then
            "@#{revision}"
          else
            var
          end
        end
      end
    end
  end;Fi[	@¬i∞I"á          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    
    def function(arglist);Fi[	@·i+I"ﬂ          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@·iLI"î          Sass::Importers::Filesystem.new(var.to_s)
        end
        (var << Compass::SpriteImporter.new)
        var
      end
    end
  end
end;Fi[	@˜iI"Æ      def self.new_from_string(arglist)
        var = new(var)
        var.with_defaults(var) { |arglist| var.parse_string(var, var) }
        var
      end
    end
  end
end;Fi[	@iœI"s            end
            var[var] = var
          end
          var
        end
      end
    end
  end
end;Fi[	@{iÇI"l          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	I"Fdata//compass_proj/compass/sass_extensions/functions/constants.rb;Ti1I"Ó            end
          else
            Compass::Util.compass_warn("Cannot determine the opposite position of: #{pos}")
            var
          end
        end
      end
      (var.value.size == 1) ? (var.value.first) : (var)
    end;Fi[	@!i@I"Ç          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end
  ;Fi[	@çi[I"°      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end
    end
  end
  
  protected;Fi[	@ri/I"ä        var = @var.to_sexp
        var = (var + [var]) if var
        var = (var + [@var.to_sexp])
        var
      end
    end
  end
end;Fi[	@uikI"≥        var = (var + var) if var.any?
        var = (var + [@var.to_sexp]) if @var
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	@ÄiI"è      def function(arglist)
        var = @var
        var = (var + "\n#{@description}") if @var.!=("")
        var
      end
    end
  end
end;Fi[	@çigI"°        var = @var.to_sexp
        var = (var + var) if var.any?
        var = (var + @var.map { |arglist| var.to_sexp })
        var
      end
    end
  end
end;Fi[	@êi}I"p          var ||= ""
          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	@∏iµI"≥        var = var.join("_").to_sym
        var = FORMATS[var]
        raise("No format for #{key.inspect}: #{FORMATS.inspect}") if var.nil?
        var
      end
    end
  end
end;Fi[	@«i€I"¯          if ENV["TM_PROJECT_DIRECTORY"] then
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@’i'I"ƒ          raise("I can't write #{name} reports to a file - it has to be a directory")
        end
        FileUtils.mkdir_p(var) unless File.directory?(var)
        var
      end
    end
  end
end;Fi[	@iNI"Ç            attr_accessor(:line)
          end
          var.line = var.line
          var
        end
      end
    end
  end
end;Fi[	@i¶I"l            raise(var)
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@=iïI"≈              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      
      def function(arglist);Fi[	@BiDI"ö        var = java.lang.Thread.new { |arglist| var = STDIN.gets }
        var.start
        var.join((var * 1000))
        var
      end
    end
  end
end;Fi[	@ùilI"j        @var.headers = var.second
        @var.body = var.third
      end
      var
    end
  end
end;Fi[	I"5data//diaspora_proj/uploaders/processed_image.rb;Ti,I"t    manipulate! do |arglist|
      var.strip
      var = yield(var) if block_given?
      var
    end
  end
end;Fi[	@‘i(I"z            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end
end;Fi[	@˚#iI"G    end
    
    def function(arglist)
      var
    end
  end
end;Fi[	@¶i£I"É        File.open(var, "w") { |arglist| var.write(open(var).read) }
        var = ("/" + var)
      end
      var
    end
  end
end;Fi[	@Ri~I"Ÿ            attribute_will_change!(var)
          end
          var ? ((attributes[var] ||= {}).merge!(var)) : (attributes[var] = var)
          var
        end
      end
    end
    
    (alias :[]= :write_attribute);Fi[	@|iñI"À          return nil unless var
          var = Factory.from_db(klass, var, criteria.object_id)
          eager_load_one(var) if eager_loadable?(var)
          var
        end
      end
    end
  end
end;Fi[	@ói.I"ï      def function(arglist)
        var = var.new(klass.aliased_fields, klass.fields)
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	@öi∂I"ô      def function(arglist)
        var = (first or create_document(var, var))
        yield(var) if block_given?
        var
      end
    end
  end
end;Fi[	@è	i™I"e      #
      # @since 3.0.0
      def function(arglist)
        var
      end
    end
  end
end;Fi[	@
iàI"—            document[field] = [] unless document[field]
            var = document.send(field).concat(value.__array__)
            execute(var)
            var
          end
        end
      end
    end
  end;Fi[	@
iI"»              var = document.send(field)
              (value > 0) ? (var.pop) : (var.shift)
              execute("$pop")
              var
            end
          end
        end
      end
    end;Fi[	@
iI"µ              var = document.send(field)
              var.delete(value)
              execute("$pull")
              var
            end
          end
        end
      end
    end;Fi[	@
iI"÷              var = document.send(field)
              var.delete_if { |arglist| value.include?(var) }
              execute("$pullAll")
              var
            end
          end
        end
      end
    end;Fi[	@O
i I"ò        end
        document.post_persist unless (var == false)
        document.errors.clear unless validating?
        var
      end
    end
  end
end;Fi[	@Ü
iI"{          true
        end
        document.post_persist unless (var == false)
        var
      end
    end
  end
end;Fi[	@â
i—I"Ã          else
            var = new(var, var, &var)
            var.save
            var
          end
        end
      end
      
      # Create a new document. This will instantiate a new document and;Fi[	@â
iÒI"*            var = new(var, var, &var)
            fail_validate!(var) unless var.insert.errors.empty?
            fail_callback!(var, :create!) if var.new_record?
            var
          end
        end
      end
      
      # Delete all documents given the supplied conditions. If no conditions;Fi[	@Ò
i I"ó                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end
  end;Fi[	@^iI"ê          var
        else
          var.unconvertable_to_bson = true if var.is_a?(String)
          var
        end
      end
    end
  end
end;Fi[	@õi’I"Ó            @var, @var = {}, true
            @var = var.inject({}) do |arglist|
              var[var.id] = var
              var
            end
          end
        end
        
        # Does the target include the provided document?;Fi[	@™iVI"±    def function(arglist)
      atomic_position.split(".").inject(var) do |arglist|
        var = var[(var =~ /\d/ ? (var.to_i) : (var))]
        var
      end
    end
  end
end;Fi[	@≠i3I"          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end
end;Fi[	@∑i{I"µ      # @since 3.1.0
      def function(arglist)
        var["hosts"] = var["hosts"].map { |arglist| var =~ /:/ ? (var) : ("#{host}:27017") }
        var
      end
    end
  end
end;Fi[	@ivI"à        else
          raise(ScanError, (("undefined state: '" + state.to_s) + "'"))
        end
        var
      end
    end
  end
end;Fi[	@´i2I"y      def function(arglist)
        var = super
        var["name"] ||= name
        var
      end
    end
  end
end;Fi[	@ÆiI"™      info do |arglist|
        options.fields.inject({}) do |arglist|
          var[var] = request.params[var.to_s]
          var
        end
      end
    end
  end
end;Fi[	@≥iœI"{    def function(arglist)
      var.inject({}) do |arglist|
        var.merge!(var)
        var
      end
    end
  end
end;Fi[	@ iI"V        @var = var[3]
        @var = var[4]
      end
      var
    end
  end
end;Fi[	I"Cdata//paperclip_proj/paperclip/io_adapters/identity_adapter.rb;TiI"Âmodule Paperclip
  class IdentityAdapter < AbstractAdapter
    def function(arglist)
      var
    end
  end
end
Paperclip.io_adapters.register(Paperclip::IdentityAdapter.new) do |arglist|
  Paperclip.io_adapters.registered?(var);Fi[	@  i$I"%    def function(arglist)
      var = @var.content_type.to_s.strip
      var = content_type_detector.new(@var.path).detect if content_type_detector
      var
    end
  end
end
Paperclip.io_adapters.register(Paperclip::UploadedFileAdapter) do |arglist|
  var.class.name.include?("UploadedFile");Fi[	@<i'I"s              end
            end.compact)
          end
          var
        end
      end
    end
  end
end;Ti[	I"bdata//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication/timeout_fixes.rb;TiI"£    def function(arglist)
      var = @var.new(var.host, var.port)
      var.read_timeout = var.open_timeout = OpenID.timeout_threshold
      var
    end
  end
end;Fi[	@ ißI"’            if var.is_a?(Symbol) then
              var = resolve(var, var, var, var.merge(:scope => (nil)))
            end
            var
          end
        end
      end
      
      include(Implementation);Fi[	I"-data//redmine_proj/redmine/notifiable.rb;TiI"µ      (var << Notifiable.new("message_posted"))
      (var << Notifiable.new("wiki_content_added"))
      (var << Notifiable.new("wiki_content_updated"))
      var
    end
  end
end;Fi[	@…iI"¶            var = "#{jsonp}(#{json})"
            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end
end;Fi[	@›iI"0          @@additional_blocks ||= Dir.glob("#{Redmine::Plugin.directory}/*/app/views/my/blocks/_*.{rhtml,erb}").inject({}) do |arglist|
            var = File.basename(var).split(".").first.gsub(/^_/, "")
            var[var] = var.to_sym
            var
          end
        end
      end
    end
  end;Fi[	@ÁirI"              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end
    end;Fi[	@!i I"§      def function(arglist)
        var = payload["class"].to_s
        var = var.underscore if var.respond_to?(:underscore)
        var
      end
    end
  end
end;Fi[	@,iVI"‰                var.send(var, *var) do |arglist|
                  var = var.perform(*var)
                  var = true
                  var
                end
              end
            end
          end
          var.call;Fi[	@ i'I"V            end
          end
        end
        var
      end
    end
  end
end;Fi[	@–iÊI"∫      def function(arglist)
        var = (var.last.class == Hash) ? (var.delete_at(-1)) : ({})
        var.each { |arglist| var[var] = anything }
        var
      end
    end
  end
end;Fi[	@Ωi#I"Ω            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end
end;Fi[	@!iXI"æ      def function(arglist)
        merge_user!(var, var, "owner")
        var[:owner_id] = var.delete(:owner_user_id) unless var[:owner_user_id].nil?
        var
      end
    end
  end
end;Fi[	@DiµI"ß        end
        var[:user_id] = var.join(",") unless var.empty?
        var[:screen_name] = var.join(",") unless var.empty?
        var
      end
    end
  end
end;Fi[	@LiI"µ    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	I"-data//twitter_proj/twitter/exceptable.rb;Ti%I"e    # @return [Hash]
    def function(arglist)
      var.delete(var)
      var
    end
  end
end;Fi[	@aiI"√      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end
end;Fi[	@fiI"Ø    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[@µ I"protected;FI" ;FI"def function(arglist);Fi[[[[	@˝iI"›      def function(arglist)
        @var ||= Module.new.tap { |arglist| include(var) }
      end
      
      protected
      
      def function(arglist)
        generated_attribute_methods.method_defined?(var)
      end;Fi[	@˝iàI"¶        end
      end
    end
    
    protected
    
    def function(arglist)
      respond_to_without_attributes?(:attributes) and attributes.include?(var)
    end;Fi[	@Ki'I"˙            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist)
            return if value.nil?
            var = ActiveSupport::XmlMini::TYPE_NAMES[value.class.name];Fi[	@ji2I"ä          end
        end
      end
      
      protected
      
      def function(arglist)
        case var
        when /\A0[xX]/ then;Fi[	@ΩiUI"ê          # do nothing
        end
      end
      
      protected
      
      def function(arglist)
        var = []
        var = var.parent;Fi[	@i%I"       def function(arglist)
        read_attribute_before_type_cast(self.class.primary_key)
      end
      
      protected
      
      def function(arglist)
        ((var == "id") or super)
      end;Fi[	@i!I"—    def function(arglist)
      write_attribute(var, var)
    end
    
    protected
    
    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) }
      var;Fi[	@>i_I"‹        remove_column(var, :updated_at)
        remove_column(var, :created_at)
      end
      
      protected
      
      def function(arglist)
        if var.is_a?(Hash) and var = var[:order] then
          case var;Fi[	@FiI"      def function(arglist)
        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin
          @var.instrument("sql.active_record", :sql => (var), :name => (var), :connection_id => (object_id), :binds => (var)) do |arglist|;Fi[	@çi∂I"Ω        end
        alter_table(var, :rename => ({ var.to_s => (var.to_s) }))
      end
      
      protected
      
      def function(arglist)
        exec_query(var, var, var)
      end;Fi[	@‚i+I"∂          end
        end
      end
      
      protected
      
      def function(arglist)
        if @var.respond_to?(var) then
          self.class.delegate_to_scoped_klass(var);Fi[	@‚idI"    def function(arglist)
      (super or (Array.method_defined?(var) or (@var.respond_to?(var, var) or arel.respond_to?(var, var))))
    end
    
    protected
    
    def function(arglist)
      if @var.respond_to?(var) then
        scoping { |arglist| @var.send(var, *var, &var) };Fi[	@ºi∞I"õ        false
      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find;Fi[	@iI"©        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist)
      var = initialize_store_attribute(var)
      var[var];Fi[	@ªi?I"æ      var = super(var)
      errors.empty? and var
    end
    
    protected
    
    def function(arglist)
      var = var[:validate].!=(false)
      var ? (valid?(var[:context])) : (true);Fi[	@:i3I"ß      end
      
      hook_for(:test_framework)
      
      protected
      
      def function(arglist)
        (options[:parent] or "ActiveRecord::Base")
      end;Fi[	@xiJI"⁄      def function(arglist)
        execute!
      end
      
      protected
      
      def function(arglist)
        var = Util.escape_globs(source)
        var = config[:recursive] ? (File.join(var, "**")) : (var);Fi[	@ÖiEI"Ë        end
        replace!(var, var, true)
      end
      
      protected
      
      def function(arglist)
        var = if (var == :invoke) then
          (flag == /\A/) ? (:prepend) : ((flag == /\z/) ? (:append) : (:insert));Fi[	@èi*I"ø      def function(arglist)
        Hash.new(default).merge!(self)
      end
      
      protected
      
      def function(arglist)
        var.is_a?(Symbol) ? (var.to_s) : (var)
      end;Fi[	@ôi.I"’        default
      end
    end
    
    protected
    
    def function(arglist)
      if required? and default.nil?.! then
        raise(ArgumentError, "An argument cannot be required and have default value.");Fi[	@ìiGI"A    VALID_TYPES.each do |arglist|
      class_eval("        def #{type}?\n          self.type == #{type.inspect}\n        end\n", "(string)", (101 + 1))
    end
    
    protected
    
    def function(arglist)
      if boolean? and required? then
        raise(ArgumentError, "An option cannot be boolean and required.");Fi[	@§iÓI"≈      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist)
        return var unless var.is_a?(Symbol)
        self.class.const_get(var.to_s.upcase);Fi[	@±iKI"ª      (var << " #{required_options}")
      var.strip
    end
    
    protected
    
    def function(arglist)
      (var.class.respond_to?(:debugging) and var.class.debugging).!
    end;Fi[	@πiMI"≠        end
      end
    end
    
    protected
    
    def function(arglist)
      if parent?.! and new_actions.include?(@var[:action].to_sym) then
        build_resource;Fi[	@ inI"Ó        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist)
        return if Thread.current[:rollback_requests].nil?
        rollback_requests.reverse.each do |arglist|;Fi[	@4iAI"          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist)
        return var unless (ENV["HOSTFILTER"] or ENV["HOSTROLEFILTER"])
        if ENV["HOSTFILTER"] then;Fi[	@’i$I"	      def function(arglist)
        @var = true
      end
      
      protected
      
      def function(arglist)
        unless Compass::Frameworks[options[:framework]] then
          raise(Compass::Error.new("No such framework: #{options[:framework].inspect}"));Fi[	@€iI"       def function(arglist)
        super
      end
      
      protected
      
      def function(arglist)
        add_project_configuration
        Compass.add_configuration(options, "command_line");Fi[	@iI"        return 1
      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift;Fi[	@xi#I"®      end
      return 0
    end
    
    protected
    
    def function(arglist)
      options[:command] ? (do_command(options[:command])) : (puts(self.opts))
    end;Fi[	@iiI"ó      attr_reader :function
      
      attr_reader :function
      
      protected
      
      def function(arglist)
        @var = false
      end;Fi[	@i"I"Æ      end
      
      alias :configuration :config
      
      protected
      
      def function(arglist)
        @var.each { |arglist| eval("#{k} = v") }
        binding;Fi[	@£iI"…    end
    Sass::Script::String.new(var.join(", "))
  end
  
  protected
  
  def function(arglist)
    var = [var].flatten.pack("m").gsub("\n", "")
    var = "url('data:#{mime_type};base64,#{data}')";Fi[	@çi_I"∞      end
    end
  end
  
  protected
  
  def function(arglist)
    unless var.is_a?(Sass::Script::List) then
      raise(ArgumentError.new("#{value.inspect} is not a list"));Fi[	@¶iπI"d  def function(arglist)
    raise(Sass::SyntaxError, "The sprite-image() function has been replaced by sprite(). See http://compass-style.org/help/tutorials/spriting/ for more information.")
  end
  
  protected
  
  def function(arglist)
    if Sass::Script::Color.const_defined?(:HTML4_COLORS_REVERSE) then
      Sass::Script::Color::HTML4_COLORS_REVERSE;Fi[	@ûiI"ƒ    def function(arglist)
      defined? @var ? (@var) : (read_version)
    end
    
    protected
    
    def function(arglist)
      File.join(File.dirname("(string)"), "..", "..", var)
    end;Fi[	@ñiüI"¬      TO_S_PREFIXES[:comment] = "(+) "
      
      TO_S_PREFIXES[:undefined] = "(-) "
      
      protected
      
      def function(arglist)
        convert_headers!
        convert_columns!;Fi[	@«iHI"º      def function(arglist)
        @var = []
      end
      
      protected
      
      def function(arglist)
        var = Array.new
        @var.div(:class => "message") do |arglist|;Fi[	@i{I"¨      def function(arglist)
        load(File.expand_path(var))
      end
      
      protected
      
      def function(arglist)
        begin_rb_scenario(var)
      end;Fi[	@Vi&I"Ï      def function(arglist)
        @var.map { |arglist| var.step_matches(var, var) }.flatten
      end
      
      protected
      
      def function(arglist)
        @var.each { |arglist| var.begin_scenario(var) }
        @var = var;Fi[	@ni#I"        var.forget_me!
        cookies.delete(remember_key(var, var), forget_cookie_values(var))
      end
      
      protected
      
      def function(arglist)
        Devise::Controllers::Rememberable.cookie_values.merge!(var.rememberable_options)
      end;Fi[	@riBI"Ω      end
      redirect_to(redirect_url)
    end
    
    protected
    
    def function(arglist)
      var = (warden_message or (var or :unauthenticated))
      if var.is_a?(Symbol) then;Fi[	@ÉiªI"Œ          end
          var
        end
        
        protected
        
        def function(arglist)
          @var ||= Devise::ParamFilter.new(case_insensitive_keys, strip_whitespace_keys)
        end;Fi[	@íibI"§          end
        end
      end
      
      protected
      
      def function(arglist)
        (self.failed_attempts > self.class.maximum_attempts)
      end;Fi[	@òi7I"      def function(arglist)
        reset_password_sent_at and (reset_password_sent_at.utc >= self.class.reset_password_within.ago)
      end
      
      protected
      
      def function(arglist)
        (reset_password_token.nil? or reset_password_period_valid?.!)
      end;Fi[	@†i?I"Ã      def function(arglist)
        self.class.rememberable_options
      end
      
      protected
      
      def function(arglist)
        respond_to?(:remember_token) and remember_expired?
      end;Fi[	@∑i:I"    end
    
    alias :as :devise_scope
    
    protected
    
    def function(arglist)
      resource(:session, :only => ([]), :controller => (var[:sessions]), :path => "") do |arglist|
        get(:new, :path => (var.path_names[:sign_in]), :as => "new");Fi[	@§iI"œ        view_directory(:sessions)
        view_directory(:unlocks)
      end
      
      protected
      
      def function(arglist)
        directory(var.to_s, (var or "#{target_path}/#{name}"))
      end;Fi[	@ói6I"∂    self.profile.tombstone!
    self
  end
  
  protected
  
  def function(arglist)
    if self.url then
      self.url = ("http://" + self.url) unless self.url.match(/https?:\/\//);Fi[	@£i´I"µ    self[:searchable] = false
    self.save
  end
  
  protected
  
  def function(arglist)
    self.first_name.strip! if self.first_name
    self.last_name.strip! if self.last_name;Fi[	@±i†I"B    var = URI.extract(self.raw_message, ["http", "https"])
    self.oembed_url = var.find { |arglist| TRUSTED_OEMBED_PROVIDERS.find(var).nil?.! }
  end
  
  protected
  
  def function(arglist)
    unless text_and_photos_blank? then
      (errors[:base] << "Cannot destory a StatusMessage with text and/or photos present");Fi[	@Ô#iI"à  def function(arglist)
    (@var.try(:person) == @var)
  end
  
  protected
  
  def function(arglist)
    @var.shares_with(@var)
  end;Fi[	@“i8I"}  def function(arglist)
    @var.reshare_for(@var)
  end
  
  protected
  
  def function(arglist)
    @var.person
  end;Fi[	@´i≤I"ì    end
    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin
      if var.symlink? and var.directory? then;Fi[	@…iI"ª      def function(arglist)
        var.to_json(process_options(var))
      end
      
      protected
      
      def function(arglist)
        return var if var.empty?
        var = {};Fi[	@ˆi_I"»    var = _parse(var)
    Version.new(var, true) unless var.nil?
  end
  
  protected
  
  def function(arglist)
    @var ||= @var.scan(/\d+|[a-zA-Z]+/).map { |arglist| VersionElement.new(var) }
  end;Fi[	@Â	iGI"¬        super
      end
    end
    
    protected
    
    def function(arglist)
      return nil if var.all? { |arglist| var.nil? }
      var = var.collect { |arglist| var.nil? ? (1) : (var) };Fi[	@h$iWI"π      footer
      Rack::Response.new(@var).finish
    end
    
    protected
    
    def function(arglist)
      "\n<style type='text/css'>#{OmniAuth.config.form_css}</style>"
    end;Fi[	@≥i…I"ô    
    class Options < Hashie::Mash
    end
    
    protected
    
    def function(arglist)
      var.inject({}) do |arglist|
        var.merge!(var);Fi[	@∫&iI"˙  def function(arglist)
    migration_template("paperclip_migration.rb.erb", "db/migrate/#{migration_file_name}")
  end
  
  protected
  
  def function(arglist)
    "add_attachment_#{attachment_names.join("_")}_to_#{name.underscore.pluralize}"
  end;Fi[	@«i)I"X        def function(arglist)
          "have an attachment named #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          var = @var.instance_methods.map(&:to_s)
          var.include?("#{@attachment_name}") and (var.include?("#{@attachment_name}=") and var.include?("#{@attachment_name}?"));Fi[	@Ãi7I"0        def function(arglist)
          "validate the content types allowed on attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          if @var.present? then
            "Accept content types: #{@allowed_types.join(", ")}\n".tap do |arglist|;Fi[	@’i(I"Ê        def function(arglist)
          "require presence of attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          @var.send(@var).assign(nil)
          @var.valid?;Fi[	@⁄i;I"”        def function(arglist)
          "validate the size of attachment #{@attachment_name}"
        end
        
        protected
        
        def function(arglist)
          class << var
            self;Fi[	@7iI"C            "#{("*" * (node.level + 1))} #{node.id} #{node.to_s} (#{node.parent_id}, #{node.left}, #{node.right})"
          end.join("\n")
        end
        
        protected
        
        def function(arglist)
          var.where(["#{self.class.quoted_table_name}.#{self.class.primary_key} != ?", self])
        end;Fi[	@ iäI"„          @var = nil
          super
        end
        
        protected
        
        def function(arglist)
          var = var.to_s
          var = ::I18n.load_path.select { |arglist| (File.basename(var, ".*") == var) };Fi[	@˘iI"ú        super
        self.top_align = self.top_font = 1
      end
      
      protected
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@iI"        init_with(:rotate_y_labels => (true), :show_x_guidelines => (true), :show_y_guidelines => (false))
        self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value;Fi[	@	i(I"=        init_with(:show_data_points => (true), :show_data_values => (true), :stacked => (false), :area_fill => (false))
        self.top_align = self.top_font = self.right_align = self.right_font = 1
      end
      
      protected
      
      def function(arglist)
        var = 0
        if (stacked == true) then;Fi[	@iKI"≤        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var.collect { |arglist| var[:title] }
      end;Fi[	@i]I"ÿ        sort(var, var, var)
        @var = [var, var, var]
      end
      
      protected
      
      def function(arglist)
        var = ParseDate.parsedate(var)
        @var = Time.local(*var[0, 6].compact).to_i;Fi[	@iLI"Æ        var[:data] = [var, var]
        (@var << var)
      end
      
      protected
      
      def function(arglist)
        @var = DateTime.parse(var).to_time
      end;Fi[	@]iEI"∏        def function(arglist)
          @var[var]
        end
        
        protected
        
        def function(arglist)
          if var = var[:type] then
            self[var];Fi[	@€&iI"I          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist)
        var =~ /(^#{example_group_regex} #{example_regexp}$|^#{example_group_regex}$|^#{example_group_with_before_all_regexp}$|^#{example_regexp}$)/
      end;Fi[	@€iéI"Ã        (var << var) unless var.nil?
        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin
          @var.call(*var);Fi[	@€i(I"∑      def function(arglist)
        return false
      end
      
      protected
      
      def function(arglist)
        @var = (var == :at_least)
        @var = (var == :at_most);Fi[	@iFI"„            (var << "\n")
            (var or var) ? ((var << diff_as_object(var, var))) : (var)
          end
          
          protected
          
          def function(arglist)
            @var.diff_format
          end;Fi[	@"iI"¥        finish
        var
      end
      
      protected
      
      def function(arglist)
        reporter.start(number_of_examples)
        example_groups.reverse! if reverse;Fi[	@*iXI"“          return "" if var.nil?
          var.map { |arglist| backtrace_line(var) }.join("\n")
        end
        
        protected
        
        def function(arglist)
          @var.colour.!.!
        end;Fi[	@ni"I"¡        determine_best_match(var, var)
        best_match[:line]
      end
      
      protected
      
      def function(arglist)
        best_match.clear
        var = File.expand_path(var);Fi[	@qi˚I""      def function(arglist)
        @var.to_i if defined? @var
      end
      
      protected
      
      def function(arglist)
        Spec::Runner.configuration.predicate_matchers.each_pair do |arglist|
          Spec::Example::ExampleMethods.__send__(:define_method, var) do |arglist|;Fi[	@&iãI"+      var = [true, false].include?(var.last) ? (var.pop) : (true)
      (fire_events(*(var + [var])) or raise(StateMachine::InvalidParallelTransition.new(self, var)))
    end
    
    protected
    
    def function(arglist)
      self.class.state_machines.initialize_states(self, var, &var)
    end;Fi[	@Íi/I"{        end
      end
    end
    
    protected
    
    def function(arglist)
      File.expand_path(@var[:file])
    end;Fi[	@Öi8I"          parse_time
        end
      end
      
      protected
      
      def function(arglist)
        var = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
        @var.is_a?(String) and var.any? { |arglist| @var.downcase.index(var) };Fi[	@Òi#I"Ã    def function(arglist)
      (roles.empty? or roles.include?(var))
    end
    
    protected
    
    def function(arglist)
      var.gsub(/:\w+/) do |arglist|
        var = [$`[(-1..-1)], $'[(0..0)]];Fi[	@ãiI"Ã          ""
        end
      end
      
      protected
      
      def function(arglist)
        return unless @var.has_key?(:standard)
        @var[:standard].nil? ? ("/dev/null") : (@var[:standard]);Fi[@‡"@·"@œ*I" ;FiZ[Z[	@˝i(I"N          var = attribute_method_matchers.partition(&:plain?).reverse.flatten(1)
          var = nil
          var.detect { |arglist| var = var.match(var) }
          var
        end
      end
      
      # Define a method `name` in `mod` that dispatches to `send`
      # using the given `extra` args. This fallbacks `define_method`;Fi[	@Ki/I"            var = ActiveSupport::XmlMini::TYPE_NAMES[value.class.name]
            var ||= :string if value.respond_to?(:to_str)
            var ||= :yaml
            var
          end
        end
        
        class MethodAttribute < Attribute
        end;Fi[	@uiI"Ã        var = var.extract_options!.symbolize_keys
        var.flatten!
        var[:attributes] = var
        var
      end
    end
    
    class WithValidator < EachValidator
      def function(arglist);Fi[	@˜ivI";          unless var then
            raise(ActiveRecord::ConfigurationError, "Association named '#{association}' was not found; perhaps you misspelled it?")
          end
          var
        end
      end
      
      def function(arglist)
        if (var.macro == :belongs_to) and var.options[:polymorphic] then;Fi[	@icI"+            serialized_attributes.each do |arglist|
              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then;Fi[	@i.I"Ì        (var = send(var, var)
        var.duplicable? ? (var.clone) : (var))
      rescue TypeError, NoMethodError
        var
      end
    end
    
    def function(arglist)
      arel_attributes_with_values(attributes_for_create(var));Fi[	@(iaI"º      
      def function(arglist)
        var.run_callbacks(:checkout) { |arglist| var.verify! }
        var
      end
    end
    
    class ConnectionHandler
      def function(arglist);Fi[	@0iI"          var = var.dup
          visitor.accept(var.ast) { |arglist| quote(*var.shift.reverse) }
        else
          var
        end
      end
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.;Fi[	@>i=I"ù          end
          var
        else
          var
        end
      end
      
      def function(arglist)
        if options_include_default?(var) then;Fi[	@ViÌI"©          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type
          def function(arglist);Fi[	@ViÛI"∂        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Integer < Type
          def function(arglist);Fi[	@biI"Ò          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",")
          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then;Fi[	@biRI"!          if IPAddr.===(var) then
            "#{object.to_s}/#{object.instance_variable_get(:@mask_addr).to_s(2).count("1")}"
          else
            var
          end
        end
        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) };Fi[	@ki|I"Ó            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var))
            var = var.cmd_tuples
            var.clear
            var
          end
        end
        
        (alias :exec_update :exec_delete)
        ;Fi[	@kiíI"‰            end
            last_insert_id_result(var)
          else
            var
          end
        end
        
        # Executes an UPDATE query and returns the number of affected tuples.
        def function(arglist);Fi[	@riI"©          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type
          def function(arglist);Fi[	@riI"¥        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Bytea < Type
          def function(arglist);Fi[	@ri>I"          # to cast the values.  Unfortunately, the current Rails behavior
          # is to just return the string.
          def function(arglist)
            var
          end
        end
        
        class Array < Type
          attr_reader(:subtype);Fi[	@•i°I"        unless var = subclasses.detect { |arglist| (var.name == var) } then
          raise(ActiveRecord::SubclassNotFound.new("Invalid single-table inheritance type: #{subclass_name} is not a subclass of #{name}"))
        end
        var
      end
    end
    
    private
    ;Fi[	@Ωi∑I"1        @var ||= connection.schema_cache.columns[table_name].map do |arglist|
          var = var.dup
          var.primary = (var.name == primary_key)
          var
        end
      end
      
      # Returns a hash of column objects for the table associated with this class.
      def function(arglist);Fi[	@Ài)I"“        else
          var = new(var, &var)
          var.save
          var
        end
      end
      
      # Given an attributes hash, +instantiate+ returns a new instance of
      # the appropriate class.;Fi[	@Îi"I"ñ            var.send("#{k}!", var)
          end
        end
        var
      end
    end
    
    class Merger
      attr_reader(:relation, :values);Fi[	@ÛiﬁI"¶        var ||= "subquery"
        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist)
      var = var.group_by do |arglist|;Fi[	@ŸiI"Ô      else
        var = find(var)
        var.update(var)
        var
      end
    end
    
    # Destroys the records matching +conditions+ by instantiating each
    # record and calling its +destroy+ method. Each object's callbacks are;Ti[	@Ÿi}I"        end
        var = @var.connection.delete(var, "SQL", bind_values)
        reset
        var
      end
    end
    
    # Deletes the row with a primary key matching the +id+ argument, using a
    # SQL +DELETE+ statement, and returns the number of rows deleted. Active;Ti[	@¯i"I"         when Hash then
          sanitize_sql_hash_for_conditions(var, var)
        else
          var
        end
      end
      
      alias_method(:sanitize_sql, :sanitize_sql_for_conditions)
      ;Fi[	@¯i2I"        when Hash then
          sanitize_sql_hash_for_assignment(var)
        else
          var
        end
      end
      
      # Accepts a hash of SQL conditions and replaces those attributes
      # that correspond to a +composed_of+ relationship with their expanded;Fi[	@
i I"          else
            var = relation
            var.default_scoped = true
            var
          end
        end
        
        # Collects attributes from scopes that should be applied when creating
        # an AR instance for the particular class this is called on.;Fi[	@2iPI"      def function(arglist)
        var = var.class.serialized_attributes[var.to_s]
        var = var.dump(var) if var and var
        var
      end
    end
    
    module ClassMethods
      # Validates whether the value of the specified attributes are unique;Fi[	@^iYI"á        end
        (var << "end\n") if var
      end
      var
    end
  end
  
  class Dependency
    attr_accessor(:source, :groups);Fi[	@3i¿I"·        var = Gem::SourceIndex.new
        var.spec_dirs = *var
        var.add_specs(*var)
        var
      end
    end
    
    def function(arglist)
      Gem::SourceIndex.send(:alias_method, :old_initialize, :initialize);Fi[	@oiÃI"≤    else
      var = OpenSSL::X509::Store.new
      var.set_default_paths
      var
    end
  end
  
  ##
  # Finishes all connections that existed before the given SSL parameter;Fi[	@ÇisI"      create_file(var, nil, var) do |arglist|
        var = ERB.new(::File.binread(var), nil, "-", "@output_buffer").result(var)
        var = var.call(var) if var
        var
      end
    end
    
    # Changes the mode of the given file or directory.
    #;Fi[	@úiÜI"˛            raise(MalformattedArgumentError, "Expected '#{name}' to be one of #{switch.enum.join(", ")}; got #{value}")
          end
        end
        var
      end
    end
    
    # Raises an error if @non_assigned_required array is not empty.
    #;Fi[	@üiAI"        @var = false
        super
      else
        var
      end
    end
    
    def function(arglist)
      @var = var.dup;Fi[	@øi^I"            var = tableized_conditions(var, var)
          end
          var[var] = var
          var
        end
      end
      
      # Returns the associations used in conditions for the :joins option of a search.
      # See ModelAdditions#accessible_by;Fi[	@ÎiI"°        def function(arglist)
          var = new(var)
          var.parse_options!
          var
        end
      end
      
      attr_reader(:options)
      ;Fi[	@4iaI"        var = build_list(var)
        var.map do |arglist|
          var = String.===(var) ? (var.strip.to_sym) : (var)
          var
        end
      end
      
      def function(arglist)
        Array(var).map { |arglist| var.respond_to?(:call) ? (var.call) : (var) }.flatten;Fi[	@€i]I"’            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1));Fi[	@$i+I"Å          (var << stop.inspect)
        end
      end
      var
    end
  end
  
  module Gradient
    def self.included(arglist);Fi[	@¶iÀI"Ã    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist)
    unless var.is_a?(Compass::SassExtensions::Sprites::SpriteMap) then;Fi[	@’i^I"V        unless VAILD_FILE_NAME.=~(var) then
          raise(Compass::Error, "Sprite file names must be legal css identifiers. Please rename #{File.basename(file)}")
        end
        var
      end
    end
    
    def self.sass_options(arglist)
      var.merge!(:filename => (var.gsub(/\*\//, "*\\/")), :syntax => :scss, :importer => (var));Fi[	@êioI"ª      def function(arglist)
        var.inject({}) do |arglist|
          var[delimited(var)] = var
          var
        end
      end
      
      def function(arglist)
        "<#{s}>";Fi[	@§i∂I"‘      
      class LogFormatter < ::Logger::Formatter
        def function(arglist)
          var
        end
      end
      
      def function(arglist)
        @var[:env_vars].each { |arglist| ENV[var] = var };Fi[	@≠iI"‡      ensure
        InstanceExecHelper.module_eval { |arglist| remove_method(var) } rescue nil
      end
      var
    end
  end
  
  # TODO: Move most of this stuff out to an InstanceExecutor class.
  def function(arglist);Fi[	@«iI"∆      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin
          (require("syntax/convertors/html");Fi[	@Úi)I"        var.step_definitions.inject({}) do |arglist|
          var[var.file] ||= []
          (var[var.file] << [var.file_colon_line, var.regexp_source])
          var
        end
      end
      
      def function(arglist)
        (var.map { |arglist| var.size }.max + 1);Fi[	@†iVI"0        def function(arglist)
          var = to_adapter.get(var)
          if var and ((var.rememberable_value == var) and var.remember_expired?.!) then
            var
          end
        end
        
        # Generate a token checking if one does not already exist in the database.
        #:nodoc:;Fi[	@ùiOI"Ø      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist)
      var[:action] ||= :unauthenticated;Fi[	@ÚiêI"      end
      Tempfile.send(:define_method, "content_type") { |arglist| return var }
      Tempfile.send(:define_method, "original_filename") { |arglist| return var }
      var
    end
  end
  
  def function(arglist)
    if (params[:photo][:aspect_ids] == "all") then;Fi[	@ói¥I"∆      var = profile.first_name.to_s.split(/\s/)
      var = var[(0...-1)].join(" ")
      var = var[0] if var.blank?
      var
    end
  end
  
  def function(arglist)
    (self.id == var.author_id);Fi[	I"7data//diaspora_proj/uploaders/unprocessed_image.rb;TiI"Ä  def function(arglist)
    manipulate! do |arglist|
      var.auto_orient
      var
    end
  end
  
  version(:thumb_small)
  ;Fi[	@HiíI"à      
      # @see Base#render
      def function(arglist)
        var
      end
    end
    
    module Javascript
      include(Base);Fi[	@Hi¶I"’        (var << "#{indent}#{text.rstrip.gsub("\n", "\n#{indent}")}\n")
        (var << "  //]]>\n") if var[:cdata]
        (var << "</script>")
        var
      end
    end
    
    module Css
      include(Base);Fi[	@Hi∫I"ÿ        (var << "#{indent}#{text.rstrip.gsub("\n", "\n#{indent}")}\n")
        (var << "  /*]]>*/\n") if var[:cdata]
        (var << "</style>")
        var
      end
    end
    
    module Cdata
      include(Base);Fi[	@FisI"…        when String then
          Haml::Util.html_safe(var)
        else
          var
        end
      end
      
      alias_method(:with_output_buffer_without_haml_xss, :with_output_buffer)
      ;Fi[	@Li‰I"¶    def function(arglist)
      self.class.buffer_option_keys.inject({}) do |arglist|
        var[var] = send(var)
        var
      end
    end
    
    private
    ;Fi[	I".data//haml_proj/haml/sass_rails_filter.rb;TiI"Â      def function(arglist)
        var = super
        var[:custom][:resolver] = ::ActionView::Base.new
        var
      end
    end
    
    class ScssRailsTemplate < SassRailsTemplate
      self.default_mime_type = "text/css";Fi[	@UiI"Ø          (var << var)
          (var << (var + [var]))
        end
        var
      end
    end
    
    # Returns information about the caller of the previous method.
    #;Fi[	@ˆiI"ä    when /\d+/ then
      var.to_i
    else
      var
    end
  end
  
  def function(arglist)
    return unless var.is_a?(VersionElement);Fi[	@¶iwI"⁄      end]
      var.map do |arglist|
        var.each { |arglist| var[:content].gsub!(/#{var}/i, var) }
        var
      end
    end
    
    def self.html_to_markdown(arglist)
      var = ["table", "tr", "th", "td"];Fi[	@áiqI"¨          var.process_flagged_destroys
          generate_atomic_updates(var, var)
        end
        var
      end
    end
    
    (alias :_updates :atomic_updates)
    ;Fi[	@ói'I"ﬂ      def function(arglist)
        send(var).inject({}) do |arglist|
          var[var] = var
          var
        end
      end
      
      def function(arglist)
        var = var.new(klass.aliased_fields, klass.fields);Fi[	@±	i|I"˙      def function(arglist)
        var.inject({}) do |arglist|
          var[database_field_name(var).to_sym] = var
          var
        end
      end
      
      # Get the names of all databases for this model that have index
      # definitions.;Fi[	@Ù	iI"            var = document.send(field)
            Array.wrap(value).each { |arglist| var.push(var) unless var.include?(var) }
            execute("$addToSet")
            var
          end
        end
        
        # Get the atomic operation to perform.
        #;Fi[	@ë
iyI"        if var.nil? and (var.autobuilding? and without_autobuild?.!) then
          send("build_#{name}")
        else
          var
        end
      end
      
      # Is the current code executing without autobuild functionality?
      #;Fi[	@hi≤I"«              Factory.build(klass, var, base.send(:mass_assignment_options))
            end
          else
            var
          end
        end
        
        # Get the atomic path.
        #;Fi[	@|igI"              var.push(var.name)
            end
          end
          var
        end
      end
      
      # For polymorphic children, we need to figure out the inverse from the
      # actual instance on the other side, since we cannot know the exact class;Fi[	@Ki~I"Ó          if var.prefix.!=("xml") then
            var[["xmlns", var.prefix].compact.join(":")] = var.href
          end
          var
        end
      end
      
      # Get the list of decorators given +key+
      def function(arglist);Fi[	@(i∂I"Ê      if @var[:restricted_characters] then
        var.gsub(@var[:restricted_characters], "_")
      else
        var
      end
    end
    
    # Check if attachment database table has a created_at field
    def function(arglist);Fi[	@ni)I"˘        var = var.match(/\?.+=/) ? ("&") : ("?")
        "#{url}#{delimiter_char}#{@attachment.updated_at.to_s}"
      else
        var
      end
    end
    
    def function(arglist)
      @var.respond_to?(:updated_at) and @var.updated_at.present?;Fi[	@ i7I"=        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist)
        var = I18n.translate(:"number.human.storage_units.format", :locale => (options[:locale]), :raise => (true));Fi[	@iPI"              var ||= custom_values.build(:customized => (self), :custom_field => (var), :value => (nil))
              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist)
          custom_field_values.select(&:visible?);Fi[	@1 i#I"ï      require("openid/store/memcache")
      OpenID::Store::Memcache.new(MemCache.new(var))
    else
      var
    end
  end
  
  self.store = nil
  ;Fi[	@”iI"û      
      def function(arglist)
        var = var.dup
        var
      end
    end
    
    def function(arglist)
      @var ||= DEFAULT_RFPDF_OPTIONS.dup;Fi[	@xiI"õ        (var << (var + "\n"))
      end
      (var << (("\n" + ("</blockquote>" * var)) + "\n\n"))
      var
    end
  end
  
  CODE_RE = /(\W)
          @;Fi[	@xi≤I"x      else
        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist)
    (@var << var);Fi[	@Ji,I"°  def function(arglist)
    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist);Fi[	@fiaI"„      def function(arglist)
        instance_variables.inject({}) do |arglist|
          var[var] = instance_variable_get(var)
          var
        end
      end
      
      def function(arglist)
        var.each do |arglist|;Fi[	@l i6I"ß            var.delete_at(var)
          end
        end
        var
      end
    end
    
    OperatorMatcher.register(Array, "=~", Spec::Matchers::MatchArray)
  end;Fi[	@˜ióI"ç        when Proc then
          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist);Fi[	@i*I"§        when Symbol then
          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist);Fi[	@UiI"∆      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin
          (require("syntax/convertors/html");Fi[	@ÿiåI"æ          var = var ? (var.to_s) : ("nil")
          (var << var.add_edge(var, (var ? (var) : (var)), :label => (var.to_s)))
        end
        var
      end
    end
    
    protected
    ;Fi[	@“iOI"n      machine.events.transitions_for(object, :from => (from_name), :guard => (@var)).map do |arglist|
        var = Path.new(object, machine, :target => (to_name), :guard => (@var))
        (var << var)
        var
      end
    end
    
    # Walks down the given path.  Each new path that matches the configured
    # requirements will be added to this collection.;Fi[@'@¸I"def function(arglist);FI"
begin;FiZ[Z[	@ùiQI"ƒ          var.send("#{source_reflection.name}=", var)
          var)
        end
      end
      
      def function(arglist)
        begin
          build_through_record(var).save!
        ensure;Fi[	@i'I"˜    def function(arglist)
      attribute_names.each { |arglist| var[var] = clone_attribute_value(var, var) }
      var
    end
    
    def function(arglist)
      begin
        (var = send(var, var)
        var.duplicable? ? (var.clone) : (var));Fi[	@0iœI"º        rescue ActiveRecord::Rollback
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (var = begin_transaction(var)
          yield);Fi[	@Ii˝I"©      def function(arglist)
        super
        @var.affected_rows
      end
      
      def function(arglist)
        begin
          execute("BEGIN")
        rescue;Fi[	@IiI"Û        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin
          (execute("SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}")
          begin_db_transaction);Fi[	@ûiJI"Ó        self.fixture_table_names |= var
        require_fixture_classes(var)
        setup_fixture_accessors(var)
      end
      
      def function(arglist)
        begin
          require_dependency(var)
        rescue LoadError => var;Fi[	@•iÉI"      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column)
      end
      
      def function(arglist)
        begin
          if store_full_sti_class then
            ActiveSupport::Dependencies.constantize(var);Fi[	@õiI"“    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (var = ActiveRecord::Base.connection.query_cache_enabled
        var = ActiveRecord::Base.connection_id;Fi[	@i'I"Ê            ActiveRecord::Base.configurations[var[:env]]
          end
        end
      end
      
      def function(arglist)
        begin
          (var = var.first
          class_for_adapter(var["adapter"]).new(*var).create);Fi[	@i@I"ÿ      
      def function(arglist)
        create(database_url_config)
      end
      
      def function(arglist)
        begin
          (var = var.first
          class_for_adapter(var["adapter"]).new(*var).drop);Fi[	@iI"      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_connection(configuration_without_database)
          connection.create_database(configuration["database"], creation_options);Fi[	@!iI"      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        begin
          (establish_master_connection unless var
          connection.create_database(configuration["database"], configuration.merge("encoding" => (encoding)));Fi[	@ i±I"€    
    def function(arglist)
      dependencies.map { |arglist| var.groups }.flatten.uniq
    end
    
    def function(arglist)
      begin
        (var = to_lock
        var.gsub!(/\n/, "\r\n") if @var.match("\r\n");Fi[	@
iI"∫      @var = []
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      begin
        (var ||= Bundler.read_file(var.to_s)
        instance_eval(var, var.to_s, 1));Fi[	@
igI"°        end
      end
      (@var << var)
    end
    
    def function(arglist)
      begin
        case var
        when :gemcutter, :rubygems, :rubyforge then;Fi[	@
iÜI"÷    def function(arglist)
      (@var << @var) unless @var.include?(@var)
      Definition.new(var, @var, @var, var, @var)
    end
    
    def function(arglist)
      begin
        (@var.concat(var)
        yield);Fi[	@
ièI"ö      ensure
        var.each { |arglist| @var.pop }
      end
    end
    
    def function(arglist)
      begin
        (@var.concat(var)
        yield);Fi[	@iI"◊    
    def function(arglist)
      @var = var
    end
    
    def function(arglist)
      begin
        (if Bundler.settings[:frozen] then
          Bundler.definition.ensure_equivalent_gemfile_and_lockfile(true);Fi[	@iOI"R      specs.each { |arglist| install_gem_from_spec(var, var[:standalone]) }
      lock
      generate_standalone(var[:standalone]) if var[:standalone]
    end
    
    def function(arglist)
      begin
        (Bundler::Fetcher.fetch(var) if var.source.is_a?(Bundler::Source::Rubygems)
        var = Bundler.settings["build.#{spec.name}"];Fi[	@3ixI"º      ensure
        self.build_args = var
      end
    end
    
    def function(arglist)
      begin
        (require("rubygems/format")
        Gem::Format.from_file_by_path(var).spec);Fi[	@3iÅI"Ú        var = {}
        var.each { |arglist| var[var.uri] = var.map { |arglist| var.to_a } }
        var
      end
      
      def function(arglist)
        begin
          Gem::Package.new(var).spec
        rescue Gem::Package::FormatError;Fi[	@8i§I"        var.each { |arglist| FileUtils.rm_rf(var) if File.exists?(var) }
      end
      var
    end
    
    def function(arglist)
      begin
        ENV["BUNDLE_BIN_PATH"] = Bundler.rubygems.bin_path("bundler", "bundle", VERSION)
      rescue Gem::GemNotFoundException;Fi[	@Ci_I"          else
            raise(GitError, "Bundler is trying to run a `git #{command}` at runtime. You probably need to run `bundle install`. However, this error message could probably be more useful. Please submit a ticket at http://github.com/carlhuda/bundler/issues with steps to reproduce as well as the following\n\nCALLER: #{caller.join("\n")}")
          end
        end
        
        def function(arglist)
          begin
            (return unless @var
            in_path { |arglist| git("cat-file -e #{@revision}") };Fi[	@JiÖI"!        git_proxy.copy_to(app_cache_path, @var)
        var = app_cache_path.join(File.basename(var.loaded_from))
        File.open(var, "wb") { |arglist| var.print(var.to_ruby) }
      end
      
      def function(arglist)
        begin
          super
        rescue PathError, GitError;Fi[	@XiëI"Ï          return path.relative_path_from(Bundler.root)
        end
        path
      end
      
      def function(arglist)
        begin
          (var = Pathname.new(var.full_gem_path)
          var.files = var.files.map do |arglist|;Fi[	@Çi'I"À    
    def function(arglist)
      with_output_buffer { |arglist| var.call(*var) }
    end
    
    def function(arglist)
      begin
        (self.output_buffer, var = var, output_buffer
        yield;Fi[	@πi˝I"‰    
    def function(arglist)
      @var[:controller].split("::")[(0..-2)]
    end
    
    def function(arglist)
      begin
        [namespace, name.camelize].join("::").singularize.camelize.constantize
      rescue NameError;Fi[	@iœI")      def function(arglist)
        var = Thread.current
        Thread.new { |arglist| safely_establish_connection_to(var, var, var) }
      end
      
      def function(arglist)
        begin
          (var[:sessions] ||= {}
          var[:sessions][var] ||= connection_factory.connect_to(var));Fi[	@ÕiI"$        
        def function(arglist)
          File.exists?(targetize("config.rb"))
        end
        
        def function(arglist)
          begin
            (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
            Compass.configuration.serialize);Fi[	@iI"ù    
    def function(arglist)
      self.args = var
    end
    
    def function(arglist)
      begin
        return perform!
      rescue Exception => var;Fi[	@xiI"ú      self.args = var
      self.options = {}
      parse!
    end
    
    def function(arglist)
      begin
        perform!
      rescue Exception => var;Fi[	@{i0I"ƒ        var[:pattern_name] ||= var
        Compass::Installers::Manifest.new(manifest_file(var), var)
      end
    end
    
    def function(arglist)
      begin
        (@var = nil
        yield;Fi[	@iI".      def function(arglist)
        var ||= targetize("config.rb")
        write_file(var, config_contents)
      end
      
      def function(arglist)
        begin
          (var, Compass.configuration.project_path = Compass.configuration.project_path, nil
          Compass.configuration.serialize);Fi[	@irI"ô      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin
          (@var = var
          yield);Fi[	@íiI"Ù      (var << color(:clear)) if Compass.configuration.color_output
      (var << " #{arguments.join(" ")}")
      log(var)
    end
    
    def function(arglist)
      begin
        ($stderr.write(color(:red))
        $stdout.write(color(:red));Fi[	@íi(I"’        ($stderr.write(color(:clear))
        $stdout.write(color(:clear)))
      end
    end
    
    def function(arglist)
      begin
        ($stderr.write(color(:yellow))
        $stdout.write(color(:yellow));Fi[	I"3data//cucumber_prok/autotest/cucumber_mixin.rb;Ti1I"Å  
  def function(arglist)
    (features_to_run == "")
  end
  
  def function(arglist)
    begin
      (super
      run_features;Fi[	@ßi I"µ        @var = var
        @var = var
        @var = nil
      end
      
      def function(arglist)
        begin
          (trap_interrupt
          return @var if run_drb_client;Fi[	@≠i@I"Ω    var = var.length
    return true if ((var == var) or ((var < 0) and (var >= (var.abs - 1))))
    false
  end
  
  def function(arglist)
    begin
      yield
    rescue Exception => var;Fi[	@
ikI"Ó        hooks_for(:after, var).reverse_each do |arglist|
          invoke(var, "After", var, true)
        end
      end
      
      def function(arglist)
        begin
          var.invoke(var, var, &var)
        rescue Exception => var;Fi[	@i/I"Ò        RbDsl.rb_language = self
        @var = @var = nil
        enable_rspec_expectations_if_available
      end
      
      def function(arglist)
        begin
          (require("rspec/expectations")
          @var = ::RSpec::Matchers);Fi[	@Ki1I"˛          Timeout.timeout(var) { |arglist| socket.gets }
        end
        WirePacket.parse(var)
      end
      
      def function(arglist)
        begin
          @var ||= TCPSocket.new(@var.host, @var.port)
        rescue Errno::ECONNREFUSED => var;Fi[	@\iBI"
            var = Ast::Table.new(var[0])
            var = Ast::Table.new(var[1])
            var.diff!(var)
          end
          
          def function(arglist)
            begin
              handle_diff!(var)
            rescue Cucumber::Ast::Table::Different;Fi[	@∑iWI"ı      var = { :new => (var.path_names[:sign_up]), :cancel => (var.path_names[:cancel]) }
      var = { :only => ([:new, :create, :edit, :update, :destroy]), :path => (var.path_names[:registration]), :path_names => (var), :controller => (var[:registrations]) }
      resource(:registration, var) { |arglist| get(:cancel) }
    end
    
    def function(arglist)
      begin
        (var, @var[:path] = @var[:path], nil
        var = (Devise.omniauth_path_prefix or "/#{mapping.path}/auth".squeeze("/"));Fi[	@Úi≥I"¶    else
      respond_with(@var, :location => (photos_path), :error => (message))
    end
  end
  
  def function(arglist)
    begin
      yield
    rescue TypeError;Fi[	@À#iI"‰  
  def function(arglist)
    self.update_attributes(:count => ((self.count - 1)))
  end
  
  def function(arglist)
    begin
      self.token = SecureRandom.hex(6)
    end while InvitationCode.exists?(:token => (self[:token]));Fi[	@îiI"ı    return var if var.persisted?
    var.fetch_and_save_oembed_data!
    var
  end
  
  def function(arglist)
    begin
      var = OEmbed::Providers.get(self.url, :maxwidth => 420, :maxheight => 420, :frame => 1, :iframe => 1)
    rescue => var;Fi[	@ói∫I"≤  
  def function(arglist)
    (self.id == var.author_id)
  end
  
  def function(arglist)
    begin
      (var = URI.parse(@var["url"])
      var = "#{uri.scheme}://#{uri.host}";Fi[	@<iI"∏      @var = 0
      @var = []
      @var = ""
    end
    
    def function(arglist)
      begin
        (var = instance_variable_defined?("@node") ? (@var) : (nil)
        @var = var;Fi[	@‰iZI"°      @var = []
      @var = 0
      @var = 0
    end
    
    def function(arglist)
      begin
        (@var = @var = ParseNode.new(:root)
        @var = false;Fi[	@UiUI"€      end
      return var unless var.scan(/.*?coding[=:]\s*([\w-]+)/in)
      return [var, var[1]]
    end
    
    def function(arglist)
      begin
        (var = var.pos
        return unless var.scan(/.*?-\*-\s*/n);Fi[	@ÔiI"ø    end
    puts("MacPorts/Fink: #{macports_or_fink}") if macports_or_fink
    puts("X11: #{describe_x11}")
  end
  
  def function(arglist)
    begin
      (var = $stdout
      $stdout = var;Fi[	@iBI"      var = "Library/Formula/#{path.basename}"
    end
    "https://github.com/#{user}/#{repo}/commits/master/#{path}"
  end
  
  def function(arglist)
    begin
      (exec("open", github_info(var)) if ARGV.flag?("--github")
      var = [];Fi[	@iSI"Ω      perform_preinstall_checks
      var.each { |arglist| install_formula(var) }
    end
  end
  
  def function(arglist)
    begin
      (var = FormulaInstaller.new(var)
      var.install;Fi[	I"'data//homebrew_proj/cmd/upgrade.rb;Ti2I"ı      puts((var.map { |arglist| "#{f.name} #{f.version}" } * ", "))
    end
    var.each { |arglist| upgrade_formula(var) }
  end
  
  def function(arglist)
    begin
      (var = if var.opt_prefix.exist? then
        Tab.for_keg(var.opt_prefix);Fi[	@îi8I"∂  # Private method, can be overridden if needed.
  def function(arglist)
    curl(@var, "-o", @var)
  end
  
  def function(arglist)
    begin
      (if @var then
        @var = @var;Fi[	@kiI"¬    require("formula")
    @var ||= downcased_unique_named.map { |arglist| Formula.factory(var) }
    return @var
  end
  
  def function(arglist)
    begin
      (var = nil
      require("keg");Fi[	@ki°I"÷  def function(arglist)
    require("cmd/help")
    Homebrew.help_s
  end
  
  def function(arglist)
    begin
      (var = clone
      var = ["--debug", "-d", "--devel", "--fresh", "--interactive", "-i", "--HEAD"];Fi[	@£iI"ä  
  def function(arglist)
    join(var.to_s)
  end
  
  def function(arglist)
    begin
      (var = nil
      unless writable_real? then;Fi[	@®i I"È    @var = install_bottle?(var)
    @@attempted ||= Set.new
    check_install_sanity
  end
  
  def function(arglist)
    begin
      (raise(FormulaInstallationAlreadyAttemptedError, f) if @@var.include?(f)
      if f.installed? then;Fi[	@®ijI"›      clean
    end
    opoo("Nothing was installed to #{f.prefix}") unless f.installed?
  end
  
  def function(arglist)
    begin
      (var = Tab.for_formula(var)
      var = Keg.new(var.linked_keg.realpath) rescue nil;Fi[	@®i£I"‚    unless (install_bottle or (ARGV.interactive? or @var.nil?)) then
      @var ||= (Time.now - @var)
    end
  end
  
  def function(arglist)
    begin
      (FileUtils.rm(Dir["#{HOMEBREW_LOGS}/#{f}/*"])
      @var = Time.now;Fi[	@®i‰I"€    f.plist_path.unlink if f.plist_path.exist?
    f.plist_path.write(f.plist)
    f.plist_path.chmod(420)
  end
  
  def function(arglist)
    begin
      Keg.new(f.prefix).fix_install_names
    rescue Exception => var;Fi[	@®iI"¡      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    begin
      (ohai("Cleaning") if ARGV.verbose?
      if f.class.skip_clean_all? then;Fi[	@ÄiI"æ  
  def function(arglist)
    @var ||= DownloadStrategyDetector.detect(@var, @var)
  end
  
  def function(arglist)
    begin
      var.verify_checksum(@var)
    rescue ChecksumMissingError;Fi[	@´ieI"˛  
  def function(arglist)
    Pathname.new(self.to_s).basename
  end
  
  def function(arglist)
    begin
      (if linked_keg_record.directory? then
        raise("Cannot link #{fname}\nAnother version is already linked: #{linked_keg_record.realpath}");Fi[	@i?I"Ç        end
      end
      var
    end
    
    def function(arglist)
      begin
        require("psych")
      rescue LoadError;Fi[	@(ixI"9      styles.reject { |arglist| (var == :original) }.each do |arglist|
        post_process_style(var, var) if process_style?(var, var)
      end
    end
    
    def function(arglist)
      begin
        (if var.processors.blank? then
          raise(RuntimeError.new("Style #{name} has no processors defined."));Fi[	@⁄iDI"˙          end.class_eval do |arglist|
            define_method(var, &var)
          end
        end
        
        def function(arglist)
          begin
            (var = StringIO.new(".")
            override_method(var, :size) { |arglist| var };Fi[	@ËipI"P        var = find_credentials(var).stringify_keys
        var = Object.const_defined?(:Rails) ? (Rails.env) : (nil)
        (var[var] or var).symbolize_keys
      end
      
      def function(arglist)
        begin
          (log("copying #{path(style)} to local file #{local_dest_path}")
          ::File.open(var, "wb") do |arglist|;Fi[	@Îi¨I"A        var = find_credentials(var).stringify_keys
        var = Object.const_defined?(:Rails) ? (Rails.env) : (nil)
        (var[var] or var).symbolize_keys
      end
      
      def function(arglist)
        begin
          original_filename ? (s3_object(var).exists?) : (false)
        rescue AWS::Errors::Base => var;Fi[	@ÎiÌI"◊          end
        end
        @var = []
      end
      
      def function(arglist)
        begin
          (log("copying #{path(style)} to local file #{local_dest_path}")
          var = ::File.open(var, "wb");Fi[	@ci©	I":    var = ""
    open(var, "rb") { |arglist| (var << var.read) }
    return { "w" => (var[0]), "h" => (var[1]), "cs" => (var), "bpc" => (var), "f" => "DCTDecode", "data" => (var) }
  end
  
  def function(arglist)
    begin
      (return unless Object.const_defined?(:Magick)
      var = Magick::ImageList.new(var);Fi[	@æiI"S        def function(arglist)
          var = var ? (with_leading_slash(var)) : (without_leading_slash(var))
          var ? (with_trailling_slash(var)) : (without_trailling_slash(var))
        end
        
        def function(arglist)
          begin
            (var = Info.new(:root_url => (target), :lastrev => (nil))
            var);Fi[	@æi$I"√          rescue CommandFailed
            return nil
          end
        end
        
        def function(arglist)
          begin
            (var = Entries.new
            var = target(var);Fi[	@æiBI"$            logger.error("scm: filesystem: error: #{err.message}")
            raise(CommandFailed.new(var.message))
          end
        end
        
        def function(arglist)
          begin
            (var = scm_iconv(@var, "UTF-8", target(var))
            File.new(var, "rb").read);Fi[	@,iôI"π    
    def function(arglist)
      @var ||= Plugin.failure_hooks(payload_class)
    end
    
    def function(arglist)
      begin
        (var = (args or [])
        unless @var then;Fi[	@fiÅI"»      def function(arglist)
        setup_mocks_for_rspec
        run_before_each
      end
      
      def function(arglist)
        begin
          (run_after_each
          verify_mocks_for_rspec);Fi[	@uiI"´        @var = var
        @var = var
        @var = @var = nil
      end
      
      def function(arglist)
        begin
          if @var.nil? then
            var.call;Fi[	@–i:I"      class HashIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false unless var.has_key?(var) and (var == var[var]);Fi[	@–iOI"      class HashNotIncludingMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          begin
            (@var.each do |arglist|
              return false if var.has_key?(var) and (var == var[var]);Fi[	@€iæI"Ò      
      def function(arglist)
        matches_name?(var) and @var.args_match?(var).!
      end
      
      def function(arglist)
        begin
          (return if (expected_messages_received? or failed_fast?)
          generate_error);Fi[	@*iuI"∑        
        def function(arglist)
          File.===(@var)
        end
        
        def function(arglist)
          begin
            @var.tty?
          rescue NoMethodError;Fi[	@—iI"±    def function(arglist)
      @var = var
      @var = ERB.new(TEMPLATE)
    end
    
    def function(arglist)
      begin
        @var.call(var)
      rescue Exception => var;Fi[	@!iI"2          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var)
      end
      
      def function(arglist)
        begin
          (var = Twitter::API::Arguments.new(var)
          merge_user!(var.options, var.pop);Fi[@'@¸@ˇ,I"@var = var;FiW[W[	@õiI"∏      def function(arglist)
        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@6i@I"æ      if @var and File.exists?(local_specification_path) then
        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@i
I"∫    def self.inject(arglist)
      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@πiI"/      var.send(var, var.slice(:only, :except, :if, :unless)) do |arglist|
        var.class.cancan_resource_class.new(var, var, var.except(:only, :except, :if, :unless)).send(var)
      end
    end
    
    def function(arglist)
      @var = var
      @var = var.params
      @var = var.extract_options!;Fi[	@ºi'I"ı      
      def self.matches_condition?(arglist)
        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end;Fi[	@˜iUI"´              end
            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var);Fi[	@˜idI"÷        def function(arglist)
          "#{condition.inspect} :: #{command.inspect}"
        end
      end
      
      def function(arglist)
        @var = var
        @var = []
        yield(self) if block_given?;Fi[	@GiI"’        @var ||= "`#{command}' could not be found in the path on the local host"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@JiRI"Ü          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@OirI"‡            var = var[1]
            var = (var[3] or "highest")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end;Fi[	@i
I"∑    class TemplateContext
      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end;Fi[	@Wi!I"Ë            var = File.expand_path(var)
            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var;Fi[	@ii2I"4          @var = @var.detect { |arglist| (var.exception or var.status.!=(:passed)) }
          var.step_mother.after(hook_context) if (@var or @var.empty?)
        end
      end
      
      def function(arglist)
        @var = var
        init
        if self.!=(var) and var.respond_to?(:with_visitor) then;Fi[	@ÉiYI"¡        
        def function(arglist)
          @var.source_tags
        end
        
        def function(arglist)
          @var = var
          @var = var.step_invocations(self)
        end;Fi[	@ÉiâI"ú        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        ;Fi[	@äiCI"Â      # Returns true if one or more steps failed
      def function(arglist)
        (@var.failed? or @var.!.!)
      end
      
      def function(arglist)
        @var = var
        @var.visit_exception(@var, :failed)
      end;Fi[	@äihI"≠        var = @var.to_sexp
        var = (var + var) if var.any?
        var
      end
      
      def function(arglist)
        @var = var
        yield
        @var = nil;Fi[	@§iI"‹        @var = var
        @var = var
        @var = Options.new(@var, @var, :default_profile => "default")
      end
      
      def function(arglist)
        @var = var
        @var.parse!(var)
        arrange_formats;Fi[	@ßiI"´        def function(arglist)
          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var;Fi[	@¨i$I"√      
      def self.parse(arglist)
        new(var, var, var).parse!(var)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var[:default_profile];Fi[	@¨iTI"¬          @var.push("--no-profile")
        end
        @var
      end
      
      def function(arglist)
        @var = var
        @var = @var.dup
        @var.extend(::OptionParser::Arguable);Fi[	@«iÕI"°      
      def function(arglist)
        move_progress
      end
      
      def function(arglist)
        @var = var
        @var = false
        if var then;Fi[	@ﬁiI"Ó      def function(arglist)
        @var = ensure_dir(var, "junit")
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = @var = @var = @var = 0
        @var = OrderedXmlMarkup.new(:indent => 2);Fi[	@ÊiqI"Ö        @var.flush
        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[	@Êi~I"¥      
      def function(arglist)
        print_feature_element_name(var, var, var, var)
      end
      
      def function(arglist)
        @var = var
        @var = 6
      end;Fi[	@Èi/I"ï      def function(arglist)
        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[	@˝iI"‹      
      class StepDefKey < StepDefinitionLight
        attr_accessor(:mean_duration, :status)
      end
      
      def function(arglist)
        @var = var
        @var = ensure_io(var, "usage")
        @var = var;Fi[	@˝iI"œ        @var = ensure_io(var, "usage")
        @var = var
        @var = Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var = var
        @var = Time.now
      end;Fi[	@i'I"Ë      Gherkin::I18n.code_keywords.each do |arglist|
        RbDsl.alias_adverb(var)
        RbWorld.alias_adverb(var)
      end
      
      def function(arglist)
        @var = var
        @var = []
        RbDsl.rb_language = self;Fi[	@qiI"Œ      module ClassMethods
        def function(arglist)
          defined? @var ? (@var) : (Devise.scoped_views)
        end
        
        def function(arglist)
          @var = var
        end
      end;Fi[	@tiI"ñ      (var << var)
    end
    var
  end
  
  def function(arglist)
    @var = var
    @var = var.html_safe
    if var = var.delete(:attachments) then;Fi[	@ti#I"x      var.text
      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var;Fi[	@Äi^I"≤  class Generator < Federated::Generator
    def self.federated_class(arglist)
      Comment
    end
    
    def function(arglist)
      @var = var
      super(var, var)
    end;Fi[	@‡#i@I"à  
  def function(arglist)
    target_guid
  end
  
  def function(arglist)
    @var = var
    @var = var.class.to_s
    @var = var.guid;Fi[	@Ui,I"Ç    else
      "No available formula for #{name} #{dependent_s}"
    end
  end
  
  def function(arglist)
    @var = var
  end
end;Fi[	@iØI"ƒ          rescue Nokogiri::SyntaxError, RuntimeError
            nil
          end
        end
        
        def function(arglist)
          @var = var
          @var = nil
          @var = nil;Fi[	@´(iI"}    
    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@∑(iI"•    #:nodoc:
    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@«iI"      class HaveAttachedFileMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = @var.class unless Class.===(@var)
          responds? and (has_column? and included?);Fi[	@Ãi$I"        def function(arglist)
          @var = var.flatten
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class)
          @var and (@var and (allowed_types_allowed? and rejected_types_rejected?));Fi[	@’iI"      class ValidateAttachmentPresenceMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          @var = var.new if (var.class == Class)
          error_when_not_valid? and no_error_when_valid?;Fi[	@⁄iI"ø      class ValidateAttachmentSizeMatcher
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@⁄iI"§        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end;Fi[	@⁄i(I"0        def function(arglist)
          @var, @var = var.first, var.last
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class)
          lower_than_low? and (higher_than_low? and (lower_than_high? and higher_than_high?));Fi[	@1 i1I"v    
    def self.[](arglist)
      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    ;Fi[	@Ui{I"î  
  def function(arglist)
    return [@var, @var, @var]
  end
  
  def function(arglist)
    @var = var
    @var = var
    var = var if (var == -1);Fi[	@UiÇI"û    @var = var
    var = var if (var == -1)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var)
  end;Fi[	@UiáI"ç  def function(arglist)
    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@UiãI"g  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@UièI"Ä  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var);Fi[	@Ui¶I"í    else
      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Ui™I"g  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@UiÆI"g  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Ui≤I"g  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Ui∂I"g  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Ui∫I"g  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@UiæI"g  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  ;Fi[	@Ui4I"Ÿ    var = 0
    var.each_byte { |arglist| var = (var + GetCharWidth(var, var)) }
    ((var * @var) / 1000.0)
  end
  
  def function(arglist)
    @var = var
    out(sprintf("%.2f w", (var * @var))) if (@var > 0)
  end;Fi[	@ôisI"'        
        def function(arglist)
          MultiCell(var, var, fix_text_encoding(var), var, var, var, var)
        end
        
        def function(arglist)
          @var = var
          writeHTMLCell(var, var, var, var, fix_text_encoding(formatted_text(var)), var, var, var)
        end;Fi[	@fiuI"Ú      # Run all the after(:each) blocks for this example
      def function(arglist)
        example_group_hierarchy.run_after_each(self)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = caller;Fi[	@YiI"ê      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.!.!
      end;Fi[	@YiHI"∑      def function(arglist)
        @var, @var = var, var
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.__send__(@var, @var)
      end;Fi[	@YifI"⁄        @var = parse_expected(var.shift)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var = var
        begin
          return @var = var.__send__(predicate, *@var, &@var);Fi[	@YiöI"´      def function(arglist)
        @var = var.shift
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var.equal?(@var)
      end;Fi[	@üiAI"‰      
      def function(arglist)
        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@üiFI"í      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@üiKI"í      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@üiPI"í      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@üiUI"í      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@l iI"ﬂ      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
        @var = difference_between_arrays(@var, @var)
        @var = difference_between_arrays(@var, @var);Fi[	@oiI"Á        @var = var
        @var = nil
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.each do |arglist|
          (@var << var) unless var.respond_to?(var) and matches_arity?(var, var);Fi[	@oi I"ß      
      def function(arglist)
        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end;Fi[	@riI"´        @var = var
        @var = var
        @var = @var = nil
      end
      
      def function(arglist)
        @var = var
        case @var.arity
        when 2 then;Fi[	@€iUI"£      # instance and not the class.
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      ;Fi[	@ÈiI"%      def self.allow_message_expectations_on_nil(arglist)
        @@warn_about_expectations_on_nil = false
        $rspec_mocks.add(nil) unless $rspec_mocks.nil?
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = ErrorGenerator.new(var, var, var);Fi[	@*iI"ï            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        ;Fi[	@qiÜI"Ë      
      def function(arglist)
        Spec::Runner.configuration.mock_framework
      end
      
      def function(arglist)
        @var = var
        if @var and Config::CONFIG["host_os"] =~ /mswin|mingw/ then
          begin;Fi[	@tiI"≈        @var = 0
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var = var
        formatters.each { |arglist| var.example_group_started(var) }
      end;Fi[	@—iI"í    
    def @@var.puts(arglist)
      # do nothing
    end
    
    def function(arglist)
      @var = var
      @var = ERB.new(TEMPLATE)
    end;Fi[	@uiI"»        var = var[:status].to_i
        var = @var.errors[var]
        raise(var.from_response(var)) if var
      end
      
      def function(arglist)
        @var = var
        super(var)
      end;Fi[	@ÍiI"æ  class CommandLine
    def self.execute(arglist)
      new(var).run
    end
    
    def function(arglist)
      @var = var
      @var[:file] ||= "config/schedule.rb"
      @var[:cut] ||= 0;Fi[	@àiI"é    
    def function(arglist)
      @var[var.to_s] = var
    end
    
    def function(arglist)
      @var = var
      @var = var
      yield;Fi[I"# do nothing;FI"end;FI" ;FI"def function(arglist);FiE[E[	@KifI"˚        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          serializable_collection.each do |arglist|
            var = ActiveSupport::XmlMini.rename_key(var.name, options);Fi[	@}iÃI"=      #
      # This is only relevant to certain associations, which is why it returns nil by default.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        reflection.build_association(var) do |arglist|
          var = [reflection.foreign_key, reflection.type].compact;Fi[	@àiI"¬      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super
        var and [var.to_s, owner[reflection.foreign_type].to_s];Fi[	@0iI"O      
      # Begins the transaction (and turns off auto-committing).
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        { :read_uncommitted => "READ UNCOMMITTED", :read_committed => "READ COMMITTED", :repeatable_read => "REPEATABLE READ", :serializable => "SERIALIZABLE" }
      end;Fi[	@0iI"      # Rolls back the transaction (and turns on auto-committing). Must be
      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@Fi˝I"ç      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@FiI"ç      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@FiI"Ñ      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end;Fi[	@ViÈI"∂      module Fields
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end;Fi[	@riI"≥      module OID
        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end;Fi[	@ïiI"    # See also http://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
    # :nodoc:
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = self.class.primary_key
      @var[var] = nil unless @var.key?(var);Fi[	@?)i	I"module ActiveRecord
  class ExplainSubscriber
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      if var = Thread.current[:available_queries_for_explain] then
        (var << var.values_at(:sql, :binds)) unless ignore_payload?(var);Fi[	@B)i<I"y    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@ÀisI"º    
    # A hook to be overridden by association modules.
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      relation_for_destroy.delete_all
    end;Fi[	@ﬂiÂI"ç      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@LiHI"·    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      unless @var then
        raise("LazySpecification has not been materialized yet (calling :#{method} #{args.inspect})");Fi[	@,i3I"ô  
  class SystemRubyVersion < RubyVersion
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      RUBY_VERSION
    end;Fi[	@gi	I"àmodule Bundler
  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@giI"{    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@giI"{    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@giI"{    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@giI"{    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@giI"y    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end;Fi[	@Õi/I"{        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if var[:create] and manifest.welcome_message_options[:replace].! then
            puts("\n*********************************************************************\nCongratulations! Your compass project has been created.\n\nYou may now add and edit sass stylesheets in the #{Compass.configuration.sass_dir} subdirectory of your project.\n\nSass files beginning with an underscore are called partials and won't be\ncompiled to CSS, but they can be imported into other sass stylesheets.\n\nYou can configure your project by editing the config.rb configuration file.\n\nYou must compile your sass stylesheets into CSS when they change.\nThis can be done in one of the following ways:\n  1. To compile on demand:\n     compass compile [path/to/project]\n  2. To monitor your project for changes and automatically recompile:\n     compass watch [path/to/project]\n\nMore Resources:\n  * Website: http://compass-style.org/\n  * Sass: http://sass-lang.com\n  * Community: http://groups.google.com/group/compass-users/\n\n");Fi[	@a)iI"}    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      opts.to_s
    end;Fi[	@i	I"Ó  module Installers
    class BareInstaller < Base
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir));Fi[	@iI"æ      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var ||= targetize("config.rb")
        write_file(var, config_contents);Fi[	@i6I"‡      # The default finalize method -- it is a no-op.
      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end;Fi[	@íiSI"Ñ  
  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@íiWI"y    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end;Fi[	@’i#I"~    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      self.class.name
    end;Fi[	@fiI"ç      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@fi#I"£      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false
        var = var.send(:import);Fi[	@çiDI"Ê      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
        @var.next_feature_element(self) { |arglist| var.skip_invoke! };Fi[	@ﬁiHI"Ø      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var)
        var = (Time.now - @var);Fi[	@Ôi
I"ü  module Formatter
    class Stepdefs < Usage
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0
      end;Fi[	@iwI"î      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = var.language
      end;Fi[	@iI"º      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.map do |arglist|
          if var = var.arguments_from(var) then;Fi[	@i>I"ç      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@iI"∞      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        "python snippet: #{code_keyword}, #{step_name}"
      end;Fi[	@i%I"ú      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.step_matches(var, var)
      end;Fi[	@=iI"„        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end;Fi[	@ViI"π      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Configuration.new(var)
        (@var << Connection.new(var));Fi[	@¶i&I"Œ      
      # Hook called after token authentication.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        self.class.expire_auth_token_on_timeout
      end;Fi[	@¥i	I"ˆ  module OmniAuth
    module UrlHelpers
      def self.define_helpers(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = Devise::Mapping.find_scope!(var)
        send("#{scope}_omniauth_authorize_path", *var);Fi[	@ÿ#i;I"d  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end;Fi[	@<i}I"´    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      var = @var.value
      rstrip_buffer! if var[:nuke_outer_whitespace];Fi[	@ú)iI"Ímodule Haml
  class SafeErubisTemplate < Tilt::ErubisTemplate
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      @var.merge!(:engine_class => (ActionView::Template::Handlers::Erubis))
      super;Fi[	@ªiI"°      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        last_request.env["rack.session"]
      end;Fi[	@π)iI"ömodule Paperclip
  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end;Fi[	@π)iI"x    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end;Fi[	@Âi	I"“  module Storage
    module Filesystem
      def self.extended(arglist)
        # do nothing
      end
      
      def function(arglist)
        original_filename ? (File.exist?(path(var))) : (false)
      end;Fi[	@UiI"á  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end;Fi[	@xi!I"õ  
  # XXX TODO XXX
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    QTAGS.each do |arglist|
      var.gsub!(var) do |arglist|;Fi[	@imI"œ      
      # Override and place code to add defs here
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var = Document.new
        (@var << XMLDecl.new);Fi[	@i`I"õ      
      # We don't need the graph
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        [""]
      end;Fi[	@BiI"≠      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        flexmock_verify
      end;Fi[	@–iI"£      
      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end;Fi[	@–i/I"À      
      class BooleanMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          (TrueClass.===(var) or FalseClass.===(var))
        end;Fi[	@iI"É      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end;Fi[	@/iI"ü        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@4iI"ü        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@9iI"æ        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          if dry_run? then
            var = "This was a dry-run";Fi[	@—iI"í    end
    
    def @@var.puts(arglist)
      # do nothing
    end
    
    def function(arglist)
      @var = var
      @var = ERB.new(TEMPLATE);Fi[I"	else;FI"# do nothing;FI"end;FI"end;FiA[A[	@†i6I"Õ            target.destroy
          when :nullify then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      ;Fi[	@ΩiQI"¿            end
            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      
      protected;Fi[	@˜iàI"ó          HasAndBelongsToMany
        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end;Fi[	@>ikI"À            end
          when String then
            var.each { |arglist| var[var] += " #{order.upcase}" }
          else
            # do nothing
          end
        end
        return var
      end;Fi[	@IiQI"∆            end
          when Fixnum then
            var.each { |arglist| var[var] += "(#{length})" }
          else
            # do nothing
          end
        end
        return var
      end;Fi[	@Li$I"“            resolve_string_connection(config.to_s)
          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private;Fi[	@kiOI"˙                var.gsub!(/[^-\d.]/, "")
              when /^-?\D+[\d.]+,\d{2}$/ then
                var.gsub!(/[^-\d,]/, "").sub!(/,/, ".")
              else
                # do nothing
              end
            end
          end
        end;Fi[	@ûiΩI"                  { var.foreign_key => (var[primary_key_name]), var.association_foreign_key => (ActiveRecord::FixtureSet.identify(var)) }
                end)
              end
            else
              # do nothing
            end
          end
        end
        var;Fi[	@¬iÔI"Ω        (method(var).arity == 0) ? (send(var)) : (send(var, var))
      when Proc then
        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist);Fi[	@ﬂiBI"•          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@ŸiﬂI"õ        (var.to_sql == to_sql)
      when Array then
        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist);Ti[	@'i I"¶        destroyed?
      when :update then
        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	@5i I"∑            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@oi°I"¿    case var
    when Net::HTTP::Delete, Net::HTTP::Get, Net::HTTP::Head, Net::HTTP::Options, Net::HTTP::Put, Net::HTTP::Trace then
      true
    else
      # do nothing
    end
  end
  
  ##;Fi[	@åiI"æ      when Hash then
        [:force, :skip, "force", "skip"].each { |arglist| var.delete(var) }
        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	@ôiKI"~        "key:value"
      when :array then
        "one two three"
      else
        # do nothing
      end
    end
  end
end;Fi[	@i*I"œ              (var << var)
            when :err then
              warn("[err :: #{ch[:server]}] #{data}")
            else
              # do nothing
            end
          end
          var
        end;Fi[	@
iI"í            false
          when "a" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end;Fi[	@`iSI"‘            "#{(variable(:scm_password) or variable(:password))}\n"
          when /\(yes\/no\)/ then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private;Fi[	@liçI"±            "#{pass}\n"
          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private;Fi[	@qiII"•            "#{pass}\n"
          when /yes\/no/i then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private;Fi[	@{iKI"            raise(Capistrano::Error, "p4port is incorrect or unset")
          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private;Fi[	@ÇiVI"            raise(Capistrano::Error, "subversion can't update because directory '#{$1}' was replaced. Please add it to svn:ignore.")
          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private;Fi[	@ñi€I"            source.checkout(revision, destination)
          when :export then
            source.export(revision, destination)
          else
            # do nothing
          end
        end
        
        # Returns the name of the file that the source code will be;Fi[	@¬iøI"z        var.abort!
      when :scp then
        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	@«i%I"º        case var
        when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@Œi>I"≤          when :stdout then
            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end;Fi[	@i_I"ú      self.identifier
    when "facebook" then
      I18n.t("invitations.a_facebook_user")
    else
      # do nothing
    end
  end
  
  # @return [String];Fi[	@ikI"}      self.identifier
    when "facebook" then
      false
    else
      # do nothing
    end
  end
  
  # @note before_save;Fi[	@‰i…I"ô          var["class"] += var
        when "#" then
          var["id"] = var
        else
          # do nothing
        end
      end
      var
    end;Fi[	I"%data//homebrew_proj/blacklist.rb;TiI"Ÿ    "lzma is now part of the xz formula."
  when "xcode" then
    "    Xcode can be installed via the App Store (on Lion or newer), or from:\n      http://connect.apple.com/\n".undent
  else
    # do nothing
  end
end;Fi[	@dioI"≈        problem("Use ENV.fortran during install instead of depends_on 'gfortran'")
      when "open-mpi", "mpich2" then
        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  ;Fi[	@diÕI"¬        end
      when /macports\/trunk/ then
        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  ;Fi[	@ti+I"é      case File.basename(var)
      when "LinkedKegs", "Aliases" then
        true
      else
        # do nothing
      end
    end
  end
end;Fi[	@i"I"$    case Hardware.cpu_type
    when :ppc, :dunno then
      abort("        Sorry, Homebrew does not support your computer's CPU architecture.\n        For PPC support, see: https://github.com/mistydemeo/tigerbrew\n".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist);Fi[	@8i;I"°      MacOS.llvm_build_version.to_i
    when :gcc then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist);Fi[	@îiI"ì    when Hash then
      @var = @var.keys.first
      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist);Fi[	@îi~I"ó      raise("Empty archive")
    when 1 then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist);Fi[	@£iºI"q        :zip
      when ".7z" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  ;Fi[	@™iYI"ï    when :bzip2 then
      @var = (@var + ".bz2")
      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist);Fi[	@Øi(I"Ù      ["/usr/bin/env", "ruby", "-rubygems", "-e", "require '#{@import_name}'"]
    when :rbx then
      ["/usr/bin/env", "rbx", "-rubygems", "-e", "require '#{@import_name}'"]
    else
      # do nothing
    end
  end
  
  def function(arglist);Fi[	@ØiAI"è      "rbx gem install"
    when :ruby then
      "gem install"
    else
      # do nothing
    end
  end
end
class X11Dependency < Requirement;Fi[	@‚isI"Ä        var
      when "maruku" then
        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	@m%i*I"©          var = var[var].split
        when Array then
          var = var[var].compact
        else
          # do nothing
        end
      end
    end
    (var or []);Fi[	@1 iáI"∏      yield(Result[:failed], var, nil)
    when OpenID::Consumer::SETUP_NEEDED then
      yield(Result[:setup_needed], var.setup_url, nil)
    else
      # do nothing
    end
  end
end;Fi[	@ci¶I"s        var = (var + var)
      end
      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #;Fi[	@ci∂I"ã      @var[@var] = @var if (@var[@var] < @var)
      @var = (@var + 1)
      @var.push([])
    else
      # do nothing
    end
  end
  
  #;Fi[	@ciI"Ì          @var = "R"
        when "left" then
          @var = "L"
        else
          # do nothing
        end
      end
      if var["bgcolor"].nil?.! and var["bgcolor"].!=("") then
        var = convertColorHexToDec(var["bgcolor"]);Fi[	@ciëI"Ü      SetFontSize((@var + var))
      SetStyle("b", true)
      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #;Fi[	@ci>I"{        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #;Fi[	@™i‹I"—        case var[:format]
        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@™iÔI"µ        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@™iI"¬        when :pdf then
          pdf_new_page?(var)
          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@≥i/I"F              var["week"] = "#{row["tyear"]}-#{row["tweek"]}"
            when "day" then
              var["day"] = "#{row["spent_on"]}"
            else
              # do nothing
            end
          end
          var = @var.collect { |arglist| var["spent_on"] }.min
          @var = var ? (var.to_date) : (Date.today);Fi[	@≥iHI"Ã            when "day" then
              (@var << "#{date_from.to_date}")
              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end;Fi[	@EiAI"’          Resque.redis.zcard(var)
        when "hash" then
          Resque.redis.hlen(var)
        else
          # do nothing
        end
      end
      def function(arglist)
        case Resque.redis.type(var);Fi[	@EiSI"          Resque.redis.zrange(var, var, (var + 20))
        when "hash" then
          Resque.redis.hgetall(var)
        else
          # do nothing
        end
      end
      def function(arglist)
        Array(var).map { |arglist| var.inspect }.join("\n");Fi[	@€i5I"ç          1
        when :twice then
          2
        else
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@ˇi)I"ñ            else
              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end;Fi[	@DiØI"            (var << var)
          when Twitter::User then
            (var << var.id)
          else
            # do nothing
          end
        end
        var[:user_id] = var.join(",") unless var.empty?
        var[:screen_name] = var.join(",") unless var.empty?;Fi[@'@(I"var;FI"end;FiA[A[	@Ci5I"¨          var.to_ary.map { |arglist| var.serializable_hash(var) }
        else
          var.serializable_hash(var)
        end
      end
      var
    end
    
    private;Fi[	@}iõI")          var[reflection.foreign_key] = owner[reflection.active_record_primary_key]
          if reflection.options[:as] then
            var[reflection.type] = owner.class.base_class.name
          end
        end
        var
      end
      
      # Sets the owner attributes on the given record;Fi[	@ÇiUI"ﬂ            var = eval_scope(var.klass, var)
            var.includes!(var.includes_values)
            var.where_values += var.where_values
          end
        end
        var
      end
      
      def function(arglist);Fi[	@ùifI"‘            if (var.macro == :has_one) then
              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      
      def function(arglist);Fi[	@Ωi¥I"È            set_target_and_inverse(var, var, var)
          else
            raise(ConfigurationError, "unknown macro: #{join_part.reflection.macro}")
          end
        end
        var
      end
      
      def function(arglist);Fi[	@¿iI"Ü          (var << alias_tracker.aliased_table_for(table_name_for(var), table_alias_for(var, var.!=(self.reflection))))
          if (var.source_macro == :has_and_belongs_to_many) then
            (var << alias_tracker.aliased_table_for((var.source_reflection or var).join_table, table_alias_for(var, true)))
          end
        end
        var
      end
      
      def function(arglist);Fi[	@IiõI"            end
            (var.last.columns << var[:Column_name])
            (var.last.lengths << var[:Sub_part])
          end
        end
        var
      end
      
      # Returns an array of +Column+ objects for the table specified by +table_name+.;Fi[	@ûi¿I"}            else
              # do nothing
            end
          end
        end
        var
      end
      var
    end;Fi[	@ΩiÕI"          end
          if create_time_zone_conversion_attribute?(var, var) then
            var[var] = AttributeMethods::TimeZoneConversion::Type.new(var)
          end
        end
        var
      end
      
      # Returns a hash where the keys are column names and the values are;Fi[	@Îi I"±            Hash.===(var) ? (var.joins!(var)) : (var.joins!(*var))
          else
            var.send("#{k}!", var)
          end
        end
        var
      end
    end
    ;Fi[	@iI"ª            var = Arel::Table.new(var, var.engine)
          end
          var.concat(expand(var, var, var, var))
        end
      end
      var
    end
    
    def self.expand(arglist);Fi[	@¯iOI"             end
          else
            var[var] = var
          end
        end
        var
      end
      
      # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.;Fi[	@•iJI"E            Logger.message("Session data loaded from cache!"))
          rescue => var
            Logger.warn(Errors::Storage::Dropbox::CacheError.wrap(var, "              Could not read session data from cache.\n              Cache data might be corrupt.\n"))
          end
        end
        var
      end
      
      ##;Fi[	@ i_I"¡        if var.respond_to?(:unlock!) and @var[:sources].include?(var.name) then
          var.unlock!
          var = true
        end
      end
      var
    end
    
    def function(arglist);Fi[	@ iëI"        next unless var.respond_to?(:unlock!)
        unless var.any? { |arglist| (var.source == var) } then
          var.unlock! if var.empty?.! and var.any? { |arglist| (var.source == var) }
        end
      end
      var
    end
    
    def function(arglist);Fi[	@ i¨I"¡          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    
    def function(arglist);Fi[	@?i4I"         var.search(var, var).each do |arglist|
          (var << var) unless var.include?([var.name, var.version, var.platform])
          (var << [var.name, var.version, var.platform])
        end
      end
      var
    end
    
    def function(arglist);Fi[	@%imI"Ω            else
              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end;Fi[	@XiáI"˝            raise(PathError, "The path `#{expanded_path}` is not a directory.")
          else
            raise(PathError, "The path `#{expanded_path}` does not exist.")
          end
        end
        var
      end
      
      def function(arglist);Fi[	@úiÑI"!        if @var.is_a?(Hash) and var = @var[var] then
          if var.enum and var.enum.include?(var).! then
            raise(MalformattedArgumentError, "Expected '#{name}' to be one of #{switch.enum.join(", ")}; got #{value}")
          end
        end
        var
      end
    end
    ;Fi[	I":data//bundler_proj/bundler/vendor/thor/rake_compat.rb;Ti$I"¸      Rake.application.last_description = nil
      var.send(:define_method, var) do |arglist|
        Rake::Task[var.name.to_sym].invoke(*var)
      end
    end
    var
  end
  def function(arglist)
    if var = Thor::RakeCompat.rake_classes.last then;Fi[	@“iSI"¬      if @var.kind_of?(Hash) then
        @var.each do |arglist|
          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private;Fi[	@ËirI"µ            (var << "\n")
          else
            (var << var.map { |arglist| "#{indentation}#{l}\n" }.join)
          end
        end
        var
      end
      
      #:nodoc:;Fi[	@i,I"´              warn("[err :: #{ch[:server]}] #{data}")
            else
              # do nothing
            end
          end
          var
        end
      end
    end;Fi[	@i}I"            var = var.map do |arglist|
              (var == "deploy:symlink") ? ("deploy:create_symlink") : (var)
            end
          end
        end
        var
      end
      
      # Trigger the named event for the named task. All associated callbacks;Fi[	@
i?I"º            (var << var)
          else
            (var << serialize_property(var, var)) unless var.nil?
          end
        end
        var
      end
      
      def function(arglist);Fi[	@{iÄI"n            end
            (var << "\n")
          end
        end
      end
      var
    end
  end
end;Fi[	@$i)I"©          (var << stop.times(Sass::Script::Number.new(100, ["%"])).inspect)
        else
          (var << stop.inspect)
        end
      end
      var
    end
  end
  ;Fi[	@$i€I"è          Sass::Script::Number.new(50, ["%"])
        else
          var
        end
      end
      var
    end
    
    def function(arglist);Fi[	@$iGI"          if (var.value.last == var.value.last) and (var.value.first.value == 0) then
            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    
    # returns the end position of the gradient from the color stop;Fi[	@≤iXI"í        if ENCODING_PATTERN.=~(var) then
          var = $1
          break
        end
      end
      var
    end
    
    def function(arglist);Fi[	@’iI"†          unless var.closed? then
            var.flush
            var.close
          end
        end
        var
      end
      
      def function(arglist);Fi[	@Éi∑I"€              var = var[var]
              var.send("#{key}=", var)
              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected;Fi[	@òiqI"0              var.reset_password!(var[:password], var[:password_confirmation])
            else
              var.errors.add(:reset_password_token, :expired)
            end
          end
          var
        end
        
        Devise::Models.config(self, :reset_password_keys, :reset_password_within);Fi[	@±iZI"u        else
          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  
  def function(arglist);Fi[	@‰iÀI"Ñ          var["id"] = var
        else
          # do nothing
        end
      end
      var
    end
    
    def function(arglist);Fi[	@Ù#iI"†      unless var.empty? then
        yield(var.name, var) if block_given?
        var[var.name] = var
      end
    end
    var
  end
  
  def function(arglist);Fi[	@ai_I"§        end
        var = Pathname.pwd.join(var).relative_path_from(HOMEBREW_REPOSITORY)
        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private;Fi[	@∂iKI"ï        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@§iëI"ì          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    
    private;Fi[	@L	i0I"˝            (var[var] ||= {}).merge!(var)
          else
            (var["$set"] ||= {}).merge!(var => (mongoize_for(var, var, var)))
          end
        end
        var
      end
      
      # Check if the hash is part of a blank relation criteria.;Fi[	@£	i-I"µ              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end
    
    # Marks all children as being persisted.;Fi[	@Ò
iI"“                var.push(Factory.from_db(klass, var))
              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end;Fi[	@|ieI"          var.class.relations.values.each do |arglist|
            if (var.as == name) and (var.class_name == inverse_class_name) then
              var.push(var.name)
            end
          end
          var
        end
      end
      ;Fi[	@
iÛI"£            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      
      def function(arglist);Fi[	@
iI"’            var = Node.new(:AN_PLUS_B, var)
          else
            raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
          end
        end
        var
      end
      
      def function(arglist);Fi[	@i<I"√        if jruby? then
          var["xerces"] = Nokogiri::XERCES_VERSION
          var["nekohtml"] = Nokogiri::NEKO_VERSION
        end
      end
      var
    end
    
    def function(arglist);Fi[	@Ki=I"ú            end
          else
            var.content = var
          end
        end
        var
      end
      
      # Create a Text Node with +string+;Fi[	@xi&I"û            end
            var = (var - 1) unless var.zero?
            var = {} if var.zero?
          end
        end
        var
      end
    end
    var;Fi[	@xi)I"e          end
        end
        var
      end
    end
    var
  end
  
  def function(arglist);Fi[	@Äi I"ë            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8(arglist);Fi[	@ÄiHI"ú            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    
    def self.to_utf8_by_setting(arglist);Fi[	@ôi2I"à                end
              end
            end
          end
        end
        var
      end
      
      def function(arglist);Fi[	@™i¢I"„        if relations[var.id] then
          relations[var.id].each do |arglist|
            ((var[var.relation_type] ||= []) << var.issue_to_id)
          end
        end
        var
      end
      
      def function(arglist);Fi[	@‘%iI"ÿ        unless system(var) then
          logger.error("Creating thumbnail failed (#{$?}):\nCommand: #{cmd}")
          return nil
        end
      end
      var
    end
    
    def self.convert_available?(arglist);Fi[	@l i4I"†        var.each do |arglist|
          if var = var.index(var) then
            var.delete_at(var)
          end
        end
        var
      end
    end
    ;Fi[	@ i%I"á            else
              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end;Fi[	@qiÔI"Ø            else
              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      
      def function(arglist);Fi[	@ñ$i)I"°        end
      else
        var["properties"][var] = properties[var].to_hash rescue properties[var]
      end
    end
    var
  end
  
  def function(arglist);Fi[	@Ô%i,I"          if var.dynamic_initial_state? then
            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    
    # Runs one or more events in parallel on the given object.  See;Fi[@'@¸I"attr_reader :function;FI" ;Fi@[@[	@3i,I"o    #   person.changes # => { "name" => ["bill", "bob"] }
    def function(arglist)
      ActiveSupport::HashWithIndifferentAccess[changed.map { |arglist| [var, attribute_change(var)] }]
    end
    
    attr_reader :function
    
    # Returns a hash of the attributes with unsaved changes indicating their original
    # values like <tt>attr => original value</tt>.;Fi[	@}i)I"Á        reset_scope
        load_target
        self unless target.nil?
      end
      
      attr_reader :function
      
      # Asserts the \target has been loaded setting the \loaded flag to +true+.
      def function(arglist);Fi[	@ÖiI"á      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function
      
      private
      ;Fi[	@
iI"«      #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      
      private
      ;Fi[	@0i‡I"é            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?;Fi[	@Ci5I"æ        @var = []
        @var = false
        @var = var.fetch(:joinable, true)
      end
      
      attr_reader :function
      
      def function(arglist)
        @var and finishing?.!;Fi[	@FiÊI"Ô      # is no longer active, then this method will reconnect to the database.
      def function(arglist)
        reconnect! unless active?
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.number;Fi[	@ïiÈI"ﬁ    # Allows sort on objects
    def function(arglist)
      (self.to_key <=> var.to_key) if var.is_a?(self.class)
    end
    
    attr_reader :function
    
    # Marks this record as read only.
    def function(arglist);Fi[	@ÀiGI"}      def function(arglist)
        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    ;Fi[	@ﬂiI"             raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      
      # Returns whether or not the association should be validated as part of
      # the parent's validation.;Fi[	@“i∫I"›            @var = var.slice((4..-36))
            @var = var.slice((-32..-1))
            @var = @var.sub((@var + "/"), "")
          end
          
          attr_reader :function
          
          private
          ;Fi[	@ inI"à    
    def function(arglist)
      (@var - specs)
    end
    
    attr_reader :function
    
    def function(arglist)
      var = [];Fi[	@6iI"√      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    
    # needed for standalone, load required_paths from local gemspec
    # after the gem in installed;Fi[	@Ji™I"∏      
      def function(arglist)
        cached_revision and super
      end
      
      attr_reader :function
      
      def function(arglist)
        allow_git_ops? and local?.!;Fi[	@giAI"¢      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.!.! and @var.!;Fi[	@úi.I"o      end
      check_requirement!
      @var
    end
    
    attr_reader :function
    
    private
    ;Fi[	@üi5I"‹        @var[var.switch_name] = var
        var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist)
      return super unless @var;Fi[	@§iI"≤        ensure
          @var = false
        end
      end
      
      attr_reader :function
      
      # Sets the output padding, not allowing less than zero values.
      #;Fi[	@˜i#I"Ø        
        def function(arglist)
          options[:last]
        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true;Fi[	@GiI"Ñ      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      
      private
      ;Fi[	@JiWI"¢      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      
      def function(arglist)
        var = @var.dup;Fi[	@Vi;I"          else
            LocalProxy.new(self)
          end
        end
        
        attr_reader :function
        
        # Returns the string used to identify the latest revision in the
        # repository. This will be passed as the "revision" parameter of;Fi[	@)iI"Ï      #attr_accessor :project_types
      def function(arglist)
        @var ||= DEAFULT_PROJECT_TYPES.dup
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.keys.===(DEAFULT_PROJECT_TYPES.keys);Fi[	@idI"»      # Enumerates over the manifest files
      def function(arglist)
        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      ;Fi[	@iiII"¿      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
      end
      
      attr_reader :function
      
      def function(arglist)
        (@var.first or self);Fi[	@ñiÅI"≥      
      def function(arglist)
        cells_rows[0][var]
      end
      
      attr_reader :function
      
      def function(arglist)
        columns[var].__send__(:width);Fi[	@¨iÍI"è            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then;Fi[	@i<I"Œ    class JsHook
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.current_world.execute(@var);Fi[	@iXI"£    class JsArg
      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing;Fi[	@iñI"”      
      def function(arglist)
        add_transform(JsTransform.new(self, var, var))
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.invoke_steps(var, @var, var);Fi[	@=i@I"‹    #   as opposed to a nested partial
    def function(arglist)
      upper.nil?
    end
    
    attr_reader :function
    
    # @return [Fixnum] The current indentation level of the document
    def function(arglist);Fi[	I"%data//homebrew_proj/checksums.rb;TiI"û  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == var.hash_type) and (@var == var.hexdigest);Fi[	@îi1I"±    else
      @var = (HOMEBREW_CACHE + File.basename(@var))
    end
  end
  
  attr_reader :function
  
  # Private method, can be overridden if needed.
  def function(arglist);Fi[	@îiæI"    @var = "#{name}--svn" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (@var + "-HEAD") if ARGV.include?("--HEAD")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.sub!(/^svn\+/, "") if @var =~ /^svn\+http:\/\//;Fi[	@îiI"Ô    @@git ||= "git"
    @var = "#{name}--git" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.!=(:revision) and host_supports_depth?;Fi[	@îieI"÷    super
    @var = "#{name}--cvs" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    ohai("Checking out #{@url}");Fi[	@îiêI")    super
    @var = "#{name}--hg" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|;Fi[	@îi∫I"    super
    @var = "#{name}--bzr" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|;Fi[	@îi⁄I"    super
    @var = "#{name}--fossil" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|;Fi[	@ÄiuI"j    else
      true
    end
  end
  
  attr_reader :function
  
  def function(arglist)
    case @var;Fi[	@ˆi3I"ã  def function(arglist)
    @var = var.to_s
    @var = var
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == "HEAD");Fi[	@ˆiUI"ﬂ    var.fill(VersionElement.new(0), var.length, (var - var.length))
    var.fill(VersionElement.new(0), var.length, (var - var.length))
    (var <=> var)
  end
  
  attr_reader :function
  
  alias_method(:to_str, :to_s)
  ;Fi[	@hiâI"›        # @since 3.0.0
        def function(arglist)
          persistable? and (_assigning?.! and inserts_valid)
        end
        
        attr_reader :function
        
        # Set the inserts valid flag.
        #;Fi[	@(iùI"æ    def function(arglist)
      var = @var[:processors]
      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    ;Fi[	@ıi/I"%      @var = @var.split(/\s+/) if @var.respond_to?(:split)
      @var = File.extname(@var.path)
      @var = File.basename(@var.path, @var)
    end
    
    attr_reader :function
    
    # Returns true if the image is meant to make use of additional convert options.
    def function(arglist);Fi[	@1 i5I"¬    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    
    ERROR_MESSAGES.keys.each do |arglist|
      define_method("#{state}?") { |arglist| (@var == var) };Fi[	@UiI"±  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then;Fi[	@Ui‡I"    var = ((var + " ") + dounderline(var, var, var)) if @var and var.!=("")
    var = (((("q " + @var) + " ") + var) + " Q") if @var
    out(var)
  end
  
  attr_reader :function
  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then;Fi[	@UiÏI"„  def function(arglist)
    @var = @var
    var.kind_of?(String) ? (@var = (@var + @var)) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var));Fi[	@UiÚI"ú  
  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    @var = @var;Fi[	@æiI"!        def function(arglist)
          @var = with_trailling_slash(var)
          @var = var.blank? ? ("UTF-8") : (var)
        end
        
        attr_reader :function
        
        def function(arglist)
          var = var ? (with_leading_slash(var)) : (without_leading_slash(var));Fi[	@7ijI"†      @var.del(@var)
      @var.srem(:queues, @var)
      @var = true
    end
    
    attr_reader :function
    
    def function(arglist)
      @var.dump(var);Fi[	@õi0I"¯    def function(arglist)
      shutdown
      kill_child
    end
    
    attr_reader :function
    
    # Kills the forked child immediately with minimal remorse. The job it
    # is processing will not be completed. Send the child a TERM signal,;Fi[	@õiJI"¡      rescue SystemCallError
        Resque.logger.debug("Child #{@child} already quit and reaped.")
      end
    end
    
    attr_reader :function
    
    alias :paused? :should_pause?
    ;Fi[	@«iII"“      # See Spec::Matchers
      def function(arglist)
        cache_or_call_cached(:description, &var)
      end
      
      attr_reader :function
      
      # See Spec::Matchers
      def function(arglist);Fi[	@9iI"ù          @var = 0
          @var = 0
          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        ;Fi[	@qi|I"ƒ      
      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.after_suite_parts
      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false;Fi[	@„iõI"X    #   StateMachine::Transition.new(Vehicle.new, machine, :park, :idling, :parked).loopback?   # => false
    def function(arglist)
      (from_name == to_name)
    end
    
    attr_reader :function
    
    # A hash of all the core attributes defined for this transition with their
    # names as keys and values of the attributes as values.;Fi[	@'iGI"{      rescue NoMethodError
        nil
      end
    end
    
    attr_reader :function
    
    alias :to_hash :attrs
    ;Fi[@µ @°+I"# do nothing;FI"end;Fi@[@[	@KidI"ï        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@àiI"ø      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@0iI"ƒ      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # Set the sequence to the max value of the table's column.;Fi[	@Fi˚I"∑        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@FiˇI"ü      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@FiI"ü      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@B)i:I"Ç    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@ﬂi„I"à          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ﬂiÁI"„      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A chain of reflections from this one back to the owner. For more see the explanation in;Fi[	I".data//bundler_proj/bundler/environment.rb;Ti'I"è    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@LiFI"v    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@giI"ç    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@giI"ç    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@giI"ç    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@giI"ç    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@giI"ç    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	I"Edata//cancan_proj/generators/cancan/ability/templates/ability.rb;TiI"cclass Ability
  include(CanCan::Ability)
  
  def function(arglist)
    # do nothing
  end
end;Fi[	@Õi-I"∞            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@a)iI"µ    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@iI"Ã        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@íiUI"ç    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@’i!I"y      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@fiI"˘        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@fi!I"ü      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@äiI"¶        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	@çiBI"÷        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@ñiI"ú        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	@∏iáI"          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      
      #define @delayed_messages = [] in your Formatter if you want to;Fi[	@ﬁiFI"Û        @var = (var.nil? or (var == "")) ? ("Unnamed scenario") : (var.split("\n")[0])
        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@i[I"{      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    ;Fi[	@iuI"›      def function(arglist)
        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@i}I"¶      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@i<I"¨        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@i@I"ë      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      
      private;Fi[	@iI"†      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@i#I"‡        @var = import((File.dirname("(string)") + "/py_language.py"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@=iI"Ø        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@=iI"ﬂ        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      ;Fi[	@PiI"ü      def function(arglist)
        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      
      private;Fi[	@ViI"ú      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@Éi-I"¢      def function(arglist)
        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      
      var = ["serializable_hash"];Fi[	@çiPI"≈        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end
      
      # A reliable way to expose the salt regardless of the implementation.;Fi[	@òiPI"æ        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods;Fi[	@ÿ#i9I"~  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist);Fi[	I"*data//diaspora_proj/models/service.rb;Ti&I"´    var = "#{truncated}#{url}"
    return var
  end
  
  def function(arglist)
    # do nothing
  end
end
require(Rails.root.join("app", "models", "services", "facebook"));Fi[	@<i{I"{        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@ªiI"ê          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@π)iI"Ö    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist);Fi[	@MiI"É      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    
    def self.make(arglist);Fi[	@UiI"~  end
  
  alias_method(:add_page, :AddPage)
  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist);Fi[	@UiI"{  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  
  attr_reader :function;Fi[	@BiI"∂  module Adapters
    module MockFramework
      include(FlexMock::MockContainer)
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@iI"ß      def function(arglist)
        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist);Fi[	@/iI"°            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@/iI"ú        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[	@4iI"‹          @var.puts("#{example_group.description} #{example.description}")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@4iI"ú        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[	@9i}I"ò          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist);Fi[	@CiI"Ä        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end;Fi[I"	self;FI"end;FI" ;FI"def function(arglist);Fi?[?[	@ΩiI"4        var.each do |arglist|
          (join_associations.detect { |arglist| (var == var) } or build(var.reflection.name, (var.find_parent_in(self) or join_base), var.join_type))
        end
        self
      end
      
      def function(arglist)
        join_parts.last((join_parts.length - 1))
      end;Fi[	@ÛiI"é    
    def function(arglist)
      self.joins_values += var
      self
    end
    
    def function(arglist)
      spawn.bind!(var)
    end;Fi[	@?ijI"±        end
        (@var[var.name] << var)
      end
      self
    end
    
    def function(arglist)
      @var.inject(@var.size) { |arglist| var = (var + var.size) }
    end;Fi[	@diEI"v    end
    
    def function(arglist)
      self
    end
    
    def function(arglist)
      sorted.dup
    end;Fi[	@îiFI"È          while var = var.next do
            yield([var.key, var.value])
          end
          self
        end
        
        def function(arglist)
          var = self.class.new
          self.each { |arglist| var[var] = var };Fi[	@DiI"∏      
      def function(arglist)
        yield(self)
        self
      end
      
      def function(arglist)
        var = RemoteDependency.new(configuration)
        (@var << var);Fi[	@Di'I"∂      
      def function(arglist)
        @var.each { |arglist| yield(var) }
        self
      end
      
      def function(arglist)
        all? { |arglist| var.pass? }
      end;Fi[	@GiI"Á      def function(arglist)
        @var ||= "`#{command}' could not be found in the path on the local host"
        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@JiI"¯      def function(arglist)
        @var ||= "`#{path}' is not a directory"
        try("test -d #{path}", var)
        self
      end
      
      def function(arglist)
        @var ||= "`#{path}' is not a file"
        try("test -f #{path}", var);Fi[	@JiI"ı      def function(arglist)
        @var ||= "`#{path}' is not a file"
        try("test -f #{path}", var)
        self
      end
      
      def function(arglist)
        @var ||= "`#{path}' is not writable"
        try("test -w #{path}", var);Fi[	@Ji"I"
      def function(arglist)
        @var ||= "`#{path}' is not writable"
        try("test -w #{path}", var)
        self
      end
      
      def function(arglist)
        @var ||= "`#{command}' could not be found in the path"
        try("which #{command}", var);Fi[	@Ji(I"/      def function(arglist)
        @var ||= "`#{command}' could not be found in the path"
        try("which #{command}", var)
        self
      end
      
      def function(arglist)
        @var ||= "gem `#{name}' #{version} could not be found"
        var = configuration.fetch(:gem_command, "gem");Fi[	@Ji/I"—        @var ||= "gem `#{name}' #{version} could not be found"
        var = configuration.fetch(:gem_command, "gem")
        try("#{gem_cmd} specification --version '#{version}' #{name} 2>&1 | awk 'BEGIN { s = 0 } /^name:/ { s = 1; exit }; END { if(s == 0) exit 1 }'", var)
        self
      end
      
      def function(arglist)
        @var ||= "package `#{name}' #{version} could not be found"
        try("dpkg -s #{name} | grep '^Version: #{version}'", var);Fi[	@Ji5I"T      def function(arglist)
        @var ||= "package `#{name}' #{version} could not be found"
        try("dpkg -s #{name} | grep '^Version: #{version}'", var)
        self
      end
      
      def function(arglist)
        @var ||= "package `#{name}' #{version} could not be found"
        try("rpm -q #{name} | grep '#{version}'", var);Fi[	@Ji;I"+      def function(arglist)
        @var ||= "package `#{name}' #{version} could not be found"
        try("rpm -q #{name} | grep '#{version}'", var)
        self
      end
      
      def function(arglist)
        var = Regexp.new(Regexp.escape(var.to_s)) unless var.is_a?(Regexp)
        var = {};Fi[	@JiQI"‰          @var = "the output #{output.inspect} from #{command.inspect} did not match #{expect.inspect}"
          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@¬iAI"»        raise(var)
      end
      logger.debug("#{transport} #{operation} complete") if logger
      self
    end
    
    def function(arglist)
      transfers.any? { |arglist| var.active? }
    end;Fi[	@ipI"¥          else
            self.inherited_data = var
          end
          self
        end
        
        def function(arglist)
          self.inherited_data = nil
        end;Fi[	@oiI"≤      end
      
      def function(arglist)
        self
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_doc_string(self);Fi[	@ûiçI"Õ        else
          send_to_all(var, *var)
        end
        self
      end
      
      def function(arglist)
        @var.each { |arglist| var.__send__(var, *var) if var.respond_to?(var) }
      end;Fi[	@¨i∆I"¥        @var[:paths] = @var.dup
        merge_profiles
        print_profile_information
        self
      end
      
      def function(arglist)
        (@var - [@var])
      end;Fi[	@¨iI"          @var[:formats] += var[:formats]
          @var[:formats] = (stdout_formats[(0..0)] + non_stdout_formats)
        end
        self
      end
      
      def function(arglist)
        require("gherkin/i18n")
        @var.write(Gherkin::I18n.get(var).keyword_table);Fi[	@Æi?I"î        end
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.parent_author_signature, self.parent.author)
  end;Fi[	@‡#i_I"ó        return
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.target_author_signature, self.target.author)
  end;Fi[	@ªidI"˝    return if (var.size > 0)
    self.set_person(Person.new((var[:person] or {})))
    self.generate_keys
    self
  end
  
  def function(arglist)
    var.url = AppConfig.pod_uri.to_s
    var.diaspora_handle = "#{self.username}#{User.diaspora_id_host}";Fi[	I"-data//homebrew_proj/build_environment.rb;TiI"y  
  def function(arglist)
    (@var << var)
    self
  end
  
  def function(arglist)
    @var.include?(:std)
  end;Fi[	@fiZI"´      
      def function(arglist)
        @var = @var.&(RECOVER.~)
        self
      end
      
      def function(arglist)
        (@var.&(RECOVER) == STRICT)
      end;Fi[	@h$iI"ﬂ    
    def function(arglist)
      (@var << "\n<label for='#{target}'>#{text}:</label>")
      self
    end
    
    def function(arglist)
      (@var << "\n<input type='#{type}' id='#{name}' name='#{name}'/>")
      self;Fi[	@h$i"I"”    
    def function(arglist)
      (@var << "\n<input type='#{type}' id='#{name}' name='#{name}'/>")
      self
    end
    
    def function(arglist)
      label_field(var, var)
      input_field("text", var);Fi[	@h$i(I"≈    def function(arglist)
      label_field(var, var)
      input_field("text", var)
      self
    end
    
    def function(arglist)
      label_field(var, var)
      input_field("password", var);Fi[	@h$i.I"◊    def function(arglist)
      label_field(var, var)
      input_field("password", var)
      self
    end
    
    def function(arglist)
      @var = true
      (@var << "\n<button type='submit'>#{text}</button>");Fi[	@h$i>I"ë      (@var << "\n<fieldset#{" style='#{options[:style]}'" if options[:style]}#{" id='#{options[:id]}'" if options[:id]}>\n  <legend>#{legend}</legend>\n")
      self.instance_eval(&var)
      (@var << "\n</fieldset>")
      self
    end
    
    def function(arglist)
      (@var << "      <!DOCTYPE html>\n      <html>\n      <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        <title>#{title}</title>\n        #{css}\n        #{header_info}\n      </head>\n      <body>\n      <h1>#{title}</h1>\n      <form method='post' #{"action='#{options[:url]}' " if options[:url]}noValidate='noValidate'>\n")
      self;Fi[	@h$iCI"+    
    def function(arglist)
      (@var << "      <!DOCTYPE html>\n      <html>\n      <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        <title>#{title}</title>\n        #{css}\n        #{header_info}\n      </head>\n      <body>\n      <h1>#{title}</h1>\n      <form method='post' #{"action='#{options[:url]}' " if options[:url]}noValidate='noValidate'>\n")
      self
    end
    
    def function(arglist)
      return self if @var
      (@var << "\n<button type='submit'>Connect</button>") unless @var;Fi[	@h$iKI"‚      (@var << "\n<button type='submit'>Connect</button>") unless @var
      (@var << "      </form>\n      </body>\n      </html>\n")
      @var = true
      self
    end
    
    def function(arglist)
      footer
      @var;Fi[	@ÃiI"±        
        def function(arglist)
          @var = var.flatten
          self
        end
        
        def function(arglist)
          @var = var.flatten
          self;Fi[	@Ãi#I"Õ        
        def function(arglist)
          @var = var.flatten
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class);Fi[	@⁄iI"°        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self;Fi[	@⁄i"I"∑        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last
          self;Fi[	@⁄i'I"€        
        def function(arglist)
          @var, @var = var.first, var.last
          self
        end
        
        def function(arglist)
          @var = var
          @var = @var.new if (@var.class == Class);Fi[	@ii"I"Ë      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        (var.description == description).&((var.location == location))
      end;Fi[	@üiEI"è      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@üiJI"è      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@üiOI"è      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@üiTI"è      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self;Fi[	@üiYI"ó      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "change ##{@message}"
      end;Fi[	@øiTI"®        end
        @var = var
        @var = var
        self
      end
      
      def function(arglist)
        "#{relativities[@relativity]}#{@expected}"
      end;Fi[	@oi$I"Ü      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end;Fi[	@€igI"´          yield(@var)
        end
        (@var << var)
        self
      end
      
      def function(arglist)
        (@var == var) and @var.args_match?(var)
      end;Fi[	@€iI"Œ      
      def function(arglist)
        @var = ArgumentExpectation.new(var, &var)
        self
      end
      
      def function(arglist)
        set_expected_received_count(:exactly, var)
        self;Fi[	@€iıI"–      
      def function(arglist)
        set_expected_received_count(:exactly, var)
        self
      end
      
      def function(arglist)
        set_expected_received_count(:at_least, var)
        self;Fi[	@€i˙I"–      
      def function(arglist)
        set_expected_received_count(:at_least, var)
        self
      end
      
      def function(arglist)
        set_expected_received_count(:at_most, var)
        self;Fi[	@€iˇI"∂      
      def function(arglist)
        set_expected_received_count(:at_most, var)
        self
      end
      
      def function(arglist)
        @var = var if var
        self;Fi[	@€iI"§      
      def function(arglist)
        @var = var if var
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = :any;Fi[	@€i
I"°      def function(arglist)
        @var = var if var
        @var = :any
        self
      end
      
      def function(arglist)
        @var = 0
        self;Fi[	@€iI"ò      
      def function(arglist)
        @var = 0
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 1;Fi[	@€iI"´      def function(arglist)
        @var = var if var
        @var = 1
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 2;Fi[	@€iI"∂      def function(arglist)
        @var = var if var
        @var = 2
        self
      end
      
      def function(arglist)
        @var = var if var
        @var.register(self);Fi[	@€i"I"¢        @var = var if var
        @var.register(self)
        @var = true
        self
      end
      
      def function(arglist)
        return false
      end;Fi[@µ @°+I"@var = var;FI"@var = var;Fi;[;[	@ΩiI"1      autoload(:JoinAssociation, "active_record/associations/join_dependency/join_association")
      
      attr_reader(:join_parts, :reflections, :alias_tracker, :active_record)
      
      def function(arglist)
        @var = var
        @var = var
        @var = [JoinBase.new(var)]
        @var = {};Fi[	@√i
I"    class Preloader
      class Association
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@igI"¿    
    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end;Fi[	@(iI"¶      
      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        ;Fi[	@IiI"
    class AbstractMysqlAdapter < AbstractAdapter
      class Column < ConnectionAdapters::Column
        attr_reader(:collation, :strict)
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var, var)
        end;Fi[	@LiI"∑      
      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        ;Fi[	@íi	I"ß  module ConnectionAdapters
    class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@ûi˘I"Ç    end
    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    ;Fi[	@ŸiI"≠    alias :loaded? :loaded
    
    alias :default_scoped? :default_scoped
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = nil;Ti[	@≠i
I"Ø    include(Enumerable)
    
    attr_reader(:columns, :rows, :column_types)
    
    def function(arglist)
      @var = var
      @var = var
      @var = nil
      @var = var;Fi[	@˝iI"émodule Backup
  class Splitter
    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    ;Fi[	@6iI"Ω    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@i0iI"‘module Bundler
  class Environment
    attr_reader(:root)
    
    def function(arglist)
      @var = var
      @var = var
      var = Bundler.app_config_path.join("environment.rb")
      var.rmtree if var.exist?;Fi[	@i	I"ômodule Bundler
  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@LiI"º    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = []
      @var = var;Fi[	@"iI"Æ    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@CiI"À        attr_accessor(:path, :uri, :ref)
        
        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	I"+data//cancan_proj/cancan/exceptions.rb;TiI"    attr_reader(:action, :subject)
    
    attr_writer(:default_message)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "You are not authorized to access this page.");Fi[	@ºi(I"ı      def self.matches_condition?(arglist)
        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@‡iI"module Capistrano
  class Callback
    attr_reader(:source, :options, :only, :except)
    
    def function(arglist)
      @var = var
      @var = var
      @var = Array(var[:only]).map { |arglist| var.to_s }
      @var = Array(var[:except]).map { |arglist| var.to_s };Fi[	@˜i;I"Ÿ        
        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end;Fi[	@˜iVI"•            end
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          super(var, var, var)
        end;Fi[	@OisI"“            var = (var[3] or "highest")
            InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          ;Fi[	@¬i!I"ú    attr_reader(:logger)
    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@iI"⁄      attr_accessor(:template_path, :target_path, :working_path)
      
      attr_accessor(:options)
      
      def function(arglist)
        @var = var
        @var = var
        @var = Dir.getwd
        @var = var;Fi[	@iI"§      def self.ctx(arglist)
        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@Wi"I"’            return var.gsub("#{path}/", "") if var.include?(var)
          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@§iI"Ÿ      include(Constantize)
      
      attr_reader(:out_stream)
      
      def function(arglist)
        @var = var
        @var = var
        @var = Options.new(@var, @var, :default_profile => "default")
      end;Fi[	@ßiI"†          new(var).execute!
        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil;Fi[	@¨i%I"Í      def self.parse(arglist)
        new(var, var, var).parse!(var)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var[:default_profile]
        @var = var[:skip_profile_information];Fi[	@i)I"◊      
      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@i	I"≠  module RbSupport
    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end;Fi[	@ØiI"˘      attr_accessor(:strategy)
      
      attr_reader(:args, :options, :provider, :strategy_name)
      
      def function(arglist)
        @var = var
        @var = var
        @var = @var.last.is_a?(Hash) ? (@var.last) : ({})
        @var = nil;Fi[	@ti$I"x      var.html
    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var;Fi[	@ï(i
I"Ü  include(PostsHelper)
  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  ;Fi[	@“iI"Ærequire(Rails.root.join("lib", "template_picker"))
class PostPresenter
  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  ;Fi[	@UiâI"Ó  attr(:actual)
  
  attr(:hash_type)
  
  def function(arglist)
    @var = var
    @var = var
    @var = var.hash_type.to_s.upcase
    super("      #{@hash_type} mismatch\n      Expected: #{@expected}\n      Actual: #{@actual}\n".undent);Fi[	@®iI"π  attr(:install_bottle, true)
  
  attr(:show_header, true)
  
  def function(arglist)
    @var = var
    @var = var
    @var = false
    @var = (ARGV.ignore_deps? or ARGV.interactive?);Fi[	@Äi
I"ùrequire("version")
class SoftwareSpec
  attr_reader(:checksum, :mirrors, :specs)
  
  def function(arglist)
    @var = var
    @var = var
    @var = []
  end;Fi[	@ÄikI"¥end
class KegOnlyReason
  attr_reader(:reason, :explanation)
  
  def function(arglist)
    @var = var
    @var = var
    @var = case @var
    when :provided_pre_mountain_lion then;Fi[	@ØiI"ëclass LanguageModuleDependency < Requirement
  fatal(true)
  
  def function(arglist)
    @var = var
    @var = var
    @var = (var or var)
  end;Fi[	@Â	i
I"Ù    module Errors
      class AttributeAssignmentError < Mongoid::Errors::MongoidError
        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end;Fi[	@MiI"¨module Paperclip
  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end;Fi[	@Ui|I"†  def function(arglist)
    return [@var, @var, @var]
  end
  
  def function(arglist)
    @var = var
    @var = var
    var = var if (var == -1)
    @var = var;Fi[	@UiêI"É  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var)
  end;Fi[	@≥i	I"  module Helpers
    class TimeReport
      attr_reader(:criteria, :columns, :hours, :total_hours, :periods)
      
      def function(arglist)
        @var = var
        @var = var
        @var = (var or [])
        @var = @var.select { |arglist| available_criteria.has_key?(var) };Fi[	@fivI"√      def function(arglist)
        example_group_hierarchy.run_after_each(self)
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = caller
      end;Fi[	@«iI"ª      include(Spec::Matchers)
      
      attr_reader(:expected, :actual)
      
      def function(arglist)
        @var = var
        @var = var
        @var = nil
        @var = false;Fi[	@ri	I"„  module Matchers
    class SimpleMatcher
      attr_writer(:failure_message, :negative_failure_message, :description)
      
      def function(arglist)
        @var = var
        @var = var
        @var = @var = nil
      end;Fi[	@|i	I"∂  module Mocks
    class ArgumentExpectation
      attr_reader(:args)
      
      def function(arglist)
        @var = var
        @var = var
        @var = false
        @var = nil;Fi[	@ÈiI"        @@warn_about_expectations_on_nil = false
        $rspec_mocks.add(nil) unless $rspec_mocks.nil?
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = ErrorGenerator.new(var, var, var)
        @var = OrderGroup.new(@var);Fi[	@ñ$iI"éend
class SiriObject
  attr_accessor(:klass, :group, :properties)
  
  def function(arglist)
    @var = var
    @var = var
    @var = {}
  end;Fi[	@ÖiI"      REGEX = /^(@(#{KEYWORDS.join("|")})|.+\s+.+\s+.+\s+.+\s+.+.?)$/
      
      attr_accessor(:time, :task)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var.is_a?(String) ? ((Chronic.parse(var) or 0)) : ((var or 0));Fi[	@ài I"ë    def function(arglist)
      @var[var.to_s] = var
    end
    
    def function(arglist)
      @var = var
      @var = var
      yield
    end;Fi[@'@¸@ˇ,I"# do nothing;Fi9[9[	@àiI"™      
      def function(arglist)
        reflection.polymorphic_inverse_of(var.class)
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@0iI"œ      # done if the transaction block raises an exception or returns false.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Fi˙I"        var = "#transaction_joinable= is deprecated. Please pass the :joinable option to #begin_transaction instead."
        ActiveSupport::Deprecation.warn(var)
        @var.joinable = var
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Fi˛I"ä      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@FiI"ä      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@B)i9I"r    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@ﬂi‚I"´            raise(InverseOfAssociationNotFoundError.new(self))
          end
        end
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ﬂiÊI"ä      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@i0i&I"ê    
    def function(arglist)
      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end;Fi[	@gi
I"~  class UI
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@giI"}    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@giI"}    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@giI"}    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@giI"}    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@Õi,I"Ÿ          unless (config_files_exist? or @var.generate_config?.!) then
            write_configuration_files
          end
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@a)iI"†    
    def function(arglist)
      OptionParser.new { |arglist| self.set_options(var) }
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@iI"Ã      def function(arglist)
        directory(targetize(""))
        directory(targetize(Compass.configuration.sass_dir))
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@íiTI"Ü  class NullLogger
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@’i I"≠        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@fiI"È        end
        self.mixin_def_count += 1 if var.is_a?(Sass::Tree::MixinDefNode)
        self.mixin_count += 1 if var.is_a?(Sass::Tree::MixinNode)
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@fi I"ä      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@äiI"®        
        def function(arglist)
          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@çiAI"ÿ        var.visit_steps(@var)
        skip_invoke! if @var and @var.failed?
        var.visit_examples_array(@var) unless @var.empty?
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ñiI"û        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@∏iÜI"Â        else
          @var.puts(format_string("\nThe --wip switch was used, so the failures were expected. All is good.\n", :passed))
        end
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ﬁiEI"Û      def function(arglist)
        @var = (var.nil? or (var == "")) ? ("Unnamed scenario") : (var.split("\n")[0])
        @var = "#{keyword}: #{@scenario}\n\n"
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@itI"»      
      def function(arglist)
        var.each { |arglist| load_code_file("#{path_to_load_js_from}#{js_file}") }
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@i|I"ë      
      def function(arglist)
        @var = var.language
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@i;I"        var = Ast::Step.new(var.line, var.keyword, var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        var.gherkin_statement(var)
        @var.add_step(var)
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@i?I"ä      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@iI"ã      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@i"I"›        RubyPython.start
        @var = import((File.dirname("(string)") + "/py_language.py"))
        @var.each { |arglist| import(var) }
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@=iI"ö        
        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@=iI"·        
        def function(arglist)
          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@PiI"ò      
      def function(arglist)
        raise(@var.exception(var))
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ViI"á      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@Éi,I"á      
      def function(arglist)
        :inactive
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@çiOI"§        var = update_attributes(var, *var)
        clean_up_passwords
        var
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@òiOI"¿      def function(arglist)
        self.reset_password_token = nil
        self.reset_password_sent_at = nil
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@ÿ#i8I"n  
  def function(arglist)
    self.class.name
  end
  
  def function(arglist)
    # do nothing
  end
  ;Fi[	@±0i%I"õ    var = truncate(var, :length => ((var - var)))
    var = "#{truncated}#{url}"
    return var
  end
  
  def function(arglist)
    # do nothing
  end
end;Fi[	@<izI"o          end
        end
      end
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@ªiI"’            [404, { "Content-Type" => "text/plain" }, [(var or var.key?("omniauth.auth").to_s)]]
          end)
        end.to_app
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@π)iI"u    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@MiI"~      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@UiI"k  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    # do nothing
  end
  ;Fi[	@iI"í      
      def function(arglist)
        var.gsub!("//", "/")
      end
      
      def function(arglist)
        # do nothing
      end
      ;Fi[	@/iI"ö            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@/iI"ù        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@4iI"‹        def function(arglist)
          @var.puts("#{example_group.description} #{example.description}")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@4iI"ù        
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end;Fi[	@9i|I"≈            var = (((example_number.to_f / @var.to_f) * 1000).to_i / 10.0)
          end
          var
        end
        
        def function(arglist)
          # do nothing
        end
        ;Fi[@'@¸I"#:nodoc:;FI"def function(arglist);Fi9[9[	@iFI"        # SQL statements.
        def function(arglist)
          @var ||= connection.quote_column_name(primary_key)
        end
        
        #:nodoc:
        def function(arglist)
          if (self == base_class) then
            self.primary_key = get_primary_key(base_class.name);Fi[	@UiI"*      include(ActiveModel::Validations::Callbacks)
      define_model_callbacks(:initialize, :find, :touch, :only => :after)
      define_model_callbacks(:save, :create, :update, :destroy)
    end
    
    #:nodoc:
    def function(arglist)
      run_callbacks(:destroy) { |arglist| super }
    end;Fi[	@Ui#I"¬    #:nodoc:
    def function(arglist)
      run_callbacks(:save) { |arglist| super }
    end
    
    #:nodoc:
    def function(arglist)
      run_callbacks(:create) { |arglist| super }
    end;Fi[	@(iPI"‘      
      def function(arglist)
        Base.send(spec.adapter_method, spec.config)
      end
      
      #:nodoc:
      def function(arglist)
        Base.connection_id ||= Thread.current.object_id
      end;Fi[	@0iÍI"¢      
      def function(arglist)
        @var = @var.begin(var)
      end
      
      #:nodoc:
      def function(arglist)
        @var = @var.commit
      end;Fi[	@0iÔI"®      #:nodoc:
      def function(arglist)
        @var = @var.commit
      end
      
      #:nodoc:
      def function(arglist)
        @var = @var.rollback
      end;Fi[	@0iÙI"∏      #:nodoc:
      def function(arglist)
        @var = @var.rollback
      end
      
      #:nodoc:
      def function(arglist)
        @var = ClosedTransaction.new(self)
      end;Fi[	@>iI"       # entire structure of the database.
      def function(arglist)
        # do nothing
      end
      
      #:nodoc:
      def function(arglist)
        var = ActiveRecord::Migrator.schema_migrations_table_name
        ActiveRecord::SchemaMigration.order("version").map do |arglist|;Fi[	@IiI"´        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        self.class::ADAPTER_NAME
      end;Fi[	@IiI"ó        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("COMMIT");Fi[	@IiI"ô        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("ROLLBACK");Fi[	@ziI"ﬂ      module ReferentialIntegrity
        def function(arglist)
          true
        end
        
        #:nodoc:
        def function(arglist)
          begin
            (if supports_disable_referential_integrity? then;Fi[	@çinI"õ        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        "SQLite"
      end;Fi[	@çi∞I"G      
      def function(arglist)
        true
      end
      
      #:nodoc:
      def function(arglist)
        { :primary_key => (default_primary_key_type), :string => ({ :name => "varchar", :limit => 255 }), :text => ({ :name => "text" }), :integer => ({ :name => "integer" }), :float => ({ :name => "float" }), :decimal => ({ :name => "decimal" }), :datetime => ({ :name => "datetime" }), :timestamp => ({ :name => "datetime" }), :time => ({ :name => "time" }), :date => ({ :name => "date" }), :binary => ({ :name => "blob" }), :boolean => ({ :name => "boolean" }) }
      end;Fi[	@çi>I"Ï      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      
      #:nodoc:
      def function(arglist)
        log("begin transaction", nil) { |arglist| @var.transaction }
      end;Fi[	@çiCI"ˆ      #:nodoc:
      def function(arglist)
        log("begin transaction", nil) { |arglist| @var.transaction }
      end
      
      #:nodoc:
      def function(arglist)
        log("commit transaction", nil) { |arglist| @var.commit }
      end;Fi[	@çiHI"ˆ      #:nodoc:
      def function(arglist)
        log("commit transaction", nil) { |arglist| @var.commit }
      end
      
      #:nodoc:
      def function(arglist)
        log("rollback transaction", nil) { |arglist| @var.rollback }
      end;Fi[	@ΩiwI"„            compute_table_name
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        (parents.detect { |arglist| var.respond_to?(:table_name_prefix) } or self).table_name_prefix
      end;Fi[	@ΩiíI"Á        else
          (@var ||= nil or base_class.sequence_name)
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var = false
        @var = connection.default_sequence_name(table_name, primary_key);Fi[	@ŸiÊI"—    
    def function(arglist)
      var.pp(self.to_a)
    end
    
    #:nodoc:
    def function(arglist)
      if default_scoped? and var = klass.send(:build_default_scope) then
        var = var.merge(self);Ti[	@˝i+I"¯        #   Post.published
        def function(arglist)
          block_given? ? (relation.scoping { |arglist| yield }) : (relation)
        end
        
        #:nodoc:
        def function(arglist)
          self.current_scope = nil
        end;Fi[	@'iJI"    # See ActiveRecord::Transactions::ClassMethods for detailed documentation.
    def function(arglist)
      self.class.transaction(var, &var)
    end
    
    #:nodoc:
    def function(arglist)
      with_transaction_returning_status { |arglist| super }
    end;Fi[	@iI"®    say(("-" * var.size))
    print_table(var, :truncate => (true))
    say
  end
  
  #:nodoc:
  def function(arglist)
    var = []
    var = ["Modules", "Namespaces"];Fi[	@§iI"ã      def function(arglist)
        var = var.to_s
        (var.size == 1) ? (/\A#{var}\z/i) : (/\A(#{var}|#{var[0, 1]})\z/i)
      end
      
      #:nodoc:
      def function(arglist)
        "Y - yes, overwrite\nn - no, do not overwrite\na - all, overwrite this and all others\nq - quit, abort\nd - diff, show the differences between the old and the new\nh - help, show this help\n"
      end;Fi[	@Ëi]I"Ì          end
          puts
        end
      end
      
      #:nodoc:
      def function(arglist)
        var = File.read(File.join(File.dirname("(string)"), "help.txt"))
        self.class.ui.page_at = (self.class.ui.output_rows - 2);Fi[	@ËiuI"¨          end
        end
        var
      end
      
      #:nodoc:
      def function(arglist)
        if @var.nil? then
          if self.class.ui.output_cols.nil? then;Fi[	@ÎiïI"ƒ          break if (var == Dir.pwd)
        end
        Dir.chdir(var)
      end
      
      #:nodoc:
      def function(arglist)
        File.join(sysconf_directory, "capistrano.conf")
      end;Fi[	@ÎiöI"‘      #:nodoc:
      def function(arglist)
        File.join(sysconf_directory, "capistrano.conf")
      end
      
      #:nodoc:
      def function(arglist)
        File.join(home_directory, ".caprc")
      end;Fi[	@Îi¶I"      # appropriate location for this file in Windows.
      def function(arglist)
        (ENV["SystemRoot"] or "/etc")
      end
      
      #:nodoc:
      def function(arglist)
        (ENV["HOME"] or ((ENV["HOMEPATH"] and "#{ENV["HOMEDRIVE"]}#{ENV["HOMEPATH"]}") or "/"))
      end;Fi[	@ñiåI"Î      #
      def function(arglist)
        cell_matrix.map { |arglist| var.map { |arglist| var.value } }
      end
      
      #:nodoc:
      def function(arglist)
        @var ||= cell_matrix[0].map { |arglist| var.value }
      end;Fi[	@ñisI"Î      
      def function(arglist)
        raw.flatten.compact.detect { |arglist| var.index(var) }
      end
      
      #:nodoc:
      def function(arglist)
        @var ||= cell_matrix.map { |arglist| @var.new(self, var) }
      end;Fi[	@ñixI"≈      #:nodoc:
      def function(arglist)
        @var ||= cell_matrix.map { |arglist| @var.new(self, var) }
      end
      
      #:nodoc:
      def function(arglist)
        raw.first
      end;Fi[	@ñi—I"Õ          var[0].value = var
          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          require("diff/lcs");Fi[	@ñiﬂI"›      
      def function(arglist)
        @var = @var = @var = @var = nil
      end
      
      #:nodoc:
      def function(arglist)
        @var ||= cell_matrix.transpose.map { |arglist| @var.new(self, var) }
      end;Fi[	@ñi7I"‡        #:nodoc:
        def function(arglist)
          [:row, line, *@var.map { |arglist| var.to_sexp }]
        end
        
        #:nodoc:
        def function(arglist)
          @var ||= @var.to_hash(self)
        end;Fi[	@«iI"%          @@converter = Syntax::Convertors::HTML.for_syntax("ruby"))
        rescue LoadError => var
          @@converter = NullConverter.new
        end
        
        #:nodoc:
        def function(arglist)
          var, var = snippet_for(var[0])
          var = @@var.convert(var, false);Fi[	@i£I"        @var = binary.nil? ? (Cucumber::BINARY) : (File.expand_path(binary))
        @var.insert(0, LIB) if (binary == Cucumber::BINARY)
        define_task
      end
      
      #:nodoc:
      def function(arglist)
        desc(@var)
        task(@var) { |arglist| runner.run };Fi[	@i∂I"Á            InProcessCucumberRunner.new(libs, var, feature_files)
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var ? ([cucumber_opts, "--profile", @var]) : (cucumber_opts)
      end;Fi[	@iªI"˜      #:nodoc:
      def function(arglist)
        @var ? ([cucumber_opts, "--profile", @var]) : (cucumber_opts)
      end
      
      #:nodoc:
      def function(arglist)
        make_command_line_safe(FileList[(ENV["FEATURE"] or [])])
      end;Fi[	@EimI"“      @var = nil
      return if @var.dry_run?
      @var.fire_hook(:after, var)
    end
    
    #:nodoc:
    def function(arglist)
      return if @var.dry_run?
      @var.fire_hook(:execute_after_step, @var);Fi[	@(iKI"“      else
        instance.errors.none? { |arglist| var.to_s.start_with?(@var.to_s) }
      end
    end
    
    #:nodoc:
    def function(arglist)
      var = @var[:storage].to_s.downcase.camelize
      begin;Fi[	@(iìI"A    
    def function(arglist)
      @var = (@var + var.uniq.map { |arglist| path(var) if exists?(var) }.compact)
    end
    
    #:nodoc:
    def function(arglist)
      return if (@var[:preserve_files] or file?.!)
      @var = (@var + [:original, *styles.keys].uniq.map { |arglist| path(var) if exists?(var) }.compact);Fi[	@(iüI"3      instance_write(:fingerprint, nil)
      instance_write(:created_at, nil) if has_enabled_but_unset_created_at?
      instance_write(:updated_at, nil)
    end
    
    #:nodoc:
    def function(arglist)
      @var.each do |arglist|
        [var].flatten.each { |arglist| instance.errors.add(name, var) };Fi[	@∑(iI"    # by default. Set Paperclip.options[:log] to false to turn off.
    def function(arglist)
      logger.info("[paperclip] #{message}") if logging?
    end
    
    #:nodoc:
    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end;Fi[	@ÂiI"Ò      
      def function(arglist)
        original_filename ? (File.exist?(path(var))) : (false)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          FileUtils.mkdir_p(File.dirname(path(var)));Fi[	@Âi!I"£        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin;Fi[	@ÎiƒI"æ      
      def function(arglist)
        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin;Fi[	@Îi‡I"£        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin;Fi[	@ﬁiMI"√      
      def function(arglist)
        __mock_proxy.received_message?(var.to_sym, *var, &var)
      end
      
      #:nodoc:
      def function(arglist)
        __mock_proxy.verify
      end;Fi[	@ﬁiRI"ß      #:nodoc:
      def function(arglist)
        __mock_proxy.verify
      end
      
      #:nodoc:
      def function(arglist)
        __mock_proxy.reset
      end;Fi[	@ÈiHI"Í        else
          raise(MockExpectationError, "The method `#{message}` was not stubbed or was already unstubbed")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          verify_expectations;Fi[	@UiI"/          @@converter = Syntax::Convertors::HTML.for_syntax("ruby"))
        rescue LoadError => var
          @@converter = NullConverter.new
        end
        
        #:nodoc:
        def function(arglist)
          var, var = snippet_for(var.backtrace[0])
          var = @@var.convert(var, false);Fi[@‹.I"var;FI"end;FI"end;Fi8[8[	@ilI"ö        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end
  end
  ;Fi[	@6iI"¡    def function(arglist)
      if var.respond_to?(:permitted?) and var.permitted?.! then
        raise(ActiveModel::ForbiddenAttributesError)
      else
        var
      end
    end
  end
end;Fi[	@i!I"À          aliases[var] += 1
          if (aliases[var] > 1) then
            "#{truncate(aliased_name)}_#{aliases[aliased_name]}"
          else
            var
          end
        end
      end
      ;Fi[	@ãiXI"ò              var[var] = var[var]
            end
            var
          else
            var
          end
        end
        (var + var)
      end;Fi[	@0iI"        if var.respond_to?(:ast) then
          var = var.dup
          visitor.accept(var.ast) { |arglist| quote(*var.shift.reverse) }
        else
          var
        end
      end
      
      # Returns an array of record hashes with the column names as keys and;Fi[	@>i<I"            end
          end
          var
        else
          var
        end
      end
      
      def function(arglist);Fi[	@biI"Ù        def function(arglist)
          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",")
          else
            var
          end
        end
        
        def function(arglist);Fi[	@bi-I"                 var = var.gsub(/^"(.*)"$/, "\\1").gsub(/\\(.)/, "\\1")
                [var, var]
              end]
            else
              var
            end
          end
        end
        ;Fi[	@biQI"¸        def function(arglist)
          if IPAddr.===(var) then
            "#{object.to_s}/#{object.instance_variable_get(:@mask_addr).to_s(2).count("1")}"
          else
            var
          end
        end
        
        def function(arglist);Fi[	@bieI"                var = ("(" == var[1]) ? ((var[2].to_i + 1)) : (var[2].to_i)
                var = (")" == var[5]) ? ((var[4].to_i - 1)) : (var[4].to_i)
                (var..var)
              else
                var
              end
            end
          end
        end;Fi[	@bizI"ë                  nil
                end
              end
            else
              var
            end
          end
        end
        ;Fi[	@kiëI"Í              return var unless var
            end
            last_insert_id_result(var)
          else
            var
          end
        end
        
        # Executes an UPDATE query and returns the number of affected tuples.;Fi[	@riLI"Á          def function(arglist)
            if String.===(var) then
              ConnectionAdapters::PostgreSQLColumn.string_to_array(var, @var)
            else
              var
            end
          end
        end
        ;Fi[	@ïi`I"        var = Relation.new(self, arel_table)
        if finder_needs_type_condition? then
          var.where(type_condition).create_with(inheritance_column.to_sym => (sti_name))
        else
          var
        end
      end
    end
    ;Fi[	@ØiëI"e      var.map! do |arglist|
        if var.is_a?(Symbol) and self.column_names.include?(var.to_s) then
          "#{connection.quote_table_name(table_name)}.#{connection.quote_column_name(column_name)}"
        else
          var
        end
      end
      if has_include?(var.first) then
        construct_relation_for_association_calculations.pluck(*var);Fi[	@Ûi›I"ô      when Relation then
        var ||= "subquery"
        var.arel.as(var.to_s)
      else
        var
      end
    end
    
    def function(arglist);Fi[	@ÛiI"≥          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end
    ;Fi[	@Ûi+I"≈          table[var].asc
        when Hash then
          var.map { |arglist| table[var].send(var) }
        else
          var
        end
      end
      var.order(*var) unless var.empty?
    end;Fi[	@¯i!I"Â          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_conditions(var, var)
        else
          var
        end
      end
      
      alias_method(:sanitize_sql, :sanitize_sql_for_conditions);Fi[	@¯i1I"Á          sanitize_sql_array(var)
        when Hash then
          sanitize_sql_hash_for_assignment(var)
        else
          var
        end
      end
      
      # Accepts a hash of SQL conditions and replaces those attributes;Fi[	@iI"∂        case var
        when Symbol, String then
          Thor::Util.find_class_and_task_by_namespace(var.to_s, var.!)
        else
          var
        end
      end
    end
    ;Ti[	@üi@I"}        shift
        @var = false
        super
      else
        var
      end
    end
    
    def function(arglist);Fi[	@Îi≈I"y          false
        when "nil" then
          nil
        else
          var
        end
      end
    end
  end;Fi[	@{iÑI"î            "#head"
          when /^\d+/ then
            "@#{revision}"
          else
            var
          end
        end
      end
    end;Fi[	@¬iØI"î          var = StringIO.new(var.read)
          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end
    ;Fi[	@€i\I"ü          else
            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      
      def function(arglist);Fi[	@·i*I"¸        (additional_import_paths or []).map do |arglist|
          if var.is_a?(String) and (project_path and absolute_path?(var).!) then
            File.join(project_path, var)
          else
            var
          end
        end
      end
      ;Fi[	@+iNI"Ø          "left"
        when "center" then
          "center"
        else
          var
        end
      end
      Sass::Script::String.new(var.join(" "), var.type)
    end;Fi[	@!i?I"Ê        if var.respond_to?(:supports?) and (var.supports?(var) and var.respond_to?(:"to_#{var}")) then
          var.options = options
          var.send(:"to_#{var}")
        else
          var
        end
      end
    end
  end;Fi[	@$iŸI"∫          Sass::Script::Number.new(100, ["%"])
        when /center/ then
          Sass::Script::Number.new(50, ["%"])
        else
          var
        end
      end
      var
    end;Fi[	@çiZI"û    else
      if defined? Sass::Script::List and var.is_a?(Sass::Script::List) then
        var.value.first
      else
        var
      end
    end
  end
  ;Fi[	@¶i I"√      Sass::Script::String.new(reversed_color_names[var.rgb])
    when Sass::Script::Bool then
      Sass::Script::String.new(var.to_s)
    else
      var
    end
  end
  
  def function(arglist);Fi[	@§i{I"           else
            if (var[(0..0)] == "@") and File.file?(var[(1..-1)]) then
              IO.read(var[(1..-1)]).split
            else
              var
            end
          end
        end.flatten.uniq
        remove_excluded_files_from(var);Fi[	@∏iBI"!        @var.collect! do |arglist|
          if var.is_a?(Cucumber::Ast::OutlineTable::ExampleRow) then
            var.scenario_outline
          else
            var
          end
        end
        if @var.empty?.! then
          @var.puts(format_string("Failing Scenarios:", :failed));Fi[	@«i⁄I"&        var.gsub(/\A([^:]*\.(?:rb|feature|haml)):(\d*).*\z/) do |arglist|
          if ENV["TM_PROJECT_DIRECTORY"] then
            "<a href=\"txmt://open?url=file://#{File.expand_path($1)}&line=#{$2}\">#{$1}:#{$2}</a> "
          else
            var
          end
        end
      end
      ;Fi[	@i•I"ü            var.backtrace.push(var.backtrace_line("World"))
            raise(var)
          end
        else
          var
        end
      end
    end
  end;Fi[	@=iîI"Õ            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end
      ;Fi[	@ùiNI"ì        end
      when Hash then
        _process_unauthenticated(var, var)
      else
        var
      end
    end
    
    def function(arglist);Fi[	@FirI"¸          var.map { |arglist| Haml::Util.html_safe(var) }
        when String then
          Haml::Util.html_safe(var)
        else
          var
        end
      end
      
      alias_method(:with_output_buffer_without_haml_xss, :with_output_buffer);Fi[	@‘i'I"ö            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end
  end;Fi[	@ˆiI"p      "beta"
    when /\d+/ then
      var.to_i
    else
      var
    end
  end
  
  def function(arglist);Fi[	@ë
ixI"Ù        end
        if var.nil? and (var.autobuilding? and without_autobuild?.!) then
          send("build_#{name}")
        else
          var
        end
      end
      
      # Is the current code executing without autobuild functionality?;Fi[	@hi±I"€              var.merge!(var)
              Factory.build(klass, var, base.send(:mass_assignment_options))
            end
          else
            var
          end
        end
        
        # Get the atomic path.;Fi[	@≠i2I"°          var = default_scoping.try(:call)
          var.remove_scoping(var)
          var.to_proc
        else
          var
        end
      end
    end
  end;Fi[	@(iµI"Ê    def function(arglist)
      if @var[:restricted_characters] then
        var.gsub(@var[:restricted_characters], "_")
      else
        var
      end
    end
    
    # Check if attachment database table has a created_at field;Fi[	@ni(I"Ó      if var[:timestamp] and timestamp_possible? then
        var = var.match(/\?.+=/) ? ("&") : ("?")
        "#{url}#{delimiter_char}#{@attachment.updated_at.to_s}"
      else
        var
      end
    end
    
    def function(arglist);Fi[	@ i6I"Â      def function(arglist)
        if var.is_a?(Range) then
          [:less_than, :less_than_or_equal_to].include?(var) ? (var.max) : (var.min)
        else
          var
        end
      end
      
      def function(arglist);Fi[	@1 i"I"¨      require("memcache")
      require("openid/store/memcache")
      OpenID::Store::Memcache.new(MemCache.new(var))
    else
      var
    end
  end
  
  self.store = nil;Fi[	@xiÆI"¥            if var then
              var = var
              ""
            else
              var
            end
          end
          var = 0
          @var.each do |arglist|;Fi[	@˜iñI"Ç        case var
        when Proc then
          var.call
        else
          var
        end
      end
      
      # :nodoc:;Fi[	@i)I"†        @var = case var
        when Symbol then
          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:;Fi[@	)I"	true;FI"end;FI" ;Fi6[6[	@µiI"ñ      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|;Fi[	I"Wdata//activerecord_proj/active_record/associations/builder/singular_association.rb;TiI"µ      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super;Fi[	@CiI"ß        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false;Fi[	@FiyI"X      
      # Does this adapter support using DISTINCT within COUNT? This is +true+
      # for all adapters except sqlite.
      def function(arglist)
        true
      end
      
      # Does this adapter support DDL rollbacks in transactions? That is, would
      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,;Fi[	@IiáI"º      end
      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true;Fi[	@IiãI"º        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist);Fi[	@IiêI"º      end
      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true;Fi[	@IiîI"„        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax
      # but at the moment (5.5) it doesn't yet implement them;Fi[	@IiöI"m      
      # Technically MySQL allows to create indexes with the sort order syntax
      # but at the moment (5.5) it doesn't yet implement them
      def function(arglist)
        true
      end
      
      # MySQL 4 technically support transaction isolation, but it is affected by a bug
      # where the transaction level gets persisted for the whole session:;Fi[	@Qi&I"∆        configure_connection
      end
      
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================
      def function(arglist);Fi[	@ViI"       
      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================
      def function(arglist);Fi[	@zi	I"‹  module ConnectionAdapters
    class PostgreSQLAdapter < AbstractAdapter
      module ReferentialIntegrity
        def function(arglist)
          true
        end
        
        #:nodoc:
        def function(arglist);Fi[	@çivI"       end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.
      def function(arglist);Fi[	@çi|I"      
      # Returns true, since this connection adapter supports prepared statement
      # caching.
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist);Fi[	@çiÅI"≈      end
      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      # Returns true.
      def function(arglist);Fi[	@çiÜI"â      end
      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true;Fi[	@çiäI"à        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@çièI"í      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var.!=(false);Fi[	@çi•I"ê      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist);Fi[	@çi™I"à      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true;Fi[	@çiÆI"Ç        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:
      def function(arglist);Fi[	@çiΩI"ø      end
      
      # Returns true.
      def function(arglist)
        true
      end
      
      # QUOTING ==================================================
      def function(arglist);Fi[	@B)iI"q      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false;Fi[	@˜i+I"§          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect;Fi[	@Ùi(I"‡        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then;Fi[	@ÙiçI"Ø        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss;Fi[	@!iI"      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value;Fi[	@$iBI"      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "deg") and var.denominator_units.empty?));Fi[	@ªiI"©        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/;Fi[	@Éi&I"â        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive;Fi[	@¨i+I"ı        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length);Fi[	@Õi$I"¡        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "remember_#{scope}_token");Fi[	@–iI"˝      private
      
      # Token Authenticatable can be authenticated with params in any controller and any verb.
      def function(arglist)
        true
      end
      
      # Do not use remember_me behavior with token.
      def function(arglist);Fi[	I"9data//diaspora_proj/models/activity_streams/photo.rb;TiI"  # A hack used in the stream_element partial to display cubbi.es posts correctly.
  # A better solution is needed.
  # @return [Boolean] true
  def function(arglist)
    true
  end
  
  def function(arglist)
    I18n.t("photos.comment_email_subject", :name => (author.name));Fi[	@úiÄI"∑    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  
  scope(:on_statuses, lambda { |arglist| where(:status_message_guid => (var)) })
end;Fi[	@Æi!I"Æ    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("Performing relayable retraction for #{target_guid}");Fi[	@RiI"    # do. To avoid messy logic figuring this out, we just inherit from whatever
    # the ERB handler does.
    # In Rails 3.1+, we don't need to include Compilable.
    def function(arglist)
      true
    end
    
    def function(arglist)
      var = Haml::Template.options.dup;Fi[	@˚#iI"z    
    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var;Fi[	@)	iyI"Ÿ      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.;Fi[	@G	iI"‰      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly;Fi[	@L	i~I"      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the
      # hash which must correspond to method on a criteria object. The hash;Fi[	@Q	iI"Ã      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Is the object not to be converted to bson on criteria creation?
      #;Fi[	@Q	i(I"˜      # @return [ true ] If the object is unconvertable.
      #
      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly;Fi[	@d	i)I"‹      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.;Fi[	@è	i6I"’      # @return [ true, false ] If the field is a foreign key.
      #
      # @since 2.4.0
      def function(arglist)
        true
      end
      
      # Evolve the object into an id compatible object.
      #;Fi[	@í	iI"Ÿ      # @return [ true, false ] If the field is localized.
      #
      # @since 2.3.0
      def function(arglist)
        true
      end
      
      # Convert the provided string into a hash for the locale.
      #;Fi[	@π)iI"x      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing;Fi[	@–iI"†          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "anything";Fi[	I"6data//state_machine_proj/state_machine/matcher.rb;Ti&I"ü    end
    
    # Always returns true
    def function(arglist)
      true
    end
    
    # Always returns the given set of values
    def function(arglist);Fi[@'@¸@ˇ,I"
super;Fi6[6[	@•i8I"ã      autoload(:JSON)
      autoload(:Xml)
    end
  end
  
  def function(arglist)
    super
    ActiveModel::Serializer.eager_load!
  end;Fi[	@ÖiI"∞        set_inverse_instance(var)
        @var = true if var
        self.target = var
      end
      
      def function(arglist)
        super
        @var = false
      end;Fi[	@µi@I"ä      var = "#{callback_name}_for_#{name}"
      model.class_attribute(var.to_sym) unless model.method_defined?(var)
      model.send("#{full_callback_name}=", Array(options[var.to_sym]))
    end
    
    def function(arglist)
      super
      mixin.class_eval("        def #{name.to_s.singularize}_ids\n          association(:#{name}).ids_reader\n        end\n", "(string)", (76 + 1))
    end;Fi[	@µiEI"ì    def function(arglist)
      super
      mixin.class_eval("        def #{name.to_s.singularize}_ids\n          association(:#{name}).ids_reader\n        end\n", "(string)", (76 + 1))
    end
    
    def function(arglist)
      super
      mixin.class_eval("        def #{name.to_s.singularize}_ids=(ids)\n          association(:#{name}).ids_writer(ids)\n        end\n", "(string)", (87 + 1))
    end;Fi[	@∫iI"¡      var = super
      define_destroy_hook
      var
    end
    
    def function(arglist)
      super
      [:delete_sql, :insert_sql].each do |arglist|
        if options.include?(var) then;Fi[	@3iI"ê    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super
      define_constructors if constructable?
    end;Fi[	@ãi"I"        var = Array(var).reject { |arglist| var.blank? }
        var.map! { |arglist| var.type_cast(var) }
        replace(klass.find(var).index_by { |arglist| var.id }.values_at(*var))
      end
      
      def function(arglist)
        super
        @var = []
      end;Fi[	@Ii¯I"Ω      # explicitly freed or not.
      def function(arglist)
        yield(execute(var, var))
      end
      
      def function(arglist)
        super
        @var.affected_rows
      end;Fi[	@QiDI"≠      def function(arglist)
        return false unless @var
        @var.ping
      end
      
      def function(arglist)
        super
        disconnect!
        connect;Fi[	@QiºI"º      # column values as values.
      def function(arglist)
        exec_query(var, var)
      end
      
      def function(arglist)
        super
        (var or @var.last_id)
      end;Fi[	@ViyI"Í        def function(arglist)
          @var[Process.pid]
        end
      end
      
      def function(arglist)
        super
        @var = StatementPool.new(@var, var.fetch(:statement_limit) { |arglist| 1000 })
        @var = nil;Fi[	@Vi©I"ñ        rescue Mysql::Error
          false
        end
      end
      
      def function(arglist)
        super
        disconnect!
        connect;Fi[	@çiI"≤      
      def function(arglist)
        log(var, var) { |arglist| @var.execute(var) }
      end
      
      def function(arglist)
        super
        @var.changes
      end;Fi[	@çi'I"€      def function(arglist)
        var = (var + " WHERE 1=1") unless var =~ /WHERE/i
        super(var, var)
      end
      
      def function(arglist)
        super
        (var or @var.last_insert_row_id)
      end;Fi[	@ñiI"†    def self.reset_runtime(arglist)
      var, self.runtime = runtime, 0
      var
    end
    
    def function(arglist)
      super
      @var = false
    end;Fi[	@⁄iI"Ó        else
          super
        end
      end
      
      def function(arglist)
        super
        if ActiveRecord::Base.connected? then
          var[:db_runtime] = ((db_runtime or 0) + ActiveRecord::LogSubscriber.reset_runtime);Fi[	@ﬂièI"    class AssociationReflection < MacroReflection
      def function(arglist)
        @var ||= active_record.send(:compute_type, class_name)
      end
      
      def function(arglist)
        super
        @var = [:has_many, :has_and_belongs_to_many].include?(macro)
      end;Fi[	@?iI"™      @var = []
      @var = {}
      @var = Hash.new { |arglist| var[var] = [] }
    end
    
    def function(arglist)
      super
      @var = @var.dup
      @var = {};Fi[	@%i%I"Ò        ALL.each do |arglist|
          @var[var] = reverse.find { |arglist| var.match_platform(var) }
        end
      end
      
      def function(arglist)
        super
        @var = var.required_by.dup
        @var = var.activated.dup;Fi[	@€iI"        self.project_name = determine_project_name(var, var)
        Compass.add_configuration({ :project_path => (determine_project_directory(var, var)) }, "implied")
        configure!
      end
      
      def function(arglist)
        super
      end
      ;Fi[	@ƒiI"‚      def function(arglist)
        @var = ensure_io(var, "json")
        super(Gherkin::Formatter::PrettyFormatter.new(@var, false), true)
      end
      
      def function(arglist)
        super
        @var.puts
      end;Fi[	@äi•I"Õ      
      def function(arglist)
        generate_confirmation_token and save(:validate => (false))
      end
      
      def function(arglist)
        super
        confirm! unless confirmed?
      end;Fi[	@iI"√      Rails.logger.info("event=registration status=failure errors='#{@user.errors.full_messages.join(", ")}'")
      redirect_to(:back)
    end
  end
  
  def function(arglist)
    super
  end
  ;Fi[	@£ihI"´    super
    puts("rm #{to_s}") if ARGV.verbose?
    $n = ($n + 1)
  end
  
  def function(arglist)
    super
    puts("rmdir #{to_s}") if ARGV.verbose?
    $d = ($d + 1);Fi[	@£inI"â    super
    puts("rmdir #{to_s}") if ARGV.verbose?
    $d = ($d + 1)
  end
  
  def function(arglist)
    super
    $n = ($n + 1)
  end;Fi[	@£isI"é  def function(arglist)
    super
    $n = ($n + 1)
  end
  
  def function(arglist)
    super
    puts("info #{to_s}") if ARGV.verbose?
  end;Fi[	@£ixI"®  def function(arglist)
    super
    puts("info #{to_s}") if ARGV.verbose?
  end
  
  def function(arglist)
    super
    puts("uninfo #{to_s}") if ARGV.verbose?
  end;Fi[	@iÑI"¸          def function(arglist)
            @var = var
            super()
          end
          
          def function(arglist)
            super
            throw(@var, @var) if @var
            throw(@var, nil) if var =~ /\A(?:div|h1|img|p|br)\z/;Fi[	I":data//redmine_proj/plugins/rfpdf/lib/fpdf/bookmark.rb;Ti:I"«    out((("<</Type /Outlines /First " + var.to_s) + " 0 R"))
    out((("/Last " + (var + var[0]).to_s) + " 0 R>>"))
    out("endobj")
  end
  
  def function(arglist)
    super
    putbookmarks
  end;Fi[	@£3i?I"®  def function(arglist)
    super
    putbookmarks
  end
  
  def function(arglist)
    super
    if @var.empty?.! then
      out((("/Outlines " + @var.to_s) + " 0 R"));Fi[	@ôiºI"›          out("<</Type /Outlines /First #{n} 0 R")
          out("/Last #{(n + lru[0])} 0 R>>")
          out("endobj")
        end
        
        def function(arglist)
          super
          putbookmarks
        end;Fi[	@ôi¡I"⁄        def function(arglist)
          super
          putbookmarks
        end
        
        def function(arglist)
          super
          if (@var.size > 0) then
            out("/Outlines #{@outlineRoot} 0 R");Fi[	@	iII"ÿ      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super
        var = (((@var[:fields][0].length / 2) * font_size) * 0.6)
        @var = var if (var > @var);Fi[	@iPI"ı      
      def function(arglist)
        @var.collect { |arglist| var[:title] }
      end
      
      def function(arglist)
        super
        var = (((get_x_labels[0].to_s.length / 2) * font_size) * 0.6)
        @var = var if (var > @var);Fi[	@iVI"        super
        var = (((get_x_labels[0].to_s.length / 2) * font_size) * 0.6)
        @var = var if (var > @var)
      end
      
      def function(arglist)
        super
        var = (((get_x_labels[-1].to_s.length / 2) * font_size) * 0.6)
        @var = var if (var > @var);Fi[	@iI"„      def self.configure(arglist)
        yield(self)
        Resque::Failure.backend = self
      end
      
      def function(arglist)
        super
        @var = self.class.classes.map { |arglist| var.new(*var) }
      end;Fi[	@liI"À      
      def function(arglist)
        (child_modules << var)
      end
      
      def function(arglist)
        super
        child_modules.each { |arglist| var.__send__(:include, var) }
      end;Fi[	@9i!I"Œ          @var.puts(html_header)
          @var.puts(report_header)
          @var.flush
        end
        
        def function(arglist)
          super
          @var = false
          @var = (@var + 1);Fi[	@>iI"        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super
          var.nested_descriptions.each_with_index do |arglist|
            unless (var.nested_descriptions[(0..var)] == @var[(0..var)]) then;Fi[	@>i$I"5          var = "#{current_indentation}#{example.description}"
          output.puts(green(var))
          output.flush
        end
        
        def function(arglist)
          super
          output.puts(yellow("#{current_indentation}#{example.description} (PENDING: #{message})"))
          output.flush;Fi[	@HiI"„        
        def function(arglist)
          @var = Time.now
        end
        
        def function(arglist)
          super
          (@var << [example_group.description, var.description, (Time.now - @var)])
        end;Fi[	@HiI"2        def function(arglist)
          super
          (@var << [example_group.description, var.description, (Time.now - @var)])
        end
        
        def function(arglist)
          super
          @var.puts("\n\nTop 10 slowest examples:\n")
          @var = @var.sort_by { |arglist| var }.reverse;Fi[	@MiI"Õ        def function(arglist)
          @var.print(green("."))
          @var.flush
        end
        
        def function(arglist)
          super
          @var.print(yellow("*"))
          @var.flush;Fi[	@ZiI"          var = "- #{example.description}"
          output.puts(green(var))
          output.flush
        end
        
        def function(arglist)
          super
          output.puts(yellow("- #{example.description} (PENDING: #{message})"))
          output.flush;Fi[	I"9data//SiriProxy_proj/siriproxy/connection/guzzoni.rb;Ti	I"ì  def function(arglist)
    super
    self.name = "Guzzoni"
  end
  
  def function(arglist)
    super
    start_tls(:verify_peer => (false))
  end;Fi[	I"8data//SiriProxy_proj/siriproxy/connection/iphone.rb;Ti
I"C    puts("Create server for iPhone connection")
    super
    self.name = "iPhone"
  end
  
  def function(arglist)
    super
    start_tls(:cert_chain_file => (File.expand_path("~/.siriproxy/server.passless.crt")), :private_key_file => (File.expand_path("~/.siriproxy/server.passless.key")), :verify_peer => (false))
  end;Fi[	@«3iI"¥  def function(arglist)
    super
    start_tls(:cert_chain_file => (File.expand_path("~/.siriproxy/server.passless.crt")), :private_key_file => (File.expand_path("~/.siriproxy/server.passless.key")), :verify_peer => (false))
  end
  
  def function(arglist)
    super
    self.other_connection = EventMachine.connect("guzzoni.apple.com", 443, SiriProxy::Connection::Guzzoni)
    self.plugin_manager.guzzoni_conn = self.other_connection;Fi[	@ÿiI"–    if other_connection.last_ref_id.!=(var) then
      self.other_connection.last_ref_id = var
    end
  end
  
  def function(arglist)
    super
    self.processed_headers = false
    self.output_buffer = "";Fi[	@ÕiI"è      @var = var
      @var = var[:target]
      @var = var[:guard]
    end
    
    def function(arglist)
      super
      @var = nil
    end;Fi[@V.@W.I"end;FI" ;Fi5[5[	@iHI"    # that the arguments supplied are valid. You could for example raise an
    # +ArgumentError+ when invalid options are supplied.
    def function(arglist)
      # do nothing
    end
  end
  
  class BlockValidator < EachValidator
    def function(arglist);Fi[	@ΩiRI"∑            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      
      protected
      ;Fi[	@0iÕI"Œ            within_new_transaction(var) { |arglist| yield }
          end)
        rescue ActiveRecord::Rollback
          # do nothing
        end
      end
      
      def function(arglist)
        begin;Fi[	@Ci&I"÷      
      # This is a noop when there are no open transactions
      def function(arglist)
        # do nothing
      end
    end
    
    class OpenTransaction < Transaction
      attr_reader(:parent, :records);Fi[	@IiI"ï        begin
          execute("BEGIN")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        begin;Fi[	@IiI"Ù          (execute("SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}")
          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@IiI"ó        begin
          execute("COMMIT")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist);Fi[	@IiI"¡        begin
          execute("ROLLBACK")
        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}");Fi[	@Li%I"®          when Hash then
            resolve_hash_connection(config)
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@ViêI"ê        begin
          exec_query("BEGIN")
        rescue Mysql::Error
          # do nothing
        end
      end
      
      private
      ;Fi[	@¬iI"$      when Proc then
        var.call(var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      raise(RecordNotFound, "Couldn't find #{self.class.reflect_on_association(association_name).klass.name} with ID=#{record_id} for #{self.class.name} with ID=#{id}");Fi[	@ﬂiCI"π            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        options.key?(:polymorphic);Fi[	@Ÿi‡I"î      when Array then
        (to_a == var)
      else
        # do nothing
      end
    end
    
    def function(arglist)
      var.pp(self.to_a);Ti[	@5i!I"∂            set_index_names
          end
        else
          # do nothing
        end
      end
      
      def function(arglist)
        attributes.each_with_index do |arglist|;Fi[	@xiÁI"          "-c --passphrase-file '#{path}'"
        else
          Logger.warn("Symmetric encryption options could not be set.")
          # do nothing
        end
      end
      
      ##
      # Create a temporary file, within a tempdir, to hold the :passphrase and;Fi[	@oiÑI"{      end
      var.finish)
    rescue IOError
      # do nothing
    end
  end
  
  # :nodoc:
  def function(arglist);Fi[	@oi¢I"ı    when Net::HTTP::Delete, Net::HTTP::Get, Net::HTTP::Head, Net::HTTP::Options, Net::HTTP::Put, Net::HTTP::Trace then
      true
    else
      # do nothing
    end
  end
  
  ##
  # Is the request idempotent or is retry_change_requests allowed;Fi[	@`iTI"ô          when /\(yes\/no\)/ then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@liéI"¢          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@qiJI"ñ          when /yes\/no/i then
            "yes\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@{iLI"‚          when /Client \'[\w\-\_\.]+\' unknown.*/i then
            raise(Capistrano::Error, "p4client is incorrect or unset")
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@ÇiWI"¢          when /accept \(t\)emporarily/ then
            "t\n"
          else
            # do nothing
          end
        end
        
        private
        ;Fi[	@ñi‹I"Ù          when :export then
            source.export(revision, destination)
          else
            # do nothing
          end
        end
        
        # Returns the name of the file that the source code will be
        # compressed to.;Fi[	@äiI"Æ        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist)
        @var = (var or EmptyBackground.new);Fi[	@ñi I"á        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable)
      ;Fi[	@«i&I"         when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        var = "img_#{@img_id}";Fi[	@i]I"Ø      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    
    class JsLanguage
      include(LanguageSupport::LanguageMethods);Fi[	@=iI"à        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize)
      ;Fi[	@i`I"û    when "facebook" then
      I18n.t("invitations.a_facebook_user")
    else
      # do nothing
    end
  end
  
  # @return [String]
  def function(arglist);Fi[	@ilI"    when "facebook" then
      false
    else
      # do nothing
    end
  end
  
  # @note before_save
  def function(arglist);Fi[	@i#I"Q    when :ppc, :dunno then
      abort("        Sorry, Homebrew does not support your computer's CPU architecture.\n        For PPC support, see: https://github.com/mistydemeo/tigerbrew\n".undent)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    if HOMEBREW_CELLAR.exist? and HOMEBREW_CELLAR.writable_real?.! then;Fi[	@8i<I"ù    when :gcc then
      MacOS.gcc_42_build_version.to_i
    else
      # do nothing
    end
  end
  
  def function(arglist)
    (@var.to_sym == var.to_sym);Fi[	@îiI"•      @var = @var.keys.first
      @var = @var.values.first
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var.each_with_index do |arglist|;Fi[	@îiI"∫    when 1 then
      Dir.chdir(var.first) rescue nil
    else
      # do nothing
    end
  end
  
  def function(arglist)
    var = /https?:\/\/(www\.)?github\.com\/.*\/(zip|tar)ball\//;Fi[	@™iZI"ê      @var = (@var + ".bz2")
      FileUtils.mv(@var, @var)
    else
      # do nothing
    end
  end
  
  def function(arglist)
    @var.nil?.!;Fi[	@Øi)I"≥    when :rbx then
      ["/usr/bin/env", "rbx", "-rubygems", "-e", "require '#{@import_name}'"]
    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var;Fi[	@!i±I"Û        end
        self.tags.values.map { |arglist| var.sort! { |arglist| (var <=> var) } })
      rescue Errno::ENOENT => var
        # do nothing
      end
    end
    
    # Remove orphaned files and empty directories in destination.
    #;Fi[	@cißI"v      end
      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #
  	# Calculate closing tags.;Fi[	@ci∑I"Å      @var = (@var + 1)
      @var.push([])
    else
      # do nothing
    end
  end
  
  #
  	# Convert to accessible file path;Fi[	@ciíI"Å      SetStyle("b", true)
      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #
  	# Process closing tags.;Fi[	@ci?I"Ö        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.;Fi[	@xiÜI"÷    var.gsub!(TEXTILE_REFS_RE) do |arglist|
      var, var = $~[(2..3)]
      @var[var.downcase] = [var, nil]
      # do nothing
    end
  end
  
  def function(arglist)
    var.gsub!(MARKDOWN_REFS_RE) do |arglist|;Fi[	@xièI"≥      var, var = $~[(2..3)]
      var = $~[6]
      @var[var.downcase] = [var, var]
      # do nothing
    end
  end
  
  def function(arglist)
    var = @var[var.downcase] if var;Fi[	@™i›I"—        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top])
        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format];Fi[	@™iI"Á          pdf_new_page?(var)
          pdf_subject(var, var.name)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Project) and (var.start_date and var.due_date) then;Fi[	@™iI"Ù          pdf_new_page?(var)
          pdf_subject(var, var.to_s_with_project)
        else
          # do nothing
        end
      end
      
      def function(arglist)
        if var.is_a?(Version) and (var.due_date and var.start_date) then;Fi[	@õi!I"ﬁ        trap("USR1", "DEFAULT")
        trap("USR2", "DEFAULT"))
      rescue ArgumentError
        # do nothing
      end
    end
    
    # Schedule this worker for shutdown. Will finish processing the
    # current job.;Fi[	@€i6I"í        when :twice then
          2
        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0;Fi[@'@õ$@ú$I"end;Fi4[4[	@√ilI"˚          var.includes!((var[:includes] or var[:includes]))
          if options[:as] then
            var.where!(klass.table_name => ({ reflection.type => (model.base_class.sti_name) }))
          end
          var
        end
      end
    end
  end;Fi[	@Úi2I"…            end
            var.order!(reflection_scope.values[:order])
            var.references!(reflection_scope.values[:references])
          end
          var
        end
      end
    end
  end;Fi[	@˜iuI"          var = var.class.reflections[var]
          unless var then
            raise(ActiveRecord::ConfigurationError, "Association named '#{association}' was not found; perhaps you misspelled it?")
          end
          var
        end
      end
      
      def function(arglist);Fi[	@ibI"¸            super(var, var)
            serialized_attributes.each do |arglist|
              var[var] = Attribute.new(var, var[var], var) if var.key?(var)
            end
            var
          end
        end
        
        def function(arglist);Fi[	@LiJI"‘          if var.query then
            var = Hash[var.query.split("&").map { |arglist| var.split("=") }].symbolize_keys
            var.merge!(var)
          end
          var
        end
      end
    end
  end;Fi[	@çi I"œ        def function(arglist)
          if var.encoding.!=(Encoding::ASCII_8BIT) then
            var = var.force_encoding(Encoding::ASCII_8BIT)
          end
          var
        end
      end
    end
    ;Fi[	@•i†I"K        return nil if (var.blank? or (var == self.name))
        unless var = subclasses.detect { |arglist| (var.name == var) } then
          raise(ActiveRecord::SubclassNotFound.new("Invalid single-table inheritance type: #{subclass_name} is not a subclass of #{name}"))
        end
        var
      end
    end
    
    private;Fi[	@Îi!I"          else
            var.send("#{k}!", var)
          end
        end
        var
      end
    end
    
    class Merger;Fi[	@iáI"¥        end
        configuration.slice("host", "port", "socket").each do |arglist|
          var.concat(["--#{k}", var]) if var
        end
        var
      end
    end
  end
end;Fi[	@%inI"∞              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@^iXI"{          (var << "\n")
        end
        (var << "end\n") if var
      end
      var
    end
  end
  
  class Dependency;Fi[	@úiÖI"0          if var.enum and var.enum.include?(var).! then
            raise(MalformattedArgumentError, "Expected '#{name}' to be one of #{switch.enum.join(", ")}; got #{value}")
          end
        end
        var
      end
    end
    
    # Raises an error if @non_assigned_required array is not empty.;Fi[	@§iNI"≠          unless var then
            say("Your response must be one of: [#{answers}]. Please try again.")
          end)
        end
        var
      end
    end
  end
end;Fi[	@øi¥I"¨        var = []
        var.each do |arglist|
          (var << (var.empty? ? (var) : ({ var => (clean_joins(var)) })))
        end
        var
      end
    end
  end
end;Fi[	@ƒi"I"ü        end
        var.each do |arglist|
          var = (var - @var.all(:conditions => (var.conditions)))
        end
        var
      end
    end
  end
end;Fi[	@i-I"{            else
              # do nothing
            end
          end
          var
        end
      end
    end
  end;Fi[	@iŒI"B              (var << { :raw => (var.send("raw_#{prop}") rescue nil), :value => (var.send("#{prop}_without_default") rescue nil), :default => (var.send("default_#{prop}") rescue nil), :resolved => (var.send(var)) })
            end
            var[var] = var
          end
          var
        end
      end
    end
  end;Fi[	@{iÅI"Å            (var << "\n")
          end
        end
      end
      var
    end
  end
end
Compass::Frameworks.discover(:defaults);Fi[	@èiDI"ã      var = (var + ((100 - var) * (var / 100.0)))
    else
      var = (var + ((var * var) / 100.0)) if (var < 0)
    end
    var
  end
end;Fi[	@$i*I"t        else
          (var << stop.inspect)
        end
      end
      var
    end
  end
  
  module Gradient;Fi[	@’i]I"        var = File.basename(var, ".png")
        unless VAILD_FILE_NAME.=~(var) then
          raise(Compass::Error, "Sprite file names must be legal css identifiers. Please rename #{File.basename(file)}")
        end
        var
      end
    end
    
    def self.sass_options(arglist);Fi[	@êi|I"â        var.each do |arglist|
          var ||= ""
          var = var.gsub(var, var)
        end
        var
      end
    end
  end
end;Fi[	@ñijI"Ê            var = var
            var.each do |arglist|
              var = var ? (var.gsub(var, var)) : (nil) if var and var.include?(var)
            end
            var
          end
        end
        Table.new(var)
      end;Fi[	@≠iI"Ê        var = send(var, *var)
      ensure
        InstanceExecHelper.module_eval { |arglist| remove_method(var) } rescue nil
      end
      var
    end
  end
  
  # TODO: Move most of this stuff out to an InstanceExecutor class.;Fi[	@ùikI"Ö        @var.status = var.first
        @var.headers = var.second
        @var.body = var.third
      end
      var
    end
  end
end;Fi[	I"&data//diaspora_proj/models/pod.rb;TiI"Ç    unless var.persisted? then
      var.ssl = (var.scheme == "https") ? (true) : (false)
      var.save
    end
    var
  end
end;Fi[	@UiI"«        var.each do |arglist|
          (var << var)
          (var << (var + [var]))
        end
        var
      end
    end
    
    # Returns information about the caller of the previous method.;Fi[	@∂iLI"K          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@¶i¢I"≠        FileUtils.mkdir_p("tumblr_files")
        File.open(var, "w") { |arglist| var.write(open(var).read) }
        var = ("/" + var)
      end
      var
    end
  end
end;Fi[	@áipI"À        _children.each do |arglist|
          var.process_flagged_destroys
          generate_atomic_updates(var, var)
        end
        var
      end
    end
    
    (alias :_updates :atomic_updates);Fi[	@Ò
iI"§              else
                var.push(Factory.build(klass, var))
              end
            end
            var
          end
        end
      end
    end;Fi[	@|ifI"            if (var.as == name) and (var.class_name == inverse_class_name) then
              var.push(var.name)
            end
          end
          var
        end
      end
      
      # For polymorphic children, we need to figure out the inverse from the;Fi[	@iuI"ñ          end
        else
          raise(ScanError, (("undefined state: '" + state.to_s) + "'"))
        end
        var
      end
    end
  end
end;Fi[	@Ki}I"
        xpath("//namespace::*").inject({}) do |arglist|
          if var.prefix.!=("xml") then
            var[["xmlns", var.prefix].compact.join(":")] = var.href
          end
          var
        end
      end
      
      # Get the list of decorators given +key+;Fi[	@ iI"l        @var = var[2]
        @var = var[3]
        @var = var[4]
      end
      var
    end
  end
end;Fi[	@iOI"?              var = custom_values.detect { |arglist| (var.custom_field == var) }
              var ||= custom_values.build(:customized => (self), :custom_field => (var), :value => (nil))
              var.value = var.value
            end
            var
          end
        end
        
        def function(arglist);Fi[	@<i&I"è                [yield(var), var.id]
              end
            end.compact)
          end
          var
        end
      end
    end
  end;Ti[	I"?data//redmine_proj/plugins/rfpdf/lib/core/image_science.rb;Ti#I"~      end
      var["bits"] = var.depth
      var["bits"] /= var["channels"] if var["channels"]
    end
    var
  end
end;Fi[	@xi±I"r        end
      else
        var = (var + var)
      end
      var
    end
  end
  
  def function(arglist);Fi[	@xi'I"î            var = (var - 1) unless var.zero?
            var = {} if var.zero?
          end
        end
        var
      end
    end
    var
  end;Fi[	@ i¶I"“            var = var[var]
            if var.is_a?(Symbol) then
              var = resolve(var, var, var, var.merge(:scope => (nil)))
            end
            var
          end
        end
      end
      ;Fi[	@…iI"√          if jsonp.present? then
            var = "#{jsonp}(#{json})"
            response.content_type = "application/javascript"
          end
          var
        end
      end
    end
  end;Fi[	@ÁiqI"1              var = @var[$1.to_i]
              if var.match(/<code\s+class="(\w+)">\s?(.+)/m) then
                var = ("<code class=\"#{$1} syntaxhl\">" + Redmine::SyntaxHighlighting.highlight_by_language($2, $1))
              end
              var
            end
          end
        end
      end;Fi[	@l i5I"»          if var = var.index(var) then
            var.delete_at(var)
          end
        end
        var
      end
    end
    
    OperatorMatcher.register(Array, "=~", Spec::Matchers::MatchArray);Fi[	@ i&I"              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end
  end
end;Fi[	@ÿiãI"◊        var.each do |arglist|
          var = var ? (var.to_s) : ("nil")
          (var << var.add_edge(var, (var ? (var) : (var)), :label => (var.to_s)))
        end
        var
      end
    end
    
    protected;Fi[	@Ωi"I"'          if ((var == :state) or ((var == :event) and var)) and var.send("#{self.attribute}_changed?").! then
            var = read(var, :state)
            var.changes[self.attribute.to_s] = [(var == :event) ? (var) : (var), var]
          end
          var
        end
      end
    end
  end;Fi[@(I"@var = var;FI"end;FI" ;Fi0[0[	@iI"B      # table_joins is an array of arel joins which might conflict with the aliases we assign here
      def function(arglist)
        @var = Hash.new { |arglist| var[var] = initial_count_for(var) }
        @var = var
        @var = var
      end
      
      def function(arglist)
        var = aliased_name_for(var, var);Fi[	@ijI"∑      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        return if values.values.compact.empty?;Fi[	@(i|I"Ã        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          return unless frequency;Fi[	@6iI"‡    
    class Table
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.;Fi[	@LiI"œ        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          case config;Fi[	@ri6I"b          # table.  +subtype+ is derived from the `typelem` column in the
          # pg_types table.
          def function(arglist)
            @var = var
            @var = var
          end
          
          # FIXME: this should probably split on +delim+ and use +subtype+
          # to cast the values.  Unfortunately, the current Rails behavior;Fi[	@íiI"≤      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@ûi˚I"µ    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      model_class.name if model_class;Fi[	@ÎiI"◊      
      def function(arglist)
        var.assert_valid_keys(*Relation::VALUE_METHODS)
        @var = var
        @var = var
      end
      
      def function(arglist)
        Merger.new(relation, other).merge;Fi[	@ÑicI"˝        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##
        # Wrapper method for the #send_message (private) method;Fi[	@˝i
I"º    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##
    # This is called as part of the procedure used to build the final;Fi[	@ùiI"Ÿ      # * Called with super(model, storage_id) from each subclass
      def function(arglist)
        load_defaults!
        @var = var
        @var = var
      end
      
      ##
      # Performs the backup transfer;Fi[	@6iI"â    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    ;Fi[	@"iI"Ú    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick
    # specs don't bother to include the arch in the platform string;Fi[	@ºi*I"Ë      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplemented, "This model adapter does not support fetching records from the database.");Fi[	@˜i>I"ﬁ          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist)
            configuration.roles[var].include?(server);Fi[	@OiuI"ø          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist)
            (@var == "highest");Fi[	@iI"      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        (config.http_stylesheets_path or (config.default_for(:http_stylesheets_path) or config.http_root_relative(config.css_dir)));Fi[	@ñiCI"≠        var = var.transpose
        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        dup;Fi[	@ñi◊I"      #   # => ['phone number', 'ADDRESS']
      #
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Returns a new Table where the headers are redefined. See #map_headers!
      def function(arglist);Fi[	@¡iI"æ  module Formatter
    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.uri(var.file);Fi[	@i.I"‘          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist)
          [("\"%s\"" % @var.join(File::PATH_SEPARATOR))];Fi[	@iI"‚      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var.current_world.cucumber_instance_exec(false, var, *[var, var].compact, &@var);Fi[	@è(iI"ôclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = PostPresenter.new(@var, @var);Fi[	@ï(iI"ù  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    as_json(var).to_json;Fi[	@Ô#iI"¡class PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = @var.as_api_response(:backbone).merge(:is_own_profile => (is_own_profile));Fi[	@“i
I"¡  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def self.collection_json(arglist)
    var.map { |arglist| PostPresenter.new(var, var) };Fi[	@“iEI"Send
class PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist)
    { :likes => (as_api(@var.likes)), :reshares => (PostPresenter.collection_json(@var.reshares, @var)), :comments => (CommentPresenter.as_collection(@var.comments)), :participations => (as_api(@var.participations)) };Fi[	@ØiûI"¸  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist)
    var = "#{@name.downcase} cannot be installed alongside #{@formula}.\n";Fi[	I",data//jekyll_proj/jekyll/static_file.rb;TiI"§    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.
    def function(arglist);Fi[	@i5I"ù            else
              @var = var
            end
            @var = var
            @var = var
          end
          
          private
          ;Fi[	@iI"‹      # Get the value of this node
      # Create a new Node with +type+ and +value+
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Accept +visitor+
      def function(arglist);Fi[	@CiÇI"≥      
      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var;Fi[	@MiI"ã    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist)
      # do nothing;Fi[	@ni	I"module Paperclip
  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist)
      escape_url_as_needed(timestamp_as_needed(@var[:interpolator].interpolate(most_appropriate_url, @var, var), var), var);Fi[	@UiˇI"z      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage)
  ;Fi[	@ciÏI"z      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage)
  ;Fi[	@iI"·      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created
      # and #save is called.;Fi[	@€&i	I"∂  module Example
    class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        var.any? do |arglist|;Fi[	@YidI"≈    class BePredicate < Be
      def function(arglist)
        @var = parse_expected(var.shift)
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var = var;Fi[	@”iI"∏      
      def function(arglist)
        @var = (var[:__declared_as] or "Mock")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {};Fi[	@fiI"    module Runner
      class HeckleRunner
        def function(arglist)
          @var = var
          @var = var
        end
        
        # Runs all the example groups held by +rspec_options+ once for each of the
        # methods in the matched classes.;Fi[	I"<data//state_machine_proj/state_machine/helper_module.rb;TiI"Œmodule StateMachine
  class HelperModule < Module
    def function(arglist)
      @var = var
      @var = var
    end
    
    # Provides a human-readable description of the module
    def function(arglist);Fi[@µ @∂ @∑ I"##;Fi/[/[	@√iWI"˘        raise(Errors::Archive::PipelineError, ("Failed to Create Backup Archive\n" + var.error_messages))
      end
    end
    
    private
    
    ##
    # Returns a "tar-ready" string of all the specified paths combined
    def function(arglist);Fi[	@@i	I"}  module CLI
    module Helpers
      UTILITY = {}
      
      private
      
      ##
      # Runs a system command
      #;Fi[	@CiÿI"Ë      def function(arglist)
        puts("Backup #{Backup::Version.current}")
      end
      
      private
      
      ##
      # Helper method for asking the user if he/she wants to overwrite the file
      def function(arglist);Fi[	@FiI"≥        log!
        yield(@var, @var)
      end
      
      private
      
      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist);Fi[	@LiI"«        @var = set_cmd
        @var = set_ext
      end
      
      private
      
      ##
      # Return the command line using the full path.
      # Ensures the command exists and is executable.;Fi[	@`iI"¨        prepare!
        log!
      end
      
      private
      
      ##
      # Defines the @dump_path and ensures it exists by creating it
      def function(arglist);Fi[	@ciMI"£          package! unless var)
        end
      end
      
      private
      
      ##
      # Builds and runs the mongodump command
      def function(arglist);Fi[	@fiII"          raise(Errors::Database::PipelineError, ("#{database_name} Dump Failed!\n" + var.error_messages))
        end
      end
      
      private
      
      ##
      # Builds the full mysqldump string based on all attributes
      def function(arglist);Fi[	@li9I"Œ        invoke_save! if invoke_save
        copy!
      end
      
      private
      
      ##
      # Tells Redis to persist the current state of the
      # in-memory database to the persisted dump file;Fi[	@oi1I"¶          end
        end
      end
      
      private
      
      ##
      # Builds the full riak-admin string based on all attributes
      def function(arglist);Fi[	@uiI"æ      def function(arglist)
        load_defaults!
      end
      
      private
      
      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist);Fi[	@xifI"ü          cleanup
        end
      end
      
      private
      
      ##
      # Remove any temporary directories and reset all instance variables.
      #;Fi[	@{i.I"        log!
        yield("#{utility(:openssl)} #{options}", ".enc")
      end
      
      private
      
      ##
      # Uses the 256bit AES encryption cipher, which is what the
      # US Government uses to encrypt information at the "Top Secret" level.;Fi[	@ÅiAI"≠          notify!(var)
        end
      end
      
      private
      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist);Fi[	@ÑiI"◊        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@ÑilI"&        def function(arglist)
          send_message(var)
        end
        
        private
        
        ##
        # Takes a "message" as argument, the "type" defaults to "Textmessage".
        # This method builds up a POST request with the necessary params (serialized to JSON format);Fi[	@âi1I"ﬁ        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@éipI"◊        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@ëiI"◊        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@îi!I"◊        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@óiI"◊        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:;Fi[	@öiGI"}    def function(arglist)
      @var ||= (((stderr_messages or "") + "The following system errors were returned:\n") + @var.map { |arglist| Errors::Error.wrap(var).message }.join("\n"))
    end
    
    private
    
    ##
    # Each command is added as part of the pipeline, grouped with an `echo`
    # command to pass along the command's index in @commands and it's exit status.;Fi[	@˝iI"ÿ      yield(@var)
      after_packaging
    end
    
    private
    
    ##
    # The `split` command reads from $stdin and will store it's output in
    # multiple files, based on the @chunk_size. The files will be;Fi[	@ùi&I"›        transfer!
        cycle!
      end
      
      private
      
      ##
      # Provider defaults to false. Overridden when using a service-based
      # storage such as Amazon S3, Rackspace Cloud Files or Dropbox;Fi[	@†iI"ÿ        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Cloud Files Storage
      def function(arglist);Fi[	@•i&I"        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # The initial connection to Dropbox will provide the user with an
      # authorization url. The user must open this URL and confirm that the;Fi[	@™i#I"Ω        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #;Fi[	@±iI"÷        instance_eval(&var) if block_given?
        @var = File.expand_path(@var)
      end
      
      private
      
      ##
      # Transfers the archived file to the specified path
      def function(arglist);Fi[	@∂iI"’        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the Ninefold storage
      def function(arglist);Fi[	@ªi%I"–        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # This is the remote path to where the backup files will be stored
      #;Fi[	@æiI"œ        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # This is the provider that Fog uses for the S3 Storage
      def function(arglist);Fi[	@√iI"·        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.;Fi[	@»iI"—        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist);Fi[	@“iTI"@              raise(Errors::Syncer::Cloud::ConfigurationError, "Unknown concurrency_type setting: #{concurrency_type.inspect}")
            end
          end
          
          private
          
          ##
          # Gathers all the relative paths to the local files
          # and merges them with the , removing;Fi[	@“iΩI"ˇ          end
          
          attr_reader :function
          
          private
          
          ##
          # Sanitize string and replace any invalid UTF-8 characters.
          # If replacements are made, flag the LocalFile object as invalid.;Fi[	@ﬂi-I"Ù          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for CloudFiles.
        def function(arglist);Fi[	@‰i$I"Ï          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end
        
        private
        
        ##
        # Established and creates a new Fog storage object for S3.
        def function(arglist);Fi[	@ÈiI"Î          super
          @var ||= Array.new
        end
        
        private
        
        ##
        # Returns the @directories as a space-delimited string of
        # single-quoted values for use in the `rsync` command line.;Fi[	@ÓiI"A          Logger.message(("#{syncer_name} started syncing the following directories:\n  " + @var.join("\n  ")))
          run(("#{utility(:rsync)} #{options} " + "#{directories_option} '#{dest_path}'"))
        end
        
        private
        
        ##
        # Return expanded @path
        def function(arglist);Fi[	@ÛiI"¿            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return expanded @path, since this path is local
        def function(arglist);Fi[	@¯i7I"æ            remove_password_file!
          end
        end
        
        private
        
        ##
        # Return @path with any preceeding "~/" removed
        def function(arglist);Fi[	@–i%I"È    def function(arglist)
      ERB.new(file_contents(var), nil, "<>").result(binding)
    end
    
    private
    
    ##
    # Reads and returns the contents of the provided file path,
    # relative from the Backup::TEMPLATE_PATH;Fi[@'@(@éI"##;Fi.[.[	@√i,I"S        (@var << var)
      else
        Logger.warn(Errors::Archive::NotFoundError.new("          The following path was not found:\n          #{path}\n          This path will be omitted from the '#{name}' Archive.\n"))
      end
    end
    
    ##
    # Adds new paths to the @excludes instance variable array
    def function(arglist);Fi[	@@i,I"V          return var
        else
          raise(Errors::CLI::SystemCallError, "            '#{name}' Failed on #{RUBY_PLATFORM}\n            The following information should help to determine the problem:\n            Command was: #{command}\n            Exit Status: #{ps.exitstatus}\n            STDOUT Messages: #{out.empty? ? ("None") : ("\n#{out}")}\n            STDERR Messages: #{err.empty? ? ("None") : ("\n#{err}")}\n")
        end
      end
      
      ##
      # Returns the full path to the specified utility.
      # Raises an error if utility can not be found in the system's $PATH;Fi[	@ci{I"@          FileUtils.rm_rf(@var)
        else
          raise(Errors::Database::PipelineError, (("#{database_name} Failed to create compressed dump package:\n" + "'#{outfile}'\n") + var.error_messages))
        end
      end
      
      ##
      # Returns the MongoDB database selector syntax
      def function(arglist);Fi[	@iiGI".          Logger.message("#{database_name} Complete!")
        else
          raise(Errors::Database::PipelineError, ("#{database_name} Dump Failed!\n" + var.error_messages))
        end
      end
      
      ##
      # Builds the full pgdump string based on all attributes
      def function(arglist);Fi[	@liCI"•        var = run(("#{redis_cli_utility} #{credential_options} " + "#{connectivity_options} #{user_options} SAVE"))
        unless var =~ /OK/ then
          raise(Errors::Database::Redis::CommandError, "            Could not invoke the Redis SAVE command.\n            The #{database} file might not contain the most recent data.\n            Please check if the server is running, the credentials (if any) are correct,\n            and the host/port/socket are correct.\n\n            Redis CLI response: #{response}\n")
        end
      end
      
      ##
      # Performs the copy command to copy over the Redis dump file to the Backup archive
      def function(arglist);Fi[	@liTI"™          end
        else
          FileUtils.cp(var, var)
        end
      end
      
      ##
      # Returns the Redis database file name
      def function(arglist);Fi[	@xi°I"U          var)
        rescue => var
          raise(Errors::Encryptor::GPG::HomedirError.wrap(var, "Failed to create or set permissions for #gpg_homedir"))
        end
      end
      
      ##
      # Write the given #gpg_config to a tempfile, within a tempdir, and
      # return the file's path to be given to the gpg --options argument.;Fi[	@xiøI"Y        rescue => var
          cleanup
          raise(Errors::Encryptor::GPG::GPGConfigError.wrap(var, "Error creating temporary file for #gpg_config."))
        end
      end
      
      ##
      # Make sure the temporary GnuPG config file created from #gpg_config
      # does not have any syntax errors that would prevent gpg from running.;Fi[	@xiËI"#        else
          Logger.warn("Symmetric encryption options could not be set.")
          # do nothing
        end
      end
      
      ##
      # Create a temporary file, within a tempdir, to hold the :passphrase and
      # return the file's path. If an error occurs, log a warning.;Fi[	@xi¸I"]        rescue => var
          Logger.warn(Errors::Encryptor::GPG::PassphraseError.wrap(var, "Error creating temporary passphrase file."))
          false
        end
      end
      
      ##
      # Process :recipients, importing their public key from :keys if needed,
      # and return the command line options to perform asymmetric encryption.;Fi[	@xi
I"?          # do nothing
        else
          ("-e --trust-model always " + user_recipients.map { |arglist| "-r '#{r}'" }.join(" "))
        end
      end
      
      ##
      # Returns an Array of the public key identifiers the user specified
      # in :recipients. Each identifier is 'cleaned' so that exact matches;Fi[	@xiSI"V        rescue => var
          Logger.warn(Errors::Encryptor::GPG::KeyImportError.wrap(var, "Public key import failed for '#{identifier}'"))
          nil
        end
      end
      
      ##
      # Parse the information for all the public keys found in the public
      # keyring (based on #gpg_homedir setting) and return an Array of all;Fi[	@˝i5I"1        FileUtils.mv(File.join(Config.tmp_path, (@var.basename + "-aa")), File.join(Config.tmp_path, @var.basename))
      else
        @var.chunk_suffixes = var
      end
    end
    
    ##
    # Returns an array of suffixes for each chunk, in alphabetical order.
    # For example: [aa, ab, ac, ad, ae];Fi[	@†i6I"?          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@•i=I"˚          @var = DropboxClient.new(var, access_type))
        rescue => var
          raise(Errors::Storage::Dropbox::ConnectionError.wrap(var))
        end
      end
      
      ##
      # Attempt to load a cached session
      def function(arglist);Fi[	@•iXI"2          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@™i5I"        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@™iBI"a            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@™iQI"            var.delete(File.join(var, var))
          end
          var.rmdir(var)
        end
      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::FTP does not support;Fi[	@±i!I"+          var = File.join(local_path, var)
          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@∂i>I"4          File.open(File.join(local_path, var), "r") do |arglist|
            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@ªi5I"      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@ªiJI"∑          end)
        ensure
          remove_password_file! unless local
        end
      end
      
      ##
      # Note: Storage::RSync doesn't cycle
      def function(arglist);Fi[	@ªi[I"          FileUtils.mkdir_p(var)
        else
          connection { |arglist| var.exec!("mkdir -p '#{remote_path}'") }
        end
      end
      
      ##
      # Writes the provided password to a temporary file so that
      # the rsync utility can read the password from this file;Fi[	@ªifI"˜          @var = Tempfile.new("backup-rsync-password")
          @var.write(password)
          @var.close
        end
      end
      
      ##
      # Removes the previously created @password_file
      # (temporary file containing the password);Fi[	@æi9I"<          File.open(File.join(local_path, var), "r") do |arglist|
            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@√i)I"      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@√i6I"i            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@»i'I"      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist);Fi[	@»i4I"e            Logger.message(("#{storage_name} started transferring " + "'#{local_file}' to '#{ip}'."))
            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling;Fi[	@»iCI"            var.remove!(File.join(var, var))
          end
          var.rmdir!(var)
        end
      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::SFTP does not support;Fi[	@¯iaI"            @var = Tempfile.new("backup-rsync-password")
            @var.write(@var)
            @var.close
          end
        end
        
        ##
        # Removes the previously created @password_file
        # (temporary file containing the password);Fi[	@–iI"ª        else
          @var = nil
        end
      end
    end
    
    ##
    # Renders the provided file (in the context of the binding if any) to the console
    def function(arglist);Fi[	@oi&I"ï          var.delete(var.object_id) if var
        end
      end
    end
  end
  
  ##
  # Creates a new connection for +uri+
  def function(arglist);Fi[	@oiTI"      var = (var.proxy_address or var.address)
      var = (var.proxy_port or var.port)
      raise(Error, "host down: #{address}:#{port}")
    end
  end
  
  ##
  # Returns an error message containing the number of requests performed on
  # this connection;Fi[	@oiíI"ö      else
        Net::HTTP::Persistent::SSLReuse
      end
    end
  end
  
  ##
  # Returns the HTTP protocol version for +uri+
  def function(arglist);Fi[	@oi£I"ñ      true
    else
      # do nothing
    end
  end
  
  ##
  # Is the request idempotent or is retry_change_requests allowed
  def function(arglist);Fi[	@oi¬I"ø    # 1.8
    def function(arglist)
      (var["connection"] =~ /keep-alive/ or var["proxy-connection"] =~ /keep-alive/)
    end
  end
  
  ##
  # Deprecated in favor of #expired?
  # :nodoc:;Fi[	@oiXI".      raise(Error, "connection refused: #{connection.address}:#{connection.port}")
    rescue Errno::EHOSTDOWN
      raise(Error, "host down: #{connection.address}:#{connection.port}")
    end
  end
  
  ##
  # Makes a request on +uri+.  If +req+ is nil a Net::HTTP::Get is performed
  # against +uri+.;Fi[	@oiÕI"ª      var = OpenSSL::X509::Store.new
      var.set_default_paths
      var
    end
  end
  
  ##
  # Finishes all connections that existed before the given SSL parameter
  # +generation+.;Fi[	@oi›I"†    def function(arglist)
      @var = var
      reconnect_ssl
    end
  end
  
  ##
  # Sets the HTTPS verify mode.  Defaults to OpenSSL::SSL::VERIFY_PEER.
  #;Fi[@‹.I"
super;FI"end;FI"end;Fi,[,[	@ijI"˝        def function(arglist)
          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist);Fi[	@ivI"Â        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist);Fi[	@iÅI"“        def function(arglist)
          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end;Fi[	@"i)I"I          if create_time_zone_conversion_attribute?(var, columns_hash[var]) then
            var, var = "              def #{attr_name}=(original_time)\n                original_time = nil if original_time.blank?\n                time = original_time\n                unless time.acts_like?(:time)\n                  time = time.is_a?(String) ? Time.zone.parse(time) : time.to_time rescue time\n                end\n                zoned_time   = time && time.in_time_zone rescue nil\n                rounded_time = round_usec(zoned_time)\n                rounded_value = round_usec(read_attribute(\"#{attr_name}\"))\n                if (rounded_value != rounded_time) || (!rounded_value && original_time)\n                  write_attribute(\"#{attr_name}\", original_time)\n                  #{attr_name}_will_change!\n                  @attributes_cache[\"#{attr_name}\"] = zoned_time\n                end\n              end\n", (52 + 1)
            generated_attribute_methods.module_eval(var, "(string)", var)
          else
            super
          end
        end
        
        private;Fi[	@Ii=I"•            :integer
          when /bit/i then
            :binary
          else
            super
          end
        end
        
        def function(arglist);Fi[	@Ii[I"            1
          when /^enum\((.+)\)/i then
            $1.split(",").map { |arglist| (var.strip.length - 2) }.max
          else
            super
          end
        end
        
        # MySQL misreports NOT NULL column default when none is given.;Fi[	@IiI"≈          else
            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      
      def function(arglist);Fi[	@IieI"æ          RecordNotUnique.new(var, var)
        when 1452 then
          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist);Fi[	@biI"ƒ            (-1.0 / 0.0)
          when / BC$/ then
            super(("-" + var.sub(/ BC$/, "")))
          else
            super
          end
        end
        
        def function(arglist);Fi[	@ki0I"–            if var then
              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        ;Fi[	@uiQI"ñ            else
              super
            end
          else
            super
          end
        end
        
        def function(arglist);Fi[	@ÉiNI"?            else
              raise(ActiveRecordError, "No range type has byte size #{limit}. Use a numeric with precision 0 instead.")
            end
          else
            super
          end
        end
        
        # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.;Fi[	@çi∆I"!        if var.kind_of?(String) and (var and ((var.type == :binary) and var.class.respond_to?(:string_to_binary))) then
          var = var.class.string_to_binary(var).unpack("H*")[0]
          "x'#{s}'"
        else
          super
        end
      end
      
      def function(arglist);Fi[	@çiÿI"Ã      def function(arglist)
        if var.respond_to?(:usec) then
          "#{super}.#{sprintf("%06d", value.usec)}"
        else
          super
        end
      end
      
      def function(arglist);Fi[	@çiI"∑        case var.message
        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end;Fi[	@•i|I"ÿ      def function(arglist)
        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist);Fi[	@⁄iI"Õ          var = ActiveRecord::LogSubscriber.reset_runtime
          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end
      end
      
      def function(arglist);Fi[	@‚i:I"‡            if arel.respond_to?(var) then
              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end;Fi[	@XijI"≈        if var then
          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end;Fi[	@˝i6I"«        else
          puts(File.read("#{root}/#{command}.txt"))
        end
      else
        super
      end
    end
    
    desc("init", "Generates a Gemfile into the current working directory");Fi[	@"i4I"∏    def function(arglist)
      if Gem::Specification.new.respond_to?(var) then
        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	@iI",      var, var = Thor::Util.find_class_and_task_by_namespace(var)
      self.class.handle_no_task_error(var, false) if var.nil?
      var.start(["-h", var].compact, :shell => (self.shell))
    else
      super
    end
  end
  
  # If a task is not found on Thor::Runner, method missing is invoked and;Fi[	@ßitI"˙          var = File.binread(var).to_s.split("\n")
          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist);Fi[	@¨ibI"˙          var = File.binread(var).to_s.split("\n")
          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist);Fi[	@˜iPI"ﬁ            else
              if configuration.respond_to?(var) then
                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end;Fi[	@åi,I"        def function(arglist)
          if configuration.respond_to?(var) then
            configuration.send(var, *var, &var)
          else
            super
          end
        end
        
        # A wrapper for Kernel#system that logs the command being executed.;Fi[	@$iûI"    def function(arglist)
      if ["owg", "svg"].include?(var) and (position_or_angle.is_a?(Sass::Script::Number) and position_or_angle.numerator_units.include?("deg")) then
        false
      else
        super
      end
    end
    
    # Output the original webkit gradient syntax;Fi[	@íi]I"æ        else
          if lock_strategy_enabled?(:failed_attempts) and attempts_exceeded? then
            :locked
          else
            super
          end
        end
      end
      ;Fi[	@Â	iCI"Ì          raise(Errors::MultiparameterAssignmentErrors.new(var), "#{errors.size} error(s) on assignment of multiparameter attributes")
        end
        super(var, var, var)
      else
        super
      end
    end
    
    protected;Fi[	@‰iI"÷        var = var.fields[var.to_s]
        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end;Fi[	@Ki…I"Â        if var.is_a?(XML::NodeSet) then
          raise("Document cannot have multiple root nodes") if (var.size > 1)
          super(var.first)
        else
          super
        end
      end
      
      alias :<< :add_child;Fi[	@5iI"∏        end
        var = Time.now.strftime("%y%m%d")
        var = "#{prefix}#{t}-#{$$}-#{rand(4294967296).to_s(36)}-#{n}#{suffix}"
      else
        super
      end
    end
  end
  ;Fi[	@’iI"Ú        def function(arglist)
          if (var.size == 1) and var.first.is_a?(::Time) then
            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist);Fi[	@îi≥I"          @var[((var == :around) ? (:before) : (var))].insert(-2, (var = Callback.new(var, var, &var)))
          add_states(var.known_states)
          var
        else
          super
        end
      end
      
      # Configures new states with the built-in humanize scheme;Fi[	@ûi>I"      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@∫i7I"      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@¬i;I"      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action;Fi[	@≈iI"≤        def function(arglist)
          if (action == :save) then
            define_helper(:instance, "              def #{action_hook}(*)\n                yielded = false\n                result = self.class.state_machines.transitions(self, :save).perform do\n                  yielded = true\n                  super\n                end\n                \n                if yielded || result\n                  result\n                else\n                  #{handle_save_failure}\n                end\n              end\n", "(string)", (63 + 1))
          else
            super
          end
        end
        def function(arglist)
          (action == :save) ? (:_save) : (super);Fi[	@ÿiÀI"Ë        if skip_after and success? then
          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    
    # Tracks that before callbacks have now completed;Fi[@V.@W.@–3I"end;Fi,[,[	@†i7I"¿          when :nullify then
            target.update_columns(reflection.foreign_key => (nil))
          else
            # do nothing
          end
        end
      end
      
      private;Fi[	@˜iâI"}        when :belongs_to then
          BelongsTo
        else
          # do nothing
        end
      end
    end
  end
end;Fi[	@kiPI"⁄              when /^-?\D+[\d.]+,\d{2}$/ then
                var.gsub!(/[^-\d,]/, "").sub!(/,/, ".")
              else
                # do nothing
              end
            end
          end
        end
        ;Fi[	@ûiæI"í                end)
              end
            else
              # do nothing
            end
          end
        end
        var
      end;Fi[	@'iÀI"ì      when :update then
        (transaction_record_state(:new_record) or destroyed?).!
      else
        # do nothing
      end
    end
  end
end;Fi[	@™icI"¢          begin
            var.mkdir(var.join("/"))
          rescue Net::FTPPermError
            # do nothing
          end
        end
      end
    end
  end;Fi[	@»iUI"¨          begin
            var.mkdir!(var.join("/"))
          rescue Net::SFTP::StatusException
            # do nothing
          end
        end
      end
    end
  end;Fi[	@i0i)I"P    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"0data//bundler_proj/bundler/gem_installer.rb;Ti	I"xmodule Bundler
  class GemInstaller < Gem::Installer
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	I"/data//bundler_proj/bundler/psyched_yaml.rb;Ti
I"  begin
    gem("psych")
  rescue LoadError
    # do nothing
  end
  end
end
begin
  require("psych") unless defined? Syck;Fi[	@åiI"©        [:force, :skip, "force", "skip"].each { |arglist| var.delete(var) }
        var.merge!(var => (true))
      else
        # do nothing
      end
    end
  end
end;Fi[	@ôiLI"o      when :array then
        "one two three"
      else
        # do nothing
      end
    end
  end
end;Fi[	@
iI"Ü          when "a" then
            exit(-1)
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[	@iéI"›          begin
            sessions.delete(var).close
          rescue IOError
            # do nothing
          end
        end
      end
      
      # Determines the set of servers within the current task's scope and;Fi[	@¬i¿I"g      when :scp then
        var.close
      else
        # do nothing
      end
    end
  end
end;Fi[	@Œi?I"ú            $stdout = self.new($stdout)
            return $stdout
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[	@ÍiTI"Ç      render(:layout => (true))
    else
      if render(:layout => (false)) then
        # do nothing
      end
    end
  end
end;Fi[	@dipI"ä      when "open-mpi", "mpich2" then
        problem("          There are multiple conflicting ways to install MPI. Use an MPIDependency:\n            depends_on MPIDependency.new(<lang list>)\n          Where <lang list> is a comma delimited list that can include:\n            :cc, :cxx, :f90, :f77\n".undent)
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@diŒI"Œ      when /macports\/trunk/ then
        problem("MacPorts patches should specify a revision instead of trunk:\n#{p.url}")
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@giI"Ô          begin
            cleanup_formula(var.basename.to_s) if var.directory?
          rescue FormulaUnavailableError => var
            # do nothing
          end
        end
      end
      clean_cache
      unless ARGV.dry_run? then;Fi[	@ti,I"u      when "LinkedKegs", "Aliases" then
        true
      else
        # do nothing
      end
    end
  end
end;Fi[	@£iΩI"|      when ".7z" then
        :p7zip
      else
        # do nothing
      end
    end
  end
  
  def function(arglist);Fi[	@ØiBI"ç    when :ruby then
      "gem install"
    else
      # do nothing
    end
  end
end
class X11Dependency < Requirement
  include(Comparable);Fi[	@‚itI"y      when "maruku" then
        Maruku.new(var).to_html
      else
        # do nothing
      end
    end
  end
end;Fi[	@m%i+I"ê        when Array then
          var = var[var].compact
        else
          # do nothing
        end
      end
    end
    (var or [])
  end;Fi[	I"'data//jekyll_proj/jekyll/plugin.rb;Ti'I"g    #
    # Returns a new instance.
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@ui	I"Ä  module XML
    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@}imI"¬        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@1 iàI"ë    when OpenID::Consumer::SETUP_NEEDED then
      yield(Result[:setup_needed], var.setup_url, nil)
    else
      # do nothing
    end
  end
end;Fi[	@ÄihI"          begin
            return Iconv.conv("UTF-8", var, var)
          rescue Iconv::Failure
            # do nothing
          end
        end
      end
      var = self.replace_invalid_utf8(var)
      var.force_encoding("UTF-8") if var.respond_to?(:force_encoding);Fi[	@≥iII"∑              (@var << "#{date_from.to_date}")
              var = (var + 1.day)
            else
              # do nothing
            end
          end
        end
      end
      ;Fi[	@i8I"e      end
      
      def self.remove(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@4iMI"f        end
      else
        Kernel.sleep(var)
        # do nothing
      end
    end
  end
end;Fi[	@%iêI"‘        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@/iI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@4iI"v        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	@CiI"z        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end
end;Fi[	I"Pdata//state_machine_proj/state_machine/integrations/active_record/locale.rb;TiI"ﬁ  begin
    require("i18n/version")
  rescue Exception => var
    # do nothing
  end
  end
end
if (defined? I18n::VERSION.! or (I18n::VERSION < "0.4.0")) then
  var[:en][:activerecord][:errors][:messages].each do |arglist|;Fi[	@ˇi*I"ã              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end
    end
  end;Fi[@	)I"
false;FI"end;FI" ;Fi,[,[	@}i¨I"q      #
      # Currently implemented by belongs_to (vanilla and polymorphic) and
      # has_one/has_many :through associations which go through a belongs_to
      def function(arglist)
        false
      end
      
      # Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of
      # the kind of the class of the associated objects. Meant to be used as;Fi[	@0iwI"       
      # Returns +true+ when the connection adapter supports prepared statement
      # caching, otherwise returns +false+
      def function(arglist)
        false
      end
      
      # Runs the given block in a database transaction, and returns the result
      # of the block.;Fi[	@CiI"Ç        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false;Fi[	@Ci I"∞        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions
      def function(arglist);Fi[	@CimI"Ä        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true;Fi[	@FilI"Q      
      # Does this adapter support migrations? Backend specific, as the
      # abstract adapter always returns +false+.
      def function(arglist)
        false
      end
      
      # Can this adapter determine the primary key for tables not attached
      # to an Active Record class, such as join tables? Backend specific, as;Fi[	@FisI"}      # Can this adapter determine the primary key for tables not attached
      # to an Active Record class, such as join tables? Backend specific, as
      # the abstract adapter always returns +false+.
      def function(arglist)
        false
      end
      
      # Does this adapter support using DISTINCT within COUNT? This is +true+
      # for all adapters except sqlite.;Fi[	@Fi{I"L      # Does this adapter support DDL rollbacks in transactions? That is, would
      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false;Fi[	@FiI"¡        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,
      # SQLite < 3.6.8 does not.;Fi[	@FiÖI";      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,
      # SQLite < 3.6.8 does not.
      def function(arglist)
        false
      end
      
      # Should primary key values be selected from their corresponding
      # sequence before the insert statement? If true, next_sequence_value;Fi[	@FiçI"P      # sequence before the insert statement? If true, next_sequence_value
      # is called before each insert to set the record's primary key.
      # This is false for all adapters but Firebird.
      def function(arglist)
        false
      end
      
      # Does this adapter support index sort order?
      def function(arglist);Fi[	@FiíI"Œ      end
      
      # Does this adapter support index sort order?
      def function(arglist)
        false
      end
      
      # Does this adapter support partial indices?
      def function(arglist);Fi[	@FióI"ˇ      end
      
      # Does this adapter support partial indices?
      def function(arglist)
        false
      end
      
      # Does this adapter support explain? As of this writing sqlite3,
      # mysql2, and postgresql are the only ones that do.;Fi[	@FiùI"/      
      # Does this adapter support explain? As of this writing sqlite3,
      # mysql2, and postgresql are the only ones that do.
      def function(arglist)
        false
      end
      
      # Does this adapter support setting the isolation level for a transaction?
      def function(arglist);Fi[	@Fi¢I".      end
      
      # Does this adapter support setting the isolation level for a transaction?
      def function(arglist)
        false
      end
      
      # QUOTING ==================================================
      # Returns a bind substitution value given a +column+ and list of current;Fi[	@Fi›I"¥      
      # Returns true if its required to reload the connection between requests for development mode.
      # This is not the case for Ruby/MySQL and it's not necessary for any adapters except SQLite.
      def function(arglist)
        false
      end
      
      # Checks whether the connection to the database is still active (i.e. not stale).
      # This is done under the hood by calling <tt>active?</tt>. If the connection;Fi[	@B)i#I"u      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false;Fi[	@B)i'I"|      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= "";Fi[	@ﬂiÚI"“        [self]
      end
      
      def function(arglist)
        false
      end
      
      # An array of arrays of scopes. Each item in the outside array corresponds to a reflection
      # in the #chain.;Fi[	@ùi,I"'      ##
      # Provider defaults to false. Overridden when using a service-based
      # storage such as Amazon S3, Rackspace Cloud Files or Dropbox
      def function(arglist)
        false
      end
      
      ##
      # Each subclass must define a +path+ where remote files will be stored;Fi[	@gi I"Å      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI
      attr_writer(:shell);Fi[	@±iI"Ò      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    
    # By default, a task invokes a method in the thor class. You can change this
    # implementation to create custom tasks.;Fi[	@i9I"ª        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "#{options[:pattern_name]}/" if options[:pattern_name];Fi[	@äiI"©      attr_reader(:line)
      
      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          [];Fi[	@êiI"ç        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped;Fi[	@–iI"»      end
      
      # Do not use remember_me behavior with token.
      def function(arglist)
        false
      end
      
      # Try both scoped and non scoped keys.
      def function(arglist);Fi[	@ài2I"º    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join(";");Fi[	@ÿ#iwI"π  end
  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false;Fi[	@ÿ#i{I"~    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("notifier.a_post_you_shared");Fi[	@UiMI"     # Overridden in haml/template.rb if this is the case.
    #
    # @return [Boolean]
    def function(arglist)
      false
    end
    
    # Returns the given text, marked as being HTML-safe.
    # With older versions of the Rails XSS-safety mechanism,;Fi[	@Z	iZI"–      # @return [ true, false ] If the object is blank criteria.
      #
      # @since 3.1.0
      def function(arglist)
        false
      end
      
      # Do or do not, there is no try. -- Yoda.
      #;Fi[	@Z	iêI"†      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Is the object a number?
      #;Fi[	@Z	iúI"√      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Remove the instance variable for the provided name.
      #;Fi[	@Z	iªI"¥      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Get the substitutable version of an object.
      #;Fi[	@ó	iFI"Ë      # @return [ true, false ] If the field is a foreign key.
      #
      # @since 2.4.0
      def function(arglist)
        false
      end
      
      # Create the new field with a name and optional additional options.
      #;Fi[	@ó	ifI"º      # @return [ true, false ] If the field is lazy.
      #
      # @since 3.1.0
      def function(arglist)
        false
      end
      
      # Is the field localized or not?
      #;Fi[	@ó	irI"◊      # @return [ true, false ] If the field is localized.
      #
      # @since 2.3.0
      def function(arglist)
        false
      end
      
      # Get the metadata for the field if its a foreign key.
      #;Fi[	@vi{I"”      # @return [ false ] Always false.
      #
      # @since 2.0.0
      def function(arglist)
        false
      end
      
      # Since method_missing is overridden we should override this as well.
      #;Fi[	@îiEI"O      # Do validations run when the action configured this machine is
      # invoked?  This is used to determine whether to fire off attribute-based
      # event transitions when the action is run.
      def function(arglist)
        false
      end
      
      # Gets the terminator to use for callbacks
      def function(arglist);Fi[@µ @°+@K1I"end;Fi*[*[	@Ci	I"ù  module ConnectionAdapters
    class Transaction
      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    ;Fi[	@riDI"æ        
        class Array < Type
          attr_reader(:subtype)
          
          def function(arglist)
            @var = var
          end
          
          def function(arglist);Fi[	I"4data//activerecord_proj/active_record/errors.rb;TiaI"ó  
  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  ;Fi[	@õiI"∂        ActiveRecord::Base.connected? ? (connection.uncached(&var)) : (yield)
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@iI"⁄      ACCESS_DENIED_ERROR = 1045
      
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@!iI"	      DEFAULT_ENCODING = (ENV["CHARSET"] or "utf8")
      
      delegate(:connection, :establish_connection, :clear_active_connections!, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@6iAI"å        eval(File.read(local_specification_path))
      end
    end
    
    def function(arglist)
      @var = var
    end
    
    private;Fi[	@iI"∑      var = new(var)
      var.inject(Bundler.default_gemfile, Bundler.default_lockfile)
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@ÉiäI"∆        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end
        
        # Returns true if one or more steps failed;Fi[	@ÊirI"é        @var = 6
        @var = 6
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@Èi0I"ï        progress(var)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@=iI"Æ      
      class StepInvoker
        include(Gherkin::Rubify)
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist);Fi[	@KiI"è      end
      
      include(WireProtocol)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@niI"∆        include(Devise::Controllers::Rememberable)
        
        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      ;Fi[	@qiI"º        def function(arglist)
          defined? @var ? (@var) : (Devise.scoped_views)
        end
        
        def function(arglist)
          @var = var
        end
      end
    end;Fi[	@XiI"oclass Caveats
  attr_reader(:f)
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Ui-I"â      "No available formula for #{name} #{dependent_s}"
    end
  end
  
  def function(arglist)
    @var = var
  end
end
module Homebrew;Fi[	@Â	iI"»      
      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError
        attr_reader(:errors)
        
        def function(arglist)
          @var = var
        end
      end
    end;Fi[	@´(iI"ç    def self.call(arglist)
      new(var).call
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@
 i
I"Æ    EMPTY_TYPE = "inode/x-empty"
    
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@ iI"¿module Paperclip
  class FileCommandContentTypeDetector
    SENSIBLE_DEFAULT = "application/octet-stream"
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@ iI"ªmodule Paperclip
  class GeometryParser
    FORMAT = /\b(\d*)x?(\d*)\b(?:,(\d?))?([\>\<\#\@\%^!])?/i
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@∑(iI"≤    def function(arglist)
      @var ||= (options[:logger] or ::Logger.new(STDOUT))
    end
    
    def function(arglist)
      @var = var
    end
    
    def function(arglist);Fi[	@1 i2I"Ü    def self.[](arglist)
      new(var)
    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function;Fi[	@UiàI"ç    @var = var
    @var = var if (@var > 0) and (@var < var)
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@UiåI"|  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@UißI"°      raise(("Incorrect layout display mode: " + var)) if var.!=("zoom")
    end
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Ui´I"|  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@UiØI"|  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Ui≥I"|  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@Ui∑I"|  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@UiªI"|  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@UiøI"|  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    @var = var
  end
  
  def function(arglist);Fi[	@YiI"ß  module Matchers
    class Be
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@l i	I"Ø  module Matchers
    class MatchArray
      include(Spec::Matchers::Pretty)
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@€iVI"õ      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var
      end
      
      def function(arglist);Fi[	@*iI"ú          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end
        
        def function(arglist);Fi[@µ @ÿ/I" ;FI"def function(arglist);Fi)[)[	@0i·I"Ü          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.open?
      end;Fi[	@Ci6I"∂        @var = false
        @var = var.fetch(:joinable, true)
      end
      
      attr_reader :function
      
      def function(arglist)
        @var and finishing?.!
      end;Fi[	@FiÁI"´      def function(arglist)
        reconnect! unless active?
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.number
      end;Fi[	@iQI"ü      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("database" => (nil))
      end;Fi[	@!iGI"¶      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["encoding"] or DEFAULT_ENCODING)
      end;Fi[	@ ioI"∫    def function(arglist)
      (@var - specs)
    end
    
    attr_reader :function
    
    def function(arglist)
      var = []
      resolve.materialize(requested_dependencies, var);Fi[	@Ji´I"ª      def function(arglist)
        cached_revision and super
      end
      
      attr_reader :function
      
      def function(arglist)
        allow_git_ops? and local?.!
      end;Fi[	@giBI"•      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.!.! and @var.!
      end;Fi[	@üi6I"         var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist)
      return super unless @var
      var = super;Fi[	@˜i$I"≤        def function(arglist)
          options[:last]
        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end;Fi[	@JiXI"Æ        @var = var
        self
      end
      
      attr_reader :function
      
      def function(arglist)
        var = @var.dup
        (var << " (#{@hosts})") if @var;Fi[	@¬iUI"«    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("#{transport} #{operation} #{from} -> #{to}") if logger
      @var = sessions.map do |arglist|;Fi[	@)iI"“      def function(arglist)
        @var ||= DEAFULT_PROJECT_TYPES.dup
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.keys.===(DEAFULT_PROJECT_TYPES.keys)
      end;Fi[	@iiJI"√      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
      end
      
      attr_reader :function
      
      def function(arglist)
        (@var.first or self)
      end;Fi[	@ñiÇI"∂      def function(arglist)
        cells_rows[0][var]
      end
      
      attr_reader :function
      
      def function(arglist)
        columns[var].__send__(:width)
      end;Fi[	@¨iÎI"´          end
        end
      end
      
      attr_reader :function
      
      def function(arglist)
        if @var then
          @var.puts("Disabling profiles...");Fi[	@i=I"«      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.current_world.execute(@var)
      end;Fi[	@iYI"ù      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end;Fi[	@ióI"÷      def function(arglist)
        add_transform(JsTransform.new(self, var, var))
      end
      
      attr_reader :function
      
      def function(arglist)
        @var.invoke_steps(var, @var, var)
      end;Fi[	@0iI"°  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == var.hash_type) and (@var == var.hexdigest)
  end;Fi[	@îiøI"Ô    @var = (@var + "-HEAD") if ARGV.include?("--HEAD")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.sub!(/^svn\+/, "") if @var =~ /^svn\+http:\/\//
    ohai("Checking out #{@url}");Fi[	@îiI"·    @var = "#{name}--git" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var.!=(:revision) and host_supports_depth?
  end;Fi[	@îifI"Î    @var = "#{name}--cvs" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    ohai("Checking out #{@url}")
    var, var = split_url(@var);Fi[	@îiëI";    @var = "#{name}--hg" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|
      File.executable?(var);Fi[	@îiªI"    @var = "#{name}--bzr" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|
      File.executable?(var);Fi[	@îi€I"!    @var = "#{name}--fossil" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|
      File.executable?(var);Fi[	@ÄivI"{      true
    end
  end
  
  attr_reader :function
  
  def function(arglist)
    case @var
    when :provided_by_osx then;Fi[	@ˆi4I"~    @var = var.to_s
    @var = var
  end
  
  attr_reader :function
  
  def function(arglist)
    (@var == "HEAD")
  end;Fi[	@UiI"‹  def function(arglist)
    # do nothing
  end
  
  attr_reader :function
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f G", (var / 255.0));Fi[	@Ui·I"‘    var = (((("q " + @var) + " ") + var) + " Q") if @var
    out(var)
  end
  
  attr_reader :function
  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true;Fi[	@UiÌI"—    @var = @var
    var.kind_of?(String) ? (@var = (@var + @var)) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var))
  end;Fi[	@UiÛI"œ  def function(arglist)
    (var >= 0) ? (@var = var) : (@var = (@var + var))
  end
  
  attr_reader :function
  
  def function(arglist)
    @var = @var
    (var >= 0) ? (@var = var) : (@var = (@var + var));Fi[	@æiI"P          @var = with_trailling_slash(var)
          @var = var.blank? ? ("UTF-8") : (var)
        end
        
        attr_reader :function
        
        def function(arglist)
          var = var ? (with_leading_slash(var)) : (without_leading_slash(var))
          var ? (with_trailling_slash(var)) : (without_trailling_slash(var));Fi[	@7ikI"ì      @var.srem(:queues, @var)
      @var = true
    end
    
    attr_reader :function
    
    def function(arglist)
      @var.dump(var)
    end;Fi[	@9iI"∂        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist)
          @var = var
          @var.puts(html_header);Fi[	@qi}I"«      def function(arglist)
        Spec::Example::BeforeAndAfterHooks.after_suite_parts
      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end;Fi[I"module Homebrew;FI"extend(self);FI" ;FI"def function(arglist);Fi([([	I"'data//homebrew_proj/cmd/--cache.rb;Ti I"wmodule Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CACHE);Fi [	I"(data//homebrew_proj/cmd/--cellar.rb;Ti I"xmodule Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CELLAR);Fi [	@ÔiI"êrequire("hardware")
module Homebrew
  extend(self)
  
  def function(arglist)
    (ARGV.first == "-1") ? (dump_c1) : (dump_verbose_config)
  end;Fi[	@ˆiI"–require("superenv")
require("hardware")
module Homebrew
  extend(self)
  
  def function(arglist)
    ENV.deps = ARGV.formulae.map(&:name) unless ARGV.named.empty? if superenv?
    ENV.setup_build_environment;Fi[	I"(data//homebrew_proj/cmd/--prefix.rb;Ti I"xmodule Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_PREFIX);Fi [	I",data//homebrew_proj/cmd/--repository.rb;Ti I"bmodule Homebrew
  extend(self)
  
  def function(arglist)
    puts(HOMEBREW_REPOSITORY)
  end;Fi [	@diI"ârequire("formula")
require("utils")
require("superenv")
module Homebrew
  extend(self)
  
  def function(arglist)
    var = 0
    var = 0;Fi[	@iI"ƒrequire("formula")
require("bottles")
require("tab")
module Homebrew
  extend(self)
  
  def function(arglist)
    unless var.installed? then
      return ofail("Formula not installed: #{f.name}");Fi[	I"#data//homebrew_proj/cmd/cat.rb;Ti I"çmodule Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    cd(HOMEBREW_REPOSITORY);Fi [	@gi	I"∑require("keg")
require("bottles")
require("cmd/prune")
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      if HOMEBREW_CELLAR.directory? then;Fi[	@niI"Â    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--all") then
      Formula.each { |arglist| puts("#{f.name}: #{(f.deps * " ")}") };Fi[	@qi I"Émodule Homebrew
  extend(self)
  
  def function(arglist)
    var = Pathname.getwd
    var = if ARGV.include?("--set-version") then;Fi [	@tiI"Frequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    unless (HOMEBREW_REPOSITORY / ".git").directory? then
      raise("        Changes will be lost!\n        The first time you `brew update', all local changes will be lost, you should\n        thus `brew update' before you `brew edit'!\n".undent);Fi[	@wiI"®require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("--deps") then;Fi[	I"$data//homebrew_proj/cmd/help.rb;TiI";HOMEBREW_HELP = "Example usage:\n  brew install FORMULA...\n  brew uninstall FORMULA...\n  brew search [foo]\n  brew list [FORMULA...]\n  brew update\n  brew upgrade [FORMULA...]\n  brew [info | home] [FORMULA...]\n\nTroubleshooting:\n  brew doctor\n  brew install -vd FORMULA\n  brew [--env | --config]\n\nBrewing:\n  brew create [URL [--no-fetch]]\n  brew edit [FORMULA...]\n  open https://github.com/mxcl/homebrew/wiki/Formula-Cookbook\n\nFurther help:\n  man brew\n  brew home\n"
module Homebrew
  extend(self)
  
  def function(arglist)
    puts(HOMEBREW_HELP)
  end;Fi[	I"$data//homebrew_proj/cmd/home.rb;Ti I"}module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      exec_browser(HOMEBREW_WWW);Fi [	@i	I"¶require("tab")
require("keg")
require("caveats")
module Homebrew
  extend(self)
  
  def function(arglist)
    (ARGV.json == "v1") ? (print_json) : (print_info)
  end;Fi[	@iI"€require("formula_installer")
require("hardware")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("--head") then;Fi[	I"#data//homebrew_proj/cmd/irb.rb;TiI"∑    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--help") then
      puts("'v8'.f # => instance of the Ack formula");Fi[	@XiI"Ãrequire("ostruct")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(KegUnspecifiedError) if ARGV.named.empty?
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then;Fi[	@zi I"êmodule Homebrew
  extend(self)
  
  def function(arglist)
    list_unbrewed if ARGV.flag?("--unbrewed")
    return unless HOMEBREW_CELLAR.exist?;Fi [	I"#data//homebrew_proj/cmd/log.rb;Ti I"zmodule Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      cd(HOMEBREW_REPOSITORY);Fi [	@Ù#iI"árequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    var = []
    HOMEBREW_CELLAR.subdirs.each do |arglist|;Fi[	@&iI"É    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    ff.each do |arglist|
      next if var.build.empty?;Fi[	@)iI"≤require("formula")
require("keg")
module Homebrew
  extend(self)
  
  def function(arglist)
    outdated_brews do |arglist|
      if $stdout.tty? and ARGV.flag?("--quiet").! then;Fi[	@iI"›require("formula")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--macports") then
      exec_browser("http://www.macports.org/ports.php?by=name&substr=#{ARGV.next}");Fi[	I""data//homebrew_proj/cmd/sh.rb;TiI"ãrequire("superenv")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    if superenv? then
      ENV.x11 = true;Fi[	@.i I"~module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.empty? then
      var = (HOMEBREW_LIBRARY / "Taps");Fi [	I"$data//homebrew_proj/cmd/test.rb;TiI"œrequire("extend/ENV")
require("hardware")
require("keg")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    ENV.extend(HomebrewEnvExtension);Fi[	@1iI"úrequire("keg")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    begin
      (raise(KegUnspecifiedError) if ARGV.named.empty?;Fi[	I"&data//homebrew_proj/cmd/unlink.rb;Ti I"çmodule Homebrew
  extend(self)
  
  def function(arglist)
    raise(KegUnspecifiedError) if ARGV.named.empty?
    ARGV.kegs.each do |arglist|;Fi [	I"%data//homebrew_proj/cmd/untap.rb;TiI"{require("cmd/tap")
module Homebrew
  extend(self)
  
  def function(arglist)
    var, var = tap_args
    var.downcase!;Fi[	@p-iI"Â    (self > 1) ? ("s") : ("")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then
      abort("Cowardly refusing to `sudo brew upgrade'");Fi[	I"$data//homebrew_proj/cmd/uses.rb;TiI"™require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    var = Formula.select do |arglist|;Fi[	@àiI"«require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise("Please `brew install git` first") unless which("git")
    unless (HOMEBREW_REPOSITORY / ".git").directory? then;Fi[I"
super;FI"end;FI"end;FI" ;Fi$[$[	I"7data//activemodel_proj/active_model/validations.rb;Ti≠I"Ú      def function(arglist)
        var = _validators.dup
        var._validators = var.each { |arglist| var[var] = var.dup }
        super
      end
    end
    
    # Clean the +Errors+ object if instance is duped.
    def function(arglist);Fi[	@ikI"2          if var and var = self.class.serialized_attributes[var.name] then
            Attribute.new(var, var, :unserialized)
          else
            super
          end
        end
        
        def function(arglist)
          self.class.serialized_attributes.include?(var) ? (var.!=(var)) : (super);Fi[	@iwI"Ï          if self.class.serialized_attributes.include?(var) then
            super.unserialized_value
          else
            super
          end
        end
        
        def function(arglist)
          super.dup.tap do |arglist|;Fi[	@"i*I"            var, var = "              def #{attr_name}=(original_time)\n                original_time = nil if original_time.blank?\n                time = original_time\n                unless time.acts_like?(:time)\n                  time = time.is_a?(String) ? Time.zone.parse(time) : time.to_time rescue time\n                end\n                zoned_time   = time && time.in_time_zone rescue nil\n                rounded_time = round_usec(zoned_time)\n                rounded_value = round_usec(read_attribute(\"#{attr_name}\"))\n                if (rounded_value != rounded_time) || (!rounded_value && original_time)\n                  write_attribute(\"#{attr_name}\", original_time)\n                  #{attr_name}_will_change!\n                  @attributes_cache[\"#{attr_name}\"] = zoned_time\n                end\n              end\n", (52 + 1)
            generated_attribute_methods.module_eval(var, "(string)", var)
          else
            super
          end
        end
        
        private
        ;Fi[	@Ii>I"£          when /bit/i then
            :binary
          else
            super
          end
        end
        
        def function(arglist)
          case var;Fi[	@Ii\I"@          when /^enum\((.+)\)/i then
            $1.split(",").map { |arglist| (var.strip.length - 2) }.max
          else
            super
          end
        end
        
        # MySQL misreports NOT NULL column default when none is given.
        # We can't detect this for columns which may have a legitimate '';Fi[	@IiI"“            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      
      def function(arglist)
        if var[:first] then;Fi[	@IifI"        when 1452 then
          InvalidForeignKey.new(var, var)
        else
          super
        end
      end
      
      def function(arglist)
        var = "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}";Fi[	@biI"À          when / BC$/ then
            super(("-" + var.sub(/ BC$/, "")))
          else
            super
          end
        end
        
        def function(arglist)
          if Hash.===(var) then;Fi[	@uiRI"±              super
            end
          else
            super
          end
        end
        
        def function(arglist)
          return super(var, var) unless var;Fi[	@ÉiOI"8              raise(ActiveRecordError, "No range type has byte size #{limit}. Use a numeric with precision 0 instead.")
            end
          else
            super
          end
        end
        
        # Returns a SELECT DISTINCT clause for a given set of columns and a given ORDER BY clause.
        #;Fi[	@çi«I"«          var = var.class.string_to_binary(var).unpack("H*")[0]
          "x'#{s}'"
        else
          super
        end
      end
      
      def function(arglist)
        @var.class.quote(var);Fi[	@çiŸI"ﬂ        if var.respond_to?(:usec) then
          "#{super}.#{sprintf("%06d", value.usec)}"
        else
          super
        end
      end
      
      def function(arglist)
        return var.to_f if BigDecimal.===(var);Fi[	@•i}I"        if using_single_table_inheritance?(var) then
          find_sti_class(var[inheritance_column])
        else
          super
        end
      end
      
      def function(arglist)
        var[inheritance_column].present? and columns_hash.include?(inheritance_column);Fi[	@⁄iI"°          self.db_runtime = (var + var)
          (var - var)
        else
          super
        end
      end
      
      def function(arglist)
        super;Fi[	@˝i7I"ø          puts(File.read("#{root}/#{command}.txt"))
        end
      else
        super
      end
    end
    
    desc("init", "Generates a Gemfile into the current working directory")
    ;Fi[	@iI"4      self.class.handle_no_task_error(var, false) if var.nil?
      var.start(["-h", var].compact, :shell => (self.shell))
    else
      super
    end
  end
  
  # If a task is not found on Thor::Runner, method missing is invoked and
  # Thor::Runner is then responsible for finding the task in all classes.;Fi[	@ßiuI"ﬂ          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action;Fi[	@¨icI"ﬂ          var = var.to_s.split("\n")
          Diff::LCS.sdiff(var, var).each { |arglist| output_diff_line(var) }
        else
          super
        end
      end
      
      def function(arglist)
        case var.action;Fi[	@åi-I"          if configuration.respond_to?(var) then
            configuration.send(var, *var, &var)
          else
            super
          end
        end
        
        # A wrapper for Kernel#system that logs the command being executed.
        def function(arglist);Fi[	@$iüI"      if ["owg", "svg"].include?(var) and (position_or_angle.is_a?(Sass::Script::Number) and position_or_angle.numerator_units.include?("deg")) then
        false
      else
        super
      end
    end
    
    # Output the original webkit gradient syntax
    def function(arglist);Fi[	@iiI"ÿ      module ClassMethods
        def function(arglist)
          var[:status] ||= 401 unless var[:exception]
          super
        end
      end
      
      def self.define_helpers(arglist)
        var = var.name;Fi[	@Â	iDI"p        end
        super(var, var, var)
      else
        super
      end
    end
    
    protected
    ;Fi[	@Ki I"ƒ          raise("Document cannot have multiple root nodes") if (var.size > 1)
          super(var.first)
        else
          super
        end
      end
      
      alias :<< :add_child
      ;Fi[	@’iI"          if (var.size == 1) and var.first.is_a?(::Time) then
            __send__(var, var.first.xmlschema, &var)
          else
            super
          end
        end
        
        def function(arglist)
          __send__(var, (var or {}).merge(:type => "array"), &var);Fi[	@îi¥I"           add_states(var.known_states)
          var
        else
          super
        end
      end
      
      # Configures new states with the built-in humanize scheme
      def function(arglist);Fi[	@ûi?I"        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	@∫i8I"        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	@ΩiI"˙          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
      
      version("2.0.x") do |arglist|
        def self.active?(arglist);Fi[	@¬i<I"        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist);Fi[	@ÿiÃI"⁄          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    
    # Tracks that before callbacks have now completed
    def function(arglist);Fi[I"
false;FI"end;FI"end;FI" ;Fi"["[	@ãiI"Ó            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end
      end
      
      def function(arglist)
        @var = merge_target_lists(find_target, target) if find_target?;Fi[	@iXI"¬            true
          end
        else
          false
        end
      end
      
      # Returns +true+ if +attribute+ is an attribute method and table exists,
      # +false+ otherwise.;Fi[	@VißI"           (@var.respond_to?(:stat) ? (@var.stat) : (@var.query("select 1"))
          @var.respond_to?(:errno) ? (@var.errno.zero?) : (true))
        rescue Mysql::Error
          false
        end
      end
      
      def function(arglist)
        super;Fi[	@ÀieI"è      begin
        create_or_update
      rescue ActiveRecord::RecordInvalid
        false
      end
    end
    
    # Saves the model.
    #;Fi[	@ºi≠I"•        end
        connection.select_value(var, "#{name} Exists", var.bind_values))
      rescue ThrowResult
        false
      end
    end
    
    protected
    ;Fi[	@xi˚I"#          var.path)
        rescue => var
          Logger.warn(Errors::Encryptor::GPG::PassphraseError.wrap(var, "Error creating temporary passphrase file."))
          false
        end
      end
      
      ##
      # Process :recipients, importing their public key from :keys if needed,;Fi[	@CigI"Í            in_path { |arglist| git("cat-file -e #{@revision}") }
            true)
          rescue GitError
            false
          end
        end
        
        # Escape the URI for git commands
        def function(arglist);Fi[	@üiêI"ƒ      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist)
      peek and (parsing_options?.! or super);Fi[	@äiòI"          yield
        else
          self.errors.add(:email, :already_confirmed)
          false
        end
      end
      
      # Generates a new random token for confirmation, and stores the time
      # this token is being generated;Fi[	@íiSI"¨          else
            save(:validate => (false))
          end
          false
        end
      end
      
      def function(arglist)
        if Devise.paranoid then;Fi[	@íiwI",        if unlock_strategy_enabled?(:time) then
          locked_at and (locked_at < self.class.unlock_in.ago)
        else
          false
        end
      end
      
      # Checks whether the record is locked or not, yielding to the block
      # if it's locked, otherwise adds an error to email.;Fi[	@íi}I"‡          yield
        else
          self.errors.add(:email, :not_locked)
          false
        end
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new;Fi[	@¬i.I"–          true
        else
          fail!(var.unauthenticated_message) if var
          false
        end
      end
      
      # Get values from params and set in the resource.
      def function(arglist);Fi[	@ªiåI"º    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist)
    var = var.id.to_s;Fi[	@ªiOI"ó      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  
  def self.build(arglist)
    var = User.new(var);Fi[	@£iäI"      unless ((var.errno == Errno::ENOTEMPTY::Errno) or ((var.errno == Errno::EACCES::Errno) or (var.errno == Errno::ENOENT::Errno))) then
        raise
      end
      false
    end
  end
  
  def function(arglist)
    require("fileutils");Fi[	@Z	i|I"˝        if instance_variable_defined?("@#{name}") then
          return instance_variable_get("@#{name}")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.;Fi[	@Z	iÆI"	        if instance_variable_defined?("@#{name}") then
          return remove_instance_variable("@#{name}")
        else
          false
        end
      end
      
      # Is the object's size changable? Only returns true for arrays and hashes
      # currently.;Fi[	@i(I"√        when Proc then
          var.call(var)
        else
          false
        end
      end
      
      # Determines if only updates can occur. Only valid for one-to-one
      # relations.;Fi[	@Ëi{I"–          end)
        rescue ::Fog::Errors::Error => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      ;Fi[	@Îi≤I"Î        begin
          original_filename ? (s3_object(var).exists?) : (false)
        rescue AWS::Errors::Base => var
          false
        end
      end
      
      def function(arglist)
        var = (@var[var] or @var[:default]);Fi[	@Îi¯I"”          var.close)
        rescue AWS::Errors::Base => var
          warn("#{e} - cannot copy #{path(style)} to local file #{local_dest_path}")
          false
        end
      end
      
      private
      ;Fi[	@UiËI"¥    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist)
    if self.BreakThePage?(var) then;Fi[	@,ioI"ƒ      begin
        payload_class.!=(Object)
      rescue NameError
        false
      end
    end
    
    # Returns an array of args represented in this job's payload.
    def function(arglist);Fi[	@*i{I"∑          begin
            @var.tty?
          rescue NoMethodError
            false
          end
        end
        
        def function(arglist)
          colour(var, "\e[32m");Fi[	@ÇiüI"        var.perform(*var)
      else
        on_failure(var)
        false
      end
    end
    
    # Marks the object as invalid and runs any failure callbacks associated with
    # this event.  This should get called anytime this event fails to transition.;Fi[	@Ô%iAI"5      if (var.length == var.length) then
        TransitionCollection.new(var, :actions => (var)).perform
      else
        false
      end
    end
    
    # Builds the collection of transitions for all event attributes defined on
    # the given object.  This will only include events whose machine actions;Fi[	@!i"I"˜          send(var.to_sym, var, var.options)
          true)
        rescue Twitter::Error::NotFound, Twitter::Error::Forbidden
          false
        end
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[	@Ai8I"»          get("/1.1/users/show.json", var)
          true)
        rescue Twitter::Error::NotFound
          false
        end
      end
      
      # Returns users that match the given query
      #;Fi[@µ @°+I"	true;FI"end;Fi"["[	@µiI"ö      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@3i
I"√    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@CiI"µ      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@CipI"      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end
    end
    ;Fi[	@IiäI"º      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true, since this connection adapter supports savepoints.;Fi[	@IiìI"¡      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Technically MySQL allows to create indexes with the sort order syntax;Fi[	@Qi%I"‘        @var = BindSubstitution.new(self)
        configure_connection
      end
      
      def function(arglist)
        true
      end
      
      # HELPER METHODS ===========================================;Fi[	@çiâI"à      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@çi≠I"Ç      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      
      #:nodoc:;Fi[	@B)iI"    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@˜i*I"®        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist);Fi[	@Ùi'I"≤      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@ÙiåI"Ω      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@!iI"à    def function(arglist)
      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@$iAI"ó    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@ñiÄI"ê        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end;Fi[	@ªiI"ä        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@Éi%I"ì      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@¨i*I"Ã      def function(arglist)
        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@Õi#I"ª          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	I"3data//diaspora_proj/models/account_deletion.rb;Ti,I"É  def function(arglist)
    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	@úiI"À  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  
  scope(:on_statuses, lambda { |arglist| where(:status_message_guid => (var)) });Fi[	@Æi I"~  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  
  def function(arglist);Fi[	I"%data//haml_proj/haml/template.rb;TiI"É  
  module Util
    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end;Fi[	@˚#i
I"    safe(true)
    
    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@π)iI"    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    
    def function(arglist);Fi[	@π)iI"u    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end;Fi[	I":data//rspec_proj/spec/interop/test/unit/autorunner.rb;TiI"nclass Test::Unit::AutoRunner
  remove_method(:process_args)
  
  def function(arglist)
    true
  end
end;Fi[	@–iI"©        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        
        def function(arglist);Fi[@'@(@éI"protected;Fi![![	@˝iÜI"è        else
          match_attribute_method?(var.to_s).nil?.!
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[	@ViVI"            var[:if].unshift("#{options[:on]}.include? self.validation_context")
          end
          set_callback(:validation, :after, *(var << var), &var)
        end
      end
      
      protected
      
      # Overwrite run validations to include callbacks.;Fi[	@ji0I"√              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@ΩiSI"Å          end
        else
          # do nothing
        end
      end
      
      protected
      
      def function(arglist);Fi[	@‚i)I"ö            return if method_defined?(var)
            super
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@ºiÆI"≥        connection.select_value(var, "#{name} Exists", var.bind_values))
      rescue ThrowResult
        false
      end
    end
    
    protected
    
    def function(arglist);Fi[	@iI"•        end
        self.stored_attributes[var] ||= []
        self.stored_attributes[var] |= var
      end
    end
    
    protected
    
    def function(arglist);Fi[	@2iI"          var = options.except(:case_sensitive, :scope, :conditions)
          var[:value] = var
          var.errors.add(var, :taken, var)
        end
      end
      
      protected
      
      # The check for an existing value should be run from a class that;Fi[	@6&iI"÷        var[0]
      else
        [var[(0..-2)].join(", "), var[-1]].join(" or ") if (var.length > 1)
      end
    end
    
    protected
    
    # http://www.informit.com/articles/article.aspx?p=683059&seqNum=36;Fi[	@ôi,I"|        default.empty?.!
      else
        default
      end
    end
    
    protected
    
    def function(arglist);Fi[	@üi|I"      var = @var.select { |arglist| var =~ /^--?(?:(?!--).)*$/ }
      unless var.empty? then
        raise(UnknownArgumentError, "Unknown switches '#{unknown.join(", ")}'")
      end
    end
    
    protected
    
    # Check if the current value in peek is a registered switch.;Fi[	@ßigI"          var = self.class.const_get(var.to_s.upcase) if var.is_a?(Symbol)
          var = var ? (BOLD) : ("")
          "#{bold}#{foreground}#{string}#{CLEAR}"
        end
      end
      
      protected
      
      # Overwrite show_diff to show diff with colors if Diff::LCS is;Fi[	@iLI"î        yield)
      ensure
        shell.padding -= 1
      end
    end
    
    protected
    
    # Allow shell to be shared between invocations.;Fi[	@πiKI"•            true if [var[:only]].flatten.include?(@var[:action].to_sym)
          end
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[	@4i?I"Q          var = var.select { |arglist| var.all? { |arglist| (var.options[var] == var) } }
          var = var.reject { |arglist| var.any? { |arglist| (var.options[var] == var) } }
          var[:skip_hostfilter] ? (var.uniq) : (filter_server_list(var.uniq))
        end
      end
      
      protected
      
      def function(arglist);Fi[	@åi"I"9            var.remote.directory(configuration[:releases_path]).or("`#{configuration[:releases_path]}' does not exist. Please run `cap deploy:setup'.")
            var.remote.writable(configuration[:deploy_to]).or("You do not have permissions to write to `#{configuration[:deploy_to]}'.")
            var.remote.writable(configuration[:releases_path]).or("You do not have permissions to write to `#{configuration[:releases_path]}'.")
          end
        end
        
        protected
        
        # This is to allow helper methods like "run" and "put" to be more;Fi[	@iI"£          ::Compass::Exec::Helpers.report_error(var, (@var or {}))
        end
        return 1
      end
    end
    
    protected
    
    def function(arglist);Fi[	@çi]I"]      else
        var
      end
    end
  end
  
  protected
  
  def function(arglist);Fi[	@íi`I"~          else
            super
          end
        end
      end
      
      protected
      
      def function(arglist);Fi[	@¨iI"Ä        var = VALIDATIONS.select { |arglist| var.respond_to?(var).! }
        unless var.empty? then
          raise(("Could not use :validatable module since #{base} does not respond " << "to the following methods: #{unavailable_validations.to_sentence}."))
        end
      end
      
      protected
      
      # Checks whether a password is needed or not. For validations only.;Fi[	@Ω	i&I"”          attribute.any? { |arglist| var.===(var) }
        else
          var.===(attribute)
        end
      end
      
      protected
      
      # Convenience method for getting the first value in a hash.;Fi[	@Â	iEI"~        super(var, var, var)
      else
        super
      end
    end
    
    protected
    
    def function(arglist);Fi[	@€&iI"‰      def function(arglist)
        var.any? do |arglist|
          (matches_literal_example?(var) or matches_example_not_considering_modules?(var))
        end
      end
      
      protected
      
      def function(arglist);Fi[	@ÿiçI"ﬂ          (var << var.add_edge(var, (var ? (var) : (var)), :label => (var.to_s)))
        end
        var
      end
    end
    
    protected
    
    # Builds a matcher strategy to use for the given options.  If neither a;Fi[	@ÿiGI"~        results[actions.first]
      else
        success?
      end
    end
    
    protected
    
    attr_reader(:results);Fi[	@Íi-I"®          puts("## [message] Run `whenever --help' for more options.")
          exit(0)
        end
      end
    end
    
    protected
    
    def function(arglist);Fi[	@Öi6I"ã          parse_as_string
        else
          parse_time
        end
      end
      
      protected
      
      def function(arglist);Fi[	@ãiI"á          ">> /dev/null 2>&1"
        else
          ""
        end
      end
      
      protected
      
      def function(arglist);Fi[@‡"@·"@‚"I"private;Fi![![	@Ci7I"ñ          var.serializable_hash(var)
        end
      end
      var
    end
    
    private
    
    (alias :read_attribute_for_serialization :send);Fi[	@óiI"          var = join_table.compile_insert(join_table[reflection.foreign_key] => (owner.id), join_table[reflection.association_foreign_key] => (var.id))
          owner.connection.insert(var)
        end
        var
      end
      
      private
      
      def function(arglist);Fi[	@ùi:I"î        end
        save_through_record(var)
        update_counter(1)
        var
      end
      
      private
      
      def function(arglist);Fi[	@¸i"I"¨        var = build_record(var)
        yield(var) if block_given?
        set_new_record(var)
        var
      end
      
      private
      
      def function(arglist);Fi[	@ˇiI"I        chain[(1..-1)].each do |arglist|
          var = var.merge(var.klass.all.with_default_scope.except(:select, :create_with, :includes, :preload, :joins, :eager_load))
        end
        var
      end
      
      private
      
      # Construct attributes for :through pointing to owner and associate. This is used by the;Fi[	@i™I"Î        var = var.association_class.new(self, var)
        association_instance_set(var, var)
      end
      var
    end
    
    private
    
    # Returns the specified association instance if it responds to :loaded?, nil otherwise.;Fi[	@6iI"˜        var[:null] = null unless null.nil?
        var[:default] = default unless default.nil?
        add_column_options!(var, var) unless (type.to_sym == :primary_key)
        var
      end
      
      private
      
      def function(arglist);Fi[	@ûiƒI"h        end
        var
      end
      var
    end
    
    private
    
    def function(arglist);Fi[	@Ωi!I"ˇ      # attributes when they are initialized. (e.g. attribute
      # serialization)
      def function(arglist)
        var
      end
      
      private
      
      # Guesses the table name, but does not decorate it with prefix and suffix information.;Fi[	@Ûi¨I"≤      var.distinct(uniq_value)
      var.from(build_from) if from_value
      var.lock(lock_value) if lock_value
      var
    end
    
    private
    
    def function(arglist);Fi[	@‚iI"}      header(var)
      tables(var)
      trailer(var)
      var
    end
    
    private
    
    def function(arglist);Fi[	@i%I"Œ      ((var << read_file("Gemfile")) << "\n")
      ((var << "\n\n") << "Gemfile.lock\n")
      ((var << read_file("Gemfile.lock")) << "\n")
      var
    end
    
    private
    
    def function(arglist);Fi[	@“iUI"†          var[var] = var unless [Array, Range, Hash].include?(var.class)
        end
      end
      var
    end
    
    private
    
    def function(arglist);Fi[	@Ji^I"®      def function(arglist)
        var = @var.dup
        (var << " (#{@hosts})") if @var
        var
      end
      
      private
      
      def function(arglist);Fi[	@åiBI"            var = Benchmark.realtime { |arglist| var = super }
          end
          logger.trace("command finished in #{(elapsed * 1000).round}ms")
          var
        end
        
        private
        
        def function(arglist);Fi[	@ñiïI"€        Cucumber::Term::ANSIColor.coloring = var
        var.rewind
        var = (("\n" + var.read) + (" " * (var[:indent] - 2)))
        var
      end
      
      private
      
      TO_S_PREFIXES = Hash.new("    ");Fi[	@0iOI"w    while var.is_a?(Reshare) do
      var = var.root
    end
    var
  end
  
  private
  
  def function(arglist);Fi[	@aiaI"k        (var[var] << var.to_s)
      end
    end
    var
  end
  
  private
  
  def function(arglist);Fi[	@ùiàI"√        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope
        end
        var
      end
      
      private
      
      def function(arglist);Fi[	@§iìI"á          end
        end
      end
      var
    end
    
    private
    
    # Get the old and new value for the provided attribute.;Fi[	@L	ièI"˘      def function(arglist)
        var = Criteria.new((delete(:klass) or delete("klass")))
        each_pair { |arglist| var = var.__send__(var, var) }
        var
      end
      
      private
      
      # Mongoize for the klass, key and value.;Fi[	@
iUI"‘        def function(arglist)
          var = yield(document)
          Threaded.clear_options!
          var
        end
        
        private
        
        # In case we need to cast going to the database.;Fi[	@¥i%I"Ò        without_autobuild { |arglist| serialize_attribute(var, var, var, var) }
      end
      serialize_relations(var, var) if var[:include]
      var
    end
    
    private
    
    # Get the names of all fields that will be serialized.;Fi[	@xiáI"    var.gsub!(/x%x%/, "&#38;")
    clean_html(var) if filter_html
    var.strip!
    var
  end
  
  private
  
  TEXTILE_TAGS = [[128, 8364], [129, 0], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [141, 0], [142, 0], [143, 0], [144, 0], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [157, 0], [158, 0], [159, 376]].collect! do |arglist|;Fi[	@}iHI"‹        end
        var.sort! { |arglist| (var.event_datetime <=> var.event_datetime) }
        var = var.slice(0, var[:limit]) if var[:limit]
        var
      end
      
      private
      
      def function(arglist);Fi[	@Ái[I"!          end
          var = [var.strip, var.strip, var.strip]
          var.each { |arglist| smooth_offtags_without_code_highlighting(var) }
          var
        end
        
        private
        
        # Patch for RedCloth.  Fixed in RedCloth r128 but _why hasn't released it yet.;Fi[	@â iI"m          false
        end
      end)
      var
    end
    
    private
    
    def function(arglist);Fi[	@î igI"∑      var = (var + keys(:name))
      var.uniq!
      var.map! { |arglist| self[var] }
      var
    end
    
    private
    
    # Gets the value for the given attribute on the node;Fi[I"	true;FI"end;FI" ;FI"def function(arglist);Fi [ [	@µiI"≤    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      [:finder_sql, :counter_sql].each do |arglist|
        if options.include?(var) then;Fi[	@3iI"ê    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      super
      define_constructors if constructable?;Fi[	@CiI"~      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end;Fi[	@IiàI"º      
      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@IiëI"º      
      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@çiáI"â      
      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@çiêI"í      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var.!=(false)
      end;Fi[	@çi´I"à      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end;Fi[	@B)i I"q    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end;Fi[	@˜i,I"ö        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          command.inspect
        end;Fi[	I"4data//capistrano_proj/capistrano/processable.rb;Ti'I"©          var.postprocess(var.&(var), var.&(var))
        end
      end
      true
    end
    
    def function(arglist)
      var = []
      sessions.each do |arglist|;Fi[	@Ùi)I"◊      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var);Fi[	@ÙiéI"~      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :scss
      end;Fi[	@!iI"v    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      css2_value
    end;Fi[	@$iCI"¯    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var.is_a?(Sass::Script::Number) and ((var.numerator_units.size == 1) and ((var.numerator_units.first == "deg") and var.denominator_units.empty?))
    end;Fi[	@ªiI"´      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        @var = (@var - 2) if var.to_s =~ /^after/
        print(var);Fi[	@Éi'I"Ç      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        :inactive
      end;Fi[	@Õi%I"ø      end
      
      def function(arglist)
        true
      end
      
      def function(arglist)
        mapping.to.rememberable_options.fetch(:key, "remember_#{scope}_token")
      end;Fi[	@F3iI"∆  # A better solution is needed.
  # @return [Boolean] true
  def function(arglist)
    true
  end
  
  def function(arglist)
    I18n.t("photos.comment_email_subject", :name => (author.name))
  end;Fi[	I"4data//diaspora_proj/models/aspect_membership.rb;TiI"9    if self.contact and (self.contact.aspects.size == 1) then
      self.user.disconnect(self.contact)
    end
    true
  end
  
  def function(arglist)
    { :id => (self.id), :person_id => (self.person.id), :contact_id => (self.contact.id), :aspect_ids => (self.contact.aspects.map { |arglist| var.id }) }
  end;Fi[	@Æi"I"Á  end
  
  def function(arglist)
    true
  end
  
  def function(arglist)
    Rails.logger.debug("Performing relayable retraction for #{target_guid}")
    if (self.parent_author_signature.nil?.! or self.parent.author.remote?) then;Fi[	@RiI"    # the ERB handler does.
    # In Rails 3.1+, we don't need to include Compilable.
    def function(arglist)
      true
    end
    
    def function(arglist)
      var = Haml::Template.options.dup
      if (ActionPack::VERSION::MAJOR >= 4) and var.respond_to?(:type) then;Fi[	@˚#iI"}    priority(:lowest)
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end;Fi[	@π)iI"x    end
    
    def function(arglist)
      true
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@i|I"À          self.custom_values = var
          custom_values.each(&:save)
          @var = false
          true
        end
        
        def function(arglist)
          @var = nil
          @var = true;Fi[	@7i3I"        
        def function(arglist)
          @var = send("#{parent_column_name}_changed?") ? (parent_id) : (false)
          true
        end
        
        def function(arglist)
          @var.nil? ? (move_to_root) : (move_to_child_of(@var) if @var)
        end;Fi[	@–iI"ï        end
        
        def function(arglist)
          true
        end
        
        def function(arglist)
          "anything"
        end;Fi[@'I"return var;FI"end;FI" ;Fi [ [	@>inI"∆          else
            # do nothing
          end
        end
        return var
      end
      
      # Overridden by the mysql adapter for supporting index lengths
      def function(arglist);Fi[	@IiTI"µ          else
            # do nothing
          end
        end
        return var
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, ""] }];Fi[	@3ilI"        Gem::SpecFetcher.new.list(false, true).each { |arglist| var[var] += var }
      rescue Gem::RemoteFetcher::FetchError
        # do nothing
      end
      return var
    end
    
    def function(arglist)
      var = self.build_args;Fi[	@Â8iI"∫        unless var.respond_to?(:session) then
          var.extend(self)
          var.session = var
        end
        return var
      end
      
      attr_accessor(:session)
    end;Fi[	@liuI".          var = yield(var).to_s.strip
          unless var =~ /^[0-9a-f]{40}$/ then
            raise("Unable to resolve revision for '#{revision}' on repository '#{repository}'.")
          end
          return var
        end
        
        def function(arglist)
          (variable(:git) or super);Fi[	@9inI"·      end
      if options[:time] then
        puts("Compilation took #{((result.__duration * 1000).round / 1000.0)}s")
      end
      return var
    end
    
    def function(arglist)
      if should_compile?(var, var) then;Fi[	@«iñI"˙              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "<span class=\"param\">#{param}</span>" });Fi[	@ài&I"∞        yield(var, var) if block_given?
        (var << var)
      end
    end
    return var
  end
  
  def function(arglist)
    if (Pathname.pwd == HOMEBREW_REPOSITORY) then;Fi[	@£i!I"|      else
        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var then;Fi[	@£i8I"æ      raise unless Kernel.system("mv", var, var)
    else
      FileUtils.mv(var, var)
    end
    return var
  end
  
  # Creates symlinks to sources in this folder.
  def function(arglist);Fi[	@£iHI"â      else
        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then;Fi[	I")data//homebrew_proj/extend/string.rb;Ti/I"#    var = super(var, var)
    if var and var.nil? then
      opoo("inreplace: replacement of '#{before}' with '#{after}' failed")
    end
    return var
  end
  
  # Looks for Makefile style variable defintions and replaces the
  # value with "new_value", or removes the definition entirely.;Fi[	@ËihI"¥          end
        else
          var = public_url
        end
        return var
      end
      
      def function(arglist)
        var = find_credentials(var).stringify_keys;Fi[	@}i/I"¢          var[var[1]] = var[2]
          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist)
      var = Diff.lcs(var, var);Fi[	@}icI"ï          var.push([var, var, var])
        end
        var.push(var)
      end
      return var
    end
    
    attr_reader(:diffs, :difftype)
    ;Fi[	@}iñI"√    var.each do |arglist|
      var = self[var]
      var.has_key?(var) ? (var[var].push(var)) : (var[var] = [var])
    end
    return var
  end
  
  def function(arglist)
    var ||= self.length;Fi[	@1 iWI"®      rescue URI::InvalidURIError
        raise(InvalidOpenId.new("#{identifier} is not an OpenID identifier"))
      end
    end
    return var
  end
  
  protected
  ;Fi[	@ci
I"}          var = 1
        end
      end
    end
    return var
  end
  
  #
  	# Converts UTF-8 strings to UTF16-BE.<br>;Fi[	@ci1I"ï          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  
  # ====================================================
  	#;Fi[	@ôiúI"          end
          var = (var.GetY - var) if ((var.GetY - var) > var)
          var.SetXY((var + var[var]), var)
        end
        return var
      end
      
      # Draw lines to close the row (MultiCell border drawing in not uniform)
      def function(arglist);Fi[	@˛i/I"…          var = (var > 0) ? (0) : (var)
        else
          var = min_scale_value
        end
        return var
      end
      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n";Fi[	@iuI"±          else
            (var << "<!-- Ruby Zlib not available for SVGZ -->")
          end
        end
        return var
      end
      
      attr_accessor(:height)
      ;Fi[	@igI"            var = var ? (((var + "; ") + var)) : (var)
            var[var] = var.strip.squeeze(" "))
          end
        end
        return var
      end
      
      # Override and place code to add defs here
      def function(arglist);Fi[	@	i5I"æ          var = var.max
        else
          var = @var.collect { |arglist| var[:data].max }.max
        end
        return var
      end
      
      def function(arglist)
        var = 0;Fi[	@	iCI"æ          else
            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist)
        @var[:fields];Fi[	@JiI"≈    var = new_hash_of_arrays
    var.each do |arglist|
      (var[$2] << var) if var =~ /\n(\.\/)?(.*spec\.rb):[\d]+:/
    end
    return var
  end
  
  def function(arglist)
    if var.empty? then;Fi[	I"5data//SiriProxy_proj/siriproxy/plugin_manager.rb;Ti,I"”      var = var.process_filters(var, var)
      var = var if ((var == false) or (var.class == var))
      return nil if (var == false)
    end
    return var
  end
  
  def function(arglist)
    var = super(var);Fi[@è7@ê7I" ;FI"def function(arglist);Fi [ [	@ûiI"ˇ        if (var[:allow_blank] == false) and (var[:minimum].nil? and var[:is].nil?) then
          var[:minimum] = 1
        end
        super
      end
      
      def function(arglist)
        var = CHECKS.keys.&(options.keys)
        if var.empty? then;Fi[	@óiI"¬      
      def function(arglist)
        @var = Arel::Table.new(var.join_table)
        super
      end
      
      def function(arglist)
        if var.new_record? then
          if var then;Fi[	@ùi#I"´            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested
        var = super;Fi[	@Ii I"◊        
        def function(arglist)
          return false if blob_or_text_column?
          super
        end
        
        def function(arglist)
          (sql_type =~ /blob/i or (type == :text))
        end;Fi[	@QiÆI"H      # Executes the SQL statement in the context of this connection.
      def function(arglist)
        @var.query_options[:database_timezone] = ActiveRecord::Base.default_timezone
        super
      end
      
      def function(arglist)
        var = execute(var, var)
        ActiveRecord::Result.new(var.fields, var.to_a);Fi[	@Qi›I"¸      
      def function(arglist)
        @var.query_options.merge!(:as => :array)
        super
      end
      
      def function(arglist)
        @var ||= @var.info[:version].scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map do |arglist|
          var.to_i;Fi[	@Vi I"W      # Many Rails applications monkey-patch a replacement of the configure_connection method
      # and don't call 'super', so leave this here even though it looks superfluous.
      def function(arglist)
        super
      end
      
      def function(arglist)
        @var.query_with_result = true
        var = exec_query(var, var, var);Fi[	@ïiI"    module ClassMethods
      def function(arglist)
        var.initialize_generated_modules
        super
      end
      
      def function(arglist)
        @var = Mutex.new
        generated_attribute_methods.const_set(:AttrNames, Module.new do |arglist|;Fi[	@´ifI"        # updated.
        def function(arglist)
          var = var.merge(locking_column => 1) if locking_enabled?
          super
        end
        
        def function(arglist)
          @var ||= (var = super
          if var.key?(locking_column) and lock_optimistically then;Fi[	@µi]I";        if (var.size == 1) and (var == nil) then
          raise(ActiveRecord::IrreversibleMigration, "To avoid mistakes, drop_table is only reversible if given options or a block (can be empty).")
        end
        super
      end
      
      def function(arglist)
        [:rename_table, var.reverse]
      end;Fi[	@µihI"        if (var.size <= 2) then
          raise(ActiveRecord::IrreversibleMigration, "remove_column is only reversible if given a type.")
        end
        super
      end
      
      def function(arglist)
        [:rename_index, ([var.first] + var.last(2).reverse)]
      end;Fi[	@⁄iI"˜      
      def function(arglist)
        ActiveRecord::LogSubscriber.reset_runtime
        super
      end
      
      def function(arglist)
        if ActiveRecord::Base.connected? then
          var = ActiveRecord::LogSubscriber.reset_runtime;Fi[	@$iI"Æ          end
        end
      end
      super
    end
    
    def function(arglist)
      if should_record_timestamps? then
        var = current_time_from_proper_timezone;Fi[	@$i*I"¸          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist)
      self.record_timestamps and (partial_writes?.! or (changed? or attributes.keys.&(self.class.serialized_attributes.keys).present?))
    end;Fi[	@ÕiI"      class Installer < Compass::Installers::ManifestInstaller
        def function(arglist)
          directory(targetize(""))
          super
        end
        
        def function(arglist)
          var ||= targetize("config.rb")
          write_file(var, config_contents);Fi[	@ÈiïI"c      # Require a compass plugin and capture that it occured so that the configuration serialization works next time.
      def function(arglist)
        ((self.required_libraries ||= []) << var)
        super
      end
      
      def function(arglist)
        ((self.loaded_frameworks ||= []) << var)
        Compass::Frameworks.register_directory(var);Fi[	@ÉiI"†      
      def function(arglist)
        init
        super
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init;Fi[	@˝i%I"x          var = StepDefKey.new(var.step_definition.regexp_source, var.step_definition.file_colon_line)
          (@var[var] << { :keyword => (var), :step_match => (var), :status => (var), :file_colon_line => (@var.file_colon_line), :duration => (@var) })
        end
        super
      end
      
      def function(arglist)
        add_unused_stepdefs
        aggregate_info;Fi[	@˝i9I"„          end
        end
        @var.puts
        super
      end
      
      def function(arglist)
        unless @var[:dry_run] then
          @var.print((format_string(sprintf("%.7f", var.mean_duration), :skipped) + " "));Fi[	@iiÿI"Î        sign_out_all_scopes(false)
        request.env["devise.skip_storage"] = true
        expire_devise_cached_variables!
        super
      end
      
      def function(arglist)
        @var ||= request.format.try(:ref)
      end;Fi[	@ú)iI"ˇ    
    def function(arglist)
      @var.merge!(:engine_class => (ActionView::Template::Handlers::Erubis))
      super
    end
    
    def function(arglist)
      [super, "@output_buffer = output_buffer ||= nil || ActionView::OutputBuffer.new;"]
    end;Fi[	@∆,i
I">    class SassRailsTemplate < ::Sass::Rails::SassTemplate
      def function(arglist)
        var = ::Rails.application.assets.context_class.new(::Rails.application.assets, "/", "/")
        super
      end
      
      def function(arglist)
        var = super
        var[:custom][:resolver] = ::ActionView::Base.new;Fi[	@ÄiDI"}end
class HeadSoftwareSpec < SoftwareSpec
  def function(arglist)
    super
  end
  
  def function(arglist)
    return
  end;Fi[	@¯i
I"H    class AttachmentContentTypeValidator < ActiveModel::EachValidator
      def function(arglist)
        var[:allow_nil] = true unless var.has_key?(:allow_nil)
        super
      end
      
      def function(arglist)
        var = "#{attribute}_content_type".to_sym
        var = var.send(:read_attribute_for_validation, var);Fi[	@ iI"‰      
      def function(arglist)
        extract_options(var)
        super
      end
      
      def function(arglist)
        var = "#{attr_name}_file_size".to_sym
        var = var.send(:read_attribute_for_validation, var);Fi[	I"Ödata//redmine_proj/plugins/open_id_authentication/generators/open_id_authentication_tables/open_id_authentication_tables_generator.rb;TiI"ﬁclass OpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("migration.rb", "db/migrate") }
  end;Fi[	I"ïdata//redmine_proj/plugins/open_id_authentication/generators/upgrade_open_id_authentication_tables/upgrade_open_id_authentication_tables_generator.rb;TiI"Âclass UpgradeOpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("migration.rb", "db/migrate") }
  end;Fi[@	)@Ú)I"@var = var;FI"@var = var;Fi[[	@√iI"      class Association
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class);Fi[	@ihI"¬    class MultiparameterAttribute
      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	@ﬂidI"      # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>{ class_name: "Money" }</tt>
      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var;Fi[	@ŸiI"•    
    alias :default_scoped? :default_scoped
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = nil
      @var = false;Ti[	@ÑiaI"        ##
        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        ;Fi[	@6iI"ä    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	@i
I"õ  class Graph
    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@"iI"ä    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	@CiI"ÿ        
        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var or Proc.new { |arglist| true });Fi[	@q1iI"Ë    
    attr_writer(:default_message)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "You are not authorized to access this page.")
    end;Fi[	@˜i<I"€        class Evaluator
          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          ;Fi[	@¬i"I"î    
    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@Wi#I"œ          end
        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["cleanup"] ||= Sass::Script::Bool.new(true);Fi[	@ßiI"é        end
      end
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil
      end;Fi[	@i*I"Â      class ForkedCucumberRunner
        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var;Fi[	@i
I"°    class RbHook
      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	@ti%I"    end
  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("notifier.invited_you", :name => (@var.name))), :host => (AppConfig.pod_uri.host) };Fi[	@ØiúI"≥  fatal(ARGV.force?.!)
  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  ;Fi[	I"'data//jekyll_proj/jekyll/layout.rb;TiI"Ô    # site - The Site.
    # base - The String path to the source.
    # name - The String filename of the post file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      self.data = {}
      self.process(var);Fi[	I"%data//jekyll_proj/jekyll/page.rb;TiI"    # base - The String path to the source.
    # dir  - The String path between the source and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      self.process(var);Fi[	@÷4iI"˝    # base - The String path to the <source>.
    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end;Fi[	@Â	iI"Ï      class AttributeAssignmentError < Mongoid::Errors::MongoidError
        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end;Fi[	@Mi	I"†  class Processor
    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@iI"(      # The worker object who detected the failure
      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end;Fi[	I")data//twitter_proj/twitter/cursor.rb;TiI"ˇ    # @param method_name [String, Symbol]
    # @param method_options [Hash]
    # @return [Twitter::Cursor]
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = Array(var[var.to_sym]).map do |arglist|;Fi[	@ÖiI"‹      
      attr_accessor(:time, :task)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var.is_a?(String) ? ((Chronic.parse(var) or 0)) : ((var or 0))
      end;Fi[@'@¸@ˇ,I"	true;Fi[[	@µiI"í      var = super
      CALLBACKS.each { |arglist| define_callback(var) }
      var
    end
    
    def function(arglist)
      true
    end
    ;Fi[	@3i	I"”  class SingularAssociation < Association
    def function(arglist)
      (super + [:remote, :dependent, :counter_cache, :primary_key, :inverse_of])
    end
    
    def function(arglist)
      true
    end
    ;Fi[	@CiI"†      
      def function(arglist)
        RealTransaction.new(connection, self, var)
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@CioI"|      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end
    end;Fi[	@IiâI"º      # Returns true, since this connection adapter supports migrations.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@IiíI"º      # Returns true, since this connection adapter supports savepoints.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@Qi$I"ü        super
        @var = BindSubstitution.new(self)
        configure_connection
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@çiàI"â      # Returns true.
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@çi¨I"à      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@B)iI"j    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    ;Fi[	@˜i)I"ì        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end
        ;Fi[	@Ùi&I"ù      
      def function(arglist)
        (top_level.environment == :development)
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@ÙiãI"®      
      def function(arglist)
        http_root_relative(top_level.http_javascripts_dir)
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@!iI"x    
    def function(arglist)
      (var == "css2")
    end
    
    def function(arglist)
      true
    end
    ;Fi[	@$i@I"Ç    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end
    
    def function(arglist)
      true
    end
    ;Fi[	@ñiI"ß      class SurplusCell < Cell
        def function(arglist)
          :comment
        end
        
        def function(arglist)
          true
        end
      end;Fi[	@ªiI"ä      def function(arglist)
        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@Éi$I"~      
      def function(arglist)
        :invalid
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@¨i)I"„      # or confirmation are being set somewhere.
      def function(arglist)
        (persisted?.! or (password.nil?.! or password_confirmation.nil?.!))
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@Õi"I"Ÿ        if var.respond_to?(:extend_remember_period=) then
          var.extend_remember_period = mapping.to.extend_remember_period
        end
      end
      
      def function(arglist)
        true
      end
      ;Fi[	@@8i+I"Ü  
  def function(arglist)
    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	@úi~I"}  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id)
  end
  
  def function(arglist)
    true
  end
  ;Fi[	@ÆiI"i  
  def function(arglist)
    self.sender_handle
  end
  
  def function(arglist)
    true
  end
  ;Fi[	@π)iI"j    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end
    ;Fi[	@π)iI"v    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      true
    end
  end;Fi[	@–iI"•      class AnyArgMatcher
        def function(arglist)
          # do nothing
        end
        
        def function(arglist)
          true
        end
        ;Fi[@'I"	self;FI"end;FI" ;Fi[[	@ΩiI"F      def function(arglist)
        var.each do |arglist|
          (join_associations.detect { |arglist| (var == var) } or build(var.reflection.name, (var.find_parent_in(self) or join_base), var.join_type))
        end
        self
      end
      
      def function(arglist)
        join_parts.last((join_parts.length - 1));Fi[	@Ûi·I"˚        self.lock_value = (var or true)
      else
        self.lock_value = false
      end
      self
    end
    
    # Returns a chainable relation with zero records, specifically an
    # instance of the <tt>ActiveRecord::NullRelation</tt> class.;Fi[	@?iiI"…          @var[var.name] -= var
        end
        (@var[var.name] << var)
      end
      self
    end
    
    def function(arglist)
      @var.inject(@var.size) { |arglist| var = (var + var.size) };Fi[	@îiEI"Õ          var = @var
          while var = var.next do
            yield([var.key, var.value])
          end
          self
        end
        
        def function(arglist)
          var = self.class.new;Fi[	@˜i±I"˝        var = CommandError.new("failed: #{message}")
        var.hosts = var.values.flatten
        raise(var)
      end
      self
    end
    
    # Force the command to stop processing, by closing all open channels
    # associated with this command.;Fi[	@JiPI"ˆ          var = var[var.first]
          @var = "the output #{output.inspect} from #{command.inspect} did not match #{expect.inspect}"
          @var = false
        end
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@ioI"€            self.inherited_data.inherit_from!(var)
          else
            self.inherited_data = var
          end
          self
        end
        
        def function(arglist)
          self.inherited_data = nil;Fi[	@ûiåI"Û          send_to_all("after_#{message}", *var)
        else
          send_to_all(var, *var)
        end
        self
      end
      
      def function(arglist)
        @var.each { |arglist| var.__send__(var, *var) if var.respond_to?(var) };Fi[	@¨iI"Â        else
          @var[:formats] += var[:formats]
          @var[:formats] = (stdout_formats[(0..0)] + non_stdout_formats)
        end
        self
      end
      
      def function(arglist)
        require("gherkin/i18n");Fi[	@iDI"⁄      EmailInviter.new(self.identifier, sender).send!
    else
      puts("broken facebook invitation_token")
    end
    self
  end
  
  # converts a personal invitation to an admin invite
  # used in account deletion;Fi[	@Æi>I"ü          return
        end
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.parent_author_signature, self.parent.author);Fi[	@-iTI"ü    var.save
    if var.auto_follow_back and var.receiving.! then
      var.share_with(var, var.auto_follow_back_aspect)
    end
    self
  end
  
  private
  ;Fi[	@‡#i^I"L        Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.sender_handle} payload_type=#{self.class}")
        return
      end
    end
    self
  end
  
  def function(arglist)
    verify_signature(self.target_author_signature, self.target.author);Fi[	@ùi$I"        if var then
          reject_matching(var, :selector, :options)
          var.inclusions.each { |arglist| inclusions.delete_one(var) }
        end
        self
      end
      
      # Forces the criteria to be scoped, unless its inside an unscoped block.
      #;Fi[	@Ò	i-I"è          end
          var.send(var, var)
        end
      end
      self
    end
    
    # Are the observers disabled for the object?
    #;Fi[	@ë
iÊI"                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        
        # Defines the setter method that allows you to set documents
        # in this relation by their ids. The defined setter, finds;Fi[	@-i;I"              var.run_callbacks(:build)
              var
            end
          end
          self
        end
        
        # Defines a creator method for an embeds_one relation. This is
        # defined as #create_name. After the object is built it will;Fi[	@ñi|I"4        def function(arglist)
          set_callback(:save, :after, :if => (lambda { |arglist| var.syncable?(var) })) do |arglist|
            var.update_inverse_keys(var)
          end
          self
        end
        
        # Set up the sync of inverse keys that needs to happen on a destroy.
        #;Fi[	@õi~I"Ú          var.each do |arglist|
            _loaded.delete(var.id)
            _added.delete(var.id)
          end
          self
        end
        
        # Iterating over this enumerable has to handle a few different
        # scenarios.;Fi[	@i;I"               var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["#{match.value[1].value.first}("]), Node.new(:FUNCTION, ["self(", var])])
            end
          end
        end
        self
      end
      
      # Find a node by type using +types+
      def function(arglist);Fi[	@KiüI"¸        unless decorators(XML::Node).include?(Nokogiri::Decorators::Slop) then
          (decorators(XML::Node) << Nokogiri::Decorators::Slop)
          decorate!
        end
        self
      end
      
      ##
      # Apply any decorators to +node+;Fi[	I"1data//nokogiri_proj/nokogiri/xml/node_set.rb;TiûI"        each do |arglist|
          var = var["class"].to_s.split(/\s+/)
          var["class"] = var.push(var).uniq.join(" ")
        end
        self
      end
      
      ###
      # Remove the class attribute +name+ from all Node objects in the NodeSet.;Fi[	@#:i≤I"∏          else
            var.delete("class")
          end
        end
        self
      end
      
      ###
      # Set the attribute +key+ to +value+ or the return value of +blk+;Fi[	@#:iËI"»          var = document.parse(var).first
          var.add_next_sibling(var)
          var.add_child(var)
        end
        self
      end
      
      ###
      # Convert this NodeSet to a string.;Fi[	@˜iÅI"Ω          var = paste("clobber_", var)
          task(:clobber => ([var]))
          task(var => (var))
        end
        self
      end
      
      # :nodoc:
      def function(arglist);Fi[	@Gi)I"◊    def function(arglist)
      Twitter::Configurable.keys.each do |arglist|
        instance_variable_set(:"@#{var}", Twitter::Default.options[var])
      end
      self
    end
    
    (alias :setup :reset!)
    ;Fi[@	)I"@var ||= {};FI"end;FI" ;Fi[[	@3i6I"¿    #   person.name # => "bob"
    #   person.name = 'robert'
    #   person.changed_attributes # => {"name" => "bob"}
    def function(arglist)
      @var ||= {}
    end
    
    private
    ;Fi[	@XiI"˙          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("#{self}##{name} has been deprecated as of " + "backup v.#{deprecation[:version]}");Fi[	@#i$I"ï        # Used internally by Capistrano to track which recipes have been loaded
        # via require, so that they may be successfully reloaded when require
        # is called again.
        def function(arglist)
          @var ||= {}
        end
        
        # Used internally to determine what the current "feature" being
        # required is. This is used to track which files load which recipes;Fi[	@
iKI"å      
      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {};Fi[	@
iOI"∑        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] };Fi[	@-i◊I"‘      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be pushed.
      #;Fi[	@-i„I"—      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be set.
      #;Fi[	@-iÔI"”      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the $pullAll operations or intialize a new one.
      #;Fi[	@ái5I"¿    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the pulls that need to happen.
    #;Fi[	@áiAI"≈    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the unique adds that need to happen.
    #;Fi[	@áiMI"    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the atomic updates that need to happen for the current
    # +Document+. This includes all changes that need to happen in the;Fi[	@áiI"¥    # @return [ Hash ] The delayed $sets.
    #
    # @since 2.3.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get a hash of atomic pulls that are pending.
    #;Fi[	@áiI"®    # @return [ Hash ] name/document pairs.
    #
    # @since 2.3.2
    def function(arglist)
      @var ||= {}
    end
    
    # Get the delayed atomic unsets.
    #;Fi[	@ái$I"¡    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Flag the document as destroyed and return the atomic path.
    #;Fi[	@Hi-I"⁄      # @return [ Hash ] The mass assignment options.
      #
      # @since 3.0.7
      def function(arglist)
        @var ||= {}
      end
      
      # Set the mass assignment options for the current model.
      #;Fi[	@Hi^I"      # @return [ Hash ] The pending relations in key/value pairs.
      #
      # @since 2.0.0.rc.7
      def function(arglist)
        @var ||= {}
      end
      
      # Get all the pending nested attributes that need to be set.
      #;Fi[	@HijI"&      # @return [ Hash ] The pending nested attributes in key/value pairs.
      #
      # @since 2.0.0.rc.7
      def function(arglist)
        @var ||= {}
      end
      
      # If the attribute is dynamic, add a field for it with a type of object
      # and then either way set the value.;Fi[	@]iI"…      # @return [ Hash ] The default options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
      
      # Define a configuration option with a default.
      #;Fi[	@≥i◊I"∑    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Set the session configuration options.
    #;Fi[	@yiI"∞      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the database session.
      #;Fi[	@|icI"Ë      # @return [ Hash ] The documents that have had eager loaded inclusions.
      #
      # @since 3.0.16
      def function(arglist)
        @var ||= {}
      end
      
      # Has the document had its inclusions loaded?
      #;Fi[	@§i5I"¡    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the changes for the document.
    #;Fi[	@§inI"    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Remove a change from the dirty attributes hash. Used by the single field
    # atomic updators.;Fi[	@ñi!I"—      # @return [ Hash ] The synced foreign keys.
      #
      # @since 2.1.0
      def function(arglist)
        @var ||= {}
      end
      
      # Has the document been synced for the foreign key?
      #;Fi[	@ iîI"          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        # Looks up a translation from the translations hash. Returns nil if
        # eiher key is nil, or locale, scope or key do not exist as a key in the;Fi[	@”iI"’        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("#{intro} received unexpected message :#{sym}#{arg_message(*args)}");Fi[I"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;FI"$# @example Mongoize the object.;Fi[[	@)	iRI"„        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@)	iåI"‰          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ])
        #;Fi[	@.	iI"«        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@3	i	I"  module Extensions
    module Boolean
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Boolean.mongoize("123.11")
        #;Fi[	@8	iI"Í        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date.mongoize
      #;Fi[	@8	i0I"          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Date.mongoize("2012-1-1")
        #;Fi[	@?	iI"…        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #;Fi[	@?	i6I"          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   DateTime.mongoize("2012-1-1")
        #;Fi[	@G	i!I"È      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11")
        #;Fi[	@L	inI"∆        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@L	i®I"Î      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ])
        #;Fi[	@Q	i-I"Ó      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #;Fi[	@Z	i{I"∆        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #;Fi[	@Z	i˚I"‚          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11")
        #;Fi[	@d	iI"∆        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   range.mongoize
      #;Fi[	@d	i<I"          var.nil? ? (nil) : (::Range.new(var["min"], var["max"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Range.mongoize(1..3)
        #;Fi[	@i	i	I"ˇ  module Extensions
    module Regexp
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Regexp.mongoize(/^[abc]/)
        #;Fi[	@n	iI"ÿmodule Mongoid
  module Extensions
    module Set
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   set.mongoize
      #;Fi[	@n	i$I"Ê          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Set.mongoize(1..3)
        #;Fi[	@s	i≥I"Ì          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   String.mongoize("123.11")
        #;Fi[	@x	i#I"Ô          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Symbol.mongoize("123.11")
        #;Fi[	@}	iI"⁄module Mongoid
  module Extensions
    module Time
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   time.mongoize
      #;Fi[	@}	i6I"‚          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1")
        #;Fi[	@Ñ	iI"Ámodule Mongoid
  module Extensions
    module TimeWithZone
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #;Fi[	@Ñ	i%I"
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   TimeWithZone.mongoize("2012-1-1")
        #;Fi[I"def self.included(arglist);FI"var.extend(ClassMethods);FI"end;FI" ;Fi[[	@XiI"Ømodule Backup
  module Configuration
    module Helpers
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        ##;Fi[	@åiI"Â  module Actions
    attr_accessor(:behavior)
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Hold source paths for one Thor instance. source_paths_for_search is the;Fi[	@iI"Õclass Thor
  module Invocation
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # This method is responsible for receiving a name and find the proper;Ti[	@„i	I"Ìmodule Capistrano
  class CLI
    module Execute
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Invoke capistrano using the ARGV array as the option parameters. This;Fi[	@Îi	I"Èmodule Capistrano
  class CLI
    module Options
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return a new CLI instance with the given arguments pre-parsed and;Fi[	@i
I"Ámodule Capistrano
  class CLI
    module UI
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return the object that provides UI-specific methods, such as prompts;Fi[	@$i0I"ô  end
  
  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist);Fi[	@iI"√module Redmine
  module Acts
    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist);Fi[	@iI"      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Returns events of type event_type visible by user that occured between from and to;Fi[	@iI"Ωmodule Redmine
  module Acts
    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist);Fi[	@iI"5      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:view_permission], self.project);Fi[	@iI"ømodule Redmine
  module Acts
    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist);Fi[	@iI"˜      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist)
          CustomField.where("type = '#{self.class.name}CustomField'").sorted.all;Fi[	@iI"∏module Redmine
  module Acts
    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist);Fi[	@iI"      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["datetime", "title", "description", "author", "type"].each do |arglist|
          var = "            def event_#{attr}\n              option = event_options[:#{attr}]\n              if option.is_a?(Proc)\n                option.call(self)\n              elsif option.is_a?(Symbol)\n                send(option)\n              else\n                option\n              end\n            end\n";Fi[	@iI"√module ActiveRecord
  module Acts
    module List
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:;Fi[	@#iI"≤module Redmine
  module Acts
    module Searchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Options:;Fi[	@#i)I"ÿ      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Searches the model for the given tokens;Fi[	@*iI"√module ActiveRecord
  module Acts
    module Tree
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:;Fi[	@2iI"ºmodule Redmine
  module Acts
    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist);Fi[	@2iI"Ë      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers
        def function(arglist);Fi[	@”i	I"œ  module ActionController
    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist);Fi[	@ÇiI"™module Redmine
  module SafeAttributes
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Declares safe attributes;Fi[	@√iI"¶module Redmine
  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist);Fi[	@!iI"ømodule Resque
  module Failure
    module Thoughtbot
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        attr_accessor(:klass);Fi[I"@var.flush;FI"end;FI" ;FI"def function(arglist);Fi[[	@∏iZI"å        @var.puts(scenario_summary(step_mother) { |arglist| format_string(var, var) })
        @var.puts(step_summary(step_mother) { |arglist| format_string(var, var) })
        @var.puts(format_duration(var.duration)) if var and var.duration
        @var.flush
      end
      
      def function(arglist)
        var = "#{e.message} (#{e.class})"
        if ENV["CUCUMBER_TRUNCATE_OUTPUT"] then;Fi[	@∏iI"ë          @var.puts(format_string((("\nIf you want snippets in a different programming language,\n" + "just make sure a file with the appropriate file extension\n") + "exists where cucumber looks for step definitions."), :failed))
        end
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        return unless var[:wip]
        var = step_mother.scenarios(:passed);Fi[	@∏i®I"∑      
      def function(arglist)
        @var.puts(format_string(var, :tag).indent(@var))
        @var.flush
      end
      
      def function(arglist)
        @var = []
      end;Fi[	@Êi1I"∂      
      def function(arglist)
        @var.puts(var.indent(@var))
        @var.flush
      end
      
      def function(arglist)
        if (@var == 1) then
          @var.puts;Fi[	@ÊiEI"∏      def function(arglist)
        @var.puts("#{keyword}: #{name}")
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2
        @var = 2;Fi[	@ÊiOI"ñ      
      def function(arglist)
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2
        @var = 2;Fi[	@Êi[I"¡      def function(arglist)
        @var = nil
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        print_feature_element_name(var, var, var, var)
      end;Fi[	@ÊiùI"A        var = "\"\"\"\n#{string}\n\"\"\"".indent(@var)
        var = var.split("\n").map { |arglist| var =~ /^\s+$/ ? ("") : (var) }.join("\n")
        @var.puts(format_string(var, @var.status))
        @var.flush
      end
      
      def function(arglist)
        return if @var
        print_exception(var, var, @var);Fi[	@Êi£I"›      def function(arglist)
        return if @var
        print_exception(var, var, @var)
        @var.flush
      end
      
      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var;Fi[	@Êi€I"∑        end
        @var.puts
        var[(1..-1)].each { |arglist| @var.puts("    #{s}") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end;Fi[	@ÈiRI"       def function(arglist)
        var = CHARS[var]
        @var.print(format_string(var, var))
        @var.flush
      end
      
      def function(arglist)
        (var == :skipped_param)
      end;Fi[	@*i)I"P          @var.puts("#{counter.to_s})")
          @var.puts(colorize_failure("#{failure.header}\n#{failure.exception.message}", var))
          @var.puts(format_backtrace(var.exception.backtrace))
          @var.flush
        end
        
        def function(arglist)
          var.pending_fixed? ? (blue(var)) : (red(var))
        end;Fi[	@*iAI"º          else
            @var.puts(red(var))
          end
          @var.flush
        end
        
        def function(arglist)
          unless @var.empty? then
            @var.puts;Fi[	@*iMI"›              @var.puts("#{pending_example[2]}\n")
            end
          end
          @var.flush
        end
        
        def function(arglist)
          @var.close if IO.===(@var).&(@var.!=($stdout))
        end;Fi[	@4iI"      class FailingExamplesFormatter < BaseTextFormatter
        def function(arglist)
          @var.puts("#{example_group.description} #{example.description}")
          @var.flush
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@9i I"«          @var = var
          @var.puts(html_header)
          @var.puts(report_header)
          @var.flush
        end
        
        def function(arglist)
          super
          @var = false;Fi[	@9i.I"F          @var.puts("<div class=\"example_group\">")
          @var.puts("  <dl>")
          @var.puts("  <dt id=\"example_group_#{example_group_number}\">#{h(example_group.description)}</dt>")
          @var.flush
        end
        
        def function(arglist)
          @var.puts("  </dl>")
          @var.puts("</div>");Fi[	@9i4I"         def function(arglist)
          @var.puts("  </dl>")
          @var.puts("</div>")
          @var.flush
        end
        
        def function(arglist)
          @var = (@var + 1)
        end;Fi[	@9i>I"h        def function(arglist)
          move_progress
          @var.puts("    <dd class=\"spec passed\"><span class=\"passed_spec_name\">#{h(example.description)}</span></dd>")
          @var.flush
        end
        
        def function(arglist)
          var = extra_failure_content(var)
          var = var.pending_fixed? ? ("pending_fixed") : ("failed");Fi[	@9iYI"6          @var.puts(var) unless (var == "")
          @var.puts("      </div>")
          @var.puts("    </dd>")
          @var.flush
        end
        
        def function(arglist)
          unless @var then
            @var.puts("    <script type=\"text/javascript\">makeYellow('rspec-header');</script>");Fi[	@9isI"
        
        def function(arglist)
          @var.puts("    <script type=\"text/javascript\">moveProgressBar('#{percent_done}');</script>")
          @var.flush
        end
        
        def function(arglist)
          var = 100.0
          if @var.!=(0) then;Fi[	@9iäI"ø          @var.puts("</div>")
          @var.puts("</body>")
          @var.puts("</html>")
          @var.flush
        end
        
        def function(arglist)
          "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE html \n  PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n<head>\n  <title>RSpec results</title>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <meta http-equiv=\"Expires\" content=\"-1\" />\n  <meta http-equiv=\"Pragma\" content=\"no-cache\" />\n  <style type=\"text/css\">\n  body {\n    margin: 0;\n    padding: 0;\n    background: #fff;\n    font-size: 80%;\n  }\n  </style>\n  <script type=\"text/javascript\">\n    // <![CDATA[\n#{global_scripts}\n    // ]]>\n  </script>\n  <style type=\"text/css\">\n#{global_styles}\n  </style>\n</head>\n<body>\n"
        end;Fi[	@MiI"’        
        def function(arglist)
          @var.print(colorize_failure("F", var))
          @var.flush
        end
        
        def function(arglist)
          @var.print(green("."))
          @var.flush;Fi[	@MiI"¡        
        def function(arglist)
          @var.print(green("."))
          @var.flush
        end
        
        def function(arglist)
          super
          @var.print(yellow("*"));Fi[	@MiI"¿        def function(arglist)
          super
          @var.print(yellow("*"))
          @var.flush
        end
        
        def function(arglist)
          @var.puts
          @var.flush;Fi[I"@var = nil;FI"end;FI" ;FI"def function(arglist);Fi[[	@∏iI"€        def function(arglist)
          @var = var
          @var = {}
          @var = nil
        end
        
        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end;Fi[	@√iI"˘          @var = var
          @var = (var.first and var.first.class)
          @var = nil
          @var = nil
        end
        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end;Fi[	@FiOI"Î        @var = Hash.new { |arglist| var[var] = {} }
        @var = false
        @var = SchemaCache.new(self)
        @var = nil
      end
      
      def function(arglist)
        synchronize do |arglist|
          unless in_use then;Fi[	@ﬂi“I"Â      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!
        if has_and_belongs_to_many? and (association_foreign_key == foreign_key) then;Fi[	@
iI"°      @var = []
      @var = []
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      begin
        (var ||= Bundler.read_file(var.to_s);Fi[	@LiI"À      @var = []
      @var = var
      @var = var
      @var = nil
    end
    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "#{@name}-#{@version}";Fi[	@JiI"÷      def function(arglist)
        @var = var
        @var = true
        @var = nil
      end
      
      def function(arglist)
        @var ||= "`#{path}' is not a directory"
        try("test -d #{path}", var);Fi[	@˙i;I"∂      
      # Support for testing.
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        configuration.to_sass_plugin_options
      end;Fi[	@3iI"Ó        
        def function(arglist)
          @var, @var, @var = var, var, var
          @var = nil
        end
        
        def function(arglist)
          raise(::Compass::Error, "You must impliment construct_sprite")
        end;Fi[	I",data//compass_proj/compass/test_case.rb;TiI"é  end
    def function(arglist)
      super
      @var = nil
    end
    
    def function(arglist)
      var = open(var)
      var = var.read;Fi[	@ÉiPI"˜        # https://rspec.lighthouseapp.com/projects/16211/tickets/342
        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end;Fi[	@ßiI"†        @var = var
        @var = var
        @var = var
        @var = nil
      end
      
      def function(arglist)
        begin
          (trap_interrupt;Fi[	@Øi
I"H  module Cli
    class ProfileLoader
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        unless cucumber_yml.has_key?(var) then
          raise(ProfileNotFound, "Could not find profile: '#{profile}'\n\nDefined profiles in cucumber.yml:\n  * #{cucumber_yml.keys.join("\n  * ")}\n");Fi[	@«ijI"†      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var
        @var = " ";Fi[	@«i™I"∂      
      def function(arglist)
        (@var << "</table>")
        @var = nil
      end
      
      def function(arglist)
        (@var << "<div class=\"examples\">")
      end;Fi[	@Êi¨I"†      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var)
        @var = 0;Fi[	@Èi6I"ú      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var
        var ||= @var;Fi[	@
i1I"ò      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var)
        var;Fi[	@‰i©I"ê    def function(arglist)
      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end;Fi[	@iI"™      def function(arglist)
        @var = StringScanner.new(var)
        @var = 1
        @var = nil
      end
      
      def function(arglist)
        yield
      end;Fi[	@ôiCI"Œ          SetCreator(Redmine::Info.app_name)
          SetFont(@var)
          @var = []
          @var = nil
        end
        
        def function(arglist)
          SetFont(@var, var, var)
        end;Fi[	@øiI"Ô        @var = (var == :no) ? (0) : (var)
        @var = var
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var ||= { :exactly => "", :at_least => "at least ", :at_most => "at most " }
      end;Fi[	@€i%I"Æ        @var = nil
        @var = false
        @var = var
        @var = nil
      end
      
      def function(arglist)
        var = clone
        var.expected_from = var;Fi[	@qi,I"ô        @var = nil
        @var = []
        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@tiI"Ã        @var = 0
        @var = 0
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var = var
        formatters.each { |arglist| var.example_group_started(var) };Fi[I"return var;FI"end;FI" ;FI"def function(arglist);Fi[[	@IiUI"‘            # do nothing
          end
        end
        return var
      end
      
      def function(arglist)
        var = Hash[var.map { |arglist| [var, ""] }]
        var = add_index_length(var, var, var);Fi[	@3imI"™      rescue Gem::RemoteFetcher::FetchError
        # do nothing
      end
      return var
    end
    
    def function(arglist)
      var = self.build_args
      begin;Fi[	@˜i|I"·          var
        end
        (var << fallback) if var.empty? and fallback
        return var
      end
      
      def function(arglist)
        branches.each { |arglist| yield(var) }
        yield(fallback) if fallback;Fi[	@livI"          unless var =~ /^[0-9a-f]{40}$/ then
            raise("Unable to resolve revision for '#{revision}' on repository '#{repository}'.")
          end
          return var
        end
        
        def function(arglist)
          (variable(:git) or super)
        end;Fi[	@9ioI"Ò      if options[:time] then
        puts("Compilation took #{((result.__duration * 1000).round / 1000.0)}s")
      end
      return var
    end
    
    def function(arglist)
      if should_compile?(var, var) then
        compile(var, var);Fi[	@«ióI"˙            end
          end
        end
        return var
      end
      
      def function(arglist)
        var = var.format_args(lambda { |arglist| "<span class=\"param\">#{param}</span>" })
        @var.div(:class => "step_name") do |arglist|;Fi[	@±0i$I"ü    end
    var = truncate(var, :length => ((var - var)))
    var = "#{truncated}#{url}"
    return var
  end
  
  def function(arglist)
    # do nothing
  end;Fi[	@ài'I"´        (var << var)
      end
    end
    return var
  end
  
  def function(arglist)
    if (Pathname.pwd == HOMEBREW_REPOSITORY) then
      "Library/Formula/#{name}.rb";Fi[	@îiI"£      end
    end
    var.insert(2, "-q") unless ARGV.verbose?
    return var
  end
  
  def function(arglist)
    safe_system(*expand_safe_system_args(var))
  end;Fi[	@£i"I"ê        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var then
      var = File.basename(var);Fi[	@£iII"¶        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then
      var = (self + File.basename(var));Fi[	@ËiiI"Ë        else
          var = public_url
        end
        return var
      end
      
      def function(arglist)
        var = find_credentials(var).stringify_keys
        var = Object.const_defined?(:Rails) ? (Rails.env) : (nil);Fi[	@}i0I"ó          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist)
      var = Diff.lcs(var, var)
      var = var = 0;Fi[	@}ióI"◊      var = self[var]
      var.has_key?(var) ? (var[var].push(var)) : (var[var] = [var])
    end
    return var
  end
  
  def function(arglist)
    var ||= self.length
    if (self.empty? or (var > self[-1])) then;Fi[	@}i®I"≤      (var > var) ? (var = (var + 1)) : (var = var)
    end
    self[var] = var
    return var
  end
  
  def function(arglist)
    var = nil
    if (var.difftype == String) then;Fi[	@˘i$I"›        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0)
      end;Fi[	@˛i0I"´        else
          var = min_scale_value
        end
        return var
      end
      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n"
      end;Fi[	@i!I"ﬂ        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@	i6I"÷        else
          var = @var.collect { |arglist| var[:data].max }.max
        end
        return var
      end
      
      def function(arglist)
        var = 0
        if (min_scale_value.nil? == false) then;Fi[	@	iDI"π            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end;Fi[	@	i\I"         var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 }
        var[:x] = (var * var);Fi[	@	icI""        var = { :x => 0, :y => 0 }
        var[:x] = (var * var)
        var[:y] = (@var - (var * var))
        return var
      end
      
      def function(arglist)
        var = min_value
        var = ((@var.to_f - ((font_size * 2) * top_font)) / (get_y_labels.max - get_y_labels.min));Fi[	@JiI"±    var.each do |arglist|
      (var[$2] << var) if var =~ /\n(\.\/)?(.*spec\.rb):[\d]+:/
    end
    return var
  end
  
  def function(arglist)
    if var.empty? then
      "";Fi[	@C9i-I"‹      var = var if ((var == false) or (var.class == var))
      return nil if (var == false)
    end
    return var
  end
  
  def function(arglist)
    var = super(var)
    self.guzzoni_conn.block_rest_of_session if var;Fi[	@C9i3I"¯  def function(arglist)
    var = super(var)
    self.guzzoni_conn.block_rest_of_session if var
    return var
  end
  
  def function(arglist)
    log("Sending Request Completed")
    var = generate_request_completed(self.guzzoni_conn.last_ref_id);Fi[I"@var = [];FI"end;FI" ;FI"def function(arglist);Fi[[	@ãi&I"«      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist)
        if block_given? then
          load_target.select.each { |arglist| yield(var) };Fi[	@B)iI"ãmodule ActiveRecord
  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end;Fi[	@LiI"º              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist)
          send("#{style}_fit")
          @var;Fi[	@iiI"›      
      def function(arglist)
        @var, @var, @var, @var, @var, @var = var, var, var, var, var, var
        @var = []
      end
      
      def function(arglist)
        return if @var
        attach_steps(@var);Fi[	@}iI"ö      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end;Fi[	@ñiI"¨        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end;Fi[	@ÊiI"≈        @var = []
        @var = 0
        @var = (var[:prefixes] or {})
        @var = []
      end
      
      def function(arglist)
        print_summary(var) unless @var[:autoformat]
      end;Fi[	@iI"±      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@ViI"∞      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	@èiI"ü  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist)
    (entries << { :name => (var), :action => (var) })
  end;Fi[	@ÄiI"£  def function(arglist)
    @var = var
    @var = var
    @var = []
  end
  
  def function(arglist)
    @var ||= DownloadStrategyDetector.detect(@var, @var)
  end;Fi[	@ØipI"¨  def function(arglist)
    @var = var
    @var = []
    @var = []
  end
  
  def function(arglist)
    var = which(var)
    return false if (var.nil? or var.executable?.!);Fi[	I";data//paperclip_proj/paperclip/io_adapters/registry.rb;TiI"û    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      (@var << [var, var])
    end;Fi[	@ÃiI"π        def function(arglist)
          @var = var
          @var = []
          @var = []
        end
        
        def function(arglist)
          @var = var.flatten
          self;Fi[	@Âi8I"ﬂ            log("There was an unexpected error while deleting directories: #{e.class}")
          end
        end
        @var = []
      end
      
      def function(arglist)
        FileUtils.cp(path(var), var)
      end;Fi[	@ËiQI"          (log("deleting #{path}")
          directory.files.new(:key => (var)).destroy)
        end
        @var = []
      end
      
      def function(arglist)
        if @var[:fog_host] then
          "#{dynamic_fog_host_for_style(style)}/#{path(style)}";Fi[	@ÎiÏI"…            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist)
        begin
          (log("copying #{path(style)} to local file #{local_dest_path}");Fi[	@}iwI"ß    
    def function(arglist)
      @var.push(@var) unless @var.empty?
      @var = []
    end
    
    def function(arglist)
      @var.push(["-", var, var])
    end;Fi[	@YiGI"…    class BeComparedTo < Be
      def function(arglist)
        @var, @var = var, var
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.__send__(@var, @var);Fi[	@oiI"≤      def function(arglist)
        @var = var
        @var = nil
        @var = []
      end
      
      def function(arglist)
        @var = var
        @var.each do |arglist|;Fi[	@i	I"¨  module Runner
    class BacktraceTweaker
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        var.gsub!("//", "/")
      end;Fi[	@*iI"õ          else
            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var
        end;Fi[	@>iI"Ã        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super
          var.nested_descriptions.each_with_index do |arglist|;Fi[	@HiI"ﬁ      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          @var.puts("Profiling enabled.")
        end;Fi[@'@¸@ˇ,I"case var;Fi[[	@pióI"—      # :nodoc:
      def function(arglist)
        [:if, :unless, :on, :allow_blank, :allow_nil, :strict]
      end
      
      def function(arglist)
        case var
        when TrueClass then
          {};Fi[	@ùimI"!      
      def function(arglist)
        ((through_reflection.macro == :belongs_to) and owner[through_reflection.foreign_key].blank?).!
      end
      
      def function(arglist)
        case var
        when :destroy then
          inverse_updates_counter_cache?(through_reflection).!;Fi[	@†iDI"«      # updated within replace.
      def function(arglist)
        replace(var, false)
      end
      
      def function(arglist)
        case var
        when :delete then
          target.delete;Fi[	@Ωi<I"‹        end.uniq
        remove_duplicate_results!(active_record, var, @var)
        var
      end
      
      def function(arglist)
        case var
        when Symbol, String then
          var = var.reflections[var];Fi[	@ΩiáI"∆      
      def function(arglist)
        JoinAssociation.new(var, self, var)
      end
      
      def function(arglist)
        case var
        when Symbol, String then
          var = var.to_s;Fi[	@Ii@I"™          else
            super
          end
        end
        
        def function(arglist)
          case var
          when /blob|text/i then
            case var;Fi[	@biáI"Â          else
            (var == "") ? ("\"\"") : (("\"%s\"" % var.to_s.gsub(/(["\\])/, "\\\\\\1")))
          end
        end
        
        def function(arglist)
          case var
          when "NULL" then
            var;Fi[	@Øi+I"Á    def function(arglist)
      var = var.respond_to?(:name) ? (var.name.to_s) : (var.to_s.split(".").last)
      @var.columns_hash[var]
    end
    
    def function(arglist)
      case var
      when "count" then
        var.to_i;Fi[	@ÛiŸI"    # on locking, please see +ActiveRecord::Locking+.
    def function(arglist)
      spawn.lock!(var)
    end
    
    def function(arglist)
      case var
      when String, TrueClass, NilClass then
        self.lock_value = (var or true);Fi[	@Ûi…I"	        var = Arel.sql(var) if String.===(var)
        var.where(Arel::Nodes::Grouping.new(var))
      end
    end
    
    def function(arglist)
      case var
      when String, Array then
        [@var.send(:sanitize_sql, (var.empty? ? (var) : (([var] + var))))];Fi[	@?i7I"”        end
      end
      var
    end
    
    def function(arglist)
      case var
      when Gem::Specification, RemoteSpecification, LazySpecification, EndpointSpecification then
        search_by_spec(var);Fi[	@åiI"     #:nodoc:
    def function(arglist)
      super.merge!(:destination_root => (self.destination_root))
    end
    
    def function(arglist)
      case var
      when Array then
        ["--force", "-f", "--skip", "-s"].each { |arglist| var.delete(var) };Fi[	@„iGI"E      # override this method to return a Configuration subclass or replacement.
      def function(arglist)
        Capistrano::Configuration.new(var)
      end
      
      def function(arglist)
        case var
        when Net::SSH::AuthenticationFailed then
          abort("authentication failed for `#{error.message}'");Fi[	@Îi≥I"ƒ            options[var][var] = coerce_variable(options[var][var])
          end
        end
      end
      
      def function(arglist)
        case var
        when /^"(.*)"$/ then
          $1;Fi[	@¶i¬I"Õ    else
      Sass::Script::Color::COLOR_NAMES_REVERSE
    end
  end
  
  def function(arglist)
    case var
    when Sass::Script::Color then
      Sass::Script::String.new(reversed_color_names[var.rgb]);Fi[	I"'data//compass_proj/compass/util.rb;TiI"í  
  def function(arglist)
    send(WARN_METHOD, *var)
  end
  
  def function(arglist)
    case var
    when NilClass, FalseClass then
      true;Fi[	@¡iI"‘      def function(arglist)
        @var = false
        @var.background(var.gherkin_statement)
      end
      
      def function(arglist)
        case var
        when Ast::Scenario then
          @var = false;Fi[	@«iI"¬        @var = nil
        @var = []
        @var = 0
      end
      
      def function(arglist)
        case var
        when /^image\/(png|gif|jpg|jpeg)/ then
          embed_image(var, var);Fi[	I")data//diaspora_proj/models/aspect.rb;TiI"~  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var
    when Post then
      (self.posts << var);Fi[	@ÁiXI"±      else
        raise(Error, "root value must be an Array or a Hash")
      end
    end
    
    def function(arglist)
      case var
      when Hash then
        objenc(var);Fi[	@ÁiyI"¡    
    def function(arglist)
      (("[" + var.map { |arglist| valenc(var) }.join(",")) + "]")
    end
    
    def function(arglist)
      case var
      when String then
        strenc(var);Fi[	@ËiéI"ﬂ        else
          "s3.amazonaws.com/#{@options[:fog_directory]}"
        end
      end
      
      def function(arglist)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@˜iêI"4          STDERR.puts("RSPECOPTS is DEPRECATED and will be removed in a future version. Use SPEC_OPTS instead.")
        end
        (ENV["SPEC_OPTS"] or (ENV["RSPECOPTS"] or (spec_opts.join(" ") or "")))
      end
      
      def function(arglist)
        case var
        when Proc then
          var.call;Fi[	@qiïI"µ            @var = false
          end
        end
      end
      
      def function(arglist)
        case var
        when :context, "context", "c" then
          @var = :context;Fi[@†:I"end;FI" ;FI"module ClassMethods;Fi[[	@Xi	I"÷  module Configuration
    module Helpers
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        ##
        # Returns or yields the Configuration::Store;Fi[	@åiI"    attr_accessor(:behavior)
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Hold source paths for one Thor instance. source_paths_for_search is the
      # method responsible to gather source_paths from this current class,;Fi[	@iI"class Thor
  module Invocation
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # This method is responsible for receiving a name and find the proper
      # class and task for it. The key is an optional parameter which is;Ti[	@„i
I"  class CLI
    module Execute
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Invoke capistrano using the ARGV array as the option parameters. This
        # is what the command-line capistrano utility does.;Fi[	@Îi
I"ˆ  class CLI
    module Options
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return a new CLI instance with the given arguments pre-parsed and
        # ready for execution.;Fi[	@iI"È  class CLI
    module UI
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Return the object that provides UI-specific methods, such as prompts
        # and more.;Fi[	@#iI"í      def self.included(arglist)
        var.send(:alias_method, :initialize_without_loading, :initialize)
        var.send(:alias_method, :initialize, :initialize_with_loading)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Used by third-party task bundles to identify the capistrano
        # configuration that is loading them. Its return value is not reliable;Fi[	@iI"%      def self.included(arglist)
        var.send(:attr_accessor, :inherited_data, :set_attributes, :top_level)
        var.send(:include, InstanceMethods)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          var.each do |arglist|;Fi[	@$i1I">  
  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ");Fi[	@i	I"  module Acts
    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          unless self.included_modules.include?(Redmine::Acts::ActivityProvider::InstanceMethods) then;Fi[	@i I"      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Returns events of type event_type visible by user that occured between from and to
          def function(arglist);Fi[	@i	I"‹  module Acts
    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          cattr_accessor(:attachable_options);Fi[	@i	I"  module Acts
    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Customizable::InstanceMethods) then;Fi[	@i	I"  module Acts
    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Event::InstanceMethods) then;Fi[	@i	I"π  module Acts
    module List
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:
        #;Fi[	@#i	I"‰  module Acts
    module Searchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Options:
        # * :columns - a column or an array of columns to search;Fi[	@#i*I"<      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods
          # Searches the model for the given tokens
          # projects argument can be either nil (will search all projects), a project or an array of projects;Fi[	@*i	I"π  module Acts
    module Tree
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        # Configuration options are:
        #;Fi[	@2i	I"	  module Acts
    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Watchable::InstanceMethods) then;Fi[	@”i
I"‡    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = breakdown_rfpdf_options(var);Fi[	@ÇiI"Ímodule Redmine
  module SafeAttributes
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      # Declares safe attributes
      # An optional Proc can be given for conditional inclusion;Fi[	@√iI"∏module Redmine
  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = nil;Fi[	@!i	I"∫  module Failure
    module Thoughtbot
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        attr_accessor(:klass)
        ;Fi[I"#       end;FI"#     end;FI"#   end;FI"#;Fi[[	@iKI"í      #       create_table :developers_projects, id: false do |t|
      #         t.integer :developer_id
      #         t.integer :project_id
      #       end
      #     end
      #   end
      #
      # It's also a good idea to add indexes to each of those columns to speed up the joins process.
      # However, in MySQL it is advised to add a compound index for both of the columns as MySQL only;Fi[	@
isI"ˇ        #     scope :red, -> { where(color: 'red') } do
        #       def dom_id
        #         'red_shirts'
        #       end
        #     end
        #   end
        #
        # Scopes can also be used while creating/building a record.
        #;Fi[	@ÕiI"    #       matcher.failure_message = "expected #{mouse} to eat cheese"
    #       wrap_expectation do |matcher|
    #         assert_eats_cheese(mouse)
    #       end
    #     end
    #   end
    #
    #   describe Mouse do
    #     it "eats cheese" do;Fi[	@â i!I"«    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events
    #   ;Fi[	@â iFI"ø    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events
    #   ;Fi[	@â ifI"5    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">
    #   events = Vehicle.state_machine.events;Fi[	@&iRI">    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.state                                 # => "parked";Fi[	@&iI":    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
    #   vehicle.fire_events(:ignite, :disable_alarm)  # => true;Fi[	@°iBI"+        #             # Override here...
        #           end
        #         end
        #       end
        #     end
        #   end
        # 
        # In the above example, a version override is defined for the ORMLibrary
        # integration when the version is between 0.2.x and 0.3.x.;Fi[	@§iI"        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@§i[I"        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer;Fi[	@§iI"        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|;Fi[	I"<data//state_machine_proj/state_machine/macro_methods.rb;Ti>I"    #     state_machine do
    #       event :park do
    #         ...
    #       end
    #     end
    #   end
    # 
    # The above example will define a state machine named "state" that will
    # store the value in the +state+ attribute.  Every vehicle will start;Fi[	@=<itI"    #       
    #       event :shift_up do
    #         transition :idling => :first_gear
    #       end
    #     end
    #   end
    #   
    #   Vehicle.human_state_name(:parked)         # => "parked"
    #   Vehicle.human_state_name(:first_gear)     # => "first gear";Fi[	@=<i•I"‰    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   vehicle.state                             # => "parked";Fi[	@=<i*I"    #       @state = 'idling'
    #       initialize_state_machines(:static => :force) do
    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked";Fi[	@=<iGI"    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition all => :idling
    #       end
    #     end
    #   end
    # 
    # ...will generate the following instance methods (assuming they're not
    # already defined in the class):;Fi[	@=<iñI"6    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly
    #   vehicle = Vehicle.create    # => #<Vehicle id=1 state="parked" alarm_state="active">;Fi[	@=<i—I"%    #       
    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end
    #   end
    # 
    # The above class defines two state machines: +heater_state+ and +alarm_state+.
    # For the +heater_state+ machine, the following methods are generated since;Fi[	I">data//state_machine_proj/state_machine/matcher_helpers.rb;TiI"Á    #       
    #       event :crash
    #         transition all - :parked => :stalled
    #       end
    #     end
    #   end
    # 
    # In the above example, +all+ will match the following states since they
    # are known:;Fi[	@L<i.I"=    #     state_machine do
    #       event :ignite
    #         transition [:idling, :first_gear] => same
    #       end
    #     end
    #   end
    # 
    # In the above example, +same+ will match whichever the from state is.  In
    # the case of the +ignite+ event, it is essential the same as the following:;Fi[	@„iÁI"!    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[	@„i I"d    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling);Fi[@	)@Ú)@Ç9I"end;Fi[[	@(i{I"Ω      class Reaper
        attr_reader(:pool, :frequency)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@6iI"ù    end
    
    class Table
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Adds a new column to the named table.;Fi[	@LiI"Œ      class Resolver
        attr_reader(:config, :klass, :configurations)
        
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@ri5I"`          # +delim+ corresponds to the `typdelim` column in the pg_types
          # table.  +subtype+ is derived from the `typelem` column in the
          # pg_types table.
          def function(arglist)
            @var = var
            @var = var
          end
          
          # FIXME: this should probably split on +delim+ and use +subtype+;Fi[	@íi
I"ß    class StatementPool
      include(Enumerable)
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@ûi˙I"î    
    attr_reader(:model_class, :fixture)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[	@˝i	I"á  class Splitter
    include(Backup::CLI::Helpers)
    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##;Fi[	@ºi)I"Ê        raise(NotImplemented, "This model adapter does not support matching on a specific condition.")
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@OitI"             InternalRevision.new(var, var)
          end
          
          def function(arglist)
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@iI"§        new(*var).send(:get_binding)
      end
      
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@ñi÷I"      #   table.hashes.keys
      #   # => ['phone number', 'ADDRESS']
      #
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Returns a new Table where the headers are redefined. See #map_headers!;Fi[	@¡i
I"≥module Cucumber
  module Formatter
    class GherkinFormatterAdapter
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@è(iI"vclass ExtremePostPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@ï(iI"á  
  include(ActionView::Helpers::TextHelper)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@Ô#iI"qclass PersonPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@“i	I"üclass PostPresenter
  attr_accessor(:post, :current_user)
  
  def function(arglist)
    @var = var
    @var = var
  end
  
  def self.collection_json(arglist);Fi[	@“iDI"  end
end
class PostInteractionPresenter
  def function(arglist)
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@iI"‚      # Get the type of this node
      # Get the value of this node
      # Create a new Node with +type+ and +value+
      def function(arglist)
        @var = var
        @var = var
      end
      
      # Accept +visitor+;Fi[	@CiÅI"£      end
      
      class NodeBuilder
        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@niI"órequire("uri")
module Paperclip
  class UrlGenerator
    def function(arglist)
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[	@€&iI"§module Spec
  module Example
    class ExampleMatcher
      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@fiI"Ë  module Spec
    module Runner
      class HeckleRunner
        def function(arglist)
          @var = var
          @var = var
        end
        
        # Runs all the example groups held by +rspec_options+ once for each of the;Fi[	@Ò4iI"¥module StateMachine
  class HelperModule < Module
    def function(arglist)
      @var = var
      @var = var
    end
    
    # Provides a human-readable description of the module;Fi[@'@¸@ˇ,I"@var = true;Fi[[	@CiGI"ª        else
          SavepointTransaction.new(connection, self, var)
        end
      end
      
      def function(arglist)
        @var = true
        perform_rollback
        parent;Fi[	@CiMI"¢        @var = true
        perform_rollback
        parent
      end
      
      def function(arglist)
        @var = true
        perform_commit
        parent;Fi[	@XiI"û        @var = var["name"]
        @var = var["version"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@Xi"I"à      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@_iI"Ì        @var = false
        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@_iI"à      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@gi=I"î      
      def function(arglist)
        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@giGI"ê      
      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@’iI"É      
      def function(arglist)
        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@iiZI"Ã        var = @var.to_sexp
        var = (var + var) if var.any?
        var
      end
      
      def function(arglist)
        @var = true
        @var = var
        @var.visit_exception(@var, :failed);Fi[	@`(iI"†    def function(arglist)
      super("Undefined step: \"#{step_name}\"")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    ;Fi[	@«i}I"ß            @var.br
          end
        end
      end
      
      def function(arglist)
        @var = true
        (@var << "<div class=\"background\">")
      end;Fi[	@«iÇI"       def function(arglist)
        @var = nil
        (@var << "</div>")
      end
      
      def function(arglist)
        @var = true
        @var.h3(:id => ("background_#{@scenario_number}")) do |arglist|
          @var.span(var, :class => "keyword");Fi[	@ﬁi2I"Î        write_file(feature_result_filename(var.file), @var.target!)
        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@ﬁiSI"           @var = (@var + "\nMessage:\n")
        end
        build_testcase(var, var.status, var.exception)
      end
      
      def function(arglist)
        @var = true
        @var = true
      end;Fi[	@Èi=I"∂        return unless @var
        var ||= @var
        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@Ïi6I"ï          end
        end
        @var = false if @var
      end
      
      def function(arglist)
        @var = true
        @var = true
      end;Fi[	@äi™I"›      def function(arglist)
        super
        confirm! unless confirmed?
      end
      
      def function(arglist)
        @var = true
        self.unconfirmed_email = self.email
        self.email = self.email_was;Fi[	@œiI"⁄  def function(arglist)
    @var = current_user.contacts.sharing.includes(:aspect_memberships)
    render(:layout => (false))
  end
  
  def function(arglist)
    @var = true
    @var = Person.community_spotlight
  end;Fi[	@h$i/I"≈      label_field(var, var)
      input_field("password", var)
      self
    end
    
    def function(arglist)
      @var = true
      (@var << "\n<button type='submit'>#{text}</button>")
    end;Fi[	@bi"I"ˆ        end
        eval_block if @var and (@var and @var) unless negative_expectation?
        @var.&(@var) ? (@var ? (@var) : (true)) : (false)
      end
      
      def function(arglist)
        @var = true
        begin
          (@var[@var];Fi[	@iüI"ë      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      ;Fi[	@ƒ3iI"ì  
  def function(arglist)
    return plugin_manager.process_filters(var, :from_guzzoni)
  end
  
  def function(arglist)
    @var = true
  end
end;Fi[I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];TI"#;Ti[[	@îi,I"4      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@îieI"Ø      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #   person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=4;Ti[	@îi~I"X      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #;Ti[	@îiúI"U      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #;Ti[	@îiI"p      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')])
      #   person.pets.size # => 5;Ti[	@îi@I"1      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@îiGI"O      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0
      #   person.pets      # => [];Ti[	@îiaI"1      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@îihI"R      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@îizI"1      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [;Ti[	@îiÅI"R      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3)
      #   # => ActiveRecord::RecordNotFound;Ti[	@îióI")      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all
      #;Ti[	@îi∑I"j      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@îi¡I"5      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>;Ti[	@îi”I"G      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3))
      #   # => [;Ti[	@îiÔI"j      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@îi˘I"=      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1)
      #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=1;Ti[	@îiI"b      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1")
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@îi'I"k      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];Ti[	@îi1I"'      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [;Ti[	@îi7I"-      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => [];Ti[	@îióI"ó      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3
      #   # Because the collection is already loaded, this will behave like;Ti[I"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;T@∑<@∏<I"#   #    ];Ti[[	@îi+I"+      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name);Ti[	@îidI"Z      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@îi}I"X      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@îiõI"U      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îi·I"H      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.create(var, &var);Ti[	@îi
I"i      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')]);Ti[	@îi?I"B      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@îiFI"4      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 0;Ti[	@îi`I"B      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@îigI".      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@îiyI"B      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all;Ti[	@îiÄI".      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1, 2, 3);Ti[	@îiñI"C      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy_all;Ti[	@îi∂I"K      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@îi“I"X      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1), Pet.find(3));Ti[	@îiÓI"K      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete(Pet.find(1));Ti[	@îi
I"C      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete("1");Ti[	@îi&I"L      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1));Ti[	@îi~I"S      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var);Ti[	@îiñI"S      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size # => 3;Ti[	@îi≤I"c      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length;Ti[I"#   # => [;F@È<@∑<@∏<i[[	@îi*I"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îicI"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi|I"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îiöI"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi‡I"L      #   person.pets.count # => 3
      #
      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist);Ti[	@îi	I""      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi>I")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îiEI"#      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi_I")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îifI"#      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îixI")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îiI"#      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îiïI")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îiµI")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi—I")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îiÌI")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi	I")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi%I")      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi}I">      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist);Ti[	@îiïI"é      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #
      #   person.pets # This will execute a SELECT * FROM query
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi±I"Ö      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist);Ti[@'@¸@ˇ,I"var = {};Fi[[	@KiI"            end
            @var = var
            @var = compute_type
          end
          
          def function(arglist)
            var = {}
            var[:encoding] = "base64" if (type == :binary)
            var[:type] = (type == :string) ? (nil) : (type);Fi[	@}iìI"p      
      def function(arglist)
        loaded?.! and ((owner.new_record?.! or foreign_key_present?) and klass)
      end
      
      def function(arglist)
        var = {}
        if ((reflection.macro == :has_one) or (reflection.macro == :has_many)) and options[:through].! then
          var[reflection.foreign_key] = owner[reflection.active_record_primary_key];Fi[	@ãiÏI":      # Equivalent to +collection.size > 1+.
      def function(arglist)
        block_given? ? (load_target.many? { |arglist| yield(*var) }) : ((size > 1))
      end
      
      def function(arglist)
        var = {}
        load_target.find_all { |arglist| var[var.id] = true unless var.key?(var.id) }
      end;Fi[	@iPI"M        var = var.map { |arglist| var.message }.join(",")
        raise(MultiparameterAssignmentErrors.new(var), "#{errors.size} error(s) on assignment of multiparameter attributes [#{error_descriptions}]")
      end
    end
    
    def function(arglist)
      var = {}
      var.each do |arglist|
        var = var.split("(").first;Fi[	@IiyI"	        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end
      
      def function(arglist)
        var = {}
        if var = columns(var).find { |arglist| (var.name == var.to_s) } then
          var[:default] = var.default;Fi[	@%i+I"–        super
        @var = var.required_by.dup
        @var = var.activated.dup
      end
      
      def function(arglist)
        var = {}
        @var.each do |arglist|
          if var = @var[var] then;Fi[	@%iÑI"Î    
    def function(arglist)
      var.values.map { |arglist| var.to_specs }.flatten.compact
    end
    
    def function(arglist)
      var = {}
      @var = Hash[var.map { |arglist| [var, gems_size(var)] }]
      resolve(var, var);Fi[	@=i%I"9      var = ENV.keys.select { |arglist| var =~ /BUNDLE_.*/ }
      var = @var.keys.|(@var.keys).|(var)
      var.map { |arglist| var.sub(/^BUNDLE_/, "").gsub(/__/, ".").downcase }
    end
    
    def function(arglist)
      var = {}
      all.each { |arglist| var[$'] = self[var] if var =~ /^local\./ }
      var;Fi[	@§iÃI"ì      var[:subject] = ((var.class == Class) ? (var) : (var.class)).to_s.underscore.humanize.downcase
      var = I18n.translate(nil, var.merge(:scope => :unauthorized, :default => ((var + [""]))))
      var.blank? ? (nil) : (var)
    end
    
    def function(arglist)
      var = {}
      relevant_rules(var, var).map do |arglist|
        var.merge!(var.attributes_from_conditions) if var.base_behavior;Fi[	@“iDI"$    
    def function(arglist)
      @var.respond_to?(:keys) and (@var.present? and @var.keys.first.kind_of?(Symbol).!)
    end
    
    def function(arglist)
      var = {}
      if var.kind_of?(Hash) then
        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) };Fi[	@“iLI"‡        var.map { |arglist| var[var] = associations_hash(var) if var.kind_of?(Hash) }
      end
      var
    end
    
    def function(arglist)
      var = {}
      if @var.kind_of?(Hash) then
        @var.each do |arglist|;Fi[	@iƒI"             (var << var.last.inherited_data)
          end
          var
        end
        
        def function(arglist)
          var = {}
          ATTRIBUTES.each do |arglist|
            var = [];Fi[	@riUI"æ      else
        scope_path
      end
    end
    
    def function(arglist)
      var = {}
      var = :"new_#{scope}_session_path"
      var[:format] = request_format unless skip_format?;Fi[	I"8data//diaspora_proj/helpers/aspect_global_helper.rb;TiI"  
  def function(arglist)
    ((@var == :profile) or ((@var == :tag) or ((@var == :search) or ((@var == :notification) or (params[:action] == "getting_started")))))
  end
  
  def function(arglist)
    var = {}
    var.each { |arglist| var[var.to_s] = var.id }
    var;Fi[	@‰iŒI"é        end
      end
      var
    end
    
    def function(arglist)
      var = {}
      var = StringScanner.new(var)
      var.scan(/\s+/);Fi[	@Ù#iI"·      (var << var) if var and (var.rack.exist? and (var.rack.subdirs.length > 0))
    end
    var
  end
  
  def function(arglist)
    var = {}
    var.each do |arglist|
      var = var.recursive_deps.uniq.reject do |arglist|;Fi[	@i&I"ö      else
        []
      end
    end
    
    def function(arglist)
      var = {}
      var["warnings"] = []
      var["nokogiri"] = Nokogiri::VERSION;Fi[	@LiI"Ï    var = "ETenms-B5-H"
    var = { "ordering" => "CNS1", "supplement" => 0 }
    AddCIDFonts(var, var, var, var, var)
  end
  
  def function(arglist)
    var = {}
    32.upto(126) { |arglist| var[var.chr] = 500 }
    var = "ETen-B5-H";Fi[	@™iõI"        var[:image].stroke("transparent")
        var[:image].stroke_width(1)
        var[:image].text(var[:indent], (var[:top] + 2), var)
      end
      
      def function(arglist)
        var = {}
        if relations[var.id] then
          relations[var.id].each do |arglist|;Fi[	@„i3I"        rescue NameError
          __mock_proxy.raise_unexpected_message_error(var, *var)
        end
      end
      
      def function(arglist)
        var = {}
        extract_option(var, var, :null_object)
        extract_option(var, var, :__declared_as, "Mock");Fi[I"*#   class Person < ActiveRecord::Base;FI"#     has_many :pets;TI"#   end;TI"#;Ti[[	@îi%I"„      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@îi^I"      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@îi|I"      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@îiïI"      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@îiI"H      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>];Ti[	@îièI"Ù      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@îiI"      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@îiI"3      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets;Ti[	@îieI"ﬂ      
      # Specifies whether the records should be unique or not.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.select(:name)
      #   # => [;Ti[	@îiwI"…      
      # Count all records using SQL.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 3
      #   person.pets;Ti[	@îiçI"z      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1;Ti[	@îißI"      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.length # => 3
      #   # executes something like SELECT "pets".* FROM "pets" WHERE "pets"."person_id" = 1;Ti[	@îi¡I">      # not already been loaded and you are going to fetch the records anyway it
      # is better to check <tt>collection.length.zero?</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count  # => 1
      #   person.pets.empty? # => false;Ti[	@îi“I"Ï      
      # Returns +true+ if the collection is not empty.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 0
      #   person.pets.any?  # => false;Ti[	@îiÙI"!      # Returns true if the collection has more than one record.
      # Equivalent to <tt>collection.size > 1</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count #=> 1
      #   person.pets.many? #=> false;Ti[	@îiI"ˆ      
      # Returns +true+ if the given object is present in the collection.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # => [#<Pet id: 20, name: "Snoop">]
      #;Ti[	@îiAI"Á      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@îi[I"      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [;Ti[	@îiÉI"/      # to the association√¢¬Ä¬òs primary key. Returns +self+, so several appends may be
      # chained together.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 0
      #   person.pets << Pet.new(name: 'Fancy-Fancy');Ti[	@îi§I"X      # Reloads the collection from the database. Returns +self+.
      # Equivalent to <tt>collection(true)</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # fetches pets from the database
      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>];Ti[I"#;F@p=@q=I"#   end;Ti[[	@îi$I"Ì      # Works in two ways.
      #
      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@îi]I"Y      # Finds an object in the collection responding to the +id+. Uses the same
      # rules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>
      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@îi{I"A      # Returns the first record, or the first +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@îiîI"?      # Returns the last record, or the last +n+ records, from the collection.
      # If the collection is empty, the first form returns +nil+, and the second
      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@îiI"      
      # Replace this collection with +other_array+. This will perform a diff
      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@îiéI"(      # Deletes the records of the collection directly from the database.
      # This will _always_ remove the records ignoring the +:dependent+
      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@îiI"      #
      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@îiI"k      # Destroys the +records+ supplied and removes them from the collection.
      # This method will _always_ remove record from the database ignoring
      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@îidI"ÿ      end
      
      # Specifies whether the records should be unique or not.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.select(:name);Ti[	@îivI"Ω      end
      
      # Count all records using SQL.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 3;Ti[	@îiåI"g      # If the collection has been already loaded +size+ and +length+ are
      # equivalent. If not and you are going to need the records anyway
      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3;Ti[	@îi¶I"m      # If the collection has been already loaded, +length+ and +size+ are
      # equivalent. If not and you are going to need the records anyway this
      # method will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.length # => 3;Ti[	@îi¿I"e      # it is equivalent to <tt>collection.exists?</tt>. If the collection has
      # not already been loaded and you are going to fetch the records anyway it
      # is better to check <tt>collection.length.zero?</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count  # => 1;Ti[	@îi—I"œ      end
      
      # Returns +true+ if the collection is not empty.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count # => 0;Ti[	@îiÛI"      
      # Returns true if the collection has more than one record.
      # Equivalent to <tt>collection.size > 1</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.count #=> 1;Ti[	@îiI"¯      end
      
      # Returns +true+ if the given object is present in the collection.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # => [#<Pet id: 20, name: "Snoop">];Ti[	@îi@I"      # contain the same number of elements and if each element is equal
      # to the corresponding element in the other array, otherwise returns
      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@îiZI"      
      # Returns a new array of objects from the collection. If the collection
      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets;Ti[	@îiÇI"L      # Adds one or more +records+ to the collection by setting their foreign keys
      # to the association√¢¬Ä¬òs primary key. Returns +self+, so several appends may be
      # chained together.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 0;Ti[	@îi£I"      
      # Reloads the collection from the database. Returns +self+.
      # Equivalent to <tt>collection(true)</tt>.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets # fetches pets from the database;Ti[@	)I"raise(NotImplementedError);FI"end;FI" ;Fi[[	@≤i9I"ô      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options;Fi[	@ãipI"      end
      
      # Do the relevant stuff to insert the given record into the association collection.
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        scope.scope_for_create.stringify_keys;Fi[	@ãiåI"6      
      # Delete the given records from the association, using one of the methods :destroy,
      # :delete_all or :nullify (or nil, in which case a default is used).
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        delete((target - var));Fi[	@∏iI"˙          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # An Arel::Table for the active_record
        def function(arglist);Fi[	@∏iI"        end
        
        # An Arel::Table for the active_record
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # The prefix to be used when aliasing columns in the active_record's table
        def function(arglist);Fi[	@∏i!I"        end
        
        # The prefix to be used when aliasing columns in the active_record's table
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # The alias for the active_record's table
        def function(arglist);Fi[	@∏i&I"        end
        
        # The alias for the active_record's table
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # The alias for the primary key of the active_record's table
        def function(arglist);Fi[	@√iI"Ù          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope;Fi[	@√i*I"        end
        
        # The name of the key on the associated records
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # This is overridden by HABTM as the condition should be on the foreign_key column in
        # the join table;Fi[	@√i5I"R        end
        
        # The name of the key on the model which declares the association
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # We're converting to a string here because postgres will return the aliased association
        # key in a habtm as a string (for whatever reason);Fi[	@Ii(I"        end
        
        # Must return the relevant concrete adapter
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          collation and collation.match(/_ci$/).!;Fi[	@Ii≠I"õ      # HELPER METHODS ===========================================
      # The two drivers have slightly different ways of yielding hashes of results, so
      # this method must be implemented to provide a uniform interface.
      def function(arglist)
        raise(NotImplementedError)
      end
      
      # Overridden by the adapters to instantiate their specific Column type.
      def function(arglist);Fi[	@Ii∏I""      
      # Must return the Mysql error number from the exception, if the exception has an
      # error number.
      def function(arglist)
        raise(NotImplementedError)
      end
      
      # QUOTING ==================================================
      def function(arglist);Fi[	@íiI"≤        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@íiI"¬        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@íiI"¬        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@íiI"¬        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@íiI"¬        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@íi#I"¬        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError);Fi[	@≥i&I"H    # @abstract This method is called when the user is on the request path. You should
    # perform any information gathering you need to be able to authenticate
    # the user in this phase.
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      self.class.uid_stack(self).last;Fi[@(@(I"end;FI" ;Fi[[	@CiI"±      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    
    class ClosedTransaction < Transaction
      def function(arglist);Fi[	@ÉiôI"˛        def function(arglist)
          if var then
            execute("SET search_path TO #{schema_csv}", "SCHEMA")
            @var = var
          end
        end
        
        # Returns the active schema search path.
        def function(arglist);Fi[	@¢6i/I"ä    
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class RecordNotUnique < WrappedDatabaseException
  end;Fi[	@¢6iBI"÷    def function(arglist)
      super("Attempted to #{attempted_action} a stale object: #{record.class.name}")
      @var = var
      @var = var
    end
  end
  
  class ConfigurationError < ActiveRecordError
  end;Fi[	@¢6i[I"±    def function(arglist)
      super(var)
      @var = var
      @var = var
    end
  end
  
  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors);Fi[	@¢6icI"ü    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  
  class UnknownPrimaryKey < ActiveRecordError
    attr_reader(:model);Fi[	@¢6ilI"»    
    def function(arglist)
      super("Unknown primary key for table #{model.table_name} in model #{model}.")
      @var = var
    end
  end
  
  class ImmutableRelation < ActiveRecordError
  end;Fi[	@
i°I"±        (@var, var = var, @var
        yield)
      ensure
        @var = var
      end
    end
    
    def function(arglist)
      var = caller[0].split(":")[(0..1)].join(":");Fi[	@iI"    end
    
    def self.shell=(arglist)
      @var = var
    end
  end
  
  module Shell
    SHELL_DELEGATED_METHODS = [:ask, :error, :set_color, :yes?, :no?, :say, :say_status, :print_in_columns, :print_table, :print_wrapped, :file_collision, :terminal_width];Fi[	@ñiI"¥        
        def function(arglist)
          super("Tables were not identical")
          @var = var
        end
      end
      
      class Builder
        attr_reader(:rows);Fi[	@niI"‚        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      
      # Remembers the given resource by setting up a cookie
      def function(arglist);Fi[	@<iI"ê          end
        end)
      ensure
        @var = var
      end
    end
    
    if (RUBY_VERSION < "1.9") then
      attr_reader :function;Fi[	I""data//haml_proj/haml/error.rb;TiI"ñ    # @param line [Fixnum] See \{#line}
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class SyntaxError < Error
  end;Fi[	@Äi,I"ó    @var = var
    unless var.nil? then
      @var = var.delete(:using)
      @var = var
    end
  end
  
  def function(arglist)
    @var ||= case var;Fi[	@Â	iI"·        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      
      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError
        attr_reader(:errors);Fi[	@3iI"©      else
        @var = var.to_f
        @var = var.to_f
        @var = var
      end
    end
    
    def self.from_file(arglist)
      GeometryDetector.new(var).make;Fi[	@UiBI"        @var = @var
      end
      @var = (@var - @var)
      @var = var
    end
  end
  
  def function(arglist)
    @var = 1;Fi[	@ciw	I"}        @var = @var
      end
      @var = (@var - @var)
      @var = var
    end
  end
  
  #
  	# End of page contents;Fi[	@bi*I"¨          (@var[@var]
          @var = true)
        rescue Exception => var
          @var = var
        end
      end
      
      def function(arglist)
        case @var;Fi[@(@ó4I"@var = var;FI"@var = var;Fi[[	@√iI"
        attr_reader(:owners, :reflection, :preload_scope, :model, :klass)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var.first and var.first.class)
          @var = nil;Fi[	@ﬂieI"      # <tt>has_many :clients</tt> returns +{}+
      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s);Fi[	@ﬂifI"·      # :nodoc:
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var
        @var = var.pluralize_table_names ? (var.to_s.pluralize) : (var.to_s)
      end;Fi[	@6iI"ä    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@iI"ù    GRAPH_NAME = :Gemfile
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = [];Fi[	@iI"∫    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = []
      @var = Hash.new { |arglist| var[var] = Set.new };Fi[	@"iI"ä    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@CiI"€        attr_writer(:revision)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = (var or Proc.new { |arglist| true })
        end;Fi[	@¬i#I"†    attr_reader(:transfers)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var;Fi[	@¬i$I"®    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var.fetch(:via, :sftp);Fi[	@¬i%I"ƒ    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var
      @var = var.fetch(:via, :sftp)
      @var = var.delete(:logger);Fi[	@Wi$I"        end
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var["cleanup"] ||= Sass::Script::Bool.new(true)
          @var["layout"] ||= Sass::Script::String.new("vertical");Fi[	@i+I"–        include(::Rake::DSL) if defined? ::Rake::DSL
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end;Fi[	@i,I"§        
        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        ;Fi[	@ti&I"/  end
  
  def function(arglist)
    @var = var
    @var = var
    @var = var
    @var = var
    var = { :to => (var), :from => (AppConfig.mail.sender_address), :subject => (I18n.t("notifier.invited_you", :name => (@var.name))), :host => (AppConfig.pod_uri.host) }
    I18n.with_locale(var) do |arglist|;Fi[	@≠9iI"    # dir  - The String path between the source and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      self.process(var)
      self.read_yaml(File.join(var, var), var);Fi[	@÷4iI"‘    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    ;Fi[	@iI"¸      # The string name of the queue from which the failed job was pulled
      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      ;Fi[	@∏9iI"    # @param method_options [Hash]
    # @return [Twitter::Cursor]
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
      @var = Array(var[var.to_sym]).map do |arglist|
        var ? (var.fetch_or_new(var)) : (var);Fi[@'@¸@ˇ,I"var = [];Fi[[	@iAI"O    # f for Float. If all the values for a given attribute are empty, the attribute will be set to +nil+.
    def function(arglist)
      execute_callstack_for_multiparameter_attributes(extract_callstack_for_multiparameter_attributes(var))
    end
    
    def function(arglist)
      var = []
      var.each do |arglist|
        begin;Fi[	@Qi}I"        def function(arglist)
          var = 1
          (("+" + var.map { |arglist| ("-" * (var + (var * 2))) }.join("+")) + "+")
        end
        
        def function(arglist)
          var = []
          var.each_with_index do |arglist|
            var = "NULL" if var.nil?;Fi[	@ i¢I"Ô    
    def function(arglist)
      @var ||= expand_dependencies(dependencies, @var)
    end
    
    def function(arglist)
      var = []
      var.each do |arglist|
        var = Dependency.new(var, ">= 0") unless var.respond_to?(:name);Fi[	@Â8i(I"Ö        end
      end
      true
    end
    
    def function(arglist)
      var = []
      sessions.each do |arglist|
        begin;Fi[	@·i
I"0    module Adapters
      def function(arglist)
        [project_path, sass_path, css_path, to_sass_engine_options.merge(var)]
      end
      
      def function(arglist)
        var = []
        (var << [sass_path, css_path]) if sass_path and css_path
        Compass::Frameworks::ALL.each do |arglist|;Fi[	@·i<I"&        var[:cache_location] = cache_path
        var[:quiet] = disable_warnings if disable_warnings
        var.merge!((sass_options or {}))
      end
      
      def function(arglist)
        var = []
        (var << sass_path) if sass_path
        Compass::Frameworks::ALL.each do |arglist|;Fi[	@«i-I""          else
            "# Couldn't get snippet for #{file}"
          end
        end
        
        def function(arglist)
          var = []
          var.split("\n").each_with_index do |arglist|
            var = "<span class=\"linenum\">#{((offending_line + i) - 2)}</span>#{line}";Fi[	@2i'I"        log.debug("Parsing feature files took #{format_duration(duration)}\n\n")
        check_tag_limits(var)
        @var = var
      end
      
      def function(arglist)
        var = []
        @var.limits.each do |arglist|
          var = (var[var] or []);Fi[	@Xi
I"•  
  def function(arglist)
    @var = var
  end
  
  def function(arglist)
    var = []
    (var << f.caveats)
    (var << f.keg_only_text) rescue nil if f.keg_only?;Fi[	@Xi,I"i    if keg and keg.completion_installed?(:zsh) then
      "      zsh completion has been installed to:\n        #{HOMEBREW_PREFIX}/share/zsh/site-functions\n".undent
    end
  end
  
  def function(arglist)
    var = []
    if (f.plist or (keg and keg.plist_installed?)) then
      var = f.plist_startup ? ("/Library/LaunchDaemons") : ("~/Library/LaunchAgents");Fi[	@di^I"#      problem("'__END__' was found, but 'DATA' is not used")
    end
    problem("File should end with a newline") if f.text.has_trailing_newline?
  end
  
  def function(arglist)
    var = []
    var = Formula.aliases
    f.deps.select { |arglist| var.include?(var.name) }.each do |arglist|;Fi[	@ziMI"j        end
      end
    end
  end
  
  def function(arglist)
    var = []
    var = []
    var = "";Fi[	@∂i>I"⁄    join("lib").find do |arglist|
      break var if (var.basename == Pathname.new(var))
    end
  end
  
  def function(arglist)
    var = []
    var = ["bin", "lib", "Frameworks"]
    var.map! { |arglist| join(var) };Fi[	@}iNI"ä      end
      match(var, var)
      1
    end
    
    def function(arglist)
      var = []
      @var.each do |arglist|
        var = 0;Fi[	@ijI"%          if (new_record? or custom_field_values_changed?) then
            custom_field_values.each(&:validate_value)
          end
        end
        
        def function(arglist)
          var = []
          custom_field_values.each do |arglist|
            if var.value.is_a?(Array) then;Fi[	@∏i3I"      def function(arglist)
        var = ((first_item + per_page) - 1)
        (var > item_count) ? (item_count) : (var)
      end
      
      def function(arglist)
        var = []
        if (item_count > 0) then
          var = (var + [first_page, page, last_page]);Fi[	@iîI"        var = (scale_x_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_x_integers
        [var, var, var]
      end
      
      def function(arglist)
        var = []
        var, var, var = x_range
        if timescale_divisions then;Fi[	@Ui5I""          else
            "# Couldn't get snippet for #{file}"
          end
        end
        
        def function(arglist)
          var = []
          var.split("\n").each_with_index do |arglist|
            var = "<span class=\"linenum\">#{((offending_line + i) - 2)}</span>#{line}";Fi[	@qi‡I"      def function(arglist)
        return examples.size unless examples.empty?
        @var.inject(0) { |arglist| (var + var.number_of_examples) }
      end
      
      def function(arglist)
        var = []
        sorted_files.each do |arglist|
          if File.directory?(var) then;Fi[@è7@ê7@ë7I"end;Fi[[	@iÇI"∫          if self.class.serialized_attributes.include?(var) then
            @var[var].serialized_value
          else
            super
          end
        end
      end
    end
  end;Fi[	@ki1I"÷              super
              last_insert_id_value((var or default_sequence_name(var, var)))
            else
              super
            end
          end
        end
        
        def function(arglist);Fi[	@çiI"¢        when /column(s)? .* (is|are) not unique/ then
          RecordNotUnique.new(var, var)
        else
          super
        end
      end
    end
  end
end;Fi[	@‚i'I"Ω        def function(arglist)
          @var.synchronize do |arglist|
            return if method_defined?(var)
            super
          end
        end
      end
      
      protected;Fi[	@‚i;I"æ              self.class.delegate(var, :to => :arel)
              arel.send(var, *var, &var)
            else
              super
            end
          end
        end
      end
    end;Fi[	@XikI"µ          self.class.log_deprecation_warning(var, var)
          var[:action].call(self, var[0]) if var[:action]
        else
          super
        end
      end
    end
  end
end;Fi[	@"i5I"û      if Gem::Specification.new.respond_to?(var) then
        _remote_specification.send(var, *var, &var)
      else
        super
      end
    end
  end
end;Fi[	@˜iQI"÷              if configuration.respond_to?(var) then
                configuration.send(var, *var, &var)
              else
                super
              end
            end
          end
        end
        ;Fi[	I"0data//cucumber_prok/cucumber/step_mother.rb;Ti
I"Â  class StepMother < Runtime
    def function(arglist)
      warn("StepMother has been deprecated and will be gently put to sleep at the next major release. Please use Runtime instead. #{caller[0]}")
      super
    end
  end
end;Fi[	@íi^I"¡          if lock_strategy_enabled?(:failed_attempts) and attempts_exceeded? then
            :locked
          else
            super
          end
        end
      end
      
      protected;Fi[	@‰iI"∑        if var.try(:localized?) and var.blank?.! then
          var.values.each { |arglist| super(var, var, var) }
        else
          super
        end
      end
    end
  end
end;Fi[	@5iI"∆        var = Time.now.strftime("%y%m%d")
        var = "#{prefix}#{t}-#{$$}-#{rand(4294967296).to_s(36)}-#{n}#{suffix}"
      else
        super
      end
    end
  end
  
  module TempfileEncoding;Fi[	@5i&I"¿    # in JRuby
    def function(arglist)
      set_encoding("ASCII-8BIT")
      super
    end
  end
end
if RUBY_PLATFORM =~ /java/ then
  ::Tempfile.send(:include, Paperclip::TempfileEncoding);Fi[	I"5data//rspec_proj/spec/matchers/method_missing.rb;Ti
I"Õ    def function(arglist)
      return Matchers::BePredicate.new(var, *var, &var) if var.to_s =~ /^be_/
      return Matchers::Has.new(var, *var, &var) if var.to_s =~ /^have_/
      super
    end
  end
end;Fi[	@èiI"∂        end
        def function(arglist)
          owner_class.set_callback(:validation, :after, "value", :prepend => (true))
          super
        end
      end
    end
  end
end;Fi[	@óikI"ø          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	@≤iÜI"ç      # DataMapper/Extlib callbacks
      def function(arglist)
        var[:bind_to_object] = true
        super
      end
    end
  end
end;Fi[	@µiSI"ø          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end
end;Fi[	@ i§I"±      def function(arglist)
        var[:bind_to_object] = true
        var[:terminator] = @var ||= lambda { |arglist| (var == false) }
        super
      end
    end
  end
end;Fi[@'@¸I"module ClassMethods;FI"def function(arglist);Fi[[	@i*I"‘      
      def function(arglist)
        ((var == "id") or super)
      end
      
      module ClassMethods
        def function(arglist)
          super
          if (var == primary_key) and var.!=("id") then;Fi[	@ïiI"2      self.timestamped_migrations = true
      class_attribute(:connection_handler, :instance_writer => (false))
      self.connection_handler = ConnectionAdapters::ConnectionHandler.new
    end
    
    module ClassMethods
      def function(arglist)
        var.initialize_generated_modules
        super;Fi[	@⁄i&I"J        if ActiveRecord::Base.connected? then
          var[:db_runtime] = ((db_runtime or 0) + ActiveRecord::LogSubscriber.reset_runtime)
        end
      end
      
      module ClassMethods
        def function(arglist)
          var, var = super, var[:db_runtime]
          (var << ("ActiveRecord: %.1fms" % var.to_f)) if var;Fi[	@ﬂiI"¯    included do |arglist|
      class_attribute(:reflections)
      self.reflections = {}
    end
    
    module ClassMethods
      def function(arglist)
        case var
        when :has_many, :belongs_to, :has_one, :has_and_belongs_to_many then;Fi[	@iI"H    included do |arglist|
      class_attribute(:stored_attributes, :instance_accessor => (false))
      self.stored_attributes = {}
    end
    
    module ClassMethods
      def function(arglist)
        serialize(var, IndifferentCoder.new(var[:coder]))
        store_accessor(var, var[:accessors]) if var.has_key?(:accessors);Fi[	@iI"        var.send(:attr_accessor, :inherited_data, :set_attributes, :top_level)
        var.send(:include, InstanceMethods)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          var.each do |arglist|
            var = (20 + 1);Fi[	@$i2I"E  module Gradient
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end;Fi[	@iiI"Ú      
      included do |arglist|
        helper_method(:warden, :signed_in?, :devise_controller?)
      end
      
      module ClassMethods
        def function(arglist)
          var[:status] ||= 401 unless var[:exception]
          super;Fi[	@¶i+I"      
      def function(arglist)
        self.class.expire_auth_token_on_timeout
      end
      
      module ClassMethods
        def function(arglist)
          find_for_authentication(:authentication_token => (var[token_authentication_key]))
        end;Fi[	@§iI"        class_option(:form_builder, :aliases => "-b")
        class_option(:markerb)
        public_task(:copy_views)
      end
      
      module ClassMethods
        def function(arglist)
          Rails::Generators.hide_namespace(self.namespace)
        end;Fi[	@â
i«I"‹    # @since 3.0.0
    def function(arglist)
      Operations.upsert(self, var).persist
    end
    
    module ClassMethods
      def function(arglist)
        _creating do |arglist|
          if var.is_a?(::Array) then;Fi[	@i
I"D    module ActivityProvider
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          unless self.included_modules.include?(Redmine::Acts::ActivityProvider::InstanceMethods) then
            cattr_accessor(:activity_provider_options);Fi[	@i
I"ı    module Attachable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          cattr_accessor(:attachable_options)
          self.attachable_options = {};Fi[	@i
I"    module Customizable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Customizable::InstanceMethods) then
            return;Fi[	@i
I"    module Event
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Event::InstanceMethods) then
            return;Fi[	@2i
I"    module Watchable
      def self.included(arglist)
        var.extend(ClassMethods)
      end
      
      module ClassMethods
        def function(arglist)
          if self.included_modules.include?(Redmine::Acts::Watchable::InstanceMethods) then
            return;Fi[	@”iI"⁄    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = breakdown_rfpdf_options(var)
        write_inheritable_hash(:rfpdf, var);Fi[	@√i	I"∑  module SubclassFactory
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods
      def function(arglist)
        var = nil
        begin;Fi[@	)@
)@)I"end;Fi[[	@iGI"5    # Hook method that gets called by the initializer allowing verification
    # that the arguments supplied are valid. You could for example raise an
    # +ArgumentError+ when invalid options are supplied.
    def function(arglist)
      # do nothing
    end
  end
  
  class BlockValidator < EachValidator;Fi[	@Ci%I"ª      end
      
      # This is a noop when there are no open transactions
      def function(arglist)
        # do nothing
      end
    end
    
    class OpenTransaction < Transaction;Fi[	@i0i(I"z      @var.lock(Bundler.default_lockfile)
    end
    
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@6iI"ërequire("rubygems/installer")
module Bundler
  class GemInstaller < Gem::Installer
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@x0iI"cclass Ability
  include(CanCan::Ability)
  
  def function(arglist)
    # do nothing
  end
end;Fi[	@äiI"§          StepCollection.new(var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@ñiI"ò          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Enumerable);Fi[	@i\I"Ü      
      attr_reader :function
      
      def function(arglist)
        # do nothing
      end
    end
    
    class JsLanguage;Fi[	@=iI"‹          @var.invoke(var.name, Ast::MultilineArgument.from((var.doc_string or var.rows)))
        end
        
        def function(arglist)
          # do nothing
        end
      end
      
      include(Constantize);Fi[	@±0i'I"Õ    return var
  end
  
  def function(arglist)
    # do nothing
  end
end
require(Rails.root.join("app", "models", "services", "facebook"))
require(Rails.root.join("app", "models", "services", "twitter"));Fi[	@$9i%I"å  end
end
class NilClass
  def function(arglist)
    # do nothing
  end
end
module StringInreplaceExtension
  # Warn if nothing was replaced;Fi[	@*6i&I"î    # config - The Hash of configuration options.
    #
    # Returns a new instance.
    def function(arglist)
      # do nothing
    end
  end
end;Fi[	@uiI"êmodule Nokogiri
  module XML
    class ProcessingInstruction < Node
      def function(arglist)
        # do nothing
      end
    end
  end
end;Fi[	@}ilI"ˆ        # Called when processing instructions are found
        # +name+ is the target of the instruction
        # +content+ is the value of the instruction
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@%ièI"‹        end
        
        # This method is invoked at the very end. Allows the formatter to clean up, like closing open streams.
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@/iI"Ñ          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@4iI"Ñ          # do nothing
        end
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[	@CiI"        
        private
        
        def function(arglist)
          # do nothing
        end
      end
    end
  end;Fi[I"@var = true;FI"end;FI" ;FI"def function(arglist);Fi[[	@ΩiâI"Ì      # Sets the value of inheritance_column
      def function(arglist)
        @var = var.to_s
        @var = true
      end
      
      def function(arglist)
        if (base_class == self) then
          @var ||= reset_sequence_name;Fi[	@Xi!I"ã      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@_iI"ã      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end;Fi[	@_i I"ç      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash
      end;Fi[	@giJI"†      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?
      end;Fi[	@˜i(I"®        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true
        end;Fi[	@GiI"Ë      
      def function(arglist)
        @var = var
        @var = true
      end
      
      def function(arglist)
        @var ||= "`#{command}' could not be found in the path on the local host"
        @var = find_in_path(var);Fi[	@«iñI"‹      
      def function(arglist)
        (@var << "</div>")
        @var = true
      end
      
      def function(arglist)
        @var.span(:class => "scenario_file") { |arglist| (@var << var) }
        @var = false;Fi[	@ŒiI"–        def function(arglist)
          @var = var
          @var = []
          @var = true
        end
        
        def function(arglist)
          (@var << var) if @var
          return @var.write(var);Fi[	@ﬁi5I"å      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@ﬁiWI"ñ      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@ÊiUI"£      def function(arglist)
        @var = 2
        @var = 2
        @var = true
      end
      
      def function(arglist)
        @var = nil
        @var.puts;Fi[	@ÊieI"≤      def function(arglist)
        @var = 4
        @var.puts
        @var = true
      end
      
      def function(arglist)
        @var.puts unless @var
        @var = false;Fi[	@Ïi:I"ñ      
      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@‚iPI"X        STDERR.puts("  Valid options are [ maruku | rdiscount | kramdown ]")
        raise(FatalException.new("Invalid Markdown process: #{@config["markdown"]}")))
      end
      @var = true
    end
    
    def function(arglist)
      var = (("(" + @var["markdown_ext"].gsub(",", "|")) + ")")
      var.=~(Regexp.new(var, Regexp::IGNORECASE));Fi[	@i=I"Î              var.value = var
            end
          end
          @var = true
        end
        
        def function(arglist)
          @var ||= available_custom_fields.collect do |arglist|
            var = CustomFieldValue.new;Fi[	@i¢I"é      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false
      end;Fi[	@qiI"µ      
      def function(arglist)
        return @var unless @var.nil?
        @var = true
      end
      
      def function(arglist)
        return unless var
        @var = var;Fi[@'@¸@g:I"# type.;Fi[[	@)	iPI"Ú      # @since 3.0.0
      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@)	iäI"˚          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@.	iI"÷      # @since 3.0.3
      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@8	iI"˚      # @since 3.0.0
      def function(arglist)
        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@8	i.I"        # @since 3.0.0
        def function(arglist)
          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@?	iI"˙          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@?	i4I"        # @since 3.0.0
        def function(arglist)
          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@L	ilI"ƒ          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@Z	i~I"¡        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@Z	i˘I"Á        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@d	iI"÷      # @since 3.0.0
      def function(arglist)
        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.;Fi[	@d	i:I"        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : (::Range.new(var["min"], var["max"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@n	i"I"Ú        # @since 3.0.0
        def function(arglist)
          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@s	i±I"Ú        # @since 3.0.0
        def function(arglist)
          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@x	i!I"Ù        # @since 3.0.0
        def function(arglist)
          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@}	i4I"ˆ            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@Ñ	i#I"        def function(arglist)
          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[@'@¸I"# :nodoc:;FI"def function(arglist);Fi[[	@i(I"π      
      def function(arglist)
        @var ||= false
      end
      
      # :nodoc:
      def function(arglist)
        super if attribute_methods_generated?
        @var = false;Fi[	@ΩiæI"*      # Returns a hash of column objects for the table associated with this class.
      def function(arglist)
        @var ||= Hash[columns.map { |arglist| [var.name, var] }]
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= decorate_columns(columns_hash.dup)
      end;Fi[	@Ûi?I"„    
    Relation::SINGLE_VALUE_METHODS.each do |arglist|
      class_eval("        def #{name}_value=(value)            # def readonly_value=(value)\n          raise ImmutableRelation if @loaded #   raise ImmutableRelation if @loaded\n          @values[:#{name}] = value          #   @values[:readonly] = value\n        end                                  # end\n", "(string)", (82 + 1))
    end
    
    # :nodoc:
    def function(arglist)
      (@var[:create_with] or {})
    end;Fi[	@˝icI"            ActiveSupport::Deprecation.warn("Calling #default_scope without a block is deprecated. For example instead of `default_scope where(color: 'red')`, please use `default_scope { where(color: 'red') }`. (Alternatively you can just redefine self.default_scope.)")
          end
          self.default_scopes = (default_scopes + [var])
        end
        
        # :nodoc:
        def function(arglist)
          if Base.is_a?(method(:default_scope).owner).! then
            evaluate_default_scope { |arglist| default_scope };Fi[	@oiÜI"ç    rescue IOError
      # do nothing
    end
  end
  
  # :nodoc:
  def function(arglist)
    if (RUBY_VERSION > "2.0") then
      Net::HTTP;Fi[	@iiI"9        def function(arglist)
          var = self.class.name.split("::").last
          var.group(2, "#(#{nice_name} ", ")") { |arglist| var.pp(text) }
        end
        
        # :nodoc:
        def function(arglist)
          "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{text.inspect}>"
        end;Fi[	@Ji.I"º      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist)
    if File.exist?("spec/spec.opts") then
      "-O #{File.join("spec", "spec.opts")} ";Fi[	@fiI"Õ        else
          Spec.warn(Spec::Example::NoDescriptionError.message("example", @var.location))
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var.options
      end;Fi[	@fi[I"”          end
        end
        raise(var) if var
      end
      
      # :nodoc:
      def function(arglist)
        instance_variables.inject({}) do |arglist|
          var[var] = instance_variable_get(var);Fi[	@ti&I"$      #   end
      def function(arglist)
        @var ||= Spec::HashWithDeprecationNotice.new("predicate_matchers", "the new Matcher DSL")
      end
      
      # :nodoc:
      def function(arglist)
        predicate_matchers.each_pair do |arglist|
          define_method(var) do |arglist|;Fi[	@˜i[I"I        yield(self) if block_given?
        @var = "spec/**/*_spec.rb" if pattern.nil? and spec_files.nil?
        define
      end
      
      # :nodoc:
      def function(arglist)
        var = File.expand_path(File.join(File.dirname("(string)"), "..", "..", "..", "bin", "spec"))
        var = libs.join(File::PATH_SEPARATOR);Fi[	@˜iÉI"∆          task(var => (var))
        end
        self
      end
      
      # :nodoc:
      def function(arglist)
        rcov ? ((ENV["RCOV_OPTS"] or (rcov_opts.join(" ") or ""))) : ("")
      end;Fi[	@˜iàI"D      # :nodoc:
      def function(arglist)
        rcov ? ((ENV["RCOV_OPTS"] or (rcov_opts.join(" ") or ""))) : ("")
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["RSPECOPTS"] then
          STDERR.puts("RSPECOPTS is DEPRECATED and will be removed in a future version. Use SPEC_OPTS instead.");Fi[	@˜iôI"ü        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["SPEC"] then
          FileList[ENV["SPEC"]];Fi[	@i,I"õ        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= mock_framework_path("rspec")
      end;Fi[	@iöI"¶      def function(arglist)
        @var ||= []
        @var = (@var + var)
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= []
      end;Fi[	@qiBI"      def function(arglist)
        require("rubygems") unless ENV["NO_RUBYGEMS"]
        require("ruby-debug")
      end
      
      # :nodoc:
      def function(arglist)
        require("pathname")
        @var ||= determine_project_root;Fi[@'@(@éI"module ClassMethods;Fi[[	@uiI"=      def function(arglist)
        var = options[:with]
        (var.method(var).arity == 0) ? (var.send(var)) : (var.send(var, var))
      end
    end
    
    module ClassMethods
      # Passes the record off to the class or classes specified and allows them
      # to add errors based on more complex conditions.;Fi[	@ûi)I"I      self.pre_loaded_fixtures = false
      self.fixture_class_names = Hash.new do |arglist|
        var[var] = ActiveRecord::FixtureSet.default_fixture_model_name(var)
      end
    end
    
    module ClassMethods
      # Sets the model class for a fixture when the class name cannot be inferred from the fixture name.
      #;Fi[	@⁄i%I"        super
        if ActiveRecord::Base.connected? then
          var[:db_runtime] = ((db_runtime or 0) + ActiveRecord::LogSubscriber.reset_runtime)
        end
      end
      
      module ClassMethods
        def function(arglist)
          var, var = super, var[:db_runtime];Fi[	@‚i?I"¢            end
          end
        end
      end
    end
    
    module ClassMethods
      @@subclasses = ThreadSafe::Cache.new(:initial_capacity => 2)
      ;Fi[	@*iI"        end.any?) then
          var.errors.add(var, :invalid, options.merge(:value => (var)))
        end
      end
    end
    
    module ClassMethods
      # Validates whether the associated object or objects are all valid
      # themselves. Works with any kind of association.;Fi[	@-iI"            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module ClassMethods
      # Validates that the specified attributes are not blank (as defined by
      # Object#blank?), and, if the attribute is an association, that the;Fi[	@2iQI"-        var = var.class.serialized_attributes[var.to_s]
        var = var.dump(var) if var and var
        var
      end
    end
    
    module ClassMethods
      # Validates whether the value of the specified attributes are unique
      # across the system. Useful for making sure that only one user;Fi[	@
iI"4          var.default_io_proc = Proc.new do |arglist|
            var = (var == :err) ? (:important) : (:info)
            var[:options][:logger].send(var, var, "#{stream} :: #{ch[:server]}")
          end
        end
        
        module ClassMethods
          attr_accessor(:default_io_proc)
        end;Fi[	@íi~I"        else
          self.errors.add(:email, :not_locked)
          false
        end
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new
        # unlock instructions to it. If not user is found, returns a new user;Fi[	@s	i°I"€          Moped::BSON::ObjectId.from_string(self)
        else
          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #;Fi[	@ë
iîI"…          yield)
        ensure
          Threaded.exit_execution("without_autobuild")
        end
      end
      
      module ClassMethods
        # Adds the existence check for relations.
        #;Fi[	@Pi"I"              var.new(self, var).cascade if var
            end
          end
        end
      end
      
      module ClassMethods
        # Attempt to add the cascading information for the document to know how
        # to handle associated documents on a removal.;Fi[	@ñi[I"          unless var.empty? then
            var.criteria(var, self.class).without_options.pull(var.inverse_foreign_key, id)
          end
        end
      end
      
      module ClassMethods
        # Set up the syncing of many to many foreign keys.
        #;Fi[	@•iëI"¿            remove_instance_variable("@#{name}")
          end
        end
      end
    end
    
    module ClassMethods
      # This is convenience for librarys still on the old API.
      #;Fi[	@≈i°I"ø          yield)
        ensure
          Threaded.exit_execution("load_revision")
        end
      end
      
      module ClassMethods
        # Execute a block in creating mode.
        #;Fi[	@˜i±I"’        var["#{name}_translations"] = var
      else
        var[var] = var if (var.! or var.versioned?)
      end
    end
    
    module ClassMethods
      # Sets the maximum number of versions to store.
      #;Fi[	@≥iI"	        attr_reader(:app, :env, :options, :response)
        option(:setup, false)
        option(:skip_info, false)
      end
    end
    
    module ClassMethods
      # Returns an inherited set of default options set at the class-level
      # for each strategy.;Fi[I"	@var;FI"end;FI" ;FI"def function(arglist);Fi[[	@≤i6I"·      configure_dependency if options[:dependent]
      @var = model.create_reflection(macro, name, scope, options, model)
      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end;Fi[	@∏i7I"Ó              (@var << [var, "#{aliased_prefix}_r#{i}"])
            end
          end
          @var
        end
        
        def function(arglist)
          Hash[column_names_with_alias.map { |arglist| [var, var[var]] }]
        end;Fi[	@ŸiØI"†    # Converts relation objects to Array.
    def function(arglist)
      load
      @var
    end
    
    def function(arglist)
      to_a.as_json(var)
    end;Ti[	@ŸiI"«        @var = var.to_a
      end
      @var = true
      @var
    end
    
    def function(arglist)
      var = arel.join_sources.map do |arglist|
        if var.is_a?(Arel::Nodes::StringJoin) then;Ti[	@˙iI"È      def function(arglist)
        @var ||= default_configuration
        yield(@var) if block_given?
        @var
      end
      
      def function(arglist)
        Data.new("defaults").extend(Defaults).extend(Comments)
      end;Fi[	@LiI"¿        
        def function(arglist)
          send("#{style}_fit")
          @var
        end
        
        def function(arglist)
          @var ||= @var.collect(&:width).max
        end;Fi[	@fihI"◊      def function(arglist)
        @var = StatsVisitor.new
        tree.visit_depth_first(@var)
        @var
      end
      
      def function(arglist)
        self.file_size = File.size(path)
        visit_tree!;Fi[	@ûi!I"*      (@var[:string] << ".#{@version[:state]}") if @var[:state]
      (@var[:string] << ".#{@version[:iteration]}") if @var[:iteration]
      (@var[:string] << ".#{r[(0..6)]}") if ENV["OFFICIAL"].! and var = revision
      @var
    end
    
    def function(arglist)
      revision_from_git
    end;Fi[	@§iôI"?      
      def function(arglist)
        warn("Deprecated: Configuration#options will be removed from the next release of Cucumber. Please use the configuration object directly instead.")
        @var
      end
      
      def function(arglist)
        @var[:paths].empty? ? (["features"]) : (@var[:paths])
      end;Fi[	@¨iSI"ˆ        unless (@var.include?(NO_PROFILE_LONG_FLAG) or @var.include?(NO_PROFILE_SHORT_FLAG)) then
          @var.push("--no-profile")
        end
        @var
      end
      
      def function(arglist)
        @var = var
        @var = @var.dup;Fi[	@ŒiI"∞        
        def function(arglist)
          @var = false
          @var
        end
        
        def function(arglist)
          @var.send(var, *var, &var)
        end;Fi[	@iI"      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("\n")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, [])
        @var.gherkin_statement(var)
        @var
      end
      
      def function(arglist)
        @var = Ast::Background.new(Ast::Comment.new(var.comments.map { |arglist| var.value }.join("\n")), var.line, var.keyword, var.name, var.description, (var = []))
        @var.background = @var;Fi[	@‚i-I"ˆ      require("yaml")
      @var = YAML.load_file((Pathname.new(ABS__FILE__).parent.realpath + "fixtures/updater_fixture.yaml"))
    end
    @var
  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new;Fi[	@h$iPI"ê    
    def function(arglist)
      footer
      @var
    end
    
    def function(arglist)
      footer
      Rack::Response.new(@var).finish;Fi[	@(iëI"Ì          @var[var.to_sym] = Paperclip::Style.new(var.to_sym, var.dup, self)
        end
      end
      @var
    end
    
    def function(arglist)
      var = @var[:only_process].dup
      var = var.call(self) if var.respond_to?(:call);Fi[	@ÎieI"      def function(arglist)
        @var = @var[:s3_host_alias]
        @var = @var.call(self) if @var.respond_to?(:call)
        @var
      end
      
      def function(arglist)
        var = (@var[:s3_url_options] or {})
        var = var.call(instance) if var.respond_to?(:call);Fi[	@Èi$I"∞      
      def function(arglist)
        @var[:null_object] = true
        @var
      end
      
      def function(arglist)
        __add(var)
        warn_if_nil_class(var);Fi[@	)I"@var ||= [];FI"end;FI" ;Fi[[	@^i1I"∏      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, ".git")) then;Fi[	@åiI"      # method responsible to gather source_paths from this current class,
      # inherited paths and the source root.
      #
      def function(arglist)
        @var ||= []
      end
      
      # Stores and return the source root for this class
      def function(arglist);Fi[	@§iI"Ô      var
    end
    
    def function(arglist)
      @var ||= []
    end
    
    # Returns an array of Rule instances which match the action and subject
    # This does not take into consideration any hash conditions or block statements;Fi[	@
iWI"‰        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|;Fi[	@ái>I"”    # @return [ Array<Proc> ] The flagged destroys.
    #
    # @since 3.0.10
    def function(arglist)
      @var ||= []
    end
    
    # Process all the pending flagged destroys from nested attributes.
    #;Fi[	@≥imI"—    # @return [ Array<Class> ] All the models in the application.
    #
    # @since 3.1.0
    def function(arglist)
      @var ||= []
    end
    
    # Register a model in the application with Mongoid.
    #;Fi[	@éiI"‰      # @return [ Array<Document> ] The documents.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= []
      end
      
      # Get the documents the context should iterate. This follows 3 rules:
      #;Fi[	@ùiZI"∫    # @return [ Array<Document> ] The documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= []
    end
    
    # Set the embedded documents on the criteria.
    #;Fi[	@ùi‰I"¥    # @return [ Array<Metadata> ] The inclusions.
    #
    # @since 2.2.0
    def function(arglist)
      @var ||= []
    end
    
    # Set the inclusions for the criteria.
    #;Fi[	@i%I""          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= [];Fi[	@i)I"≥          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then;Fi[	@]iI"ÿ          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|;Fi[	@liI"∂module Spec
  module Example
    module ModuleReopeningFix
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (child_modules << var);Fi[	@{i!I"Æ        
        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          var = find(var.description);Fi[	@€iﬁI"¶        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var);Fi[	@iùI"ë      end
      
      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true;Fi[	@°i,I"6        end
        
        # Tracks the various version overrides for an integration
        def function(arglist)
          @var ||= []
        end
        
        # Creates a new version override for an integration.  When this
        # integration is activated, each version that is marked as active will;Fi[@µ @g:I"# type.;FI"#;Fi[[	@)	iQI"˜      def function(arglist)
        (first.resizable? or (size > 1))
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@)	iãI"            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Array.mongoize([ 1, 2, 3 ]);Fi[	@.	iI"€      def function(arglist)
        to_f
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@8	iI"˛      def function(arglist)
        ::Time.configured.local(year, month, day)
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date.mongoize;Fi[	@8	i/I""        def function(arglist)
          ::Date.new(var.year, var.month, var.day) if var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Date.mongoize("2012-1-1");Fi[	@?	iI"ˇ          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   date_time.mongoize;Fi[	@?	i5I"        def function(arglist)
          ::Time.demongoize(var).try(:to_datetime)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   DateTime.mongoize("2012-1-1");Fi[	@L	imI"         end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@Z	iI"Œ          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize;Fi[	@Z	i˙I"ˆ        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Object.mongoize("123.11");Fi[	@d	iI"⁄      def function(arglist)
        to_a
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   range.mongoize;Fi[	@d	i;I"&        def function(arglist)
          var.nil? ? (nil) : (::Range.new(var["min"], var["max"]))
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Range.mongoize(1..3);Fi[	@n	i#I"˙        def function(arglist)
          ::Set.new(var)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Set.mongoize(1..3);Fi[	@s	i≤I"        def function(arglist)
          var.try(:to_s)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   String.mongoize("123.11");Fi[	@x	i"I"        def function(arglist)
          var.try(:to_sym)
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Symbol.mongoize("123.11");Fi[	@}	i5I"Ê          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Time.mongoize("2012-1-1");Fi[	@Ñ	i$I"#          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   TimeWithZone.mongoize("2012-1-1");Fi[I"@var = false;FI"end;FI" ;FI"def function(arglist);Fi[[	@ñiI"æ    
    def function(arglist)
      super
      @var = false
    end
    
    def function(arglist)
      if var then
        var = "<#{value.bytesize} bytes of binary data>" if var.binary?;Fi[	@Ÿi!I"æ      @var = var
      @var = nil
      @var = false
      @var = false
    end
    
    def function(arglist)
      @var = Hash[@var]
      @var[:bind] = @var[:bind].dup if @var.key?(:bind);Ti[	@˜iI"¯          @var = var.strip.gsub(/\r?\n/, "\\\n")
          @var = (var or Capistrano::Configuration.default_io_proc)
          @var = var
          @var = false
        end
        
        def function(arglist)
          options[:last]
        end;Fi[	@imI"ì      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@iqI"í      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin
          (@var = var;Fi[	@ﬁi9I"œ      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?
        var = var.split(/\r?\n/);Fi[	@ﬁi[I"°      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
        @var = Time.now;Fi[	@ÈiI"•      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var
        @var = false;Fi[	@Èi I"Ω      
      def function(arglist)
        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var
        @var = false;Fi[	@Èi%I"•      
      def function(arglist)
        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end;Fi[	@Èi)I"ó      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var)
        @var = var;Fi[	@Ïi$I"’      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then
          (@var << var.line);Fi[	@Ïi>I"ì      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
      end;Fi[	@‰i≠I"›    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["if", "case", "unless"].include?(var.value[:keyword])
      return unless (var.value[:keyword] == "case");Fi[	@ÈiI"‘        @var = []
        @var = []
        @var = var ? (DEFAULT_OPTIONS.dup.merge(var)) : (DEFAULT_OPTIONS)
        @var = false
      end
      
      def function(arglist)
        @var[:null_object]
      end;Fi[	@qiÅI"º      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        Spec::Runner.configuration.mock_framework
      end;Fi[I"#   person.pets;TI"#   # => [;T@È<@∑<i[[	@îi)I"(      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îibI"(      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi{I"(      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îiôI"(      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îiI"<      #   person.pets.size # => 3
      #
      #   person.id # => 1
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi=I"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi^I"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îiwI"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îiîI"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi¥I"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi–I"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îiÏI"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îiI"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi$I"/      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi|I"0      #   end
      #
      #   person.pets.count # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi∞I"q      #
      #   # Because the collection is loaded, you can
      #   # call the collection with no additional queries:
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@	)I"	self;FI"end;FI" ;Fi[[	@-iI"£    # If your model does not act like an Active Model object, then you should
    # define <tt>:to_model</tt> yourself returning a proxy object that wraps
    # your object with Active Model compliant methods.
    def function(arglist)
      self
    end
    
    # Returns an Enumerable of all key attributes if any is set, regardless if
    # the object is persisted or not. If there no key attributes, returns +nil+.;Fi[	@diDI"x      var
    end
    
    def function(arglist)
      self
    end
    
    def function(arglist)
      sorted.dup;Fi[	@oiI"¢        super(var)
      end
      
      def function(arglist)
        self
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@ùiJI"ó    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    
    # Convert the criteria to a proc.
    #;Fi[	@W	iI"¨      # @return [ nil ] Always nil.
      #
      # @since 3.1.0
      def function(arglist)
        self
      end
      
      # Get the name of a nil collection.
      #;Fi[	@Z	iI"∫      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[	@Z	iI"¨      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.
      #;Fi[	@Z	i*I"Æ      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.
      #;Fi[	@Z	iBI"∂      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.
      #;Fi[	@Z	iNI"«      # @return [ Object ] The object.
      #
      # @since 3.0.3
      def function(arglist)
        self
      end
      
      # Check if the object is part of a blank relation criteria.
      #;Fi[	@Z	iÑI"ß      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Is the object multi args.
      #;Fi[	@Z	i«I"∑      # @return [ Object ] self.
      #
      # @since 2.0.0
      def function(arglist)
        self
      end
      
      # You must unlearn what you have learned. -- Yoda
      #;Fi[	@_	iI"…      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__)
      ;Fi[	@|iI"µ      # @return [ Metadata ] self.
      #
      # @since 2.4.6
      def function(arglist)
        self
      end
      
      # Returns default order for this association.
      #;Fi[	@KiWI"ª      end
      
      # A reference to +self+
      def function(arglist)
        self
      end
      
      ##
      # Recursively get all namespaces from this node and its subtree and;Fi[	@oi'I"        self
      end
      
      def function(arglist)
        self
      end
      
      alias :arguments :argument
      ;Fi[@µ @°+I"
false;FI"end;Fi[[	@ói3I"ü          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end
  end;Fi[	@CiI"ê      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@CiI"∞      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # This is a noop when there are no open transactions;Fi[	@CilI"Å          end
        end
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@Fi~I"º      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      
      # Does this adapter support savepoints? PostgreSQL and MySQL do,;Fi[	@B)i"I"~    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist);Fi[	@B)i&I"    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    
    def function(arglist);Fi[	@B)i>I"v    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@ﬂiÒI"◊      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false
      end
      
      # An array of arrays of scopes. Each item in the outside array corresponds to a reflection;Fi[	@giI"Å    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    
    class Shell < UI;Fi[	@±iI"’      super(var)
      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    
    # By default, a task invokes a method in the thor class. You can change this;Fi[	@€idI"≥      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end;Fi[	@i8I"ò      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@êiI"ò      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      
      def function(arglist);Fi[	@ài1I"é  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist);Fi[	@ÿ#izI"r  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  
  def function(arglist);Fi[@'@¸@ˇ,I"
false;Fi[[	@ói2I"ß          end
          owner.connection.delete(var.where(var).compile_delete)
        end
      end
      
      def function(arglist)
        false
      end
    end;Fi[	@CiI"{      
      def function(arglist)
        true
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@CiI"|      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@CikI"≤            var.logger.error(var) if var.respond_to?(:logger) and var.logger
          end
        end
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@Fi}I"ª      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@B)i!I"n    
    def function(arglist)
      true
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@B)i%I"o    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@B)i=I"w    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
  end;Fi[	@ﬂiI"ë      # ThroughReflection.
      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@giI"v    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@±iI"û    def function(arglist)
      super(var)
      self.options = var.options.dup if var.options
    end
    
    def function(arglist)
      false
    end
    ;Fi[	@€icI"¥      
      def function(arglist)
        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end;Fi[	@i7I"±      # This could print out a message or something.
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@êiI"É      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end
      ;Fi[	@ài0I"~  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end
  ;Fi[	@ÿ#iyI"π  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end
  ;Fi[@'@¸@ˇ,I"%return if Cucumber.wants_to_quit;Fi[[	@ii$I"œ          @var = true
          @var.dup(var)
        end
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?;Fi[	@liI"˙      
      def function(arglist)
        (@var.nil? or (@var == ""))
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        @var.strip.split("\n").each { |arglist| var.visit_comment_line(var.strip) }
      end;Fi[	@oiI"≤      
      def function(arglist)
        self
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_doc_string(self)
      end;Fi[	@riI"Ï      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_comment(@var) unless @var.empty?
        var.visit_examples_name(@var, name);Fi[	@ui&I"Œ      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?;Fi[	@}iI"Ò      def function(arglist)
        var.features = self
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var = Time.now
        self.each { |arglist| var.visit_feature(var) };Fi[	@ÉiI"…      def function(arglist)
        init
        super
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        cells_rows.each_with_index do |arglist|;Fi[	@ÉibI"        
        def function(arglist)
          @var.each { |arglist| var.skip_invoke! }
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          var.configuration.expand? ? (accept_expand(var)) : (accept_plain(var))
        end;Fi[	@äi/I".        attach_steps(@var)
        var = @var.map { |arglist| var.step_invocation }
        @var = @var.step_collection(var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        with_visitor(var) do |arglist|
          var.visit_comment(@var) unless @var.empty?;Fi[	@çi7I"        end
        @var.extend(ExamplesArray)
        (@var.feature_elements << self) if @var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_comment(@var) unless @var.empty?
        var.visit_tags(@var);Fi[	@êi.I"E        var = replace_name_arguments(var)
        var = @var.nil? ? (nil) : (@var.arguments_replaced(var))
        StepInvocation.new(self, var, var, var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        visit_step_result(var, first_match(var), @var, :skipped, nil, nil)
      end;Fi[	@ìiI"      def function(arglist)
        @var = var
        @var.each { |arglist| var.step_collection = self }
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        @var.each { |arglist| var.visit_step(var) if (var.nil? or var.call(var)) }
      end;Fi[	@ñiôI"·      
      def function(arglist)
        cells_rows.each(&var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        cells_rows.each { |arglist| var.visit_table_row(var) }
        nil;Fi[	@ñi+I"È        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) }
          nil;Fi[	@ñifI"Ô        
        def function(arglist)
          @var, @var, @var = var, var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          var.visit_table_cell_value(value, status)
        end;Fi[	@õiI"›      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        @var.each { |arglist| var.visit_tag_name(var.name) }
      end;Fi[@û=I"def function(arglist);FI"@var = var;FI"end;Fi[[	@ciîI"∑  	# @param float :scale image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_image_scale, :SetImageScale);Fi[	@ci˙I"Á  	# @param float :margin The margin.
  	# @since 1.5
  	# @see SetLeftMargin(), SetRightMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_top_margin, :SetTopMargin);Fi[	@ciI"È  	# @param float :margin The margin.
  	# @since 1.5
  	# @see SetLeftMargin(), SetTopMargin(), SetAutoPageBreak(), SetMargins()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_right_margin, :SetRightMargin);Fi[	@ciBI"–  	# @param string :title The title.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetSubject()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_title, :SetTitle);Fi[	@ciNI"÷  	# @param string :subject The subject.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetKeywords(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_subject, :SetSubject);Fi[	@ciZI"ﬂ  	# @param string :author The name of the author.
  	# @since 1.2
  	# @see SetCreator(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_author, :SetAuthor);Fi[	@cifI"·  	# @param string :keywords The list of keywords.
  	# @since 1.2
  	# @see SetAuthor(), SetCreator(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_keywords, :SetKeywords);Fi[	@cirI"‚  	# @param string :creator The name of the creator.
  	# @since 1.2
  	# @see SetAuthor(), SetKeywords(), SetSubject(), SetTitle()
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_creator, :SetCreator);Fi[	@ciBI"È   	# Set header margin.
  	# (minimum distance between header and top page margin)
  	# @param int :hm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_margin, :SetHeaderMargin);Fi[	@ciMI"Ï   	# Set footer margin.
  	# (minimum distance between footer and bottom page margin)
  	# @param int :fm distance in millimeters
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_margin, :SetFooterMargin);Fi[	@ciWI"Ì  #
   	# Set a flag to print page header.
  	# @param boolean :val set to true to print the page header (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_header, :SetPrintHeader);Fi[	@ciaI"Ô  #
   	# Set a flag to print page footer.
  	# @param boolean :value set to true to print the page footer (default), false otherwise. 
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_print_footer, :SetPrintFooter);Fi[	@ci:I"©   	# Set header font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_header_font, :SetHeaderFont);Fi[	@ciEI"©   	# Set footer font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_footer_font, :SetFooterFont);Fi[	@ciPI"±   	# Set language array.
  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  
  alias_method(:set_language_array, :SetLanguageArray);Fi[	@ciZI"|  #
   	# Set document barcode.
  	# @param string :bc barcode
  	#
  def function(arglist)
    @var = var
  end
  
  #;Fi[@À8@Ã8I"end;FI"end;Fi[[	@Ci·I"≤        if File.exist?(var) then
          return yes?("A file already exists at '#{path}'. Do you want to overwrite? [y/n]")
        end
        true
      end
    end
  end
end;Fi[	@ñiÇI"n        end
        
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@¨iÁI"»        @var.delete_if do |arglist|
          if var =~ /^(\w+)=(.*)$/ then
            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function;Fi[	@ÉihI"s      (errors[:base] << "Cannot connect to an ignored user")
      false
    else
      true
    end
  end
end;Fi[	@çibI"Ω    if self.parent and self.parent.participants.include?(self.author).! then
      (errors[:base] << "Author is not participating in the conversation")
    else
      true
    end
  end
end;Fi[	@G8iI"◊    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end
Haml::Template.options[:ugly] = Rails.env.development?.!
Haml::Template.options[:escape_html] = true;Fi[	@p-iI"–          if (var.rack.exist?.! or var.rack.children.empty?) then
            onoe("#{f} not installed")
          else
            true
          end
        end
      end
      exit(1) if var.empty?
    end;Fi[	@)	i§I"z        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@L	i¡I"z        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end
end;Fi[	@∫	iI"ó            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	@I
iI"è        document.destroyed = true
        IdentityMap.remove(document)
        Threaded.clear_options!
        true
      end
    end
  end
end;Fi[	@ni!I"A                if [:attribute_nodes, :children].include?(var.first) then
                  var.last.empty?.!
                else
                  true
                end
              end
            end
            var.seplist(var) do |arglist|
              if [:attribute_nodes, :children].include?(var.first) then;Fi[	@π)i I"     end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|
  (var.nil? or (Paperclip::Attachment.===(var) and var.present?.!));Fi[	@¬i&I"à              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end
end;Fi[	@îi‰I"‚        end
        var.class.changed if var.class.respond_to?(:changed)
        var.class.notify_observers("update_with_transition", ObserverUpdate.new("#{type}_transition", var, var))
        true
      end
    end
  end
end;Fi[@û=I"# @return [ nil ] Nil.;FI"#;FI"# @since 3.0.0;Fi[[	@viI"8      #
      # @param [ String, Symbol ] field The name of the field to add to.
      # @param [ Object ] value The single value to add.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$addToSet" => ({ database_field_name(var) => (var) }));Fi[	@viI"y      # @param [ String, Symbol ] field The name of the field to operate on.
      # @param [ Hash ] value The bitwise operations to perform. Keys may be
      #   "and" or "or" and must have numeric values.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$bit" => ({ database_field_name(var) => (var) }));Fi[	@vi.I".      #
      # @param [ String, Symbol ] field The field to increment.
      # @param [ Integer ] value The amount to increment by.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$inc" => ({ database_field_name(var) => (var) }));Fi[	@viBI"      #   from.
      # @param [ Integer ] value 1 to pop from the end, -1 to pop from the
      #   front.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pop" => ({ database_field_name(var) => (var) }));Fi[	@viSI",      #
      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Object ] value The single value to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pull" => ({ database_field_name(var) => (var) }));Fi[	@vibI"1      #
      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Array<Object> ] values The values to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pullAll" => ({ database_field_name(var) => (var) }));Fi[	@viqI"#      #
      # @param [ String, Symbol ] field The field to push to.
      # @param [ Object ] value The value to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$push" => ({ database_field_name(var) => (var) }));Fi[	@vi{I"/      #
      # @param [ String, Symbol ] field The field to push to.
      # @param [ Array<Object> ] values The values to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pushAll" => ({ database_field_name(var) => (var) }));Fi[	@viäI"7      #
      # @param [ String, Symbol ] old_name The old field name.
      # @param [ String, Symbol ] new_name The new field name.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$rename" => ({ database_field_name(var) => (var.to_s) }));Fi[	@viôI""      #
      # @param [ String, Symbol ] field The name of the field.
      # @param [ Object ] value The value to set.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$set" => ({ database_field_name(var) => (var) }));Fi[	@vißI"#      #   context.unset(:name)
      #
      # @param [ String, Symbol, Array ] fields The name of the fields.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = var.__find_args__.collect { |arglist| [database_field_name(var), true] };Fi[	@ãi(I"Ω      #
      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count;Fi[	@ãi>I"ø      #
      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count;Fi[	@éiCI"ﬂ      #
      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        self.count.tap { |arglist| query.remove_all };Fi[	@éiQI"ƒ      #
      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = self.count;Fi[@	)I"@var = true;FI"end;FI" ;Fi[[	@ïiÓI"    attr_reader :function
    
    # Marks this record as read only.
    def function(arglist)
      @var = true
    end
    
    # Returns the connection currently associated with the class. This can
    # also be used to "borrow" the connection to do database work that isn't;Fi[	@Xi I"ï        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@Xi$I"¿        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def self.from_lock(arglist)
        new(var.merge("path" => (var.delete("remote"))));Fi[	@_iI"Û        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true;Fi[	@_iI"ó        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        Rubygems.hash;Fi[	@gi?I"î        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      ;Fi[	@giII"≤        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        tell_me(var, nil, var) if debug?;Fi[	@˜i'I"•        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist)
          true;Fi[	@’i!I"|        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      protected
      ;Fi[	@`(iI"{      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function
  end;Fi[	@ﬁi4I"≠        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false;Fi[	@Èi?I"õ        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      
      private
      ;Fi[	@äi^I"’      
      # If you don't want reconfirmation to be sent, neither a code
      # to be generated, call skip_reconfirmation!
      def function(arglist)
        @var = true
      end
      
      protected
      ;Fi[	@«iNI"µ      attr_reader :function
      
      # See Spec::Matchers
      def function(arglist)
        @var = true
      end
      
      # See Spec::Matchers
      def function(arglist);Fi[	@i°I"ò        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var ||= false;Fi[@AI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@viI":      # @param [ String, Symbol ] field The name of the field to add to.
      # @param [ Object ] value The single value to add.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$addToSet" => ({ database_field_name(var) => (var) }))
      end;Fi[	@vi I"6      # @param [ Hash ] value The bitwise operations to perform. Keys may be
      #   "and" or "or" and must have numeric values.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$bit" => ({ database_field_name(var) => (var) }))
      end;Fi[	@vi/I"0      # @param [ String, Symbol ] field The field to increment.
      # @param [ Integer ] value The amount to increment by.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$inc" => ({ database_field_name(var) => (var) }))
      end;Fi[	@viCI"      # @param [ Integer ] value 1 to pop from the end, -1 to pop from the
      #   front.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pop" => ({ database_field_name(var) => (var) }))
      end;Fi[	@viTI".      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Object ] value The single value to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pull" => ({ database_field_name(var) => (var) }))
      end;Fi[	@vicI"3      # @param [ String, Symbol ] field The field to pull from.
      # @param [ Array<Object> ] values The values to pull.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pullAll" => ({ database_field_name(var) => (var) }))
      end;Fi[	@virI"%      # @param [ String, Symbol ] field The field to push to.
      # @param [ Object ] value The value to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$push" => ({ database_field_name(var) => (var) }))
      end;Fi[	@vi|I"1      # @param [ String, Symbol ] field The field to push to.
      # @param [ Array<Object> ] values The values to push.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$pushAll" => ({ database_field_name(var) => (var) }))
      end;Fi[	@viãI"9      # @param [ String, Symbol ] old_name The old field name.
      # @param [ String, Symbol ] new_name The new field name.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$rename" => ({ database_field_name(var) => (var.to_s) }))
      end;Fi[	@viöI"$      # @param [ String, Symbol ] field The name of the field.
      # @param [ Object ] value The value to set.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        query.update_all("$set" => ({ database_field_name(var) => (var) }))
      end;Fi[	@vi®I"6      #
      # @param [ String, Symbol, Array ] fields The name of the fields.
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = var.__find_args__.collect { |arglist| [database_field_name(var), true] }
        query.update_all("$unset" => (Hash[var]));Fi[	@ãi)I"‘      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count
        var = map do |arglist|;Fi[	@ãi?I"—      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = count
        each do |arglist|;Fi[	@éiDI"·      # @example Delete all the documents.
      #   context.delete
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        self.count.tap { |arglist| query.remove_all }
      end;Fi[	@éiRI"„      # @example Destroy all the documents.
      #   context.destroy
      #
      # @return [ nil ] Nil.
      #
      # @since 3.0.0
      def function(arglist)
        var = self.count
        each { |arglist| var.destroy };Fi[@Ô>@>I"end;FI" ;Fi[[	@i"I"˛          return if attribute_methods_generated?
          superclass.define_attribute_methods unless (self == base_class)
          super(column_names)
          @var = true
        end
      end
      
      def function(arglist)
        @var ||= false;Fi[	@˙iVI"          Sass::Plugin.on_compilation_error do |arglist|
            Compass.configuration.run_stylesheet_error(var, var.message)
          end
          @var = true
        end
      end
      
      def function(arglist)
        configuration.to_sass_engine_options;Fi[	@äi<I"”            skip_invoke! if failed?
            var.visit_steps(@var)
          end
          @var = true
        end
      end
      
      # Returns true if one or more steps failed
      def function(arglist);Fi[	@«ioI"          @var.text!("makeRed('cucumber-header');") unless @var
          @var = true
          @var.text!("makeRed('scenario_#{@scenario_number}');") unless @var
          @var = true
        end
      end
      
      def function(arglist)
        @var.script do |arglist|;Fi[	@‰i'I"Ô      if ["if", "case", "unless"].include?(var) then
        @var.push([var.to_sym, @var.tabs])
        (@var.last << false) if (var == "case")
        @var = true
      end
    end
    
    def function(arglist)
      @var = block_opened?;Fi[	@®iÓI"Ï      puts("The formula built, but you may encounter issues using it or linking other")
      puts("formula against it.")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    begin;Fi[	@®iI"      opoo("The cleaning step did not complete successfully")
      puts("Still, the installation was successful, so we will link it into your prefix")
      ohai(var, var.backtrace) if ARGV.debug?
      @var = true
    end
  end
  
  def function(arglist)
    var, var = f.fetch;Fi[	@®i I"1      opoo("A top-level \"man\" directory was found.")
      puts("Homebrew requires that man pages live under share.")
      puts("This can often be fixed by passing \"--mandir=\#{man}\" to configure.")
      @var = true
    end
  end
  
  def function(arglist)
    if (f.prefix + "info").directory? then;Fi[	@®i)I"-      opoo("A top-level \"info\" directory was found.")
      puts("Homebrew suggests that info pages live under share.")
      puts("This can often be fixed by passing \"--infodir=\#{info}\" to configure.")
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?;Fi[	@®i8I"“      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.lib.directory?;Fi[	@®iHI"◊      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.bin.directory?;Fi[	@®iTI"⁄      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    return unless f.sbin.directory?;Fi[	@®i`I"∆      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist)
    check_jars;Fi[	@„iÛI"
    def function(arglist)
      unless @var then
        machine.write(object, :state, to)
        @var = true
      end
    end
    
    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.;Fi[	@„iîI"            machine.callbacks[var].each { |arglist| var.call(object, context, self) }
          end
        end
        @var = true
      end
    end
    
    # Gets a hash of the context defining this unique transition (including
    # event, from state, and to state).;Fi[@–0@—0I"end;FI"end;Fi[[	@HiÖI"ö        var = ActiveSupport::JSON.decode(var)
        var = var.values.first if var
        self.attributes = var
        self
      end
    end
  end
end;Fi[	@Ki‘I"ß      #   person.awesome       # => true
      def function(arglist)
        self.attributes = Hash.from_xml(var).values.first
        self
      end
    end
  end
end;Fi[	@îiµI"Ø      #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
      def function(arglist)
        proxy_association.reload
        self
      end
    end
  end
end;Ti[	@ë
i¸I"¥          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end
end;Fi[	@-iTI"ê            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end
end;Fi[	@Pi3I"©        # @since 2.0.0.rc.1
        def function(arglist)
          cascades.push(var.name.to_s) if var.dependent?
          self
        end
      end
    end
  end
end;Fi[	@åi I"ë              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end
end;Fi[	@ñiåI"ø        # @since 2.2.1
        def function(arglist)
          set_callback(:destroy, :after) { |arglist| var.remove_inverse_keys(var) }
          self
        end
      end
    end
  end
end;Fi[	@†iI"¶        # @since 3.0.0
        def function(arglist)
          self.touchables.push(var.name) if var.touchable?
          self
        end
      end
    end
  end
end;Fi[	@‘i.I"é        # @since 2.3.0
        def function(arglist)
          Threaded.timeless = true
          self
        end
      end
    end
  end
end;Fi[	@Ci§I"~            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end
end;Fi[	@«iWI"π        self.class.class_eval do |arglist|
          define_method(var) do |arglist|
            var.call(*var)
            self
          end
        end
      end
      
      private;Fi[	@Oi
I"ò    # Returns the object's singleton class (exists in Ruby 1.9.2)
    def function(arglist)
      class << self
        self
      end
    end
  end
end;Fi[	@ *i/I"u    # @return [Twitter::RateLimit]
    def function(arglist)
      @var.update(var)
      self
    end
  end
end;Fi[	I"/data//twitter_proj/twitter/relationship.rb;Ti I"°    # @return [Twitter::Relationship]
    def function(arglist)
      @var.update(var[:relationship]) unless var[:relationship].nil?
      self
    end
  end
end;Fi[@'@(@)I"var;Fi[[	@ùieI"«          else
            if (var.macro == :has_one) then
              var.send("#{inverse.name}=", build_through_record(var))
            end
          end
        end
        var
      end
      ;Fi[	@ûiøI"á              end
            else
              # do nothing
            end
          end
        end
        var
      end
      var;Fi[	@ i´I"Ÿ        var.gem_platforms(@var).each do |arglist|
          if (var or (var == generic(Gem::Platform.local))) then
            (var << DepProxy.new(var, var))
          end
        end
      end
      var
    end
    ;Fi[	@%ilI"              (var << "gem '#{clean_req(requirement.required_by.first)}', in any of the sources.")
            else
              (var << "Could not find gem '#{clean_req(requirement)} in any of the sources\n")
            end
          end
        end
        var
      end
    end;Fi[	@i|I"œ            warn(var)
            var = var.map do |arglist|
              (var == "deploy:symlink") ? ("deploy:create_symlink") : (var)
            end
          end
        end
        var
      end
      ;Fi[	@{iI"ê              (var << " - #{description}")
            end
            (var << "\n")
          end
        end
      end
      var
    end
  end;Fi[	@$iFI"‹        else
          if (var.value.last == var.value.last) and (var.value.first.value == 0) then
            var.value[0] = Sass::Script::Number.new(var.value)
          end
        end
      end
      var
    end
    ;Fi[	@±iYI"ñ          person_link(var, :class => "mention hovercardable")
        else
          ERB::Util.h($~[1])
        end
      end
    end
    var
  end
  ;Fi[	@∂iJI"∆        next if (var.symlink? or var.directory?)
        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end
end;Fi[	@§iêI"…            var.add_atomic_changes(self, var, var, var, var, var)
          else
            var[var] = var unless atomic_unsets.include?(var)
          end
        end
      end
      var
    end
    ;Fi[	@£	i,I"§              var.push(var)
              var.concat(var._children) unless var.versioned?
            end
          end
        end
      end
      var
    end
    ;Fi[	@ôi1I"Ü                  var = 0
                end
              end
            end
          end
        end
        var
      end
      ;Fi[	@ i$I"Ø              (var << "#{item.inspect} and ")
            else
              (var << "#{item.inspect}")
            end
          end
        end
        var
      end
    end;Fi[	@qiÓI"Æ              (var << var)
            else
              raise("File or directory not found: #{file}")
            end
          end
        end
        var
      end
      ;Fi[	@Ô%i+I"Á        each_value do |arglist|
          if var.dynamic_initial_state? then
            var.initialize_state(var, :force => ((var[:dynamic] == :force)), :to => (var[:to]))
          end
        end
      end
      var
    end
    ;Fi[@‹.I"nil;FI"end;FI"end;Fi[[	@Ii I"          if var.to_s =~ /PRIMARY KEY\s+(?:USING\s+\w+\s+)?\((.+)\)/ then
            var = $1.split(",").map { |arglist| var.delete("`\"") }
            (var.length == 1) ? ([var.first, nil]) : (nil)
          else
            nil
          end
        end
      end
      ;Fi[	@bivI"Û              else
                if [var.first, var.last].all? { |arglist| NilClass.===(var) } then
                  "empty"
                else
                  nil
                end
              end
            else
              var;Fi[	@,i)I"⁄        else
          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end;Fi[	@iqI"Ù        else
          if base.respond_to?(var, true) then
            raise(Thor::PrivateMethodEncodedError, "Method #{base.class}##{sym} should be public, not private")
          else
            nil
          end
        end
      end
      ;Fi[	@(iI"®            var = var.offset(var)[0]
            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end;Fi[	@=i±I"{            (@var << var)
            nil
          end
        else
          nil
        end
      end
    end
  end;Fi[	@9i#I"á        if var then
          var.email_the_user(var, var)
          var
        else
          nil
        end
      end
    end
  end;Fi[	@ói|I"ﬁ    else
      if var[:username].present? and var = User.find_by_username(var[:username]) then
        var.person
      else
        nil
      end
    end
    raise(ActiveRecord::RecordNotFound) unless var.present?
    var;Fi[	@.ifI"∏      "#{$1}/#{$2}/#{File.basename($3, ".rb")}"
    when /^#{HOMEBREW_LIBRARY}\/Formula\/(.+)/ then
      "mxcl/master/#{File.basename($1, ".rb")}"
    else
      nil
    end
  end
end;Fi[	@¸iÁI"Õ      var = self.site.posts.index(self)
      if var and (var < (self.site.posts.length - 1)) then
        self.site.posts[(var + 1)]
      else
        nil
      end
    end
    
    def function(arglist);Fi[	@|i\I"‰      def function(arglist)
        if relation.stores_foreign_key? and polymorphic? then
          "#{name}_#{field}"
        else
          nil
        end
      end
      
      # Deterimene the inverses that can be memoized.;Fi[	@iéI"ﬁ        ("%09d" % var).scan(/\d{3}/).join("/")
      when String then
        var.scan(/.{3}/).first(3).join("/")
      else
        nil
      end
    end
    
    # Returns the pluralized form of the attachment name. e.g.;Fi[	@õi.I"Ö        var = new(*var)
        var.to_s = var
        var
      else
        nil
      end
    end
    
    def self.attach(arglist);Fi[	@niI"£          else
            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist);Fi[	@€iI"            var.jump(:ident).source.to_sym
          when :string_literal then
            var.jump(:tstring_content).source
          else
            nil
          end
        end
        
        # Extracts the values from the node as either strings or symbols.;Fi[@‘7@’7I" ;FI"def function(arglist);Fi[[	@CiI"      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end;Fi[	@CinI"~      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        true
      end;Fi[	@Fi|I"      # CREATE TABLE or ALTER TABLE get rolled back by a transaction? PostgreSQL,
      # SQL Server, and others support this. MySQL and others do not.
      def function(arglist)
        false
      end
      
      def function(arglist)
        false
      end;Fi[	@B)i$I"r    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      false
    end;Fi[	@B)i(I"x    end
    
    def function(arglist)
      false
    end
    
    def function(arglist)
      @var ||= ""
    end;Fi[	@9iDI"˚      sass_files.zip(css_files).each do |arglist|
        return var if needs_update?(var, var)
      end
      false
    end
    
    def function(arglist)
      staleness_checker.stylesheet_needs_update?(var, File.expand_path(var), importer)
    end;Fi[	@{i_I"¯      if var = self[var] and var.templates_directory then
        return File.directory?(File.join(var.templates_directory, var))
      end
      false
    end
    
    def function(arglist)
      var, var = var.split(/\//, 2)
      var = self[var];Fi[	@i:I"∞      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        "#{options[:pattern_name]}/" if options[:pattern_name]
      end;Fi[	@äiI"ú      
      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end;Fi[	@êiI"Ç      end
      
      def function(arglist)
        false
      end
      
      def function(arglist)
        :skipped
      end;Fi[	@≠i?I"ø    var = cucumber_arity(var)
    var = var.length
    return true if ((var == var) or ((var < 0) and (var >= (var.abs - 1))))
    false
  end
  
  def function(arglist)
    begin
      yield;Fi[	@ài3I"ó  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    self.participants.map { |arglist| var.diaspora_handle }.join(";")
  end;Fi[	@ÿ#ixI"π  
  # @return Returns true if this Post will accept updates (i.e. updates to the caption of a photo).
  def function(arglist)
    false
  end
  
  def function(arglist)
    false
  end;Fi[	@ÿ#i|I"  end
  
  def function(arglist)
    false
  end
  
  def function(arglist)
    I18n.t("notifier.a_post_you_shared")
  end;Fi[	@≥iSI"ö          return true
        end
      end
      false
    end
    
    def function(arglist)
      self.env["omniauth.auth"] = auth_hash
      call_app!;Fi[@'@¸@ˇ,I"var = 0;Fi[[	@9iYI"    def function(arglist)
      remove(options[:cache_location])
      css_files.each { |arglist| remove(var) }
    end
    
    def function(arglist)
      var = 0
      if new_config? then
        remove(options[:cache_location]) if options[:cache_location];Fi[	@«ixI".          @var.text!("makeYellow('cucumber-header');") unless @var
          @var.text!("makeYellow('scenario_#{@scenario_number}');") unless @var
        end
      end
      
      def function(arglist)
        var = 0
        var = var.instance_variable_get("@features")
        var.each do |arglist|;Fi[	@3iI"F    Rails.logger.debug("event=post_to_service type=twitter sender_id=#{self.user_id}")
    var = public_message(var, var)
    client.update(var)
  end
  
  def function(arglist)
    var = 0
    URI.extract(var.text(:plain_text => (true)), ["http", "https"]) do |arglist|
      var = (var + (var.length - SHORTENED_URL_LENGTH));Fi[	@ªiåI"    if unconfirmed_email_changed? then
      self.confirm_email_token = unconfirmed_email ? (SecureRandom.hex(15)) : (nil)
    end
  end
  
  def function(arglist)
    var = 0
    var.each do |arglist|
      self.aspects.find(var).update_attributes(:order_id => (var));Fi[	@.iCI"¯    end
    HOMEBREW_LIBRARY.join("Formula/.gitignore").atomic_write(var.uniq.join("\n"))
    var
  end
  
  def function(arglist)
    var = 0
    Dir["#{HOMEBREW_REPOSITORY}/Library/Formula/*.rb"].each do |arglist|
      if File.exist?(var).! then;Fi[	@Ö7iI"È    var = unlink_tap_formula(var)
    rm_rf(var)
    puts("Untapped #{untapped} formula")
  end
  
  def function(arglist)
    var = 0
    var = (HOMEBREW_LIBRARY / "Formula/.gitignore").read.split rescue []
    var.each do |arglist|;Fi[	@7i@I"	          var = var ? ((var[right_column_name] or 0)) : (0)
          self[left_column_name] = (var + 1)
          self[right_column_name] = (var + 2)
        end
        
        def function(arglist)
          var = 0
          begin
            transaction(&var);Fi[	@Li<I"    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[	@Oi,I"    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[	@Ri+I"    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length;Fi[	@xi–I"∞    var.gsub!(/\n{3,}/, "\n\n")
    var.gsub!(/"$/, "\" ")
    flush_left(var)
  end
  
  def function(arglist)
    var = 0
    if var =~ /^ / then
      unless var.empty? then;Fi[	@˛i&I"5      #   :side stacks the bars side-by-side. Defaults to :overlap.
      def function(arglist)
        @var.collect { |arglist| var[:data].max }.max
      end
      
      def function(arglist)
        var = 0
        if min_scale_value.nil? then
          var = @var.collect { |arglist| var[:data].min }.min;Fi[	@	i7I"È          var = @var.collect { |arglist| var[:data].max }.max
        end
        return var
      end
      
      def function(arglist)
        var = 0
        if (min_scale_value.nil? == false) then
          var = min_scale_value;Fi[	@iiI"Æ      
      def function(arglist)
        [""]
      end
      
      def function(arglist)
        var = 0
        var = 0
        @var.each { |arglist| var = (var + var) };Fi[@'I"
super;FI"end;FI" ;Fi[[	@ûiI"        end
        if (var[:allow_blank] == false) and (var[:minimum].nil? and var[:is].nil?) then
          var[:minimum] = 1
        end
        super
      end
      
      def function(arglist)
        var = CHECKS.keys.&(options.keys);Fi[	@ùi"I"ø            raise_on_type_mismatch(var)
            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested;Fi[	@iI"¢    def function(arglist)
      if self.class.columns_hash[var.attr_name] then
        ActiveSupport::Deprecation.warn("The method `#{match.method_name}', matching the attribute `#{match.attr_name}' has dispatched through method_missing. This shouldn't happen, because `#{match.attr_name}' is a column of the table. If this error has happened through normal usage of Active Record (rather than through your own code or external libraries), please report it as a bug.")
      end
      super
    end
    
    # A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>,
    # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>;Fi[	@iñI"    def function(arglist)
      unless self.class.attribute_methods_generated? then
        self.class.define_attribute_methods
      end
      super
    end
    
    # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
    #;Fi[	@•iI"˘          if var = subclass_from_attrs(var) then
            return var.new(*var, &var)
          end
        end
        super
      end
      
      # True if this isn't a concrete subclass needing a STI type condition.
      def function(arglist);Fi[	@µi\I"M      def function(arglist)
        if (var.size == 1) and (var == nil) then
          raise(ActiveRecord::IrreversibleMigration, "To avoid mistakes, drop_table is only reversible if given options or a block (can be empty).")
        end
        super
      end
      
      def function(arglist)
        [:rename_table, var.reverse];Fi[	@µigI")      def function(arglist)
        if (var.size <= 2) then
          raise(ActiveRecord::IrreversibleMigration, "remove_column is only reversible if given a type.")
        end
        super
      end
      
      def function(arglist)
        [:rename_index, ([var.first] + var.last(2).reverse)];Fi[	@$iI"©            write_attribute(var.to_s, var)
          end
        end
      end
      super
    end
    
    def function(arglist)
      if should_record_timestamps? then;Fi[	@$i)I"          next if attribute_changed?(var)
          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist)
      self.record_timestamps and (partial_writes?.! or (changed? or attributes.keys.&(self.class.serialized_attributes.keys).present?));Fi[	@˝i$I"        if var.name.nil? then
          var = StepDefKey.new(var.step_definition.regexp_source, var.step_definition.file_colon_line)
          (@var[var] << { :keyword => (var), :step_match => (var), :status => (var), :file_colon_line => (@var.file_colon_line), :duration => (@var) })
        end
        super
      end
      
      def function(arglist)
        add_unused_stepdefs;Fi[	@ùi}I"    def function(arglist)
      if var.is_a?(::String) and embedded? then
        raise(Errors::UnsupportedJavascript.new(klass, var))
      end
      super
    end
    
    # Tell the next persistance operation to query from a specific collection,
    # database or session.;Fi[	@ÙiŒI"ï              autosave(var.merge!(:autosave => (true)))
            end
          end
        end
        super
      end
      
      private
      ;Fi[	@˛iI"<      def function(arglist)
        unless var[:fields] and (var[:fields].kind_of?(Array) and (var[:fields].length > 0)) then
          raise("fields was not supplied or is empty")
        end
        super
      end
      
      # In addition to the defaults set in Graph::initialize, sets
      			# [bar_gap] true;Fi[	@	iI"B      def function(arglist)
        unless var[:fields] and (var[:fields].kind_of?(Array) and (var[:fields].length > 0)) then
          raise("fields was not supplied or is empty")
        end
        super
      end
      
      # In addition to the defaults set in Graph::initialize, sets
      # [show_data_points] true;Fi[@‘7@’7@÷7I"end;Fi[[	I"1data//activemodel_proj/active_model/model.rb;Ti(I"ä    #  person = Person.new(id: 1, name: 'bob')
    #  person.persisted? # => false
    def function(arglist)
      false
    end
  end
end;Fi[	@ói5I"[      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@ùi®I"ë      
      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@B)i@I"I    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@Ÿi,I"l          ActiveSupport::Deprecation.warn("It looks like you are eager loading table(s) (one of: #{string_tables.join(", ")}) that are referenced in a string SQL snippet. For example: \n\n    Post.includes(:comments).where(\"comments.title = 'foo'\")\n\nCurrently, Active Record recognises the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:\n\n    Post.includes(:comments).where(\"comments.title = 'foo'\").references(:comments)\n\n")
          true
        else
          false
        end
      end
    end
    
    def function(arglist);Ti[	@ßiåI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@¨iI"          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end
end;Fi[	@7i@I"◊            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      
      # Access a named variable. If the value of the variable responds_to? :call,;Fi[	@€ifI"[      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@ÿ;iI"^    when String, Array then
      var.length.zero?
    else
      false
    end
  end
end;Fi[	@èiWI"}      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end
def function(arglist);Fi[	I"8data//mongoid_proj/lib/mongoid/railties/document.rb;TiI"Ç    #
    # See ActionView::Helpers::FormHelper::fields_for for more info.
    def function(arglist)
      false
    end
  end
end;Fi[	@«i,I"…          begin
            instance_exec(var, &@var)
          rescue Spec::Expectations::ExpectationNotMetError
            false
          end
        end
      end
      
      # See Spec::Matchers;Fi[	@iI"†          true)
        rescue DRb::DRbConnError
          var.error_stream.puts("No server is running")
          false
        end
      end
    end
  end
end;Fi[@'@¸@ˇ,I"@var = false;Fi[[	@Fi^I"ü      def function(arglist)
        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@inI"ä      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@¡iI"›      def function(arglist)
        @var.uri(var.file)
        @var.feature(var.gherkin_statement)
      end
      
      def function(arglist)
        @var = false
        @var.background(var.gherkin_statement)
      end;Fi[	@ŒiI"√        def function(arglist)
          (@var << var) if @var
          return @var.write(var)
        end
        
        def function(arglist)
          @var = false
          @var
        end;Fi[	@ﬁi6I"â      
      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@ﬁiXI"ñ      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@Êi~I"∫      def function(arglist)
        @var = var
        @var = 6
      end
      
      def function(arglist)
        @var = false
        if var then
          if @var.include?(var) then;Fi[	@ÈiI"ë        @var.puts
        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@Èi&I"•      def function(arglist)
        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@Ïi!I"à      
      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@Ïi;I"ñ      def function(arglist)
        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      ;Fi[	@‰i§I"œ      if respond_to?("close_#{node.type}", :include_private) then
        send("close_#{node.type}", var)
      end
    end
    
    def function(arglist)
      @var = false
      @var = nil
      @var = nil;Fi[	@‰i™I"{      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    ;Fi[	@biI"§        else
          @var, @var = var, var
        end
      end
      
      def function(arglist)
        @var = false
        @var = false
        @var = false;Fi[I"2broadcast(var) { |arglist| var.accept(self) };FI"end;FI" ;FI"def function(arglist);Fi[[	@ûiI"œ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ûiI"œ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ûiI"∞      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@ûi#I"∞      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end;Fi[	@ûi0I"      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ûi4I"ø      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@ûi<I"œ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ûi@I"µ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@ûiHI"ø      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var)
      end;Fi[	@ûiPI"œ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ûiTI"      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|
          visit_step_name(var, var, var, var, var, var);Fi[	@ûidI"µ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@ûipI"œ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ûitI"µ      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[@‹.I"
false;FI"end;FI"end;Fi[[	@ãiI"◊            load_target if options[:finder_sql]
            loaded? ? (target.include?(var)) : (scope.exists?(var))
          end
        else
          false
        end
      end
      
      def function(arglist);Fi[	@iWI"∂          else
            true
          end
        else
          false
        end
      end
      
      # Returns +true+ if +attribute+ is an attribute method and table exists,;Fi[	@Ÿi+I"s        if (var - var).any? then
          ActiveSupport::Deprecation.warn("It looks like you are eager loading table(s) (one of: #{string_tables.join(", ")}) that are referenced in a string SQL snippet. For example: \n\n    Post.includes(:comments).where(\"comments.title = 'foo'\")\n\nCurrently, Active Record recognises the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:\n\n    Post.includes(:comments).where(\"comments.title = 'foo'\").references(:comments)\n\n")
          true
        else
          false
        end
      end
    end
    ;Ti[	@üièI"ß      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    
    def function(arglist);Fi[	@7i?I"¶          if @var.key?(var) then
            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end
      ;Fi[	@ÿ;iI"i      true
    when String, Array then
      var.length.zero?
    else
      false
    end
  end
end;Fi[	@íivI"      def function(arglist)
        if unlock_strategy_enabled?(:time) then
          locked_at and (locked_at < self.class.unlock_in.ago)
        else
          false
        end
      end
      
      # Checks whether the record is locked or not, yielding to the block;Fi[	@ªiãI"     var = var.class.base_class.name
    if self.hidden_shareables.has_key?(var) then
      self.hidden_shareables[var].include?(var.id.to_s)
    else
      false
    end
  end
  
  def function(arglist);Fi[	@ªiNI"Ø    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  
  def self.build(arglist);Fi[	@Z	i{I"      def function(arglist)
        if instance_variable_defined?("@#{name}") then
          return instance_variable_get("@#{name}")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly;Fi[	@Z	i≠I"      def function(arglist)
        if instance_variable_defined?("@#{name}") then
          return remove_instance_variable("@#{name}")
        else
          false
        end
      end
      
      # Is the object's size changable? Only returns true for arrays and hashes;Fi[	@i'I"           (var.method(var).arity == 0) ? (var.send(var)) : (var.send(var, var))
        when Proc then
          var.call(var)
        else
          false
        end
      end
      
      # Determines if only updates can occur. Only valid for one-to-one;Fi[	@UiÁI"®  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  
  def function(arglist);Fi[	@Ô%i@I"˙      end.compact
      if (var.length == var.length) then
        TransitionCollection.new(var, :actions => (var)).perform
      else
        false
      end
    end
    
    # Builds the collection of transitions for all event attributes defined on;Fi[@'@(I"return var;FI"end;Fi[[	@>imI"Ï            var.each { |arglist| var[var] += " #{order.upcase}" }
          else
            # do nothing
          end
        end
        return var
      end
      
      # Overridden by the mysql adapter for supporting index lengths;Fi[	@IiSI"æ            var.each { |arglist| var[var] += "(#{length})" }
          else
            # do nothing
          end
        end
        return var
      end
      
      def function(arglist);Fi[	@«iïI"‹              var = var.instance_variable_get("@cell_matrix")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      
      def function(arglist);Fi[	@UizI"˚            var.encode(var)
          rescue Encoding::UndefinedConversionError => var
            yield("Invalid #{encoding.name} character #{e.error_char.dump}\n".rstrip, (var + 1))
          end
        end
        return var
      end
    end
    ;Fi[	@ài%I"∞      unless (var.include?(var) or var.nil?) then
        yield(var, var) if block_given?
        (var << var)
      end
    end
    return var
  end
  
  def function(arglist);Fi[	@£i I"®        var.each { |arglist| (var << install_p(var, var)) }
      else
        (var << install_p(var))
      end
    end
    return var
  end
  
  def function(arglist);Fi[	@£iGI"∏        var.each { |arglist| (var << install_symlink_p(var, var)) }
      else
        (var << install_symlink_p(var))
      end
    end
    return var
  end
  
  def function(arglist);Fi[	@}i.I"ò        while var do
          var[var[1]] = var[2]
          var = var[0]
        end
      end
      return var
    end
    
    def function(arglist);Fi[	@1 iVI"«        var = var.normalize.to_s)
      rescue URI::InvalidURIError
        raise(InvalidOpenId.new("#{identifier} is not an OpenID identifier"))
      end
    end
    return var
  end
  
  protected;Fi[	@ciÔ
I"c          var = []
          var = 1
        end
      end
    end
    return var
  end
  
  #;Fi[	@ci0I"≤          (var << (var >> 8).chr)
          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  
  # ====================================================;Fi[	@itI"≈            var = var.read
          else
            (var << "<!-- Ruby Zlib not available for SVGZ -->")
          end
        end
        return var
      end
      
      attr_accessor(:height);Fi[	@ifI"            (var = var[var]
            var = var ? (((var + "; ") + var)) : (var)
            var[var] = var.strip.squeeze(" "))
          end
        end
        return var
      end
      
      # Override and place code to add defs here;Fi[	@	iBI"Œ            var = @var[-1][:data].min
          else
            var = @var.collect { |arglist| var[:data].min }.min
          end
        end
        return var
      end
      
      def function(arglist);Fi[@	)@≤BI"end;FI" ;Fi[[	@ûiI"Ó        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûiI"˚        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûiI"‹        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@ûi"I"Ω        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var);Fi[	@ûi/I"      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûi3I"Î        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@ûi;I"Î        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûi?I"·        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@ûiGI"—        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var);Fi[	@ûiOI"Î        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûiSI"        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var, var, var, var, var, var, var) do |arglist|;Fi[	@ûicI"€        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@ûioI"‹        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûisI"·        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var);Fi[@'@¸@ˇ,@≤Bi[[	@ûiI"«      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûiI"Ã      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûiI"Ã      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûi I"≠      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûi1I"      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûi9I"º      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûi=I"Ã      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûiEI"≤      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûiMI"º      
      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûiQI"Ã      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûiaI"∆      
      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûimI"≠      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[	@ûiqI"Ã      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      ;Fi[@	)I"@var[var];FI"end;FI" ;Fi[[	@
iI"O      #   task.read_attribute_before_type_cast('id')           # => '1'
      #   task.read_attribute('completed_on')                  # => Sun, 21 Oct 2012
      #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      ;Fi[	@ri´I"æ            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var);Fi[	@'iΩI"J    end
    
    # Determine if a record was created or destroyed in a transaction. State should be one of :new_record or :destroyed.
    def function(arglist)
      @var[var]
    end
    
    # Determine if a transaction included an action for :create, :update, or :destroy. Used in filtering callbacks.
    def function(arglist);Fi[	@?i~I"à    
    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist)
      @var[(var or false)] ||= {};Fi[	@%iOI"®        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "#{name} (#{version})";Fi[	@¬iI"ß        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	@}iI"ï        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var);Fi[	@ñiBI"™          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line;Fi[	@¨i1I"ù        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var;Fi[	@ÊiﬁI"ù        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var);Fi[	@CiäI"À          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({});Fi[	@]iBI"ò          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        
        protected
        ;Fi[	@ˇ&iI"4    #   
    #   states.at(0).name    # => :parked
    #   states.at(1).name    # => :idling
    def function(arglist)
      @var[var]
    end
    
    # Gets the node indexed by the given key.  By default, this will look up the
    # key in the first index configured for the collection.  A custom index can;Fi[@µ @°+@≤BI"end;Fi[[	@ûiI"‘      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûiI"·      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûiI"·      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûi!I"¬      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûi2I"·      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûi:I"—      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûi>I"·      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûiFI"«      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûiNI"—      def function(arglist)
        broadcast(var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûiRI"·      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûibI"€      def function(arglist)
        broadcast(var, var, var, var, var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûinI"¬      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[	@ûirI"·      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist);Fi[@(@ó4@">I"end;Fi[[	@iiI"º      attr_reader(:object, :name, :values, :column)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@ÑibI"        # Instantiates a new Campfire::Room object and sets all the
        # necessary arguments (@room_id, @subdomain, @api_token)
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##;Fi[	@6iI"â    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function;Fi[	@"iI"≥    
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Needed before installs, since the arch matters then and quick;Fi[	@˜i=I"„          attr_reader(:configuration, :condition, :server)
          
          def function(arglist)
            @var = var
            @var = var
            @var = var
          end
          
          def function(arglist);Fi[	@ñiBI"“        var = ensure_array_of_array(rubify(var))
        var = var.transpose
        create_cell_matrix(var)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@i-I"π        def function(arglist)
          @var = var
          @var = var
          @var = var
          @var = var
          @var = var
        end
        
        def function(arglist);Fi[	@iI"¨      attr_reader(:tag_expressions)
      
      def function(arglist)
        @var = var
        @var = var
        @var = var
      end
      
      def function(arglist);Fi[	@ØiùI"¥  
  # The user can chose to force installation even in the face of conflicts.
  def function(arglist)
    @var = var
    @var = var
    @var = var
  end
  
  def function(arglist);Fi[	@÷4iI"∏    # name - The String filename of the file.
    def function(arglist)
      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    # Returns source file path.;Fi[	@Â	iI"Æ        attr_reader(:exception, :attribute)
        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      ;Fi[	@Mi
I"®    attr_accessor(:file, :options, :attachment)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var
    end
    
    def function(arglist);Fi[	@iI"˛      # The payload object associated with the failed job
      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = var
      end
      
      # When a job fails, a new instance of your Failure backend is created;Fi[@'@¸@ˇ,I"@var = nil;Fi[[	@}iTI"ƒ      # actually gets built.
      def function(arglist)
        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@ﬂiœI"¢      
      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@«igI"î      def function(arglist)
        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@«i}I"√      def function(arglist)
        @var = true
        (@var << "<div class=\"background\">")
      end
      
      def function(arglist)
        @var = nil
        (@var << "</div>")
      end;Fi[	@ÊiVI"ö        @var = 2
        @var = 2
        @var = true
      end
      
      def function(arglist)
        @var = nil
        @var.puts
        @var.flush;Fi[	@ÊiuI"ê      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
        @var = 4
      end;Fi[	@Êi©I"Ø      def function(arglist)
        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@Èi3I"Ü      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@
i.I"õ      def function(arglist)
        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@iÄI"í      
      def function(arglist)
        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      ;Fi[	@EigI"”      return if (@var.dry_run? or @var)
      @var = var
      @var.fire_hook(:before, var)
    end
    
    def function(arglist)
      @var = nil
      return if @var.dry_run?
      @var.fire_hook(:after, var);Fi[	@;i?I"        log("Duplicate path for #{name} with #{default_path}. This will clash with attachment defined in #{@names_path[name][:class]} class")
      end
      @var[var] = { :path => (var), :class => (var) }
    end
    
    def function(arglist)
      @var = nil
    end
  end;Fi[	@i}I"¥          custom_values.each(&:save)
          @var = false
          true
        end
        
        def function(arglist)
          @var = nil
          @var = true
        end;Fi[@µ @°+I"@var = true;FI"end;Fi[[	@XiI"ü        @var = var["version"]
        @var = @var
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@Xi#I"£      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def self.from_lock(arglist);Fi[	@_iI"Ù        @var = false
        @var = ([Bundler.app_cache] + Bundler.rubygems.gem_path.map { |arglist| File.expand_path("#{p}/cache") })
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@_iI"ù      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@gi>I"©      def function(arglist)
        tell_me(var, :red, var)
      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function;Fi[	@giHI"•      def function(arglist)
        @var.!.! and @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@˜i&I"¢        end
        
        attr_reader :function
        
        def function(arglist)
          @var = true
        end
        
        def function(arglist);Fi[	@’i I"å      def function(arglist)
        @var.!
      end
      
      def function(arglist)
        @var = true
      end
      
      protected;Fi[	@`(iI"†      super("Undefined step: \"#{step_name}\"")
      @var = var
    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function;Fi[	@ﬁi3I"√        Interceptor::Pipe.unwrap!(:stdout)
        Interceptor::Pipe.unwrap!(:stderr)
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@Èi>I"©        var ||= @var
        progress(var) unless table_header_cell?(var)
      end
      
      def function(arglist)
        @var = true
      end
      
      private;Fi[	@i†I"ù      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end
      
      def function(arglist);Fi[	@ƒ3iI"ê  def function(arglist)
    return plugin_manager.process_filters(var, :from_guzzoni)
  end
  
  def function(arglist)
    @var = true
  end
end;Fi[@	)I"var;FI"end;FI"end;Fi[[	@ViÏI"¢            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@ViÚI"¢        end
        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Integer < Type;Fi[	@riI"¢            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        
        class Identity < Type;Fi[	@riI"†        end
        
        class Identity < Type
          def function(arglist)
            var
          end
        end
        
        class Bytea < Type;Fi[	@ri=I"-          # FIXME: this should probably split on +delim+ and use +subtype+
          # to cast the values.  Unfortunately, the current Rails behavior
          # is to just return the string.
          def function(arglist)
            var
          end
        end
        
        class Array < Type;Fi[	@§iµI"§      end
      
      class LogFormatter < ::Logger::Formatter
        def function(arglist)
          var
        end
      end
      
      def function(arglist);Fi[	@«iI"†      
      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin;Fi[	@HiëI"à      include(Base)
      
      # @see Base#render
      def function(arglist)
        var
      end
    end
    
    module Javascript;Fi[	@˚#iI"Q      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[	@è	i©I"ì      # @return [ Object ] The serialized default.
      #
      # @since 3.0.0
      def function(arglist)
        var
      end
    end
  end
end;Fi[	@s+iI"ºmodule Paperclip
  class IdentityAdapter < AbstractAdapter
    def function(arglist)
      var
    end
  end
end
Paperclip.io_adapters.register(Paperclip::IdentityAdapter.new) do |arglist|;Fi[	@Ui
I"Æ    module Formatter
      class SnippetExtractor
        class NullConverter
          def function(arglist)
            var
          end
        end
        
        begin;Fi[	@ÿi√I"W  end
  
  #Stub -- override in subclass
  def function(arglist)
    var
  end
end;Fi[@'I"end.compact;FI"end;FI" ;Fi[[	@ÉibI"              nil
            else
              IndexDefinition.new(var, var, var, var, [], var, var)
            end
          end.compact
        end
        
        # Returns the list of all column definitions for a table.
        def function(arglist);Fi[	@i2I"ú        else
          var = var.to_s
          var.split(".").first.to_sym if var.include?(".")
        end
      end.compact
    end
    
    private
    ;Fi[	@xi%I"¸              Logger.warn("No public key was found in #keys for '#{identifier}'")
              # do nothing
            end
          end
        end.compact
      end
      
      ##
      # Returns the #keys hash set by the user with all identifiers;Fi[	@iÉI"“            StepMatch.new(var, var, var, var)
          else
            nil
          end
        end.compact
      end
      
      def function(arglist)
        (@var << JsStepDefinition.new(self, var, var));Fi[	@iII"∏            StepMatch.new(var, var, var, var)
          else
            nil
          end
        end.compact
      end
      
      ARGUMENT_PATTERNS = ["\"(.*?)\"", "(\\d+)"]
      ;Fi[	@ai~I"é        Pathname.new($1)
      else
        # do nothing
      end
    end.compact
  end
  
  def function(arglist)
    tapped_formula_for(:A);Fi[	@¥	i!I"        unless (var == "_id") then
          var = var.options[:as]
          "#{name}#{as ? ("(#{as})") : (nil)}: #{@attributes[name].inspect}"
        end
      end.compact
    end
    
    # Get an array of inspected dynamic fields for the document.
    #;Fi[	@	i!I"Ò            logger.info("MONGOID: Index: #{index}, Options: #{options}")
          end
          var
        end
      end.compact
    end
    
    # Remove indexes for each model given the provided globs and the class is
    # not embedded.;Fi[	@`i6I"∏            nil
          else
            nested_description_from(var)
          end
        end.compact
      end
      
      def function(arglist)
        var.description_args.join;Fi[	@Íi]I"S            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)))
          rescue Twitter::Error::Forbidden => var
            raise unless (var.message == Twitter::Error::AlreadyFavorited::MESSAGE)
          end
        end.compact
      end
      
      (alias :fav :favorite)
      ;Fi[	I"<data//twitter_proj/twitter/api/friends_and_followers.rb;Ti°I"            object_from_response(Twitter::User, :post, "/1.1/friendships/create.json", merge_user(var.options, var))
          rescue Twitter::Error::Forbidden
            # do nothing
          end
        end.compact
      end
      
      (alias :friendship_create! :follow!)
      ;Fi[	@;iïI"b            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var
            raise unless (var.message == Twitter::Error::AlreadyRetweeted::MESSAGE)
          end
        end.compact
      end
      
      # Retweets the specified Tweets as the authenticating user and raises an error if one has already been retweeted
      #;Fi[	@;i∞I"            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var
            handle_forbidden_error(Twitter::Error::AlreadyRetweeted, var)
          end
        end.compact
      end
      
      # Updates the authenticating user's status with media
      #;Fi[I"	end);FI"end;FI" ;FI"def function(arglist);Fi[[	@àiGI"¿            var[var[0]] = var[1]
            var
          end
        end)
      end
      
      def function(arglist)
        @var, @var, @var, @var, @var = var
        prepare_default_proc;Fi[	@JiôI"˛          Bundler.user_bundle_path.join("cache/git", var)
        else
          Bundler.cache.join("git", var)
        end)
      end
      
      def function(arglist)
        "#{base_name}-#{shortref_for_path((cached_revision or revision))}"
      end;Fi[	@±ioI"q      not_debugging?(var) and (var.message =~ /wrong number of arguments/ and begin
        (var = sans_backtrace(var.backtrace, var)
        (var.empty? or ((var.size == 1) and (RUBY_VERSION >= "1.9"))))
      end)
    end
    
    def function(arglist)
      not_debugging?(var) and var.message =~ /^undefined method `#{name}' for #{Regexp.escape(var.to_s)}$/
    end;Fi[	@ìiI"◊          var = var.step_invocation
          var.background = var
          var
        end)
      end
      
      def function(arglist)
        @var.map { |arglist| var.step_invocation_from_cells(var) }
      end;Fi[	@Â#i!I"ˇ    end
    var = (var + var.connection.select_values("#{construct_public_followings_sql(opts).to_sql} LIMIT #{opts[:limit]}").map do |arglist|
      var.to_i
    end)
  end
  
  def function(arglist)
    var = var.table_name
    var = prep_opts(var, var);Fi[	I"5data//diaspora_proj/presenters/user_presenter.rb;TiI"·    var = self.aspects_ids.empty?
    var.each do |arglist|
      var[:selected] = (var or self.aspects_ids.include?(var[:id].to_s))
    end)
  end
  
  def function(arglist)
    @var ||= user.unread_notifications.count
  end;Fi[	@8iI"Ü      end
    else
      # do nothing
    end)
  end
  
  def function(arglist)
    var = @var.fails_with?(@var)
    return unless var;Fi[	@éi=I"j          end
        end
      end
    end)
  end
  
  def function(arglist)
    prefix.nil?.!
  end;Fi[	@ìi$I"û      else
        MacOS.pkgutil_info(FORGE_PKG_ID) =~ /version: (\d\.\d\.\d).+$/ and $1
      end
    end)
  end
  
  def function(arglist)
    "2.7.4"
  end;Fi[	@äi´I"    var = RecursivelyCascadedTreeMixin.find(:first, :include => ({ :children => ({ :children => :children }) }), :order => "mixins.id")
    assert_equal(@var, assert_no_queries do |arglist|
      var.children.first.children.first.children.first
    end)
  end
  
  def function(arglist)
    var = RecursivelyCascadedTreeMixin.find(:first, :include => ({ :first_child => ({ :first_child => :first_child }) }), :order => "mixins.id")
    assert_equal(@var, assert_no_queries { |arglist| var.first_child.first_child.first_child });Fi[	@ci4I"z        Spec.deprecate("ExampleGroupProxy#filtered_description", "gsub (or similar) to modify ExampleGroupProxy#description")
        ExampleGroupMethods.build_description_from(*nested_descriptions.collect do |arglist|
          var.=~(var) ? (var.gsub($1, "")) : (var)
        end)
      end
      
      def function(arglist)
        (var.description == description)
      end;Fi[	@ri#I"‹          explanation
        else
          "expected #{@description.inspect} but got #{@given.inspect}"
        end)
      end
      
      def function(arglist)
        (@var or if @var.nil? then
          explanation;Fi[	@ri+I"˙          explanation
        else
          "expected not to get #{@description.inspect}, but got #{@given.inspect}"
        end)
      end
      
      def function(arglist)
        "No description provided. See RDoc for simple_matcher()"
      end;Fi[I"raise(var);FI"end;FI"end;FI" ;Fi[[	@Fi%I"¯          @var.error(var) if @var
          var = translate_exception(var, var)
          var.set_backtrace(var.backtrace)
          raise(var)
        end
      end
      
      def function(arglist)
        ActiveRecord::StatementInvalid.new(var);Fi[	@õi%I"î        var)
      rescue Exception => var
        restore_query_cache_settings(var, var)
        raise(var)
      end
    end
    
    private
    ;Fi[	@˝iﬂI"`        if Bundler.definition.no_sources? then
          Bundler.ui.warn("Your Gemfile has no remote sources. If you need gems that are not already on\nyour machine, add a line like this to your Gemfile:\n    source 'https://rubygems.org'")
        end
        raise(var)
      end
    end
    
    desc("update", "update the current environment")
    ;Fi[	@iÑI"          end
          var = ConnectionError.new("connection failed for: #{errors.join(", ")}")
          var.hosts = var.map { |arglist| var[:server] }
          raise(var)
        end
      end
      
      # Destroys sessions for each server in the list.
      def function(arglist);Fi[	@ñiŸI"Ò          require("diff/lcs")
        rescue LoadError => var
          (var.message << "\n Please gem install diff-lcs\n")
          raise(var)
        end
      end
      
      def function(arglist)
        @var = @var = @var = @var = nil;Fi[	@≠iHI"C    rescue Exception => var
      var = "(string):#{(71 - 2)}:in `cucumber_run_with_backtrace_filtering'"
      replace_instance_exec_invocation_line!((var.backtrace or []), var, var)
      raise(var)
    end
  end
  
  INSTANCE_EXEC_OFFSET = if (Cucumber::RUBY_1_9 or (Cucumber::RUBY_1_8_7 or Cucumber::JRUBY)) then
    -3;Fi[	@≤i1I"        var)
      rescue Gherkin::Lexer::LexingError, Gherkin::Parser::ParseError => var
        var.message.insert(0, "#{@path}: ")
        raise(var)
      end
    end
    
    def function(arglist)
      @var ||= if @var =~ /^http/ then;Fi[	@i3I"‘        begin
          var = RubyPython.import(var)
        rescue RubyPython::PythonError => var
          raise(var)
        end
      end
      
      def function(arglist)
        var = File.expand_path(var);Fi[	@=iAI"$          step_match(var).invoke(var)
        rescue Exception => var
          var.nested! if Undefined.===(var)
          raise(var)
        end
      end
      
      # Loads and registers programming language implementation.
      # Instances are cached, so calling with the same argument;Fi[	@IiI"”              "(haml):#{($1.to_i - 1)}"
            end
          end
          raise(var)
        end
      end
      
      # @return [String] A human-readable string representation
      def function(arglist);Fi[	@ÄiI"      puts("For your reference the SHA1 is: #{fn.sha1}")
    rescue ChecksumMismatchError => var
      var.advice = "    Archive: #{fn}\n    (To retry an incomplete download, remove the file above.)\n".undent
      raise(var)
    end
  end
  
  Checksum::TYPES.each do |arglist|
    class_eval("\n      def #{cksum}(val=nil)\n        if val.nil?\n          @checksum if @checksum.nil? or @checksum.hash_type == :#{cksum}\n        else\n          @checksum = Checksum.new(:#{cksum}, val)\n        end\n      end\n    ");Fi[	@,iaI"‹        return var)
      rescue Object => var
        run_failure_hooks(var)
        raise(var)
      end
    end
    
    # Returns the actual class constant represented in this job's payload.
    def function(arglist);Fi[	@YirI"        begin
          return @var = var.__send__(present_tense_predicate, *@var, &@var)
        rescue NameError
          raise(var)
        end
      end
      
      def function(arglist)
        "expected #{predicate}#{args_to_s} to return true, got #{@result.inspect}";Fi[I"nil;FI"end;FI"end;FI" ;Fi[[	@xiRI"          var)
        rescue => var
          Logger.warn(Errors::Encryptor::GPG::KeyImportError.wrap(var, "Public key import failed for '#{identifier}'"))
          nil
        end
      end
      
      ##
      # Parse the information for all the public keys found in the public;Fi[	@Bi;I"√        begin
          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var
          nil
        end
      end
      
      def function(arglist)
        var = nil;Fi[	@ªikI"±    begin
      self.invitations_to_me.first.sender.invitation_code
    rescue Exception => var
      nil
    end
  end
  
  def function(arglist)
    self.invited_by = var.user;Fi[	@¸iËI"Õ      if var and (var < (self.site.posts.length - 1)) then
        self.site.posts[(var + 1)]
      else
        nil
      end
    end
    
    def function(arglist)
      var = self.site.posts.index(self);Fi[	@|i]I"–        if relation.stores_foreign_key? and polymorphic? then
          "#{name}_#{field}"
        else
          nil
        end
      end
      
      # Deterimene the inverses that can be memoized.
      #;Fi[	@i≠I"∆              # do nothing
            end)
          rescue Nokogiri::SyntaxError, RuntimeError
            nil
          end
        end
        
        def function(arglist)
          @var = var;Fi[	@ièI"‹      when String then
        var.scan(/.{3}/).first(3).join("/")
      else
        nil
      end
    end
    
    # Returns the pluralized form of the attachment name. e.g.
    # "avatars" for an attachment of :avatar;Fi[	@õi/I"}        var.to_s = var
        var
      else
        nil
      end
    end
    
    def self.attach(arglist)
      find(var);Fi[	@õiÓI"√        end
      rescue NotImplementedError
        @var = true
        nil
      end
    end
    
    # Runs all the methods needed when a worker begins its lifecycle.
    def function(arglist);Fi[	@ûi‚I"≤    begin
      queue(var).pop(true)
    rescue ThreadError
      nil
    end
  end
  
  # Returns an integer representing the size of a queue.
  # Queue name should be a string.;Fi[	@niI"ª            best_match[:example_group].description
          end
        else
          nil
        end
      end
      
      def function(arglist)
        determine_best_match(var, var);Fi[	@€iI"#          when :string_literal then
            var.jump(:tstring_content).source
          else
            nil
          end
        end
        
        # Extracts the values from the node as either strings or symbols.
        # If the node isn't an array, it'll be converted to an array.;Fi[	@'iEI"Å      begin
        send(var.to_sym)
      rescue NoMethodError
        nil
      end
    end
    
    attr_reader :function
    ;Fi[@eD@fD@gDI"end;Fi[[	@ji=I"Æ          begin
            Kernel.Float(var)
          rescue ArgumentError, TypeError
            nil
          end
        end
      end
      
      def function(arglist);Fi[	@Ii!I"Û            var = $1.split(",").map { |arglist| var.delete("`\"") }
            (var.length == 1) ? ([var.first, nil]) : (nil)
          else
            nil
          end
        end
      end
      
      # Returns just a table's primary key;Fi[	@ûiCI"∫          begin
            var.instance_variable_set("@#{fixture_name}", var.find)
          rescue FixtureClassNotFound
            nil
          end
        end
      end
    end
    ;Fi[	@,i*I"”          if engine_version.!=(var.engine_version) and @var then
            [:engine_version, engine_version, var.engine_version]
          else
            nil
          end
        end
      end
    end
  end;Fi[	@irI"-          if base.respond_to?(var, true) then
            raise(Thor::PrivateMethodEncodedError, "Method #{base.class}##{sym} should be public, not private")
          else
            nil
          end
        end
      end
      
      # Receives a hash of options and just execute the block if some;Fi[	@(iI"á            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@=i≤I"e            nil
          end
        else
          nil
        end
      end
    end
  end
end;Fi[	@9i$I"{          var.email_the_user(var, var)
          var
        else
          nil
        end
      end
    end
  end
  ;Fi[	@.igI"à    when /^#{HOMEBREW_LIBRARY}\/Formula\/(.+)/ then
      "mxcl/master/#{File.basename($1, ".rb")}"
    else
      nil
    end
  end
end;Fi[	@àiMI"¨        Object.send(:remove_const, Formula.class_s(name))
        var)
      rescue SyntaxError, TypeError, NameError, ArgumentError
        nil
      end
    end
  end
end;Fi[	@÷4iAI"a    
    def self.reset_cache(arglist)
      @@mtimes = Hash.new
      nil
    end
  end
end;Fi[	@	iWI"u            var.push(var))
          rescue => var
            logger.error("MONGOID: Failed to determine model from #{file}:\n              #{e.class}:#{e.message}\n              #{e.backtrace.join("\n")}\n            ")
            nil
          end
        end
      end
      var = ::Mongoid.models.|(var) if var
      var.compact.sort_by { |arglist| (var.name or "") };Fi[I"
raise;FI"end;FI"end;FI"end;Fi[[	@(iÈI"≈          ActiveRecord::Base.clear_active_connections! unless var
        end
        var) rescue ActiveRecord::Base.clear_active_connections! unless var
          raise
      end
    end
  end
end;Fi[	@0i›I"æ            commit_transaction unless var
          rescue Exception
            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function;Fi[	@IiÓI"E          if var.message.split(":").first =~ /Packets out of order/ then
            raise(ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.")
          else
            raise
          end
        end
      end
      
      # MysqlAdapter has to free a result after using it, so we use this method to write;Fi[	@!iI"–          if /database .* already exists/.===(var.message) then
            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      
      def function(arglist);Fi[	@˝i5I"˝          Bundler.ui.error(var.message)
          Bundler.ui.warn("The ruby graphviz gem requires GraphViz to be installed")
        else
          raise
        end
      end
    end
    
    desc("gem GEM", "Creates a skeleton for creating a rubygem");Fi[	@∫i)I"¢        Rails.logger.debug("[Devise] Trying to deserialize invalid class #{klass_name}")
        # do nothing
      else
        raise
      end
    end
  end
end;Fi[	I"!data//homebrew_proj/build.rb;Ti|I"Œ        if ((var = var.rack.children).size == 1) and var.first.directory? then
          var.first
        else
          raise
        end
      end
    end
    Keg.new(var).optlink)
  rescue StandardError;Fi[	@ai;I"ú      end
    rescue Exception
      FileUtils.rm_rf(".git")
      raise
    end
  end
end
class Updater
  attr_reader(:initial_revision, :current_revision);Fi[	@îiKI"˙          if var.kind_of?(ErrorDuringExecution) then
            raise(CurlDownloadStrategyError, "Download failed: #{@url}")
          else
            raise
          end
        end
      end
      return @var)
    rescue CurlDownloadStrategyError;Fi[	@ki:I"K      if var then
        raise("        Multiple kegs installed to #{rack}\n        However we don't know which one you refer to.\n        Please delete (with rm -rf!) all but one and then try again.\n        Sorry, we know this is lame.\n".undent)
      else
        raise
      end
    end
  end
  
  # self documenting perhaps?;Fi[	@õi”I"’          retry
        else
          Resque.logger.info("Error reconnecting to Redis; quitting")
          raise
        end
      end
    end
    
    # Returns a list of queues to use when searching for a job.;Fi[	@wiI"¯        if (var.message == "no acceptor") then
          raise("Cannot start the server on port #{$APP_CONFIG.port} - are you root, or have another process on this port already?")
        else
          raise
        end
      end
    end
  end
end;Fi[@'@(@éI"module HelperMethods;Fi[[	@Pi
I"2    class AbsenceValidator < EachValidator
      def function(arglist)
        var.errors.add(var, :present, options) if var.present?
      end
    end
    
    module HelperMethods
      # Validates that the specified attributes are blank (as defined by
      # Object#blank?). Happens by default on save.;Fi[	@SiI"P        var = attributes.reject { |arglist| var.attribute_method?("#{name}=") }
        var.send(:attr_reader, *var)
        var.send(:attr_writer, *var)
      end
    end
    
    module HelperMethods
      # Encapsulates the pattern of wanting to validate the acceptance of a
      # terms of service check box (or similar agreement).;Fi[	@\iI"M        var.send(:attr_accessor, *attributes.map do |arglist|
          :"#{var}_confirmation" unless var.method_defined?(:"#{var}_confirmation")
        end.compact)
      end
    end
    
    module HelperMethods
      # Encapsulates the pattern of wanting to validate a password or email
      # address field with a confirmation.;Fi[	@_iI",        if include?(var, var) then
          var.errors.add(var, :exclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates that the value of the specified attribute is not in a
      # particular enumerable object.;Fi[	@bi4I"«            raise(ArgumentError, "The provided regular expression is using multiline anchors (^ or $), which may present a security risk. Did you mean to use \\A and \\z, or forgot to add the :multiline => true option?")
          end
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is of the correct
      # form, going by the regular expression provided.You can require that the;Fi[	@giI"9        unless include?(var, var) then
          var.errors.add(var, :inclusion, options.except(:in, :within).merge!(:value => (var)))
        end
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is available in a
      # particular enumerable object.;Fi[	@ûiBI"2      
      def function(arglist)
        (var == :maximum) and (options[:allow_nil].nil? and options[:allow_blank].nil?)
      end
    end
    
    module HelperMethods
      # Validates that the specified attribute matches the length restrictions
      # supplied. Only one option can be used at a time:;Fi[	@jiHI"5      
      def function(arglist)
        options.except(*RESERVED_OPTIONS).merge!(:value => (var))
      end
    end
    
    module HelperMethods
      # Validates whether the value of the specified attribute is numeric by
      # trying to convert it to a float with Kernel.Float (if <tt>only_integer</tt>;Fi[	@mi
I"3    class PresenceValidator < EachValidator
      def function(arglist)
        var.errors.add(var, :blank, options) if var.blank?
      end
    end
    
    module HelperMethods
      # Validates that the specified attributes are not blank (as defined by
      # Object#blank?). Happens by default on save.;Fi[	@¯i3I"f        unless (options.has_key?(:content_type) or options.has_key?(:not)) then
          raise(ArgumentError, "You must pass in either :content_type or :not to the validator")
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the content type of the file
      # assigned. The possible options are:;Fi[	@˚iI"‘            var.errors.add(var, :blank, options)
          end
        end
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the presence of a file.
      # Options:;Fi[	@ iMI"        var = var.call(var) if var.respond_to?(:call)
        var = var.max if var.respond_to?(:max)
        human_size(var)
      end
    end
    
    module HelperMethods
      # Places ActiveRecord-style validations on the size of the file assigned. The
      # possible options are:;Fi[@'@¸@ˇ,I"(@var << var);Fi[[	@di;I"ø    def function(arglist)
      var = var.name if var.respond_to?(:name)
      lookup[var].reverse
    end
    
    def function(arglist)
      (@var << var)
      @var = nil
      @var = nil;Fi[	@ui"I"è          var.init
          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      ;Fi[	@xiI"ã      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      ;Fi[	@ñiI"ö        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        ;Fi[	@«i1I"∞        build_cell(@var, var, var)
        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      ;Fi[	@iI"à      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      ;Fi[	@1i	I"àclass BuildEnvironment
  def function(arglist)
    @var = Set.new(var)
  end
  
  def function(arglist)
    (@var << var)
    self
  end;Fi[	@8iI"±  def function(arglist)
    var = var.name if var.is_a?(Compiler)
    @var.any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    (@var << var)
    self
  end;Fi[	@h$i4I"Æ    def function(arglist)
      @var = true
      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    ;Fi[	@xi¥I"y      end
      var
    end
  end
  
  def function(arglist)
    (@var << var)
    " :redsh##{@shelf.length}:"
  end;Fi[	@ÊiI"õ      def function(arglist)
        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      ;Fi[	@qi-I"ç        @var = []
        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      ;Fi[@V.@W.@X.I"###;Fi[[	@Fi—I"U      # The default implementation does nothing; the implementation should be
      # overridden by concrete adapters.
      def function(arglist)
        # do nothing
      end
      
      ###
      # Clear any caching the database adapter may be doing, for example
      # clearing the prepared statement cache. This is database specific.;Fi[	@ciNI"Ô      # XInclude end type
      # DOCB document node type
      def function(arglist)
        # do nothing
      end
      
      ###
      # Decorate this node with the decorators set up in this node's Document
      def function(arglist);Fi[	@}iI"‡        ###
        # Called when an XML declaration is parsed
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document starts parsing
        def function(arglist);Fi[	@}iI"Ÿ        ###
        # Called when document starts parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when document ends parsing
        def function(arglist);Fi[	@}iI"Á        ###
        # Called when document ends parsing
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element
        # * +name+ is the name of the tag;Fi[	@}i!I"2        # * +attrs+ are an assoc list of namespaces and attributes, e.g.:
        #     [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the end of an element
        # +name+ is the tag name;Fi[	@}i(I"ı        # Called at the end of an element
        # +name+ is the tag name
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called at the beginning of an element
        # +name+ is the element name;Fi[	@}iII"Í        #
        # +string+ contains the character data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when comments are encountered
        # +string+ contains the comment data;Fi[	@}iPI"ˇ        # Called when comments are encountered
        # +string+ contains the comment data
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document warnings
        # +string+ contains the warning;Fi[	@}iWI"Ì        # Called on document warnings
        # +string+ contains the warning
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called on document errors
        # +string+ contains the error;Fi[	@}i^I"˙        # Called on document errors
        # +string+ contains the error
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when cdata blocks are found
        # +string+ contains the cdata content;Fi[	@}ieI"        # Called when cdata blocks are found
        # +string+ contains the cdata content
        def function(arglist)
          # do nothing
        end
        
        ###
        # Called when processing instructions are found
        # +name+ is the target of the instruction;Fi[@À8@Ã8@¸@I" ;Fi[[	@ùivI"ô        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested;Fi[	@CirI"ò      end
      
      def function(arglist)
        true
      end
    end
    
    class RealTransaction < OpenTransaction
      def function(arglist);Fi[	@3i≥I"î            raise(var)
          end
        end
        true
      end
    end
    
    def function(arglist)
      var = class << Gem::SourceIndex;Fi[	@±iyI"á  
  class HiddenTask < Task
    def function(arglist)
      true
    end
  end
  
  class DynamicTask < Task
    def function(arglist);Fi[	@ßi1I"Ò          var.results.failure?)
        rescue ProfilesNotDefinedError, YmlLoadError, ProfileNotFound => var
          @var.puts(var.message)
          true
        end
      end
      
      def function(arglist)
        return @var if @var;Fi[	@úi@I"Ò    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist)
    var = StatusMessage.find_by_guid(self.status_message_guid);Fi[	@úiII"Õ    if self.status_message_guid and var then
      (self.diaspora_handle == var.diaspora_handle)
    else
      true
    end
  end
  
  def self.diaspora_initialize(arglist)
    var = self.new(var.to_hash);Fi[	@ªiöI"î    else
      self.add_hidden_shareable(var, var)
      self.save
      true
    end
  end
  
  def function(arglist)
    var = var.base_class.to_s;Fi[	@ÄisI"ê    when :provided_pre_mountain_lion then
      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function
  ;Fi[	@Ëi5I"†            @var[:fog_public]
          end
        else
          true
        end
      end
      
      def function(arglist)
        for var, var in @var do;Fi[	@æiI"‚      class FilesystemAdapter < AbstractAdapter
        class << self
          def function(arglist)
            true
          end
        end
        
        def function(arglist)
          @var = with_trailling_slash(var);Fi[	@„i]I"Ë        raise(var) if var
        var.!
      else
        true
      end
    end
    
    # Runs the machine's +before+ callbacks for this transition.  Only
    # callbacks that are configured to match the event, from state, and to;Fi[@(I"	self;FI"end;FI" ;Fi[[	@GiI"Ä      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@JiUI"Ä      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function
      ;Fi[	@⁄iI"û        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var = var;Fi[	@⁄i!I"¥        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist)
          @var, @var = var.first, var.last;Fi[	@ii!I""      # Convenience method for example group - updates the value of
      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        (var.description == description).&((var.location == location));Fi[	@üiDI"å      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@üiII"å      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@üiNI"å      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@üiSI"å      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        @var = var;Fi[	@üiXI"ó      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        "change ##{@message}";Fi[	@øiSI"«          @var = var.pluralize(var.to_s)
        end
        @var = var
        @var = var
        self
      end
      
      def function(arglist)
        "#{relativities[@relativity]}#{@expected}";Fi[	@oi#I"Ü      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self;Fi[@ =I"end;FI" ;FI"def function(arglist);Fi[[	@≤i:I"ñ    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      Association.valid_options
    end;Fi[	@ãiqI"      
      # Do the relevant stuff to insert the given record into the association collection.
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        scope.scope_for_create.stringify_keys
      end;Fi[	@ãiçI"Z      # Delete the given records from the association, using one of the methods :destroy,
      # :delete_all or :nullify (or nil, in which case a default is used).
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        delete((target - var))
        unless concat((var - target)) then;Fi[	@√iI"µ        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          @var ||= build_scope
        end;Fi[	@Ii)I"        
        # Must return the relevant concrete adapter
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist)
          collation and collation.match(/_ci$/).!
        end;Fi[	@íiI"©      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@íiI"©      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@íiI"©      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@íiI"©      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@íi I"©      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@íi$I"©      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end;Fi[	@≥i'I"˘    # perform any information gathering you need to be able to authenticate
    # the user in this phase.
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist)
      self.class.uid_stack(self).last
    end;Fi[@	)@ÂC@ÊCI" ;Fi[[	@3i^I"›      end
      
      # Quotes the column name. Defaults to no quoting.
      def function(arglist)
        var
      end
      
      # Quotes the table name. Defaults to column name quoting.
      def function(arglist);Fi[	@6iI"
    end
    
    class ColumnDefinition < Struct.new(:base, :name, :type, :limit, :precision, :scale, :default, :null)
      def function(arglist)
        var
      end
      
      def function(arglist)
        base.type_to_sql(type.to_sym, limit, precision, scale);Fi[	@FiI"§        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        var[var].lower.eq(var.lower(var));Fi[	@Ii4I"¬        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist)
        @var.fetch(:strict, true);Fi[	@Ωi I"Î      # This is a hook for use by modules that need to do extra stuff to
      # attributes when they are initialized. (e.g. attribute
      # serialization)
      def function(arglist)
        var
      end
      
      private
      ;Fi[	@§iÎI"≈      # Apply color to the given string with optional bold. Disabled in the
      # Thor::Shell::Basic class.
      #
      def function(arglist)
        var
      end
      
      protected
      ;Fi[	@VioI"©        # By default, this method simply returns the revision itself. If a
        # particular SCM is able to determine a subsequent revision given a
        # revision identifier, it should override this method.
        def function(arglist)
          var
        end
        
        # Should analyze the given text and determine whether or not a
        # response is expected, and if so, return the appropriate response.;Fi[	@viI"         
        # No versioning, so this just returns the argument, with no
        # modification.
        def function(arglist)
          var
        end
        
        # log: There's no log, so it just echos from and to.
        def function(arglist);Fi[	@\i-I"π            super(var)
          end
          
          def function(arglist)
            var
          end
          
          alias :handle_snippet_text :handle_success
        end;Fi[	@˚#iI"q      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var;Fi[	@Z	i˜I"Ë        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@e3i+I"«    end
    
    # Always returns the given set of values
    def function(arglist)
      var
    end
    
    # A human-readable description of this matcher.  Always "all".
    def function(arglist);Fi[@'@¸@ˇ,I"@var ||= [];Fi[[	@^i/I"í    # RubyGems 1.8+ used only.
    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    ;Fi[	@§iI"ú        var = (var + aliases_for_action(var)) if var.include?(var)
      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end
    ;Fi[	@ÈiÉI"ë            end
          end
        end
      end
      
      def function(arglist)
        @var ||= []
        (@var << [var, var])
      end;Fi[	@«iÌI"ƒ        end
        (@var << "</li>")
        print_messages
      end
      
      def function(arglist)
        @var ||= []
        var = (var and @var.!)
        @var = (@var.index(var) or var);Fi[	@
iUI"™      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      ;Fi[	@8i I"’          @var[var] = var
          scenarios.push(var)
        end
      end
      
      def function(arglist)
        @var ||= []
        var ? (@var.select { |arglist| (var.status == var) }) : (@var)
      end;Fi[	@8i%I"      def function(arglist)
        @var ||= []
        var ? (@var.select { |arglist| (var.status == var) }) : (@var)
      end
      
      def function(arglist)
        @var ||= []
        var ? (@var.select { |arglist| (var.status == var) }) : (@var)
      end;Fi[	@Äi;I"u    else
      Version.new(var)
    end
  end
  
  def function(arglist)
    @var ||= []
    (@var << var)
  end;Fi[	@i#I"        
        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        ;Fi[	@i'I"ö        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        ;Fi[	@]iI"∞        def function(arglist)
          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        ;Fi[	@€i‹I"ã      
      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      ;Fi[I"(@var << var);FI"end;FI" ;FI"def function(arglist);Fi[[	@
ifI"{          end
        end
      end
      (@var << var)
    end
    
    def function(arglist)
      begin
        case var;Fi[	@Li<I"Ø              var = new_row(var)
            end
          end
          (@var << var)
        end
        
        def function(arglist)
          fast_fit
          var = [];Fi[	@ui%I"•      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init;Fi[	@xiI"≥      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self }
      end;Fi[	@}iI"¡      
      def function(arglist)
        var.features = self
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var = Time.now;Fi[	@ñiI"†        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing
        end;Fi[	@«i4I"¨      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?
        @var.each do |arglist|;Fi[	@iI"é      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing
      end;Fi[	I"0data//homebrew_proj/compat/compatibility.rb;TiHI"
  def self.fails_with_llvm(arglist)
    var = FailsWithLLVM.new(var, var)
    @var ||= CompilerFailures.new
    (@var << var)
  end
  
  def function(arglist)
    "-DCMAKE_INSTALL_PREFIX='#{prefix}' -DCMAKE_BUILD_TYPE=None -DCMAKE_FIND_FRAMEWORK=LAST -Wno-dev"
  end;Ti[	@h$i7I"    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "\n<fieldset#{" style='#{options[:style]}'" if options[:style]}#{" id='#{options[:id]}'" if options[:id]}>\n  <legend>#{legend}</legend>\n")
      self.instance_eval(&var);Fi[	@ÊiI"ú      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var)
      end;Fi[	@qi0I"ë      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!
      end;Fi[I"@var[var];FI"end;FI" ;FI"def function(arglist);Fi[[	@ri¨I"∞          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist)
            @var.key?(var)
          end;Fi[	@i}I"◊      
      def function(arglist)
        var = @var.keys.detect { |arglist| var[var] }
        @var[var]
      end
      
      def function(arglist)
        var = [var]
        (var << "test") if var.development?;Fi[	@?iI"≠    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist)
      @var[(var or false)] ||= {}
      @var[(var or false)][var] ||= begin;Fi[	@%iPI"î      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        "#{name} (#{version})"
      end;Fi[	@7iXI"°            @var[var] = @var[var].call
          end
        end
        @var[var]
      end
      
      def function(arglist)
        fetch(var, nil)
      end;Fi[	@¬iÄI"ç      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	@iÅI"≤        
        def function(arglist)
          @var ||= {}
          @var[var]
        end
        
        def function(arglist)
          @var and (@var.size > 0)
        end;Fi[	@}iI"ç      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end;Fi[	@ñiCI"ú        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          @var[0].line
        end;Fi[	@¨i2I"ç      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end;Fi[	@ÊiﬂI"ß      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        print_stats(var, @var)
        print_snippets(@var);Fi[	@CiãI"…        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist)
          var = var.last.is_a?(Hash) ? (var.pop) : ({})
          case var.to_s;Fi[@	)I"@var = false;FI"end;FI" ;Fi[[	@Fi`I"›        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      
      # Returns the human-readable name of the adapter. Use mixed case - one
      # can always use downcase if needed.;Fi[	@ilI"ê      
      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false;Fi[	@ipI"ë        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        begin;Fi[	@ﬁi8I"¬        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        raise(UnNamedFeatureError.new(@var.file)) if var.empty?;Fi[	@ﬁiZI"ù        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@ÈiI"´        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(:failed) if @var;Fi[	@Èi(I"ô        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        progress(var);Fi[	@Ïi#I"À        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        if (@var or var.failed?) and Ast::ScenarioOutline.===(var).! then;Fi[	@Ïi=I"ù        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var;Fi[	@‰i¨I"∫      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist)
      @var.pop if ["if", "case", "unless"].include?(var.value[:keyword]);Fi[	@qiÄI"π      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        Spec::Runner.configuration.mock_framework;Fi[@	)@Ú)I"	self;FI"end;Fi[[	@GiI"Ü        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@JiTI"Ü        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      attr_reader :function;Fi[	@⁄iI"û          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@⁄i I"ò          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        
        def function(arglist);Fi[	@ii I"‚      
      # Convenience method for example group - updates the value of
      # <tt>description</tt> and returns self.
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@üiCI"‰        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@üiHI"Ü        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@üiMI"Ü        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@üiRI"Ü        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@üiWI"Ü        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[	@oi"I"ß        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist);Fi[@	)I"@var = [];FI"end;FI" ;Fi[[	@B)iI"Émodule ActiveRecord
  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      [];Fi[	@}iI"ó      
      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var];Fi[	@ñiI"¥      class Builder
        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var);Fi[	@∏i´I"|        @var.flush
      end
      
      def function(arglist)
        @var = []
      end
      
      private
      ;Fi[	@«iEI"}        empty_messages
      end
      
      def function(arglist)
        @var = []
      end
      
      protected
      ;Fi[	@iI"º    class PyLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var);Fi[	@ViI"Ω    class WireLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        # do nothing;Fi[	@èiI"ú  
  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist)
    (entries << { :name => (var), :action => (var) });Fi[	@û;iI"õ    
    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      (@var << [var, var]);Fi[	@iRI"(      # reuse it to create a new graph but with the same config options.
      #
      #   graph.clear_data
      def function(arglist)
        @var = []
      end
      
      # This method processes the template with the data and
      # config which has been set and returns the resulting SVG.;Fi[	@iI"Æmodule Spec
  module Runner
    class BacktraceTweaker
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        var.gsub!("//", "/");Fi[@'@¸@ˇ,I"return if @var;Fi[[	@iiI"˛      def function(arglist)
        @var, @var, @var, @var, @var, @var = var, var, var, var, var, var
        @var = []
      end
      
      def function(arglist)
        return if @var
        attach_steps(@var)
        @var = StepCollection.new(@var);Fi[	@Éi0I"      def function(arglist)
        init
        example_rows.each { |arglist| var.skip_invoke! }
      end
      
      def function(arglist)
        return if @var
        @var = true
        example_rows.each { |arglist| var.create_step_invocations!(var) };Fi[	@äi&I"        @var = (var or EmptyBackground.new)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
        @var = @var = nil
      end
      
      def function(arglist)
        return if @var
        @var.init
        (@var.feature_elements << self);Fi[	@çi!I"∆      
      def function(arglist)
        (@var << [var, var])
      end
      
      def function(arglist)
        return if @var
        attach_steps(@var)
        @var = StepCollection.new(@var);Fi[	@«i·I"'        return if @var
        set_scenario_color(var)
        (@var << "<li id='#{@step_id}' class='step #{status}'>")
      end
      
      def function(arglist)
        return if @var
        if (var == :undefined) then
          var = @var.multiline_arg ? (@var.multiline_arg.class) : (nil);Fi[	@«iI"      def function(arglist)
        return if (@var or @var)
        (@var << "</table>") if Ast::Table.===(var)
      end
      
      def function(arglist)
        return if @var
        @var.pre(:class => "val") do |arglist|
          (@var << h(var).gsub("\n", "&#x000A;"));Fi[	@«iI"‹        @var = 0
        return if @var
        (@var << "<tr class='step' id='#{@row_id}'>")
      end
      
      def function(arglist)
        return if @var
        print_table_row_messages
        (@var << "</tr>");Fi[	@«i'I"        @var = (@var + 1) if @var
        @var = (@var + 1)
        move_progress
      end
      
      def function(arglist)
        return if @var
        @var = (@var == 0) ? (:th) : (:td)
        var = { :id => ("#{@row_id}_#{@col_index}"), :class => "step" };Fi[	@ÊiéI"»          return
        end
        @var = var
      end
      
      def function(arglist)
        return if @var
        var = nil unless @var[:source]
        var = format_step(var, var, var, var);Fi[	@ÊiñI"B        var = format_step(var, var, var, var)
        @var.puts(var.indent((@var + 2)))
        print_messages
      end
      
      def function(arglist)
        return if @var
        var = "\"\"\"\n#{string}\n\"\"\"".indent(@var)
        var = var.split("\n").map { |arglist| var =~ /^\s+$/ ? ("") : (var) }.join("\n");Fi[	@ÊiûI"        var = var.split("\n").map { |arglist| var =~ /^\s+$/ ? ("") : (var) }.join("\n")
        @var.puts(format_string(var, @var.status))
        @var.flush
      end
      
      def function(arglist)
        return if @var
        print_exception(var, var, @var)
        @var.flush;Fi[@;I"@var = nil;FI"@var = nil;FI"@var = nil;Fi[[	@ΩiI"        connection.clear_cache!
        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@ΩiI"˜        undefine_attribute_methods
        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@ΩiI"Á        connection.schema_cache.clear_table_cache!(table_name) if table_exists?
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil;Fi[	@ΩiI"»        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var;Fi[	@ΩiI"»        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil unless defined? @var and @var
        @var = nil;Fi[	@xioI"œ      def function(arglist)
        FileUtils.rm_rf(@var, :secure => (true)) if @var
        @var = []
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
      end;Fi[	@xipI"∫        FileUtils.rm_rf(@var, :secure => (true)) if @var
        @var = []
        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
      end
      ;Fi[	@oiÔI"     @var = [var, "ssl_generations"].join("_").intern
    @var = [var, "requests"].join("_").intern
    @var = [var, "timeouts"].join("_").intern
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = OpenSSL::SSL::VERIFY_PEER;Fi[	@oiI"⁄    @var = [var, "requests"].join("_").intern
    @var = [var, "timeouts"].join("_").intern
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    @var = OpenSSL::SSL::VERIFY_PEER
    @var = nil;Fi[	@Wi*I"          @var = var
          @var["cleanup"] ||= Sass::Script::Bool.new(true)
          @var["layout"] ||= Sass::Script::String.new("vertical")
          @var = nil
          @var = nil
          @var = nil
          @var = nil
          @var = var
          validate!;Fi[	I"*data//homebrew_proj/test/test_ARGV.rb;TiI"µrequire("testing_env")
module ExtendArgvPlusYeast
  def function(arglist)
    @var = nil
    @var = nil
    @var = nil
    @var = nil
    while (ARGV.length > 0) do
      ARGV.shift;Fi[@'@(@éI"#;Fi[[	@ciÀI"{        putstream(var)
        out("endobj")
      end
    end
  end
  
  #
  	# putxobjectdict
  	# @access protected;Fi[	@ci’I"¿  def function(arglist)
    @var.each_value do |arglist|
      out((((("/I" + var["i"].to_s) + " ") + var["n"].to_s) + " 0 R"))
    end
  end
  
  #
  	# putresourcedict
  	# @access protected;Fi[	@ci#	I"ç      else
        out("/PageLayout /TwoColumnLeft") if (@var == "two")
      end
    end
  end
  
  #
  	# puttrailer
  	# @access protected;Fi[	@cix	I"{      end
      @var = (@var - @var)
      @var = var
    end
  end
  
  #
  	# End of page contents
  	# @access protected;Fi[	@ci∑	I"x      var)
    ensure
      var.close
    end
  end
  
  #
  	# Extract info from a PNG file
  	# @access protected;Fi[	@ci
I"      return { "w" => (var), "h" => (var), "cs" => (var), "bpc" => (var), "f" => "FlateDecode", "parms" => (var), "pal" => (var), "trns" => (var), "data" => (var) })
    ensure
      var.close
    end
  end
  
  #
  	# Read a 4-byte integer from file
  	# @access protected;Fi[	@ciA
I"∞      (@var[@var] << (var.to_s + "\n"))
    else
      (@var << (var.to_s + "\n"))
    end
  end
  
  #
  	# Adds unicode fonts.<br>
  	# Based on PDF Reference 1.3 (section 5);Fi[	@ci®I"î      @var = (@var + var)
    else
      # do nothing
    end
  end
  
  #
  	# Calculate closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@ci∏I"ñ      @var.push([])
    else
      # do nothing
    end
  end
  
  #
  	# Convert to accessible file path
  	# @param string :attrname image file name;Fi[	@ciìI"î      @var = (@var * @@var)
    else
      # do nothing
    end
  end
  
  #
  	# Process closing tags.
  	# @param string :tag tag name (in upcase);Fi[	@ci@I"Ä      end
    else
      # do nothing
    end
  end
  
  #
  	# Sets font style.
  	# @param string :tag tag name (in lowercase);Fi[@'@¸@ˇ,@ =i[[	@≤i7I"¥      @var = model.create_reflection(macro, name, scope, options, model)
      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    ;Fi[	@≤i[I":      end
      mixin.class_eval("        def #{macro}_dependent_for_#{name}\n          association(:#{name}).handle_dependency\n        end\n", "(string)", (102 + 1))
      model.before_destroy("#{macro}_dependent_for_#{name}")
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
  end;Fi[	@∏iI"‘        
        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        ;Fi[	@√iI"ﬁ        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        ;Fi[	@íiI"¢      def function(arglist)
        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@íiI"¶      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@íiI"¶      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@íiI"¶      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@íiI"¶      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@íi!I"¶      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      ;Fi[	@íi%I"ß      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end;Fi[@'@(@éI"#:nodoc:;Fi[[	@Ii~I"“          @var = Arel::Visitors::MySQL.new(self)
        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        self.class::ADAPTER_NAME;Fi[	@IiI"õ          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin;Fi[	@IiI"ó          execute("COMMIT")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin;Fi[	@çimI"√          @var = Arel::Visitors::SQLite.new(self)
        else
          @var = BindSubstitution.new(self)
        end
      end
      
      #:nodoc:
      def function(arglist)
        "SQLite";Fi[	@ΩivI"Ë          else
            compute_table_name
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        (parents.detect { |arglist| var.respond_to?(:table_name_prefix) } or self).table_name_prefix;Fi[	@ΩiëI"≈          @var ||= reset_sequence_name
        else
          (@var ||= nil or base_class.sequence_name)
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var = false;Fi[	@Ëi\I"‹            puts(format_text(var.description))
          end
          puts
        end
      end
      
      #:nodoc:
      def function(arglist)
        var = File.read(File.join(File.dirname("(string)"), "help.txt"));Fi[	@ñi–I"Ω          end
          var[0].value = var
          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin;Fi[	@iµI"Ï          else
            InProcessCucumberRunner.new(libs, var, feature_files)
          end
        end
      end
      
      #:nodoc:
      def function(arglist)
        @var ? ([cucumber_opts, "--profile", @var]) : (cucumber_opts);Fi[	@(iJI"”        true
      else
        instance.errors.none? { |arglist| var.to_s.start_with?(@var.to_s) }
      end
    end
    
    #:nodoc:
    def function(arglist)
      var = @var[:storage].to_s.downcase.camelize;Fi[	@ÈiGI"Á          @var.delete(var)
        else
          raise(MockExpectationError, "The method `#{message}` was not stubbed or was already unstubbed")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin;Fi[@'@(@éI"attr_reader :function;Fi[[	@0iﬂI"ú            rollback_transaction
            raise
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist);Fi[	@ÀiFI"¨      # the single-table inheritance discriminator.
      def function(arglist)
        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function;Fi[	@ﬂiI"Ó          else
            raise(InverseOfAssociationNotFoundError.new(self, var))
          end
        end
      end
      
      attr_reader :function
      
      # Returns whether or not the association should be validated as part of;Fi[	@üi4I"Ÿ      var.each do |arglist|
        @var[var.switch_name] = var
        var.aliases.each { |arglist| @var[var.to_s] ||= var.switch_name }
      end
    end
    
    attr_reader :function
    
    def function(arglist);Fi[	@§iI"ª          yield)
        ensure
          @var = false
        end
      end
      
      attr_reader :function
      
      # Sets the output padding, not allowing less than zero values.;Fi[	@Vi:I"“            end
          else
            LocalProxy.new(self)
          end
        end
        
        attr_reader :function
        
        # Returns the string used to identify the latest revision in the;Fi[	@¨iÈI"ü            @var[:env_vars][$1] = $2
            true
          end
        end
      end
      
      attr_reader :function
      
      def function(arglist);Fi[	@îi0I"∆      @var = (HOMEBREW_CACHE + (@var + ext))
    else
      @var = (HOMEBREW_CACHE + File.basename(@var))
    end
  end
  
  attr_reader :function
  
  # Private method, can be overridden if needed.;Fi[	@ÄitI"~      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@õiII"»        end
      rescue SystemCallError
        Resque.logger.debug("Child #{@child} already quit and reaped.")
      end
    end
    
    attr_reader :function
    
    alias :paused? :should_pause?;Fi[	@'iFI"è        send(var.to_sym)
      rescue NoMethodError
        nil
      end
    end
    
    attr_reader :function
    
    alias :to_hash :attrs;Fi[@	)I"0;FI"end;FI" ;Fi[[	@CiI"º    end
    
    class ClosedTransaction < Transaction
      def function(arglist)
        0
      end
      
      def function(arglist)
        RealTransaction.new(connection, self, var);Fi[	@B)iI"k      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@B)iI"j      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@B)iI"j      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@B)iI"m      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[	@B)i3I"k      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0;Fi[	@B)i7I"u      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing;Fi[	@D	iI"°      # @return [ Integer ] 0.
      #
      # @since 3.0.0
      def function(arglist)
        0
      end
      
      # Is the passed value a boolean?
      #;Fi[	@π)iI"n      ""
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true;Fi[	@iuI"Ê      
      # Where in the X area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        if show_data_values then;Fi[	@i™I""      
      # Where in the Y area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        ((@var.to_f - ((font_size * 2) * right_font)) / (get_x_labels.length - right_align));Fi[@'@¸@ˇ,I"var = "";Fi[[	@ i¿I"j      rescue Errno::EACCES
        raise(Bundler::InstallError, "There was an error while trying to write to Gemfile.lock. It is likely that \nyou need to allow write permissions for the file at path: \n#{File.expand_path(file)}")
      end
    end
    
    def function(arglist)
      var = ""
      sorted_sources.each do |arglist|
        (var << var.to_lock);Fi[	@ËidI"9        var = File.read(File.join(File.dirname("(string)"), "help.txt"))
        self.class.ui.page_at = (self.class.ui.output_rows - 2)
        self.class.ui.say(format_text(var))
      end
      
      def function(arglist)
        var = ""
        var.each_line do |arglist|
          var = (var[/^\s+/] or "");Fi[	@
i)I"=          self.additional_import_paths.uniq!
        end
        issue_deprecation_warnings
      end
      
      def function(arglist)
        var = ""
        (required_libraries or []).each { |arglist| (var << "require '#{lib}'\n") }
        (loaded_frameworks or []).each { |arglist| (var << "load '#{lib}'\n") };Fi[	@{ipI"˘          "          No Usage!\n".gsub(/^ {8}/, "")
        end
      end
    end
    
    def function(arglist)
      var = ""
      var = Compass::Frameworks::ALL.inject(0) do |arglist|
        var = var.template_directories.inject(0) do |arglist|;Fi[	@$i≈I"      else
        var.all? { |arglist| color_stop?(var) } ? (var) : (nil) if var.is_a?(Array)
      end
    end
    
    def function(arglist)
      var = ""
      if angle?(position_or_angle) then
        var = " gradientTransform = \"rotate(#{position_or_angle.value})\"";Fi[	@ui0I"%        var.visit_feature_name(@var, indented_name)
        var.visit_background(@var) if @var
        @var.each { |arglist| var.visit_feature_element(var) }
      end
      
      def function(arglist)
        var = ""
        name.split("\n").map do |arglist|
          var = "#{indent}#{l}";Fi[	I"2data//diaspora_proj/models/services/tumblr.rb;Ti#I"˝  
  def function(arglist)
    { :type => "text", :format => "markdown", :body => (tumblr_template(var, var)) }
  end
  
  def function(arglist)
    var = ""
    var.photos.each do |arglist|
      var = (var + "![photo](#{photo.url(:scaled_full)})\n\n");Fi[	@Ui2I"◊    
    def function(arglist)
      var.include?("\#{")
    end
    
    def function(arglist)
      var = ""
      var = Haml::Util.handle_interpolation(var.dump) do |arglist|
        var = ((var[2].size - 1) / 2);Fi[	@£iëI"Ë  def function(arglist)
    require("fileutils")
    FileUtils.chmod_R(var, to_s)
  end
  
  def function(arglist)
    var = ""
    var = `find #{to_s} -type f ! -name .DS_Store | wc -l`.to_i
    (var << "#{n} files, ") if (var > 1);Fi[	@™i•I"Õ          end
        end
        var
      end
      
      def function(arglist)
        var = ""
        if var[:bar_start] and var[:bar_end] then
          var = ((var[:bar_end] - var[:bar_start]) - 2);Fi[	@ iI"Á        else
          " #{words[(0...-1)].join(", ")}, and #{words[-1]}"
        end
      end
      
      def function(arglist)
        var = ""
        var.each_with_index do |arglist|
          if (var < (var.length - 2)) then;Fi[@û=I"#   class Person;FI"+#     include ActiveModel::Validations;FI"#;Fi[[	@pi~I"]      # <tt>ActiveModel::StrictValidationFailed</tt> instead of adding error
      # when validation fails. See <tt>validates</tt> for more information about
      # the validation itself.
      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name
      #     validates! :name, presence: true;Fi[	@uieI"    
    # Passes the record off to the class or classes specified and allows them
    # to add errors based on more complex conditions.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     validate :instance_validations
    #;Fi[	@uitI"Ê    # creating your own validator.
    #
    # You may also pass it multiple classes, like so:
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     validate :instance_validations, on: :create
    #;Fi[	@ï7iI"‹    
    module ClassMethods
      # Validates each attribute against a block.
      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :first_name, :last_name
      #;Fi[	@ï7iyI"%      
      # List all validators that are being used to validate the model using
      # +validates_with+ method.
      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     validates_with MyValidator
      #     validates_with OtherValidator, on: :create;Fi[	@ï7iàI"Â      end
      
      # List all validators that are being used to validate a specific attribute.
      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name , :age
      #;Fi[	@ï7iπI"˜    
    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name;Fi[	@ï7i I"    
    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name;Fi[	@ï7i⁄I"8    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new;Fi[	@ï7iÒI"    
    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name;Fi[	@ï7iI"8    #
    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new;Fi[@µ @°+I"@var = false;FI"end;Fi[[	@Fi_I"–        var.connection = self
        @var = var
      end
      
      def function(arglist)
        @var = false
      end
      
      # Returns the human-readable name of the adapter. Use mixed case - one;Fi[	@ikI"ó      attr_reader :function
      
      protected
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@ioI"ü      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@ﬁi7I"û      def function(arglist)
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@ﬁiYI"ñ        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@ÈiI"õ        @var.puts
        print_summary(var)
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@Èi'I"•        progress(:failed) if @var
        @var = false
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@Ïi"I"ù      def function(arglist)
        @var.close
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@Ïi<I"ñ        @var = true
        @var = true
      end
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[	@‰i´I"Ç      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false
    end
    
    def function(arglist);Fi[	@qiI"ë      end
      
      attr_reader :function
      
      def function(arglist)
        @var = false
      end
      
      def function(arglist);Fi[@‹.I"	true;FI"end;FI"end;Fi[[	@ùiuI"æ          inverse_updates_counter_cache?(through_reflection).!
        when :nullify then
          false
        else
          true
        end
      end
      
      def function(arglist);Fi[	@üi∫I"‹          if ["false", "FALSE", "f", "F", false].include?(peek) then
            shift
            false
          else
            true
          end
        end
      else
        (@var.key?(var) or no_or_skip?(var).!);Fi[	@ÉigI"∏    if user and user.blocks.where(:person_id => (person_id)).exists? then
      (errors[:base] << "Cannot connect to an ignored user")
      false
    else
      true
    end
  end
end;Fi[	@çiaI"’  def function(arglist)
    if self.parent and self.parent.participants.include?(self.author).! then
      (errors[:base] << "Author is not participating in the conversation")
    else
      true
    end
  end
end;Fi[	@úi?I"   def function(arglist)
    if self.status_message_guid and self.status_message.text_and_photos_blank? then
      self.status_message.destroy
    else
      true
    end
  end
  
  def function(arglist);Fi[	@úiHI"Ï    var = StatusMessage.find_by_guid(self.status_message_guid)
    if self.status_message_guid and var then
      (self.diaspora_handle == var.diaspora_handle)
    else
      true
    end
  end
  
  def self.diaspora_initialize(arglist);Fi[	@p-iI"’        else
          if (var.rack.exist?.! or var.rack.children.empty?) then
            onoe("#{f} not installed")
          else
            true
          end
        end
      end
      exit(1) if var.empty?;Fi[	@ÄirI"¢    @var = case @var
    when :provided_pre_mountain_lion then
      (MacOS.version < :mountain_lion)
    else
      true
    end
  end
  
  attr_reader :function;Fi[	@ni I"              if var.last then
                if [:attribute_nodes, :children].include?(var.first) then
                  var.last.empty?.!
                else
                  true
                end
              end
            end
            var.seplist(var) do |arglist|;Fi[	@Ëi4I"è          else
            @var[:fog_public]
          end
        else
          true
        end
      end
      
      def function(arglist);Fi[	@„i\I"∑        @var = @var = nil
        raise(var) if var
        var.!
      else
        true
      end
    end
    
    # Runs the machine's +before+ callbacks for this transition.  Only;Fi[@'@¸I"# @return [Integer];FI"def function(arglist);Fi[[	I"+data//twitter_proj/twitter/identity.rb;Ti$I"ƒ    # @return [Boolean]
    def function(arglist)
      (super or (attr_equal(:id, var) or attrs_equal(var)))
    end
    
    # @return [Integer]
    def function(arglist)
      @var[:id]
    end;Fi[	I"(data//twitter_proj/twitter/place.rb;TiI"—    # @return [String]
    def function(arglist)
      @var ||= (@var[:country_code] or @var[:countryCode])
    end
    
    # @return [Integer]
    def function(arglist)
      @var ||= @var[:parentid]
    end;Fi[	@ *iI"…    # @return [Twitter::RateLimit]
    def function(arglist)
      @var = var
    end
    
    # @return [Integer]
    def function(arglist)
      var = @var["x-rate-limit-limit"]
      var.to_i if var;Fi[	@ *iI"÷    def function(arglist)
      var = @var["x-rate-limit-limit"]
      var.to_i if var
    end
    
    # @return [Integer]
    def function(arglist)
      var = @var["x-rate-limit-remaining"]
      var.to_i if var;Fi[	@ *i I"‹    def function(arglist)
      var = @var["x-rate-limit-reset"]
      Time.at(var.to_i) if var
    end
    
    # @return [Integer]
    def function(arglist)
      [(reset_at - Time.now).ceil, 0].max if reset_at
    end;Fi[	I"1data//twitter_proj/twitter/search_results.rb;TiI"    # @return [Float]
    def function(arglist)
      @var[:search_metadata][:completed_in] if search_metadata?
    end
    
    # @return [Integer]
    def function(arglist)
      @var[:search_metadata][:max_id] if search_metadata?
    end;Fi[	@UGiI"Í    # @return [Integer]
    def function(arglist)
      @var[:search_metadata][:max_id] if search_metadata?
    end
    
    # @return [Integer]
    def function(arglist)
      @var[:search_metadata][:page] if search_metadata?
    end;Fi[	@UGi#I"Ù    # @return [String]
    def function(arglist)
      @var[:search_metadata][:query] if search_metadata?
    end
    
    # @return [Integer]
    def function(arglist)
      @var[:search_metadata][:results_per_page] if search_metadata?
    end;Fi[	@UGi.I"≈    
    def function(arglist)
      @var[:search_metadata].nil?.!
    end
    
    # @return [Integer]
    def function(arglist)
      @var[:search_metadata][:since_id] if search_metadata?
    end;Fi[	@Ìi I"«    # @return [Boolean]
    def function(arglist)
      @var[:entities].nil?.!
    end
    
    # @return [Integer]
    def function(arglist)
      var = @var[:favoriters_count]
      var.to_i if var;Fi[	@Ìi[I"Ë    # @return [Twitter::Place]
    def function(arglist)
      @var ||= Twitter::Place.fetch_or_new(@var[:place])
    end
    
    # @return [Integer]
    def function(arglist)
      var = @var[:repliers_count]
      var.to_i if var;Fi[@µ @°+@ =I"end;Fi[[	@≤i8I"Ö      super
      @var
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
    
    def function(arglist);Fi[	@≤i\I"4      mixin.class_eval("        def #{macro}_dependent_for_#{name}\n          association(:#{name}).handle_dependency\n        end\n", "(string)", (102 + 1))
      model.before_destroy("#{macro}_dependent_for_#{name}")
    end
    
    def function(arglist)
      raise(NotImplementedError)
    end
  end
end;Fi[	@∏iI"˙        def function(arglist)
          Arel::Nodes::TableAlias.new(table, aliased_table_name)
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        # An Arel::Table for the active_record;Fi[	@√iI"Û        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?
        end
        
        def function(arglist)
          raise(NotImplementedError)
        end
        
        def function(arglist);Fi[	@íiI"¢        @var = var
        @var = var
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@íiI"ª      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@íiI"ª      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@íiI"ª      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@íiI"ª      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@íi"I"ª      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist);Fi[	@íi&I"¶      def function(arglist)
        raise(NotImplementedError)
      end
      
      def function(arglist)
        raise(NotImplementedError)
      end
    end
  end;Fi[I"var = -1;FI"var = 0;FI"var = 0;FI"var = 0;Fi[[	@LinI"°        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@Li≤I"∂    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@OicI"°        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@Oi≠I"∂    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@Ri]I"°        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@Ri°I"∂    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@UiCI"ñ        var = var.index("T").nil?.! ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@UiäI"∂    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@ci<I"k        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@ci¶I"î      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[I"0;FI"end;FI" ;FI"def function(arglist);Fi[[	@CiI"æ    
    class ClosedTransaction < Transaction
      def function(arglist)
        0
      end
      
      def function(arglist)
        RealTransaction.new(connection, self, var)
      end;Fi[	@B)iI"j    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@B)iI"j    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@B)iI"j    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@B)iI"m    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[	@B)i4I"j    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end;Fi[	@B)i8I"u    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@π)iI"m    end
    
    def function(arglist)
      0
    end
    
    def function(arglist)
      true
    end;Fi[	@ivI"ç      # Where in the X area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        if show_data_values then
          @var.add_element("text", "x" => (var.to_s), "y" => (var.to_s), "class" => "dataPointLabel", "style" => ("#{style} stroke: #fff; stroke-width: 2;")).text = var.to_s;Fi[	@i´I"%      # Where in the Y area the label is drawn
      # Centered in the field, should be width/2.  Start, 0.
      def function(arglist)
        0
      end
      
      def function(arglist)
        ((@var.to_f - ((font_size * 2) * right_font)) / (get_x_labels.length - right_align))
      end;Fi[@'@(@éI"module InstanceMethods;Fi[[	@i[I"˜        def function(arglist)
          var = (160 + 1)
          class_eval("\n            alias_method :_chained_#{method}, method\n            def #{method}(*args, &block)\n              _chained_#{method}(*args, &block)\n              if inherited_data\n                inherited_data.#{method}(*args, &block)\n              end\n            end\n          ", "(string)", var)
        end
      end
      
      module InstanceMethods
        def function(arglist)
          self.set_top_level(self);Fi[	@iI"            var[:author_key] = "#{table_name}.#{options[:author_key]}"
          end
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods);Fi[	@iI"§          has_many(:attachments, var.merge(:as => :container, :order => ("#{Attachment.table_name}.created_on ASC, #{Attachment.table_name}.id ASC"), :dependent => :destroy))
          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods);Fi[	@iI"(          send(:include, Redmine::Acts::Customizable::InstanceMethods)
          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods);Fi[	@iI"          cattr_accessor(:event_options)
          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods);Fi[	@i I"ö            var = "def scope_condition() \"#{configuration[:scope]}\" end"
          end
          class_eval("            include ActiveRecord::Acts::List::InstanceMethods\n\n            def acts_as_list_class\n              ::#{self.name}\n            end\n\n            def position_column\n              '#{configuration[:column]}'\n            end\n\n            #{scope_condition_method}\n\n            before_destroy :remove_from_list\n            before_create  :add_to_list_bottom\n")
        end
      end
      
      module InstanceMethods
        # Insert the item at the given position (defaults to the top position of 1).
        def function(arglist);Fi[	@#i%I"y          searchable_options[:order_column] ||= searchable_options[:date_column]
          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods);Fi[	@*iI"Ω          has_many(:children, :class_name => (name), :foreign_key => (var[:foreign_key]), :order => (var[:order]), :dependent => (var[:dependent]))
          scope(:roots, where("#{configuration[:foreign_key]} IS NULL").order(var[:order]))
          send(:include, ActiveRecord::Acts::Tree::InstanceMethods)
        end
      end
      
      module InstanceMethods
        # Returns list of ancestors, starting from parent until root.
        #;Fi[	@2iI"          end
          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods);Fi[	@&iI"+    #   Vehicle.state_machines # => {:state => #<StateMachine::Machine:0xb6f6e4a4 ...>}
    def function(arglist)
      @var ||= superclass.state_machines.dup
    end
  end
  
  module InstanceMethods
    # Runs one or more events in parallel.  All events will run through the
    # following steps:;Fi[@	)@˛2@ˇ2I"end;Fi[[	@CiqI"ä        false
      end
      
      def function(arglist)
        true
      end
    end
    
    class RealTransaction < OpenTransaction;Fi[	@±ixI"x  end
  
  class HiddenTask < Task
    def function(arglist)
      true
    end
  end
  
  class DynamicTask < Task;Fi[	@ñiÅI"}          :comment
        end
        
        def function(arglist)
          true
        end
      end
    end
  end;Fi[	@@8i-I"p    Postzord::Dispatcher.build(person.owner, self).post
  end
  
  def function(arglist)
    true
  end
end;Fi[	@G8iI"π  module Util
    undef :rails_xss_safe? if defined? rails_xss_safe?
    
    def function(arglist)
      true
    end
  end
end
Haml::Template.options[:ugly] = Rails.env.development?.!;Fi[	@)	i£I"í        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end;Fi[	@L	i¿I"í        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end
  end;Fi[	@π)iI"ô      # do nothing
    end
    
    def function(arglist)
      true
    end
  end
end
Paperclip.io_adapters.register(Paperclip::NilAdapter) do |arglist|;Fi[	@æiI"À    module Adapters
      class FilesystemAdapter < AbstractAdapter
        class << self
          def function(arglist)
            true
          end
        end
        
        def function(arglist);Fi[	@P8iI"nclass Test::Unit::AutoRunner
  remove_method(:process_args)
  
  def function(arglist)
    true
  end
end;Fi[@'I"var = -1;FI"var = var;FI"var = 0;Fi[[	@LiåI"	        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@Li⁄I"¸        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@OiÜI"	        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@Oi‚I"¸        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@Ri{I"	        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@Ri…I"¸        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@UioI"·            end
            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1);Fi[	@Ui¥I"›        else
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@cijI"           end
          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1);Fi[	@ciÕI"⁄        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[I"var = var;FI"var = 0;FI"if (var == 1) then;FI"@var = @var;Fi[[	@LiæI"        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Li‹I"          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@OiπI"        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Oi‰I"          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Ri≠I"        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@RiÀI"          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@UiïI"        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Ui∂I"Â          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var);Fi[	@ci±I"        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[	@ciœI"”          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var));Fi[I")#   matcher.matches?({ :key => 10 });FI"#;FI"1# @param [ Hash ] value The values to check.;FI"#;Fi[[	@∑	iI"8      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If the values match.
      def function(arglist);Fi[	@¬	iI"      # non-existence.
      #
      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@≈	iI"*      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@»	iI"6      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@À	iI"!      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@Œ	iI"'      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@—	iI"3      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@‘	iI".      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@◊	iI")      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[	@›	iI"1      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist);Fi[@ED@FD@GDI"end;Fi[[	I"2data//bundler_proj/bundler/friendly_errors.rb;TiI"¸      exit(var.status)
    rescue Exception => var
      Bundler.ui.error("Unfortunately, a fatal error has occurred. Please see the Bundler \ntroubleshooting documentation at http://bit.ly/bundler-issues. Thanks!\n")
      raise(var)
    end
  end
end;Fi[	@içI"            Bundler.ui.info("#{@output_file}.#{@output_format}"))
          rescue ArgumentError => var
            $stderr.puts("Unsupported output format. See Ruby-Graphviz/lib/graphviz/constants.rb")
            raise(var)
          end
        end
      end
    end
  end;Fi[	@±i3I"ı        if handle_no_method_error?(var, var, caller) then
          var.class.handle_no_task_error(name)
        else
          raise(var)
        end
      end
    end
    
    # Returns the formatted usage by injecting given required arguments;Fi[	@„iPI"ä        when Capistrano::Error then
          abort(var.message)
        else
          raise(var)
        end
      end
    end
  end
end;Fi[	@§iØI"¸            var.new(var, var, @var))
          rescue Exception => var
            (var.message << "\nError creating formatter: #{format}")
            raise(var)
          end
        end
      end
      
      class LogFormatter < ::Logger::Formatter;Fi[	@≤iJI"˙            STDERR.puts("You don't have a 'features' directory.  Please create one to get started.", "See http://cukes.info/ for more information.")
            exit(1)
          end
          raise(var)
        end
      end
    end
    
    private;Fi[	@Úi¡I"π    rescue RuntimeError => var
      var = I18n.t("photos.create.runtime_error")
      respond_with(@var, :location => (photos_path), :error => (var))
      raise(var)
    end
  end
end;Fi[	@6iI"Ñ        var.perform!)
      rescue => var
        FEDERATION_LOGGER.info(var.message)
        raise(var)
      end
    end
  end
end;Fi[	@ËiI"#            require("fog")
          rescue LoadError => var
            (var.message << " (You may need to install the fog gem)")
            raise(var)
          end
          end
        end
        var.instance_eval do |arglist|
          unless @var[:url].to_s.match(/^:fog.*url$/) then;Fi[	@ÎiI"-            require("aws-sdk")
          rescue LoadError => var
            (var.message << " (You may need to install the aws-sdk gem)")
            raise(var)
          end
          end
        end
        if (AWS::VERSION >= "1.3.9") then
          AWS::Core::LogFormatter.class_eval do |arglist|;Fi[@'@¸@ˇ,I"@var = [];Fi[[	@∏i©I"∑      def function(arglist)
        @var.puts(format_string(var, :tag).indent(@var))
        @var.flush
      end
      
      def function(arglist)
        @var = []
      end
      ;Fi[	@«iQI"«        (@var << "</div>")
        (@var << "</body>")
        (@var << "</html>")
      end
      
      def function(arglist)
        @var = []
        (@var << "<div class=\"feature\">")
      end;Fi[	@«iCI"—        return if @var.empty?
        @var.td(:class => "message") { |arglist| (@var << @var.join(", ")) }
        empty_messages
      end
      
      def function(arglist)
        @var = []
      end
      ;Fi[	@Êi"I"»      
      def function(arglist)
        print_summary(var) unless @var[:autoformat]
      end
      
      def function(arglist)
        @var = []
        @var = 0
        if @var[:autoformat] then;Fi[	@ÏiI"π        @var = var
        @var = []
        @var = Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var = []
        @var = var.file
      end;Fi[	@iI"      
      def function(arglist)
        "python snippet: #{code_keyword}, #{step_name}"
      end
      
      def function(arglist)
        @var = []
        add_to_python_path(File.dirname("(string)"))
        @var.each { |arglist| add_to_python_path(File.dirname(var)) };Fi[	@™iªI"0        var = project_versions(var)
        var.each { |arglist| render_version(var, var, var) }
        var[:indent] -= var[:indent_increment]
      end
      
      def function(arglist)
        @var = []
        var.each do |arglist|
          subject_for_issue(var, var) unless (var[:only] == :lines);Fi[	@ÁiI"Ÿ          self.hard_breaks = true
          self.no_span_caps = true
          self.filter_styles = false
        end
        
        def function(arglist)
          @var = []
          super(*RULES).to_s
        end;Fi[	@Ái/I"Ó          end
          var[1] = var unless var[1].blank?
          var.reject(&:blank?).join("\n\n")
        end
        
        def function(arglist)
          @var = []
          var = self.dup
          rip_offtags(var, false, false);Fi[	@C9iI"¶  
  def function(arglist)
    load_plugins
  end
  
  def function(arglist)
    @var = []
    if $APP_CONFIG.plugins then
      $APP_CONFIG.plugins.each do |arglist|;Fi[I"var = 0;F@¯GI"@var = @var;FI"!var = ((@var - @var) - @var);Fi[[	@LiøI"„        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@Li›I"◊        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@Oi∫I"„        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@OiÂI"◊        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@RiÆI"„        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@RiÃI"◊        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@UiñI"„        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@Ui∑I"◊        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end;Fi[	@ci≤I"—        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[	@ci–I"≈        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end;Fi[@µ @°+@K1I"	self;Fi[[	@GiI"ã        @var = find_in_path(var)
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@JiSI"{        end
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@⁄iI"û        def function(arglist)
          @var = var
        end
        
        def function(arglist)
          @var = var
          self
        end
        ;Fi[	@⁄iI"è          @var = var
          self
        end
        
        def function(arglist)
          @var = var
          self
        end
        ;Fi[	@üiBI"‰      def function(arglist)
        "#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@üiGI"}        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@üiLI"}        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@üiQI"}        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@üiVI"}        @var = var
        self
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[	@oi!I"ß      def function(arglist)
        "respond to #{pp_names}#{with_arity}"
      end
      
      def function(arglist)
        @var = var
        self
      end
      ;Fi[@‹.I""";FI"end;FI"end;Fi[[	@Éi*I"              " TABLESPACE = \"#{value}\""
            when :connection_limit then
              " CONNECTION LIMIT = #{value}"
            else
              ""
            end
          end
          execute("CREATE DATABASE #{quote_table_name(name)}#{option_string}")
        end;Fi[	@‰iI"      def function(arglist)
        if top_level.line_comments then
          "# To disable debugging comments that display the original location of your selectors. Uncomment:\n# line_comments = false\n"
        else
          ""
        end
      end
      
      def function(arglist);Fi[	@‰i+I"–      def function(arglist)
        if (top_level.preferred_syntax == :scss) and top_level.sass_dir then
          "\n# If you prefer the indented syntax, you might want to regenerate this\n# project again passing --syntax sass, or you can uncomment this:\n# preferred_syntax = :sass\n# and then run:\n# sass-convert -R --from scss --to sass #{top_level.sass_dir} scss && rm -rf sass && mv scss sass\n"
        else
          ""
        end
      end
    end
  end;Fi[	@íi8I"    def function(arglist)
      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("") : ("[#{COLORS[c.to_sym]}m")
      else
        ""
      end
    end
    
    def function(arglist);Fi[	@™iI"à          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist);Fi[	@™i6I"à          else
            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist);Fi[	@™isI"ô          else
            # do nothing
          end
        else
          ""
        end
      end
      
      if Object.const_defined?(:Magick) then;Fi[	@Ji4I"ì  def function(arglist)
    if File.exist?("spec/spec.opts") then
      "-O #{File.join("spec", "spec.opts")} "
    else
      ""
    end
  end
end;Fi[	@ãiI"ú          redirect_from_hash
        when NilClass then
          ">> /dev/null 2>&1"
        else
          ""
        end
      end
      
      protected;Fi[	@ãi6I"ú          "> /dev/null"
        when stdout then
          ">> #{stdout}"
        else
          ""
        end
      end
      
      def function(arglist);Fi[@{GI"var = var;FI"var = 0;F@¯Gi[[	@LiΩI"      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@Li€I"          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@Oi∏I"˛      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@Oi„I"          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@Ri¨I"      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@Ri I"          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@UiîI"      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@UiµI"˜          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@ci∞I"      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[	@ciŒI"Ù          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var);Fi[@;@AFI"end;FI" ;Fi[[	@}iI"      # Resets the \loaded flag to +false+ and sets the \target to +nil+.
      def function(arglist)
        @var = false
        @var = nil
        @var = nil
      end
      
      # Reloads the \target and returns +self+ on success.
      def function(arglist);Fi[	@√iI"          @var = var
          @var = var
          @var = (var.first and var.first.class)
          @var = nil
          @var = nil
        end
        
        def function(arglist)
          preload unless owners.first.association(reflection.name).loaded?;Fi[	I"Fdata//activerecord_proj/active_record/railties/jdbcmysql_error.rb;TiI"Ü    
    def function(arglist)
      super
      @var = nil
      @var = nil
    end
    
    alias_method(:errno, :error_number)
    ;Fi[	@xirI"î        @var = nil
        @var = nil
        @var = nil
        @var = nil
        @var = nil
      end
      
      alias :cleanup :prepare
      ;Fi[	@
iI"Ñ      @var = []
      @var = []
      @var = []
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      begin;Fi[	@‰i®I"ç    
    def function(arglist)
      @var = false
      @var = nil
      @var = nil
    end
    
    def function(arglist)
      @var = false;Fi[	@i≥I"®        
        def function(arglist)
          @var = var
          @var = nil
          @var = nil
        end
        
        attr_reader(:encoding_found)
        ;Fi[	@Öi I"–        @var = var
        @var = File.basename(var)
        @var = @var.humanize
        @var = nil
        @var = nil
      end
      
      # Directory name used as the theme id
      def function(arglist);Fi[	@øiI"      def function(arglist)
        @var = (var == :no) ? (0) : (var)
        @var = var
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var ||= { :exactly => "", :at_least => "at least ", :at_most => "at most " };Fi[	@tiI"ô        @var = []
        @var = 0
        @var = 0
        @var = nil
        @var = nil
      end
      
      def function(arglist)
        @var = var;Fi[@	)I"(@var << var);FI"end;FI" ;Fi[[	@öiI":    # Adds a command to be executed in the pipeline.
    # Each command will be run in the order in which it was added,
    # with it's output being piped to the next command.
    def function(arglist)
      (@var << var)
    end
    
    ##
    # Runs the command line from `#pipeline` and collects STDOUT/STDERR.;Fi[	@œi$I"ï      
      ##
      # Adds a path to the @directories array
      def function(arglist)
        (@var << var)
      end
      
      private
      ;Fi[	@ui$I"§        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@xiI"æ        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        var.each { |arglist| var.feature_element = self };Fi[	@ñiI"®          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist)
          # do nothing;Fi[	@«i3I"ß        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?;Fi[	@iI"ñ        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        # do nothing;Fi[	@h$i6I"8      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist)
      (@var << "\n<fieldset#{" style='#{options[:style]}'" if options[:style]}#{" id='#{options[:id]}'" if options[:id]}>\n  <legend>#{legend}</legend>\n");Fi[	@ÊiI"´        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return (@var.first == var);Fi[	@qi/I"ö        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        line_number.!.!;Fi[@µ @°+I"@var[var];FI"end;Fi[[	@ri™I"√          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          
          def function(arglist);Fi[	@?i}I"s    end
    
    private
    
    def function(arglist)
      @var[var]
    end
    
    def function(arglist);Fi[	@%iNI"•      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@¬i~I"´      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@}iI"ô      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@ñiAI"±        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist);Fi[	@¨i0I"§        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@Êi›I"º        var[(1..-1)].each { |arglist| @var.puts("    #{s}") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist);Fi[	@CiâI"±        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        
        def function(arglist);Fi[	@]iAI"Æ          @var = Hash.new(var)
          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        
        protected;Fi[@û=I"# == Examples;FI"#;FI"#   class Vehicle;Fi[[	@â iI"=    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do;Fi[	@â i;I"=    #   are specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do;Fi[	@§iI"        # 
        # See StateMachine::Machine#before_transition for more
        # information about the various configuration options available.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     ;Fi[	@§iOI"        
        # Creates a callback that will be invoked *around* a transition so long
        # as the given requirements match the transition.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     ;Fi[	@L<iI"module StateMachine
  module MatcherHelpers
    # Represents a state that matches all known states in a machine.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine do
    #       before_transition any => :parked, :do => lambda {...};Fi[	@L<i'I"Ù    
    # Represents a state that matches the original +from+ state.  This is useful
    # for defining transitions which are loopbacks.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite;Fi[	@î iI"7    # object's current value doesn't match the state, then this will return
    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling;Fi[	@î i&I"M    # Determines the current state of the given object as configured by this
    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling;Fi[	@î iAI"*    # Determines the current state of the given object as configured by this
    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling;Fi[	@„iÆI"6    # Runs the actual transition and any before/after callbacks associated
    # with the transition.  The action associated with the transition/machine
    # can be skipped by passing in +false+.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :action => :save do
    #       ...;Fi[@YHI"var = 0;FI"var = 0;FI"var = 1;Fi[[	@LioI"®      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@Li≥I"»    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@OidI"®      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@OiÆI"»    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@Ri^I"®      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@Ri¢I"»    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@UiEI"~    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[	@UiãI"ú    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[	@ci>I"~    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[	@cißI"      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var];Fi[I"(instance_eval(&var) if block_given?;FI"end;FI" ;FI"private;Fi[[	@ÑiI"¨      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@âi/I"®        @var ||= "yellow"
        @var ||= "yellow"
        @var ||= "yellow"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@éinI"¨      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@ëiI"–      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@îiI"≤      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@óiI"£      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@†iI"§        super(var, var)
        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@•i$I"™        super(var, var)
        @var ||= "backups"
        @var ||= :app_folder
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@∂iI"©      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[	@æiI"©      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      
      ##;Fi[I"@var = {};FI"end;FI" ;FI"def function(arglist);Fi[[	@iI"ó    #   end
    def function(arglist)
      @var = var
      @var = {}
    end
    
    def function(arglist)
      @var = var.messages.dup
      super;Fi[	@ri§I"∑        
        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end;Fi[	@%iI"›    end
    
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      if var = @var[var.name] and var.any? then
        var = [var.requirement.as_list, var.first.version.to_s].flatten.compact;Fi[	@îiI"◊        Node = Struct.new(:key, :value, :next, :prev)
        
        def function(arglist)
          @var = {}
        end
        
        def function(arglist)
          @var[var] and @var[var].value
        end;Fi[	@§i±I"    
    # Removes previously aliased actions including the defaults.
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      var = ModelAdapters::AbstractAdapter.adapter_class(var)
      var.new(var, relevant_rules_for_query(var, var));Fi[	@iI",      # The hash of callbacks that have been registered for this configuration
      def function(arglist)
        initialize_without_callbacks(*var)
        @var = {}
      end
      
      def function(arglist)
        trigger(:before, var)
        var = invoke_task_directly_without_callbacks(var);Fi[	@8iI"±      def function(arglist)
        @var = var
        @var = {}
        @var = {}
      end
      
      def function(arglist)
        @var = Configuration.parse(var)
      end;Fi[	@=i(I"”        @var = Runtime::ForProgrammingLanguages.new(self, var)
        @var = []
        @var = []
        @var = {}
      end
      
      def function(arglist)
        @var = Configuration.parse(var)
      end;Fi[	@ƒi	I"∂  module Interpolations
    class PluralCache
      def function(arglist)
        @var = {}
      end
      
      def function(arglist)
        @var[var] ||= var.pluralize
      end;Fi[	@ËiII"≤          end)
        end
        after_flush_writes
        @var = {}
      end
      
      def function(arglist)
        for var in @var do
          (log("deleting #{path}");Fi[@û=I" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;Ti[[	@îi;I"M      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îi\I":      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiuI"=      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiíI"%      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îi≤I"M      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiŒI":      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiÍI"=      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiI"%      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îi"I"%      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiBI"a      #
      # You can pass +Fixnum+ or +String+ values, it finds the records
      # responding to the +id+ and then deletes them from the database.
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[I"var = (var + 1);FI"var = -1;FI"var = var;FI"var = 0;Fi[[	@LixI"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@LiºI"ı      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@OimI"Ù      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@Oi∑I"Á      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@RigI"      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@Ri´I"ı      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@UiRI"Í        end
        var = (var == 0) ? (0) : ((var - 1))
        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1);Fi[	@UiìI"Ù      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[	@ciLI"         var = (var == 0) ? (0) : ((var - 1))
        var = (var == 0) ? (1) : (var)
        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1);Fi[	@ciØI"Ò      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var;Fi[@YH@II"var = 1;FI"while (var < var) do;Fi[[	@LipI"∂    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@Li¥I"√    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@OieI"Æ    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@OiØI"ª    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var;Fi[	@Ri_I"∂    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@Ri£I"√    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128);Fi[	@UiFI"ï    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[	@UiåI"û    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[	@ci?I"ï    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[	@ci®I"ë    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then;Fi[@û=@p=I"#   end;FI"#;Fi[[	@-iI"$    
    # Returns an Enumerable of all key attributes if any is set, regardless if
    # the object is persisted or not. If there no key attributes, returns +nil+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create
    #   person.to_key # => [1];Fi[	@-i*I"	    
    # Returns a +string+ representing the object's key suitable for use in URLs,
    # or +nil+ if <tt>persisted?</tt> is +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create
    #   person.to_param # => "1";Fi[	@i^I"(      
      # Returns +true+ if +attribute+ is an attribute method and table exists,
      # +false+ otherwise.
      #
      #   class Person < ActiveRecord::Base
      #   end
      #
      #   Person.attribute_method?('name')   # => true
      #   Person.attribute_method?(:age=)    # => true;Fi[	@ikI"C      
      # Returns an array of column names as strings if it's not an abstract class and
      # table exists. Otherwise it returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #   end
      #
      #   Person.attribute_names
      #   # => ["id", "created_at", "updated_at", "name", "age"];Fi[	@iáI"N    # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
    # which will all return +true+. It also define the attribute methods if they have
    # not been generated.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.respond_to(:name)    # => true;Fi[	@iõI"ˆ    end
    
    # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.has_attribute?(:name)    # => true;Fi[	@i®I"÷    end
    
    # Returns an array of names for the attributes available on this object.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.attribute_names;Fi[	@i¥I"    end
    
    # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.create(name: 'Francesco', age: 22)
    #   person.attributes;Fi[	@iÒI"+    
    # Returns the column object for the named attribute. Returns +nil+ if the
    # named attribute not exists.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter;Fi[	@iI"    
    # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
    # (Alias for the protected <tt>write_attribute</tt> method).
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person[:age] = '22';Fi[@µ @°+I"@var ||= [];FI"end;Fi[[	@^i0I"ç    def function(arglist)
      full_gem_path
    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist);Fi[	@§iI"•      end
      var
    end
    
    def function(arglist)
      @var ||= []
    end
    
    # Returns an array of Rule instances which match the action and subject;Fi[	@
iVI"ø      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist);Fi[	@i$I"*        def function(arglist)
          respond_to?(:visible?) ? (visible?(var)) : (true) and var.allowed_to?(self.class.attachable_options[:delete_permission], self.project)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@i(I"Ø        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@]iI"∞          @var = nil
          default(ExampleGroup)
        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@{i I"î        end
        
        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist);Fi[	@€i›I"†      def function(arglist)
        (@var == @var)
      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist);Fi[	@ÙiI"r      end
      
      private
      
      def function(arglist)
        @var ||= []
      end
    end
  end;Fi[@µ @°+I"0;FI"end;Fi[[	@B)iI"}    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@B)iI"|    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@B)iI"|    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@B)iI"|    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@B)i2I"}    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	@B)i6I"|    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[	I"Pdata//cucumber_prok/cucumber/core_ext/disable_mini_and_test_unit_autorun.rb;TiI"Ü      class << self
        @@installed_at_exit = true
      end
      
      def function(arglist)
        0
      end
    end
  end);Fi[	@ÔiI"      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0
      end
    end
  end;Fi[	@π)iI"}    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end
    
    def function(arglist);Fi[I"[];FI"end;FI"end;FI" ;Fi[[	@ºi∫I"Ó        var = connection.select_all(var, "SQL", var.bind_values.dup)
        var.instantiate(var))
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = (eager_load_values + includes_values).uniq;Fi[	@=iPI"Û      if self[:without] then
        self[:without].split(":").map { |arglist| var.to_sym }
      else
        []
      end
    end
    
    # @local_config["BUNDLE_PATH"] should be prioritized over ENV["BUNDLE_PATH"]
    def function(arglist);Fi[	@{i$I"ø            File.basename(var)
          end
        else
          []
        end
      end
      
      def function(arglist)
        File.join(templates_directory, var.to_s, "manifest.rb");Fi[	I""data//compass_proj/compass.rb;TiI"ñ        []
      end
    rescue ArgumentError
      []
    end
  end
  
  module_function(:base_directory, :lib_directory, :shared_extension_paths)
  ;Fi[	@Ci$I"œ    if defined? @var and (params[:controller] == "multis") then
      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist)
    defined? @var ? (@var.publisher.open?) : (false);Fi[	@ÁiΩI"¶          end
        end
      else
        []
      end
    end
    
    def function(arglist)
      var = /"([^"\\]|\\["\/\\bfnrt]|\\u[0-9a-fA-F]{4})*"/.match(var);Fi[	@ùiúI"%      if options[:fields] then
        options[:fields].keys.reject { |arglist| (var == "_type") }
      else
        []
      end
    end
    
    # When freezing a criteria we need to initialize the context first
    # otherwise the setting of the context on attempted iteration will raise a;Fi[	@i$I"      if compiled_parser_version.!=(loaded_parser_version) then
        ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end
    
    def function(arglist)
      var = {};Fi[	@ÖiI"        var = connection.select_all(var, "SQL", var.bind_values)
        var.map { |arglist| var["id"].to_i })
      rescue ThrowResult
        []
      end
    end
    
    def function(arglist)
      var = except(:includes, :eager_load, :preload, :select).select("#{table_name}.id");Fi[@û=@◊@I"return @var;FI"end;Fi[[	@ci†I"≤  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale);Fi[	@ci¨I"≠  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth);Fi[	@ci∏I"∞  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight);Fi[	@ciƒI"∏  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin);Fi[	@ci–I"≥  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor);Fi[	@cißI"ü  	# @return int page number
  	# @since 1.0
  	# @see alias_nb_pages()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:page_no, :PageNo);Fi[	@ci¨I"¨  	# @return boolean
  	# @since 1.4
  	# @see SetAutoPageBreak()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:accept_page_break, :AcceptPageBreak);Fi[	@cieI"ó  	# @return float
  	# @since 1.2
  	# @see SetX(), GetY(), SetY()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_x, :GetX);Fi[	@ci}I"ó  	# @return float
  	# @since 1.0
  	# @see SetY(), GetX(), SetX()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_y, :GetY);Fi[@'I"	@var;FI"end;FI" ;Fi[[	@∏i6I"D            ([primary_key] + (column_names - [primary_key])).compact.each_with_index do |arglist|
              (@var << [var, "#{aliased_prefix}_r#{i}"])
            end
          end
          @var
        end
        
        def function(arglist)
          Hash[column_names_with_alias.map { |arglist| [var, var[var]] }];Fi[	@_iBI"         unless @var then
          @var = Role.wrap_list(@var.call(@var), @var)
          @var = true
        end
        @var
      end
      
      # Clear the cached value
      def function(arglist);Fi[	@¨iRI"Î        end)
        unless (@var.include?(NO_PROFILE_LONG_FLAG) or @var.include?(NO_PROFILE_SHORT_FLAG)) then
          @var.push("--no-profile")
        end
        @var
      end
      
      def function(arglist)
        @var = var;Fi[	@‚i,I"Ô    unless @var then
      require("yaml")
      @var = YAML.load_file((Pathname.new(ABS__FILE__).parent.realpath + "fixtures/updater_fixture.yaml"))
    end
    @var
  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|;Fi[	@(iêI"€        var.each_pair do |arglist|
          @var[var.to_sym] = Paperclip::Style.new(var.to_sym, var.dup, self)
        end
      end
      @var
    end
    
    def function(arglist)
      var = @var[:only_process].dup;Fi[	@}i!I"«              @var.allowed_to?("view_#{o}".to_sym, var)
            end
          end
        end
        @var
      end
      
      # Yields to filter the activity scope
      def function(arglist);Fi[	@ÖidI"Ï  def function(arglist)
    unless instance_variable_defined?(:@current_theme) then
      @var = Redmine::Themes.theme(Setting.ui_theme)
    end
    @var
  end
  
  # Returns the header tags for the current theme
  def function(arglist);Fi[	@‘%i I"      @var = system("#{shell_quote(CONVERT_BIN)} -version") rescue false
      unless @var then
        logger.warn("Imagemagick's convert binary (#{CONVERT_BIN}) not available")
      end
      @var
    end
    
    def self.logger(arglist)
      Rails.logger;Fi[	@'iI"¯      return unless Twitter.identity_map
      unless defined? @var and (@var.class == Twitter.identity_map) then
        @var = Twitter.identity_map.new
      end
      @var
    end
    
    def self.fetch(arglist)
      return unless identity_map;Fi[I"#     end;FI"#   end;FI"#;FI"#   person = Person.new;Fi[[	@˝i/I"›      #
      #     def clear_attribute(attr)
      #       send("#{attr}=", nil)
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob";Fi[	@˝iSI"ﬁ      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob";Fi[	@˝iwI"      #
      #     def reset_attribute_to_default!(attr)
      #       ...
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name                         # => 'Gem'
      #   person.reset_name_to_default!;Fi[	@˝ièI"‡      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob";Fi[	@˝i”I"‹      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob";Fi[	@˝iˆI"€      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true;Fi[	@CiI"±    #
    #     def capitalized_name
    #       name.capitalize
    #     end
    #   end
    #
    #   person = Person.new
    #   person.name = 'bob'
    #   person.age  = 22;Fi[	@Vi!I"ﬁ        #
        #     def remove_whitespaces
        #       name.strip!
        #     end
        #   end
        #
        #   person = Person.new
        #   person.name = '  bob  '
        #   person.valid? # => true;Fi[	@ViCI"‡        #
        #     def set_status
        #       self.status = errors.empty?
        #     end
        #   end
        #
        #   person = Person.new
        #   person.name = ''
        #   person.valid? # => false;Fi[@µ @°+I"(@var << var);FI"end;Fi[[	@ui#I"ò          var.feature = self
        end
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@xiI"†      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@ñiI"Ø        def function(arglist)
          @var = []
        end
        
        def function(arglist)
          (@var << var)
        end
        
        def function(arglist);Fi[	@«i2I"©        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@iI"ù      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@di1I"N  end
  
  private
  
  def function(arglist)
    (@var << var)
  end
end;Fi[	@h$i5I"Æ      @var = true
      (@var << "\n<button type='submit'>#{text}</button>")
    end
    
    def function(arglist)
      (@var << var)
    end
    
    def function(arglist);Fi[	@ÊiI"õ        @var = var
        @var = Array.new
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[	@qi.I"ó        @var = false
        @var = nil
      end
      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist);Fi[@	)I"%@var, @var, @var = var, var, var;FI"end;FI" ;Fi[[	@ñidI"ﬂ        
        attr_accessor(:status, :value)
        
        def function(arglist)
          @var, @var, @var = var, var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit;Fi[	@ûiI"Ã      
      #:nodoc:
      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@i:I"ñ    end
    
    class JsHook
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      attr_reader :function
      ;Fi[	@2iI"Õ    class FeaturesLoader
      include(Formatter::Duration)
      
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        load unless @var;Fi[	@ù
iI"Ú      # @param [ Metadata ] metadata The relation's metadata.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      # Execute the provided block inside a binding.
      #;Fi[	@Â
iI"™      #   id to query with.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      protected
      ;Fi[	@iiI"¨module Spec
  module Example
    class ExampleProxy
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      attr_reader(:options)
      ;Fi[	@ºiI"—module Spec
  module Matchers
    class Has
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        var.__send__(predicate(@var), *@var, &@var);Fi[	@äiI"%        # The method to invoke on the observer
        # The object being transitioned
        # The transition being run
        def function(arglist)
          @var, @var, @var = var, var, var
        end
        
        # The arguments to pass into the method
        def function(arglist);Fi[I" #   person.pets.size # => 3;TI"#   person.pets;TI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[[	@îi<I"a      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îi]I"N      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îivI"Q      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiìI"9      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îi≥I"a      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiœI"N      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiÎI"Q      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiI"9      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îi#I"9      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@û=@HI"#;FI"1# @return [ true, false ] If a value exists.;Fi[[	@¬	iI"      #
      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first);Fi[	@≈	iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>);Fi[	@»	iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=);Fi[	@À	iI"	      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var);Fi[	@Œ	iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<);Fi[	@—	iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=);Fi[	@‘	iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first);Fi[	@◊	iI"6      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) };Fi[	@›	iI"      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first);Fi[@'@¸@ˇ,I"&if (@var["type"] == "Type0") then;Fi[[	@Li4I"Â    var = "GBK-EUC-H"
    var = { "ordering" => "GB1", "supplement" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else;Fi[	@LiNI"∑      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@Li¢I"§        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else;Fi[	@Oi$I"Ï    var = "90ms-RKSJ-H"
    var = { "ordering" => "Japan1", "supplement" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else;Fi[	@OiCI"π      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@OiùI"¶        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else;Fi[	@Ri#I"Ì    var = "KSCms-UHC-HW-H"
    var = { "ordering" => "Korea1", "supplement" => 1 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else;Fi[	@Ri=I"∑      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else;Fi[	@RiëI"§        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else;Fi[I"#   end;FI"#;F@jII"#   person.pets;Ti[[	@îi:I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îi[I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îitI"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îiëI"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îi±I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets # dependent: :nullify option by default
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îiÕI"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :destroy
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îiÈI"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets, dependent: :delete_all
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îiI"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îi!I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[@'I"	else;FI"# do nothing;FI"end;Fi[[	@ΩiPI"¬              end
            end
            remove_duplicate_results!(var.klass, var, var[var]) unless var.empty?
          end
        else
          # do nothing
        end
      end
      ;Fi[	@ûiºI";                var[var].concat(var.map do |arglist|
                  { var.foreign_key => (var[primary_key_name]), var.association_foreign_key => (ActiveRecord::FixtureSet.identify(var)) }
                end)
              end
            else
              # do nothing
            end
          end
        end;Fi[	@ﬂiAI"º            Associations::HasOneThroughAssociation
          else
            Associations::HasOneAssociation
          end
        else
          # do nothing
        end
      end
      ;Fi[	@5iI"µ            @var = "join"
            @var = attributes.map(&:plural_name)
            set_index_names
          end
        else
          # do nothing
        end
      end
      ;Fi[	I"2data//diaspora_proj/helpers/o_embed_helper.rb;TiI"Ÿ      if var.has_key?("url") then
        var = var.options_hash("")
        var = link_to_oembed_image(var, "")
      end
    else
      # do nothing
    end
    return var.gsub("http://", "https://").html_safe
  end;Fi[	@ˆi'I"¡          print(" => #{path}")
        else
          print(" => #{Pathname.new(value).realpath}") if File.symlink?(var)
        end
      else
        # do nothing
      end
      puts
    end;Fi[	@îiOI"#        when :tag, :revision then
          nostdout do |arglist|
            quiet_safe_system(@@var, "checkout", { :quiet_flag => "-q" }, @var, "--")
          end
        else
          # do nothing
        end
      else
        quiet_safe_system(@@var, "reset", "--hard", "origin/HEAD");Fi[	@ci=I"ì          SetLineWidth(0.1)
        end
        Line((@var + var), @var, (@var + var), @var)
      end
    else
      # do nothing
    end
  end
  ;Fi[	@ˇi(I"µ              LoopbackMatcher.instance
            else
              AllMatcher.instance
            end
          else
            # do nothing
          end
        end
      end;Fi[@	)I"return @var;FI"end;FI" ;Fi[[	@ci°I"ï  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_image_scale, :GetImageScale)
  ;Fi[	@ci≠I"ì  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_width, :GetPageWidth)
  ;Fi[	@ciπI"ï  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_page_height, :GetPageHeight)
  ;Fi[	@ci≈I"ó  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_break_margin, :GetBreakMargin)
  ;Fi[	@ci—I"ó  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_scale_factor, :GetScaleFactor)
  ;Fi[	@ci®I"Ö  	# @since 1.0
  	# @see alias_nb_pages()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:page_no, :PageNo)
  ;Fi[	@ci≠I"ö  	# @since 1.4
  	# @see SetAutoPageBreak()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:accept_page_break, :AcceptPageBreak)
  ;Fi[	@cifI"á  	# @since 1.2
  	# @see SetX(), GetY(), SetY()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_x, :GetX)
  ;Fi[	@ci~I"á  	# @since 1.0
  	# @see SetY(), GetX(), SetX()
  	#
  def function(arglist)
    return @var
  end
  
  alias_method(:get_y, :GetY)
  ;Fi[@'@¸@ˇ,I"	init;Fi[[	@iiI"Î        attach_steps(@var)
        @var = StepCollection.new(@var)
        @var = @var.step_invocations(true)
      end
      
      def function(arglist)
        init
        if @var then
          @var.step_invocations(true).dup(var);Fi[	@ii<I"±        else
          yield
        end
      end
      
      def function(arglist)
        init
        if hook_context.!=(self) then
          hook_context.accept_hook?(var);Fi[	@iiOI"—      
      def function(arglist)
        (@var.first or self)
      end
      
      def function(arglist)
        init
        var = [:background, @var, @var]
        var = (var + [name]) unless name.empty?;Fi[	@uiEI"∑      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init
        var = @var.index(var)
        var = @var[(var + 1)];Fi[	@ui`I"      def function(arglist)
        var = name.split(/\n/)[0]
        var =~ /#{language.keywords("feature")}:(.*)/ ? ($1.strip) : (var)
      end
      
      def function(arglist)
        init
        var = [:feature, @var, name]
        var = @var.to_sexp;Fi[	@xi>I"©      
      def function(arglist)
        (max_line_length - var)
      end
      
      def function(arglist)
        init
        @var.max_line_length(self)
      end;Fi[	@ÉiI"¨      
      def function(arglist)
        create_step_invocations_for_example_rows!(@var)
      end
      
      def function(arglist)
        init
        super
      end;Fi[	@Éi+I"Œ      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init
        example_rows.each { |arglist| var.skip_invoke! }
      end;Fi[	@çi[I"ÿ      
      def function(arglist)
        @var.select { |arglist| var.failed? }.any?
      end
      
      def function(arglist)
        init
        var = [:scenario_outline, @var, name]
        var = @var.to_sexp;Fi[I"$# @example Do the values match?;F@HI"#;F@Hi[[	@∑	i
I"4    class All < Default
      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If the values match.;Fi[	@≈	i
I"%    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@»	i
I"2    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@À	i
I"    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@Œ	i
I""    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@—	i
I"/    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@‘	i
I")    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@◊	i
I"%    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[	@›	i
I".    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.;Fi[@'@(I"	self;FI"end;Fi[[	@Æi=I"A          Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.parent.author.diaspora_handle} payload_type=#{self.class} parent_id=#{self.parent.id}")
          return
        end
      end
    end
    self
  end
  
  def function(arglist);Fi[	@›#iAI"È        Rails.logger.info("event=retraction status=abort reason='no post found authored by retractor' sender=#{person.diaspora_handle} post_guid=#{post_guid}")
      else
        self.perform(var)
      end
    end
    self
  end
end;Fi[	@‡#i]I"      else
        Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.sender_handle} payload_type=#{self.class}")
        return
      end
    end
    self
  end
  
  def function(arglist);Fi[	@Ò	i,I"ô            end
          end
          var.send(var, var)
        end
      end
      self
    end
    
    # Are the observers disabled for the object?;Fi[	@ë
iÂI"‚              else
                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        
        # Defines the setter method that allows you to set documents;Fi[	@-i:I"Ï              var = send("#{name}=", var)
              var.run_callbacks(:build)
              var
            end
          end
          self
        end
        
        # Defines a creator method for an embeds_one relation. This is;Fi[	@åiI"ı            if var.relation.stores_foreign_key? then
              field(var.inverse_type, :type => (String))
              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end;Fi[	@i:I"-              var.value[0].value = ["*"]
              var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["#{match.value[1].value.first}("]), Node.new(:FUNCTION, ["self(", var])])
            end
          end
        end
        self
      end
      
      # Find a node by type using +types+;Fi[	@#:i±I"Ä            end
          else
            var.delete("class")
          end
        end
        self
      end
      
      ###;Fi[I"private;FI" ;F@∏ I"
begin;Fi[[	@i&I"©    
    (alias :attributes= :assign_attributes)
    
    private
    
    def function(arglist)
      begin
        public_send("#{k}=", var)
      rescue NoMethodError;Fi[	@i(I"Ö      var
    end
    
    private
    
    def function(arglist)
      begin
        File.read(var).strip
      rescue Errno::ENOENT;Fi[	@JiaI"∑        var
      end
      
      private
      
      def function(arglist)
        begin
          (return unless @var
          configuration.invoke_command(var, var) do |arglist|;Fi[	@ßi=I"◊        @var
      end
      
      private
      
      def function(arglist)
        begin
          (return false unless configuration.drb?
          @var = DRbClient.run(@var, @var, @var, configuration.drb_port);Fi[	@Bi5I"Œ        @var.embed(var, var, var)
      end
      
      private
      
      def function(arglist)
        begin
          Timeout.timeout(var) { |arglist| STDIN.gets }
        rescue Timeout::Error => var;Fi[	@ai.I"Ç    end
  end
  
  private
  
  def function(arglist)
    begin
      if Dir[".git/*"].empty? then
        safe_system("git init");Fi[	@6iI"      (var or raise(Errors::NotIdentifiedByImageMagickError.new))
    end
    
    private
    
    def function(arglist)
      begin
        silence_stream(STDERR) do |arglist|
          Paperclip.run("identify", "-format '%wx%h,%[exif:orientation]' :file", :file => ("#{path}[0]"));Fi[	@ÖiI"·      find_ids_with_associations
    end
    
    private
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find_ids(var);Fi[	@• i\I"Î      request(:put, var, var)
    end
    
    private
    
    def function(arglist)
      begin
        connection.send(var.to_sym, var, var) do |arglist|
          var.headers[:authorization] = auth_header(var.to_sym, var, var).to_s;Fi[@û=@#K@HI"#;Fi[[	@∑	i	I"  module Matchers
    class All < Default
      # Return true if the attribute and first value in the hash are equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@≈	i	I"  module Matchers
    class Gt < Default
      # Return true if the attribute is greater than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@»	i	I"  module Matchers
    class Gte < Default
      # Return true if the attribute is greater than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@À	i	I"˚  module Matchers
    class In < Default
      # Return true if the attribute is in the values.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@Œ	i	I"  module Matchers
    class Lt < Default
      # Return true if the attribute is less than the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@—	i	I"  module Matchers
    class Lte < Default
      # Return true if the attribute is less than or equal to the value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@‘	i	I"  module Matchers
    class Ne < Default
      # Return true if the attribute and first value are not equal.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@◊	i	I"  module Matchers
    class Nin < Default
      # Return true if the attribute is not in the value list.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[	@›	i	I"  module Matchers
    class Size < Default
      # Return true if the attribute size is equal to the first value.
      #
      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #;Fi[I"##;FI"3# Creates a new instance of the storage object;FI"def function(arglist);FI"super(var, var);Fi[[	@†iI")      # (LAN-based transfers to avoid charges and improve performance)
      ##
      # Rackspace Cloud Files container name and path
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= false
        @var ||= "backups";Fi[	@•iI"      #   :dropbox (full access)
      ##
      # Path to where the backups will be stored
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        @var ||= :app_folder;Fi[	@™iI"‰      # Path to store backups to
      ##
      # use passive mode?
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 21
        @var ||= "backups";Fi[	@±iI"(      
      ##
      # Path where the backup will be stored.
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= File.join(File.expand_path((ENV["HOME"] or "")), "backups")
        instance_eval(&var) if block_given?;Fi[	@∂iI"˛      # Ninefold Credentials
      ##
      # Ninefold directory path
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?;Fi[	@ªiI"Ï      # Path to store backups to
      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups";Fi[	@æiI"      # Amazon S3 bucket name and path
      ##
      # Region of the specified S3 bucket
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?;Fi[	@√iI"Ò      # Server IP Address and SCP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups";Fi[	@»iI"Ú      # Server IP Address and SFTP port
      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups";Fi[I"@var ||= [];FI"end;FI" ;FI"def function(arglist);Fi[[	@^i2I"Ù    end
    
    def function(arglist)
      @var ||= []
    end
    
    def function(arglist)
      if @var and File.exist?(File.join(full_gem_path, ".git")) then
        var = Dir.chdir(full_gem_path) { |arglist| `git rev-parse HEAD`.strip };Fi[	@
iXI"       end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        hooks_for(:around, var).reverse.inject(var) do |arglist|
          proc do |arglist|;Fi[	@i&I"ù        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          @var ||= []
        end;Fi[	@i*I"¬        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          if var.is_a?(Hash) then
            var = var.stringify_keys;Fi[	@]iI"‰        end
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          example_group_creation_listeners.each do |arglist|
            var.register_example_group(var);Fi[	@li	I"¥  module Example
    module ModuleReopeningFix
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (child_modules << var)
      end;Fi[	@{i"I"«        private
        
        def function(arglist)
          @var ||= []
        end
        
        def function(arglist)
          var = find(var.description)
          return false unless var;Fi[	@€iﬂI"ô      end
      
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        (similar_messages << var)
      end;Fi[	@iûI"ë      
      # :nodoc:
      def function(arglist)
        @var ||= []
      end
      
      def function(arglist)
        @var = true
      end;Fi[@'@¸@ˇ,I"@var[var];Fi[[	@ri©I"Æ          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end
          ;Fi[	@%iMI"ê      
      def function(arglist)
        @var ||= first.source
      end
      
      def function(arglist)
        @var[var]
      end
      ;Fi[	@¬i}I"ñ      
      def function(arglist)
        (@var.nil? or @var.active?)
      end
      
      def function(arglist)
        @var[var]
      end
      ;Fi[	@}iI"Ñ      
      def function(arglist)
        @var = []
      end
      
      def function(arglist)
        @var[var]
      end
      ;Fi[	@ñi@I"ú        
        def function(arglist)
          self[var].value
        end
        
        def function(arglist)
          @var[var]
        end
        ;Fi[	@¨i/I"ö        @var = []
        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end
      ;Fi[	@Êi‹I"≤        @var.puts
        var[(1..-1)].each { |arglist| @var.puts("    #{s}") }
        @var.flush
      end
      
      def function(arglist)
        @var[var]
      end
      ;Fi[	@CiàI"ú        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end
        ;Fi[	@]i@I"±          var = @var
          @var = Hash.new(var)
          @var.merge!(var) if var
        end
        
        def function(arglist)
          @var[var]
        end
        ;Fi[I"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;FI"#     end;Fi[[	@â iI"ƒ    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@â iDI"ƒ    #         transition :idling => :parked
    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@â idI"‹    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@§iI"¸        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@§iYI"¸        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@§i}I"¸        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   ;Fi[	@=<iéI"    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do;Fi[	@„iÂI"≥    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[	@„i˛I"«    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   ;Fi[I"# @rate_limited Yes;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;FI"&# @return [Array<Twitter::Tweet>];Fi[[	@!i/I"      # Show tweet timeline for members of the specified list
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/statuses
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload list_timeline(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;Fi[	@5iI",      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@5i*I"ˇ      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={})
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@5iBI"      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.;Fi[	@5iZI"*      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@5ioI"<      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@5iÅI"<      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[	@5iñI"K      # Returns the 20 most recent tweets of the authenticated user that have been retweeted by others
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets_of_me
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@;iI"Ì      # Returns up to 100 of the first retweets of a given tweet
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets/:id
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param id [Integer] The numerical ID of the desired Tweet.
      # @param options [Hash] A customizable set of options.;Fi[@HI"#;F@ûJI"def function(arglist);Fi[[	@¬	iI"      # @example Does anything exist?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.nil?.!=(var.values.first)
      end;Fi[	@≈	iI"      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>)
      end;Fi[	@»	iI"      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :>=)
      end;Fi[	@À	iI"Q      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        var = Array.wrap(@var)
        var.values.first.any? { |arglist| var.any? { |arglist| var.===(var) } };Fi[	@Œ	iI"      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<)
      end;Fi[	@—	iI"      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        determine(var, :<=)
      end;Fi[	@‘	iI"      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        @var.!=(var.values.first)
      end;Fi[	@◊	iI"8      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        Array.wrap(@var).none? { |arglist| var.values.first.include?(var) }
      end;Fi[	@›	iI"      # @example Do the values match?
      #   matcher.matches?({ :key => 10 })
      #
      # @param [ Hash ] value The values to check.
      #
      # @return [ true, false ] If a value exists.
      def function(arglist)
        (@var.size == var.values.first)
      end;Fi[@'@¸@ˇ,I"0;Fi[[	@B)iI"h    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@B)iI"g    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@B)iI"g    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@B)iI"g    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@B)i1I"h    
    def function(arglist)
      {}
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@B)i5I"g    
    def function(arglist)
      0
    end
    
    def function(arglist)
      0
    end
    ;Fi[	@ÛIiI"ò    class MiniTest::Unit
      class << self
        @@installed_at_exit = true
      end
      
      def function(arglist)
        0
      end
    end;Fi[	@ÔiI"î    class Stepdefs < Usage
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        0
      end
    end;Fi[	@π)iI"h    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end
    ;Fi[@'@(@)I"	else;Fi[[	@KiäI"-                    var = { :type => (var) }
                  end
                  var.to_xml(var.merge(var))
                end
              end
            end
          else
            var[:root] = var.to_s
            var[:type] = var.class.name unless (var.class.to_s.underscore == var.to_s);Fi[	@üikI"ß                end
              else
                (@var << var)
              end
            end
          end
        else
          (@var << shift)
        end;Fi[	@ÚiZI"5            respond_with(var, :location => (post_path(var.status_message)))
          else
            respond_with(var, :location => (person_photos_path(current_user.person)))
          end
        end
      end
    else
      respond_with(var, :location => (person_photos_path(current_user.person)))
    end;Fi[	@ıiQI"±                end
              end
            end
          end
        end
      end
    else
      if var = params[:reorder_aspects] then
        @var.reorder_aspects(var);Fi[	@<iI"§                "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">"
              else
                "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">"
              end
            end
          end
        else
          if @var.html4? then
            case @var.value[:type];Fi[	@gi3I"ˇ            end
          else
            opoo("Skipping (old) keg-only: #{keg}")
          end
        end
      end
    else
      if (var.rack.children.length > 1) then
        opoo("Skipping #{f.name}: most recent version #{f.version} not installed");Fi[	@.iI"        var.children.each do |arglist|
          if (var / ".git").directory? then
            puts(var.basename.to_s.reverse.sub("-", "/").reverse)
          end
        end
      end
    else
      (ARGV.first == "--repair") ? (repair_taps) : (install_tap(*tap_args))
    end;Fi[	@ciI"Œ            var = (var + @var["desc"]["MissingWidth"])
          else
            var = (var + 500)
          end
        end
      end
    else
      var.each_byte do |arglist|
        if var[var.chr] then;Fi[	@ci◊
I"∏                var = []
                var = 1
              end
            end
          end
        end
      else
        if ((var >> 6) == 2) then
          (var << (var - 128));Fi[@	)I"@var, @var = var, var;FI"end;FI" ;Fi[[	@LiI"Ÿ    class ConnectionSpecification
      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        @var = var.config.dup;Fi[	@∫i
I"*    class SQLiteDatabaseTasks
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        raise(DatabaseAlreadyExists) if File.exist?(configuration["database"]);Fi[	@i&I"ﬂ        end
        
        class ArrayProxy
          def function(arglist)
            @var, @var = var, var
          end
          
          def function(arglist)
            @var.send(:"read_inherited_#{@var}_array");Fi[	@ñi)I"Õ        
        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit;Fi[	@õiI"æ    class Tags
      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@5iI"Ó    class ForProgrammingLanguages
      extend(Forwardable)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def_delegators(:@user_interface, :embed, :ask, :puts, :features_paths, :step_match)
      ;Fi[	I":data//cucumber_prok/cucumber/step_definition_light.rb;Ti	I"  class StepDefinitionLight
    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist)
      (regexp_source == var.regexp_source) and (file_colon_line == var.file_colon_line);Fi[	@YiI"Æ      
      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        var = [@var];Fi[	@Ω	iI"$      # @param [ Object ] attribute The current attribute to check against.
      #
      # @since 1.0.0
      def function(arglist)
        @var, @var = var, var
      end
      
      # Return true if the attribute and value are equal, or if it is an array
      # if the value is included.;Fi[@	)I"@var = nil;FI"end;FI" ;Fi[[	@}iVI"ÿ        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      
      # Set the inverse association, if possible
      def function(arglist);Fi[	@ﬂi—I"æ        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        check_validity_of_inverse!;Fi[	@˙i:I"∂      end
      
      # Support for testing.
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        configuration.to_sass_plugin_options;Fi[	@Øi	I"ømodule Cucumber
  module Cli
    class ProfileLoader
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        unless cucumber_yml.has_key?(var) then;Fi[	@«iiI"ù        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        @var.text!(@var) if @var;Fi[	@Êi´I"¢        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var);Fi[	@Èi5I"ö        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var;Fi[	@
i0I"ò        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        transforms.unshift(var);Fi[	@iÇI"Ñ        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      ;Fi[@ÿK@ŸK@⁄KI" # @return [Twitter::Cursor];Fi[[	@DiI"ƒ      include(Twitter::API::Utils)
      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following;Fi[	@Di*I"¨      end
      
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload follower_ids(options={})
      #   Returns an array of numeric IDs for every user following the authenticated user;Fi[	@Di[I"ß      # Returns an array of numeric IDs for every user who has a pending request to follow the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/incoming
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@DijI"≥      # Returns an array of numeric IDs for every protected user for whom the authenticating user has a pending follow request
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/outgoing
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Di I"      # Returns a cursored collection of user objects for users following the specified user.
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following;Fi[	@DiI"2      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following;Fi[	@!iqI"«      # List the lists the specified user has been added to
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/memberships
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload memberships(options={})
      #   @param options [Hash] A customizable set of options.;Fi[	@!i,I"‹      # Returns the members of the specified list
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/members
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload list_members(list, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;Fi[	@!iÀI"¡      # List the lists the specified user follows
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/lists/subscriptions
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload subscriptions(options={})
      #   @param options [Hash] A customizable set of options.;Fi[I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;FI"#       end;Fi[[	@â icI"Â    # == Examples
    # 
    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[	@&iAI"›    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@&isI"›    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do;Fi[	@§iI"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@§iXI"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@§i|I"        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end;Fi[	@=<içI"Ò    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #     ;Fi[	@„i˝I"œ    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end;Fi[@û=I"-# @return [ Time ] The object mongoized.;FI"#;FI"# @since 3.0.0;Fi[[	@8	iI"”      #
      # @example Mongoize the object.
      #   date.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self);Fi[	@8	i7I"        #   Date.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          unless var.blank? then;Fi[	@?	iI"‹      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self);Fi[	@?	i=I"        #   DateTime.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var);Fi[	@}	iI"”      #
      # @example Mongoize the object.
      #   time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Time.mongoize(self);Fi[	@}	i=I"        #   Time.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return nil if var.blank?;Fi[	@Ñ	iI"Ô      #
      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self);Fi[	@Ñ	i,I"
        #   TimeWithZone.mongoize("2012-1-1")
        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var);Fi[@'@(@éI"# :call-seq:;Fi[[	@Yi´I"±      
      def function(arglist)
        "be #{expected_to_sentence}#{args_to_sentence}"
      end
    end
    
    # :call-seq:
    #   should be_true
    #   should be_false;Fi[	@üi^I"‘      
      def function(arglist)
        "change ##{@message}"
      end
    end
    
    # :call-seq:
    #   should change(receiver, message, &block)
    #   should change(receiver, message, &block).by(value);Fi[	@øiYI"Ò      
      def function(arglist)
        "#{relativities[@relativity]}#{@expected}"
      end
    end
    
    # :call-seq:
    #   should have(number).named_collection__or__sugar
    #   should_not have(number).named_collection__or__sugar;Fi[	@bi`I"’      
      def function(arglist)
        caller.first(3).find { |arglist| var =~ /should_not/ }
      end
    end
    
    # :call-seq:
    #   should raise_exception()
    #   should raise_exception(NamedError);Fi[	@oi=I"’      
      def function(arglist)
        (@var.length == 1) ? ("##{@names.first}") : (@var.inspect)
      end
    end
    
    # :call-seq:
    #   should respond_to(*names)
    #   should_not respond_to(*names);Fi[	@Ê(iI"µ      
      def function(arglist)
        "expected #{@actual} not to satisfy block"
      end
    end
    
    # :call-seq:
    #   should satisfy {}
    #   should_not satisfy {};Fi[	@uiBI"»      
      def function(arglist)
        @var.nil? ? ("") : (" with #{@expected_arg.inspect}")
      end
    end
    
    # :call-seq:
    #   should throw_symbol()
    #   should throw_symbol(:sym);Fi[	@–iãI"µ        
        def function(arglist)
          var.kind_of?(@var)
        end
      end
      
      # :call-seq:
      #   object.should_receive(:message).with(no_args())
      #;Fi[I"#   class BlogPost;FI"%#     extend ActiveModel::Naming;FI"#   end;FI"#;Fi[[	@iI"7    # Equivalent to <tt>String#==</tt>. Returns +true+ if the class name and
    # +other+ are equal, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name == 'BlogPost'  # => true
    #   BlogPost.model_name == 'Blog Post' # => false;Fi[	@i(I"Ë    #
    # Equivalent to <tt>#==</tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name === 'BlogPost'  # => true
    #   BlogPost.model_name === 'Blog Post' # => false;Fi[	@i6I"Ë    #
    # Equivalent to <tt>String#<=></tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name <=> 'BlogPost'  # => 0
    #   BlogPost.model_name <=> 'Blog'      # => 1;Fi[	@iGI"    # regexp. Returns the position where the match starts or +nil+ if there is
    # no match.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name =~ /Post/ # => 4
    #   BlogPost.model_name =~ /\d/   # => nil;Fi[	@iVI"I    # Equivalent to <tt>String#!~</tt>. Match the class name against the given
    # regexp. Returns +true+ if there is no match, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name !~ /Post/ # => false
    #   BlogPost.model_name !~ /\d/   # => true;Fi[	@ieI"V    # Equivalent to <tt>String#eql?</tt>. Returns +true+ if the class name and
    # +other+ have the same length and content, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.eql?('BlogPost')  # => true
    #   BlogPost.model_name.eql?('Blog Post') # => false;Fi[	@isI"Ø    #
    # Returns the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.to_s # => "BlogPost"
    ##;Fi[	@iõI"    # Transform the model name into a more humane format, using I18n. By default,
    # it will underscore then humanize the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.human # => "Blog post"
    #;Fi[@'@¸@†>I"I# Convert the object from its mongo friendly ruby type to this type.;Fi[[	@.	iI"È      # @since 3.0.0
      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[	@8	iI"˙      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[	@?	i%I"˛      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[	@d	i+I"È      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[	@n	iI"˘      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[	@s	i¢I"”        else
          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[	@x	iI"ı      # @since 2.3.1
      def function(arglist)
        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[	@Ñ	iI"      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.;Fi[I"if (var == 1) then;FI"@var = @var;F@[HI"/var = (((var - (2 * @var)) * 1000) / @var);Fi[[	@Li¿I"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@LiﬁI"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@OiªI"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@OiÊI"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@RiØI"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@RiÕI"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@UióI"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[	@Ui∏I"„        var = -1
        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1);Fi[I"assert(Category.valid?);FI"end;FI" ;FI"def function(arglist);Fi[[	@öi.I"3    categories(:child_2).move_left
    assert_nil(categories(:child_2).left_sibling)
    assert_equal(categories(:child_1), categories(:child_2).right_sibling)
    assert(Category.valid?)
  end
  
  def function(arglist)
    categories(:child_2).move_right
    assert_nil(categories(:child_2).right_sibling);Fi[	@öi5I"N    categories(:child_2).move_right
    assert_nil(categories(:child_2).right_sibling)
    assert_equal(categories(:child_3), categories(:child_2).left_sibling)
    assert(Category.valid?)
  end
  
  def function(arglist)
    categories(:child_3).move_to_left_of(categories(:child_1))
    assert_nil(categories(:child_3).left_sibling);Fi[	@öi<I"k    categories(:child_3).move_to_left_of(categories(:child_1))
    assert_nil(categories(:child_3).left_sibling)
    assert_equal(categories(:child_1), categories(:child_3).right_sibling)
    assert(Category.valid?)
  end
  
  def function(arglist)
    categories(:child_1).move_to_right_of(categories(:child_3))
    assert_nil(categories(:child_1).right_sibling);Fi[	@öiCI"K    categories(:child_1).move_to_right_of(categories(:child_3))
    assert_nil(categories(:child_1).right_sibling)
    assert_equal(categories(:child_3), categories(:child_1).left_sibling)
    assert(Category.valid?)
  end
  
  def function(arglist)
    categories(:child_2).move_to_root
    assert_nil(categories(:child_2).parent);Fi[	@öiMI"W    assert_equal(1, categories(:child_2_1).level)
    assert_equal(1, categories(:child_2).left)
    assert_equal(4, categories(:child_2).right)
    assert(Category.valid?)
  end
  
  def function(arglist)
    categories(:child_1).move_to_child_of(categories(:child_3))
    assert_equal(categories(:child_3).id, categories(:child_1).parent_id);Fi[	@öiSI"@  def function(arglist)
    categories(:child_1).move_to_child_of(categories(:child_3))
    assert_equal(categories(:child_3).id, categories(:child_1).parent_id)
    assert(Category.valid?)
  end
  
  def function(arglist)
    var = Category.create!(:name => "New Child")
    var.move_to_child_of(categories(:top_level));Fi[	@öi≤I"·  def function(arglist)
    assert(Category.valid?)
    Category.delete(categories(:child_2).id)
    assert(Category.valid?)
  end
  
  def function(arglist)
    assert(Category.valid?)
    categories(:top_level_2)["lft"] = 0;Fi[	@öi	I"‚    var.move_to_child_of(var)
    assert(Category.valid?)
    var.move_to_child_of(var)
    assert(Category.valid?)
  end
  
  def function(arglist)
    assert_nothing_raised { |arglist| Note.no_duplicates_for_columns? }
  end;Fi[@µ I"module ClassMethods;F@»LI"#;Fi[[	@.	i I"˙      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Object.demongoize(object);Fi[	@8	i I"	      def function(arglist)
        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Date.demongoize(object);Fi[	@?	i&I"      def function(arglist)
        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   DateTime.demongoize(object);Fi[	@d	i,I"      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Range.demongoize({ "min" => 1, "max" => 5 });Fi[	@n	iI"      def function(arglist)
        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Set.demongoize({ "min" => 1, "max" => 5 });Fi[	@s	i£I"Ï          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   String.demongoize(object);Fi[	@x	iI"      def function(arglist)
        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Symbol.demongoize(object);Fi[	@Ñ	iI"(      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   TimeWithZone.demongoize(object);Fi[I"I# Removes the transferred archive file(s) from the storage location.;FI"6# Any error raised will be rescued during Cycling;FI"B# and a warning will be logged, containing the error message.;FI"def function(arglist);Fi[[	@†i:I"O      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|;Fi[	@•i\I"0      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@™iFI"?      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[	@±i%I"0      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@∂iBI"H      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then;Fi[	@æi=I"=      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock;Fi[	@√i:I"0      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = [];Fi[	@»i8I"?      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|;Fi[@M@M@MI"var = remote_path_for(var);Fi[[	@†i;I"∏      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        transferred_files_for(var) do |arglist|
          Logger.message(("#{storage_name} started removing '#{local_file}' " + "from container '#{container}'."));Fi[	@•i]I"V      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@™iGI"g      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[	@±i&I"V      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@∂iCI"Q      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        if var = directory_for(var) then
          var = [];Fi[	@æi>I"c      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection.sync_clock
        transferred_files_for(var) do |arglist|;Fi[	@√i;I"V      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|;Fi[	@»i9I"g      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        connection do |arglist|
          transferred_files_for(var) do |arglist|;Fi[@äLI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@8	iI"’      # @example Mongoize the object.
      #   date.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Date.mongoize(self)
      end;Fi[	@8	i8I"        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          unless var.blank? then
            var = var.__mongoize_time__;Fi[	@?	i I"ﬁ      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::DateTime.mongoize(self)
      end;Fi[	@?	i>I"Ë        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end;Fi[	@}	iI"’      # @example Mongoize the object.
      #   time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Time.mongoize(self)
      end;Fi[	@}	i>I"Ò        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return nil if var.blank?
          begin;Fi[	@Ñ	iI"Ò      # @example Mongoize the object.
      #   date_time.mongoize
      #
      # @return [ Time ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::ActiveSupport::TimeWithZone.mongoize(self)
      end;Fi[	@Ñ	i-I"Ë        #
        # @param [ Object ] object The object to convert.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          ::Time.mongoize(var)
        end;Fi[I"!var = ((@var - @var) - @var);FI"/var = (((var - (2 * @var)) * 1000) / @var);FI"end;FI"var = (var + 1);Fi[[	@Li¬I"◊        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@Li‡I"Û        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@OiΩI"◊        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@OiËI"Â        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var);Fi[	@Ri±I"◊        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@RiœI"Û        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)));Fi[	@UiôI"◊        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end;Fi[	@Ui∫I"„        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1);Fi[@‹.I"
raise;FI"end;FI"end;Fi[[	@IiÌI"!        rescue ActiveRecord::StatementInvalid => var
          if var.message.split(":").first =~ /Packets out of order/ then
            raise(ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings.")
          else
            raise
          end
        end
      end
      ;Fi[	@!iI"È        rescue ActiveRecord::StatementInvalid => var
          if /database .* already exists/.===(var.message) then
            raise(DatabaseAlreadyExists)
          else
            raise
          end
        end
      end
      ;Fi[	@˝i4I"        if var.message =~ /GraphViz not installed or dot not in PATH/ then
          Bundler.ui.error(var.message)
          Bundler.ui.warn("The ruby graphviz gem requires GraphViz to be installed")
        else
          raise
        end
      end
    end
    ;Fi[	@∫i(I"ÿ      if var.message =~ /uninitialized constant/ then
        Rails.logger.debug("[Devise] Trying to deserialize invalid class #{klass_name}")
        # do nothing
      else
        raise
      end
    end
  end
end;Fi[	@≤Di{I"¬      else
        if ((var = var.rack.children).size == 1) and var.first.directory? then
          var.first
        else
          raise
        end
      end
    end
    Keg.new(var).optlink);Fi[	@îiJI"          ignore_interrupts { |arglist| @var.unlink if @var.exist? }
          if var.kind_of?(ErrorDuringExecution) then
            raise(CurlDownloadStrategyError, "Download failed: #{@url}")
          else
            raise
          end
        end
      end
      return @var);Fi[	@ki9I"P    rescue FormulaUnavailableError
      if var then
        raise("        Multiple kegs installed to #{rack}\n        However we don't know which one you refer to.\n        Please delete (with rm -rf!) all but one and then try again.\n        Sorry, we know this is lame.\n".undent)
      else
        raise
      end
    end
  end
  ;Fi[	@wiI"      rescue RuntimeError => var
        if (var.message == "no acceptor") then
          raise("Cannot start the server on port #{$APP_CONFIG.port} - are you root, or have another process on this port already?")
        else
          raise
        end
      end
    end
  end;Fi[@{K@M@M@Mi[[	@†i9I"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@•i[I"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@™iEI"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@±i$I"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@∂iAI"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@æi<I"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@√i9I"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[	@»i7I"+        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var);Fi[I"L# There is also a list of default options supported by every validator:;FI"-# +:if+, +:unless+, +:on+ and +:strict+.;FI"J# See <tt>ActiveModel::Validation#validates</tt> for more information;FI"def function(arglist);Fi[[	@PiI"™      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AbsenceValidator, _merge_attributes(var))
      end;Fi[	@Si2I"ß      #   a database column, since the attribute is typecast from "1" to +true+
      #   before validation.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AcceptanceValidator, _merge_attributes(var))
      end;Fi[	@\i4I"ß      # * <tt>:message</tt> - A custom error message (default is: "doesn't match
      #   confirmation").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ConfirmationValidator, _merge_attributes(var))
      end;Fi[	@_i,I"∫      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the
      #   attribute is blank(default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ExclusionValidator, _merge_attributes(var))
      end;Fi[	@bimI"⁄      #   anchors that match the beginning or end of lines as opposed to the
      #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(FormatValidator, _merge_attributes(var))
      end;Fi[	@gi+I"Ω      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(InclusionValidator, _merge_attributes(var))
      end;Fi[	@ûinI"∑      #   as in above example). Defaults to <tt>->(value) { value.split(//) }</tt>
      #   which counts individual characters.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(LengthValidator, _merge_attributes(var))
      end;Fi[	@mi!I"¨      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end;Fi[@µ @°+I"@var = nil;FI"end;Fi[[	@}iUI"ÿ      def function(arglist)
        @var ||= AssociationScope.new(self).scope if klass
      end
      
      def function(arglist)
        @var = nil
      end
      
      # Set the inverse association, if possible;Fi[	@ﬂi–I"∑      def function(arglist)
        @var ||= klass.connection.columns(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@«ihI"î        @var.text!(var)
        @var.br
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@Êi™I"Ø        return if (@var[:no_multiline] or @var)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@Èi4I"õ      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@
i/I"õ        (hooks[var.to_sym] << var)
        var
      end
      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist);Fi[	@iÅI"ô      def function(arglist)
        begin_rb_scenario(var)
      end
      
      def function(arglist)
        @var = nil
      end
      
      private;Fi[	@;i@I"â      end
      @var[var] = { :path => (var), :class => (var) }
    end
    
    def function(arglist)
      @var = nil
    end
  end
end;Fi[@	)I"@var.empty?;TI"end;TI" ;Ti[[	@îiÃI"“      #
      #   person.pets.count  # => 0
      #   person.pets.empty? # => true
      def function(arglist)
        @var.empty?
      end
      
      # Returns +true+ if the collection is not empty.
      #;Ti[	@öi:I"†      end
    end
    
    def function(arglist)
      @var.empty?
    end
    
    ##
    # Returns a multi-line String, reporting all STDERR messages received;Fi[	@úi9I"~      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first;Fi[	@ìi.I"ƒ        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length };Fi[	@=ifI"Î        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) };Fi[	@0iI"m    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function
  ;Fi[	@Äi´I"é    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var);Fi[	@™iI"â    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?;Fi[@'@¸@ˇ,I"var = super;Fi[[	@àiI"¬      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var = super
        var and [var.to_s, owner[reflection.foreign_type].to_s]
      end;Fi[	@Í"iI"È    
    def function(arglist)
      options[:polymorphic].!
    end
    
    def function(arglist)
      var = super
      add_counter_cache_callbacks(var) if options[:counter_cache]
      add_touch_callbacks(var) if options[:touch];Fi[	@∫iI"Õ    
    def function(arglist)
      (super + [:join_table, :association_foreign_key, :delete_sql, :insert_sql])
    end
    
    def function(arglist)
      var = super
      define_destroy_hook
      var;Fi[	@´i-I"Ò          send((var + "="), var)
          raise
        end
      end
      
      def function(arglist)
        var = super
        if locking_enabled? and var.!=(1) then
          raise(ActiveRecord::StaleObjectError.new(self, "destroy"));Fi[	@´i5I"Ë          raise(ActiveRecord::StaleObjectError.new(self, "destroy"))
        end
        var
      end
      
      def function(arglist)
        var = super
        if locking_enabled? then
          var = self.class.locking_column;Fi[	@)i:I"–    def function(arglist)
      return true if @var.empty?
      @var.any? { |arglist| send("#{p}?") }
    end
    
    def function(arglist)
      var = super
      (var << "!") if source
      (var << "\n");Fi[	@∆,iI"      def function(arglist)
        var = ::Rails.application.assets.context_class.new(::Rails.application.assets, "/", "/")
        super
      end
      
      def function(arglist)
        var = super
        var[:custom][:resolver] = ::ActionView::Base.new
        var;Fi[	@´i-I"ö      
      def function(arglist)
        name?
      end
      
      def function(arglist)
        var = super
        var["name"] ||= name
        var;Fi[I"=# @param [ Hash ] options The mongo persistence options.;FI"#;FI"<# @return [ Array<Object> ] The new value of the field.;FI"#;Fi[[	@F
i!I"G      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist);Fi[	@F
iJI"5      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist);Fi[	@F
i^I"?      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@F
iqI"/      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@F
i~I"7      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist);Fi[	@F
ièI"/      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist);Fi[	@F
i†I"7      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@F
i¬I"/      #
      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist);Fi[@û=I"# @since 3.0.0;FI"def function(arglist);FI"@var = var;Fi[[	@ãi,I"∑      # @param [ Integer ] value The limit.
      #
      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      ;Fi[	@ãiHI"µ      # @param [ Integer ] value The skip.
      #
      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      ;Fi[	@ùieI"Œ    # @param [ Array<Document> ] docs The embedded documents.
    #
    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    ;Fi[	@ùiI"Ω    # @param [ Array<Metadata> ] The inclusions.
    #
    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    ;Fi[	@ó	iTI"C      # @option options [ Class ] :type The class of the field.
      # @option options [ Object ] :default The default value for the field.
      # @option options [ String ] :label The field's label.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
        @var = var
        @var = var[:label];Fi[	@∆iI"™    # @param [ Logger ] The logger to set.
    #
    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    ;Fi[	@hióI"œ        # @param [ true, false ] value The flag.
        #
        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        ;Fi[	@hiŒI"≈        # @param [ String ] value The path.
        #
        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        ;Fi[I"@var = @var;F@[H@›LI"end;Fi[[	@Li¡I"ﬂ        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@LiﬂI"›        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@OiºI"ﬂ        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@OiÁI"›        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@Ri∞I"ﬂ        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@RiŒI"›        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[	@UiòI"ﬂ        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next;Fi[	@UiπI"›        var = var
        var = 0
        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else;Fi[@µ @°+I"@var = [];FI"end;Fi[[	@}iI"ü      include(Enumerable)
      
      attr_reader(:duration)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist);Fi[	@ñiI"£      
      class Builder
        attr_reader(:rows)
        
        def function(arglist)
          @var = []
        end
        
        def function(arglist);Fi[	@∏i™I"©        @var.puts(format_string(var, :tag).indent(@var))
        @var.flush
      end
      
      def function(arglist)
        @var = []
      end
      
      private;Fi[	@«iDI"√        @var.td(:class => "message") { |arglist| (@var << @var.join(", ")) }
        empty_messages
      end
      
      def function(arglist)
        @var = []
      end
      
      protected;Fi[	@i
I"π  module PySupport
    class PyLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist);Fi[	@ViI"Ω  module WireSupport
    class WireLanguage
      include(LanguageSupport::LanguageMethods)
      
      def function(arglist)
        @var = []
      end
      
      def function(arglist);Fi[	@èiI"  attr_accessor(:prompt)
  
  attr_accessor(:entries)
  
  def function(arglist)
    @var = []
  end
  
  def function(arglist);Fi[	@û;iI"à    end
    
    attr_reader(:registered_handlers)
    
    def function(arglist)
      @var = []
    end
    
    def function(arglist);Fi[@µ I"##;F@M@Mi[[	@†i8I"          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@•iZI"          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@™iDI"          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@±i#I"<          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@∂i@I"          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@æi;I"          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@√i8I"          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[	@»i6I"          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist);Fi[I""";FI"end;FI"end;FI" ;Fi[[	@‰iI"9        if top_level.line_comments then
          "# To disable debugging comments that display the original location of your selectors. Uncomment:\n# line_comments = false\n"
        else
          ""
        end
      end
      
      def function(arglist)
        if top_level.output_style_without_default then;Fi[	@íi9I"˚      if Compass.configuration.color_output and (var and COLORS.has_key?(var.to_sym)) then
        defined? $boring and $boring ? ("") : ("[#{COLORS[c.to_sym]}m")
      else
        ""
      end
    end
    
    def function(arglist)
      print(var);Fi[	@i5I"{      end
      
      def function(arglist)
        ""
      end
    end
    
    class JsHook
      def function(arglist);Fi[	@™iI"ì            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format];Fi[	@™i7I"ª            # do nothing
          end
        else
          ""
        end
      end
      
      def function(arglist)
        while @var.any? and var.is_descendant_of?(@var.last).! do;Fi[	@™itI"¨            # do nothing
          end
        else
          ""
        end
      end
      
      if Object.const_defined?(:Magick) then
        # Generates a gantt image;Fi[	@ãiI"Ü        when NilClass then
          ">> /dev/null 2>&1"
        else
          ""
        end
      end
      
      protected
      ;Fi[	@ãi7I"°        when stdout then
          ">> #{stdout}"
        else
          ""
        end
      end
      
      def function(arglist)
        ">> #{@output} 2>&1";Fi[@µ @°+I"@var.empty?;FI"end;Fi[[	@öi9I"ê        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end
    
    ##;Fi[	@îiOI"§          var.each { |arglist| var[var] = var }
          var
        end
        
        def function(arglist)
          @var.empty?
        end
      end
    end;Fi[	@úi8I"é      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist);Fi[	@ìi-I"´        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist);Fi[	@=ieI"         load_programming_language("rb") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist);Fi[	@0iI"y    @var = var
    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  
  attr_reader :function;Fi[	@Äi™I"í  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist);Fi[	@™iI"}  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist);Fi[@û=@ïM@ñM@óMi[[	@PiI"®      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "must be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AbsenceValidator, _merge_attributes(var));Fi[	@Si1I"Ï      #   an HTML checkbox. This should be set to +true+ if you are validating
      #   a database column, since the attribute is typecast from "1" to +true+
      #   before validation.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(AcceptanceValidator, _merge_attributes(var));Fi[	@\i3I"º      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "doesn't match
      #   confirmation").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ConfirmationValidator, _merge_attributes(var));Fi[	@_i+I"„      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to true, skips this validation if the
      #   attribute is blank(default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(ExclusionValidator, _merge_attributes(var));Fi[	@bilI"       # * <tt>:multiline</tt> - Set to true if your regular expression contains
      #   anchors that match the beginning or end of lines as opposed to the
      #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(FormatValidator, _merge_attributes(var));Fi[	@gi*I"Ê      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(InclusionValidator, _merge_attributes(var));Fi[	@ûimI"¸      #   (e.g. <tt>tokenizer: ->(str) { str.scan(/\w+/) }</tt> to count words
      #   as in above example). Defaults to <tt>->(value) { value.split(//) }</tt>
      #   which counts individual characters.
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(LengthValidator, _merge_attributes(var));Fi[	@mi I"™      #
      # Configuration options:
      # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
      #
      # There is also a list of default options supported by every validator:
      # +:if+, +:unless+, +:on+ and +:strict+.
      # See <tt>ActiveModel::Validation#validates</tt> for more information
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var));Fi[@û=I"#   class BlogPost;F@≥LI"#   end;Fi[[	@iI"    #
    # Equivalent to <tt>String#==</tt>. Returns +true+ if the class name and
    # +other+ are equal, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name == 'BlogPost'  # => true;Fi[	@i'I"ƒ    #   ===(other)
    #
    # Equivalent to <tt>#==</tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name === 'BlogPost'  # => true;Fi[	@i5I"«    #   ==(other)
    #
    # Equivalent to <tt>String#<=></tt>.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name <=> 'BlogPost'  # => 0;Fi[	@iFI".    # Equivalent to <tt>String#=~</tt>. Match the class name against the given
    # regexp. Returns the position where the match starts or +nil+ if there is
    # no match.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name =~ /Post/ # => 4;Fi[	@iUI"    #
    # Equivalent to <tt>String#!~</tt>. Match the class name against the given
    # regexp. Returns +true+ if there is no match, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name !~ /Post/ # => false;Fi[	@idI"#    #
    # Equivalent to <tt>String#eql?</tt>. Returns +true+ if the class name and
    # +other+ have the same length and content, otherwise +false+.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.eql?('BlogPost')  # => true;Fi[	@irI"∑    #   to_s()
    #
    # Returns the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.to_s # => "BlogPost";Fi[	@iöI"    
    # Transform the model name into a more humane format, using I18n. By default,
    # it will underscore then humanize the class name.
    #
    #   class BlogPost
    #     extend ActiveModel::Naming
    #   end
    #
    #   BlogPost.model_name.human # => "Blog post";Fi[@'@¸@ˇ,I"@var.empty?;Fi[[	@öi8I"ß      rescue Exception => var
        raise(Errors::Pipeline::ExecutionError.wrap(var))
      end
    end
    
    def function(arglist)
      @var.empty?
    end
    ;Fi[	@îiNI"Õ          self.each { |arglist| var[var] = var }
          var.each { |arglist| var[var] = var }
          var
        end
        
        def function(arglist)
          @var.empty?
        end
      end;Fi[	@úi7I"é    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/
      $2
    end
    
    def function(arglist)
      @var.empty?
    end
    ;Fi[	@ìi,I"´      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)]
      end
      
      def function(arglist)
        @var.empty?
      end
      ;Fi[	@=idI"       def function(arglist)
        load_programming_language("rb") if unknown_programming_language?
        @var.map { |arglist| var.snippet_text(var, var, var) }.join("\n")
      end
      
      def function(arglist)
        @var.empty?
      end
      ;Fi[	@0iI"y  def function(arglist)
    @var = var
    @var = var.to_s
  end
  
  def function(arglist)
    @var.empty?
  end
  ;Fi[	@Äi©I"}  
  def function(arglist)
    any? { |arglist| (var.name == var) }
  end
  
  def function(arglist)
    @var.empty?
  end
  ;Fi[	@™iI"m  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end
  ;Fi[@'@¸I"##;F@Mi[[	@†i7I"A            connection.put_object(container, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@•iYI"4            connection.put_file(File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@™iCI"?            var.put(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@±i"I"D          var = File.join(var, var)
          FileUtils.send(transfer_method, var, var)
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@∂i?I"6            var.files.create(:key => (var), :body => (var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@æi:I">            connection.put_object(bucket, File.join(var, var), var)
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@√i7I"G            var.scp.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[	@»i5I"C            var.upload!(File.join(local_path, var), File.join(var, var))
          end
        end
      end
      
      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.;Fi[I"module ClassMethods;F@»LI"#;FI"&# @example Demongoize the object.;Fi[[	@.	i!I"Ë        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Object.demongoize(object)
        #;Fi[	@8	i!I"˜        ::Date.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Date.demongoize(object)
        #;Fi[	@?	i'I"ˇ        ::DateTime.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   DateTime.demongoize(object)
        #;Fi[	@d	i-I"˚        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Range.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@n	iI"	        ::Set.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Set.demongoize({ "min" => 1, "max" => 5 })
        #;Fi[	@s	i§I"Á        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   String.demongoize(object)
        #;Fi[	@x	iI"Ù        to_s.mongoid_id?
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   Symbol.demongoize(object)
        #;Fi[	@Ñ	iI"        ::ActiveSupport::TimeWithZone.mongoize(self)
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #
        # @example Demongoize the object.
        #   TimeWithZone.demongoize(object)
        #;Fi[@'@¸@ˇ,I"return if var.nil?;Fi[[	@ViI"Î        class Date < Type
          def function(arglist)
            :date
          end
          
          def function(arglist)
            return if var.nil?
            ConnectionAdapters::Column.value_to_date(var)
          end;Fi[	@ViI"Ù        class DateTime < Type
          def function(arglist)
            :datetime
          end
          
          def function(arglist)
            return if var.nil?
            ConnectionAdapters::Column.string_to_time(var)
          end;Fi[	@ViI"Ú        class Time < Type
          def function(arglist)
            :time
          end
          
          def function(arglist)
            return if var.nil?
            ConnectionAdapters::Column.string_to_dummy_time(var)
          end;Fi[	@Vi"I"»        class Float < Type
          def function(arglist)
            :float
          end
          
          def function(arglist)
            return if var.nil?
            var.to_f
          end;Fi[	@ricI"         class Timestamp < Type
          def function(arglist)
            :timestamp
          end
          
          def function(arglist)
            return if var.nil?
            ConnectionAdapters::PostgreSQLColumn.string_to_time(var)
          end;Fi[	@rinI"Ô        class Date < Type
          def function(arglist)
            :datetime
          end
          
          def function(arglist)
            return if var.nil?
            ConnectionAdapters::Column.value_to_date(var)
          end;Fi[	@˙iI"¸      
      def function(arglist)
        Data.new("defaults").extend(Defaults).extend(Comments)
      end
      
      def function(arglist)
        return if var.nil?
        var = configuration_for(var, var)
        var.inherit_from!(configuration);Fi[	@ÎiI"Ô      
      def function(arglist)
        (s3_protocol(var) == "https")
      end
      
      def function(arglist)
        return if var.nil?
        var = var.call(instance) if var.respond_to?(:call)
        var.inject({}) do |arglist|;Fi[I"#homepage("http://example.com");FI" ;FI",url("file:///foo.com/testball-0.1.tbz");FI" ;Fi[[	I")data//homebrew_proj/test/testball.rb;TicI"’  fails_with(:clang) { |arglist| cause("failure") }
end
class SpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  mirror("file:///foo.org/testball-0.1.tbz")
  ;Fi[	@ÒNiíI"∂  end
end
class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[	@ÒNi¢I"∫  end
end
class AncientBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[	@ÒNiﬂI"æ  end
end
class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[	@ÒNiÓI"∑  end
end
class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[	@ÒNi˝I"∫  end
end
class AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[	@ÒNiI"∫  end
end
class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[	@ÒNi"I"⁄class CustomVersionScheme < Version
end
class CustomVersionSchemeTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[@'@¸@ˇ,I"return unless @var;Fi[[	@~i8I"      
      def function(arglist)
        @var ||= self.class.to_s.sub("Backup::Errors::", "")
      end
      
      def function(arglist)
        return unless @var
        @var ||= @var.is_a?(Errors::Error) ? (@var.send(:class_name)) : (@var.class.to_s)
      end;Fi[	@~i=I"L      def function(arglist)
        return unless @var
        @var ||= @var.is_a?(Errors::Error) ? (@var.send(:class_name)) : (@var.class.to_s)
      end
      
      def function(arglist)
        return unless @var
        return @var unless @var.nil?
        var = @var.is_a?(Errors::Error) ? (@var.send(:orig_msg)) : (@var.to_s);Fi[	@îi=I"ÿ        
        def function(arglist)
          self.map { |arglist| var }
        end
        
        def function(arglist)
          return unless @var
          yield([@var.key, @var.value])
          var = @var;Fi[	@ﬁi\I"°      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
        @var = Time.now
      end;Fi[	@ÊiºI"Û        if var.exception and @var.include?(var.exception).! then
          print_exception(var.exception, var.status, @var)
        end
      end
      
      def function(arglist)
        return unless @var
        @var = (@var + 1)
      end;Fi[	@Èi7I"«      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return unless @var
        var ||= @var
        progress(var) unless table_header_cell?(var);Fi[	@Ïi?I"ê      
      def function(arglist)
        @var = false
      end
      
      def function(arglist)
        return unless @var
      end
      ;Fi[	@Öi{I"¬          return parse_as_string
        end
        var.join(" ")
      end
      
      def function(arglist)
        return unless @var
        var = @var.to_s
        var = Array.new(4, "*");Fi[@¡KI"#       end;FI"#     end;FI"#   end;Fi[[	@â i I"Œ    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine(:state).events;Fi[	@â iEI"∆    #       end
    #       
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   events = Vehicle.state_machine.events;Fi[	@â ieI"2    #   class Vehicle < ActiveRecord::Base
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">;Fi[	@§iI"˜        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@§iZI"˜        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@§i~I"˜        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver;Fi[	@„iÊI"     #   class Vehicle
    #     state_machine do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new;Fi[	@„iˇI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">;Fi[@ÌNI" ;FI"5sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5");FI" ;Fi[[	@ÒNiîI"¯class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    url("file:///foo.com/testball-0.1-bottle.tar.gz");Fi[	@ÒNi§I"Íclass AncientBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle("file:///foo.com/testball-0.1-bottle.tar.gz")
  ;Fi[	@ÒNi·I"class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[	@ÒNiI"class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :lion);Fi[	@ÒNiˇI"class AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[	@ÒNiI"’class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    version(1);Fi[	@ÒNi$I"ﬂclass CustomVersionSchemeTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  version("1.0" => (CustomVersionScheme))
  ;Fi[@	)I"[];FI"end;FI" ;Fi[[	@B)iI"s      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0;Fi[	@iieI"2      # Override this method, as there are situations where the background
      # wind up being the one called fore Before scenarios, and
      # backgrounds don't have tags.
      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name };Fi[	@äiI"§          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var);Fi[	@ÿ#iBI"[    ""
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    [];Fi[	@ÿ#iFI"ë    []
  end
  
  def function(arglist)
    []
  end
  
  def self.excluding_blocks(arglist)
    var = var.blocks.map { |arglist| var.person_id };Fi[	@iI"û        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?;Fi[	@°iI"        end
        
        # The list of ancestor names that cause this integration to matched.
        def function(arglist)
          []
        end
        
        # Whether the integration should be used for the given class.
        def function(arglist);Fi[I"2require("capistrano/recipes/deploy/scm/base");FI"module Capistrano;FI"module Deploy;FI"module SCM;Fi[[	@[i I"îrequire("capistrano/recipes/deploy/scm/base")
module Capistrano
  module Deploy
    module SCM
      class Bzr < Base
        default_command("bzr");Fi [	@`i I"îrequire("capistrano/recipes/deploy/scm/base")
module Capistrano
  module Deploy
    module SCM
      class Cvs < Base
        default_command("cvs");Fi [	@ei I"òrequire("capistrano/recipes/deploy/scm/base")
module Capistrano
  module Deploy
    module SCM
      class Darcs < Base
        default_command("darcs");Fi [	@li I"îrequire("capistrano/recipes/deploy/scm/base")
module Capistrano
  module Deploy
    module SCM
      class Git < Base
        default_command("git");Fi [	@qi I"ôrequire("capistrano/recipes/deploy/scm/base")
module Capistrano
  module Deploy
    module SCM
      class Mercurial < Base
        default_command("hg");Fi [	@vi I"∏require("capistrano/recipes/deploy/scm/base")
module Capistrano
  module Deploy
    module SCM
      class None < Base
        # No versioning, thus, no head. Returns the empty string.;Fi [	@{i I"òrequire("capistrano/recipes/deploy/scm/base")
module Capistrano
  module Deploy
    module SCM
      class Perforce < Base
        default_command("p4");Fi [I"var.puts(var);FI"var.puts("---");FI"var.puts(var);FI"end;Fi[[	@Ìi&I"6          (var.nil? or (var == ""))
        end.to_yaml
        File.open("#{dir}/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
        if var then
          var = var["SELECT dst FROM #{prefix}url_alias WHERE src = ?", "node/#{node_id}"].all;Fi[	@˚iI"’          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@ i#I"’          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@iI"’          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@
i2I"ı            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end
        var = (var + 1);Fi[	@iI"’          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end;Fi[	@i`I"¬        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end
    ;Fi[@'@¸@ˇ,I"var;Fi[[	@FiI"Å      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      ;Fi[	@Ii2I"ß      
      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      ;Fi[	@ViÍI"Æ        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[	@riI"Æ        class Type
          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end;Fi[	@\i+I"˘          def function(arglist)
            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end
          ;Fi[	@˚#iI"l    
    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    ;Fi[	@˚#iI"l    
    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end
  end;Fi[@'@¸@ˇ,I"return if @var.empty?;Fi[[	@∏iùI"      def function(arglist)
        @var.each { |arglist| print_message(var) }
        empty_messages
      end
      
      def function(arglist)
        return if @var.empty?
        @var.print(format_string(@var.join(", "), :tag).indent(2))
        @var.flush;Fi[	@«i5I"Í      
      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if @var.empty?
        @var.each do |arglist|
          @var.li(:class => "step message") { |arglist| (@var << var) };Fi[	@«i=I"          @var.li(:class => "step message") { |arglist| (@var << var) }
        end
        empty_messages
      end
      
      def function(arglist)
        return if @var.empty?
        @var.td(:class => "message") { |arglist| (@var << @var.join(", ")) }
        empty_messages;Fi[	@<i6I"ß    
    def function(arglist)
      push_merged_text("#{text}\n", var)
    end
    
    def function(arglist)
      return if @var.empty?
      var = ""
      var = 0;Fi[	@tiwI"Û      
      def function(arglist)
        @var.backtrace_tweaker
      end
      
      def function(arglist)
        return if @var.empty?
        @var.inject(1) do |arglist|
          formatters.each { |arglist| var.dump_failure(var, var) };Fi[	@àiMI"‘          @var[var] = var
        end
      end
    end
    
    def function(arglist)
      return if @var.empty?
      var = []
      @var.each { |arglist| (var << "#{key}=#{val.blank? ? ("\"\"") : (val)}\n") };Fi[	@àinI"†        end
      end
      var.map { |arglist| var.join(" ") }
    end
    
    def function(arglist)
      return if @var.empty?
      var = []
      var = [];Fi[@û=@ıFI"0#     include ActiveModel::AttributeMethods;FI"#;Fi[[	@˝i#I"       #
      # An instance method <tt>#{prefix}attribute</tt> must exist and accept
      # at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_prefix 'clear_';Fi[	@˝iGI"!      #
      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[	@˝ikI"H      #
      # An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and
      # accept at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!';Fi[	@˝iÅI"Í      end
      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[	@˝ißI"Å      # To use, pass attribute names (as strings or symbols), be sure to declare
      # +define_attribute_methods+ after you define any prefix, suffix or affix
      # methods, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name, :age, :address
      #     attribute_method_prefix 'clear_';Fi[	@˝i√I"p      # To use, pass an attribute name (as string or symbol), be sure to declare
      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[	@˝iÍI"      end
      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?';Fi[I"# @since 3.0.0;F@˛MI"@var = var;FI"end;Fi[[	@ãi-I"™      #
      # @return [ Integer ] The limit.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Get the skiping value.;Fi[	@ãiII"™      #
      # @return [ Integer ] The skip.
      #
      # @since 3.0.0
      def function(arglist)
        @var = var
      end
      
      # Apply criteria options.;Fi[	@ùifI"æ    #
    # @return [ Array<Document> ] The embedded documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Is the criteria for embedded documents?;Fi[	@ùiÒI"Ÿ    #
    # @return [ Array<Metadata> ] The new inclusions.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    # Merges another object with this +Criteria+ and returns a new criteria.;Fi[	@∆i I"ã    #
    # @return [ Logger ] The new logger.
    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private;Fi[	@hiòI"Î        #
        # @return [ true, false ] The flag.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Normalize the documents, in case they were provided as an array of;Fi[	@hiœI"Á        #
        # @return [ String ] The path.
        #
        # @since 3.0.0
        def function(arglist)
          @var = var
        end
        
        # Get the selector for executing atomic operations on the collection.;Fi[@¨O@˛MI"	self;FI"end;Fi[[	@ùiII"ó    #
    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    
    # Convert the criteria to a proc.;Fi[	@Z	iI"ª      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__);Fi[	@Z	iI"¨      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Mongoize a plain object into a time.;Fi[	@Z	i)I"Æ      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Try to form a setter from this object.;Fi[	@Z	iAI"∂      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Conversion of an object to an $inc-able value.;Fi[	@Z	iÉI"ß      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      # Is the object multi args.;Fi[	@_	iI"       #
      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      
      (alias :__mongoize_object_id__ :__evolve_object_id__);Fi[I"assert(var.ppc7400?.!);FI"assert(var.ppc64?.!);FI"assert(var.dylib?.!);FI"%assert(var.mach_o_executable?.!);Fi[[	I"*data//homebrew_proj/test/test_mach.rb;TiGI"     assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@◊OiUI"     assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@◊OicI"     assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?);Fi[	@◊OiqI"    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@◊OiêI"    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@◊Oi†I"    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?)
    assert_equal([], var.archs);Fi[	@◊Oi∞I"    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs);Fi[@'@¸@ˇ,I""with_temp_folder do |arglist|;Fi[[	@—iI"    assert_raises(RuntimeError) do |arglist|
      Pathname.getwd.install("non_existant_file")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt")
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.");Fi[	@—i"I"Q      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(["a.txt", "b.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.");Fi[	@—i*I"I      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install(Dir["*.txt"])
      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.");Fi[	@—i2I"      assert((TARGET_FOLDER + "a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("bin")
      system("mv *.txt bin");Fi[	@—i<I"W      assert((TARGET_FOLDER + "bin/a.txt").exist?, "a.txt not installed.")
      assert((TARGET_FOLDER + "bin/b.txt").exist?, "b.txt not installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt" => "c.txt")
      assert((TARGET_FOLDER + "c.txt").exist?, "c.txt not installed.");Fi[	@—iEI"w      assert((TARGET_FOLDER + "a.txt").exist?.!, "a.txt was installed but not renamed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      TARGET_FOLDER.install("a.txt" => "c.txt", "b.txt" => "d.txt")
      assert((TARGET_FOLDER + "c.txt").exist?, "c.txt not installed.");Fi[	@—iOI"8      assert((TARGET_FOLDER + "a.txt").exist?.!, "a.txt was installed but not renamed.")
      assert((TARGET_FOLDER + "b.txt").exist?.!, "b.txt was installed but not renamed.")
    end
  end
  
  def function(arglist)
    with_temp_folder do |arglist|
      FileUtils.mkdir_p("bin")
      system("mv *.txt bin");Fi[I"C# config<Hash>:: give :verbose => false to not log the status.;FI"#;FI"# ==== Example;FI"#;Fi[[	@Çi|I"˘    # ==== Parameters
    # mode<Integer>:: the file mode
    # path<String>:: the name of the file to change mode
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Example
    #
    #   chmod "script/*", 0755
    #;Fi[	@ÇiâI"Q    # ==== Parameters
    # path<String>:: path of the file to be changed
    # data<String>:: the data to prepend to the file, can be also given as a block.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Example
    #
    #   prepend_to_file 'config/environments/test.rb', 'config.gem "rspec"'
    #;Fi[	@Çi†I"O    # ==== Parameters
    # path<String>:: path of the file to be changed
    # data<String>:: the data to append to the file, can be also given as a block.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Example
    #
    #   append_to_file 'config/environments/test.rb', 'config.gem "rspec"'
    #;Fi[	@ÇiœI"ï    # path<String>:: path of the file to be changed
    # flag<Regexp|String>:: the regexp or string to be replaced
    # replacement<String>:: the replacement, can be also given as a block
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Example
    #
    #   gsub_file 'app/controllers/application_controller.rb', /#\s*(filter_parameter_logging :password)/, '\1'
    #;Fi[	@ÇiÏI"Z    # ==== Parameters
    # path<String>:: path of the file to be changed
    # flag<Regexp|String>:: the regexp or string used to decide which lines to uncomment
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Example
    #
    #   uncomment_lines 'config/initializers/session_store.rb', /active_record/
    #;Fi[	@Çi˛I"U    # ==== Parameters
    # path<String>:: path of the file to be changed
    # flag<Regexp|String>:: the regexp or string used to decide which lines to comment
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Example
    #
    #   comment_lines 'config/initializers/session_store.rb', /cookie_store/
    #;Fi[	@ÇiI"    #
    # ==== Parameters
    # path<String>:: path of the file to be changed
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Example
    #
    #   remove_file 'README'
    #   remove_file 'app/controllers/application_controller.rb';Fi[@'@¸@ˇ,I"@var ||= {};Fi[[	@XiI"∫        # Used only within the specs
        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        ;Fi[	@i{I"“          inherit_from!(var)
          yield
          reset_inheritance!
        end
        
        def function(arglist)
          @var ||= {}
          send("#{attribute}=", nil)
          @var.delete(var);Fi[	@i}I"∂          send("#{attribute}=", nil)
          @var.delete(var)
          nil
        end
        
        def function(arglist)
          @var ||= {}
          @var[var]
        end;Fi[	@
iMI"à      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      ;Fi[	@;i6I"%          var.const_missing(var)
        end
      end
    end
    
    def function(arglist)
      @var ||= {}
      var = (var or Attachment.default_options[:path])
      if @var[var] and ((@var[var][:path] == var) and (@var[var][:class].!=(var) and (not @var[var][:path] =~ /:class/))) then;Fi[	@ iíI"˘          var = ::I18n.load_path.select { |arglist| (File.basename(var, ".*") == var) }
          load_translations(var)
          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        ;Fi[	@”iI"¶        @var = (var[:__declared_as] or "Mock")
        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      ;Fi[@¨O@˛MI"	true;FI"end;Fi[[	@)	ixI"ó      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@)	i¢I"ñ        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[	@G	iI"û      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[	@L	i}I"…      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Convert this hash to a criteria. Will iterate over each keys in the;Fi[	@L	iøI"ñ        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end
    end;Fi[	@Q	iI"Ã      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      # Is the object not to be converted to bson on criteria creation?;Fi[	@d	i(I"ó      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods;Fi[I"assert(var.x86_64?.!);F@—O@“O@”Oi[[	@◊Oi8I"    var = Pathname.new("#{TEST_FOLDER}/mach/a.out")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?)
    assert(var.text_executable?.!);Fi[	@◊OiFI"    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@◊OiTI"    var = Pathname.new("#{TEST_FOLDER}/mach/i386.bundle")
    assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@◊OipI"&    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[	@◊OièI"¸    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@◊OiüI"    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?);Fi[	@◊OiØI"¯    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!);Fi[I"assert(var.i386?.!);F@.P@—O@“Oi[[	@◊OiI"  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.dylib")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!);Fi[	@◊Oi7I"  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/a.out")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?);Fi[	@◊OiEI"  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@◊OioI"  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@◊OiéI"    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@◊OiûI"    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[	@◊OiÆI"     var = (HOMEBREW_PREFIX / "foo_script")
    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!);Fi[@$D@%DI"end;FI" ;Fi[[	@†iQI"ê          if target.persisted? and (owner.persisted? and target.save.!) then
            set_owner_attributes(target)
            raise(RecordNotSaved, ("Failed to remove the existing associated #{reflection.name}. " + "The record failed to save after its foreign key was set to nil."))
          end)
        end
      end
      
      def function(arglist)
        var[reflection.foreign_key] = nil;Fi[	@i I"ò            end
          else
            var.number? ? (var.zero?.!) : (var.blank?.!)
          end)
        end
      end
      
      private
      ;Fi[	@çipI"ú        exec_query("PRAGMA index_list(#{quote_table_name(table_name)})", "SCHEMA").map do |arglist|
          IndexDefinition.new(var, var["name"], var["unique"].!=(0), exec_query("PRAGMA index_info('#{row["name"]}')", "SCHEMA").map do |arglist|
            var["name"]
          end)
        end
      end
      
      def function(arglist)
        var = table_structure(var).find { |arglist| (var["pk"] == 1) };Fi[	@ iGI"„      var.any? do |arglist|
        (var or specs_changed?(var) do |arglist|
          var.class.===(var.class) and (var.uri == var.uri)
        end)
      end
    end
    
    def function(arglist)
      @var.any? do |arglist|;Fi[	@?iíI"6        var.reject! { |arglist| var.version.prerelease? } unless (var or var)
        var.sort_by do |arglist|
          [var.version, (var.platform.to_s == "ruby") ? ("\x00") : (var.platform.to_s)]
        end)
      end
    end
    
    def function(arglist)
      specs_by_name(var.name).select do |arglist|;Fi[	@%i.I"ì          end
        else
          var = []
        end)
      end
    end
    
    def function(arglist)
      if var.to_s.include?(">= 0") then;Fi[	@Gi@I"            if @var.any?(&:repeat_x?) then
              calculate_repeat_extra_width!
              tile_images_that_repeat
            end)
          end
        end
        
        def function(arglist)
          @var.map { |arglist| var if var.repeat_x? }.compact.each do |arglist|;Fi[@	)I"@var ||= false;FI"end;FI" ;Fi[[	@i&I"å        end
      end
      
      def function(arglist)
        @var ||= false
      end
      
      # :nodoc:
      def function(arglist);Fi[	@s	iåI"µ      # @return [ true, false ] If the object is unconvertable.
      #
      # @since 2.2.1
      def function(arglist)
        @var ||= false
      end
      
      private
      ;Fi[	I",data//mongoid_proj/lib/mongoid/state.rb;TiI"
    #   person.new_record?
    #
    # @return [ true, false ] True if new, false if not.
    def function(arglist)
      @var ||= false
    end
    
    # Checks if the document has been saved to the database. Returns false
    # if the document has been destroyed.;Fi[	@kPi)I"Œ    # @return [ true, false ] If the document is flagged.
    #
    # @since 2.3.2
    def function(arglist)
      @var ||= false
    end
    
    (alias :marked_for_destruction? :flagged_for_destroy?)
    ;Fi[	@kPi7I"¡    #   person.destroyed?
    #
    # @return [ true, false ] True if destroyed, false if not.
    def function(arglist)
      @var ||= false
    end
    
    (alias :deleted? :destroyed?)
    ;Fi[	@˜iãI"    # @return [ true, false ] Is the document not currently versioning.
    #
    # @since 2.0.0
    def function(arglist)
      @var ||= false
    end
    
    # Filters fields that should not be versioned out of an attributes hash.
    # Dynamic attributes are always versioned.;Fi[	@i•I"}        @var = true
      end
      
      def function(arglist)
        @var ||= false
      end
      
      private
      ;Fi[@–0@—0@©AI" ;Fi[[	@ÀiEI"‹      # See +ActiveRecord::Inheritance#discriminate_class_for_record+ for
      # the single-table inheritance discriminator.
      def function(arglist)
        self
      end
    end
    
    attr_reader :function
    ;Fi[	@Ûi•I"      else
        references!(PredicateBuilder.references(var)) if Hash.===(var)
        self.where_values += build_where(var, var)
        self
      end
    end
    
    # Allows to specify a HAVING clause. Note that you can't use HAVING
    # without also specifying a GROUP clause.;Fi[	@ŸiÔI"†        var.default_scoped = false
        var
      else
        self
      end
    end
    
    # Returns true if relation is blank.
    def function(arglist);Ti[	@éi=I"Ω        else
          @var = criteria.order_by(var)
          apply_option(:sort)
          self
        end
      end
      
      # Update the first matching document atomically.
      #;Fi[	@s	i†I"        if Moped::BSON::ObjectId.legal?(self) then
          Moped::BSON::ObjectId.from_string(self)
        else
          self
        end
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.;Fi[	@∏iHI"=      
      def function(arglist)
        ActiveSupport::Deprecation.warn("Paginator#current will be removed. Use .offset instead of .current.offset.")
        self
      end
    end
    
    # Paginates the given scope or model. Returns a Paginator instance and
    # the collection of objects for the current page.;Fi[	@Èi“I"Ω      
      def function(arglist)
        class << @var
          self
        end
      end
      
      def function(arglist)
        @var.each { |arglist| var.verify_messages_received };Fi[@	)I"	to_s;FI"end;FI" ;Fi[[	@!iI"ä      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var);Fi[	@$iI"“      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    
    def self.color_to_s(arglist)
      var.is_a?(Sass::Script::String) ? (var.value.dup) : (var.inspect.dup);Fi[	@$i:I"á      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var);Fi[	@ºi&I"ç      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "#{name}(#{args.join(", ")})";Fi[	@.	iI"‰      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        to_s
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.;Fi[	I"1data//mongoid_proj/lib/mongoid/extensions.rb;TiI"Øclass Moped::BSON::ObjectId
  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist)
    ActiveSupport::XmlMini.to_tag(var[:root], self.to_s, var);Fi[	@3iRI"˛    end
    
    # Same as to_s
    def function(arglist)
      to_s
    end
    
    # Returns the scaling and cropping geometries (in string-based ImageMagick format)
    # neccessary to transform this Geometry into the Geometry given. If crop is true,;Fi[@»J@…JI"7# @param [ Symbol ] name The name of the relation.;FI"4# @param [ Hash ] options The relation options.;Fi[[	@oi/I"V        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@oiMI"V        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@oiiI"S        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@oiÄI"O        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@oiôI"R        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[	@oiµI"Q        #   class Preference
        #     include Mongoid::Document
        #     has_and_belongs_to_many :people
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        #;Fi[	@oi”I"O        #   class Person
        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist);Fi[@'@¸@ˇ,I"var = @var;Fi[[	@êiuI"¶      
      def function(arglist)
        "<#{s}>"
      end
      
      def function(arglist)
        var = @var
        var.each do |arglist|
          var ||= "";Fi[	@Vi,I"Ô      def function(arglist)
        @var.each { |arglist| var.begin_scenario(var) }
        @var = var
      end
      
      def function(arglist)
        var = @var
        @var.each { |arglist| var.end_scenario(var) }
        @var = nil;Fi[	@Îi∫I",        var = (@var[var] or @var[:default])
        var = var.call(self, var) if var.respond_to?(:call)
        var
      end
      
      def function(arglist)
        var = @var
        var = var.call(var, self) if var.respond_to?(:call)
        var and var.empty?.! ? ("#{protocol}:") : (var.to_s);Fi[	@LiVI"ì    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[	@OiKI"ì    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[	@RiEI"ì    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"];Fi[	@Ui?I"Ø    out(sprintf("/MediaBox [0 0 %.2f %.2f]", var, var))
    out(">>")
    out("endobj")
  end
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[@;@;I"end;FI" ;Fi[[	@QiTI"—        super
        unless @var.nil? then
          @var.close
          @var = nil
        end
      end
      
      # DATABASE STATEMENTS ======================================
      def function(arglist);Fi[	@
ixI"Ï          yield if block_given?
          return @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      source(Source::Path.new(_normalize_hash(var).merge("path" => (Pathname.new(var)))), var, &var);Fi[	@3iI"Ù      Gem::Version.send(:define_method, :yaml_initialize) do |arglist|
        @var = var["version"]
        @var = nil
        @var = nil
      end
    end
    
    # This backports base_dir which replaces installation path
    # Rubygems 1.8+;Fi[	@{i8I"í        yield
        @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist)
      @var = Framework.new(var, *var);Fi[	@iyI"Œ          (@var = var
          yield)
        ensure
          @var = nil
        end
      end
      
      # parses a manifest file which is a ruby script
      # evaluated in a Manifest instance context;Fi[	@£iºI"x  def function(arglist)
    if @var then
      errors.add(:birthday)
      @var = nil
    end
  end
  
  private
  ;Fi[	@/iI"›          if @var then
            @var.puts(@var.description.gsub(/ \(druby.*\)/, ""))
            @var.flush
            @var = nil
          end
        end
        
        def function(arglist)
          # do nothing;Fi[@'I"	var);FI"end;FI" ;Fi[[	@xi3I"%        var = Hash[var.map { |arglist| [clean_identifier(var), var] }]
        if var.keys.count.!=(var.keys.count) then
          Logger.warn("Duplicate public key identifiers were detected in #keys.")
        end
        var)
      end
      
      ##
      # Cleans a public key identifier.;Fi[	@“ihI"?            @var ||= (var = {}
            local_hashes.lines.map { |arglist| LocalFile.new(@var, var) }.compact.each do |arglist|
              var.merge!(var.relative_path => (var))
            end
            var)
          end
          
          ##
          # Returns a String of file paths and their md5 hashes.;Fi[	@“i{I"7            @var ||= (var = {}
            @var.files.all(:prefix => (@var)).each do |arglist|
              var.merge!(var.key.sub("#{@remote_base}/", "") => (var))
            end
            var)
          end
          
          ##
          # Performs a sync operation on a file. When mirroring is enabled;Fi[	@ idI"         var = Bundler.settings[:frozen] ? (rubygems_index) : (index)
        var = var.search(Gem::Dependency.new("bundler", VERSION)).last
        var["bundler"] = var if var
      end
      var)
    end
    
    def function(arglist)
      (specs - @var);Fi[	@_i®I"◊            var.loaded_from = File.expand_path("..", "(string)")
          end
          (var << var)
        end
        var)
      end
      
      def function(arglist)
        @var ||= (var = installed_specs.dup;Fi[	@8iHI"ö          @var ||= (var = (get_var_file("repeat") or (options.get_var("repeat") or Sass::Script::String.new(NO_REPEAT))).value
          unless VALID_REPEATS.include?(var) then
            raise(SpriteException, "Invalid option for repeat \"#{rep}\" - valid options are #{VALID_REPEATS.join(", ")}")
          end
          var)
        end
        
        def function(arglist)
          (repeat == REPEAT_X);Fi[	@ÌiBI"/              var = extract_node_name(var[1])
              var[var] = var
            end
          end
          var)
        end
        
        # Gets the machine that was inherited from a superclass.  This also
        # ensures each ancestor has been loaded prior to looking up their definitions.;Fi[@µ @°+I"var;FI"end;Fi[[	@FiI"ñ      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist);Fi[	@Ii3I"º      def function(arglist)
        var.case_sensitive? ? (super) : (var[var].eq(var))
      end
      
      def function(arglist)
        var
      end
      
      def function(arglist);Fi[	@ViÎI"§          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[	@riI"§          def function(arglist)
            # do nothing
          end
          
          def function(arglist)
            var
          end
        end
        ;Fi[	@\i,I"            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end
          
          alias :handle_snippet_text :handle_success;Fi[	@˚#iI"|    def function(arglist)
      true
    end
    
    def function(arglist)
      var
    end
    
    def function(arglist);Fi[	@˚#iI"k    def function(arglist)
      var
    end
    
    def function(arglist)
      var
    end
  end
end;Fi[I"!Compass.projectize(var, var);FI"end;FI"end;FI" ;Fi[[	@Ùi.I"      
      def function(arglist)
        if var = top_level.project_path and var = top_level.sass_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then;Fi[	@Ùi4I"      
      def function(arglist)
        if var = top_level.project_path and var = top_level.css_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then;Fi[	@Ùi:I"$      
      def function(arglist)
        if var = top_level.project_path and var = top_level.images_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.generated_images_dir then;Fi[	@ÙiHI"#      
      def function(arglist)
        if var = top_level.project_path and var = top_level.javascripts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then;Fi[	@ÙiNI"      
      def function(arglist)
        if var = top_level.project_path and var = top_level.extensions_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then;Fi[	@ÙiTI"      
      def function(arglist)
        if var = top_level.project_path and var = top_level.fonts_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then;Fi[	@ÙiZI"Í      
      def function(arglist)
        if var = top_level.project_path and var = top_level.cache_dir then
          Compass.projectize(var, var)
        end
      end
      
      def function(arglist)
        top_level.images_dir;Fi[I"require("formula");FI"module Homebrew;FI"extend(self);FI" ;Fi[[	@ti I"Ürequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    unless (HOMEBREW_REPOSITORY / ".git").directory? then;Fi [	@wi I"Ñrequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi [	@Ù#i I"^require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    var = [];Fi [	@x7iI"{require("superenv")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    if superenv? then;Fi[	@1iI"jrequire("keg")
require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    begin;Fi[	@ä7i I"Ñrequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi [	@ài I"çrequire("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise("Please `brew install git` first") unless which("git");Fi [@‹.I"[];FI"end;FI"end;Fi[[	@=iOI"Û    def function(arglist)
      if self[:without] then
        self[:without].split(":").map { |arglist| var.to_sym }
      else
        []
      end
    end
    
    # @local_config["BUNDLE_PATH"] should be prioritized over ENV["BUNDLE_PATH"];Fi[	@{i#I"»          Dir.glob(File.join(templates_directory, "*")).map do |arglist|
            File.basename(var)
          end
        else
          []
        end
      end
      
      def function(arglist);Fi[	@Ci#I"≤  def function(arglist)
    if defined? @var and (params[:controller] == "multis") then
      @var.post_from_group(var)
    else
      []
    end
  end
  
  def function(arglist);Fi[	@ÁiºI"å            [:val, var[0], Integer(var[0])]
          end
        end
      else
        []
      end
    end
    
    def function(arglist);Fi[	@ùiõI"    def function(arglist)
      if options[:fields] then
        options[:fields].keys.reject { |arglist| (var == "_type") }
      else
        []
      end
    end
    
    # When freezing a criteria we need to initialize the context first;Fi[	@¥	i/I"˘      if Mongoid.allow_dynamic_fields then
        var = (((@var.keys - fields.keys) - relations.keys) - ["_id", "_type"])
        return var.map { |arglist| "#{name}: #{@attributes[name].inspect}" }
      else
        []
      end
    end
  end
end;Fi[	@i#I",      return [] unless libxml2?
      if compiled_parser_version.!=(loaded_parser_version) then
        ["Nokogiri was built against LibXML version #{compiled_parser_version}, but has dynamically loaded #{loaded_parser_version}"]
      else
        []
      end
    end
    
    def function(arglist);Fi[@'I"
false;FI"end;FI" ;Fi[[	@oi<I"…      if ((var[-var.length, var.length] == var) or (var[-var.length, var.length] == var)) then
        return true
      end
    end
    false
  end
  
  ##
  # Forces reconnection of HTTP connections.;Fi[	@Gi.I"‚            var = File.join(var, (var + var))
            return true if File.executable?(var)
          end
        end
        false
      end
      
      def self.on_windows?(arglist)
        RUBY_PLATFORM =~ /mswin|mingw/;Fi[	@9iCI"    def function(arglist)
      sass_files.zip(css_files).each do |arglist|
        return var if needs_update?(var, var)
      end
      false
    end
    
    def function(arglist)
      staleness_checker.stylesheet_needs_update?(var, File.expand_path(var), importer);Fi[	@{i^I"˙      var ||= "project"
      if var = self[var] and var.templates_directory then
        return File.directory?(File.join(var.templates_directory, var))
      end
      false
    end
    
    def function(arglist)
      var, var = var.split(/\//, 2);Fi[	@≥iRI"ó        else
          return true
        end
      end
      false
    end
    
    def function(arglist)
      self.env["omniauth.auth"] = auth_hash;Fi[	@?i?I"P          end
        end
      end
    end
    false
  end
  
  private
  ;Fi[	@ iÇI"        var = self
        owner_class.def_dataset_method(var) do |arglist|
          var.send(:run_scope, var, self, var)
        end
        false
      end
      
      # Generates the results for the given scope based on one or more states to
      # filter by;Fi[@'@¸@ˇ,I"var = TestBall.new;Fi[[	@∑iI"    assert_raises(ChecksumMismatchError) do |arglist|
      nostdout { |arglist| var.brew { |arglist| } }
    end
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2");Fi[	@∑iI"‹      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("61aa838a9e4050d1876a295a9e62cbe6");Fi[	@∑i"I"‰      md5("61aa838a9e4050d1876a295a9e62cbe6")
    end
    bad_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5");Fi[	@∑i*I"Ó      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e");Fi[	@∑i2I"      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e")
    end
    bad_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f");Fi[	@∑i:I""      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("dcbf5f44743b74add648c7e35e414076632fa3b24463d68d1f6afc5be77024f8");Fi[	@»i'I"œ    var.uninstall
    assert(var.exist?.!)
    assert(var.installed?.!)
  end
  
  def function(arglist)
    var = TestBall.new
    assert_equal(Formula.path(var.name), var.path)
    assert(var.installed?.!);Fi[@'@¸@ˇ,I"if @var then;Fi[[	@£iìI"°  
  def function(arglist)
    birthday.to_s(:long).gsub(", 1000", "") if birthday.present?
  end
  
  def function(arglist)
    if @var then
      @var
    else;Fi[	@£i∑I"÷    if (self.tag_string.count("#") > 5) then
      (errors[:base] << "Profile cannot have more than five tags")
    end
  end
  
  def function(arglist)
    if @var then
      errors.add(:birthday)
      @var = nil;Fi[	@üi!I"‰      
      def function(arglist)
        @var.call
      end
      
      def function(arglist)
        if @var then
          "#{@message} should have been changed to #{@to.inspect}, but is now #{@after.inspect}"
        else;Fi[	@bi7I"ü        else
          (@var == @var.message)
        end
      end
      
      def function(arglist)
        if @var then
          @var.message
        else;Fi[	@ui$I"Û        else
          @var.nil? ? ((@var == @var)) : ((@var == @var).&((@var == @var)))
        end
      end
      
      def function(arglist)
        if @var then
          "expected #{expected}, got #{@caught_symbol.inspect}"
        else;Fi[	@ui,I"—        else
          "expected #{expected} but nothing was thrown"
        end
      end
      
      def function(arglist)
        if @var then
          "expected #{expected} not to be thrown"
        else;Fi[	@€iYI"£      
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        if @var then
          @var.clear
          @var = false;Fi[@û=@˝M@˛MI"	self;Fi[[	@ùiHI"é    #   criteria.to_criteria
    #
    # @return [ Criteria ] self.
    #
    # @since 3.0.0
    def function(arglist)
      self
    end
    ;Fi[	@Z	iI"•      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@Z	iI"û      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@Z	i(I"¢      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@Z	i@I"ù      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@Z	iÇI"ü      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[	@_	iI"∑      #   object_id.__evolve_object_id__
      #
      # @return [ Moped::BSON::ObjectId ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end
      ;Fi[I";# @param options [Hash] A customizable set of options.;FI"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;FI"w# @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[[	I"6data//twitter_proj/twitter/api/direct_messages.rb;TiI"`      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent to the authenticating user.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :page Specifies the page of results to retrieve.
      # @example Return the 20 most recent direct messages sent to the authenticating user;Fi[	@|Qi)I"`      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent by the authenticating user.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :page Specifies the page of results to retrieve.
      # @example Return the 20 most recent direct messages sent by the authenticating user;Fi[	@5iI"§      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user;Fi[	@5iGI"¿      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@5i^I"é      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@5isI"é      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[	@5iÖI"é      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi[@	)@Ú)I"reconnect_ssl;FI"end;Fi[[	@oiˇI"ò  
  ##
  # Sets this client's OpenSSL::X509::Certificate
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :cert= :certificate=;Fi[	@oi	I"ë  # For Net::HTTP parity
  ##
  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##;Fi[	@oiI"ü  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##;Fi[	@oi‰I"å  
  ##
  # Sets this client's SSL private key
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :key= :private_key=;Fi[	@oi⁄I"ê  if (RUBY_VERSION > "1.9") then
    ##
    # SSL version to use
    def function(arglist)
      @var = var
      reconnect_ssl
    end
  end
  ;Fi[	@oiÊI"
  # Setting this to VERIFY_NONE is a VERY BAD IDEA and should NEVER be used.
  # Securely transfer the correct certificate and update the default
  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##;Fi[	@oiÌI"í  
  ##
  # SSL verification callback.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
end
require("net/http/persistent/ssl_reuse");Fi[@0LI"end;FI" ;FI"def function(arglist);Fi[[	@LiI"¡      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        @var = var.config.dup
      end;Fi[	@∫iI"8      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        raise(DatabaseAlreadyExists) if File.exist?(configuration["database"])
        establish_connection(configuration);Fi[	@i'I"·        
        class ArrayProxy
          def function(arglist)
            @var, @var = var, var
          end
          
          def function(arglist)
            @var.send(:"read_inherited_#{@var}_array")
          end;Fi[	@ñi*I"˚        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) };Fi[	@õiI"Ï      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        @var.each { |arglist| var.visit_tag_name(var.name) };Fi[	@ALi
I"Û    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist)
      (regexp_source == var.regexp_source) and (file_colon_line == var.file_colon_line)
    end;Fi[	@YiI"≈      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist)
        var = [@var]
        (var << @var) if @var;Fi[@'@¸@ˇ,I"if var then;Fi[[	@Öi1I"ˆ        else
          var.id.!=(owner[reflection.foreign_key])
        end
      end
      
      def function(arglist)
        if var then
          owner[reflection.foreign_key] = var[reflection.association_primary_key(var.class)]
        else;Fi[	@ñiI"—    def function(arglist)
      super
      @var = false
    end
    
    def function(arglist)
      if var then
        var = "<#{value.bytesize} bytes of binary data>" if var.binary?
        [var.name, var];Fi[	@irI"Â        var = RbStepDefinition.new(self, var, var, var)
        (@var << var)
        var
      end
      
      def function(arglist)
        if var then
          raise(MultipleWorld.new(@var, var)) if @var
          @var = var;Fi[	@EiRI"ø      around(var, var) do |arglist|
        before_and_after(var, var) { |arglist| yield(var) }
      end
    end
    
    def function(arglist)
      if var then
        yield
        return;Fi[	@£i#I"â      end
    end
    return var
  end
  
  def function(arglist)
    if var then
      var = File.basename(var)
      var = (self + var);Fi[	@•iI"·      var[var.issued] = var
      @var.write(var, var)
      @var.write(var, var, :expires_in => (var.lifetime))
    end
    
    def function(arglist)
      if var then
        @var.read(association_key(var, var))
      else;Fi[	@”iZI"A    var = File.join(File.dirname("(string)"), "..", "..", "scripts", "gen_certs.sh")
    var = File.join(File.dirname("(string)"), "..", "..")
    puts(`#{var} "#{var}" "#{var}"`)
  end
  
  def function(arglist)
    if var then
      puts("=== Installing from '#{directory}' ===")
      puts(`cd #{var} && rake install`);Fi[@µ @°+@K1I"@var = [];Fi[[	@˜ieI"¬          "#{condition.inspect} :: #{command.inspect}"
        end
      end
      
      def function(arglist)
        @var = var
        @var = []
        yield(self) if block_given?
      end;Fi[	@DiI"∏      include(Enumerable)
      
      attr_reader(:configuration)
      
      def function(arglist)
        @var = var
        @var = []
        yield(self) if block_given?
      end;Fi[	@Œi
I"Ω    module Interceptor
      class Pipe
        attr_reader(:pipe, :buffer)
        
        def function(arglist)
          @var = var
          @var = []
          @var = true
        end;Fi[	@i(I"Œ        RbDsl.alias_adverb(var)
        RbWorld.alias_adverb(var)
      end
      
      def function(arglist)
        @var = var
        @var = []
        RbDsl.rb_language = self
        @var = @var = nil;Fi[	@diKI"(  attr(:problems, true)
  
  BUILD_TIME_DEPS = ["autoconf", "automake", "boost-build", "bsdmake", "cmake", "imake", "libtool", "pkg-config", "scons", "smake", "swig"]
  
  def function(arglist)
    @var = var
    @var = []
    @var = var.text.without_patch
    var.class.redefine_const(:DATA, "");Fi[	@ØilI"s  fatal(true)
  
  env(:userpaths)
  
  def function(arglist)
    @var = var
    @var = []
    @var = []
  end;Fi[	@§iI"≥      include(Redmine::I18n)
      
      attr_reader(:startdt, :enddt)
      
      def function(arglist)
        @var = var
        @var = []
        @var = {}
        @var = {};Fi[@	)I"
super;FI"end;FI" ;Fi[[	@Vi…I"6      
      # Many Rails applications monkey-patch a replacement of the configure_connection method
      # and don't call 'super', so leave this here even though it looks superfluous.
      def function(arglist)
        super
      end
      
      def function(arglist)
        @var.query_with_result = true;Fi[	@€iI"z        configure!
      end
      
      def function(arglist)
        super
      end
      
      protected
      ;Fi[	@iI"M    end
  end
  
  def function(arglist)
    super
  end
  
  private
  ;Fi[	@ÄiCI"}  end
end
class HeadSoftwareSpec < SoftwareSpec
  def function(arglist)
    super
  end
  
  def function(arglist)
    return;Fi[	I"2data//nokogiri_proj/xsd/xmlparser/nokogiri.rb;TiI"Ø      
      ###
      # Handle the end_element event with +name+
      def function(arglist)
        super
      end
      
      ###
      # Handle errors with message +msg+;Fi[	@|9iI"ÿclass OpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("migration.rb", "db/migrate") };Fi[	@9iI"ﬂclass UpgradeOpenIdAuthenticationTablesGenerator < Rails::Generator::NamedBase
  def function(arglist)
    super
  end
  
  def function(arglist)
    record { |arglist| var.migration_template("migration.rb", "db/migrate") };Fi[@û=@˝M@˛MI"	true;Fi[[	@)	iwI"ô      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@)	i°I"´        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[	@G	iI"û      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@L	i|I"ï      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@L	iæI"®        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end
      end;Fi[	@Q	iI"û      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[	@d	i'I"ò      #   range.resizable?
      #
      # @return [ true ] True.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      ;Fi[@µ @°+@0LI"end;Fi[[	@Li
I"◊  module ConnectionAdapters
    class ConnectionSpecification
      attr_reader(:config, :adapter_method)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist);Fi[	@∫i	I"Í  module Tasks
    class SQLiteDatabaseTasks
      delegate(:connection, :establish_connection, :to => (ActiveRecord::Base))
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist);Fi[	@ñi(I"–        include(Gherkin::Formatter::Escaping)
        
        attr_reader(:exception)
        
        def function(arglist)
          @var, @var = var, var
        end
        
        def function(arglist);Fi[	@õi
I"¢  module Ast
    class Tags
      attr_reader(:tags)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist);Fi[	@5i
I"˜  class Runtime
    class ForProgrammingLanguages
      extend(Forwardable)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def_delegators(:@user_interface, :embed, :ask, :puts, :features_paths, :step_match);Fi[	@ALiI"ømodule Cucumber
  class StepDefinitionLight
    attr_reader(:regexp_source, :file_colon_line)
    
    def function(arglist)
      @var, @var = var, var
    end
    
    def function(arglist);Fi[	@YiI"£      end
      
      attr_reader(:message, :params)
      
      def function(arglist)
        @var, @var = var, var
      end
      
      def function(arglist);Fi[@'@¸@ˇ,I"if var.nil? then;Fi[[	@biI"ô          else
            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else;Fi[	@biXI"÷        
        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else;Fi[	@bijI"ú              end
            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else;Fi[	@˙iI"∞        var.inherit_from!(configuration)
        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else;Fi[	@iöI"Î      def function(arglist)
        @var.__cucumber_step_mother = @var
        @var.__natural_language = var.language
      end
      
      def function(arglist)
        if var.nil? then
          begin
            raise(NilWorld.new);Fi[	@£iJI"á      end
    end
    return var
  end
  
  def function(arglist)
    if var.nil? then
      var = (self + File.basename(var))
    else;Fi[	@ÄióI"¿    @var = Array.new(var)
    @var.extend(HomebrewArgvExtension)
    @var = Set.new
  end
  
  def function(arglist)
    if var.nil? then
      case var
      when :universal, "universal" then;Fi[@	)@H6@I6I"end;Fi[[	@uBi'I"ê    #
    #  person = Person.new(id: 1, name: 'bob')
    #  person.persisted? # => false
    def function(arglist)
      false
    end
  end
end;Fi[	@ói4I"g        end
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@ùißI"õ      end
      
      # NOTE - not sure that we can actually cope with inverses here
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@B)i?I"\      # do nothing
    end
    
    def function(arglist)
      false
    end
  end
end;Fi[	@€ieI"õ        ((var.index(File::SEPARATOR) == 0) or (var.index(":") == 1))
      end
      
      def function(arglist)
        false
      end
    end
  end
end;Fi[	@Ii`I"€  # is a proper Haml context.
  # Because `ActionView` helpers may be included in non-`ActionView::Base` classes,
  # it's a good idea to define \{#is\_haml?} for all objects.
  def function(arglist)
    false
  end
end;Fi[	@åBiI"∫    # only supports immediate deletion of associations.
    #
    # See ActionView::Helpers::FormHelper::fields_for for more info.
    def function(arglist)
      false
    end
  end
end;Fi[@‡"@·"@‚"I"protected;Fi[[	@Ki%I"	            var[:encoding] = "base64" if (type == :binary)
            var[:type] = (type == :string) ? (nil) : (type)
            var[:nil] = true if value.nil?
            var
          end
          
          protected
          
          def function(arglist);Fi[	@'iêI"◊        end
        raise(ActiveRecord::Rollback) unless var
      end
      var
    end
    
    protected
    
    # Save the new record state and id of a record so it can be restored later if a transaction fails.;Fi[	@§iÏI"ï      # Thor::Shell::Basic class.
      #
      def function(arglist)
        var
      end
      
      protected
      
      def function(arglist);Fi[	@ ilI"”        trigger(var[:before], var) if var[:before]
        var = execute_task(var)
        trigger(var[:after], var) if var[:after]
        var
      end
      
      protected
      
      def function(arglist);Fi[	@ÉiπI"æ              var.errors.add(var, (var.present? ? (var) : (:blank)))
            end
          end
          var
        end
        
        protected
        
        def function(arglist);Fi[	@ıiZI"      (var << "-auto-orient") if auto_orient
      ((var << "-resize") << "\"#{scale}\"") unless (var.nil? or var.empty?)
      (((var << "-crop") << "\"#{crop}\"") << "+repage") if var
      var
    end
    
    protected
    
    # Return true if the format is animated;Fi[	@"iI"∂        var = true
        example_groups.each { |arglist| var = var.&(var.run(@var)) }
        finish
        var
      end
      
      protected
      
      def function(arglist);Fi[@û=I"7# @param [ Symbol ] name The name of the relation.;F@úPI"D# @param [ Proc ] block Optional block for defining extensions.;Fi[[	@oi0I"v        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then;Fi[	@oiNI"y        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var);Fi[	@oijI"x        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var);Fi[	@oiÅI"{        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = reference_one_to_one(var, var, Referenced::In, &var);Fi[	@oiöI"z        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Referenced::Many, var, &var);Fi[	@oi∂I"P        #     include Mongoid::Document
        #     has_and_belongs_to_many :people
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        #
        # @since 2.0.0.rc.1;Fi[	@oi‘I"v        #     include Mongoid::Document
        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var);Fi[@µ @ÌNI" ;F@+Oi[[	@ÒNiìI"∆end
class OldBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@ÒNi£I"Îend
class AncientBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle("file:///foo.com/testball-0.1-bottle.tar.gz");Fi[	@ÒNi‡I"Œend
class SnowLeopardBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@ÒNiÔI"«end
class LionBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@ÒNi˛I" end
class AllCatsBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@ÒNiI" end
class RevisedBottleSpecTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|;Fi[	@ÒNi#I"‡end
class CustomVersionSchemeTestBall < Formula
  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  version("1.0" => (CustomVersionScheme));Fi[@‡"@·"@‚"I"###;Fi[[	@ci¸I"        else
          add_child_node(var)
        end
        var
      end
      
      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@ciıI"Ô      # Set the parent Node for this Node
      def function(arglist)
        var.add_child(self)
        var
      end
      
      ###
      # Returns a Hash of {prefix => value} for all namespaces on this
      # node and its ancestors.;Fi[	@#:iI"›        return self[0] unless var
        var = []
        0.upto((var - 1)) { |arglist| (var << self[var]) }
        var
      end
      
      ###
      # Get the last element of the NodeSet.
      def function(arglist);Fi[	@#:idI"∆          var = (var + var.xpath(*(var + [var, var].compact)))
        end
        document.decorate(var)
        var
      end
      
      ###
      # Search this NodeSet for XPath +paths+
      #;Fi[	@#:iqI"+        var = NodeSet.new(document)
        each { |arglist| var = (var + var.xpath(*(var + [var, var].compact))) }
        document.decorate(var)
        var
      end
      
      ###
      # Search this NodeSet's nodes' immediate children using CSS selector +selector+
      def function(arglist);Fi[	@#:i7I"˙      def function(arglist)
        var = NodeSet.new(document)
        (length - 1).downto(0) { |arglist| var.push(self[var]) }
        var
      end
      
      ###
      # Return a nicely formated string representation
      def function(arglist);Fi[	@xi]I"
      def function(arglist)
        var = attr_nodes
        var.each { |arglist| var.instance_variable_set(:@_r, self) }
        var
      end
      
      ###
      # Move the cursor through the document yielding the cursor to the block
      def function(arglist);Fi[@q=I"#   end;TI"#;TI"#   person.pets;Ti[[	@îi&I"      # *First:* Specify a subset of fields to be selected from the result set.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îi_I"¸      # error if the object can not be found.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îi}I"Û      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îiñI"Û      # form returns an empty array.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îiI"      # and delete/add only records that have changed.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>]
      #;Ti[	@îiBI"ﬁ      # +false+.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îi\I"      # hasn't been loaded, it fetches the records from the database.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,;Ti[@'@ﬂJI"var;FI"end;Fi[[	@biyI"ù                else
                  nil
                end
              end
            else
              var
            end
          end
        end;Fi[	@ÛiI"≈        when Hash then
          var.each_with_object({}) do |arglist|
            var[var] = (var == :asc) ? (:desc) : (:asc)
          end
        else
          var
        end
      end
    end;Fi[	@€i[I"¢            var[:project_name]
          else
            File.join(var, var[:project_name])
          end
        else
          var
        end
      end
      ;Fi[	@i§I"π            var.backtrace.clear
            var.backtrace.push(var.backtrace_line("World"))
            raise(var)
          end
        else
          var
        end
      end
    end;Fi[	@=iìI"⁄            end.min
            var.select do |arglist|
              (var.args.inject(0) { |arglist| (var + var.to_s.length) } == var)
            end
          else
            var
          end
        end
      end;Fi[	@‘i&I"¥            var = var.call(var)
            var = modify_keys(var, &var)
            var.merge!(var => (var))
          end
        else
          var
        end
      end
    end;Fi[	@hi∞I"               var = { :metadata => (metadata), :_parent => (base) }
              var.merge!(var)
              Factory.build(klass, var, base.send(:mass_assignment_options))
            end
          else
            var
          end
        end
        ;Fi[I"var = @var;FI"var = @var;FI"var = @var;FI"var = @var;Fi[[	@Ui⁄I"Æ    self.Open if (@var == 0)
    var = @var
    var = (@var + (@var ? ("U") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var;Fi[	@Ui€I"®    var = @var
    var = (@var + (@var ? ("U") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then;Fi[	@Ui‹I"´    var = (@var + (@var ? ("U") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then
      @var = true;Fi[	@ci«I"√    Open if (@var == 0)
    var = @var
    var = ((@var + (@var ? ("U") : (""))) + (@var ? ("D") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var;Fi[	@ci»I"¬    var = @var
    var = ((@var + (@var ? ("U") : (""))) + (@var ? ("D") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then;Fi[	@ci…I"≈    var = ((@var + (@var ? ("U") : (""))) + (@var ? ("D") : ("")))
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    var = @var
    if (@var > 0) then
      @var = true;Fi[I"#       ...;FI"#     end;FI"#   end;FI"#;Fi[[	@˝ivI"‹      #     private
      #
      #     def reset_attribute_to_default!(attr)
      #       ...
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name                         # => 'Gem';Fi[	@=<iJI"∑    # 
    #   class Vehicle
    #     state_machine :status, :attribute => :status_value do
    #       ...
    #     end
    #   end
    # 
    # With a static initial state:
    # ;Fi[	@=<iRI"∞    # 
    #   class Vehicle
    #     state_machine :status, :initial => :parked do
    #       ...
    #     end
    #   end
    # 
    # With a dynamic initial state:
    # ;Fi[	@=<iZI"’    # 
    #   class Vehicle
    #     state_machine :status, :initial => lambda {|vehicle| vehicle.speed == 0 ? :parked : :idling} do
    #       ...
    #     end
    #   end
    # 
    # == Class Methods
    # ;Fi[	@=<i⁄I"ˇ    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked";Fi[	@„i≥I"¯    # 
    #   class Vehicle
    #     state_machine :action => :save do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, machine, :ignite, :parked, :idling);Fi[I"D# : Notification will be sent if `on_success` was set to `true`;FI"#;FI"# `:warning`;FI"D# : The backup completed successfully, but warnings were logged;Fi[[	@Ñi"I"k      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@âi:I"k      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@éiyI"k      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@ëi I"k      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@îi*I"k      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[	@óiI"k      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`;Fi[@'@›GI"var = 0;FI"var = 0;Fi[[	@LimI"¬        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@OibI"¬        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@Ri\I"¬        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@UiBI"ø        var = (var + "R") unless var.index("R").nil?
        var = var.index("T").nil?.! ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0;Fi[	@ci;I"î          var = var.include?("T") ? ((var + "T")) : (var)
        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0;Fi[	@ci•I"£    if (var == 1) and (var == " ") then
      @var = (@var + GetStringWidth(var))
      return
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[@ÿK@ŸK@⁄KI";# @param options [Hash] A customizable set of options.;Fi[[	@$iI"¡      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[	@$i2I"¢      # Search for places that can be attached to a {Twitter::API::Tweets#update}
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[	@$iLI"à      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[	@$iaI"â      # Creates a new place at the given latitude and longitude
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/geo/place
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.;Fi[	@8i&I"      # Returns the locations that Twitter has trending topic information for
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/trends/available
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @return [Array<Twitter::Place>]
      # @example Return the locations that Twitter has trending topic information for;Fi[	@8i6I"¶      # Returns the locations that Twitter has trending topic information for, closest to a specified location.
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/trends/closest
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat If provided with a :long option the available trend locations will be sorted by distance, nearest to furthest, to the co-ordinate pair. The valid ranges for latitude are -90.0 to +90.0 (North is positive) inclusive.
      # @option options [Float] :long If provided with a :lat option the available trend locations will be sorted by distance, nearest to furthest, to the co-ordinate pair. The valid ranges for longitude are -180.0 to +180.0 (East is positive) inclusive.;Fi[I"# `:warning`;F@ªRI"C# : Notification will be sent, including a copy of the current;FI"6# : backup log, if `on_warning` was set to `true`;Fi[[	@Ñi$I"k      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@âi<I"k      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@éi{I"k      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@ëi"I"k      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@îi,I"k      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[	@ói I"k      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`;Fi[@(@(@˜=I"end;Fi[[	@qiI"t        end
        
        def function(arglist)
          @var = var
        end
      end
    end
  end
end;Fi[	@=i5I"é          var = @var
          yield)
        ensure
          @var = var
        end
      end
    end
    
    include(ActionViewExtensions);Fi[	@Ui8I"Ö    
    def function(arglist)
      super(var)
      @var = var
    end
  end
end
class CannotInstallFormulaError < RuntimeError
end;Fi[	@ÄieI"£    if var.nil? then
      return @var ||= Version.parse(@var)
    else
      @var = var
    end
  end
end
class KegOnlyReason
  attr_reader(:reason, :explanation);Fi[	@Â	iI"         attr_reader(:errors)
        
        def function(arglist)
          @var = var
        end
      end
    end
    
    # Process the provided attributes casting them to their proper values if a;Fi[	@ci5I"{      else
        if (var == 2) then
          @var = var
          @var = var
        end
      end
    end
  end
  ;Fi[@ªR@ÍR@ÎRI"#;Fi[[	@Ñi%I"e      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@âi=I"e      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@éi|I"e      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@ëi#I"e      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@îi-I"e      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[	@ói!I"e      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.;Fi[@ÍR@ÎRI"#;FI"# `:failure`;Fi[[	@Ñi&I"i      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@âi>I"i      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@éi}I"i      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@ëi$I"i      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@îi.I"i      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[	@ói"I"i      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused;Fi[@ÎRI"#;FI"# `:failure`;FI"%# : The backup operation failed.;Fi[[	@Ñi'I"©      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@âi?I"©      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@éi~I"©      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@ëi%I"©      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@îi/I"©      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[	@ói#I"©      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current;Fi[I"+# : The backup completed successfully.;F@∏RI"#;FI"# `:warning`;Fi[[	@Ñi!I"d      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@âi9I"d      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@éixI"d      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@ëiI"d      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@îi)I"d      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[	@óiI"d      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current;Fi[@û=I"%# @return [ Mongo ] The context.;FI"#;FI"# @since 3.0.0;Fi[[	@ãi∏I"Î      #   context.limit(20)
      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.limiting = var;Fi[	@ãi«I"Ë      #   context.skip(20)
      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.skipping = var;Fi[	@ãi◊I"Ô      #
      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        in_place_sort(var) and self;Fi[	@éiÙI"Ò      #   context.limit(20)
      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.limit(var) and self;Fi[	@éi$I"Ì      #   context.skip(20)
      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.skip(var) and self;Fi[	@éi3I"Ë      #
      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then;Fi[@'@¸@ˇ,I"return unless var;Fi[[	@?i_I"+        var.map { |arglist| var.dependencies.map { |arglist| var.name } }
      end.flatten.uniq
      var.select { |arglist| specs_by_name(var).empty? }
    end
    
    def function(arglist)
      return unless var
      var.each do |arglist|
        if var = search_by_spec(var) and var.any? then;Fi[	@ﬁi
I"‹    def function(arglist)
      @var ||= Hash.new
      @var[var.to_sym] = var
    end
    
    def function(arglist)
      return unless var
      @var ||= Hash.new
      (@var[var.to_sym] or @var[abbreviation_of(var)]);Fi[	@ÿ#iaI"    var = self.for_visible_shareable_sql(var, var).includes_for_a_stream
    var = var.excluding_hidden_content(var) if var.present?
    var
  end
  
  def function(arglist)
    return unless var
    reshares.where(:author_id => (var.person.id)).first
  end;Fi[	@ÿ#ifI"◊  def function(arglist)
    return unless var
    reshares.where(:author_id => (var.person.id)).first
  end
  
  def function(arglist)
    return unless var
    likes.where(:author_id => (var.person.id)).first
  end;Fi[	@1iI"›      rescue Encoding::UndefinedConversionError => var
        raise(EncodeException, var.message, var.backtrace)
      end
    end
    
    def function(arglist)
      return unless var
      begin
        JSON.load(var);Fi[	@qiI"Ó      def function(arglist)
        return @var unless @var.nil?
        @var = true
      end
      
      def function(arglist)
        return unless var
        @var = var
        Spec::Expectations.differ = self.differ_class.new(self);Fi[I"# `:failure`;F@*SI"H# : Notification will be sent, including the Exception which caused;FI"F# : the failure, the Exception's backtrace, a copy of the current;Fi[[	@Ñi)I"•      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@âiAI"•      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@éi{I"•      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@ëi'I"•      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@îi1I"•      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[	@ói%I"•      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #;Fi[@'I" @var.each_pair do |arglist|;FI"newobj;FI"@var[var]["n"] = @var;Fi[[	@LiıI"(      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@LiI"Ÿ      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[	@Oi˛I"(      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@OiI"Ÿ      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[	@Ri‰I"(      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var);Fi[	@RiˆI"Ÿ      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then;Fi[@'@¸@ˇ,I"var = @var["cw"];Fi[[	@Li™I"∂    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Oi•I"∂    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@RiôI"∂    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Ui-I"’  
  def function(arglist)
    var.is_a?(String) ? (var[var.ord]) : (var[var])
  end
  
  def function(arglist)
    var = @var["cw"]
    var = 0
    var.each_byte { |arglist| var = (var + GetCharWidth(var, var)) };Fi[	@Ui-I"æ    else
      @var = (@var + var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@UiÇI"    var = (var + "B") if var.!=(0) and var.index("B").nil?.!
    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[I"# `:success`;F@9S@∏RI"#;Fi[[	@Ñi I"X      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@âi8I"X      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@éiwI"X      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@ëiI"X      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@îi(I"X      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[	@óiI"X      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged;Fi[@*S@kS@lSI"K# : backup log and other information if `on_failure` was set to `true`;Fi[[	@Ñi*I"|      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@âiBI"|      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@éi|I"|      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@ëi(I"|      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@îi2I"|      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[	@ói&I"|      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist);Fi[@õEI"var;FI"end;FI" ;Fi[[	@(i[I"ˆ        raise(ConnectionNotEstablished) unless @var
        var = new_connection
        var.pool = self
        (@var << var)
        var
      end
      
      def function(arglist)
        var.run_callbacks(:checkout) { |arglist| var.verify! };Fi[	@DiI"‘      
      def function(arglist)
        var = RemoteDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        var = LocalDependency.new(configuration);Fi[	@Di!I"Õ      
      def function(arglist)
        var = LocalDependency.new(configuration)
        (@var << var)
        var
      end
      
      def function(arglist)
        @var.each { |arglist| yield(var) };Fi[	@ipI"Ω      
      def function(arglist)
        var = RbStepDefinition.new(self, var, var, var)
        (@var << var)
        var
      end
      
      def function(arglist)
        if var then;Fi[	@™iàI"F          (var << "width:#{(params[:subject_width] - params[:indent])}px;")
        end
        var = view.content_tag(:div, var, :class => (var[:css]), :style => (var), :title => (var[:title]), :id => (var[:id]))
        (@var << var)
        var
      end
      
      def function(arglist)
        var[:pdf].SetY(var[:top]);Fi[	@™iÎI"˝          (var << "height:12px;")
          (var << view.content_tag(:div, var.html_safe, :style => (var), :class => "tooltip"))
        end
        (@var << var)
        var
      end
      
      def function(arglist)
        var = (var[:height] or 2);Fi[@û=I"# @since 2.0.0.rc.1;FI"def function(arglist);FI"binding do |arglist|;Fi[[	@¢
i0I"|          # @param [ Hash ] options The options to pass through.
          #
          # @option options [ true, false ] :continue Do we continue unbinding?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding do |arglist|
              if base.embedded_many? then
                target.do_or_do_not(metadata.inverse(target)).delete(base);Fi[	@¥
i,I"i          #
          # @option options [ true, false ] :continue Do we continue unbinding?
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil)
            end;Fi[	@Ω
iI"B          # @example Bind the documents.
          #   game.person.bind(:continue => true)
          #   game.person = Person.new
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding do |arglist|
              check_inverses!(target)
              bind_foreign_key(base, target.id);Fi[	@Ω
i-I"O          # @example Unbind the document.
          #   game.person.unbind(:continue => true)
          #   game.person = nil
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding do |arglist|
              var = metadata.inverse(target)
              if var.! and metadata.inverse_of_field then;Fi[	@’
iI"F          #   person.preferences.bind_one(preference)
          #
          # @param [ Document ] doc The single document to bind.
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding do |arglist|
              var = var.you_must(metadata.inverse_foreign_key)
              if var then;Fi[	@’
i#I"V          #
          # @example Unbind the document.
          #   person.preferences.unbind_one(document)
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding do |arglist|
              base.send(metadata.foreign_key).delete_one(var.id)
              var = var.you_must(metadata.inverse_foreign_key);Fi[I"@var[var] = var;FI"end;FI" ;FI"def function(arglist);Fi[[	@ri®I"±          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var]
          end;Fi[	@¬iÑI"è      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!
      end;Fi[	@¨i6I"©      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var
        @var = (var = false;Fi[	@CiáI"ü        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var]
        end;Fi[	@«iwI"∆      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end;Fi[	@àiI"·      return if @var[var]
      instance_variable_set("@#{variable}".to_sym, var)
      self.class.send(:attr_reader, var.to_sym)
      @var[var] = var
    end
    
    def function(arglist)
      @var[var.to_s] = var
    end;Fi[@kS@lS@´SI"#;Fi[[	@Ñi+I"[      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@âiCI"`      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@éi}I"`      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var;Fi[	@ëi)I"[      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@îi3I"[      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[	@ói'I"[      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var;Fi[@'I"	true;FI"end;FI" ;Fi[[	@Â8i&I"´          var = var.listeners.keys
          var.postprocess(var.&(var), var.&(var))
        end
      end
      true
    end
    
    def function(arglist)
      var = [];Fi[	@\itI"        def function(arglist)
          if File.exists?(filename) then
            return @var.any? { |arglist| (var.mtime.to_i > self.mtime.to_i) }
          end
          true
        end
        
        # Mtime of the sprite file
        def function(arglist);Fi[	@¬iôI"˙          else
            return false unless (var == false)
          end
        end
        true
      end
      
      # Holds the authenticatable name for this class. Devise::Strategies::DatabaseAuthenticatable
      # becomes simply :database.;Fi[	@¯8iI"Q  before_destroy do |arglist|
    if self.contact and (self.contact.aspects.size == 1) then
      self.user.disconnect(self.contact)
    end
    true
  end
  
  def function(arglist)
    { :id => (self.id), :person_id => (self.person.id), :contact_id => (self.contact.id), :aspect_ids => (self.contact.aspects.map { |arglist| var.id }) };Fi[	@±	iAI"W      def function(arglist)
        if hereditary? and index_options[:_type => 1].! then
          index({ :_type => 1 }, :unique => (false), :background => (true))
        end
        true
      end
      
      # Adds an index on the field specified. Options can be :unique => true or
      # :unique => false. It will default to the latter.;Fi[	@?iI"¡    while var.skip_until(HIGH_BIT_RANGE) do
      var.pos -= 1
      return false if sequence_length(var).!
    end
    true
  end
  
  def self.clean!(arglist)
    var = StringScanner.new(var);Fi[@lS@´SI"#;FI"def function(arglist);Fi[[	@Ñi,I"n      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@âiDI"s      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@éi~I"s      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var, var = case var
        when :success then;Fi[	@ëi*I"n      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@îi4I"n      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[	@ói(I"n      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then;Fi[I"/# `status` indicates one of the following:;FI"#;FI"# `:success`;F@9Si[[	@ÑiI"      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@âi6I"      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@éiuI"      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@ëiI"      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@îi&I"      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[	@óiI"      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #;Fi[@;R@úP@<RI"def function(arglist);Fi[[	@oi1I"á        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          if ancestors.include?(Mongoid::Versioning) then
            raise(Errors::VersioningNotOnRoot.new(self));Fi[	@oiOI"~        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::Many, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@oikI"}        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Embedded::One, var, &var)
          self.cyclic = true if var[:cyclic];Fi[	@oiÇI"à        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = reference_one_to_one(var, var, Referenced::In, &var)
          aliased_fields[var.to_s] = var.foreign_key;Fi[	@oiõI"m        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          var = characterize(var, Referenced::Many, var, &var)
          relate(var, var);Fi[	@oi’I"Z        #     has_one :game
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.
        def function(arglist)
          reference_one_to_one(var, var, Referenced::One, &var)
        end;Fi[I"7# @param [ String ] meth The name of the accessor.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@§iI"n      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_change") { |arglist| attribute_change(var) };Fi[	@§iI"o      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed?") { |arglist| attribute_changed?(var) };Fi[	@§i*I"k      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed_from_default?") do |arglist|;Fi[	@§i;I"p      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_was") { |arglist| attribute_was(var) };Fi[	@§iJI"Y      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_will_change!") do |arglist|;Fi[	@§i[I"d      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) };Fi[I"1# @param [ String ] name The attribute name.;F@>TI"#;FI"# @since 3.0.0;Fi[[	@§iI"C      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@§iI"=      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@§i)I"E      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@§i:I"K      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@§iII";      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[	@§iZI"6      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|;Fi[I"var = "LTRB";FI"var = "LRT";FI"var = "LR";FI"	else;Fi[[	@LidI"æ    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@OiYI"æ    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@RiSI"æ    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?;Fi[	@Ui9I"ø    var = 0
    if var.!=(0) then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.index("L").nil?;Fi[	@ci0I"∞    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then
          var = "";Fi[	@ci˚I"∞    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then
          var = "";Fi[@'@¸@ØGI"def self.included(arglist);Fi[[	@iI"Õ          end
          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@iI"          send(:include, Redmine::Acts::Attachable::InstanceMethods)
          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@iI"Ì          validate(:validate_custom_field_values)
          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@iI"˘          self.event_options = var.merge(var)
          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@#i&I"4          searchable_options[:search_custom_fields] = reflect_on_association(:custom_values).nil?.!
          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[	@2iI"          send(:include, Redmine::Acts::Watchable::InstanceMethods)
          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end;Fi[I"&merge_list!(var.options, var.pop);FI"Lunless (var.options[:owner_id] or var.options[:owner_screen_name]) then;FI"8merge_owner!(var.options, (var.pop or screen_name));FI"end;Fi[[	@!iJI"©      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::Tweet, :get, "/1.1/lists/statuses.json", var.options)
      end;Fi[	@!iI"Ç      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options)
      end;Fi[	@!iI"o      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var)
      end;Fi[	@!iI"t        begin
          (var = Twitter::API::Arguments.new(var)
          merge_user!(var.options, var.pop)
          merge_list!(var.options, var.pop)
          unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
            merge_owner!(var.options, (var.pop or screen_name))
          end
          send(var.to_sym, var, var.options)
          true);Fi[	@!i)I"Ö      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options)
      end;Fi[	@!i3I"À      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var = var.pop
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        var.flatten.each_slice(MAX_USERS_PER_REQUEST).threaded_map do |arglist|
          object_from_response(Twitter::List, var, var, merge_users(var.options, var));Fi[@û=@˝M@˛MI"/generated_methods.module_eval do |arglist|;Fi[[	@§iI"<      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_change") { |arglist| attribute_change(var) }
        end;Fi[	@§iI"@      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed?") { |arglist| attribute_changed?(var) }
        end;Fi[	@§i+I"Y      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_changed_from_default?") do |arglist|
            attribute_changed_from_default?(var);Fi[	@§i<I"6      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_was") { |arglist| attribute_was(var) }
        end;Fi[	@§iKI"G      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("#{meth}_will_change!") do |arglist|
            attribute_will_change!(var);Fi[	@§i\I"<      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist)
        generated_methods.module_eval do |arglist|
          re_define_method("reset_#{meth}!") { |arglist| reset_attribute!(var) }
        end;Fi[@€LI"var = "LTRB";FI"var = "LRT";FI"var = "LR";Fi[[	@LicI"     var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@OiXI"     var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@RiRI"     var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@Ui8I"‘    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "\n")
    var = 0
    if var.!=(0) then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = "";Fi[	@ci/I"≤    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then;Fi[	@ci˙I"À    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        if var.is_a?(String) then;Fi[@'@¸I"!# Output is always HTML safe;FI"def function(arglist);Fi[[	@FiI""        var = var.to_s
        return var if var.html_safe?
        Haml::Util.html_safe(html_escape_without_haml_xss(var))
      end
      
      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(find_and_preserve_without_haml_xss(*var, &var))
      end;Fi[	@FiI")      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(find_and_preserve_without_haml_xss(*var, &var))
      end
      
      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(preserve_without_haml_xss(*var, &var))
      end;Fi[	@FiI"      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(preserve_without_haml_xss(*var, &var))
      end
      
      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(list_of_without_haml_xss(*var, &var))
      end;Fi[	@Fi3I"J      # Input is escaped, output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(succeed_without_haml_xss(haml_xss_html_escape(var), &var))
      end
      
      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(capture_haml_without_haml_xss(*var, &var))
      end;Fi[	@Fi>I"S      def function(arglist)
        var = instance_variable_defined?("@_haml_concat_raw") ? (@var) : (false)
        haml_concat_without_haml_xss((var ? (var) : (haml_xss_html_escape(var))))
      end
      
      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(haml_indent_without_haml_xss)
      end;Fi[	@FiLI"8          var.unshift(haml_xss_html_escape(var.shift.to_s))
        end
        with_raw_haml_concat { |arglist| haml_tag_without_haml_xss(var, *var, &var) }
      end
      
      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(escape_once_without_haml_xss(*var))
      end;Fi[@µ @ÿ/@È6I"attr_reader :function;Fi[[	@ÀiHI"∂        self
      end
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Returns true if the record is persisted, i.e. it's not a new record and it was;Fi[	@∫i,I"w      end
      
      private
      
      attr_reader :function
      
      attr_reader :function
    end
  end;Fi[	@ieI"≠      def function(arglist)
        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      
      protected;Fi[	@(iûI"Û      var = @var[:processors]
      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Saves the file, if there are no errors. If there are, it flushes them to;Fi[	@9iI"®          @var = 0
          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist);Fi[	@ÿiOI"ñ    attr_reader(:results)
    
    private
    
    attr_reader :function
    
    attr_reader :function
    
    # Gets the object being transitioned;Fi[@JSI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@ãiπI"‹      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.limiting = var
        self;Fi[	@ãi»I"⁄      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        self.skipping = var
        self;Fi[	@ãiÿI"Ò      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        in_place_sort(var) and self
      end;Fi[	@éiıI"ﬂ      #
      # @param [ Integer ] value The number of documents to return.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.limit(var) and self
      end;Fi[	@éi%I"‹      #
      # @param [ Integer ] value The number of documents to skip.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        query.skip(var) and self
      end;Fi[	@éi4I"ˆ      # @param [ Hash ] values The sorting values as field/direction(1/-1)
      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          super(&var);Fi[I"7# Notify the user of the backup operation results.;F@TI"#;FI"# `:success`;Fi[[	@ÑiI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@âi5I"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@éitI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@ëiI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@îi%I"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[	@óiI"      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`;Fi[@†D@°D@¢DI" ;Fi[[	@´i+I"•          var)
        rescue Exception
          send((var + "="), var)
          raise
        end
      end
      
      def function(arglist)
        var = super;Fi[	@‰iI"›        @var)
      rescue Haml::Error => var
        var.backtrace.unshift("#{@options[:filename]}:#{(((e.line ? ((e.line + 1)) : (@index)) + @options[:line]) - 1)}")
        raise
      end
    end
    
    private
    ;Fi[	@®i<I"™      end)
    rescue FormulaUnavailableError => var
      var.dependent = f.name
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? then;Fi[	@®i»I"⁄        f.prefix.rmtree if f.prefix.directory?
        f.rack.rmdir_if_possible
      end
      raise
    end
  end
  
  def function(arglist)
    if f.linked_keg.directory? and (f.linked_keg.realpath == f.prefix) then;Fi[	@´i•I"∑    rescue Exception
      opoo("Could not link #{fname}. Unlinking...")
      unlink
      raise
    end
  end
  
  def function(arglist)
    var = ((HOMEBREW_PREFIX / :opt) / fname);Fi[	@ÿi°I"‡        yield
      rescue Exception
        rollback
        raise
      end
    end
    
    # Runs a block within a transaction for the object being transitioned.  If
    # transactions are disabled, then this is a no-op.;Fi[@µ @°+I"@var[var] = var;FI"end;Fi[[	@ri¶I"√          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist);Fi[	@¬iÇI"ü      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[	@)iI"Å          eval(@var[var])
        end
      end
      
      def function(arglist)
        @var[var] = var
      end
    end
    ;Fi[	@¨i4I"ü      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[	@CiÖI"©          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist);Fi[	@«iuI"√      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist);Fi[I"end.compact.join(" ");FI"end;FI" ;FI"##;Fi[[	@ciãI"6        ["username", "password"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds the MongoDB connectivity options syntax to connect the user
      # to perform the database dumping process;Fi[	@ciïI"        ["host", "port"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Returns the mongodump syntax for enabling ipv6
      def function(arglist);Fi[	@fi_I"Q        ["username", "password"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'".gsub("--username", "--user")
        end.compact.join(" ")
      end
      
      ##
      # Builds the MySQL connectivity options syntax to connect the user
      # to perform the database dumping process;Fi[	@fiiI"        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds a MySQL compatible string for the additional options
      # specified by the user;Fi[	@iigI"A        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'".gsub("--socket=", "--host=")
        end.compact.join(" ")
      end
      
      ##
      # Builds a PostgreSQL compatible string for the additional options
      # specified by the user;Fi[	@likI"$        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "-#{option[0, 1]} '#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds a Redis compatible string for the
      # additional options specified by the user;Fi[@û=I"# `:failure`;F@*S@kSi[[	@Ñi(I"„      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@âi@I"„      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@éiI"„      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@ëi&I"„      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@îi0I"„      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[	@ói$I"„      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #
      # `:failure`
      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`;Fi[@û=I"# `:warning`;F@ªR@ÍRi[[	@Ñi#I"k      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@âi;I"k      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@éizI"k      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@ëi!I"k      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@îi+I"k      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[	@óiI"k      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`
      # : The backup completed successfully, but warnings were logged
      # : Notification will be sent, including a copy of the current
      # : backup log, if `on_warning` was set to `true`
      #;Fi[@'@¸@ˇ,I"@var = var if var;Fi[[	@Ê(i
I"±    class Satisfy
      def function(arglist)
        @var = var
      end
      
      def function(arglist)
        @var = var if var
        @var = var
        @var.call(var);Fi[	@€i I"π      def function(arglist)
        set_expected_received_count(:at_most, var)
        self
      end
      
      def function(arglist)
        @var = var if var
        self
      end;Fi[	@€iI"™      def function(arglist)
        @var = var if var
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = :any
        self;Fi[	@€iI"û      def function(arglist)
        @var = 0
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 1
        self;Fi[	@€iI"ú        @var = var if var
        @var = 1
        self
      end
      
      def function(arglist)
        @var = var if var
        @var = 2
        self;Fi[	@€iI"Æ        @var = var if var
        @var = 2
        self
      end
      
      def function(arglist)
        @var = var if var
        @var.register(self)
        @var = true;Fi[@û=I"# `:success`;F@9S@∏Ri[[	@ÑiI"      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@âi7I"      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@éivI"      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@ëiI"      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@îi'I"      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[	@óiI"      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.
      # : Notification will be sent if `on_success` was set to `true`
      #
      # `:warning`;Fi[@{G@¢H@£HI"var = (var + 1);Fi[[	@LiyI"˜      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@LiçI"          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@OinI"Ò      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@OiáI"          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@RihI"˜      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@Ri|I"          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[@'@¸I"# See Spec::Matchers;FI"def function(arglist);Fi[[	@«i/I"ê            false
          end
        end
      end
      
      # See Spec::Matchers
      def function(arglist)
        @var = var
      end;Fi[	@«i4I"∏      # See Spec::Matchers
      def function(arglist)
        @var = var
      end
      
      # See Spec::Matchers
      def function(arglist)
        @var = var
        match(&var);Fi[	@«i:I"‘      def function(arglist)
        @var = var
        match(&var)
      end
      
      # See Spec::Matchers
      def function(arglist)
        cache_or_call_cached(:failure_message_for_should, &var)
      end;Fi[	@«i?I"      # See Spec::Matchers
      def function(arglist)
        cache_or_call_cached(:failure_message_for_should, &var)
      end
      
      # See Spec::Matchers
      def function(arglist)
        cache_or_call_cached(:failure_message_for_should_not, &var)
      end;Fi[	@«iDI"˝      # See Spec::Matchers
      def function(arglist)
        cache_or_call_cached(:failure_message_for_should_not, &var)
      end
      
      # See Spec::Matchers
      def function(arglist)
        cache_or_call_cached(:description, &var)
      end;Fi[	@«iPI"Á      # See Spec::Matchers
      def function(arglist)
        @var = true
      end
      
      # See Spec::Matchers
      def function(arglist)
        self.class.class_eval do |arglist|
          define_method(var) do |arglist|;Fi[I"# @author Nicola Asuni;FI"# @since 1.5.2;FI"#;FI"def function(arglist);Fi[[	@ciíI"°  #
  	# Set the image scale.
  	# @param float :scale image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    @var = var
  end;Fi[	@ciûI"†  #
  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end;Fi[	@ci™I"•  #
  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end;Fi[	@ci∂I"ß  #
  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end;Fi[	@ci¬I"™  #
  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end;Fi[	@ciŒI"¿  #
  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end;Fi[I"extend(self);FI" ;FI"def function(arglist);FI"if ARGV.named.empty? then;Fi[[	@;7iI"{module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CACHE)
    else;Fi[	@>7iI"|module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_CELLAR)
    else;Fi[	@E7iI"|module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      puts(HOMEBREW_PREFIX)
    else;Fi[	@gi
I"€require("bottles")
require("cmd/prune")
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      if HOMEBREW_CELLAR.directory? then
        HOMEBREW_CELLAR.children.each do |arglist|;Fi[	@_7iI"Åmodule Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      exec_browser(HOMEBREW_WWW)
    else;Fi[	@m7iI"¢module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.named.empty? then
      cd(HOMEBREW_REPOSITORY)
      exec("git", "log", *ARGV.options_only);Fi[@˙I@˚II" ;FI"def function(arglist);Fi[[	@B)iI"k    end
    
    def function(arglist)
      []
    end
    
    def function(arglist)
      0
    end;Fi[	@%i@I"Æ          (@var << var)
          return (__dependencies[var] or [])
        end
        []
      end
      
      def function(arglist)
        @var ||= first.name
      end;Fi[	@iifI"Ò      # wind up being the one called fore Before scenarios, and
      # backgrounds don't have tags.
      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end;Fi[	@äiI"†        end
        
        def function(arglist)
          []
        end
        
        def function(arglist)
          StepCollection.new(var)
        end;Fi[	@ÿ#iCI"Z  end
  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end;Fi[	@iI"∫      end
      
      def function(arglist)
        []
      end
      
      def function(arglist)
        return if var.backtrace.nil?
        var = var.backtrace.collect do |arglist|;Fi[@˜O@¯OI"# ==== Examples;FI"#;Fi[[	@riI"n    # ==== Parameters
    # destination<String>:: the relative path to the destination root.
    # data<String|NilClass>:: the data to append to the file.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   create_file "lib/fun_party.rb" do
    #     hostname = ask("What is the virtual hostname I should use?");Fi[	@iI"È    #
    # ==== Parameters
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   empty_directory "doc"
    #;Fi[	@Çi-I"+    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   link_file "README", "doc/README"
    #;Fi[	@ÇiCI"8    # ==== Parameters
    # source<String>:: the address of the given content.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   get "http://gist.github.com/103208", "doc/README"
    #;Fi[	@ÇicI"*    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   template "README", "doc/README"
    #;Fi[	@ÇiπI"ß    # path<String>:: path of the file to be changed
    # klass<String|Class>:: the class to be manipulated
    # data<String>:: the data to append to the class, can be also given as a block.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   inject_into_class "app/controllers/application_controller.rb", ApplicationController, "  filter_parameter :password\n"
    #;Fi[I"#   class Person;F@öOI"#;FI"#     attr_accessor :name;Fi[[	@˝i$I"C      # An instance method <tt>#{prefix}attribute</tt> must exist and accept
      # at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_prefix 'clear_'
      #     define_attribute_methods :name;Fi[	@˝iHI"D      # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@˝ilI"k      # An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and
      # accept at least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
      #     define_attribute_methods :name;Fi[	@˝iÇI"      
      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name;Fi[	@˝iƒI"'      # +define_attribute_method+ after you define any prefix, suffix or affix
      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #;Fi[	@˝iÎI"&      
      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name;Fi[@'I"	end);FI"end;FI" ;Fi[[	@iZI"ô            @var[var] = var.type_cast(var)
          else
            var.type_cast(var)
          end
        end)
      end
      
      private
      ;Fi[	@àiFI"Â          self.instance_variable_get(var).inject({}) do |arglist|
            var[var[0]] = var[1]
            var
          end
        end)
      end
      
      def function(arglist)
        @var, @var, @var, @var, @var = var;Fi[	@HiıI"        rescue LoadError => var
          var = var.message.split("--").last.strip
          raise(Error.new(Error.message(:gem_install_filter_deps, tilt_extension, var)))
        end
        end)
      end
      
      def self.extended(arglist)
        var.options = {};Fi[	@éi<I"ï            var if (var / "usr/bin/make").executable?
          end
        end
      end
    end)
  end
  
  def function(arglist)
    prefix.nil?.!;Fi[	@ìi#I"§        end
      else
        MacOS.pkgutil_info(FORGE_PKG_ID) =~ /version: (\d\.\d\.\d).+$/ and $1
      end
    end)
  end
  
  def function(arglist)
    "2.7.4";Fi[	@ÌiTI"            if var.!=(namespace) then
              var = globals.state_machines[var.name][name]
              break var if var
            end
          end)
        end
        
        # Gets members of this class's superclasses have already been loaded
        # by YARD;Fi[@≈U@ˆFI"#;FI"#     attr_accessor :name;Fi[[	@piI"      # when validation fails. See <tt>validates</tt> for more information about
      # the validation itself.
      #
      #   class Person
      #     include ActiveModel::Validations
      #
      #     attr_accessor :name
      #     validates! :name, presence: true
      #   end;Fi[	@ï7i∫I"˛    # Returns the +Errors+ object that holds all information about attribute
    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@ï7iÀI"    # Runs all the specified validations and returns +true+ if no errors were
    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@ï7i€I">    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[	@ï7iÚI"	    # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end;Fi[	@ï7iI">    # Context can optionally be supplied to define which callbacks to test
    # against (the context is defined on the validations using <tt>:on</tt>).
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name, on: :new
    #   end;Fi[I"out("endobj");FI"end;FI" @var.each_pair do |arglist|;FI"newobj;Fi[[	@LiÙI")    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[	@LiI"œ      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[	@Oi˝I")    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[	@OiI"œ      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[	@Ri„I")    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[	@RiıI"œ      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font");Fi[@»J@…JI"#   person.pets;TI"#   # => [;Ti[[	@îi'I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îi`I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îi~I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îióI"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiCI"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>;Ti[	@îi]I"      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,;Ti[I"I#   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.;FI"=#   @param options [Hash] A customizable set of options.;FI"def function(arglist);FI"+var = Twitter::API::Arguments.new(var);Fi[[	@|Qi`I"ñ      #   Returns direct messages
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        if var.empty? then
          direct_messages_received(var.options);Fi[	@ÍiTI"§      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin;Fi[	@ÍivI"§      #   @example Favorite the Tweet with the ID 25938088801
      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin;Fi[	@'i#I"      #   Retrieve the data for saved searches owned by the authenticating user
      #
      #   @see https://dev.twitter.com/docs/api/1.1/get/saved_searches/show/:id
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        if var.empty? then
          objects_from_response(Twitter::SavedSearch, :get, "/1.1/saved_searches/list.json", var.options);Fi[	@'iYI"9      #   @example Destroys a saved search for the authenticated user with the ID 16129012
      #     Twitter.saved_search_destroy(16129012)
      # @overload saved_search_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "/1.1/saved_searches/destroy/#{id}.json", var.options);Fi[	@>ikI"Ê      #   @example Return activity summary for the Tweet with the ID 25938088801
      #     Twitter.statuses_activity(25938088801)
      # @overload statuses_activity(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map { |arglist| status_activity(var, var.options) }
      end;Fi[@	)I"@var.name;FI"end;FI" ;Fi[[	@,iI"Ñ      @var.type
    end
    
    def function(arglist)
      @var.name
    end
    
    def function(arglist)
      @var.requirement;Fi[	@„iI"„    end
    
    # The event that triggered the failed transition
    def function(arglist)
      @var.name
    end
    
    # The fully-qualified name of the event that triggered the failed transition
    def function(arglist);Fi[	@„i%I"∑    end
    
    # The name for the current state
    def function(arglist)
      @var.name
    end
    
    # The fully-qualified name for the current state
    def function(arglist);Fi[	@„ijI"’    end
    
    # The event that triggered the transition
    def function(arglist)
      @var.name
    end
    
    # The fully-qualified name of the event that triggered the transition
    def function(arglist);Fi[	@„iyI"«    end
    
    # The state name *before* the transition
    def function(arglist)
      @var.name
    end
    
    # The fully-qualified state name *before* the transition
    def function(arglist);Fi[	@„iÉI"Õ    end
    
    # The new state name *after* the transition
    def function(arglist)
      @var.name
    end
    
    # The new fully-qualified state name *after* the transition
    def function(arglist);Fi[@'@¸@ˇ,I"var = false;Fi[[	@[i'I"¨            var = (var + 1)
          end
          var
        end
        
        def function(arglist)
          var = false
          var = false
          var = false;Fi[	@ i€I"*        (var << var.name)
      end
      var
    end
    
    def function(arglist)
      var = false
      var = "You are trying to install in deployment mode after changing\nyour Gemfile. Run `bundle install` elsewhere and add the\nupdated Gemfile.lock to version control."
      unless var then;Fi[	@ iRI"          (var.class == var.class) and (var.path == var.path)
        end
      end
    end
    
    def function(arglist)
      var = false
      var = @var.find { |arglist| Source::Rubygems.===(var) }
      var = @var.find { |arglist| Source::Rubygems.===(var) };Fi[	@˜irI"Û      
      def function(arglist)
        @var = Branch.new(var, {}, var)
      end
      
      def function(arglist)
        var = false
        var = branches.select do |arglist|
          var = (var.! and (var.skip?.! and var.match(var)));Fi[	@ıiI"¥  
  def function(arglist)
    @var = current_user.blocks.includes(:person)
  end
  
  def function(arglist)
    var = false
    @var = current_user
    if var = params[:user] then;Fi[	@i-I"ˆ          
          def function(arglist)
            diff_as_string(PP.pp(var, ""), PP.pp(var, ""))
          end
          
          def function(arglist)
            var = false
            var = false
            var = (var.keys - var.keys);Fi[@ØG@sTI"var.extend(ClassMethods);FI"end;Fi[[	@iI"∞        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@iI"≤        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@iI"≤        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        def function(arglist);Fi[	@iI"Â        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        ["datetime", "title", "description", "author", "type"].each do |arglist|;Fi[	@#i(I"∞        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        module ClassMethods;Fi[	@2iI"÷        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        
        # Returns an array of users that are proposed as watchers;Fi[@eOI"var.puts(var);FI"end;FI"end;Fi[[	@˚iI"∑        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@ i$I"∑        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@iI"∂        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
    ;Fi[	@
i3I"F          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end
        var = (var + 1)
        var = JSON.parse(self.fetch("/api/v2/users/me/sites/#{blog}/posts?api_token=#{@api_token}&page=#{page}").body);Fi[	@iI"∑        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end;Fi[	@iaI"≈      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end
    
    def self.clean_entities(arglist);Fi[@{K@‰T@TI"#;Fi[[	@ÑiI"÷      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@âi4I"÷      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@éisI"÷      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@ëiI"÷      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@îi$I"÷      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[	@óiI"÷      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`
      # : The backup completed successfully.;Fi[I"6var = (var[var].chr == " ") ? ((var + 1)) : (var);FI"end;FI"var = -1;FI"var = var;Fi[[	@LiãI"#          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@LiŸI"*          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@OiÖI"#          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@Oi·I"*          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@RiI"#          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@Ri»I"*          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[@	)@Ú)@Û)I"end;Fi[[	@Ci
I"´    class Transaction
      attr_reader(:connection)
      
      def function(arglist)
        @var = var
      end
    end
    
    class ClosedTransaction < Transaction;Fi[	@¢6ibI"¬  class MultiparameterAssignmentErrors < ActiveRecordError
    attr_reader(:errors)
    
    def function(arglist)
      @var = var
    end
  end
  
  class UnknownPrimaryKey < ActiveRecordError;Fi[	@niI"œ        
        delegate(:cookies, :env, :to => :@warden)
        
        def function(arglist)
          @var = var
        end
      end
      
      # Remembers the given resource by setting up a cookie;Fi[	@qiI"§          defined? @var ? (@var) : (Devise.scoped_views)
        end
        
        def function(arglist)
          @var = var
        end
      end
    end
  end;Fi[	@Ui.I"    end
  end
  
  def function(arglist)
    @var = var
  end
end
module Homebrew
  class InstallationError < RuntimeError;Fi[	@Â	iI"∆      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError
        attr_reader(:errors)
        
        def function(arglist)
          @var = var
        end
      end
    end
    ;Fi[@=I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];Ti[[	@îipI"@      #   # => #<Pet id: 2, name: "fancy-fancy", person_id: 1>
      #
      #   person.pets.find(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.find(*var, &var);Ti[	@îi¿I"¸      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@îi¯I"¸      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   Pet.find(1);Ti[	@îiI"@      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.delete(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.delete(*var);Ti[	@îi0I"      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3));Ti[	@îi6I"      #   #    ]
      #
      #   person.pets.destroy(Pet.find(2), Pet.find(3))
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0;Ti[@YHI"var = 1;F@ûII"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[[	@LiqI"Œ    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@LiµI"Œ    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@OifI"¿    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@Oi∞I"¿    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then;Fi[	@Ri`I"Œ    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[	@Ri§I"Œ    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then;Fi[I"output.flush;FI"end;FI" ;FI"def function(arglist);Fi[[	@>iI"2        
        def function(arglist)
          output.puts(red("#{current_indentation}#{example.description} (FAILED - #{counter})"))
          output.flush
        end
        
        def function(arglist)
          var = "#{current_indentation}#{example.description}"
          output.puts(green(var));Fi[	@>i#I"<        def function(arglist)
          var = "#{current_indentation}#{example.description}"
          output.puts(green(var))
          output.flush
        end
        
        def function(arglist)
          super
          output.puts(yellow("#{current_indentation}#{example.description} (PENDING: #{message})"));Fi[	@>i)I"        def function(arglist)
          super
          output.puts(yellow("#{current_indentation}#{example.description} (PENDING: #{message})"))
          output.flush
        end
        
        def function(arglist)
          (INDENT * @var.length)
        end;Fi[	@ZiI"˙          super
          output.puts
          output.puts(var.description)
          output.flush
        end
        
        def function(arglist)
          output.puts(red("- #{example.description} (FAILED - #{counter})"))
          output.flush;Fi[	@ZiI"
        
        def function(arglist)
          output.puts(red("- #{example.description} (FAILED - #{counter})"))
          output.flush
        end
        
        def function(arglist)
          var = "- #{example.description}"
          output.puts(green(var));Fi[	@ZiI"        def function(arglist)
          var = "- #{example.description}"
          output.puts(green(var))
          output.flush
        end
        
        def function(arglist)
          super
          output.puts(yellow("- #{example.description} (PENDING: #{message})"));Fi[I"end.to_yaml;FI"2File.open("_posts/#{name}", "w") do |arglist|;FI"var.puts(var);FI"var.puts("---");Fi[[	@˚iI"¥        var = ("%02d-%02d-%02d-%s.markdown" % [var.year, var.month, var.day, var])
        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@ i!I"        var = ([var.year, var.month, var.day, var].join("-") + ".markdown")
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@iI"ù        var = (([var.year, var.month, var.day, var].join("-") + ".") + self.suffix(var))
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@
i0I"ç          var = ("%02d-%02d-%02d-%s.html" % [var.year, var.month, var.day, var])
          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end;Fi[	@iI"Ñ        var = ([var.strftime("%Y-%m-%d"), var].join("-") + ".textile")
        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end;Fi[	@i^I"       end
      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end;Fi[I"(var.nil? or (var == ""));FI"end.to_yaml;F@–VI"var.puts(var);Fi[[	@˚iI"ƒ        var = var[:content]
        var = ("%02d-%02d-%02d-%s.markdown" % [var.year, var.month, var.day, var])
        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var);Fi[	@ i I"å        var = var[:body]
        var = ([var.year, var.month, var.day, var].join("-") + ".markdown")
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var);Fi[	@iI"ƒ        var = ((var + " \n") + var) if var.!=(nil)
        var = (([var.year, var.month, var.day, var].join("-") + ".") + self.suffix(var))
        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var);Fi[	@
i/I"£          var = var["is_private"].!
          var = ("%02d-%02d-%02d-%s.html" % [var.year, var.month, var.day, var])
          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var);Fi[	@iI"ë        var = var[:Body]
        var = ([var.strftime("%Y-%m-%d"), var].join("-") + ".textile")
        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var);Fi[	@i]I"P        var.sort! { |arglist| (var["id"] <=> var["id"]) }
      end
      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var);Fi[I"super(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@oiI"å      
      def function(arglist)
        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end;Fi[	@\iI"          def function(arglist)
            @var, @var = var, var
            var = { :name_to_match => (var) }
            super(var)
          end
          
          def function(arglist)
            var.map { |arglist| create_step_match(var) }
          end;Fi[	@\i*I"        class SnippetText < RequestHandler
          def function(arglist)
            var = { :step_keyword => (var), :step_name => (var), :multiline_arg_class => (var) }
            super(var)
          end
          
          def function(arglist)
            var
          end;Fi[	@\i7I"        class Invoke < RequestHandler
          def function(arglist)
            var = { :id => (var), :args => (var) }
            super(var)
          end
          
          def function(arglist)
            raise(Pending, (var or "TODO"))
          end;Fi[	@£3iI"module PDF_Bookmark
  def (PDF_Bookmark).extend_object(arglist)
    var.instance_eval("@outlines,@OutlineRoot=[],0")
    super(var)
  end
  
  def function(arglist)
    var = self.GetY if (var == -1)
    @var.push("t" => (var), "l" => (var), "y" => (var), "p" => (self.PageNo));Fi[	@ôiOI"          var = "<FEFF"
          (var << var.unpack("C*").map { |arglist| sprintf("%02X", var) }.join)
          (var << ">")) rescue var or "")
          super(var)
        end
        
        def function(arglist)
          if var =~ /^</ then
            return var;Fi[@µ @°+I"var = TestBall.new;FI"*var.stable.instance_eval do |arglist|;Fi[[	@∑iI"”      nostdout { |arglist| var.brew { |arglist| } }
    end
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end;Fi[	@∑iI"∂    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("61aa838a9e4050d1876a295a9e62cbe6")
    end;Fi[	@∑i#I"æ    end
    bad_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end;Fi[	@∑i+I"ø    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("7ea8a98acb8f918df723c2ae73fe67d5664bfd7e")
    end;Fi[	@∑i3I"ÿ    end
    bad_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end;Fi[	@∑i;I"Ÿ    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("dcbf5f44743b74add648c7e35e414076632fa3b24463d68d1f6afc5be77024f8")
    end;Fi[@è7@ê7@F9I"private;Fi[[	@iOI"ï  class BlockValidator < EachValidator
    def function(arglist)
      @var = var
      super
    end
    
    private
    
    def function(arglist);Fi[	@$iI"É    
    def function(arglist)
      clear_timestamp_attributes
      super
    end
    
    private
    
    def function(arglist);Fi[	@Ri!I"Ω      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Lzma is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist);Fi[	@Ui'I"ø      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Pbzip2 is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super
      end
      
      private
      
      def function(arglist);Fi[	@iI"]  end
  
  def function(arglist)
    super
  end
  
  private
  
  def function(arglist);Fi[	@ÙiœI"™            end
          end
        end
        super
      end
      
      private
      
      # Adds an associated validator for the relation if the validate option;Fi[I"2File.open("_posts/#{name}", "w") do |arglist|;FI"var.puts(var);F@“VI"var.puts(var);Fi[[	@˚iI"k        var = { "layout" => "post", "title" => (var.to_s), "joomla_id" => (var[:id]), "joomla_url" => (var[:alias]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@ i"I"=        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@iI"N        var = { "layout" => "post", "title" => (var.to_s), "mt_id" => (var[:entry_id]), "date" => (var) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@
i1I"H          var = { "layout" => "post", "title" => (var.to_s), "published" => (var) }.delete_if do |arglist|
            (var.nil? or (var == ""))
          end.to_yaml
          File.open("_posts/#{name}", "w") do |arglist|
            var.puts(var)
            var.puts("---")
            var.puts(var)
          end
        end;Fi[	@iI"G        var = { "layout" => "post", "title" => (var.to_s), "tags" => (var[:Keywords].split(",")) }.delete_if do |arglist|
          (var.nil? or (var == ""))
        end.to_yaml
        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end;Fi[	@i_I"      var = { "layout" => (var[:type].to_s), "status" => (var[:status].to_s), "published" => ((var[:status].to_s == "publish")), "title" => (var.to_s), "author" => (var[:author].to_s), "author_login" => (var[:author_login].to_s), "author_email" => (var[:author_email].to_s), "author_url" => (var[:author_url].to_s), "excerpt" => (var), "more_anchor" => (var), "wordpress_id" => (var[:id]), "wordpress_url" => (var[:guid].to_s), "date" => (var), "categories" => (var[:categories] ? (var) : (nil)), "tags" => (var[:tags] ? (var) : (nil)), "comments" => (var[:comments] ? (var) : (nil)) }.delete_if do |arglist|
        (var.nil? or (var == ""))
      end.to_yaml
      File.open("_posts/#{name}", "w") do |arglist|
        var.puts(var)
        var.puts("---")
        var.puts(var)
      end
    end;Fi[@'@¸@ˇ,@Ui[[	@ri•I"π        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          ;Fi[	@¬iÅI"ä      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      ;Fi[	@)iI"â        else
          eval(@var[var])
        end
      end
      
      def function(arglist)
        @var[var] = var
      end
    end;Fi[	@¨i3I"ä      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      ;Fi[	@CiÑI"©        def function(arglist)
          @var = var
          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        ;Fi[	@«itI"Æ      
      def function(arglist)
        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      ;Fi[@'@ﬂJI"
super;FI"end;Fi[[	@IiI"¿            "longtext"
          else
            raise(ActiveRecordError, "No text type has character length #{limit}")
          end
        else
          super
        end
      end
      ;Fi[	@uiMI"µ                "X'#{value}'"
              else
                # do nothing
              end
            else
              super
            end
          else
            super;Fi[	@uiPI"ä              end
            else
              super
            end
          else
            super
          end
        end
        ;Fi[	@ÉiMI"ˆ              "int8range"
            else
              raise(ActiveRecordError, "No range type has byte size #{limit}. Use a numeric with precision 0 instead.")
            end
          else
            super
          end
        end
        ;Fi[	@˝i5I"º          Kernel.exec("#{groff} #{root}/#{command} | #{pager}")
        else
          puts(File.read("#{root}/#{command}.txt"))
        end
      else
        super
      end
    end
    ;Fi[	@ÿi I"æ        end
        if skip_after and success? then
          each { |arglist| var.machine.write(object, :event_transition, var) }
        end
      else
        super
      end
    end
    ;Fi[@ÚV@ÛVI"end;FI"end;Fi[[	I";data//activerecord_proj/active_record/serialization.rb;TiI"˘      var = (var.try(:clone) or {})
      var[:except] = Array(var[:except]).map { |arglist| var.to_s }
      var[:except] |= Array(self.class.inheritance_column)
      super(var)
    end
  end
end
require("active_record/serializers/xml_serializer");Fi[	@D	i I"Ë      # @since 1.0.0
      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::FalseClass.__send__(:include, Mongoid::Extensions::FalseClass);Fi[	@â	i I"Ê      # @since 1.0.0
      def function(arglist)
        return true if ((var == ::Boolean) or (var.class == ::Boolean))
        super(var)
      end
    end
  end
end
::TrueClass.__send__(:include, Mongoid::Extensions::TrueClass);Fi[	I"4data//state_machine_proj/state_machine/error.rb;TiI"o    # The object that failed
    def function(arglist)
      @var = var
      super(var)
    end
  end
end;Fi[	@iI"ä      
      def function(arglist)
        @var = var.last.is_a?(::Hash) ? (var.pop) : ({})
        super(var)
      end
    end
  end
end;Fi[	@uiI"i      
      def function(arglist)
        @var = var
        super(var)
      end
    end
  end
end;Fi[@µ @ØG@sT@KVi[[	@iI"»          self.activity_provider_options[var] = var
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@iI"≈          before_save(:attach_saved_attachments)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@iI"ƒ          after_save(:save_custom_field_values)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@iI"‘          send(:include, Redmine::Acts::Event::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@#i'I"Ÿ          send(:include, Redmine::Acts::Searchable::InstanceMethods)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[	@2iI"–          alias_method_chain(:watcher_user_ids=, :uniq_ids)
        end
      end
      
      module InstanceMethods
        def self.included(arglist)
          var.extend(ClassMethods)
        end
        ;Fi[@YHI"var = (var + 1);FI"$var = var if var and (var == 2);FI"	else;Fi[[	@LièI"ª        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@OiâI"≈        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@Ri~I"ª        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@UiVI"¡        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == " "[0]) then
          var = var;Fi[	@UisI"¡          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1)
        end;Fi[	@cinI"Ø        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1)
      end;Fi[@'@¸@ˇ,I"var = nil;Ti[[	@Ÿi(I"      @var = Hash[@var]
      @var[:bind] = @var[:bind].dup if @var.key?(:bind)
      reset
    end
    
    def function(arglist)
      var = nil
      if primary_key and Hash.===(var) then
        var = var[var.keys.find { |arglist| (var.name == primary_key) }];Ti[	@§iCI"      def function(arglist)
        say("#{statement} ", var)
        stdin.gets.tap { |arglist| var.strip! if var }
      end
      
      def function(arglist)
        var = nil
        until var do
          (var = ask_simply("#{statement} #{answer_set.inspect}", *var);Fi[	@GikI".        def function(arglist)
          @var = @var.inject(0) { |arglist| (var + var.width) }
          @var = @var.inject(0) { |arglist| (var + var.height) }
        end
        
        def function(arglist)
          var = nil
          @var.each_with_index do |arglist|
            if var.nil? then;Fi[	@Bi=I"—        rescue Timeout::Error => var
          nil
        end
      end
      
      def function(arglist)
        var = nil
        var = java.lang.Thread.new { |arglist| var = STDIN.gets }
        var.start;Fi[	@}i©I"ü    end
    self[var] = var
    return var
  end
  
  def function(arglist)
    var = nil
    if (var.difftype == String) then
      var = var.difftype.new("");Fi[	@fiOI"¬      
      def function(arglist)
        var.each { |arglist| instance_eval(&var) }
      end
      
      def function(arglist)
        var = nil
        var.each do |arglist|
          begin;Fi[@OK@PKI"##;F@‰Ti[[	@ÑiI"Ã        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@âi2I"Ã        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@éiqI"Ã        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@ëiI"Ã        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@îi"I"Ã        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[	@óiI"Ã        instance_eval(&var) if block_given?
      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #;Fi[@OK@PKI"attr_reader :function;FI" ;Fi[[	@iPI"±        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        configuration.merge("database" => (nil));Fi[	@!iFI"Ê        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist)
        (configuration["encoding"] or DEFAULT_ENCODING);Fi[	@∫i+I"ê        `sqlite3 #{var} < "#{var}"`
      end
      
      private
      
      attr_reader :function
      
      attr_reader :function
    end;Fi[	@¬iTI"Ÿ      to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist)
      logger.info("#{transport} #{operation} #{from} -> #{to}") if logger;Fi[	@’iÁI"      "#<#{self.class} #{(attributes.map { |attr, value| "#{attr}=#{value.inspect}" } * " ")}>"
    end
    
    private
    
    attr_reader :function
    
    # Adds a predicate method to the owner class so long as a name has
    # actually been configured for the state;Fi[	@ÿiNI"w    
    attr_reader(:results)
    
    private
    
    attr_reader :function
    
    attr_reader :function
    ;Fi[I"if (@var > 0) then;FI"@var = 0;FI"out("0 Tw");FI"end;Fi[[	@UiLI"    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0
          out("0 Tw")
        end
        var = (var == 0) ? (0) : ((var - 1))
        self.Cell(var, var, var[(var..var)], var, 2, var, var);Fi[	@UicI"        if (var > var) then
          if (var == -1) then
            var = (var + 1) if (var == var)
            if (@var > 0) then
              @var = 0
              out("0 Tw")
            end
            self.Cell(var, var, var[(var..(var - 1))], var, 2, var, var)
          else;Fi[	@Ui{I"’        end
      end
    end
    if (@var > 0) then
      @var = 0
      out("0 Tw")
    end
    var = (var + "B") if var.!=(0) and var.index("B").nil?.!
    self.Cell(var, var, var[(var..var)], var, 2, var, var);Fi[	@ciEI"    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0
          out("0 Tw")
        end
        var = (var == 0) ? (0) : ((var - 1))
        var = (var == 0) ? (1) : (var);Fi[	@ci^I"      if (var > var) then
        if (var == -1) then
          var = (var + 1) if (var == var)
          if (@var > 0) then
            @var = 0
            out("0 Tw")
          end
          Cell(var, var, var[(var..(var - 1))], var, 2, var, var)
        else;Fi[	@ciuI"·        var = (var + 1)
      end
    end
    if (@var > 0) then
      @var = 0
      out("0 Tw")
    end
    (var << "B") if var.is_a?(String) and var.include?("B")
    Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[@	)I"@var[var] = var;FI"end;FI" ;Fi[[	@iµI"Ì    end
    
    # Set the specified association instance.
    def function(arglist)
      @var[var] = var
    end
    
    module ClassMethods
      # Specifies a one-to-many association. The following methods for retrieval and query of;Fi[	@rißI"π            @var = {}
          end
          
          def function(arglist)
            @var[var] = var
          end
          
          def function(arglist)
            @var[var];Fi[	@¬iÉI"ó        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        @var.abort!;Fi[	@¨i5I"ü        @var[var]
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var;Fi[	@CiÜI"®          @var = var
        end
        
        def function(arglist)
          @var[var] = var
        end
        
        def function(arglist)
          @var[var];Fi[	@«ivI"Ú        var ? (cache(var, &var)) : (call_cached(var))
      end
      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call);Fi[@eD@fDI" ;FI"def function(arglist);Fi[[	@9iSI"ˆ      css_files.each do |arglist|
        return var if File.exists?(var) and (var > File.mtime(var))
      end
      nil
    end
    
    def function(arglist)
      remove(options[:cache_location])
      css_files.each { |arglist| remove(var) };Fi[	@i|I"¿          @var ||= {}
          send("#{attribute}=", nil)
          @var.delete(var)
          nil
        end
        
        def function(arglist)
          @var ||= {}
          @var[var];Fi[	@’iI"‘      if var.=~(SPRITE_IMPORTER_REGEX) then
        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing
    end;Fi[	@ÉiI"Ú        cells_rows.each_with_index do |arglist|
          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end;Fi[	@∏i#I"      ShareVisibility.new(:contact_id => (var.id), :shareable_id => (var.id), :shareable_type => "Post")
    end
    ShareVisibility.import(var) unless var.empty?
    nil
  end
  
  def function(arglist)
    var = var.posts.all
    if (var.mutual?.! or var[:force]) then;Fi[	@´i$I"Ë        return "#{first_name} #{last_name}".strip if (first_name? or last_name?)
        return nickname if nickname?
        return email if email?
        nil
      end
      
      def function(arglist)
        name.!.!
      end;Fi[@µ @∂ @∑ @°Wi[[	@iOI"√        var.concat(["--database", "#{configuration["database"]}"])
        Kernel.system(*var)
      end
      
      private
      
      attr_reader :function
      
      def function(arglist);Fi[	@!iEI"√        set_psql_env
        Kernel.system("psql -f #{filename} #{configuration["database"]}")
      end
      
      private
      
      attr_reader :function
      
      def function(arglist);Fi[	@∫i*I"∞        var = configuration["database"]
        `sqlite3 #{var} < "#{var}"`
      end
      
      private
      
      attr_reader :function
      
      attr_reader :function;Fi[	@¬iSI"©    def function(arglist)
      to.responds_to?(:read) ? ("#<#{to.class}>") : (to)
    end
    
    private
    
    attr_reader :function
    
    def function(arglist);Fi[	@’iÊI"?      var = [[:name, name], [:value, @var], [:initial, initial?], [:context, methods.keys]]
      "#<#{self.class} #{(attributes.map { |attr, value| "#{attr}=#{value.inspect}" } * " ")}>"
    end
    
    private
    
    attr_reader :function
    
    # Adds a predicate method to the owner class so long as a name has;Fi[	@ÿiMI"{    protected
    
    attr_reader(:results)
    
    private
    
    attr_reader :function
    
    attr_reader :function;Fi[I"#@var = (HOMEBREW_CACHE + @var);FI"end;FI" ;FI"attr_reader :function;Fi[[	@îiΩI"ˆ    @@svn ||= "svn"
    @var = "#{name}--svn" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (@var + "-HEAD") if ARGV.include?("--HEAD")
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@îiI"…    super
    @@git ||= "git"
    @var = "#{name}--git" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@îidI"Õ  def function(arglist)
    super
    @var = "#{name}--cvs" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@îièI"Ã  def function(arglist)
    super
    @var = "#{name}--hg" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@îiπI"Õ  def function(arglist)
    super
    @var = "#{name}--bzr" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@îiŸI"–  def function(arglist)
    super
    @var = "#{name}--fossil" unless (var.to_s.empty? or (var == "__UNKNOWN__"))
    @var = (HOMEBREW_CACHE + @var)
  end
  
  attr_reader :function
  
  def function(arglist);Fi[@ˆG@˜GI"var = (var + 1);F@sWi[[	@LizI"·        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@LiéI"Ì          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[	@OioI"·        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@OiàI"ﬂ          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + var);Fi[	@RiiI"·        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@Ri}I"Ì          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)));Fi[@µ I"#:nodoc:;FI"def function(arglist);FI"
begin;Fi[[	@IiI"ó          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("COMMIT")
        rescue;Fi[	@IiI"ô          # do nothing
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          execute("ROLLBACK")
        rescue;Fi[	@ViäI"∞      end
      
      alias :exec_update :exec_delete
      
      #:nodoc:
      def function(arglist)
        begin
          exec_query("BEGIN")
        rescue Mysql::Error;Fi[	@ziI"Ô        def function(arglist)
          true
        end
        
        #:nodoc:
        def function(arglist)
          begin
            (if supports_disable_referential_integrity? then
              execute(tables.collect do |arglist|;Fi[	@ñi“I"–          @var[var] = @var.delete(var) if @var.has_key?(var)
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          require("diff/lcs")
        rescue LoadError => var;Fi[	@ÈiII"Ï          raise(MockExpectationError, "The method `#{message}` was not stubbed or was already unstubbed")
        end
      end
      
      #:nodoc:
      def function(arglist)
        begin
          verify_expectations
        ensure;Fi[@µ @:N@‰T@Ti[[	@ÑiI"≥      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@âi3I"≥      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@éirI"≥      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@ëiI"≥      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@îi#I"≥      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[	@óiI"≥      end
      
      private
      
      ##
      # Notify the user of the backup operation results.
      # `status` indicates one of the following:
      #
      # `:success`;Fi[@û=@PT@>TI"#;Fi[[	@§i
I"      #
      # @example Create the accessor.
      #   Model.create_dirty_change_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@§iI"      #
      # @example Create the check.
      #   Model.create_dirty_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@§i(I"      #
      # @example Create the check.
      #   Model.create_dirty_default_change_check("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@§i9I"       #
      # @example Create the accessor.
      #   Model.create_dirty_previous_value_accessor("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@§iHI"      #
      # @example Create the flag.
      #   Model.create_dirty_change_flag("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@§iYI"      #
      # @example Create the reset.
      #   Model.create_dirty_reset("name", "alias")
      #
      # @param [ String ] name The attribute name.
      # @param [ String ] meth The name of the accessor.
      #
      # @since 3.0.0
      def function(arglist);Fi[@'@¸@ˇ,I"return @var if @var;Fi
[
[	@~iI"È      def function(arglist)
        super(var)
        set_backtrace(var.backtrace) if @var = var
      end
      
      def function(arglist)
        return @var if @var
        var = super()
        if (var == self.class.to_s) then;Fi[	@ßi3I"À          @var.puts(var.message)
          true
        end
      end
      
      def function(arglist)
        return @var if @var
        @var = Configuration.new(@var, @var)
        @var.parse!(@var);Fi[	@¨i7I"≥      
      def function(arglist)
        @var[var] = var
      end
      
      def function(arglist)
        return @var if @var
        @var = (var = false
        var = false;Fi[	@éiòI"  def function(arglist)
    `/usr/bin/clang -v 2>&1` =~ /tags\/Apple\/clang-(\d+)\.(\d+)\.(\d+)/
    ($1.to_i >= 421) and ($3.to_i >= 57)
  end
  
  def function(arglist)
    return @var if @var
    @var = true
    @var ||= ([STANDALONE_PKG_ID, FROM_XCODE_PKG_ID].find do |arglist|;Fi[	@Íi9I")    def function(arglist)
      return "" if @var[:clear]
      @var ||= ([comment_open, Whenever.cron(@var), comment_close].compact.join("\n") + "\n")
    end
    
    def function(arglist)
      return @var if @var
      var = ["crontab -l"]
      (var << "-u #{@options[:user]}") if @var[:user];Fi[@'@(I"var = -1;FI"var = 0;Fi
[
[	@LilI"Ë        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@OiaI"Ë        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@Ri[I"Ë        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@UiAI"‡        var = "L" unless var.index("L").nil?
        var = (var + "R") unless var.index("R").nil?
        var = var.index("T").nil?.! ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@ci:I"¥          (var << "R") if var.include?("R")
          var = var.include?("T") ? ((var + "T")) : (var)
        end
      end
    end
    var = -1
    var = 0
    var = 0
    var = 0;Fi[I"protected;FI" ;F@°+I"
begin;Fi
[
[	@FiI"	        pool.checkin(self)
      end
      
      protected
      
      def function(arglist)
        begin
          @var.instrument("sql.active_record", :sql => (var), :name => (var), :connection_id => (object_id), :binds => (var)) do |arglist|
            yield;Fi[	@ºi±I"»      end
    end
    
    protected
    
    def function(arglist)
      begin
        (var = construct_join_dependency_for_association_find
        var = construct_relation_for_association_find(var);Fi[	@iI"ò      end
    end
    
    protected
    
    def function(arglist)
      begin
        ($command = args.shift
        var = Compass::Commands[$command];Fi[	@´i≥I"ø    var.make_relative_symlink(self)
  end
  
  protected
  
  def function(arglist)
    begin
      if var.symlink? and var.directory? then
        var = (var.parent + var.readlink).cleanpath;Fi[	@€ièI"Ω        (@var.arity == 0) ? (@var.call) : (@var.call(*var))
      end
      
      protected
      
      def function(arglist)
        begin
          @var.call(*var)
        rescue => var;Fi[@'@¸@ˇ,I"passert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi
[
[	@ái6I"L  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower
    assert_equal([1, 3, 2, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi[	@áiFI"'    assert_equal([1, 3, 4, 2], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(4).move_to_top
    assert_equal([4, 1, 3, 2], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(3).move_to_bottom
    assert_equal([1, 2, 4, 3], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi[	@áiÄI"d    assert_equal(1, var.pos)
    var.reload
    assert_equal(5, var.pos)
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(2).destroy
    assert_equal([1, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi[	@ái†I"µ    assert_equal(true, ListMixin.find(1).in_list?)
    ListMixin.find(1).remove_from_list
    assert_equal(false, ListMixin.find(1).in_list?)
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(2).remove_from_list
    assert_equal([2, 1, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi[	@ái™I"X    assert_equal(nil, ListMixin.find(2).pos)
    assert_equal(2, ListMixin.find(3).pos)
    assert_equal(3, ListMixin.find(4).pos)
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(2).remove_from_list
    ListMixin.find(2).destroy;Fi[@'@(I"module Homebrew;FI"extend(self);Fi
[
[	@ni
I"Ω  var.deps.each do |arglist|
    puts((("> " * var) + var.to_s))
    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist);Fi[	@f7iI"Çclass String
  def function(arglist)
    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist);Fi[	@&iI"ô      raise(FormulaUnspecifiedError) if ARGV.named.empty?
      ARGV.formulae
    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist);Fi[	@p-i	I"Üclass Fixnum
  def function(arglist)
    (self > 1) ? ("s") : ("")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist);Fi[	@UiìI"7  
  def function(arglist)
    (super + advice.to_s)
  end
end
module Homebrew
  extend(self)
  
  SUDO_BAD_ERRMSG = "    You can use brew with sudo, but only if the brew executable is owned by root.\n    However, this is both not recommended and completely unsupported so do so at\n    your own risk.\n".undent;Fi[@µ @:NI"# Server credentials;FI"##;Fi
[
[	@™iI"®      attr_accessor(:path)
      
      attr_accessor(:passive_mode)
      
      ##
      # Server credentials
      ##
      # Server IP Address and FTP port
      ##;Fi[	@ªiI"°      attr_accessor(:path)
      
      attr_accessor(:local)
      
      ##
      # Server credentials
      ##
      # Server IP Address and SSH port
      ##;Fi[	@√iI"•      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials
      ##
      # Server IP Address and SCP port
      ##;Fi[	@»iI"¶      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials
      ##
      # Server IP Address and SFTP port
      ##;Fi[	@¯iI"∂        attr_accessor(:port)
        
        attr_accessor(:compress)
        
        ##
        # Server credentials
        ##
        # Server IP Address and SSH port
        ##;Fi[@'@¸@ˇ,I"@var = (@var + 1);Fi
[
[	@«iãI"          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = (@var + 1)
        @var = false
        var = { Ast::Scenario => "scenario", Ast::ScenarioOutline => "scenario outline" }[var.class];Fi[	@Ui%I"Ç    out(var)
    out("%%EOF")
    @var = 3
  end
  
  def function(arglist)
    @var = (@var + 1)
    @var[@var] = ""
    @var = 2;Fi[	@UiHI"õ  
  def function(arglist)
    @var = 1
  end
  
  def function(arglist)
    @var = (@var + 1)
    @var[@var] = @var.length
    out((@var.to_s + " 0 obj"));Fi[	@9i5I"µ          @var.puts("  </dl>")
          @var.puts("</div>")
          @var.flush
        end
        
        def function(arglist)
          @var = (@var + 1)
        end
        ;Fi[	@tiI"ﬂ      
      def function(arglist)
        formatters.each { |arglist| var.example_started(var) }
      end
      
      def function(arglist)
        @var = (@var + 1)
        if var.nil? then
          example_passed(var);Fi[@	)I"@var.clear;FI"end;FI" ;Fi
[
[	@Vi»I"      end
      
      # Clears the prepared statements cache.
      def function(arglist)
        @var.clear
      end
      
      ENCODINGS = { "armscii8" => (nil), "ascii" => (Encoding::US_ASCII), "big5" => (Encoding::Big5), "binary" => (Encoding::ASCII_8BIT), "cp1250" => (Encoding::Windows_1250), "cp1251" => (Encoding::Windows_1251), "cp1256" => (Encoding::Windows_1256), "cp1257" => (Encoding::Windows_1257), "cp850" => (Encoding::CP850), "cp852" => (Encoding::CP852), "cp866" => (Encoding::IBM866), "cp932" => (Encoding::Windows_31J), "dec8" => (nil), "eucjpms" => (Encoding::EucJP_ms), "euckr" => (Encoding::EUC_KR), "gb2312" => (Encoding::EUC_CN), "gbk" => (Encoding::GBK), "geostd8" => (nil), "greek" => (Encoding::ISO_8859_7), "hebrew" => (Encoding::ISO_8859_8), "hp8" => (nil), "keybcs2" => (nil), "koi8r" => (Encoding::KOI8_R), "koi8u" => (Encoding::KOI8_U), "latin1" => (Encoding::ISO_8859_1), "latin2" => (Encoding::ISO_8859_2), "latin5" => (Encoding::ISO_8859_9), "latin7" => (Encoding::ISO_8859_13), "macce" => (Encoding::MacCentEuro), "macroman" => (Encoding::MacRoman), "sjis" => (Encoding::SHIFT_JIS), "swe7" => (nil), "tis620" => (Encoding::TIS_620), "ucs2" => (Encoding::UTF_16BE), "ujis" => (Encoding::EucJP_ms), "utf8" => (Encoding::UTF_8), "utf8mb4" => (Encoding::UTF_8) }
      ;Fi[	@çi†I"Ø      end
      
      # Clears the prepared statements cache.
      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist);Fi[	@ÈiƒI"¢        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@Èi»I"í        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear;Fi[	@ÈiÃI"ï        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var;Fi[@µ @ÿ/@È6I"private;Fi
[
[	@ÖiI"á        super
        @var = false
      end
      
      attr_reader :function
      
      private
      
      def function(arglist);Fi[	@
iI"¨      def function(arglist)
        @var[var]
      end
      
      attr_reader :function
      
      private
      
      # Handle *_before_type_cast for method_missing.;Fi[	@“iªI"√            @var = var.slice((-32..-1))
            @var = @var.sub((@var + "/"), "")
          end
          
          attr_reader :function
          
          private
          
          ##;Fi[	@úi/I"      check_requirement!
      @var
    end
    
    attr_reader :function
    
    private
    
    def function(arglist);Fi[	@GiI"≥        @var = var
        self
      end
      
      attr_reader :function
      
      private
      
      # Searches the path, looking for the given utility. If an executable;Fi[@µ @X@XI"@var.each do |arglist|;Fi
[
[	@(i†I"      instance_write(:created_at, nil) if has_enabled_but_unset_created_at?
      instance_write(:updated_at, nil)
    end
    
    #:nodoc:
    def function(arglist)
      @var.each do |arglist|
        [var].flatten.each { |arglist| instance.errors.add(name, var) }
      end;Fi[	@ÂiI"      def function(arglist)
        original_filename ? (File.exist?(path(var))) : (false)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          FileUtils.mkdir_p(File.dirname(path(var)))
          File.open(path(var), "wb") do |arglist|;Fi[	@Âi"I"º        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}");Fi[	@Îi≈I"·      def function(arglist)
        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("saving #{path(style)}");Fi[	@Îi·I"º        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}");Fi[I"J# Defines an initialization hook into the owner class for setting the;FI"J# initial state of the machine *before* any attributes are set on the;FI"# object;FI"def function(arglist);Fi
[
[	@ûi(I"0        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_static_state_initializer
        define_dynamic_state_initializer;Fi[	@≤iTI"ﬂ        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (426 + 1))
      end;Fi[	@∫i&I"‘        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (325 + 1))
      end;Fi[	@¬i*I"√        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              @attributes ||= {}\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false)\n              \n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (386 + 1))
      end;Fi[	@ iJI"⁄        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize_set(*)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (344 + 1))
      end;Fi[@$D@%D@PPI"end;Fi
[
[	@ji.I"            var = var.send(var) if var.is_a?(Symbol)
            unless var.send(CHECKS[var], var) then
              var.errors.add(var, var, filtered_options(var).merge(:count => (var)))
            end)
          end
        end
      end
      
      protected;Fi[	@∫i"I"      var = self.name
      model.send(:include, Module.new do |arglist|
        class_eval("          def destroy_associations\n            association(:#{name}).delete_all\n            super\n          end\n", "(string)", (36 + 1))
      end)
    end
  end
end;Fi[	@qimI"Â        def function(arglist)
          @var ||= (variable(:scm_password) or if variable(:scm_prefer_prompt) then
            Capistrano::CLI.password_prompt("hg password: ")
          end)
        end
      end
    end
  end
end;Fi[	@E7iI"ô    else
      puts(ARGV.formulae.map do |arglist|
        var.opt_prefix.exist? ? (var.opt_prefix) : (var.installed_prefix)
      end)
    end
  end
end;Fi[	@èixI"˝                set_trace_func(nil)
                IRB.start_within(var)
              end
            end)
          end
        end
      end
      var.choice(:shell) do |arglist|
        puts("When you exit this shell, you will return to the menu.");Fi[@'@(I"out(">>");FI"out("endobj");Fi
[
[	@Li"I"             else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[	@Oi+I"             else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[	@RiI"             else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj;Fi[	@UiyI"˝              out("/Encoding /WinAnsiEncoding")
            else
              out((("/Encoding " + (var + var["diff"]).to_s) + " 0 R"))
            end
          end
          out(">>")
          out("endobj")
          newobj
          var = var["cw"];Fi[	@ciaI"                out((("/Encoding " + (var + var["diff"]).to_s) + " 0 R"))
              else
                out("/Encoding /WinAnsiEncoding")
              end
            end
            out(">>")
            out("endobj")
            newobj
            var = var["cw"];Fi[@“O@”O@‘OI"#assert(var.text_executable?.!);Fi
[
[	@◊OiHI"    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var));Fi[	@◊OiVI"    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var));Fi[	@◊OidI"    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var));Fi[	@◊OirI"    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert((var.arch == :dunno));Fi[	@◊Oi±I"    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert_equal([], var.archs)
    assert((var.arch == :dunno));Fi[@'@(I"
false;FI"end;Fi
[
[	@oi;I"∑    @var.each do |arglist|
      if ((var[-var.length, var.length] == var) or (var[-var.length, var.length] == var)) then
        return true
      end
    end
    false
  end
  
  ##;Fi[	@Gi-I"€          var.each do |arglist|
            var = File.join(var, (var + var))
            return true if File.executable?(var)
          end
        end
        false
      end
      
      def self.on_windows?(arglist);Fi[	@≥iQI"ò          return options.skip_info.call(uid)
        else
          return true
        end
      end
      false
    end
    
    def function(arglist);Fi[	@?i>I"f            var.pos -= 1
          end
        end
      end
    end
    false
  end
  
  private;Fi[	@ói!I"I              var = var.state_machine(var).states
              var = var.flatten.map { |arglist| var.fetch(var).value }
              ::ActiveRecord::NamedScope::Scope.new(var, :conditions => (var.call(var)))
            end
          end
          false
        end
        def function(arglist)
          if defined? I18n then;Fi[@'@¸@ˇ,I"teardown_db;Fi
[
[	@ái2I"Æ  def function(arglist)
    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  ;Fi[	@áiºI"∆    (1..4).each do |arglist|
      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  ;Fi[	@äi?I"©    @var = TreeMixin.create!(:parent_id => (@var.id))
    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  ;Fi[	@äióI"    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  ;Fi[	@äiΩI"ò    setup_db
    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  ;Fi[@	)I"var = @var;TI"@var.each do |arglist|;FI"newobj;Fi
[
[	@LiÔI"—  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@Oi¯I"—  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@RiﬁI"—  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[	@UiAI"„    out("endobj")
  end
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out(((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences " + "[") + var) + "]>>"))
      out("endobj");Fi[	@ci$I"Î  	# putfonts
  	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj");Fi[@'@(I"	true;FI"end;Fi
[
[	@3i±I"ú              var.version_requirement = var.requirement
            end
            raise(var)
          end
        end
        true
      end
    end
    ;Fi[	@Â8i%I"≈        ensure_each_session do |arglist|
          var = var.listeners.keys
          var.postprocess(var.&(var), var.&(var))
        end
      end
      true
    end
    
    def function(arglist);Fi[	@¬iòI"            self.authentication_hash[var] = var
          else
            return false unless (var == false)
          end
        end
        true
      end
      
      # Holds the authenticatable name for this class. Devise::Strategies::DatabaseAuthenticatable;Fi[	@∫	iI"ƒ            var = var
            var = var[var]
            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end;Fi[	@¬i$I"°              end
            else
              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end;Fi[I"# == Examples;FI"#;FI"#   class Vehicle;F@tLi
[
[	@â iI"2    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@â i<I"2    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :park do
    #         transition :idling => :parked;Fi[	@î iI"˘    # false, otherwise true.  If the given state is unknown, then an IndexError
    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@î i'I"    # state machine.  This will attempt to find a known state that matches
    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[	@î iBI"Î    # state machine.  If no state is found, then an ArgumentError will be
    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end;Fi[I"
yield;FI"end;FI"end;FI"end;Fi
[
[	@∞iI"â      def function(arglist)
        transaction do |arglist|
          lock!(var)
          yield
        end
      end
    end
  end
end;Fi[	@·iI"{  
  unless Deprecate.respond_to?(:skip_during) then
    def (Deprecate).skip_during(arglist)
      yield
    end
  end
end;Fi[	@íi[I"I    end
    
    def function(arglist)
      yield
    end
  end
end;Fi[	@Å(iRI"»    # The hook which is called inside devise.
    # So your ORM can include devise compatibility stuff.
    def function(arglist)
      yield
    end
  end
end
require("devise/models/authenticatable");Fi[	@ÿiÆI"è          success?
        end
      else
        yield
      end
    end
  end
  
  class AttributeTransitionCollection < TransitionCollection;Fi[@	)I"super(var);FI"(instance_eval(&var) if block_given?;FI"end;Fi
[
[	@ÑiI"       # Campfire account's subdomain
      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private;Fi[	@éilI"&      # Folder where mail will be kept when using the `:file` `delivery_method` option.
      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private;Fi[	@ëiI"Ÿ      ##
      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private;Fi[	@îiI"≈      # The message title
      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private;Fi[	@óiI"≈      # Twitter consumer key credentials
      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private;Fi[@'@(I"
super;FI"end;Fi
[
[	@ùi!I"Õ          var.flatten.each do |arglist|
            raise_on_type_mismatch(var)
            var.save! if var.new_record?
          end
        end
        super
      end
      
      def function(arglist);Fi[	@•iI"        if (var = var.first).is_a?(Hash) then
          if var = subclass_from_attrs(var) then
            return var.new(*var, &var)
          end
        end
        super
      end
      
      # True if this isn't a concrete subclass needing a STI type condition.;Fi[	@$iI"‹          if respond_to?(var) and (respond_to?("#{column}=") and self.send(var).nil?) then
            write_attribute(var.to_s, var)
          end
        end
      end
      super
    end
    
    def function(arglist);Fi[	@$i(I"Ø          var = var.to_s
          next if attribute_changed?(var)
          write_attribute(var, var)
        end
      end
      super
    end
    
    def function(arglist);Fi[	@ÙiÕI"√            if var and var[:autosave].!=(false) then
              autosave(var.merge!(:autosave => (true)))
            end
          end
        end
        super
      end
      
      private;Fi[I"teardown_db;FI"end;FI" ;FI"def function(arglist);Fi
[
[	@ái5I"‚  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@áiøI"Â  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower;Fi[	@äiBI"ß  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var])
    assert_equal(@var.children, [@var]);Fi[	@äiöI"Û  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "mixins.parent_id IS NULL", :order => "mixins.id")
    assert_equal([@var, @var, @var], var);Fi[	@äi¿I"ï  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root))
  end;Fi[I"&def self.required_fields(arglist);FI"[];FI"end;FI" ;Fi
[
[	@ÉiI"&        before_validation(:strip_whitespace)
      end
      
      def self.required_fields(arglist)
        []
      end
      
      # Check if the current object is valid for authentication. This method and
      # find_for_authentication are the methods used in a Warden::Strategy to check;Fi[	@ïiI"⁄    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        Devise::Models.config(self, :omniauth_providers);Fi[	@õi
I"Ì    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods
        # A convenience method that receives both parameters and session to;Fi[	@£iI"    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      # Checks whether the user session has expired based on configured time.
      def function(arglist);Fi[	@¨i
I"9    module Validatable
      VALIDATIONS = [:validates_presence_of, :validates_uniqueness_of, :validates_format_of, :validates_confirmation_of, :validates_length_of].freeze
      
      def self.required_fields(arglist)
        []
      end
      
      def self.included(arglist)
        var.extend(ClassMethods);Fi[@'@(@)I"def function(arglist);Fi
[
[	@≤Di'I"Ÿ      Marshal.dump(var, var)
      var.close
      exit!(1)
    end
  end
end
def function(arglist)
  if (var.env.userpaths? or var.recursive_requirements.any? { |arglist| var.env.userpaths? }) then
    ENV.userpaths!;Fi[	@≤DinI"Î        ARGV.debug? ? (debrew(var, var)) : (raise(var))
      end
      var.prefix.install_metafiles(Pathname.pwd)
    end
  end
end
def function(arglist)
  begin
    (var = if var.linked_keg.directory? and var.linked_keg.symlink? then;Fi[	@èiYI"¬    rescue LoadError
      false
    end
    end
  end
end
def function(arglist)
  puts("#{exception.backtrace.first}")
  puts("#{Tty.red}#{exception.class.to_s}#{Tty.reset}: #{exception.to_s}");Fi[	@áiI"      var.column(:parent_id, :integer)
      var.column(:created_at, :datetime)
      var.column(:updated_at, :datetime)
    end
  end
end
def function(arglist)
  ActiveRecord::Base.connection.tables.each do |arglist|
    ActiveRecord::Base.connection.drop_table(var);Fi[	@äi!I"    create_table(:mixins) do |arglist|
      var.column(:type, :string)
      var.column(:parent_id, :integer)
    end
  end
end
def function(arglist)
  ActiveRecord::Base.connection.tables.each do |arglist|
    ActiveRecord::Base.connection.drop_table(var);Fi[@'@¸I"attr_reader(:options);FI" ;Fi
[
[	@Ki4I"≠        end
        
        class MethodAttribute < Attribute
        end
        
        attr_reader(:options)
        
        def function(arglist)
          @var = var;Fi[	@ÎiI"Ë          var.parse_options!
          var
        end
      end
      
      attr_reader(:options)
      
      # The hash of (parsed) command-line options
      # Return an OptionParser instance that defines the acceptable command;Fi[	@iI"¨        def function(arglist)
          (options[:to] or from)
        end
      end
      
      attr_reader(:options)
      
      def function(arglist)
        @var = [];Fi[	@ciI"¥        @var = var.options.dup
        @var.delete(:location)
        @var.delete(:scope)
      end
      
      attr_reader(:options)
      
      attr_reader(:description)
      ;Fi[	@ii
I"∂    class ExampleProxy
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      attr_reader(:options)
      
      attr_reader(:description)
      ;Fi[I"O# * <tt>:if</tt> - Specifies a method, proc or string to call to determine;FI"M#   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,;FI"O#   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,;FI"O#   proc or string should return or evaluate to a +true+ or +false+ value.;Fi
[
[	@piPI"∞      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	@ï7i)I"Õ      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	@ï7icI"Õ      #   (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt>)
      # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	@*i)I"∞      # * <tt>:on</tt> - Specifies when this validation is active. Runs in all
      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[	@2iÑI"¢      #   attribute is +nil+ (default is +false+).
      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should ot occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[@µ @°+I"teardown_db;FI"end;Fi
[
[	@ái3I"Æ    setup_db
    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@áiΩI"¡      (((var % 2) == 1) ? (ListMixinSub1) : (ListMixinSub2)).create!(:pos => (var), :parent_id => 5000)
    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@äi@I"ã    @var = TreeMixin.create!
    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@äiòI"„    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[	@äiæI"£    @var = TreeMixinWithoutOrder.create!
    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist);Fi[@'@¸@ˇ,I"[];Fi
[
[	@B)i	I"|  module NullRelation
    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    ;Fi[	@äiI"û      class EmptyBackground
        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        ;Fi[	@ÿ#i@I"W  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end
  ;Fi[	@ÿ#iDI"W  
  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end
  ;Fi[	@iI"Ä      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      ;Fi[@	)@
)@)I"def function(arglist);Fi
[
[	@”i/I"Ω      def function(arglist)
        super(var)
      end
      def function(arglist)
        # do nothing
      end
      def function(arglist)
        puts("No plugin responded")
      end;Fi[	@µi1I"‡        def function(arglist)
          (action == :save) ? (:create_or_update) : (super)
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          false
        end;Fi[	@µi:I"»        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          var.to_s.humanize.downcase
        end;Fi[	@≈i"I"        def self.active?(arglist)
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == 2) and (::Sequel::MINOR <= 11)))
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing
        end;Fi[	@≈i%I"€        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          (action == :save) ? (:save) : (super)
        end;Fi[@µ @ÜYI"[];FI"end;Fi
[
[	@ÉiI"¸        before_validation(:downcase_keys)
        before_validation(:strip_whitespace)
      end
      
      def self.required_fields(arglist)
        []
      end
      
      # Check if the current object is valid for authentication. This method and;Fi[	@ïi
I"±  module Models
    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods;Fi[	@õi	I"±  module Models
    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      module ClassMethods;Fi[	@£i
I"‰  module Models
    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      
      # Checks whether the user session has expired based on configured time.;Fi[	@¨i	I"(  module Models
    module Validatable
      VALIDATIONS = [:validates_presence_of, :validates_uniqueness_of, :validates_format_of, :validates_confirmation_of, :validates_length_of].freeze
      
      def self.required_fields(arglist)
        []
      end
      
      def self.included(arglist);Fi[I".assert(Category.left_and_rights_valid?.!);FI"end;FI" ;FI"def function(arglist);Fi
[
[	@öiﬂI"    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil;Fi[	@öiÊI"4    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt];Fi[	@öiÌI"Q    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft];Fi[	@öiÙI"G    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt];Fi[	@öi˚I"    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    var = Category.create
    var = Category.create;Fi[I"if (@var > @var) then;FI"@var = @var;FI"@var = (@var + var);FI"!var = ((@var - @var) - @var);Fi
[
[	@LiÃI"T      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[	@Oi‘I"'      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var);Fi[	@RiªI"T      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[	@Ui¶I"4      var = (var + GetCharWidth(var, var))
      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1);Fi[	@ciøI")      var = GetStringWidth(var[var, (var - var)])
      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (var - (3 * @var))
            var = (var + 1);Fi[@	)I"@var = {};FI"end;FI" ;Fi
[
[	@ri£I"µ        end
        
        class TypeMap
          def function(arglist)
            @var = {}
          end
          
          def function(arglist)
            @var[var] = var;Fi[	@%iI"§      search(var).size
    end
    
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      if var = @var[var.name] and var.any? then;Fi[	@îiI"‘        
        Node = Struct.new(:key, :value, :next, :prev)
        
        def function(arglist)
          @var = {}
        end
        
        def function(arglist)
          @var[var] and @var[var].value;Fi[	@§i∞I"‹    end
    
    # Removes previously aliased actions including the defaults.
    def function(arglist)
      @var = {}
    end
    
    def function(arglist)
      var = ModelAdapters::AbstractAdapter.adapter_class(var);Fi[	@ƒiI"Ωmodule Paperclip
  module Interpolations
    class PluralCache
      def function(arglist)
        @var = {}
      end
      
      def function(arglist)
        @var[var] ||= var.pluralize;Fi[@µ I"5sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5");FI" ;FI"bottle do |arglist|;Fi
[
[	@ÒNiïI"  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    url("file:///foo.com/testball-0.1-bottle.tar.gz")
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");Fi[	@ÒNi‚I"Á  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
  end;Fi[	@ÒNiÒI"‡  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :lion)
  end;Fi[	@ÒNi I"  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion);Fi[	@ÒNiI"  homepage("http://example.com")
  
  url("file:///foo.com/testball-0.1.tbz")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);Fi[@è7@ê7@F9I"protected;Fi
[
[	@€iI"~      end
      
      def function(arglist)
        super
      end
      
      protected
      
      def function(arglist);Fi[	@ iàI"•        def function(arglist)
          @var = nil
          @var = nil
          super
        end
        
        protected
        
        def function(arglist);Fi[	@ûiI"       
      def self.extended(arglist)
        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>;Fi[	@¬iI"ƒ      
      def self.extended(arglist)
        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>;Fi[	@ i4I"›      # Pluralizes the name using the built-in inflector
      def function(arglist)
        load_inflector
        super
      end
      
      protected
      
      # Initializes class-level extensions for this machine;Fi[I"require("sequel");FI"require("fileutils");FI"require("yaml");FI"module Jekyll;Fi
[
[	@ÌiI"órequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Drupal
    QUERY = "SELECT n.nid,                     n.title,                     nr.body,                     n.created,                     n.status              FROM node AS n,                   node_revisions AS nr              WHERE (n.type = 'blog' OR n.type = 'story')              AND n.vid = nr.vid";Fi[	@˚iI"Ürequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Joomla
    def self.process(arglist);Fi[	@iI"xrequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module MT
    QUERY = "SELECT entry_id,                     entry_basename,                     entry_text,                     entry_text_more,                     entry_authored_on,                     entry_title,                     entry_convert_breaks              FROM mt_entry";Fi[	@iI"\require("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module TextPattern
    QUERY = "SELECT Title,                     url_title,                     Posted,                     Body,                     Keywords              FROM textpattern              WHERE Status = '4' OR                    Status = '5'";Fi[	@iI"ârequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module WordPress
    def self.process(arglist);Fi[I"(var << var);FI"end;FI"end;FI"end;Fi
[
[	@>i$I"œ          else
            if (var < var) then
              execute("INSERT INTO #{sm_table} (version) VALUES ('#{v}')")
              (var << var)
            end
          end
        end
      end
      ;Fi[	@[iQI"Í                  add_item_to_array(var, var, var)
                  return [var, var]
                else
                  (var << var)
                end
              end
            end
            var = (var + 1)
          end;Fi[	@#iªI"◊      def function(arglist)
        if self.class.current_feature then
          var = self.class.recipes_per_feature[self.class.current_feature] ||= []
          (var << var)
        end
      end
    end
  end
end;Fi[	@∂iII"ﬁ      var.find do |arglist|
        next if (var.symlink? or var.directory?)
        if (var.dylib? or (var.mach_o_bundle? or var.mach_o_executable?)) then
          (var << var)
        end
      end
    end
    var
  end;Fi[	@ÁiTI"ﬁ                    var = true
                  end
                else
                  (var << var)
                end
              end
            end
          end
          var = [var.strip, var.strip, var.strip];Fi[@'@(@éI"# :nodoc:;Fi
[
[	@oiÖI"è      var.finish)
    rescue IOError
      # do nothing
    end
  end
  
  # :nodoc:
  def function(arglist)
    if (RUBY_VERSION > "2.0") then;Fi[	@Ji-I"≥    var.keys.inject({}) do |arglist|
      var[File.expand_path(var)] = []
      var
    end
  end
  
  # :nodoc:
  def function(arglist)
    if File.exist?("spec/spec.opts") then;Fi[	@fiI"—          var
        else
          Spec.warn(Spec::Example::NoDescriptionError.message("example", @var.location))
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var.options;Fi[	@˜iòI"í          var.call
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        if ENV["SPEC"] then;Fi[	@i+I"π          mock_framework_path(var.to_s)
        else
          var
        end
      end
      
      # :nodoc:
      def function(arglist)
        @var ||= mock_framework_path("rspec");Fi[I"$# @example Define the relation.;FI"#;FI"#   class Person;FI"$#     include Mongoid::Document;Fi
[
[	@oi%I"C        # document. If a child does not define this relation calling
        # persistence methods on the child object will cause a save to fail.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses
        #   end;Fi[	@oiCI"        # of the relation needs to be a pluralized form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses
        #   end;Fi[	@oi_I"        # of the relation needs to be a singular form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_one :name
        #   end;Fi[	@oièI"(        # Adds a relational association from a parent Document to many
        # Documents in another database or collection.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_many :posts
        #   end;Fi[	@oi´I":        # Adds a relational many-to-many association between many of this
        # Document and many of another Document.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_and_belongs_to_many :preferences
        #   end;Fi[@ÚV@ZYI"end;FI" ;Fi
[
[	@ÑiI"¨      ##
      # Campfire account's room id
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@éimI"’      # Default location is '$HOME/Backup/emails'
      # Example: '/tmp/test-mails'
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@ëiI"◊      # API-Key
      # Create a Prowl account and request an API key on prowlapp.com.
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@îiI"≤      ##
      # The priority of the notification
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@óiI"£      ##
      # OAuth credentials
      def function(arglist)
        super(var)
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[@YHI"if var then;F@€LI"var = "LTRB";Fi
[
[	@LiaI"‡    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@OiVI"‡    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@RiPI"‡    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@ci-I"ø    var = (var - (3 * @var))
    var = var.gsub("\r", "")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[	@ci¯I"∫    SetX(var)
    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR";Fi[I"2var.step(var, var) { |arglist| (var << var) };FI"return var;FI"end;FI" ;Fi
[
[	@˘i#I"        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        (var / 2.0);Fi[	@i I"        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields];Fi[	@	i[I"         var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        var = { :x => 0, :y => 0 };Fi[	@iqI"’      def function(arglist)
        var, var, var = x_range
        var = []
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      alias :get_x_labels :get_x_values
      ;Fi[	@iàI"’      def function(arglist)
        var, var, var = y_range
        var = []
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      alias :get_y_labels :get_y_values
      ;Fi[@‹.I"/render(:nothing => (true), :status => 422);FI"end;FI"end;Fi
[
[	@ iI"€          render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	@ÌiI"≈          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	@ÂiÅI"ˇ    if params[:diaspora_handle] then
      Webfinger.in_background(params[:diaspora_handle], :single_aspect_form => (true))
      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	@ÚiII"™      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist);Fi[	I";data//diaspora_proj/controllers/reshares_controller.rb;TiI"O      current_user.add_to_streams(@var, current_user.aspects)
      current_user.dispatch_post(@var, :url => (post_url(@var)), :additional_subscribers => (@var.root_author))
      render(:json => (ExtremePostPresenter.new(@var, current_user)), :status => 201)
    else
      render(:nothing => (true), :status => 422)
    end
  end
end;Fi[@µ @°+I"@var.each(&var);FI"end;Fi
[
[	@}iI"ü      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist);Fi[	@ìi$I"∂      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist);Fi[	@ñiYI"À            var.value ? (escape_cell(var.value.to_s).unpack("U*").length) : (0)
          end.max
        end
        
        def function(arglist)
          @var.each(&var)
        end
      end
      ;Fi[	@ÄiÆI"}  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist);Fi[	@™iI"ç  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist);Fi[@À8I"	else;FI"
false;TI"end;Ti
[
[	@Ÿi*I"y      else
        if (var - var).any? then
          ActiveSupport::Deprecation.warn("It looks like you are eager loading table(s) (one of: #{string_tables.join(", ")}) that are referenced in a string SQL snippet. For example: \n\n    Post.includes(:comments).where(\"comments.title = 'foo'\")\n\nCurrently, Active Record recognises the table in the string, and knows to JOIN the comments table to the query, rather than loading comments in a separate query. However, doing this without writing a full-blown SQL parser is inherently flawed. Since we don't want to write an SQL parser, we are removing this functionality. From now on, you must explicitly tell Active Record when you are referencing a table from a string:\n\n    Post.includes(:comments).where(\"comments.title = 'foo'\").references(:comments)\n\n")
          true
        else
          false
        end
      end
    end;Ti[	@üiéI"ß    def function(arglist)
      case peek
      when LONG_RE, SHORT_RE, EQ_RE, SHORT_NUM, SHORT_SQ_RE then
        true
      else
        false
      end
    end
    ;Fi[	@7i>I"¡        protect(var) do |arglist|
          if @var.key?(var) then
            @var[var] = @var.delete(var)
            true
          else
            false
          end
        end
      end;Fi[	@ªiMI"ù    end
    if self.profile.update_attributes(var) then
      Postzord::Dispatcher.build(self, profile).post
      true
    else
      false
    end
  end
  ;Fi[	@UiÊI"ì  
  def function(arglist)
    if ((@var + var) > @var) and (@var.! and self.AcceptPageBreak) then
      true
    else
      false
    end
  end
  ;Fi[@»J@…JI"8# @return [ Object ] The return value of the block.;FI"#;Fi
[
[	@≈i2I"Ê      # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@≈iQI"È      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist);Fi[	@≈i|I"Á      # @example Execute in loading mode.
      #   _loading do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.3.2
      def function(arglist);Fi[	@≈iñI"Ù      # @example Execute in loading revision mode.
      #   _loading_revision do
      #     load_revision
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.3.4
      def function(arglist);Fi[	@≈i™I"˙        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist);Fi[I"# @since 2.4.0;FI"def function(arglist);FI"@var ||= {};FI"end;Fi
[
[	@ái4I"¿    #
    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the pulls that need to happen.;Fi[	@ái@I"≈    #
    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # For array fields these are the unique adds that need to happen.;Fi[	@áiLI"     #
    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the atomic updates that need to happen for the current;Fi[	@§i4I"¡    #
    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get all the changes for the document.;Fi[	@§imI"Ò    #
    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    
    # Remove a change from the dirty attributes hash. Used by the single field;Fi[@À8@Ã8@Õ8I"module ClassMethods;Fi
[
[	@¨i,I"≥      end
      
      def function(arglist)
        true
      end
      
      module ClassMethods
        Devise::Models.config(self, :email_regexp, :password_length)
      end;Fi[	@)	izI"ƒ      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the provided object to a propery array of foreign keys.
        #;Fi[	@G	iI"Œ      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@Q	i)I"Œ      #
      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.;Fi[	@d	i*I"«      #
      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Convert the object from its mongo friendly ruby type to this type.
        #;Fi[@µ @ X@ÀXI"# object;Fi
[
[	@ûi'I"          var.default
        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_static_state_initializer;Fi[	@≤iSI"Ò      def function(arglist)
        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (426 + 1));Fi[	@∫i%I"Ê      def function(arglist)
        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (325 + 1));Fi[	@¬i)I"’      def function(arglist)
        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              @attributes ||= {}\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false)\n              \n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (386 + 1));Fi[	@ iII"Ï      def function(arglist)
        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist)
        define_helper(:instance, "            def initialize_set(*)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (344 + 1));Fi[I"rescue;FI"# do nothing;FI"end;FI"end;Fi
[
[	@IiI"£      def function(arglist)
        begin
          execute("BEGIN")
        rescue
          # do nothing
        end
      end
      
      def function(arglist);Fi[	@IiI"Ê        begin
          (execute("SET TRANSACTION ISOLATION LEVEL #{transaction_isolation_levels.fetch(isolation)}")
          begin_db_transaction)
        rescue
          # do nothing
        end
      end
      
      #:nodoc:;Fi[	@IiI"ó      def function(arglist)
        begin
          execute("COMMIT")
        rescue
          # do nothing
        end
      end
      
      #:nodoc:;Fi[	@IiI"¶      def function(arglist)
        begin
          execute("ROLLBACK")
        rescue
          # do nothing
        end
      end
      
      def function(arglist);Fi[	I"*data//redmine_proj/redmine/version.rb;TiI"¸        begin
          (var = Redmine::Scm::Adapters::AbstractAdapter.shell_quote(Rails.root.to_s)
          return $1.to_i if `svn info --xml #{var}` =~ /revision="(\d+)"/)
        rescue
          # do nothing
        end
      end
      nil
    end;Fi[@'@¸@ˇ,I"if var.empty? then;Fi
[
[	@Vi÷I"0        return @var if @var
        var = exec_query("SHOW VARIABLES WHERE Variable_name = 'character_set_client'", "SCHEMA")
        @var = ENCODINGS[var.rows.last.last]
      end
      
      def function(arglist)
        if var.empty? then
          var, var = exec_without_stmt(var, var)
        else;Fi[	@Ûi¸I"Á      var.join_associations.each { |arglist| var.join_to(var) }
      var.join_sources.concat(var)
      var
    end
    
    def function(arglist)
      if var.empty? then
        var.project(@var.arel_table[Arel.star])
      else;Fi[	@8iBI"É          end
        end
      end
    end
    
    def function(arglist)
      if var.empty? then
        dependencies
      else;Fi[	@‚iI"&            add_column(var, "#{attachment_name}_#{column_name}", var)
          end
        end
      end
      
      def function(arglist)
        if var.empty? then
          raise(ArgumentError, "Please specify attachment name in your remove_attachment call in your migration.")
        end;Fi[	@JiI"†      (var[$2] << var) if var =~ /\n(\.\/)?(.*spec\.rb):[\d]+:/
    end
    return var
  end
  
  def function(arglist)
    if var.empty? then
      ""
    else;Fi[@µ I"G# Creates a scope for finding records *with* a particular state or;FI"# states for the attribute;FI"def function(arglist);Fi
[
[	@ûiGI"f      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] })
      end;Fi[	@≤isI"(      def function(arglist)
        (action == :save) ? (:save_self) : (super)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) }
      end;Fi[	@∫i@I"{      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "$in" => (var) }) }) };Fi[	@¬iDI"h      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } })
      end;Fi[	@ iuI"_      def function(arglist)
        (owner_class.db.literal(var.value) == owner_class_attribute_default)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) })
      end;Fi[@µ I"J# Creates a scope for finding records *without* a particular state or;FI"# states for the attribute;FI"def function(arglist);Fi
[
[	@ûiMI"k      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} NOT IN (?)", var] })
      end;Fi[	@≤iyI"<      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) }
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute.to_sym.not => (var)) }
      end;Fi[	@∫iHI"_          { :conditions => ({ attribute => ({ "$in" => (var) }) }) }
        end)
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "$nin" => (var) }) }) };Fi[	@¬iJI"l      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$nin" => (var) }) } })
      end;Fi[	@ i{I"l      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.exclude(attribute_column => (var)) })
      end;Fi[@µ @°+I"+source_tags.map { |arglist| var.name };FI"end;Fi
[
[	@iihI"ö      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
    end
  end;Fi[	@ui>I"∂      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@xiHI"Ó      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@Éi(I"Ω      def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist);Fi[	@ÉiRI"ª          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist);Fi[@'I"@var = var;FI"end;FI" ;Fi
[
[	@uiUI"˝      def function(arglist)
        if Cucumber::WINDOWS and (var and ENV["CUCUMBER_FORWARD_SLASH_PATHS"].!) then
          var = var.gsub(/\//, "\\")
        end
        @var = var
      end
      
      def function(arglist)
        "#{@file}:#{line}";Fi[	@ÊiåI"π        if var.!=(:failed) and @var.^(var) then
          @var = true
          return
        end
        @var = var
      end
      
      def function(arglist)
        return if @var;Fi[	@i}I"*      def function(arglist)
        if var and Cucumber::RUBY_1_9 then
          raise(((failed + "RCov only works on Ruby 1.8.x. You may want to use SimpleCov: https://github.com/colszowka/simplecov") + reset))
        end
        @var = var
      end
      
      attr_accessor(:rcov_opts)
      ;Fi[	@Li¡I"’    def function(arglist)
      unless self.class.valid_formats.include?(var) then
        raise(Haml::Error, "Invalid output format #{value.inspect}")
      end
      @var = var
    end
    
    undef :cdata
    ;Fi[	@‰isI"l      unless ((flat? and (closes_flat?(var).! and closes_flat?(@var).!)) or (var and ((@var.text[0] == ":") and var.full =~ /^#{@var.full[/^\s+/]}\s/))) then
        return next_line if var.text.empty?
        handle_multiline(var)
      end
      @var = var
    end
    
    def function(arglist)
      var and (var.text.empty?.! and (not var.full =~ /^#{@var}/));Fi[@»J@…J@CJI"#   person.name = 'Bob';Fi
[
[	@˝i0I"Ò      #     def clear_attribute(attr)
      #       send("#{attr}=", nil)
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.clear_name;Fi[	@˝iTI"ˇ      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name          # => "Bob"
      #   person.name_short?   # => true;Fi[	@˝iêI"      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name            # => "Bob"
      #   person.nickname        # => "Bob";Fi[	@˝i‘I"˚      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name        # => "Bob"
      #   person.name_short? # => true;Fi[	@˝i˜I"€      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob'
      #   person.name_short? # => true
      #;Fi[I"yield(var);FI"end;FI"end;FI" ;Fi
[
[	@™i4I"        Net::FTP.send(:const_set, :FTP_PORT, port)
        Net::FTP.open(ip, username, password) do |arglist|
          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server;Fi[	@ªi4I"+      # Establishes a connection to the remote server
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server;Fi[	@√i(I"3      # Net::SCP will use this connection to transfer backups
      def function(arglist)
        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server;Fi[	@»i&I",      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server;Fi[	@;i*I"     # This method is used by the refresh rake tasks.
    def function(arglist)
      class_for(var).unscoped.where("#{name}_file_name IS NOT NULL").find_each do |arglist|
        yield(var)
      end
    end
    
    def function(arglist)
      var.split("::").inject(Object) do |arglist|;Fi[@'@¸@=[@>[i
[
[	@ûiLI"Ç      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} NOT IN (?)", var] });Fi[	@≤ixI"S      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) }
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute.to_sym.not => (var)) };Fi[	@∫iGI"G        define_scope(var, lambda do |arglist|
          { :conditions => ({ attribute => ({ "$in" => (var) }) }) }
        end)
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|;Fi[	@¬iII"É      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$nin" => (var) }) } });Fi[	@ izI"É      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) })
      end
      
      # Creates a scope for finding records *without* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.exclude(attribute_column => (var)) });Fi[@√NI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;FI"#;Fi
[
[	@3	iI"module Mongoid
  module Extensions
    module Boolean
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Boolean.mongoize("123.11");Fi[	@G	i I"Ï        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Float.mongoize("123.11");Fi[	@L	ißI"        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Hash.mongoize([ 1, 2, 3 ]);Fi[	@Q	i,I"Ò        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11");Fi[	@i	iI"module Mongoid
  module Extensions
    module Regexp
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.
        #   Regexp.mongoize(/^[abc]/);Fi[@ÉII"end;FI"end;FI"end;Fi
[
[	@$içI"              var[var].stop = var[(var - 1)].stop.plus(var[var].stop.minus(var[(var - 1)].stop).div(Sass::Script::Number.new(var)))
              break
            else
              var = (var + 1)
            end
          end
        end
      end
      var.each do |arglist|;Fi[	@™iI"◊      var = [var] unless var.kind_of?(Array)
      var.each do |arglist|
        (@var << Patch.new(var, ("%03d-homebrew.diff" % var), var))
        var = (var + 1)
      end
    end
  end
  
  def function(arglist);Fi[	@UiwI"Æ          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1)
        end
      end
    end
    if (@var > 0) then
      @var = 0;Fi[	@˘iAI"∂            make_datapoint_text((var + (var / 2.0)), (var - 6), var.to_s)
            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[	@iAI"…            make_datapoint_text(((var + var) + 5), (var + var), var, "text-anchor: start; ")
            var = (var + 1))
          end
          var = (var + 1)
        end
      end
    end
  end
end;Fi[@'@¸@.[@/[i
[
[	@ûiFI"ò      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| ["#{attribute_column} IN (?)", var] });Fi[	@≤irI"Y      # Uses internal save hooks if using the :save action
      def function(arglist)
        (action == :save) ? (:save_self) : (super)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        lambda { |arglist| var.all(attribute => (var)) };Fi[	@∫i?I"r      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda do |arglist|;Fi[	@¬iCI"ö      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        define_scope(var, lambda { |arglist| { attribute => ({ "$in" => (var) }) } });Fi[	@ itI"¢      # Uses the DB literal to match the default against the specified state
      def function(arglist)
        (owner_class.db.literal(var.value) == owner_class_attribute_default)
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist)
        create_scope(var, lambda { |arglist| var.filter(attribute_column => (var)) });Fi[I"# @rate_limited No;FI",# @authentication Requires user context;FI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;FI"6# @return [Twitter::User] The authenticated user.;Fi
[
[	@Ai>I"      # Sets which device Twitter delivers updates to for the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_delivery_device
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param device [String] Must be one of: 'sms', 'none'.
      # @param options [Hash] A customizable set of options.;Fi[	@AiNI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile
      # @note Only the options specified will be updated.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :name Full name associated with the profile. Maximum of 20 characters.;Fi[	@Ai`I"      # Updates the authenticating user's profile background image
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_background_image
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param image [File] The background image for the profile, base64-encoded. Must be a valid GIF, JPG, or PNG image of less than 800 kilobytes in size. Images with width larger than 2048 pixels will be forcibly scaled down. The image must be provided as raw multipart data, not a URL.
      # @param options [Hash] A customizable set of options.;Fi[	@AipI"=      # Sets one or more hex values that control the color scheme of the authenticating user's profile
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_colors
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :profile_background_color Profile background color.;Fi[	@AiÄI"_      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_image
      # @note Updates the authenticating user's profile image. Note that this method expects raw multipart data, not a URL to an image.
      # @note This method asynchronously processes the uploaded file before updating the user's profile image URL. You can either update your local cache the next time you request the user's information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/show.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param image [File] The avatar image for the profile, base64-encoded. Must be a valid GIF, JPG, or PNG image of less than 700 kilobytes in size. Images with width larger than 500 pixels will be scaled down. Animated GIFs will be converted to a static GIF of the first frame, removing the animation.
      # @param options [Hash] A customizable set of options.;Fi[@µ @°+I"	to_s;FI"end;Fi
[
[	@!iI"ã      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[	@$iI"ê      end
      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    
    def self.color_to_s(arglist);Fi[	@$i9I"        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[	@ºi%I"}    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist);Fi[	@ñPiI"zend
class Moped::BSON::ObjectId
  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist);Fi[@'@¸@ X@ÀXi
[
[	@ûi&I"o        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default
        end
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist);Fi[	@≤iRI"\      # Pluralizes the name using the built-in inflector
      def function(arglist)
        ::DataMapper::Inflector.pluralize(var.to_s)
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist);Fi[	@∫i$I"a      # Gets the Mongoid key for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.keys[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist);Fi[	@¬i(I"]      # Gets the field for this machine's attribute (if it exists)
      def function(arglist)
        owner_class.fields[attribute.to_s]
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist);Fi[	@ iHI"C      # Loads the built-in inflector
      def function(arglist)
        require("sequel/extensions/inflector")
      end
      
      # Defines an initialization hook into the owner class for setting the
      # initial state of the machine *before* any attributes are set on the
      # object
      def function(arglist);Fi[@'@¸I"6# Gets the db default for the machine's attribute;FI"def function(arglist);Fi
[
[	@ûiI"n      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then
          var.default;Fi[	@≤iCI"-      # Is validation support currently loaded?
      def function(arglist)
        @var ||= ::DataMapper.const_defined?("Validate")
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_property and attribute_property.default
      end;Fi[	@∫iI"      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value
      end;Fi[	@¬iI"      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default
      end;Fi[	@ ihI"      # Uses internal save hooks if using the :save action
      def function(arglist)
        (action == :save) ? (:around_save) : (super)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.db.table_exists?(owner_class.table_name) and var = owner_class.db_schema[attribute.to_sym] then
          var[:default];Fi[I"out(">>");FI"out("endobj");FI"newobj;FI"out("<</Type /Font");Fi
[
[	@LiBI"0    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@OiKI"0    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@Ri1I"0    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@ciàI"0    out(((("/BaseFont /" + var["name"]) + "-") + var["cMap"]))
    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]));Fi[	@ciS
I"(    out("/Encoding /Identity-H")
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out((("/ToUnicode " + (@var + 2).to_s) + " 0 R"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType2")
    out((("/BaseFont /" + var["name"]) + ""));Fi[@˜U@¯UI"end;FI"end;Fi
[
[	@Li7I"„            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[	@Oi@I"„            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[	@Ri&I"„            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end
  ;Fi[	@Ui∑I"Ì        var = @var ? (Zlib::Deflate.deflate(var["pal"])) : (var["pal"])
        out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
        putstream(var)
        out("endobj")
      end
    end
  end
  
  def function(arglist);Fi[	@ci…I"Œ        var = @var ? (gzcompress(var["pal"])) : (var["pal"])
        out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
        putstream(var)
        out("endobj")
      end
    end
  end
  
  #;Fi[@'@)J@*JI"end;Fi
[
[	@îiVI"⁄        @var = {}
        [:token, :user, :message, :title, :priority, :device].each do |arglist|
          @var.merge!(var => (self.instance_variable_get("@#{k}")))
        end
        @var
      end
    end
  end
end;Fi[	@ËiI"~          else
            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end
end;Fi[	@Ôi)I"ø        @var = MacOS::Xcode.version
        unless MacOS::Xcode.default_prefix? then
          @var = (@var + " => #{MacOS::Xcode.prefix}")
        end
        @var
      end
    end
  end
  ;Fi[	@”i&I"±      @var ||= DEFAULT_RFPDF_OPTIONS.dup
      @var.merge!((self.class.read_inheritable_attribute(:rfpdf) or {})) do |arglist|
        var
      end
      @var
    end
  end
end;Fi[	@≥iVI"p        var = (var + TimeEntryActivityCustomField.all)
        var.select { |arglist| ["list", "bool"].include?(var.field_format) }.each do |arglist|
          @var["cf_#{cf.id}"] = { :sql => ("#{cf.join_alias}.value"), :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[@'@¸I"L# Skips defining reader/writer methods since this is done automatically;FI"def function(arglist);Fi
[
[	@îiäI"ç          (callbacks[:after] << Callback.new(:after) { |arglist| notify(:after, var, var) })
          (callbacks[:failure] << Callback.new(:failure) { |arglist| notify(:after_failure_to, var, var) })
        end
      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function(arglist)
        var = self.name
        if supports_validations? then;Fi[	@≤iYI"„      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (426 + 1))
      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function(arglist)
        owner_class.property(attribute, String) unless attribute_property
        if supports_validations? then;Fi[	@∫i+I"¡      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*args)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (325 + 1))
      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function(arglist)
        owner_class.key(attribute, String) unless attribute_key
        super;Fi[	@¬i/I"Ω      # object
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              @attributes ||= {}\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false)\n              \n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (386 + 1))
      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function(arglist)
        owner_class.field(attribute, :type => (String)) unless attribute_field
        super;Fi[	@ iOI"∆      # object
      def function(arglist)
        define_helper(:instance, "            def initialize_set(*)\n              self.class.state_machines.initialize_states(self, :static => :force) { super }\n            end\n", "(string)", (344 + 1))
      end
      
      # Skips defining reader/writer methods since this is done automatically
      def function(arglist)
        var = self.name
        owner_class.validates_each(attribute) do |arglist|;Fi[I"if var then;F@€LI"var = "LTRB";FI"var = "LRT";Fi
[
[	@LibI"Œ    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@OiWI"Œ    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@RiQI"Œ    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@ci.I"≠    var = var.gsub("\r", "")
    var = var.length
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[	@ci˘I"∑    SetY(var)
    var = ((@var - var) - @var) if (var == 0)
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else;Fi[@	)I"	name;FI"end;FI" ;Fi
[
[	@Xi]I"x        local_specs
      end
      
      def function(arglist)
        name
      end
      
      private
      ;Fi[	@ﬂ;iI"Ç  
  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var;Fi[	I"Idata//redmine_proj/plugins/awesome_nested_set/spec/support/models.rb;Ti%I"∞    @@var
  end
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } });Fi[	I"Ldata//redmine_proj/plugins/awesome_nested_set/test/fixtures/category.rb;TiI"Ÿclass Category < ActiveRecord::Base
  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } });Fi[	@+iI"ômodule Redmine
  class Notifiable < Struct.new(:name, :parent)
    def function(arglist)
      name
    end
    
    def self.all(arglist)
      var = [];Fi[I"return [var, var];FI"end;FI" ;FI"def function(arglist);Fi
[
[	@[iWI"˙            end
            var = (var + 1)
          end
          return [var, var]
        end
        
        def function(arglist)
          unless (var.length == 0) then
            var.! and (var == "NULL") ? (var.push(nil)) : (var.push(var));Fi[	@‰icI"∂      return unless var
      var = @var
      @var = (@var + 1)
      return [var, var]
    end
    
    def function(arglist)
      var, var = raw_next_line
      return unless var;Fi[	@∏i]I"      end
      var = paginator(var.count, var)
      var = var.limit(var.per_page).offset(var.offset).to_a
      return [var, var]
    end
    
    def function(arglist)
      ActiveSupport::Deprecation.warn("#paginate with a Symbol and/or find options is depreceted and will be removed. Use a scope instead.")
      var = var.is_a?(Symbol) ? (var.to_s.classify.constantize) : (var);Fi[	@Ái%I"/        def function(arglist)
          var = extract_sections(var)[1]
          var = Digest::MD5.hexdigest(var)
          return [var, var]
        end
        
        def function(arglist)
          var = extract_sections(var)
          if var.present? and var.!=(Digest::MD5.hexdigest(var[1])) then;Fi[	@Ui
I"˛    module ArgsAndOptions
      def function(arglist)
        var = Hash.===(var.last) ? (var.pop) : ({})
        return [var, var]
      end
      
      def function(arglist)
        (var << {}) unless Hash.===(var.last)
        var.extend(WithOptions);Fi[@˜UI"newobj;FI"#out("<</Type /FontDescriptor");FI"'out(("/FontName /" + var["name"]));Fi
[
[	@LiXI"’      end
    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]");Fi[	@OiYI"Ô    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]");Fi[	@RiCI"„      var = (var + "]")
    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]");Fi[	@ciñI"Ô    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]");Fi[	@ciÑ
I"    out("/Ordering (UCS)")
    out("/Supplement 0")
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    var["desc"].each { |arglist| out(((("/" + var.to_s) + " ") + var.to_s)) }
    if var["file"] then;Fi[@Ù[@ı[I"end;FI" ;Fi
[
[	@Ui=I"º    out((var + "]"))
    out(("/Count " + var.to_s))
    out(sprintf("/MediaBox [0 0 %.2f %.2f]", var, var))
    out(">>")
    out("endobj")
  end
  
  def function(arglist)
    var = @var;Fi[	@Ui’I"π    out("2 0 obj")
    out("<<")
    putresourcedict
    out(">>")
    out("endobj")
  end
  
  def function(arglist)
    out(("/Producer " + textstring(("Ruby FPDF " + FPDF_VERSION))));Fi[	@ciI"©    out((var + "]"))
    out(("/Count " + var.to_s))
    out(sprintf("/MediaBox [0 0 %.2f %.2f]", var, var))
    out(">>")
    out("endobj")
  end
  
  #
  	# Adds fonts;Fi[	@ci°I"É    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>")
    out("endobj")
  end
  
  #
  	# putimages;Fi[	@ciÛI"s    out("2 0 obj")
    out("<<")
    putresourcedict
    out(">>")
    out("endobj")
  end
  
  #
  	# putinfo;Fi[I")AddCIDFonts(var, var, var, var, var);FI"end;FI" ;FI"def function(arglist);Fi
[
[	@LiI"Ï    var = Big5_widths
    var = "ETenms-B5-H"
    var = { "ordering" => "CNS1", "supplement" => 0 }
    AddCIDFonts(var, var, var, var, var)
  end
  
  def function(arglist)
    var = {}
    32.upto(126) { |arglist| var[var.chr] = 500 };Fi[	@Li%I"Ú    32.upto(126) { |arglist| var[var.chr] = 500 }
    var = "ETen-B5-H"
    var = { "ordering" => "CNS1", "supplement" => 0 }
    AddCIDFonts(var, var, var, var, var)
  end
  
  def function(arglist)
    var = GB_widths
    var = "GBKp-EUC-H";Fi[	@Li,I"    var = GB_widths
    var = "GBKp-EUC-H"
    var = { "ordering" => "GB1", "supplement" => 2 }
    AddCIDFonts(var, var, var, var, var)
  end
  
  def function(arglist)
    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "GBK-EUC-H";Fi[	@OiI"    var = SJIS_widths
    var = "90msp-RKSJ-H"
    var = { "ordering" => "Japan1", "supplement" => 2 }
    AddCIDFonts(var, var, var, var, var)
  end
  
  def function(arglist)
    var = "KozMinPro-Regular-Acro"
    32.upto(126) { |arglist| cw[var.chr] = 500 };Fi[	@RiI"˙    var = UHC_widths
    var = "KSCms-UHC-H"
    var = { "ordering" => "Korea1", "supplement" => 1 }
    AddCIDFonts(var, var, var, var, var)
  end
  
  def function(arglist)
    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "KSCms-UHC-HW-H";Fi[@'@Ù9@ı9I"end;Fi
[
[	@›#iBI"N      else
        self.perform(var)
      end
    end
    self
  end
end;Fi[	@ë
i˚I"‡          var = "#{name.to_s.singularize}_ids="
          re_define_method(var) do |arglist|
            send(var.setter, var.klass.find(var.reject(&:blank?)))
          end
          self
        end
      end
    end
  end;Fi[	@-iSI"°            var.save
            save if new_record? and var.stores_foreign_key?
            var
          end
          self
        end
      end
    end
  end;Fi[	@åiI"∆              field(var.inverse_type, :type => (String))
              field(var.inverse_of_field, :type => (Symbol))
            end
          end
          self
        end
      end
    end
  end;Fi[	@Ci£I"†            var = @var.instance_eval(&var)
            @var.parent = var
            return var
          end
          self
        end
      end
    end
  end;Fi[@'I"@var = [];FI"end;FI" ;Fi
[
[	@LiI"æ            else
              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist)
          send("#{style}_fit");Fi[	@Âi7I"˝          rescue SystemCallError => var
            log("There was an unexpected error while deleting directories: #{e.class}")
          end
        end
        @var = []
      end
      
      def function(arglist)
        FileUtils.cp(path(var), var);Fi[	@ËiPI"ﬁ        for var in @var do
          (log("deleting #{path}")
          directory.files.new(:key => (var)).destroy)
        end
        @var = []
      end
      
      def function(arglist)
        if @var[:fog_host] then;Fi[	@ÎiÎI"©          rescue AWS::Errors::Base => var
            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist)
        begin;Fi[	@*iI"∂            @var = File.open(var, "w")
          else
            @var = var
          end
          @var = []
        end
        
        def function(arglist)
          @var = var;Fi[@µ @°+I"@var ||= {};FI"end;Fi
[
[	@XiI"≥        def function(arglist)
          defaults.reset!
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist);Fi[	@
iJI"Ç      end
      
      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist);Fi[	@
iNI"ù      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist);Fi[	@ iìI"Ì          load_translations(var)
          translations[var] ||= {}
        end
        
        def function(arglist)
          @var ||= {}
        end
        
        # Looks up a translation from the translations hash. Returns nil if;Fi[	@”iI"ì        @var = var
        @var = var
      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist);Fi[@ìU@îU@ïUI"8raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi
[
[	@O7iI"Àmodule Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    cd(HOMEBREW_REPOSITORY)
    exec("cat", ARGV.formulae.first.path, *ARGV.options_only);Fi[	@wiI"∑require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("--deps") then
      var = [];Fi[	@i	I" require("hardware")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    if ARGV.include?("--head") then
      raise("Specify `--HEAD` in uppercase to build from trunk.");Fi[	@}7i	I"Ÿrequire("hardware")
require("keg")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    ENV.extend(HomebrewEnvExtension)
    ENV.setup_build_environment;Fi[	@ä7iI"–require("formula")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?
    var = Formula.select do |arglist|
      ARGV.formulae.all? do |arglist|;Fi[@–0@—0@“0I"###;Fi
[
[	@ciI"=      # Also see related method +add_child+.
      def function(arglist)
        add_child(var)
        self
      end
      
      ###
      # Insert +node_or_tags+ before this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@#:iüI"3          var = var["class"].to_s.split(/\s+/)
          var["class"] = var.push(var).uniq.join(" ")
        end
        self
      end
      
      ###
      # Remove the class attribute +name+ from all Node objects in the NodeSet.
      # If +name+ is nil, remove the class attribute from all Nodes in the;Fi[	@#:i≥I"’            var.delete("class")
          end
        end
        self
      end
      
      ###
      # Set the attribute +key+ to +value+ or the return value of +blk+
      # on all Node objects in the NodeSet.;Fi[	@#:i I"      # Remove the attributed named +name+ from all Node objects in the NodeSet
      def function(arglist)
        each { |arglist| var.delete(var) }
        self
      end
      
      ###
      # Iterate over each node, yielding  to +block+
      def function(arglist);Fi[	@#:iÈI"∫          var.add_next_sibling(var)
          var.add_child(var)
        end
        self
      end
      
      ###
      # Convert this NodeSet to a string.
      def function(arglist);Fi[@'@¸@ˇ,I"@var.clear;Fi
[
[	@(ivI"¨      def function(arglist)
        ActiveSupport::Deprecation.warn("In the next release, this will return the same as #connection_pool_list. (An array of pools, rather than a hash mapping specs to pools.)")
        Hash[connection_pool_list.map { |arglist| [var.spec, var] }]
      end
      
      def function(arglist)
        @var.clear
        owner_to_pool[var.name] = ConnectionAdapters::ConnectionPool.new(var)
      end;Fi[	@_i(I"Ñ    
    def function(arglist)
      servers.empty?
    end
    
    def function(arglist)
      @var.clear
      @var.clear
    end;Fi[	@Èi¬I"ñ      
      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      ;Fi[	@Èi∆I"Ü      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      ;Fi[	@Èi I"Ü      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      ;Fi[@û=I"# == Example;FI"#;FI"#   class Vehicle;Fi
[
[	@&i=I"N    # On the other hand, any <tt>:halt</tt> error that's thrown within an
    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[	@&ioI"    # a StateMachine::InvalidTransition exception will be raised.
    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[	@§isI")        
        # Creates a callback that will be invoked *after* a transition failures to
        # be performed so long as the given requirements match the transition.
        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     ;Fi[	@„i‡I")    # Transitions the current value of the state to that specified by the
    # transition.  Once the state is persisted, it cannot be persisted again
    # until this transition is reset.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine do
    #       event :ignite do;Fi[	@„i˘I"
    
    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do;Fi[@û=I",# Call with a block to register a hook.;FI"=# Call with no arguments to return all registered hooks.;FI"def function(arglist);Fi
[
[	@ûi]I"L  # only once, before forking to run the first job. Be careful- any
  # changes you make will be permanent for the lifespan of the
  # worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(arglist)
    if var then
      register_hook(:before_first_fork, var);Fi[	@ûipI"|  # The `before_fork` hook will be run in the **parent** process
  # before every job, so be careful- any changes you make will be
  # permanent for the lifespan of the worker.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(arglist)
    var ? (register_hook(:before_fork, var)) : (hooks(:before_fork))
  end;Fi[	@ûiI"â  # The `after_fork` hook will be run in the child process and is passed
  # the current job. Any changes you make, therefore, will only live as
  # long as the job currently being processed.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(arglist)
    var ? (register_hook(:after_fork, var)) : (hooks(:after_fork))
  end;Fi[	@ûiüI"q  # The `before_perform` hook will be run in the child process before
  # the job code is performed. This hook will run before any
  # Job.before_perform hook.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(arglist)
    var ? (register_hook(:before_perform, var)) : (hooks(:before_perform))
  end;Fi[	@ûiÆI"l  # The `after_perform` hook will be run in the child process after
  # the job code has performed. This hook will run after any
  # Job.after_perform hook.
  #
  # Call with a block to register a hook.
  # Call with no arguments to return all registered hooks.
  def function(arglist)
    var ? (register_hook(:after_perform, var)) : (hooks(:after_perform))
  end;Fi[@‹.I"var = (var + 1);FI"end;FI"end;Fi
[
[	@$iåI"            if var[var].stop then
              var[var].stop = var[(var - 1)].stop.plus(var[var].stop.minus(var[(var - 1)].stop).div(Sass::Script::Number.new(var)))
              break
            else
              var = (var + 1)
            end
          end
        end
      end;Fi[	@UivI"±          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1)
        end
      end
    end
    if (@var > 0) then;Fi[	@UiæI"Ù          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1)
      end
    end
    if var.!=(var) then
      self.Cell(((var / 1000.0) * @var), var, var[var, var], 0, 0, "", 0, var);Fi[	@ciqI"™        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1)
      end
    end
    if (@var > 0) then
      @var = 0;Fi[	@ci◊I"È          var = (var - (3 * @var))
        end
        var = (var + 1)
      else
        var = (var + 1)
      end
    end
    if var.!=(var) then
      Cell(GetStringWidth(var[(var..var)]), var, var[(var..var)], 0, 0, "", var, var);Fi[I"exit(1);FI"end;FI"end;FI" ;Fi
[
[	@Ci:I"©          end)
        rescue => var
          Logger.error(Errors::CLIError.wrap(var))
          exit(1)
        end
      end
      
      desc("generate:model", (((("Generates a Backup model file\n\n" + "Note:\n") + "  '--config-path' is the path to the directory where 'config.rb' is located.\n") + "  The model file will be created as '<config_path>/models/<trigger>.rb'\n") + "  Default: #{Config.root_path}\n"))
      ;Fi[	@˝i|I"	      rescue GemNotFound => var
        Bundler.ui.error(var.message)
        Bundler.ui.warn("Run `bundle install` to install missing gems.")
        exit(1)
      end
    end
    
    desc("package", "Locks and then caches all of the gems into vendor/cache")
    ;Fi[	@˝iÇI"        Bundler.load.clean
      else
        Bundler.ui.error("Can only use bundle clean when --path is set or --force is set")
        exit(1)
      end
    end
    
    desc("platform", "Displays platform compatibility information")
    ;Fi[	@EiöI"Ü        var = var.message[/^no such file to load -- (.*)/, 1]
        raise(var) if (@var[:trace] or (var.nil? or var.empty?))
        $stderr.puts("Required dependency #{dep} not found!\n    Run \"gem install #{dep}\" to get it.\n  Use --trace for backtrace.\n")
        exit(1)
      end
    end
    
    class Haml < Generic
      # @param args [Array<String>] The command-line arguments;Fi[	@ÍiSI"Y      else
        warn("[fail] Couldn't write crontab; try running `whenever' with no options to ensure your schedule file is valid.")
        var.close!
        exit(1)
      end
    end
    
    def function(arglist)
      if read_crontab.=~(Regexp.new("^#{comment_open} *$")) and read_crontab.=~(Regexp.new("^#{comment_close} *$")).nil? then;Fi[@p=I"#   end;FI"#;FI"#   person = Person.new;Fi
[
[	@iàI")    # which will all return +true+. It also define the attribute methods if they have
    # not been generated.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.respond_to(:name)    # => true
    #   person.respond_to(:name=)   # => true;Fi[	@iúI"     
    # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.has_attribute?(:name)    # => true
    #   person.has_attribute?('age')    # => true;Fi[	@i©I"    
    # Returns an array of names for the attributes available on this object.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.attribute_names
    #   # => ["id", "created_at", "updated_at", "name", "age"];Fi[	@iÚI"Ø    # Returns the column object for the named attribute. Returns +nil+ if the
    # named attribute not exists.
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter
    #   # => #<ActiveRecord::ConnectionAdapters::SQLite3Column:0x007ff4ab083980 @name="name", @sql_type="varchar(255)", @null=true, ...>;Fi[	@iI"0    # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
    # (Alias for the protected <tt>write_attribute</tt> method).
    #
    #   class Person < ActiveRecord::Base
    #   end
    #
    #   person = Person.new
    #   person[:age] = '22'
    #   person[:age] # => 22;Fi[@µ @°+I"[];FI"end;Fi
[
[	@B)i
I"Ä    def function(arglist)
      @var = []
    end
    
    def function(arglist)
      []
    end
    
    def function(arglist);Fi[	@äiI"†        def function(arglist)
          false
        end
        
        def function(arglist)
          []
        end
        
        def function(arglist);Fi[	@ÿ#iAI"l  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end
  
  def function(arglist);Fi[	@ÿ#iEI"y  def function(arglist)
    []
  end
  
  def function(arglist)
    []
  end
  
  def self.excluding_blocks(arglist);Fi[	@iI"ï      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        []
      end
      
      def function(arglist);Fi[@wQ@xQ@yQI"¥# @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi
[
[	@5iI"ë      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @example Return the 20 most recent mentions (statuses containing @username) for the authenticating user
      #   Twitter.mentions;Fi[	@5iHI"	      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@5i_I"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@5itI"Å      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.;Fi[	@5iÜI"      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[@;@;@æPI"end;Fi
[
[	@irI"¨        #   Project.primary_key # => "foo_id"
        def function(arglist)
          @var = (var and var.to_s)
          @var = nil
        end
      end
    end
  end
end;Fi[	@¯iiI"´        # (temporary file containing the password)
        def function(arglist)
          @var.delete if @var
          @var = nil
        end
      end
    end
  end
end;Fi[	@–iI"†        if var.is_a?(Hash) then
          @var = Backup::Binder.new(var).get_binding
        else
          @var = nil
        end
      end
    end
    
    ##;Fi[	@Vi1I"ì      def function(arglist)
        var = @var
        @var.each { |arglist| var.end_scenario(var) }
        @var = nil
      end
    end
  end
end;Fi[	@;iBI"N    end
    
    def function(arglist)
      @var = nil
    end
  end
end;Fi[@û=I"# For example,;FI"#;FI"#   class Vehicle;Fi
[
[	@=<iiI"S    # * <tt>human_state_event_name(event)</tt> - Gets the humanized value for
    #   the given event.  This may be generated by internationalization
    #   libraries if supported by the integration.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do;Fi[	@=<iöI"D    #   specified, then this will match any event.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do;Fi[	@=<i’I":    # automatically assigned when a new object is created.  However, this
    # behavior will *not* work if the class defines an +initialize+ method
    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...;Fi[	@=<iÜI"*    # for an object.  Events can be fired either directly (through the method
    # generated for the event) or indirectly (through attributes defined on
    # the machine).
    # 
    # For example,
    # 
    #   class Vehicle
    #     include DataMapper::Resource
    #     property :id, Serial;Fi[	@=<iºI"m    # states/events in the machine.  This is particularly useful when a class
    # has multiple state machines and it would be difficult to differentiate
    # between the various states / events.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :heater_state, :initial => :off, :namespace => 'heater' do
    #       event :turn_on do;Fi[@û=@oZI"#;F@qZi
[
[	@oi$I"        # necessary to set the references from the child back to the parent
        # document. If a child does not define this relation calling
        # persistence methods on the child object will cause a save to fail.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses;Fi[	@oiBI"I        # Adds the relation from a parent document to its children. The name
        # of the relation needs to be a pluralized form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_many :addresses;Fi[	@oi^I">        # Adds the relation from a parent document to its child. The name
        # of the relation needs to be a singular form of the child class
        # name.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     embeds_one :name;Fi[	@oiéI"!        
        # Adds a relational association from a parent Document to many
        # Documents in another database or collection.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_many :posts;Fi[	@oi™I"3        
        # Adds a relational many-to-many association between many of this
        # Document and many of another Document.
        #
        # @example Define the relation.
        #
        #   class Person
        #     include Mongoid::Document
        #     has_and_belongs_to_many :preferences;Fi[I"
break;FI"end;FI"end;FI"end;Fi
[
[	@˜i£I"p      var = Benchmark.realtime do |arglist|
        loop do |arglist|
          unless process_iteration { |arglist| @var.any? { |arglist| var[:closed].! } } then
            break
          end
        end
      end
      logger.trace("command finished in #{(elapsed * 1000).round}ms") if logger
      if (var = @var.select { |arglist| var[:status].!=(0) }).any? then;Fi[	@‚ihI"∂          var = I18n.inflector.true_token(var, :gender, var)
          unless var.nil? then
            @var = var
            break
          end
        end
      end
    end
  end;Fi[	@£i@I"˜        var.children.map { |arglist| var.relative_path_from(self) }.each do |arglist|
          yield(var) if var.to_s =~ /.rb$/
        end
        break
      end
    end
  end
  
  # Writes an exec script in this folder for each target pathname;Fi[	@xiVI"                var = $1
                next if (var == "src") and var =~ /^(?!http)\w+:/
                (var << "#{prop}=\"#{$1.gsub("\"", "\\\"")}\"")
                break
              end
            end
          end
        end
        "<#{raw[1]}#{pcs.join(" ")}>";Fi[	@àihI"            if (var == (var[var][(0...var)] + var[var][((var + 1)..-1)])) then
              var[var][var] += ("," + var[var][var])
              var.delete_at(var)
              break
            end
          end
        end
      end
      var.map { |arglist| var.join(" ") };Fi[I"require("rubygems");FI"require("sequel");FI"require("fileutils");FI"require("yaml");Fi
[
[	@Ìi I"mrequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Drupal;Fi [	@˚i I"mrequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module Joomla;Fi [	@i I"irequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module MT;Fi [	@i I"rrequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module TextPattern;Fi [	@i I"prequire("rubygems")
require("sequel")
require("fileutils")
require("yaml")
module Jekyll
  module WordPress;Fi [@û=I"# @since 2.4.0;F@ÁZI"@var ||= {};Fi
[
[	@ái3I"£    #   person.atomic_array_pushes
    #
    # @return [ Hash ] The array pushes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[	@ái?I"°    #   person.atomic_array_pulls
    #
    # @return [ Hash ] The array pulls.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[	@áiKI"≠    #   person.atomic_array_add_to_sets
    #
    # @return [ Hash ] The array add_to_sets.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[	@§i3I"∂    #   model.changed_attributes
    #
    # @return [ Hash<String, Object> ] The attribute changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[	@§ilI"¡    #   model.previous_changes
    #
    # @return [ Hash<String, Array<Object, Object> ] The previous changes.
    #
    # @since 2.4.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[@û=I"0# @return [ Class ] The class being set up.;FI"#;FI"# @since 2.0.0.rc.1;Fi
[
[	@ë
i∂I"^        #
        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method(var) { |arglist| get_relation(var, var, var) };Fi[	@ë
iŸI"H        #
        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("#{name}=") do |arglist|;Fi[	@-i.I"*        #   Person.builder("name")
        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("build_#{name}") do |arglist|;Fi[	@-iGI"+        #   Person.creator("name")
        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("create_#{name}") do |arglist|;Fi[	@åiI"        #   Movie.polymorph(metadata)
        #
        # @param [ Metadata ] metadata The relation metadata.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          if var.polymorphic? then;Fi[@'@ÉII"	next;FI"end;Fi
[
[	@LiƒI"          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@OiøI"          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@Ri≥I"          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0));Fi[	@UiõI"‹          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == " "[0]) then
        var = var;Fi[	@ci∑I"Ô          @var = @var
          var = ((@var - @var) - @var)
          var = (var - (3 * @var))
        end
        var = (var + 1)
        next
      end
      var = var if (var == " "[0])
      var = GetStringWidth(var[var, (var - var)]);Fi[@û=@˝M@˛MI"if block_given? then;Fi
[
[	@liOI"È        # @param [ Symbol ] field The field to sum.
        #
        # @return [ Float ] The sum value.
        #
        # @since 3.0.0
        def function(arglist)
          if block_given? then
            super()
          else;Fi[	@ãidI"      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          (documents[(skipping or 0), (limiting or documents.length)] or []).each do |arglist|
            yield(var);Fi[	@éitI"      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          selecting do |arglist|
            documents_for_iteration.each { |arglist| yield_document(var, &var) };Fi[	@éi5I"∏      #   pairs.
      #
      # @return [ Mongo ] The context.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          super(&var)
        else;Fi[	@≠iéI"      #
      # @return [ Criteria, Object ] The unscoped criteria or result of the
      #   block.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          without_default_scope { |arglist| yield(self) }
        else;Fi[@ÿ/I" ;FI"private;FI" ;Fi
[
[	@ÖiI"∞        @var = false
      end
      
      attr_reader :function
      
      private
      
      def function(arglist)
        loaded?.! and (foreign_key_present? and klass);Fi[	@
iI"¨        @var[var]
      end
      
      attr_reader :function
      
      private
      
      # Handle *_before_type_cast for method_missing.
      def function(arglist);Fi[	@“iºI"·            @var = @var.sub((@var + "/"), "")
          end
          
          attr_reader :function
          
          private
          
          ##
          # Sanitize string and replace any invalid UTF-8 characters.;Fi[	@úi0I"á      @var
    end
    
    attr_reader :function
    
    private
    
    def function(arglist)
      var =~ /^--(no|skip)-([-\w]+)$/;Fi[	@GiI"Â        self
      end
      
      attr_reader :function
      
      private
      
      # Searches the path, looking for the given utility. If an executable
      # file is found that matches the parameter, this returns true.;Fi[I"out("/Subtype /Type1");FI"8if var.!=("Symbol") and var.!=("ZapfDingbats") then;FI"&out("/Encoding /WinAnsiEncoding");FI"end;Fi
[
[	@LiI"8        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[	@OiI"8        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[	@RiI"8        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]));Fi[	@UieI"	        newobj
        out("<</Type /Font")
        out(("/BaseFont /" + var))
        out("/Subtype /Type1")
        if var.!=("Symbol") and var.!=("ZapfDingbats") then
          out("/Encoding /WinAnsiEncoding")
        end
        out(">>")
        out("endobj");Fi[	@ciJI"	        newobj
        out("<</Type /Font")
        out(("/BaseFont /" + var))
        out("/Subtype /Type1")
        if var.!=("Symbol") and var.!=("ZapfDingbats") then
          out("/Encoding /WinAnsiEncoding")
        end
        out(">>")
        out("endobj");Fi[I"@var.empty?;TI"end;TI" ;TI"def function(arglist);Fi
[
[	@úi:I"}    end
    
    def function(arglist)
      @var.empty?
    end
    
    def function(arglist)
      @var.first
    end;Fi[	@ìi/I"º      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        var = (@var + [var]).map { |arglist| var.text_length }
        var.max;Fi[	@=igI"´      end
      
      def function(arglist)
        @var.empty?
      end
      
      def function(arglist)
        @var.each { |arglist| var.send(var, *var) }
      end;Fi[	@Äi¨I"p  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end;Fi[	@™i I"ì  end
  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    return unless external_patches?
    curl(*external_curl_args);Fi[I";#   #       #<Pet id: 5, name: "Brain", person_id: 1>,;TI":#   #       #<Pet id: 6, name: "Boss",  person_id: 1>;TI"#   #    ];TI"#;Ti
[
[	@îiGI"Q      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4")
      #   # => #<Pet id: 4, name: "Benny", person_id: 1>;Ti[	@îiQI"      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy(5, 6)
      #   # => [;Ti[	@îiWI"      #
      #   person.pets.destroy(5, 6)
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 0
      #   person.pets       # => [];Ti[	@îibI"0      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [;Ti[	@îiiI"I      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')])
      #;Ti[@'I"@var = true;TI"end;FI"end;Fi
[
[	@˙iUI"Ï          end
          Sass::Plugin.on_compilation_error do |arglist|
            Compass.configuration.run_stylesheet_error(var, var.message)
          end
          @var = true
        end
      end
      
      def function(arglist);Fi[	@äi;I"¸          var.step_mother.with_hooks(self, skip_hooks?) do |arglist|
            skip_invoke! if failed?
            var.visit_steps(@var)
          end
          @var = true
        end
      end
      
      # Returns true if one or more steps failed;Fi[	@®i]I"ﬁ              install_dependency(var) unless var.installed?
            end
          end
        end
        @var = true
      end
    end
    oh1("Installing #{Tty.green}#{f}#{Tty.reset}") if show_header
    (@@var << f);Fi[	@ÚiI"g          unless @var then
            content_for(:header_tags) do |arglist|
              ((javascript_include_tag("jstoolbar/jstoolbar-textile.min") + javascript_include_tag("jstoolbar/lang/jstoolbar-#{current_language.to_s.downcase}")) + stylesheet_link_tag("jstoolbar"))
            end
            @var = true
          end
        end
      end
    end;Fi[	@„iìI"            var = @var ? (:after) : (:failure)
            machine.callbacks[var].each { |arglist| var.call(object, context, self) }
          end
        end
        @var = true
      end
    end
    
    # Gets a hash of the context defining this unique transition (including;Fi[@	)I"@var.!.!;FI"end;FI" ;Fi
[
[	@éi#I"‘      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the number of documents matching the query.
      #;Fi[	@éiÛI"»      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the documents for cached queries.
      #;Fi[	@ùisI"¯    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    
    # Extract a single id from the provided criteria. Could be in an $and
    # query or a straight _id query.;Fi[	@õi'I"˛        # @return [ true, false ] If the enumerable has been _loaded.
        #
        # @since 2.1.0
        def function(arglist)
          @var.!.!
        end
        
        # Provides the data needed to Marshal.dump an enumerable proxy.
        #;Fi[	@ÎiéI"–        s3_bucket.objects[path(var).sub(/^\//, "")]
      end
      
      def function(arglist)
        @var.!.!
      end
      
      def function(arglist)
        using_http_proxy? ? (@var[:host]) : (nil);Fi[@'@¸I"# @return [String];FI"def function(arglist);Fi
[
[	@iVI"¶  # @return [Invitation] self
  def function(arglist)
    self.send!
  end
  
  # @return [String]
  def function(arglist)
    case self.service
    when "email" then;Fi[	@ibI"Ö    else
      # do nothing
    end
  end
  
  # @return [String]
  def function(arglist)
    case self.service
    when "email" then;Fi[	@LGiI"¸    # @return [Twitter::Geo]
    def function(arglist)
      @var ||= Twitter::GeoFactory.fetch_or_new(@var[:bounding_box])
    end
    
    # @return [String]
    def function(arglist)
      @var ||= (@var[:country_code] or @var[:countryCode])
    end;Fi[	@LGiI"Î    # @return [Integer]
    def function(arglist)
      @var ||= @var[:parentid]
    end
    
    # @return [String]
    def function(arglist)
      @var ||= (@var[:place_type] or (@var[:placeType] and @var[:placeType][:name]))
    end;Fi[	@UGiI"Ë    # @return [Integer]
    def function(arglist)
      @var[:search_metadata][:page] if search_metadata?
    end
    
    # @return [String]
    def function(arglist)
      @var[:search_metadata][:query] if search_metadata?
    end;Fi[@(I"reconnect_ssl;FI"end;FI" ;Fi
[
[	@oi I"ò  ##
  # Sets this client's OpenSSL::X509::Certificate
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :cert= :certificate=
  ;Fi[	@oi
I"ª  ##
  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Overrides the default SSL certificate store used for verifying;Fi[	@oiI"Ê  # Overrides the default SSL certificate store used for verifying
  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Finishes all connections on the given +thread+ that were created before;Fi[	@oiÂI"å  ##
  # Sets this client's SSL private key
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  alias :key= :private_key=
  ;Fi[	@oiÁI"‹  # Securely transfer the correct certificate and update the default
  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # SSL verification callback.;Fi[@'@˝S@˛SI"end;Fi
[
[	@Ci‡I"Œ      def function(arglist)
        if File.exist?(var) then
          return yes?("A file already exists at '#{path}'. Do you want to overwrite? [y/n]")
        end
        true
      end
    end
  end
end;Fi[	@3i≤I"~            end
            raise(var)
          end
        end
        true
      end
    end
    
    def function(arglist);Fi[	@¡iæI"Ò    unless (HOMEBREW_CELLAR.to_s == "/usr/local/Cellar") then
      return false unless var
      raise("Bottles are only supported with a /usr/local/Cellar cellar.")
    end
    true
  end
end
require("macos/xcode")
require("macos/xquartz");Fi[	@∫	iI"≤            var = var[var]
            return false unless Strategies.matcher(document, var, var).matches?(var)
          end
        end
        true
      end
    end
  end
end;Fi[	@¬i%I"ï            else
              return false unless var.include?(var)
            end
          end
          true
        end
      end
    end
  end;Fi[@∑<@∏<@π<I"def function(arglist);Ti
[
[	@îiqI"      #
      #   person.pets.find(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.find(*var, &var)
      end;Ti[	@îi‚I"J      #   person.pets.find(1, 2, 3)
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.create(var, &var)
      end;Ti[	@îiI"	      #
      #   person.pets.delete(2, 3)
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.delete(*var)
      end;Ti[	@îiI":      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.count(var, var)
      end;Ti[	@îi≥I"1      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      def function(arglist)
        @var.length
      end;Ti[@'@¸@ˇ,I"@var.each(&var);Fi
[
[	@}iI"ä      
      def function(arglist)
        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      ;Fi[	@ìi#I"‚      # Duplicates this instance and adds +step_invocations+ to the end
      def function(arglist)
        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      ;Fi[	@ñiXI"ﬂ          map do |arglist|
            var.value ? (escape_cell(var.value.to_s).unpack("U*").length) : (0)
          end.max
        end
        
        def function(arglist)
          @var.each(&var)
        end
      end;Fi[	@Äi≠I"m  
  def function(arglist)
    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  ;Fi[	@™iI"}  
  def function(arglist)
    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  ;Fi[@'@¸@ˇ,I"assert(Category.valid?);Fi
[
[	@öi°I"˚    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.update_all("lft = null")
    assert(Category.valid?.!);Fi[	@öißI"‡    assert(Category.valid?)
    Category.update_all("lft = null")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.update_all("rgt = null")
    assert(Category.valid?.!);Fi[	@öi≠I"Â    assert(Category.valid?)
    Category.update_all("rgt = null")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.delete(categories(:child_2).id)
    assert(Category.valid?);Fi[	@öi≥I"Î    assert(Category.valid?)
    Category.delete(categories(:child_2).id)
    assert(Category.valid?)
  end
  
  def function(arglist)
    assert(Category.valid?)
    categories(:top_level_2)["lft"] = 0
    categories(:top_level_2).save;Fi[	@öi∫I"ˆ    categories(:top_level_2)["lft"] = 0
    categories(:top_level_2).save
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    var = Category.root.to_text
    Category.update_all("lft = null, rgt = null");Fi[@'@¸@ˇ,I",assert(Category.left_and_rights_valid?);Fi
[
[	@öiŸI"?      assert(categories(:top_level).is_or_is_ancestor_of?(categories(var)))
    end
    assert(categories(:top_level).is_or_is_ancestor_of?(categories(:top_level_2)).!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false);Fi[	@öi‡I"    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false);Fi[	@öiÁI"1    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false);Fi[	@öiÓI"J    categories(:top_level_2)[:lft] = categories(:top_level_2)[:rgt]
    categories(:top_level_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false);Fi[	@öiıI"@    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false);Fi[@'I"def function(arglist);FI"# do nothing;FI"end;Fi
[
[	@”i.I"Ω      end
      def function(arglist)
        super(var)
      end
      def function(arglist)
        # do nothing
      end
      def function(arglist)
        puts("No plugin responded");Fi[	@µi0I"‡        end
        def function(arglist)
          (action == :save) ? (:create_or_update) : (super)
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          false;Fi[	@µi9I"»        end
        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          var.to_s.humanize.downcase;Fi[	@≈i!I"/      version("2.8.x - 2.11.x") do |arglist|
        def self.active?(arglist)
          (defined? ::Sequel::MAJOR.! or ((::Sequel::MAJOR == 2) and (::Sequel::MINOR <= 11)))
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing;Fi[	@≈i$I"€        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          # do nothing
        end
        def function(arglist)
          (action == :save) ? (:save) : (super);Fi[@	)I"teardown_db;FI"end;FI" ;Fi
[
[	@ái4I"    (1..4).each { |arglist| ListMixin.create!(:pos => (var), :parent_id => 5) }
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5", :order => "pos").map(&:id));Fi[	@áiæI"Ã    end
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id));Fi[	@äiAI"ú    @var = TreeMixin.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal(@var.children, [@var, @var]);Fi[	@äiôI"    @var = RecursivelyCascadedTreeMixin.create!(:parent_id => (@var.id))
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    var = TreeMixin.find(:all, :include => :children, :conditions => "mixins.parent_id IS NULL", :order => "mixins.id");Fi[	@äiøI"∏    @var = TreeMixinWithoutOrder.create!
  end
  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert([@var, @var].include?(TreeMixinWithoutOrder.root));Fi[@'@¸@ˇ,@L[i
[
[	@iigI"π      # backgrounds don't have tags.
      def function(arglist)
        []
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
    end;Fi[	@ui=I"°      
      def function(arglist)
        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      ;Fi[	@xiGI"Ÿ      
      def function(arglist)
        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      ;Fi[	@Éi'I"®      
      def function(arglist)
        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      ;Fi[	@ÉiQI"ª        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        ;Fi[@û=I"-# @return [ Hash ] The object mongoized.;FI"#;FI"# @since 3.0.0;Fi
[
[	@L	iØI"        #   Hash.mongoize([ 1, 2, 3 ])
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return if var.nil?;Fi[	@d	iI"’      #
      # @example Mongoize the object.
      #   range.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Range.mongoize(self);Fi[	@d	iCI"+        #   Range.mongoize(1..3)
        #
        # @param [ Range ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : ({ "min" => (var.first), "max" => (var.last) });Fi[	@n	iI"—      #
      # @example Mongoize the object.
      #   set.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self);Fi[	@n	i+I"Ì        #   Set.mongoize(1..3)
        #
        # @param [ Set ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.to_a;Fi[I"# @since 1.5.2;FI"#;FI"def function(arglist);FI"return @var;Fi
[
[	@ciüI"ü  	# Returns the image scale.
  	# @return float image scale.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@ci´I"§  	# Returns the page width in units.
  	# @return int page width.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@ci∑I"¶  	# Returns the page height in units.
  	# @return int page height.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@ci√I"©  	# Returns the page break margin.
  	# @return int page break margin.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[	@ciœI"ø  	# Returns the scale factor (number of points in user unit).
  	# @return int scale factor.
  	# @author Nicola Asuni
  	# @since 1.5.2
  	#
  def function(arglist)
    return @var
  end
  ;Fi[@'I"nil;FI"end;FI" ;Fi
[
[	@9iRI"„      var = File.mtime(var)
      css_files.each do |arglist|
        return var if File.exists?(var) and (var > File.mtime(var))
      end
      nil
    end
    
    def function(arglist)
      remove(options[:cache_location]);Fi[	@’iI"Ê    def function(arglist)
      if var.=~(SPRITE_IMPORTER_REGEX) then
        return self.class.sass_engine(var, self.class.sprite_name(var), self, var)
      end
      nil
    end
    
    def function(arglist)
      # do nothing;Fi[	@ÉiI"ı        init
        cells_rows.each_with_index do |arglist|
          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var);Fi[	@[iI"y        rescue
          # do nothing
        end
      end
      nil
    end
    
    REVISION = self.revision
    ;Fi[	@ÇièI"S          var = var[:to].values.empty? ? (var) : (var[:to].values.first)
          return Transition.new(var, machine, name, var, var, var.!)
        end
      end
      nil
    end
    
    # Attempts to perform the next available transition on the given object.
    # If no transitions can be made, then this will return false, otherwise;Fi[@®^I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi
[
[	@L	i∞I"        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return if var.nil?
          evolve(var).update_values { |arglist| var.mongoize };Fi[	@d	iI"◊      # @example Mongoize the object.
      #   range.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Range.mongoize(self)
      end;Fi[	@d	iDI"        #
        # @param [ Range ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.nil? ? (nil) : ({ "min" => (var.first), "max" => (var.last) })
        end;Fi[	@n	iI"”      # @example Mongoize the object.
      #   set.mongoize
      #
      # @return [ Hash ] The object mongoized.
      #
      # @since 3.0.0
      def function(arglist)
        ::Set.mongoize(self)
      end;Fi[	@n	i,I"⁄        #
        # @param [ Set ] object The object to mongoize.
        #
        # @return [ Hash ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.to_a
        end;Fi[@ŸK@⁄K@€KI";# @param options [Hash] A customizable set of options.;Fi
[
[	@5iI"ß      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/mentions_timeline
      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@5i[I"•      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@5ipI"∑      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@5iÇI"∑      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/home_timeline
      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi[	@5ióI"f      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/retweets_of_me
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;Fi[@'I"module Homebrew;FI"extend(self);FI" ;Fi
[
[	@niI"√    puts((("> " * var) + var.to_s))
    recursive_deps_tree(Formula.factory(var), (var + 1))
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--all") then;Fi[	@f7iI"ô  def function(arglist)
    Formula.factory(self)
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--help") then;Fi[	@&iI"}      ARGV.formulae
    end
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    ff.each do |arglist|;Fi[	@p-i
I"≈  def function(arglist)
    (self > 1) ? ("s") : ("")
  end
end
module Homebrew
  extend(self)
  
  def function(arglist)
    if Process.uid.zero? and File.stat(HOMEBREW_BREW_FILE).uid.zero?.! then;Fi[	@UiîI"8  def function(arglist)
    (super + advice.to_s)
  end
end
module Homebrew
  extend(self)
  
  SUDO_BAD_ERRMSG = "    You can use brew with sudo, but only if the brew executable is owned by root.\n    However, this is both not recommended and completely unsupported so do so at\n    your own risk.\n".undent
end;Fi[@‹.@›.@ﬁ.I"	else;Fi
[
[	@uiKI"Ÿ                "B'#{value}'"
              when /^[0-9A-F]*$/i then
                "X'#{value}'"
              else
                # do nothing
              end
            else
              super
            end;Fi[	@îiPI"          nostdout do |arglist|
            quiet_safe_system(@@var, "checkout", { :quiet_flag => "-q" }, @var, "--")
          end
        else
          # do nothing
        end
      else
        quiet_safe_system(@@var, "reset", "--hard", "origin/HEAD")
      end;Fi[	@™iI"            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end;Fi[	@™i3I"            image_task(var, var, :label => (var), :markers => (true), :height => 3)
          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end;Fi[	@™ipI"÷            image_task(var, var, :label => (var))
          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end;Fi[@â?@ä?I"end;FI"end;Fi
[
[	@îiWI"»        [:token, :user, :message, :title, :priority, :device].each do |arglist|
          @var.merge!(var => (self.instance_variable_get("@#{k}")))
        end
        @var
      end
    end
  end
end;Fi[	@Ëi{I"t            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end
end;Fi[	@Ôi*I"≥        unless MacOS::Xcode.default_prefix? then
          @var = (@var + " => #{MacOS::Xcode.prefix}")
        end
        @var
      end
    end
  end
  
  def function(arglist);Fi[	@”i'I"à      @var.merge!((self.class.read_inheritable_attribute(:rfpdf) or {})) do |arglist|
        var
      end
      @var
    end
  end
end;Fi[	@≥iWI"9        var.select { |arglist| ["list", "bool"].include?(var.field_format) }.each do |arglist|
          @var["cf_#{cf.id}"] = { :sql => ("#{cf.join_alias}.value"), :joins => (var.join_for_order_statement), :format => (var.field_format), :label => (var.name) }
        end
        @var
      end
    end
  end
end;Fi[I"out((var + "]"));FI"out("endobj");FI"newobj;FI"8var = ("<</Type /FontDescriptor /FontName /" + var);Fi
[
[	@Li+I"[          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[	@Oi4I"[          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[	@RiI"[          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var));Fi[	@UiÅI"l          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| (var << (GetCharWidth(var, var).to_s + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each { |arglist| (var << (((" /" + var) + " ") + var)) }
          var = var["file"];Fi[	@ciiI"o            var = var["cw"]
            var = "["
            32.upto(255) { |arglist| (var << (var[var.chr] + " ")) }
            out((var + "]"))
            out("endobj")
            newobj
            var = ("<</Type /FontDescriptor /FontName /" + var)
            var["desc"].each { |arglist| (var << (((" /" + var) + " ") + var)) }
            var = var["file"];Fi[@â?@ä?@_I" ;Fi
[
[	@Ûi1I"Ã          end
        end
        @var.where_values += var
        @var
      end
    end
    
    Relation::MULTI_VALUE_METHODS.each do |arglist|
      class_eval("        def #{name}_values                   # def select_values\n          @values[:#{name}] || []            #   @values[:select] || []\n        end                                  # end\n                                             #\n        def #{name}_values=(values)          # def select_values=(values)\n          raise ImmutableRelation if @loaded #   raise ImmutableRelation if @loaded\n          @values[:#{name}] = values         #   @values[:select] = values\n        end                                  # end\n", "(string)", (63 + 1));Fi[	@iUI"ì          @var = var
          @var = var
        else
          @var
        end
      end
      
      def function(arglist)
        (@var or {});Fi[	@i>I"          if @var.nil? then
            File.exist?("./Gemfile") and gem_available?("bundler")
          else
            @var
          end
        end
        
        def function(arglist)
          (gem_available_new_rubygems?(var) or gem_available_old_rubygems?(var));Fi[	@›#iI"«    else
      @var ||= self.object.subscribers(var)
      @var = (@var - self.object.resharers) unless self.object.is_a?(Photo)
      @var
    end
  end
  
  def self.for(arglist)
    var = self.new;Fi[	@’iíI"Á          @var.call
        end
      else
        @var
      end
    end
    
    # Determines whether this state matches the given value.  If no matcher is
    # configured, then this will check whether the values are equivalent.;Fi[I"E# @option options [ true, false ] :binding Are we in build mode?;FI"#;FI"# @since 2.0.0.rc.1;FI"def function(arglist);Fi
[
[	@¢
iI"£          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata
            base.parentize(target);Fi[	@≠
iI"n          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base)
            binding do |arglist|;Fi[	@≠
i(I"î          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) }
          end;Fi[	@¥
iI"s          # @param [ Hash ] options The options to pass through.
          #
          # @option options [ true, false ] :continue Do we continue binding?
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            target.parentize(base)
            binding do |arglist|;Fi[	@¥
i+I"ö          # @param [ Hash ] options The options to pass through.
          #
          # @option options [ true, false ] :continue Do we continue unbinding?
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), nil);Fi[@ô]I"#;F@õ]I"def function(arglist);Fi
[
[	@ë
i∑I"c        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method(var) { |arglist| get_relation(var, var, var) }
          self;Fi[	@ë
i⁄I"i        # @param [ String, Symbol ] name The name of the relation.
        # @param [ Metadata ] metadata The metadata for the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("#{name}=") do |arglist|
            without_autobuild do |arglist|;Fi[	@-i/I"/        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("build_#{name}") do |arglist|
            var, var = parse_args(*var);Fi[	@-iHI"0        #
        # @param [ String, Symbol ] name The name of the relation.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          re_define_method("create_#{name}") do |arglist|
            var, var = parse_args(*var);Fi[	@åiI"        #
        # @param [ Metadata ] metadata The relation metadata.
        #
        # @return [ Class ] The class being set up.
        #
        # @since 2.0.0.rc.1
        def function(arglist)
          if var.polymorphic? then
            self.polymorphic = true;Fi[@ÿ/@√]@ƒTI" ;Fi
[
[	@ÀiII"◊      end
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Returns true if the record is persisted, i.e. it's not a new record and it was
    # not destroyed, otherwise returns false.;Fi[	@ifI"ò        @var.each { |arglist| yield(var) }
      end
      
      attr_reader :function
      
      attr_reader :function
      
      protected
      ;Fi[	@(iüI"      var.respond_to?(:call) ? (var.call(instance)) : (var)
    end
    
    attr_reader :function
    
    attr_reader :function
    
    # Saves the file, if there are no errors. If there are, it flushes them to
    # the instance's errors and returns false, cancelling the save.;Fi[	@9iI"™          @var = nil
        end
        
        attr_reader :function
        
        attr_reader :function
        
        def function(arglist)
          @var = var;Fi[	@ÿiPI"ñ    
    private
    
    attr_reader :function
    
    attr_reader :function
    
    # Gets the object being transitioned
    def function(arglist);Fi[@û=I"# @since 2.1.0;FI"def function(arglist);FI"prepare do |arglist|;Fi
[
[	@˘	iI"        #   bit.persist
        #
        # @return [ Integer ] The new value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            var = document[field]
            return nil unless var;Fi[	@
iI"˛        #   pop.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then
              var = document.send(field);Fi[	@
iI"ˇ        #   pull.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then
              var = document.send(field);Fi[	@1
iI"        #   inc.persist
        #
        # @return [ Object ] The new integer value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            @var = value.to_s
            document[value] = document.attributes.delete(field);Fi[	@?
iI"        #   unset.persist
        #
        # @return [ nil ] The new value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            fields.each { |arglist| document.attributes.delete(var) }
            execute("$unset");Fi[@û=I"1# @return [ Array<Object> ] The dumped data.;FI"#;FI"# @since 3.0.15;Fi	[	[	@óiI"
      #
      # @example Dump the criteria.
      #   Marshal.dump(criteria)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        var = [klass, driver, inclusions, documents, strategy, negating];Fi[	@yiI"‹      #
      # @example Dump the proxy.
      #   Marshal.dump(proxy)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        [base, target, metadata];Fi[	@õi/I"Ú        #
        # @example Dump the proxy.
        #   Marshal.dump(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          [_added, _loaded, _unloaded];Fi[	@õi;I"Ï        #
        # @example Load the proxy.
        #   Marshal.load(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          @var, @var, @var = var;Fi[@û=@j:I"#   object.mongoize;FI"#;Fi	[	[	@)	iTI"ﬁ      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.
      #;Fi[	@.	iI"ﬂ      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[	@L	ipI"›      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.
      #;Fi[	@Z	i}I"ﬂ      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #;Fi[@û=I"%# @return [ Object ] The object.;FI"#;FI"# @since 3.0.0;Fi	[	[	@.	iI"º      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        to_s;Fi[	@.	i(I"#        #   Object.demongoize(object)
        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var.numeric? ? (::BigDecimal.new(var.to_s)) : (var) if var;Fi[	@Z	iÄI"º      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self;Fi[	@Z	iÛI"Ï        #   Object.demongoize(object)
        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var;Fi[@û=I"/# @return [ String ] The object mongoized.;FI"#;FI"# @since 3.0.0;Fi	[	[	@3	iI"Í        #
        # @example Mongoize the object.
        #   Boolean.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          evolve(var);Fi[	@G	i(I"'        #   Float.mongoize("123.11")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0);Fi[	@Q	i2I"        #
        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_i rescue 0);Fi[	@s	i∫I"         #   String.mongoize("123.11")
        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          demongoize(var);Fi[@û=I")# @return [ Criteria ] The criteria.;FI"#;FI"# @since 3.0.0;Fi	[	[	@ùiåI"h    # @option options [ String, Symbol ] :collection The collection name.
    # @option options [ String, Symbol ] :database The database name.
    # @option options [ String, Symbol ] :session The session name.
    #
    # @return [ Criteria ] The criteria.
    #
    # @since 3.0.0
    def function(arglist)
      Threaded.set_persistence_options(klass, var);Fi[	@ùiI"      #
      # @example Apply the default scope.
      #   criteria.apply_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        klass.without_default_scope { |arglist| merge!(klass.default_scoping.call) };Fi[	@ùiI"Á      #
      # @example Get the criteria with the default scope.
      #   criteria.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        var = clone;Fi[	@≠iúI"Û      #
      # @example Get a criteria with the default scope.
      #   Model.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        queryable.with_default_scope;Fi[@û=I"C# @return [ nil, false ] False if no attributes were provided.;FI"#;FI"# @since 3.0.0;Fi	[	[	@ãiÂI"%      #   context.update(name: "Smiths")
      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, [first]);Fi[	@ãiÛI"*      #   context.update_all(name: "Smiths")
      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, entries);Fi[	@éiGI"-      #   context.update({ "$set" => { name: "Smiths" }})
      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var);Fi[	@éiUI";      #   context.update({ "$set" => { name: "Smiths" }})
      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, :update_all);Fi[@û=I"$# @return [ true ] Always true.;FI"#;FI"# @since 3.0.0;Fi	[	[	@|iI"ˆ      #   context.eager_load(docs)
      #
      # @param [ Array<Document> ] docs The docs returning from the db.
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        load_inclusions(var);Fi[	@G	iI"ø      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true;Fi[	@Q	iI"ø      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true;Fi[	@
iI"ﬁ        #
        # @example Execute the upsert.
        #   operation.persist
        #
        # @return [ true ] Always true.
        #
        # @since 3.0.0
        def function(arglist)
          prepare do |arglist|;Fi[@û=I"# @return [ true ] true.;FI"#;FI"# @since 3.0.0;Fi	[	[	@)	iuI"∫      #
      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true;Fi[	@)	iüI"À        #
        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true;Fi[	@L	iI"¥      #
      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true;Fi[	@L	iºI"∆        #
        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true;Fi[@û=I"# @return [ Object ] self.;FI"#;FI"# @since 3.0.0;Fi	[	[	@Z	iI"¿      #
      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self;Fi[	@Z	iI"¬      #
      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self;Fi[	@Z	i&I"ø      #
      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self;Fi[	@Z	i>I"∆      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self;Fi[@û=I"## @example Build the document.;FI"'#   Builder.new(meta, attrs).build;FI"#;Fi	[	[	@Ë
iI"X        class In < Builder
          # This builder doesn't actually build anything, just returns the
          # parent since it should already be instantiated.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type Not used in this context.
          #;Fi[	@¯
iI"ó          # Builds the document out of the attributes using the provided
          # metadata on the relation. Instantiates through the factory in order
          # to make sure subclasses and allocation are used if fitting.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type Not used in this context.
          #;Fi[	@iI"b        class In < Builder
          # This builder either takes a foreign key and queries for the
          # object or a document, where it will just return it.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #;Fi[	@&iI"c        class One < Builder
          # This builder either takes an _id or an object and queries for the
          # inverse side using the id or sets the object.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #;Fi[@´SI"#;F@TI"var = case var;Fi	[	[	@Ñi-I"o      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@ëi+I"o      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@îi5I"o      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[	@ói)I"o      # : The backup operation failed.
      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success";Fi[I"if (var > 0) then;FI"@var = 0;FI"out("0 Tw");FI"end;Fi	[	[	@UiI"∂    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("0 Tw")
      end
      self.AddPage(@var)
      @var = var;Fi[	@ciŒI"¡      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var;Fi[	@ciI"(      if ((var + ((var["h"] * var) / (@var * @var))) > @var) and (@var.! and AcceptPageBreak) then
        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("0 Tw")
          end
          AddPage(@var)
          if (var > 0) then;Fi[	@ciMI"¡      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var;Fi[@û=@˝M@˛MI"
begin;Fi	[	[	@éi∫I"      #
      # @example Apply the id sorting params to the given block
      #   context.with_sorting
      #
      # @since 3.0.0
      def function(arglist)
        begin
          (query.sort(:_id => 1) unless criteria.options.has_key?(:sort)
          yield);Fi[	@éiÀI"1      #
      # @example Apply the inverse sorting params to the given block
      #   context.with_inverse_sorting
      #
      # @since 3.0.0
      def function(arglist)
        begin
          (if var = criteria.options[:sort] then
            query.sort(Hash[var.map { |arglist| [var, (-1 * var)] }]);Fi[	@ë
iåI"⁄      #   end
      #
      # @return [ Object ] The result of the yield.
      #
      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("without_autobuild")
          yield);Fi[	@≠i¬I"ﬁ      #   end
      #
      # @return [ Object ] The result of the block.
      #
      # @since 3.0.0
      def function(arglist)
        begin
          (Threaded.begin_execution("without_default_scope")
          yield);Fi[I"attr_accessor(:ip, :port);FI" ;FI"attr_accessor(:path);FI" ;Fi	[	[	@™iI"∏    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:passive_mode)
      ;Fi[	@ªiI"£      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:local)
      ;Fi[	@√iI"≤    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[	@»iI"≥    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials;Fi[I"!@var = path.sub(/^\~\//, "");FI"end;FI" ;FI"private;Fi	[	[	@™i!I"±        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[	@ªi#I"±        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[	@√iI"Æ        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[	@»iI"Æ        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##;Fi[@û=@ÈMI"#;FI"# @since 2.0.0;Fi	[	[	@F
i"I"q      # @param [ Symbol ] field The name of the field.
      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        AddToSet.new(self, var, var, var).persist;Fi[	@F
iKI"Z      # @param [ Symbol ] field The name of the field.
      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Inc.new(self, var, var, var).persist;Fi[	@F
iI"`      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        PullAll.new(self, var, var, var).persist;Fi[	@F
iêI"U      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Push.new(self, var, var, var).persist;Fi[@û=@ÈM@5`I"# @since 2.1.0;Fi	[	[	@F
i_I"d      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pop.new(self, var, var, var).persist;Fi[	@F
irI"U      # @param [ Symbol ] field The name of the field.
      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pull.new(self, var, var, var).persist;Fi[	@F
i°I"`      # @param [ Symbol ] field The name of the field.
      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        PushAll.new(self, var, var, var).persist;Fi[	@F
i√I"U      # @param [ Symbol ] field The name of the field.
      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Sets.new(self, var, var, var).persist;Fi[I"-# Credentials for the specified database;FI"##;FI"# Connectivity options;FI"##;Fi	[	[	@ciI"Ÿ      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # IPv6 support (disabled by default)
      ##;Fi[	@fiI"      # Name of the database that needs to get dumped
      # To dump all databases, set this to `:all` or leave blank.
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	@iiI"‡      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database
      ##;Fi[	@liI"A      ##
      # Name of and path to the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Determines whether Backup should invoke the SAVE command through
      # the 'redis-cli' utility to persist the most recent data before;Fi[@nJI"end;FI" ;FI"def function(arglist);Fi	[	[	@ñieI"
        attr_accessor(:status, :value)
        
        def function(arglist)
          @var, @var, @var = var, var, var
        end
        
        def function(arglist)
          return if Cucumber.wants_to_quit
          var.visit_table_cell_value(value, status);Fi[	@ûiI"œ      #:nodoc:
      #:nodoc:
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@2iI"¡      include(Formatter::Duration)
      
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        load unless @var
        @var;Fi[	@ºi	I"œ  module Matchers
    class Has
      def function(arglist)
        @var, @var, @var = var, var, var
      end
      
      def function(arglist)
        var.__send__(predicate(@var), *@var, &@var)
      end;Fi[@û=I"G# This case sets the metadata on the inverse object as well as the;FI"# document itself.;FI"#;Fi	[	[	@¢
iI"í        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   name.person.bind(:continue => true);Fi[	@¥
iI"í        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.name.bind(:continue => true);Fi[	@Ω
iI"í        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.
          #   game.person.bind(:continue => true);Fi[	@ﬁ
iI"í        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.
          #   person.game.bind(:continue => true);Fi[I"(attr_accessor(:username, :password);FI" ;F@`I" ;Fi	[	[	@™i	I"≠module Backup
  module Storage
    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      ;Fi[	@ªiI"ª    class RSync < Base
      include(Backup::CLI::Helpers)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      ;Fi[	@√i
I"≠module Backup
  module Storage
    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      ;Fi[	@»i
I"Æmodule Backup
  module Storage
    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      ;Fi[I"# @access private;FI"#;FI"def function(arglist);FI"case var;Fi	[	[	@ciÇI"Œ  	#
  	# @param string :tag tag name (in upcase)
  	# @param string :attr tag attribute (in upcase)
  	# @access private
  	#
  def function(arglist)
    case var
    when "table" then
      @var[@var] = 0;Fi[	@ciÆI"—  #
  	# Calculate closing tags.
  	# @param string :tag tag name (in upcase)
  	# @access private
  	#
  def function(arglist)
    case var
    when "table" then
      @var[@var] = @var if (@var[@var] < @var);Fi[	@ci»I"5  	# @param string :tag tag name (in upcase)
  	# @param string :attr tag attribute (in upcase)
  	# @param int :fill Indicates if the cell background must be painted (1) or transparent (0). Default value: 0.
  	# @access private
  	#
  def function(arglist)
    case var
    when "pre" then
      @var = true;Fi[	@ciôI"±  #
  	# Process closing tags.
  	# @param string :tag tag name (in upcase)
  	# @access private
  	#
  def function(arglist)
    case var
    when "pre" then
      @var = false;Fi[@û=I"(# @example Instantiate the strategy;FI")#   Strategy.new(document, metadata);FI"#;Fi	[	[	@2iI"d        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@;iI"d        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@DiI"d        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[	@IiI"d        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.;Fi[@û=I"A# @param [ Document ] document The document to cascade from.;FI"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;Fi	[	[	@2iI"J        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@;iI"J        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@DiI"J        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[	@IiI"J        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist);Fi[@û=I"-# @return [ Strategy ] The new strategy.;FI"def function(arglist);FI"@var, @var = var, var;Fi	[	[	@2iI"7        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@;iI"7        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@DiI"7        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[	@IiI"7        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end;Fi[I"(self.class.to_s.sub("Backup::", "");FI"end;FI" ;FI"##;Fi	[	[	@FiI"       ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor;Fi[	@`i(I"      ##
      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database;Fi[	@uiI"!      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive;Fi[	@ÅiGI"%      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process;Fi[@NI"	else;FI"if (var == 0) then;FI"@var = var;Fi	[	[	@LiôI"˚    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@OiîI"˚    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@RiàI"˚    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else;Fi[	@ci|I"    (var << "B") if var.is_a?(String) and var.include?("B")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var);Fi[I"puts(var);FI"@var = true;FI"end;FI"end;Fi	[	[	@®i7I"      puts("install to \"libexec\" and then symlink or wrap binaries into \"bin\".")
      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@®iGI"Î      opoo("Non-libraries were installed to \"lib\".")
      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@®iSI"Ô      opoo("Non-executables were installed to \"bin\".")
      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[	@®i_I"Ò      opoo("Non-executables were installed to \"sbin\".")
      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  
  def function(arglist);Fi[@û=I"# @api private;FI"#;FI"%# @example Validate the options.;Fi	[	[	@giRI"Ù        
        # Return true if the configuration has no database or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config)
        #;Fi[	@gicI"Ó        
        # Return true if the configuration has no hosts or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_hosts_or_uri?(config)
        #;Fi[	@gitI"˙        
        # Return true if the configuration has both standard options and a uri
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config)
        #;Fi[	@®	i#I"›        private
        
        # Validates the options of the index spec.
        #
        # @api private
        #
        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #;Fi[I"binding;FI"end;FI"end;FI"end;Fi	[	[	I"'data//backup_proj/backup/binder.rb;TiI"ò    ##
    # Returns the binding (needs a wrapper method because #binding is a private method)
    def function(arglist)
      binding
    end
  end
end;Fi[	@iÖI"]      end
      
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	@i'I"      
      def function(arglist)
        @var.each { |arglist| eval("#{k} = v") }
        binding
      end
    end
  end
end;Fi[	@ci
I"|  module Sprites
    class Binding < OpenStruct
      def function(arglist)
        binding
      end
    end
  end
end;Fi[@û=I"/# @return [ String, Symbol ] The override.;FI"#;FI"# @since 3.0.0;Fi	[	[	I"/data//mongoid_proj/lib/mongoid/threaded.rb;TiI"Ô    #
    # @example Get the global database override.
    #   Threaded.database_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:db-override"];Fi[	@ ai*I"	    #   Threaded.database_override = :testing
    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:db-override"] = var;Fi[	@ ai:I"Ú    #
    # @example Get the global session override.
    #   Threaded.session_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:session-override"];Fi[	@ aiHI"    #   Threaded.session_override = :testing
    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:session-override"] = var;Fi[I"/@var.compressor.compress_with do |arglist|;FI"(var << var);FI"(var << var);FI"end;Fi	[	[	@√iJI"_      var = Pipeline.new
      (var << ("#{utility(:tar)} #{tar_args} -cPf - " + "#{paths_to_exclude} #{paths_to_package}"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "cat > '#{File.join(archive_path, "#{name}.#{archive_ext}")}'");Fi[	@ciuI"        var = (((@var + "-") + var) + ".tar")
        Logger.message(("#{database_name} started compressing and packaging:\n" + "  '#{@dump_path}'"))
        (var << "#{utility(:tar)} -cf - -C '#{base_dir}' '#{dump_dir}'")
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
        (var << "cat > #{outfile}")
        var.run;Fi[	@fi<I"        var = "sql"
        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, dump_filename)}.#{dump_ext}'");Fi[	@ii<I"        var = "sql"
        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, name)}.#{dump_ext}'");Fi[@û=I"# ==== Parameters;FI"=# source<String>:: the relative path to the source root.;FI"G# destination<String>:: the relative path to the destination root.;Fi	[	[	@xi&I"D    # <b>Encoded path note:</b> Since Thor internals use Object#respond_to? to check if it can
    # expand %something%, this `something` should be a public method in the class calling
    # #directory. If a method is private, Thor stack raises PrivateMethodEncodedError.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #                If :recursive => false, does not look for paths recursively.;Fi[	@ÇiI"Â  module Actions
    # Copies the file from the relative source to the relative destination. If
    # the destination is not given it's assumed to be equal to the source.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status, and
    #                :mode => :preserve, to preserve the file mode from the source.;Fi[	@Çi)I"Ü    
    # Links the file from the relative source to the relative destination. If
    # the destination is not given it's assumed to be equal to the source.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #;Fi[	@Çi_I"»    # Gets an ERB template at the relative source, executes it and makes a copy
    # at the relative destination. If the destination is not given it's assumed
    # to be equal to the source removing .tt from the filename.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #;Fi[@6I@'`I"end;FI" ;Fi	[	[	@™i I"º        @var ||= 21
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      ;Fi[	@ªi"I"º        @var ||= 22
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      ;Fi[	@√iI"Ω        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      ;Fi[	@»iI"Ω        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "")
      end
      
      private
      ;Fi[@û=I" #   person.pets.size # => 2;TI"#   person.pets;TI"#   # => [;Ti	[	[	@îiΩI"@      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiıI"@      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îi-I"A      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiMI"-      #
      #   person.pets.destroy("4")
      #   # => #<Pet id: 4, name: "Benny", person_id: 1>
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>;Ti[@N@	Z@
ZI"/var = (((var - (2 * @var)) * 1000) / @var);Fi	[	[	@LiÕI"7      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[	@Oi’I"9      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + var)
            var = (var + 1);Fi[	@RiºI"7      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[	@UißI"%      if (var > var) then
        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1);Fi[@6I@7I@8II"##;Fi	[	[	@√i!I"–      @var = Array.new
      @var = Array.new
      @var = ""
      instance_eval(&var) if block_given?
    end
    
    ##
    # Adds new paths to the @paths instance variable array
    def function(arglist);Fi[	@{i!I"        @var ||= false
        @var ||= true
        @var ||= nil
        instance_eval(&var) if block_given?
      end
      
      ##
      # This is called as part of the procedure run by the Packager.
      # It sets up the needed options to pass to the openssl command,;Fi[	@ÓiI"        # the block from the user's configuration file is evaluated.
        def function(arglist)
          super
          instance_eval(&var) if block_given?
        end
        
        ##
        # Performs the RSync::Local operation
        # debug options: -vhP;Fi[	@¯i(I"÷          super
          @var ||= 22
          @var ||= false
          instance_eval(&var) if block_given?
        end
        
        ##
        # Performs the RSync:Push operation
        # debug options: -vhP;Fi[@û=I"#   class Vehicle;F@tLI"#       event :ignite do;Fi	[	[	@&i?I"¯    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@&iqI"    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[	@=<iBI"    # 
    # When a new state is defined, a predicate method for that state is
    # generated on the class.  For example,
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition all => :idling
    #       end;Fi[	@„i˚I"Ú    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end;Fi[I""include(Backup::CLI::Helpers);FI" ;FI",include(Backup::Configuration::Helpers);FI" ;Fi	[	[	@FiI"‰module Backup
  module Compressor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##
      # Yields to the block the compressor command and filename extension.;Fi[	@`iI"’module Backup
  module Database
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##
      # Creates a new instance of the MongoDB database object;Fi[	@uiI"¬module Backup
  module Encryptor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      def function(arglist)
        load_defaults!;Fi[	@œiI"Æmodule Backup
  module Syncer
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      attr_accessor(:path)
      ;Fi[@û=I"#   person.pets;TI"#   # => [;T@È<i	[	[	@îi(I"C      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiaI"C      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiI"C      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îiòI"C      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@û=@SaI"7#     state_machine :state, :initial => :parked do;FI"#       ...;Fi	[	[	@=<i◊I"ø    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end;Fi[	@=<iÂI"    # the default behavior of initializing the state machine attributes is used.
    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     ;Fi[	@=<iˆI"(    # never get initialized.  In order to ensure that all initialization hooks
    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     ;Fi[	@=<iI"    # 
    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     ;Fi[@NI"@var = @var;FI"@var = @var;FI"@var = @var;Fi	[	[	@Ui7I"™    end
    if var.!=(@var) then
      if (var == "P") then
        @var = @var
        @var = @var
        @var = @var
        @var = @var
      else
        @var = @var;Fi[	@Ui<I"ß        @var = @var
        @var = @var
      else
        @var = @var
        @var = @var
        @var = @var
        @var = @var
      end
      @var = (@var - @var);Fi[	@cil	I"™    end
    if var.!=(@var) then
      if (var == "P") then
        @var = @var
        @var = @var
        @var = @var
        @var = @var
      else
        @var = @var;Fi[	@ciq	I"ß        @var = @var
        @var = @var
      else
        @var = @var
        @var = @var
        @var = @var
        @var = @var
      end
      @var = (@var - @var);Fi[I"@var = @var = nil;TI"end;FI" ;FI"def function(arglist);Fi	[	[	@äi%I"      def function(arglist)
        @var = (var or EmptyBackground.new)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
        @var = @var = nil
      end
      
      def function(arglist)
        return if @var
        @var.init;Fi[	@¨i.I"•        @var = []
        @var = []
        @var = default_options
        @var = @var = nil
      end
      
      def function(arglist)
        @var[var]
      end;Fi[	@riI"≥      def function(arglist)
        @var = var
        @var = var
        @var = @var = nil
      end
      
      def function(arglist)
        @var = var
        case @var.arity;Fi[	@uiI"≤      def function(arglist)
        @var = var
        @var = var
        @var = @var = nil
      end
      
      def function(arglist)
        begin
          if @var.nil? then;Fi[@û=I"/#     state_machine :initial => :parked do;FI"#       event :ignite do;FI",#         transition :parked => :idling;Fi	[	[	@§iI"        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@§iWI"        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@§i{I"        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end;Fi[	@=<iåI"¸    #   class Vehicle
    #     include DataMapper::Resource
    #     property :id, Serial
    #     
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[@û=I"K#   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">;FI".#   vehicle.state           # => "parked";FI"#;Fi	[	[	@=<i›I"P    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,
    # the default behavior of initializing the state machine attributes is used.;Fi[	@=<iI"L    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling
    # <tt>super()</tt> will not only call the superclass's +initialize+, but;Fi[	@=<iI"h    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually
    # in cases where you want to change how static / dynamic initial states get;Fi[	@=<i-I"O    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid
    # initialization issues when +nil+ is a valid state.  Without passing in;Fi[I"reconnect_ssl;FI"end;FI" ;FI"##;Fi	[	[	@oiI"«  # Sets the SSL certificate authority file.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Overrides the default SSL certificate store used for verifying
  # connections.;Fi[	@oiI"‰  # connections.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # Finishes all connections on the given +thread+ that were created before
  # the given +generation+ in the threads +generation_key+ list.;Fi[	@oiI"Ç      end
    end
    reconnect
    reconnect_ssl
  end
  
  ##
  # Creates a URI for an HTTP proxy server from ENV variables.
  #;Fi[	@oiËI"Ø  # certificate store or set the ca file instead.
  def function(arglist)
    @var = var
    reconnect_ssl
  end
  
  ##
  # SSL verification callback.
  def function(arglist);Fi[I"@var = (@var + 1);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@«i0I"‘        var[:class] += " #{status}" if var
        build_cell(@var, var, var)
        set_scenario_color(var)
        @var = (@var + 1)
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@ﬁiÉI"Û          @var.tag!("system-out")
          @var.tag!("system-err")
        end
        @var = (@var + 1)
      end
      
      def function(arglist)
        (["#{exception.message} (#{exception.class})"] + var.backtrace).join("\n")
      end;Fi[	@Êi¿I"…      
      def function(arglist)
        return unless @var
        @var = (@var + 1)
      end
      
      def function(arglist)
        return if (@var.! or @var)
        var ||= (@var or :passed);Fi[	@9i8I"        end
        
        def function(arglist)
          @var = (@var + 1)
        end
        
        def function(arglist)
          move_progress
          @var.puts("    <dd class=\"spec passed\"><span class=\"passed_spec_name\">#{h(example.description)}</span></dd>");Fi[@û=I"%# @return [Array<Twitter::User>];FI"def function(arglist);FI"S@var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) };Fi	[	[	@iI"ˆ      end
      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end;Fi[	@iI"˚      end
      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end;Fi[	@i&I"˜      end
      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end;Fi[	@iI"˜      end
      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end;Fi[I"# Returns true;FI"def function(arglist);FI"	true;FI"end;Fi	[	[	@çiuI"ø        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true if SQLite version is '3.6.8' or greater, false otherwise.;Fi[	@çiéI"à        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[	@çi§I"á        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true;Fi[	@çi©I"à        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      
      def function(arglist);Fi[@û=@◊@I"var = case var;FI"when :success then;Fi	[	[	@Ñi.I"c      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[	@ëi,I"c      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[	@îi6I"c      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :failure then;Fi[	@ói*I"c      # : Notification will be sent, including the Exception which caused
      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then;Fi[I"G# destination<String>:: the relative path to the destination root.;FI"C# config<Hash>:: give :verbose => false to not log the status.;FI"#;FI"# ==== Examples;Fi	[	[	@i
I"    # Creates an empty directory.
    #
    # ==== Parameters
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   empty_directory "doc";Fi[	@Çi,I"+    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   link_file "README", "doc/README";Fi[	@ÇiBI"8    #
    # ==== Parameters
    # source<String>:: the address of the given content.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   get "http://gist.github.com/103208", "doc/README";Fi[	@ÇibI"*    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples
    #
    #   template "README", "doc/README";Fi[@û=I"# @note Undocumented;FI"# @rate_limited Yes;FI",# @authentication Requires user context;Fi	[	[	@>iI"K      include(Twitter::API::Utils)
      
      # Returns activity about me
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] An array of actions;Fi[	@>i!I"5      end
      
      # Returns activity by friends
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid./
      # @return [Array] An array of actions;Fi[	@>iMI"G      end
      
      # Returns activity summary for a Tweet
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.;Fi[	@>i`I"s      (alias :tweet_activity :status_activity)
      
      # Returns activity summary for Tweets
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.;Fi[@'@¸@ˇ,I"shutup do |arglist|;Fi	[	[	@∆iI"class PatchingTests < Test::Unit::TestCase
  def function(arglist)
    File.open(var, "r") { |arglist| var.read }
  end
  
  def function(arglist)
    shutup do |arglist|
      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[	@∆i(I"˘        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[	@∆i2I"ı        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[	@∆i<I"ı        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP");Fi[@û=I"%#     def attribute_short?(attr);FI""#       send(attr).length < 5;FI"#     end;Fi	[	[	@˝iPI"ø      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@˝iåI"¡      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@˝i–I"æ      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[	@˝iÛI"æ      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #;Fi[@ÉI@sWI"	next;FI"end;Fi	[	[	@Li|I"Ø        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[	@OiqI"Õ        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then
        var = (var + (var[var.chr] or 0));Fi[	@RikI"Ø        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then
        var = var;Fi[	@ciQI"∏        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var == " "[0]) then
        var = var;Fi[@≈UI"$#     include Mongoid::Document;FI"#     field :title;FI"#;Fi	[	[	@ÙiI"∑      #
      # @example
      #
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_uniqueness_of :title
      #   end;Fi[	@ÙiâI"Ó      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end;Fi[	@ÙiöI"‚      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end;Fi[	@Ùi´I"˘      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_presence_of :title
      #   end;Fi[@öOI"#;F@«UI",#     attribute_method_suffix '_short?';Fi	[	[	@˝iII"¸      # least the +attr+ argument.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@˝iÉI"      # Allows you to make aliases for attributes.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #;Fi[	@˝i≈I"      # method, or they will not hook in.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #
      #     # Call to define_attribute_method must appear after the;Fi[	@˝iÏI"'      # Removes all the previously dynamically defined methods from the class.
      #
      #   class Person
      #     include ActiveModel::AttributeMethods
      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #;Fi[@û=I"#     private;FI"#;F@#bi	[	[	@˝iNI"˜      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[	@˝iäI"ﬁ      #     define_attribute_methods :name
      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[	@˝iŒI"      #     # attribute_method_prefix, attribute_method_suffix or
      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[	@˝iÒI"ˆ      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end;Fi[@ÉII"var = (var + 1);FI"	next;FI"end;Fi	[	[	@Li—I"T            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@Ri¿I"T            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@Ui´I"G            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var)
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var);Fi[	@ciƒI"0            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (var - (3 * @var))
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var)
          Cell(var, var, var[var, (var - 1)], 0, 2, "", var, var);Fi[I"#     private;FI"#;F@#b@$bi	[	[	@˝iOI"Â      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@˝iãI"¡      #
      #     alias_attribute :nickname, :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@˝iœI"Â      #     # attribute_method_affix declares.
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[	@˝iÚI"‰      #     attribute_method_suffix '_short?'
      #     define_attribute_method :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end;Fi[I"destination;FI"end;FI"end;FI"end;Fi	[	[	@ i&I"v    
    def function(arglist)
      FileUtils.cp(var.path, destination.path)
      destination
    end
  end
end;Fi[	@ i"I"˘      else
        FileUtils.cp(var.path(@var), destination.path)
      end
      destination
    end
  end
end
Paperclip.io_adapters.register(Paperclip::AttachmentAdapter) do |arglist|
  (Paperclip::Attachment.===(var) or Paperclip::Style.===(var));Fi[	@z"iI"¡        destination.write(var)
      end
      destination.rewind
      destination
    end
  end
end
Paperclip.io_adapters.register(Paperclip::StringioAdapter) do |arglist|
  StringIO.===(var);Fi[	@"i&I"≠      end
      var.close
      destination.rewind
      destination
    end
  end
end
Paperclip.io_adapters.register(Paperclip::UriAdapter) do |arglist|
  var.kind_of?(URI);Fi[@ÉI@°[I"var = -1;FI"var = var;Fi	[	[	@UinI"¸              out(sprintf("%.3f Tw", (@var * @var)))
            end
            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0;Fi[	@Ui≥I"          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        else
          self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@ciiI"Â            out(sprintf("%.3f Tw", (@var * @var)))
          end
          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0;Fi[	@ciÃI"          Cell(var, var, var[var, (var - 1)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[@√NI"end;FI"end;FI"end;Fi	[	[	@i\I"°          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@iÑI"s          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@i?I"{          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[	@2iSI"Ñ          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end
end;Fi[@@J@AJ@BJ@≠ai	[	[	@=<i€I"ˇ    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[	@=<iˇI"    #     def initialize(attributes = {})
    #       ...
    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[	@=<iI"    #     def initialize(attributes = {})
    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[	@=<i+I"     #       initialize_state_machines(:static => :force) do
    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # ;Fi[I"var = var.length;FI"var = -1;FI"var = 0;FI"var = 0;Fi	[	[	@Li±I"æ    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@Oi¨I"æ    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@Ri†I"æ    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[	@UiâI"æ    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0
    var = 1;Fi[I"#extend(ActiveSupport::Concern);FI" ;FI"module ClassMethods;FI"def function(arglist);Fi	[	[	@0iI"rmodule ActiveModel
  module DeprecatedMassAssignmentSecurity
    extend(ActiveSupport::Concern)
    
    module ClassMethods
      def function(arglist)
        raise("`attr_protected` is extracted out of Rails into a gem. Please use new recommended protection model for params(strong_parameters) or add `protected_attributes` to your Gemfile to use old one.")
      end;Fi[	@iVI"Ò      end
      
      module Behavior
        extend(ActiveSupport::Concern)
        
        module ClassMethods
          def function(arglist)
            var = if var.delete(:serialized) { |arglist| true } then
              :serialized;Fi[	@¯iI"≤module ActiveRecord
  module Sanitization
    extend(ActiveSupport::Concern)
    
    module ClassMethods
      def function(arglist)
        connection.quote(var, var)
      end;Fi[	@qiI"‚module Devise
  module Controllers
    module ScopedViews
      extend(ActiveSupport::Concern)
      
      module ClassMethods
        def function(arglist)
          defined? @var ? (@var) : (Devise.scoped_views)
        end;Fi[@»J@…J@CJI"#   person.name = '';Fi	[	[	@ViDI"˚        #     def set_status
        #       self.status = errors.empty?
        #     end
        #   end
        #
        #   person = Person.new
        #   person.name = ''
        #   person.valid? # => false
        #   person.status # => false;Fi[	@piÑI"      #
      #     attr_accessor :name
      #     validates! :name, presence: true
      #   end
      #
      #   person = Person.new
      #   person.name = ''
      #   person.valid?
      #   # => ActiveModel::StrictValidationFailed: Name can't be blank;Fi[	@ï7i–I"œ    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.valid? # => false
    #   person.name = 'david';Fi[	@ï7i˜I"–    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.invalid? # => true
    #   person.name = 'david';Fi[@µ I"# @param klass [Class];FI"%# @param request_method [Symbol];FI"# @param path [String];Fi	[	[	@Di%I"ı        end
        objects_from_response(Twitter::User, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@Di0I"        merge_user!(var.options, var.pop)
        objects_from_response(var, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Array];Fi[	@DiAI"ı      def function(arglist)
        var.map { |arglist| var.fetch_or_new(var) }
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array];Fi[	@DiMI"          object_from_response(var, var, var, var.options.merge(:id => (var)))
        end
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Object];Fi[@µ I"%# @param request_method [Symbol];FI"# @param path [String];FI"# @param args [Array];Fi	[	[	@!i I"»      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[	@;i˛I"…      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>]
      def function(arglist);Fi[	@DiI"ÿ      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[	@DiI"          object_from_response(Twitter::User, var, var, merge_user(var.options, var))
        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[@»J@…JI"def function(arglist);FI"2var = var.last.is_a?(Hash) ? (var.pop) : ({});Fi	[	[	@ÇiKI"    #
    #   get "http://gist.github.com/103208" do |content|
    #     content.split("\n").first
    #   end
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var = var.first
      unless var =~ /^https?\:\/\// then;Fi[	@ÇiëI"    #
    #   prepend_to_file 'config/environments/test.rb' do
    #     'config.gem "rspec"'
    #   end
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var.merge!(:after => /\A/)
      insert_into_file(var, *(var << var), &var);Fi[	@Çi®I"    #
    #   append_to_file 'config/environments/test.rb' do
    #     'config.gem "rspec"'
    #   end
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var.merge!(:before => /\z/)
      insert_into_file(var, *(var << var), &var);Fi[	@Çi¡I"b    #
    #   inject_into_class "app/controllers/application_controller.rb", ApplicationController do
    #     "  filter_parameter :password\n"
    #   end
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var.merge!(:after => (/class #{var}\n|class #{var} .*\n/))
      insert_into_file(var, *(var << var), &var);Fi[I"var = 1;F@ûII"var = var[var];FI"if (var == "\n"[0]) then;Fi	[	[	@UiHI"™    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@UiéI"Ÿ    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var)
        var = (var + 1);Fi[	@ciAI"™    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then
          @var = 0;Fi[	@ci™I"÷    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[@¯b@ûI@ÆVI"var = (var < 128);Fi	[	[	@LirI"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@Li∂I"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[	@RiaI"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@Ri•I"    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[I"J# Determines what the response should be for a particular bit of text;FI"H# from the SCM. Password prompts, connection requests, passphrases,;FI"# etc. are handled here.;FI"def function(arglist);Fi	[	[	@`iII"B          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          logger.info("[#{stream}] #{text}")
          case var;Fi[	@li}I"n          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}");Fi[	@{i>I"P          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          case var
          when /\(P4PASSWD\) invalid or unset\./i then;Fi[	@ÇiEI"c          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}");Fi[I"@var ||= var;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@riI"Ê      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_comment(@var) unless @var.empty?;Fi[	@uiI"»      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var
        @var.init if @var;Fi[	@xiI"Ã      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var)
      end;Fi[	@êiI"¢      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false
      end;Fi[@»J@…JI"/# @param [ Proc ] block The block to call.;FI"#;Fi	[	[	@I
iI"˜      # @example Execute common delete logic.
      #   prepare do |doc|
      #     collection.remove({ :_id => "value })
      #   end
      #
      # @param [ Proc ] block The block to call.
      #
      # @return [ true ] Always true.
      #;Fi[	@L
iI"
      # @example Execute common insertion logic.
      #   prepare do |doc|
      #     collection.insert({ :field => "value })
      #   end
      #
      # @param [ Proc ] block The block to call.
      #
      # @return [ Document ] The inserted document.
      #;Fi[	@O
iI"#      # @example Execute common modification logic.
      #   prepare do |doc|
      #     collection.update({ :_id => 1 }, { :field => "value })
      #   end
      #
      # @param [ Proc ] block The block to call.
      #
      # @return [ true, false ] If the save passed or not.
      #;Fi[	@Ü
iI"+      # @example Execute common upsert logic.
      #   prepare do |doc|
      #     collection.find({ :_id => 1 }).upsert({ name: "test" }, [ :upsert ])
      #   end
      #
      # @param [ Proc ] block The block to call.
      #
      # @return [ true, false ] If the save passed or not.
      #;Fi[@µ I" @var = { :action => :save };FI" ;FI")def self.matching_ancestors(arglist);Fi	[	[	@ûiI"Ë      include(ActiveModel)
      
      require("state_machine/integrations/active_record/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["ActiveRecord::Base"]
      end;Fi[	@∫iI"Í      include(ActiveModel)
      
      require("state_machine/integrations/mongo_mapper/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["MongoMapper::Document"]
      end;Fi[	@¬iI"·      include(ActiveModel)
      
      require("state_machine/integrations/mongoid/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["Mongoid::Document"]
      end;Fi[	@ iI"’      include(Base)
      
      require("state_machine/integrations/sequel/versions")
      
      @var = { :action => :save }
      
      def self.matching_ancestors(arglist)
        ["Sequel::Model"]
      end;Fi[I"(@var << [var, var]);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@ÈiáI"≠      
      def function(arglist)
        @var ||= []
        (@var << [var, var])
      end
      
      def function(arglist)
        if defined? @var then
          @var;Fi[	@çi I"®      end
      
      def function(arglist)
        (@var << [var, var])
      end
      
      def function(arglist)
        return if @var
        attach_steps(@var);Fi[	@û;iI"Ï    end
    
    def function(arglist)
      (@var << [var, var])
    end
    
    def function(arglist)
      @var.each { |arglist| return var if var.call(var) }
      raise(NoHandlerError.new("No handler found for #{target.inspect}"));Fi[	@qi∑I"‡          @var = true
        end
        @var ||= []
        (@var << [var, var])
      end
      
      def function(arglist)
        @var ||= [["progress", @var]]
        @var ||= load_formatters(@var, EXAMPLE_FORMATTERS);Fi[@µ I")undef_method(:namespace_definitions);FI" ;FI"2undef_method(:line) if method_defined?(:line);Fi	[	[	@@iI"“      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@QiI"“      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@Wi	I"Á  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist);Fi[	@ZiI"’      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist);Fi[@»J@…J@≠a@Æai	[	[	@=<i‹I"6    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # In the above example, no +initialize+ method is defined.  As a result,;Fi[	@=<i I"    #       ...
    #       super()
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # Because of the way the inclusion of modules works in Ruby, calling;Fi[	@=<iI"(    #       ...
    #       initialize_state_machines
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # You may also need to call the +initialize_state_machines+ helper manually;Fi[	@=<i,I"    #         ...
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
    #   vehicle.state           # => "parked"
    # 
    # The above example is also noteworthy because it demonstrates how to avoid;Fi[@'@¸@ˇ,I"case @var;Fi	[	[	@ØiI"Z  
  def function(arglist)
    "    Unsatisfied dependency: #{@module_name}\n    Homebrew does not provide #{@language.to_s.capitalize} dependencies; install with:\n      #{command_line} #{@module_name}\n".undent
  end
  
  def function(arglist)
    case @var
    when :chicken then
      ["/usr/bin/env", "csi", "-e", "(use", "#{@import_name})"];Fi[	@Øi+I"Å    else
      # do nothing
    end
  end
  
  def function(arglist)
    case @var
    when :chicken then
      "chicken-install";Fi[	@bi,I"§        rescue Exception => var
          @var = var
        end
      end
      
      def function(arglist)
        case @var
        when nil then
          true;Fi[	@Öi*I"ƒ      
      def function(arglist)
        [time_in_cron_syntax, task].compact.join(" ").strip
      end
      
      def function(arglist)
        case @var
        when REGEX then
          @var;Fi[@'@¸@ˇ,I"var = var.dup;Fi	[	[	@‰i
I"∫      end
      var = var.to_s.strip
      [var, var, var, var, var, var, var, var, (var or @var)]
    end
    
    def function(arglist)
      var = var.dup
      var = @var
      begin;Fi[	@‰iI"∂      end
      var = var[(1...-1)] if var
      return [var, var, var]
    end
    
    def function(arglist)
      var = var.dup
      var = StringScanner.new(var)
      var = @var;Fi[	@æigI"ˇ    
    def function(arglist)
      "<style type='text/css'>#{OmniAuth.config.form_css}</style>"
    end
    
    def function(arglist)
      var = var.dup
      var.keys.each do |arglist|
        if var[var].is_a?(::Hash) and var[var].is_a?(::Hash) then;Fi[	@l i-I"Ù      
      def function(arglist)
        var.all? { |arglist| var.respond_to?(:<=>) } ? (var.sort) : (var)
      end
      
      def function(arglist)
        var = var.dup
        var.each do |arglist|
          if var = var.index(var) then;Fi[I"	to_s;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@!iI"{    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      value.to_s(var)
    end;Fi[	@$i;I"Ö    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      GRADIENT_ASPECTS.include?(var)
    end;Fi[	@ºi'I"ä    end
    
    def function(arglist)
      to_s
    end
    
    def function(arglist)
      var = "#{name}(#{args.join(", ")})"
    end;Fi[	@ñPiI"ô  undef :as_json
  
  def function(arglist)
    to_s
  end
  
  def function(arglist)
    ActiveSupport::XmlMini.to_tag(var[:root], self.to_s, var)
  end;Fi[I"var = @var.to_sexp;FI"var = (var + [var]) if var;FI"var = @var.to_sexp;FI""var = (var + var) if var.any?;Fi	[	[	@iiUI"˘        init
        var = [:background, @var, @var]
        var = (var + [name]) unless name.empty?
        var = @var.to_sexp
        var = (var + [var]) if var
        var = @var.to_sexp
        var = (var + var) if var.any?
        var
      end;Fi[	@uieI"2      def function(arglist)
        init
        var = [:feature, @var, name]
        var = @var.to_sexp
        var = (var + [var]) if var
        var = @var.to_sexp
        var = (var + var) if var.any?
        var = (var + [@var.to_sexp]) if @var
        var = (var + @var.map { |arglist| var.to_sexp });Fi[	@äiaI"      
      def function(arglist)
        var = [:scenario, @var, @var, name]
        var = @var.to_sexp
        var = (var + [var]) if var
        var = @var.to_sexp
        var = (var + var) if var.any?
        var = @var.to_sexp
        var = (var + var) if var.any?;Fi[	@çi`I"      def function(arglist)
        init
        var = [:scenario_outline, @var, name]
        var = @var.to_sexp
        var = (var + [var]) if var
        var = @var.to_sexp
        var = (var + var) if var.any?
        var = @var.to_sexp
        var = (var + var) if var.any?;Fi[I"@var = Time.now;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@ﬁi$I"›      
      def function(arglist)
        @var = Ast::ScenarioOutline.===(var)
        @var = Time.now
      end
      
      def function(arglist)
        @var = OrderedXmlMarkup.new(:indent => 2)
        @var.instruct!;Fi[	@ﬁi`I"Ú      
      def function(arglist)
        return unless @var
        @var = Time.now
      end
      
      def function(arglist)
        return unless @var and Cucumber::Ast::OutlineTable::ExampleRow.===(var)
        var = (Time.now - @var);Fi[	@˝iI"•      
      def function(arglist)
        @var = var
        @var = Time.now
      end
      
      def function(arglist)
        @var = (Time.now - @var)
      end;Fi[	@HiI"„        end
        
        def function(arglist)
          @var = Time.now
        end
        
        def function(arglist)
          super
          (@var << [example_group.description, var.description, (Time.now - @var)]);Fi[@	)@Ú)@Ç9I"@var = [];Fi	[	[	@LiI"í    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = []
      @var = var
      @var = var;Fi[	@_i6I"°    protected
    
    class DynamicServerList
      def function(arglist)
        @var = var
        @var = var
        @var = []
        @var = false
      end;Fi[	@ÄiI"çclass SoftwareSpec
  attr_reader(:checksum, :mirrors, :specs)
  
  def function(arglist)
    @var = var
    @var = var
    @var = []
  end
  ;Fi[	@„iQI"%    # The result of invoking the action associated with the machine
    # Whether the transition is only existing temporarily for the object
    # Creates a new, specific transition
    def function(arglist)
      @var = var
      @var = var
      @var = []
      @var = false
      @var = nil;Fi[@µ I"J# Initialize the new cascade strategy, which will set up the relation;FI"# and the metadata.;FI"#;Fi	[	[	@2i
I"4    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@;i
I"5    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@Di
I"5    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[	@Ii
I"6    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata);Fi[I"9require("spec/runner/formatter/base_text_formatter");FI"module Spec;FI"module Runner;FI"module Formatter;Fi	[	[	@/i I"¡require("spec/runner/formatter/base_text_formatter")
module Spec
  module Runner
    module Formatter
      class FailingExampleGroupsFormatter < BaseTextFormatter
        def function(arglist);Fi [	@4i I"ºrequire("spec/runner/formatter/base_text_formatter")
module Spec
  module Runner
    module Formatter
      class FailingExamplesFormatter < BaseTextFormatter
        def function(arglist);Fi [	@>i I"Ørequire("spec/runner/formatter/base_text_formatter")
module Spec
  module Runner
    module Formatter
      class NestedTextFormatter < BaseTextFormatter
        INDENT = "  ";Fi [	@Zi I"¥require("spec/runner/formatter/base_text_formatter")
module Spec
  module Runner
    module Formatter
      class SpecdocFormatter < BaseTextFormatter
        def function(arglist);Fi [@L[I"end;FI" ;FI"def function(arglist);Fi	[	[	@ui@I"±      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end;Fi[	@xiJI"⁄      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq
      end;Fi[	@Éi*I"Œ      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init
        example_rows.each { |arglist| var.skip_invoke! };Fi[	@ÉiTI"Ω        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags
        end;Fi[@µ I"E# Unbinds the base object and the inverse, caused by setting the;FI"# reference to nil.;FI"#;Fi	[	[	@¢
i%I"              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true);Fi[	@¥
i I"D              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true);Fi[	@Ω
i&I"              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true);Fi[	@ﬁ
iI"Q          def function(arglist)
            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.game.unbind(:continue => true);Fi[@'@¸@ˇ,I"Avar = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi	[	[	@
i¬I"‰      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@
i«I"Ù      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@
iÃI"Ù      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[	@
i—I"Ù      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end;Fi[I"@var.each(&var);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@}iI"£      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self
        (@var << var);Fi[	@ìi&I"Ø      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1)
        @var[(var - 1)];Fi[	@Äi∞I"  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag }
  end;Fi[	@™iI"p  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?
  end;Fi[I"Bout((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"));FI"putstream(var);FI"out("endobj");FI"end;Fi	[	[	@Ui1I"      out("endobj")
      var = @var ? (Zlib::Deflate.deflate(@var[var])) : (@var[var])
      newobj
      out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
      putstream(var)
      out("endobj")
    end
    @var[1] = @var.length
    out("1 0 obj");Fi[	@UiµI"      if (var["cs"] == "Indexed") then
        newobj
        var = @var ? (Zlib::Deflate.deflate(var["pal"])) : (var["pal"])
        out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
        putstream(var)
        out("endobj")
      end
    end
  end;Fi[	@ciI"˚      out("endobj")
      var = @var ? (gzcompress(@var[var])) : (@var[var])
      newobj
      out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
      putstream(var)
      out("endobj")
    end
    @var[1] = @var.length
    out("1 0 obj");Fi[	@ci«I"˝      if (var["cs"] == "Indexed") then
        newobj
        var = @var ? (gzcompress(var["pal"])) : (var["pal"])
        out((((("<<" + var) + "/Length ") + var.length.to_s) + ">>"))
        putstream(var)
        out("endobj")
      end
    end
  end;Fi[I"#   class Vehicle;F@yaI"#       ...;FI"#     end;Fi	[	[	@=<iÿI"†    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #   end
    #   ;Fi[	@=<iÊI"Â    # 
    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize;Fi[	@=<i˜I"    # are called, the custom method *must* call +super+ without any arguments
    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[	@=<iI"(    # If you want to avoid calling the superclass's constructor, but still want
    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {});Fi[@µ I"+api_accessible(:backbone) do |arglist|;FI"var.add(:id);FI"var.add(:guid);Fi	[	[	I"'data//diaspora_proj/models/like.rb;TiI"§  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	I"0data//diaspora_proj/models/participation.rb;TiI"î  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author)
    var.add(:created_at);Fi[	@óiI"ÿ  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:name)
    var.add(lambda { |arglist| var.diaspora_handle }, :as => :diaspora_id);Fi[	@úiI"≠  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:created_at)
    var.add(:author);Fi[@	)@0LI"@var = var.send(var.name);FI"end;Fi	[	[	@2iI"A        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@;iI"A        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[	@DiI">        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead;Fi[	@IiI"A        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.;Fi[@µ I"acts_as_api;FI" ;F@di	[	[	@#diI"∏  after_destroy { |arglist| self.parent.update_likes_counter }
  
  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid);Fi[	@&diI"ä      { :target => (@var) }
    end
  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid);Fi[	@óiI"ö  include(Encryptor::Public)
  
  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid);Fi[	@úiI"£  include(Diaspora::Commentable)
  
  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid);Fi[@'@¸@ˇ,I""";Fi	[	[	@i2I"‡      def function(arglist)
        var = eval_js("#{@regexp}.exec('#{step_name}')")
        var.to_a[(1..-1)].map { |arglist| JsArg.new(var) } if var
      end
      
      def function(arglist)
        ""
      end
    end;Fi[	@ÿ#i<I"a  
  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end
  ;Fi[	@π)i	I"é  class NilAdapter < AbstractAdapter
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end
    ;Fi[	@π)iI"i    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end
    ;Fi[I"@var.puts;FI"@var.flush;FI"end;FI" ;Fi	[	[	@∏i~I"x        if var then
          @var.puts(format_string((("\nIf you want snippets in a different programming language,\n" + "just make sure a file with the appropriate file extension\n") + "exists where cucumber looks for step definitions."), :failed))
        end
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        return unless var[:wip];Fi[	@ÊiDI"Æ      
      def function(arglist)
        @var.puts("#{keyword}: #{name}")
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2;Fi[	@ÊiNI"è      end
      
      def function(arglist)
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        @var = 2;Fi[	@ÊiZI"æ      
      def function(arglist)
        @var = nil
        @var.puts
        @var.flush
      end
      
      def function(arglist)
        print_feature_element_name(var, var, var, var);Fi[@µ I"# For testing only;FI"#:nodoc:;FI"def function(arglist);Fi	[	[	@oi*I"ª      def function(arglist)
        index(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:doc_string, to_step_definition_arg]
      end;Fi[	@ñiØI"‹        var = "table:#{headers.join(",")}"
        var.match(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:table, *cells_rows.map { |arglist| var.to_sexp }]
      end;Fi[	@ñi2I"Î          each { |arglist| var.visit_table_cell(var) }
          nil
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:row, line, *@var.map { |arglist| var.to_sexp }]
        end;Fi[	@ñitI"Ÿ        def function(arglist)
          (SurplusCell.===(var) or (value == var.value))
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:cell, @var]
        end;Fi[I"Hout(sprintf("%f %f %f %f %f %f c\n", var, var, var, var, var, var));FI"var = var;FI"var = var;FI"var = 0.0;Fi	[	[	@UiJI"œ    var = var
    var = var
    var = (var + (var * var))
    out(sprintf("%f %f %f %f %f %f c\n", var, var, var, var, var, var))
    var = var
    var = var
    var = 0.0
    var = (0.0 - var)
    var = var;Fi[	@Ui\I"œ    var = var
    var = var
    var = (var - (var * var))
    out(sprintf("%f %f %f %f %f %f c\n", var, var, var, var, var, var))
    var = var
    var = var
    var = 0.0
    var = (0.0 + var)
    var = var;Fi[	@ciPI"œ    var = var
    var = var
    var = (var + (var * var))
    out(sprintf("%f %f %f %f %f %f c\n", var, var, var, var, var, var))
    var = var
    var = var
    var = 0.0
    var = (0.0 - var)
    var = var;Fi[	@cibI"œ    var = var
    var = var
    var = (var - (var * var))
    out(sprintf("%f %f %f %f %f %f c\n", var, var, var, var, var, var))
    var = var
    var = var
    var = 0.0
    var = (0.0 + var)
    var = var;Fi[I"empty_messages;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@∏iúI"˙      
      def function(arglist)
        @var.each { |arglist| print_message(var) }
        empty_messages
      end
      
      def function(arglist)
        return if @var.empty?
        @var.print(format_string(@var.join(", "), :tag).indent(2));Fi[	@∏i£I"        return if @var.empty?
        @var.print(format_string(@var.join(", "), :tag).indent(2))
        @var.flush
        empty_messages
      end
      
      def function(arglist)
        @var.puts(format_string(var, :tag).indent(@var))
        @var.flush;Fi[	@«i<I"!        @var.each do |arglist|
          @var.li(:class => "step message") { |arglist| (@var << var) }
        end
        empty_messages
      end
      
      def function(arglist)
        return if @var.empty?
        @var.td(:class => "message") { |arglist| (@var << @var.join(", ")) };Fi[	@«iBI"Ê      def function(arglist)
        return if @var.empty?
        @var.td(:class => "message") { |arglist| (@var << @var.join(", ")) }
        empty_messages
      end
      
      def function(arglist)
        @var = []
      end;Fi[@µ @c@c@ci	[	[	@`iHI"Q          end.sort.last + " UTC")
          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          logger.info("[#{stream}] #{text}");Fi[	@li|I"T        def function(arglist)
          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host];Fi[	@{i=I"7        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          case var;Fi[	@ÇiDI"I        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host];Fi[@	)@“QI"@var = nil;FI"end;Fi	[	[	I"Gdata//bundler_proj/bundler/vendor/net/http/persistent/ssl_reuse.rb;TiI"r  
  @var = nil
  
  def function(arglist)
    super
    @var = nil
  end
  
  if (RUBY_VERSION > "1.9") then;Fi[	@';iI"É  else
    Test::Unit::TestCase
  end
    def function(arglist)
      super
      @var = nil
    end
    
    def function(arglist);Fi[	@ÉiNI"Í        attr_reader(:scenario_outline)
        
        # https://rspec.lighthouseapp.com/projects/16211/tickets/342
        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist);Fi[	@ÕiI"î      @var = var[:guard]
    end
    
    def function(arglist)
      super
      @var = nil
    end
    
    # The initial state name for this path;Fi[@ˆGI"while (var < var) do;FI"(var << var);FI"var = Time.at(var).to_a;Fi	[	[	@i°I"            var = nil
            case var
            when "months" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[4] += var
                if (var[4] > 12) then;Fi[	@i≠I"%                var = Time.local(*var).to_i
              end
            when "years" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[5] += var
                var = Time.local(*var).to_i;Fi[	@ihI"            var = nil
            case var
            when "month" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[4] += var
                if (var[4] > 12) then;Fi[	@itI"$                var = Time.local(*var).to_i
              end
            when "year" then
              var = var
              while (var < var) do
                (var << var)
                var = Time.at(var).to_a
                var[5] += var
                var = Time.local(*var).to_i;Fi[I"module Mongoid;FI"module Relations;FI"module Bindings;FI"module Referenced;Fi	[	[	@Ω
i I"∏module Mongoid
  module Relations
    module Bindings
      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we;Fi [	@Œ
i I"Æmodule Mongoid
  module Relations
    module Bindings
      module Referenced
        class Many < Binding
          # Binds a single document with the inverse relation. Used;Fi [	@’
i I"¥module Mongoid
  module Relations
    module Bindings
      module Referenced
        class ManyToMany < Binding
          # Binds a single document with the inverse relation. Used;Fi [	@ﬁ
i I"πmodule Mongoid
  module Relations
    module Bindings
      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we;Fi [@'@¸@ˇ,I"@var.puts;Fi	[	[	@ÊiKI"ô      def function(arglist)
        @var = 2
        @var = 2
      end
      
      def function(arglist)
        @var.puts
        @var.flush
      end;Fi[	@ÈiI"Œ      
      def function(arglist)
        @var, @var, @var = var, ensure_io(var, "progress"), var
      end
      
      def function(arglist)
        @var.puts
        @var.puts
        print_summary(var);Fi[	@*i"I"S        
        def function(arglist)
          (@var << ["#{@example_group.description} #{example.description}", var, var.location])
        end
        
        def function(arglist)
          @var.puts
          @var.puts("#{counter.to_s})")
          @var.puts(colorize_failure("#{failure.header}\n#{failure.exception.message}", var));Fi[	@MiI"Æ          super
          @var.print(yellow("*"))
          @var.flush
        end
        
        def function(arglist)
          @var.puts
          @var.flush
        end;Fi[@	)I"if var.nil? then;FI"nil;FI"	else;Fi	[	[	@biI"◊          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if String.===(var) then
              Hash[var.scan(HstorePair).map do |arglist|;Fi[	@biZI"Ì          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if ("empty" == var) then
              (nil..nil);Fi[	@bilI"Ì          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if Range.===(var) then
              if [var.first, var.last].all? { |arglist| Integer.===(var) } then;Fi[	@˙iI"Ω        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then
            var;Fi[@¿K@¡K@¬KI"#;Fi	[	[	@&iBI"¯    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked;Fi[	@&itI"¯    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked;Fi[	@=<inI"    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :shift_up do
    #         transition :idling => :first_gear;Fi[	@=<iüI"     # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked;Fi[@´d@¨dI"module Builders;FI"module Referenced;Fi	[	[	@i I"∞module Mongoid
  module Relations
    module Builders
      module Referenced
        class In < Builder
          # This builder either takes a foreign key and queries for the;Fi [	@i I"´module Mongoid
  module Relations
    module Builders
      module Referenced
        class Many < Builder
          # This builder either takes a hash and queries for the;Fi [	@i I"±module Mongoid
  module Relations
    module Builders
      module Referenced
        class ManyToMany < Builder
          # This builder either takes a hash and queries for the;Fi [	@&i I"∑module Mongoid
  module Relations
    module Builders
      module Referenced
        class One < Builder
          # This builder either takes an _id or an object and queries for the;Fi [@´ZI"end;FI"end;FI" ;Fi	[	[	@ iI"ù        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Comment.find(params[:id]);Fi[	@ÌiI"«        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id);Fi[	@ÂiÇI"      Webfinger.in_background(params[:diaspora_handle], :single_aspect_form => (true))
      render(:nothing => (true))
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    @var = Person.find_by_guid(params[:person_id]);Fi[	@ÚiJI"ﬂ        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  
  def function(arglist)
    var = current_user.photos.where(:id => (params[:id])).first;Fi[@	)@˛2@ˇ2I"def function(arglist);Fi	[	[	@ói/I"Ó        def function(arglist)
          defined? I18n ? (super) : (var ? (var.to_s.humanize.downcase) : ("nil"))
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end;Fi[	@ói2I"™        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end;Fi[	@ói5I"≥        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          :activerecord
        end;Fi[	@µi7I"≥        def function(arglist)
          false
        end
        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing
        end;Fi[@ˆG@˜GI"var = 0;FI"var = (var + 1);Fi	[	[	@UiTI"‰        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[	@UiqI"≈            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else;Fi[	@ciNI"·        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next;Fi[	@cilI"≥          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else;Fi[I"acts_as_api;FI" ;F@dI"var.add(:id);Fi	[	[	@#diI"é  
  xml_attr(:positive)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author);Fi[	@&diI"É    end
  end
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:author);Fi[	@óiI"ê  
  include(Diaspora::Guid)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:name);Fi[	@úiI"õ  
  include(Diaspora::Shareable)
  
  acts_as_api
  
  api_accessible(:backbone) do |arglist|
    var.add(:id)
    var.add(:guid)
    var.add(:created_at);Fi[I"include(Base);FI" ;FI"# @see Base#render;FI"def function(arglist);Fi	[	[	@HiéI"É    end
    
    module Plain
      include(Base)
      
      # @see Base#render
      def function(arglist)
        var
      end;Fi[	@HiøI"º    end
    
    module Cdata
      include(Base)
      
      # @see Base#render
      def function(arglist)
        "<![CDATA[#{("\n" + text).rstrip.gsub("\n", "\n    ")}\n]]>"
      end;Fi[	@Hi»I"†    end
    
    module Escaped
      include(Base)
      
      # @see Base#render
      def function(arglist)
        Haml::Helpers.html_escape(var)
      end;Fi[	@HiﬂI"û    end
    
    module Preserve
      include(Base)
      
      # @see Base#render
      def function(arglist)
        Haml::Helpers.preserve(var)
      end;Fi[@µ @`I" ;F@`i	[	[	@™i
I"¬  module Storage
    class FTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:passive_mode);Fi[	@ªiI"¿      include(Backup::CLI::Helpers)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      attr_accessor(:local);Fi[	@√iI"®  module Storage
    class SCP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##;Fi[	@»iI"©  module Storage
    class SFTP < Base
      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##;Fi[@µ I"# Returns true;F@‰aI"	true;Fi	[	[	@çitI"å      def function(arglist)
        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@çiçI"à      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@çi£I"é      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[	@çi®I"à      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end
      ;Fi[I"%#         transition all => :off;FI"#       end;FI"#     end;FI"#   end;Fi	[	[	@&iQI"
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	@&i~I"
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">;Fi[	@=<iïI"‰    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   
    #   # Fire +ignite+ event directly;Fi[	@=<i–I"Â    #       end
    #       
    #       event :turn_off do
    #         transition all => :off
    #       end
    #     end
    #   end
    # 
    # The above class defines two state machines: +heater_state+ and +alarm_state+.;Fi[I"%puts("The offending files are:");FI"puts(var);FI"@var = true;FI"end;Fi	[	[	@®i6I"7      puts("For Java software, it is typically better for the formula to")
      puts("install to \"libexec\" and then symlink or wrap binaries into \"bin\".")
      puts("See \"activemq\", \"jruby\", etc. for examples.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  ;Fi[	@®iFI"Ó    unless var.empty? then
      opoo("Non-libraries were installed to \"lib\".")
      puts("Installing non-libraries to \"lib\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  ;Fi[	@®iRI"Ú    unless var.empty? then
      opoo("Non-executables were installed to \"bin\".")
      puts("Installing non-executables to \"bin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  ;Fi[	@®i^I"Ù    unless var.empty? then
      opoo("Non-executables were installed to \"sbin\".")
      puts("Installing non-executables to \"sbin\" is bad practice.")
      puts("The offending files are:")
      puts(var)
      @var = true
    end
  end
  ;Fi[I"$1.to_i;FI"end;FI"end;FI" ;Fi	[	[	@¡ieI"  def function(arglist)
    @var ||= if locate("gcc-4.0") then
      `#{locate("gcc-4.0")} --version` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("gcc-4.2") and locate("gcc-4.2").realpath.basename.to_s =~ /^llvm/.! then;Fi[	@¡ilI"  def function(arglist)
    @var ||= if locate("gcc-4.2") and locate("gcc-4.2").realpath.basename.to_s =~ /^llvm/.! then
      `#{locate("gcc-4.2")} --version` =~ /build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("llvm-gcc") then;Fi[	@¡isI"‹  def function(arglist)
    @var ||= if locate("llvm-gcc") then
      `#{locate("llvm-gcc")} --version` =~ /LLVM build (\d{4,})/
      $1.to_i
    end
  end
  
  def function(arglist)
    @var ||= if locate("clang") then;Fi[	@¡i|I"˝  def function(arglist)
    @var ||= if locate("clang") then
      `#{locate("clang")} --version` =~ /tags\/Apple\/clang-(\d{2,})/
      $1.to_i
    end
  end
  
  # See these issues for some history:
  # http://github.com/mxcl/homebrew/issues/#issue/13;Fi[@H;@I;I"end;FI"end;Fi	[	[	@biLI"´        end
        unless var.empty? then
          (reader::HISTORY << var)
          return var
        end
      end
    end
    
    # Display a verbose help message.;Fi[	I"]data//redmine_proj/plugins/open_id_authentication/lib/open_id_authentication/db_store.rb;Ti#I"¢          if (var.expires_in == 0) then
            var.destroy
          else
            return var
          end
        end
      end
      return nil
    end;Fi[	@i∆I"~          end
        end
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
    end
  end
end;Fi[	@iàI"~          end
        end
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
    end
  end
end;Fi[I"fatal(true);FI" ;FI"env(:userpaths);FI" ;Fi	[	[	@ØiiI"ãclass MPIDependency < Requirement
  attr_reader(:lang_list)
  
  fatal(true)
  
  env(:userpaths)
  
  def function(arglist)
    @var = var;Fi[	@Øi∫I"É  end
end
class MysqlInstalled < Requirement
  fatal(true)
  
  env(:userpaths)
  
  satisfy { |arglist| which("mysql_config") }
  ;Fi[	@Øi≈I"Ö  end
end
class PostgresqlInstalled < Requirement
  fatal(true)
  
  env(:userpaths)
  
  satisfy { |arglist| which("pg_config") }
  ;Fi[	@Øi–I"å  end
end
class TeXInstalled < Requirement
  fatal(true)
  
  env(:userpaths)
  
  satisfy { |arglist| (which("tex") or which("latex")) }
  ;Fi[@H;@I;@heI" ;Fi	[	[	@kisI"Ô            end
            var = ActiveRecord::Result.new(var.fields, var.values, var)
            var.clear
            return var
          end
        end
        
        def function(arglist)
          log(var, var, var) do |arglist|;Fi[	@
i’I"             var = ((var + " ") + var)
            run(var, var, &var)
          else
            return var
          end
        end
        
        # Returns a Proc object that defines the behavior of the sudo
        # callback. The returned Proc will defer to the +fallback+ argument;Fi[	@eiMI"Ê            var = yield(scm(:changes, "--last 1", "--xml-output", "--repo=#{repository}"))
            return var[/hash='(.*?)'/, 1]
          else
            return var
          end
        end
        
        private
        ;Fi[	@Ui|I"            yield("Invalid #{encoding.name} character #{e.error_char.dump}\n".rstrip, (var + 1))
          end
        end
        return var
      end
    end
    
    if (RUBY_VERSION < "1.9") then
      # Like {\#check\_encoding}, but also checks for a Ruby-style `-# coding:` comment;Fi[@	)I"exec_query(var, var, var);FI"end;FI" ;Fi	[	[	@0iKI"û      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@0iRI"û      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with;Fi[	@0iYI"U      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Returns the last auto-generated ID from the affected table.
      #;Fi[	@çiπI"È      
      protected
      
      def function(arglist)
        exec_query(var, var, var)
      end
      
      def function(arglist)
        var = exec_query("PRAGMA table_info(#{quote_table_name(table_name)})", "SCHEMA").to_hash;Fi[@µ @:NI"A# Transfers the archived file to the specified remote server;FI"def function(arglist);Fi	[	[	@™i7I"›          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	@ªi7I"‘          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin
          (write_password_file! unless local;Fi[	@√i+I"›          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[	@»i)I"›          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|;Fi[@µ @∂ @∑ @ﬂbi	[	[	@!i˛I"˙      def function(arglist)
        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@$iqI"Ú      def function(arglist)
        object_from_response(Twitter::Place, :post, "/1.1/geo/place.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash];Fi[	@;i¸I"˙          object_from_response(Twitter::OEmbed, :get, "/1.1/statuses/oembed.json?id=#{id}", var.options)
        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@DiI"≥  module API
    module Utils
      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[I",@var = sprintf("%.3f g", (var / 255.0));FI"	else;FI"U@var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0));FI"end;Fi	[	[	@UiI"/  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[	@Ui$I"  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end;Fi[	@ciÃI"1  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0);Fi[	@ciÏI"4  	#
  def function(arglist)
    if (((var == 0) and ((:g == 0) and (:b == 0))) or (:g == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    @var = [var, var, var] if var;Fi[@'@¸@ˇ,I"var = pages(:welcome);Fi	[	[	@èiI"˛    assert_equal(1, var.versions.size)
    assert_equal(1, var.version)
    assert_instance_of(Page.versioned_class, var.versions.first)
  end
  
  def function(arglist)
    var = pages(:welcome)
    var = var.versions.count
    var.save_without_revision;Fi[	@èiI"+    var.save_without_revision
    var.without_revision { |arglist| var.update_attributes(:title => "changed") }
    assert_equal(var, var.versions.count)
  end
  
  def function(arglist)
    var = pages(:welcome)
    assert_equal(24, var.version)
    assert_equal("Welcome to the weblog", var.title);Fi[	@èi9I"¯    assert_nothing_raised do |arglist|
      locked_pages(:welcome).versions.first.hello_world
    end
  end
  
  def function(arglist)
    var = pages(:welcome)
    assert_equal(24, var.version)
    assert_equal("Welcome to the weblog", var.title);Fi[	@èiI"⁄    var.destroy
    assert_equal(0, Widget.count)
    assert_equal(1, Widget.versioned_class.count)
  end
  
  def function(arglist)
    var = pages(:welcome)
    var = var.versions.last
    assert_equal(var, var.page);Fi[@'@¸@ˇ,I"broadcast(var, var);Fi	[	[	@ûi(I"ì      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@ûiAI"≤      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@ûieI"≤      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[	@ûiuI"≤      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      ;Fi[I"assert(var.universal?.!);FI"assert(var.i386?.!);FI"assert(var.x86_64?.!);FI"assert(var.ppc7400?.!);Fi	[	[	@◊OinI"˘  
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/tarballs/testball-0.1.tbz")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@◊OiçI"˘  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#!/bin/sh")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@◊OiùI"  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@◊Oi≠I"Û  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write(" #!")
    assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[I"$var = read_file("libexec/NOOP");FI":assert(var.include?("NOOP").!, "File was unpatched.");FI"Fassert(var.include?("ABCD"), "File was not patched as expected.");FI"end;Fi	[	[	@∆i#I"2  def function(arglist)
    shutup do |arglist|
      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end;Fi[	@∆i-I"4  def function(arglist)
    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end;Fi[	@∆i7I"0  def function(arglist)
    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end;Fi[	@∆iAI"0  def function(arglist)
    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end;Fi[@‰e@ÂeI"end;FI"end;Fi	[	[	@∆i$I"    shutup do |arglist|
      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  ;Fi[	@∆i.I"    shutup do |arglist|
      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  ;Fi[	@∆i8I"    shutup do |arglist|
      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  ;Fi[	@∆iBI"    shutup do |arglist|
      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
end;Fi[@IY@JY@KYI" ;Fi	[	[	@õi&I"          var[:available_queries_for_explain] = nil
        end
      else
        yield
      end
    end
    
    # Relation#explain needs to be able to collect the queries regardless of
    # whether auto explain is enabled. This method serves that purpose.;Fi[	@ii:I"÷        if self.!=(var) and var.respond_to?(:with_visitor) then
          var.with_visitor(var) { |arglist| yield }
        else
          yield
        end
      end
      
      def function(arglist)
        init;Fi[	@—iI"      assert(TARGET_FOLDER.exist?.!, "setup failed.")
      (TEMP_FOLDER + "a.txt").write("This is sample file a.")
      (TEMP_FOLDER + "b.txt").write("This is sample file b.")
      yield
    end
  end
  
  def function(arglist)
    assert_raises(RuntimeError) do |arglist|;Fi[	@îi¶I"{      # Runs state events around the object's validation process
      def function(arglist)
        var.class.state_machines.transitions(var, action, :after => (false)).perform do |arglist|
          yield
        end
      end
      
      # Creates a new callback in the callback chain, always inserting it
      # before the default Observer callbacks that were created after;Fi[I"@var.each do |arglist|;FI"newobj;FI"]out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));FI"out("endobj");Fi	[	[	@LiÒI"Ï  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@Oi˙I"Ï  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@Ri‡I"Ï  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@ci&I"È  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each do |arglist|;Fi[@µ @°+I"var = @var["cw"];F@XMi	[	[	@Li´I"       super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@Oi¶I"       super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@RiöI"       super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@UiÉI"Ì    self.Cell(var, var, var[(var..var)], var, 2, var, var)
    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[@ÂeI"end;FI"end;FI"end;Fi	[	[	@∆i%I"      DefaultPatchBall.new("test_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@∆i/I"      ListPatchBall.new("test_patch_list").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@∆i9I"      P0PatchBall.new("test_p0_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
  
  def function(arglist);Fi[	@∆iCI"      P1PatchBall.new("test_p1_patch").brew do |arglist|
        var = read_file("libexec/NOOP")
        assert(var.include?("NOOP").!, "File was unpatched.")
        assert(var.include?("ABCD"), "File was not patched as expected.")
      end
    end
  end
end;Fi[@YH@rW@sWI"	next;Fi	[	[	@Li{I"µ        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[	@OipI"ª        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var < 128) then;Fi[	@RijI"µ        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if var.! then;Fi[	@ciPI"∑        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end
      if (var == " "[0]) then;Fi[@µ @°+@ÍcI"var;Fi	[	[	@
i√I"œ        var = Node.new(:FUNCTION, [var.first.strip])
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@
i»I"ﬂ        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@
iÕI"ﬂ        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[	@
i“I"ﬂ        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      ;Fi[@µ @°+I""";FI"end;Fi	[	[	@i3I"…        var = eval_js("#{@regexp}.exec('#{step_name}')")
        var.to_a[(1..-1)].map { |arglist| JsArg.new(var) } if var
      end
      
      def function(arglist)
        ""
      end
    end
    ;Fi[	@ÿ#i=I"v  def function(arglist)
    # do nothing
  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist);Fi[	@π)i
I"É    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist);Fi[	@π)iI"~    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist);Fi[@YH@≠V@ûII"var = var[var];Fi	[	[	@UiGI"£    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then;Fi[	@UiçI"Œ    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        self.Cell(var, var, var[var, (var - var)], 0, 2, "", 0, var);Fi[	@ci@I"£    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        if (@var > 0) then;Fi[	@ci©I"À    var = -1
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);Fi[@µ @°+@ eI"end;Fi	[	[	@ûi)I"Ã      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # +feature_element+ is either Scenario or ScenarioOutline;Fi[	@ûiBI"«      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@ûifI"«      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist);Fi[	@ûivI"¸      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.;Fi[@	)@∂`I"end;FI" ;Fi	[	[	@FiI"      
      ##
      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform;Fi[	@`i'I"Ó      
      ##
      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform;Fi[	@uiI"Ô      
      ##
      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform;Fi[	@ÅiFI"Ó      
      ##
      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform;Fi[@	)I"var = case var;F@ÚaI""Success";Fi	[	[	@Ñi/I"-      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[	@ëi-I"-      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[	@îi7I"-      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :failure then
          "Failure";Fi[	@ói+I"-      # : the failure, the Exception's backtrace, a copy of the current
      # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning";Fi[I"if @var.!=(var) then;FI"@var = var;FI"out(var);FI"end;Fi	[	[	@Ui˜I"ƒ      out(sprintf("%.2f w", (var * @var)))
    end
    self.SetFont(var, var, var) if var
    if @var.!=(var) then
      @var = var
      out(var)
    end
    if @var.!=(var) then
      @var = var;Fi[	@Ui˚I"Ü      @var = var
      out(var)
    end
    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var;Fi[	@ci‰I"ø      out(sprintf("%.2f w", (var * @var)))
    end
    SetFont(var, var, var) if var
    if @var.!=(var) then
      @var = var
      out(var)
    end
    if @var.!=(var) then
      @var = var;Fi[	@ciËI"Ü      @var = var
      out(var)
    end
    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var;Fi[@dOI"end;FI"end;FI"end;Fi	[	[	@˚iI"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@ i%I"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[	@iI"ø        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
    
    def self.suffix(arglist);Fi[	@iI"ß        File.open("_posts/#{name}", "w") do |arglist|
          var.puts(var)
          var.puts("---")
          var.puts(var)
        end
      end
    end
  end
end;Fi[@µ @°+I"var = @var;F@Yi	[	[	@LiÓI"√  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[	@Oi˜I"√  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[	@Ri›I"√  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"));Fi[	@Ui@I"›    out(">>")
    out("endobj")
  end
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out(((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences " + "[") + var) + "]>>"));Fi[@µ @°+I"@var ||= var;FI"end;Fi	[	[	@riI"õ      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@uiI"õ      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@xiI"—      attr_accessor(:feature)
      
      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[	@êiI"õ      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist);Fi[@YH@II"var = (var + 1);FI"$var = var if var and (var == 2);Fi	[	[	@UiUI"≈        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        if (var == " "[0]) then;Fi[	@UirI"√          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2)
        else
          var = (var + 1);Fi[	@ciOI"±        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
        next
      end;Fi[	@cimI"±        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + 1);Fi[I"&# @return [Array<Twitter::Tweet>];F@Â^I"{# @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.;FI"|# @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.;Fi	[	[	@5iI"N      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@5i]I"N      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@5irI"N      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[	@5iÑI"N      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;Fi[@µ @°+I"	name;FI"end;Fi	[	[	@Xi\I"ú        @var = app_cache_path if has_app_cache?
        local_specs
      end
      
      def function(arglist)
        name
      end
      
      private;Fi[	@ﬂ;iI"¨  attr_accessible(:name, :contacts_visible, :order_id)
  
  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist);Fi[	@E\i$I"q  def function(arglist)
    @@var
  end
  
  def function(arglist)
    name
  end
  
  def function(arglist);Fi[	@H\iI"}class Category < ActiveRecord::Base
  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist);Fi[@µ @°+I"(@var or @var);FI"end;Fi	[	[	@Ji∆I"†        end
        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist);Fi[	@q1iI"∆      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "You are not authorized to access this page.")
    end
    
    def function(arglist)
      (@var or @var)
    end
  end
end;Fi[	@ÉiÜI"Ω        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist);Fi[	@iI"Æ  module Parser
    class GherkinBuilder
      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist);Fi[@Õ_I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@)	ivI"º      # @example Is the object resizable?
      #   object.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@)	i†I"Õ        # @example Is the object resizable?
        #   Array.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end;Fi[	@L	i{I"∂      # @example Is the hash resizable?
      #   {}.resizable?
      #
      # @return [ true ] true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@L	iΩI"»        # @example Is the hash resizable?
        #   {}.resizable?
        #
        # @return [ true ] true.
        #
        # @since 3.0.0
        def function(arglist)
          true
        end;Fi[I"class Base;FI""include(Backup::CLI::Helpers);FI" ;F@aai	[	[	@FiI"ômodule Backup
  module Compressor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##;Fi[	@`iI"ómodule Backup
  module Database
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##;Fi[	@uiI"´module Backup
  module Encryptor
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      def function(arglist);Fi[	@œiI"ßmodule Backup
  module Syncer
    class Base
      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      attr_accessor(:path);Fi[I"return false;FI"end;FI"end;FI"end;Fi	[	[	@ÄiFI"      if self.post.comments.where(:author_id => (var.person.id)).!=([]) and self.author_id.!=(var.person.id) then
        return Notifications::AlsoCommented
      else
        return false
      end
    end
  end
  
  def function(arglist);Fi[	@0ilI"±  def function(arglist)
    if self.root and self.root.public.! then
      (errors[:base] << "Only posts which are public may be reshared.")
      return false
    end
  end
end;Fi[	@⁄	iI"k          end
          return var if var
        end
        return false
      end
    end
  end
end;Fi[	@Õi7I"ç        return true)
      rescue Exception => var
        var.failure_message = var.message
        return false
      end
    end
  end
end;Fi[@	)I""";FI"end;FI" ;Fi	[	[	@viI"    module SCM
      class None < Base
        # No versioning, thus, no head. Returns the empty string.
        def function(arglist)
          ""
        end
        
        # Simply does a copy from the :repository directory to the
        # :destination directory.;Fi[	@ÿ#i>I"e    # do nothing
  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    [];Fi[	@π)iI"w      # do nothing
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      "";Fi[	@π)iI"l      ""
    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0;Fi[I"super(var, var);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@iDI"          var = clone_attribute_value(:read_attribute, var)
          @var[var] = var if _field_changed?(var, var, var)
        end
        super(var, var)
      end
      
      def function(arglist)
        partial_writes? ? (super(keys_for_partial_write)) : (super)
      end;Fi[	@çi&I"ÿ      
      def function(arglist)
        var = (var + " WHERE 1=1") unless var =~ /WHERE/i
        super(var, var)
      end
      
      def function(arglist)
        super
        (var or @var.last_insert_row_id);Fi[	@ÄibI"ü    
    def function(arglist)
      @var = var
      super(var, var)
    end
    
    def function(arglist)
      { :post => (@var), :text => (@var) }
    end;Fi[	@0i;I"    if var and (var.root.author_id == var.person.id) then
      return unless var.has_contact_for?(var)
    end
    super(var, var)
  end
  
  def function(arglist)
    I18n.t("reshares.comment_email_subject", :resharer => (author.name), :author => (root.author_name))
  end;Fi[I"out("/ItalicAngle 0");FI"out("/Ascent 800");FI"out("/Descent -200");FI"out("/CapHeight 800");Fi	[	[	@Li^I"Ë    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>");Fi[	@Oi_I"Ë    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>");Fi[	@RiII"Ë    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>");Fi[	@ciúI"Ë    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>");Fi[@	)@L[I"end;FI" ;Fi	[	[	@ui?I"π        @var.tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var);Fi[	@xiII"        Gherkin::TagExpression.new(var.tag_expressions).eval(source_tags)
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        (@var.tags.to_a + (@var ? (@var.source_tags.to_a) : ([]))).uniq;Fi[	@Éi)I"Æ        @var.source_tags
      end
      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        init;Fi[	@ÉiSI"∆          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name }
        end
        
        def function(arglist)
          @var.source_tags;Fi[@	)I"@var ||= var;FI"end;FI" ;Fi	[	[	@riI"∫      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit;Fi[	@uiI"µ      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        @var.feature = self if @var;Fi[	@xiI"…      
      attr_reader(:gherkin_statement, :raw_steps, :title, :description)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        (@var << var);Fi[	@êiI"ü      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      
      def function(arglist)
        false;Fi[I"@var.clear;FI"end;FI" ;FI"def function(arglist);Fi	[	[	@_i,I"ã    
    def function(arglist)
      @var.clear
      @var.clear
    end
    
    def function(arglist)
      servers.include?(var)
    end;Fi[	@Èi≈I"â      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@Èi…I"â      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end;Fi[	@ÈiÕI"ë      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        class << @var
          self;Fi[@	)I"@var.each(&var);FI"end;FI" ;Fi	[	[	@}iI"ü        @var[var]
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var.features = self;Fi[	@ìi%I"¿        StepCollection.new((@var + var))
      end
      
      def function(arglist)
        @var.each(&var)
      end
      
      def function(arglist)
        var = (@var.index(var) or -1);Fi[	@ÄiØI"Ñ    @var.empty?
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    map { |arglist| var.flag };Fi[	@™iI"Ö    external_curl_args.empty?.!
  end
  
  def function(arglist)
    @var.each(&var)
  end
  
  def function(arglist)
    @var.empty?;Fi[@µ @°+@RI"nil;Fi	[	[	@biI"Æ            var
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if String.===(var) then;Fi[	@biYI"Ú        def function(arglist)
          parse_pg_array(var).map { |arglist| var.type_cast(var) }
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if ("empty" == var) then;Fi[	@bikI"≠            end
          end
        end
        
        def function(arglist)
          if var.nil? then
            nil
          else
            if Range.===(var) then;Fi[	@˙iI"¡        var.on_top!
        @var = var
      end
      
      def function(arglist)
        if var.nil? then
          nil
        else
          if var.is_a?(Compass::Configuration::Data) then;Fi[@¿_I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@|iI"Ù      #
      # @param [ Array<Document> ] docs The docs returning from the db.
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        load_inclusions(var)
        self.eager_loaded = true;Fi[	@G	iI"¡      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@Q	iI"¡      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #
      # @since 3.0.0
      def function(arglist)
        true
      end;Fi[	@
iI""        # @example Execute the upsert.
        #   operation.persist
        #
        # @return [ true ] Always true.
        #
        # @since 3.0.0
        def function(arglist)
          prepare do |arglist|
            collection.find(selector).update(document.as_document, [:upsert]);Fi[I"require("twitter/base");FI"!require("twitter/creatable");FI"module Twitter;FI"module Action;Fi	[	[	@i I"ñrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class Follow < Twitter::Base
      include(Twitter::Creatable);Fi [	@i I"ürequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class ListMemberAdded < Twitter::Base
      include(Twitter::Creatable);Fi [	@i I"órequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class Mention < Twitter::Base
      include(Twitter::Creatable);Fi [	I"/data//twitter_proj/twitter/action/tweet.rb;Ti I"ïrequire("twitter/base")
require("twitter/creatable")
module Twitter
  module Action
    class Tweet < Twitter::Base
      include(Twitter::Creatable);Fi [@	)@ eI"end;FI" ;Fi	[	[	@ûi*I"Ã        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # +feature_element+ is either Scenario or ScenarioOutline
      def function(arglist);Fi[	@ûiCI"·        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûigI"¬        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var);Fi[	@ûiwI"¸        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var, var)
      end
      
      # Print +messages+. This method can be called from within StepDefinitions.
      def function(arglist);Fi[I"	var);FI"end;FI" ;FI"def function(arglist);Fi	[	[	@ ieI"√        var = var.search(Gem::Dependency.new("bundler", VERSION)).last
        var["bundler"] = var if var
      end
      var)
    end
    
    def function(arglist)
      (specs - @var)
    end;Fi[	@_i©I"∂          end
          (var << var)
        end
        var)
      end
      
      def function(arglist)
        @var ||= (var = installed_specs.dup
        var = Bundler.app_cache;Fi[	@diI"Ô        (var.platform.to_s == "ruby") ? ("\x00") : (var.platform.to_s)
      end
      var.reverse_each { |arglist| (var[var.name] << var) }
      var)
    end
    
    def function(arglist)
      @var.each { |arglist| yield(var) }
    end;Fi[	@8iII"'          unless VALID_REPEATS.include?(var) then
            raise(SpriteException, "Invalid option for repeat \"#{rep}\" - valid options are #{VALID_REPEATS.join(", ")}")
          end
          var)
        end
        
        def function(arglist)
          (repeat == REPEAT_X)
        end;Fi[@≥_I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@ãiÊI"      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, [first])
      end;Fi[	@ãiÙI"      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, entries)
      end;Fi[	@éiHI"˝      #
      # @param [ Hash ] attributes The new attributes for the document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var)
      end;Fi[	@éiVI"      #
      # @param [ Hash ] attributes The new attributes for each document.
      #
      # @return [ nil, false ] False if no attributes were provided.
      #
      # @since 3.0.0
      def function(arglist)
        update_documents(var, :update_all)
      end;Fi[@¶_I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@ùiçI")    # @option options [ String, Symbol ] :database The database name.
    # @option options [ String, Symbol ] :session The session name.
    #
    # @return [ Criteria ] The criteria.
    #
    # @since 3.0.0
    def function(arglist)
      Threaded.set_persistence_options(klass, var)
      self;Fi[	@ùiI"<      # @example Apply the default scope.
      #   criteria.apply_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        klass.without_default_scope { |arglist| merge!(klass.default_scoping.call) }
        self.scoping_options = true, false;Fi[	@ùiÄI"'      # @example Get the criteria with the default scope.
      #   criteria.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then;Fi[	@≠iùI"ı      # @example Get a criteria with the default scope.
      #   Model.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        queryable.with_default_scope
      end;Fi[I"'out("/FontBBox [0 -200 1000 900]");F@$gI"out("/Ascent 800");F@&gi	[	[	@Li]I"˝    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50");Fi[	@Oi^I"˝    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60");Fi[	@RiHI"˝    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50");Fi[	@ciõI"˝    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60");Fi[I";#   #       #<Pet id: 4, name: "Benny", person_id: 1>,;T@Ú]@Û]I"#   #    ];Ti	[	[	@îiFI":      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   person.pets.destroy("4");Ti[	@îiaI"'      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets = person.pets.to_ary;Ti[	@îihI"I      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #
      #   other_pets.replace([Pet.new(name: 'BooGoo')]);Ti[	@îiuI"M      #   person.pets
      #   # This is not affected by replace
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      def function(arglist)
        load_target.dup;Ti[I"out("/Flags 6");F@¡g@$gI"out("/Ascent 800");Fi	[	[	@Li\I"Û    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@Oi]I"Û    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@RiGI"Û    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[	@ciöI"Û    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200")
    out("/CapHeight 800");Fi[@	)@ÍcI"var;FI"end;Fi	[	[	@
iƒI"∂        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@
i…I"∂        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@
iŒI"∂        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[	@
i”I"∂        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist);Fi[@µ @°+I"super(var);FI"@var = var;Fi	[	[	@Ci.I"∏      attr_reader(:parent, :records)
      
      attr_writer(:joinable)
      
      def function(arglist)
        super(var)
        @var = var
        @var = []
        @var = false;Fi[	@¢6i,I"™  
  class WrappedDatabaseException < StatementInvalid
    attr_reader(:original_exception)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end;Fi[	@¢6iWI"π  
  class AttributeAssignmentError < ActiveRecordError
    attr_reader(:exception, :attribute)
    
    def function(arglist)
      super(var)
      @var = var
      @var = var
    end;Fi[	@Ui5I"ömodule Homebrew
  class InstallationError < RuntimeError
    attr(:formula)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end;Fi[@	)I"%var = Node.new(:COMBINATOR, var);FI"var;FI"end;Fi	[	[	@
i(I"∏      
      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@
i-I"ö        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@
i2I"ö        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist);Fi[	@
i7I"ò        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted;Fi[@s_I"#;FI"# @since 3.0.15;FI"def function(arglist);Fi	[	[	@óiI"Y      # @example Dump the criteria.
      #   Marshal.dump(criteria)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        var = [klass, driver, inclusions, documents, strategy, negating]
        var.push(scoping_options).push(dump_hash(:selector)).push(dump_hash(:options));Fi[	@yiI"ﬁ      # @example Dump the proxy.
      #   Marshal.dump(proxy)
      #
      # @return [ Array<Object> ] The dumped data.
      #
      # @since 3.0.15
      def function(arglist)
        [base, target, metadata]
      end;Fi[	@õi0I"Ù        # @example Dump the proxy.
        #   Marshal.dump(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          [_added, _loaded, _unloaded]
        end;Fi[	@õi<I"Ó        # @example Load the proxy.
        #   Marshal.load(proxy)
        #
        # @return [ Array<Object> ] The dumped data.
        #
        # @since 3.0.15
        def function(arglist)
          @var, @var, @var = var
        end;Fi[@÷a@◊aI"S@var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) };FI"end;Fi	[	[	@iI"      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection containing the followed user;Fi[	@iI"#      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection of lists that were added to;Fi[	@iI"      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # The user who mentioned a user;Fi[	@ägiI"Ó      
      attr_reader(:max_position, :min_position)
      
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
    ;Fi[@q=@oR@pRI" #   person.pets.size # => 3;Ti	[	[	@îiêI"Ω      # option.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@îiI"È      # responding to the +id+ and executes delete on them.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@îi I"˘      # the +:dependent+ option. Returns an array with the removed records.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [;Ti[	@îiéI":      # +length+ will take one less query. Otherwise +size+ is more efficient.
      #
      #   class Person < ActiveRecord::Base
      #     has_many :pets
      #   end
      #
      #   person.pets.size # => 3
      #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
      #;Ti[@_\I"out("/Flags 6");F@¡g@$gi	[	[	@Li[I"Î    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@Oi\I"Î    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@RiFI"Î    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[	@ciôI"Î    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800")
    out("/Descent -200");Fi[I"# type.;FI"#;F@j:@Ä_i	[	[	@)	iSI"‡      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Array ] The object.;Fi[	@.	iI"·      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[	@L	ioI"ﬂ      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Hash ] The object.;Fi[	@Z	i|I"·      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #
      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.;Fi[@÷a@◊a@ÿaI"end;Fi	[	[	@iI"Ú      
      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	@i I"˜      
      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	@i'I"Û      
      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[	@iI"Û      
      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end;Fi[@	)I"var = @var["cw"];F@XM@YMi	[	[	@Li¨I"ø    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@OißI"ø    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@RiõI"ø    end
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@UiÑI"«    @var = @var
  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[@å_I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@.	iI"æ      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        to_s
      end;Fi[	@.	i)I"	        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var.numeric? ? (::BigDecimal.new(var.to_s)) : (var) if var
        end;Fi[	@Z	iÅI"æ      # @example Mongoize the object.
      #   object.mongoize
      #
      # @return [ Object ] The object.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@Z	iÙI"“        #
        # @param [ Object ] object The object to demongoize.
        #
        # @return [ Object ] The object.
        #
        # @since 3.0.0
        def function(arglist)
          var
        end;Fi[@	)I"@var = 1;FI"end;FI" ;Fi	[	[	@Ui»I"ä    raise(("FPDF error: " + var))
  end
  
  def function(arglist)
    @var = 1
  end
  
  def function(arglist)
    return if (@var == 3);Fi[	@UiFI"q    end
  end
  
  def function(arglist)
    @var = 1
  end
  
  def function(arglist)
    @var = (@var + 1);Fi[	@ci¶I"Ç  	# @since 1.0
  	# @see AddPage(), Close()
  	#
  def function(arglist)
    @var = 1
  end
  
  # alias_method :open, :Open
  	#;Fi[	@ci	I"  	# End of page contents
  	# @access protected
  	#
  def function(arglist)
    @var = 1
  end
  
  #
  	# Begin a new object;Fi[@ô_I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@3	iI"Ï        # @example Mongoize the object.
        #   Boolean.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          evolve(var)
        end;Fi[	@G	i)I"        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_f rescue 0.0)
        end;Fi[	@Q	i3I"        # @example Mongoize the object.
        #   BigDecimal.mongoize("123.11")
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          var.blank? ? (nil) : (__numeric__(var).to_i rescue 0)
        end;Fi[	@s	iªI"Ê        #
        # @param [ Object ] object The object to mongoize.
        #
        # @return [ String ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          demongoize(var)
        end;Fi[@^\@_\I"out("/Flags 6");F@¡gi	[	[	@LiZI"Ù    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@Oi[I"‡    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@RiEI"Ù    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[	@ciòI"‡    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0")
    out("/Ascent 800");Fi[I"yield(var) if block_given?;FI"var.parse_with(self);FI"end;FI" ;Fi	[	[	@,iI"          raise(ArgumentError) unless var
          return unless (var.length > 0)
          var = ParserContext.memory(var, var)
          yield(var) if block_given?
          var.parse_with(self)
        end
        
        ###
        # Parse a file with +filename+;Fi[	@ÇiEI"Ù          check_encoding(var)
          @var = var
          var = ParserContext.io(var, ENCODINGS[var])
          yield(var) if block_given?
          var.parse_with(self)
        end
        
        ###
        # Parse a file with +filename+;Fi[	@ÇiPI"7          raise(Errno::ENOENT) unless File.exists?(var)
          raise(Errno::EISDIR) if File.directory?(var)
          var = ParserContext.file(var)
          yield(var) if block_given?
          var.parse_with(self)
        end
        
        def function(arglist)
          var = ParserContext.memory(var);Fi[	@ÇiVI"¬        
        def function(arglist)
          var = ParserContext.memory(var)
          yield(var) if block_given?
          var.parse_with(self)
        end
        
        private
        ;Fi[@'@¸@ˇ,I"-@var.each { |arglist| var.skip_invoke! };Fi	[	[	@iiEI"®        else
          @var.accept_hook?(var)
        end
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
      end
      ;Fi[	@Éi^I"Ÿ        def function(arglist)
          @var = var
          @var = var.step_invocations(self)
        end
        
        def function(arglist)
          @var.each { |arglist| var.skip_invoke! }
        end
        ;Fi[	@äiXI"˝      def function(arglist)
        return :failed if @var
        @var.status
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
        @var.next_feature_element(self) { |arglist| var.skip_invoke! }
      end;Fi[	@çiEI"Ê      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        @var.each { |arglist| var.skip_invoke! }
        @var.next_feature_element(self) { |arglist| var.skip_invoke! }
      end;Fi[I">out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));FI"out(">>");FI"out("endobj");FI"newobj;Fi	[	[	@LiAI"$    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[	@OiJI"$    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[	@Ri0I"$    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[	@ciáI"$    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["cMap"]))
    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0");Fi[@⁄_I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@Z	iI"¬      # @example Evolve the object.
      #   object.__evolve_object_id__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@Z	iI"ƒ      # @example Convert the object to args.
      #   object.__find_args__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@Z	i'I"¡      # @example Mongoize the object.
      #   object.__mongoize_time__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[	@Z	i?I"»      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #
      # @since 3.0.0
      def function(arglist)
        self
      end;Fi[@µ @MI"end;FI"end;Fi	[	[	@i[I"ª        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@iÉI"          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@i>I"¶          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[	@2iRI"û        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end
  end;Fi[@ÿaI"end;FI"end;FI"end;Fi	[	[	@iI"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@i"I"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@i)I"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@iI"Ω      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@îRI"if (var > 0) then;FI"@var = 0;FI"out("0 Tw");Fi	[	[	@UiÔI"Ω  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("0 Tw")
      end
      self.AddPage(@var);Fi[	@ciÕI"Ò    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var);Fi[	@ciI"(      var = 1 if (var >= 1)
      if ((var + ((var["h"] * var) / (@var * @var))) > @var) and (@var.! and AcceptPageBreak) then
        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("0 Tw")
          end
          AddPage(@var);Fi[	@ciLI"È    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var);Fi[@	)I"@var.qualified_name;FI"end;FI" ;Fi	[	[	@„i I"›    end
    
    # The fully-qualified name of the event that triggered the failed transition
    def function(arglist)
      @var.qualified_name
    end
    
    # The name for the current state
    def function(arglist);Fi[	@„ioI"˙    end
    
    # The fully-qualified name of the event that triggered the transition
    def function(arglist)
      @var.qualified_name
    end
    
    # The human-readable name of the event that triggered the transition
    def function(arglist);Fi[	@„i~I"‡    end
    
    # The fully-qualified state name *before* the transition
    def function(arglist)
      @var.qualified_name
    end
    
    # The human-readable state name *before* the transition
    def function(arglist);Fi[	@„iàI"Ê    end
    
    # The new fully-qualified state name *after* the transition
    def function(arglist)
      @var.qualified_name
    end
    
    # The new human-readable state name *after* the transition
    def function(arglist);Fi[@îR@YI"newobj;F@
fi	[	[	@LiI"÷  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@Oi˘I"÷  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@RiﬂI"÷  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[	@ci%I"Â  	# @access protected
  	#
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end;Fi[@ÈMI"#;FI"# @since 2.0.0;FI"def function(arglist);Fi	[	[	@F
i#I"D      # @param [ Object, Array<Object> ] value The value or values to add.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        AddToSet.new(self, var, var, var).persist
      end;Fi[	@F
iLI"-      # @param [ Numeric ] value The value to increment.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Inc.new(self, var, var, var).persist
      end;Fi[	@F
iÄI"3      # @param [ Array<Object> ] value The values to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        PullAll.new(self, var, var, var).persist
      end;Fi[	@F
iëI"(      # @param [ Object ] value The value to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.0.0
      def function(arglist)
        Push.new(self, var, var, var).persist
      end;Fi[@	)@ÿaI"end;FI"end;Fi	[	[	@iI"Ô      # A collection containing the followed user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@i!I"Ù      # A collection of users who were added to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@i(I"      # A collection containing the mentioned user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[	@iI"      # A collection containing the retweeted user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:targets]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
    end
  end
end;Fi[@Ô>@>@Ò>I"attr_reader :function;Fi	[	[	@gi@I"ê      end
      
      def function(arglist)
        @var = true
      end
      
      attr_reader :function
      
      def function(arglist);Fi[	@`(iI"m    end
    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function
  end
  ;Fi[	@7iiI"•    def function(arglist)
      @var.del(@var)
      @var.srem(:queues, @var)
      @var = true
    end
    
    attr_reader :function
    
    def function(arglist);Fi[	@€i±I"â      
      def function(arglist)
        @var = var.clone
        @var = true
      end
      
      attr_reader :function
    end
    ;Fi[@	)@VI"*var.flatten.threaded_map do |arglist|;FI"
begin;Fi	[	[	@ÍiVI"Â      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)))
          rescue Twitter::Error::Forbidden => var;Fi[	@ÍixI"Â      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)))
          rescue Twitter::Error::Forbidden => var;Fi[	@;iéI",      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var;Fi[	@;i©I",      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            post_retweet(var, var.options)
          rescue Twitter::Error::Forbidden => var;Fi[I"†# @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.;F@ÿK@ŸK@⁄Ki	[	[	@|QiI"ñ      # Returns the 20 most recent direct messages sent to the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent to the authenticating user.
      # @param options [Hash] A customizable set of options.;Fi[	@|Qi$I"õ      # Returns the 20 most recent direct messages sent by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/sent
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] Direct messages sent by the authenticating user.
      # @param options [Hash] A customizable set of options.;Fi[	@|Qi7I"5      # Returns a direct message
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/direct_messages/show
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::DirectMessage] The requested messages.
      # @param id [Integer] A Tweet IDs.;Fi[	@|QiEI"@        object_from_response(Twitter::DirectMessage, :get, "/1.1/direct_messages/show.json", var)
      end
      
      # @note This method requires an access token with RWD (read, write & direct message) permissions. Consult The Application Permission Model for more information.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::DirectMessage>] The requested messages.
      # @overload direct_messages(options={});Fi[@Ô>@>@áAI"end;Fi	[	[	@ÏiMI"m      
      def function(arglist)
        yield if @var
        @var = true
      end
    end
  end
end;Fi[	@®iI"ﬂ        unless ORIGINAL_PATHS.include?(var) then
          opoo("#{bin} is not in your PATH")
          puts("You can amend this by altering your ~/.bashrc file")
          @var = true
        end
      end
    end
  end
  ;Fi[	@ÚiI"R            content_for(:header_tags) do |arglist|
              ((javascript_include_tag("jstoolbar/jstoolbar-textile.min") + javascript_include_tag("jstoolbar/lang/jstoolbar-#{current_language.to_s.downcase}")) + stylesheet_link_tag("jstoolbar"))
            end
            @var = true
          end
        end
      end
    end
  end;Fi[	@,i¢I"ó          failure_hooks.each { |arglist| payload_class.send(var, var, *var) }
        end)
      ensure
        @var = true
      end
    end
  end
end;Fi[@#b@$bI"#     end;FI"#   end;Fi	[	[	@˝iQI"≤      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@˝içI"≤      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@˝i—I"≤      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[	@˝iÙI"≤      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new;Fi[@$bI"#     end;FI"#   end;FI"#;Fi	[	[	@˝iRI"»      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@˝iéI"»      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@˝i“I"»      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[	@˝iıI"»      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5
      #     end
      #   end
      #
      #   person = Person.new
      #   person.name = 'Bob';Fi[@ÈM@ˇhI"# @since 2.1.0;FI"def function(arglist);Fi	[	[	@F
i`I"7      # @param [ Integer ] value Whether to pop the first or last.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pop.new(self, var, var, var).persist
      end;Fi[	@F
isI"(      # @param [ Object ] value The value to pull.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Pull.new(self, var, var, var).persist
      end;Fi[	@F
i¢I"3      # @param [ Array<Object> ] value The values to push.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        PushAll.new(self, var, var, var).persist
      end;Fi[	@F
iƒI"(      # @param [ Integer ] value The value to set.
      # @param [ Hash ] options The mongo persistence options.
      #
      # @return [ Array<Object> ] The new value of the field.
      #
      # @since 2.1.0
      def function(arglist)
        Sets.new(self, var, var, var).persist
      end;Fi[@'@¸@ˇ,I"	to_s;Fi	[	[	@!iI"ã    def function(arglist)
      self.value = var
      self.css2_value = var
    end
    
    def function(arglist)
      to_s
    end
    ;Fi[	@$iI"≥        raise(Sass::SyntaxError, "Expected a number. Got: #{stop}")
      end
      self.color, self.stop = var, var
    end
    
    def function(arglist)
      to_s
    end
    ;Fi[	@$i8I"      def function(arglist)
        class_eval("\n          def to_#{prefix}(options = self.options)\n            Sass::Script::String.new(\"-#{prefix}-#{to_s(options)}\")\n          end\n        ")
      end
    end
    
    def function(arglist)
      to_s
    end
    ;Fi[	@ºi$I"m    
    def function(arglist)
      args
    end
    
    def function(arglist)
      to_s
    end
    ;Fi[I"<# @param [ Metadata ] metadata The relation's metadata.;FI"#;F@©`@™`i	[	[	@2iI"X        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@;iI"X        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@DiI"X        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[	@IiI"X        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name);Fi[I"J# Binds the base object to the inverse of the relation. This is so we;FI"E# are referenced to the actual objects themselves on both sides.;FI"#;F@g`i	[	[	@¢
i
I"a    module Bindings
      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #;Fi[	@¥
i
I"b    module Bindings
      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #;Fi[	@Ω
i
I"c    module Bindings
      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #;Fi[	@ﬁ
i
I"d    module Bindings
      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #;Fi[@'@¸@ˇ,I"var = key_for(var);Fi	[	[	@=iI"ﬁ      @var = var
      @var = load_config(local_config_file)
      @var = load_config(global_config_file)
    end
    
    def function(arglist)
      var = key_for(var)
      (@var[var] or (ENV[var] or @var[var]))
    end;Fi[	@=i+I"›      var = {}
      all.each { |arglist| var[$'] = self[var] if var =~ /^local\./ }
      var
    end
    
    def function(arglist)
      var = key_for(var)
      var = {}
      var[:local] = @var[var] if @var.key?(var);Fi[	@=i4I"Õ      var[:env] = ENV[var] if ENV[var]
      var[:global] = @var[var] if @var.key?(var)
      var
    end
    
    def function(arglist)
      var = key_for(var)
      var = []
      if @var.key?(var) then;Fi[	@=imI"’    def function(arglist)
      var = var.to_s.sub(".", "__").upcase
      "BUNDLE_#{key}"
    end
    
    def function(arglist)
      var = key_for(var)
      unless (var[var] == var) then
        var[var] = var;Fi[@ÇiI"#;F@g`@h`i	[	[	@¢
iI"v      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.;Fi[	@¥
iI"v      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.;Fi[	@Ω
iI"x      module Referenced
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the documents.;Fi[	@ﬁ
iI"x      module Referenced
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we
          # are referenced to the actual objects themselves on both sides.
          #
          # This case sets the metadata on the inverse object as well as the
          # document itself.
          #
          # @example Bind the document.;Fi[@›c@ﬁcI"#;FI"$# @example Unbind the document.;Fi	[	[	@¢
i&I"            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   name.person.unbind(:continue => true)
          #   name.person = nil;Fi[	@¥
i!I"            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.name.unbind(:continue => true)
          #   person.name = nil;Fi[	@Ω
i'I"            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   game.person.unbind(:continue => true)
          #   game.person = nil;Fi[	@ﬁ
iI"Q            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.
          #   person.game.unbind(:continue => true)
          #   person.game = nil;Fi[@Ë_I"#;FI"@# @param [ String ] type The type of document to query for.;FI"#;Fi	[	[	@iI"S          # object or a document, where it will just return it.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #
          # @return [ Document ] A single document.
          def function(arglist);Fi[	@iI"c          # object or an array of documents, where it will just return tem.
          #
          # @example Build the documents.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #
          # @return [ Array<Document> ] The documents.
          def function(arglist);Fi[	@iI"d          # object or an array of documents, where it will just return them.
          #
          # @example Build the documents.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #
          # @return [ Array<Document> ] The documents.
          def function(arglist);Fi[	@&iI"M          # inverse side using the id or sets the object.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #
          # @return [ Document ] A single document.
          def function(arglist);Fi[@⁄K@€K@Â^@Ωfi	[	[	@5iI"œ      # @note This method can only return up to 800 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@5i\I"—      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@5iqI"„      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[	@5iÉI"„      # @note This method can only return up to 800 Tweets, including retweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.;Fi[I"3attr_accessor(:document, :relation, :metadata);FI" ;F@µc@∂ci	[	[	@2i	I"  module Relations
    module Cascading
      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy;Fi[	@;i	I"  module Relations
    module Cascading
      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy;Fi[	@Di	I"  module Relations
    module Cascading
      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy;Fi[	@Ii	I"  module Relations
    module Cascading
      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy;Fi[@'I"return false;FI"end;FI" ;Fi	[	[	I"3data//capistrano_proj/capistrano/extensions.rb;Ti$I"#    if EXTENSIONS.delete(var) then
      Capistrano::Configuration.send(:remove_method, var)
      return true
    end
    return false
  end
  
  def self.configuration(arglist)
    warn("[DEPRECATION] Capistrano.configuration is deprecated. Use Capistrano::Configuration.instance instead");Fi[	@kiêI"Á      return true if (var == var)
      next if (var[(1..1)] == "-")
      return true if var.include?(var[(2..2)])
    end
    return false
  end
  
  # eg. `foo -ns -i --bar` has three switches, n, s and i
  def function(arglist);Fi[	@kiöI"æ    options_only.each do |arglist|
      next if (var[(1..1)] == "-")
      return true if var.include?(var)
    end
    return false
  end
  
  def function(arglist)
    require("cmd/help");Fi[	@HiRI"ﬁ        if nested_attributes.has_key?(var) then
          pending_nested[var] = var
          return true
        end
        return false
      end
      
      # Get all the pending relations that need to be set.
      #;Fi[@'I"	puts;FI"end;FI"end;Fi	[	[	@ËiZI"¡            puts("There is no description for this task.")
          else
            puts(format_text(var.description))
          end
          puts
        end
      end
      
      #:nodoc:;Fi[	@Ôi¨I"Ø    print(" clang-#{clang_build} llvm-#{llvm} ")
    if MacOS::XQuartz.prefix then
      print("#{MacOS::XQuartz.prefix}-#{MacOS::XQuartz.version}")
    end
    puts
  end
end;Fi[	@ˆi*I"W        end
      else
        # do nothing
      end
      puts
    end
  end
end;Fi[	@±EiÖI"«      puts("If it doesn't work you can: brew install --use-gcc")
    else
      puts("If it doesn't work you can try: brew install --use-clang")
    end
    puts
  end
end
module MacOS
  extend(self);Ti[@‹.I"(var << var);FI"end;FI"end;Fi	[	[	@[iPI"˙                when "}" then
                  add_item_to_array(var, var, var)
                  return [var, var]
                else
                  (var << var)
                end
              end
            end
            var = (var + 1);Fi[	@∂iMI",            Logger.message(("#{storage_name} started removing " + "'#{local_file}' from Ninefold."))
            if var = var.files.get(var) then
              var.destroy
            else
              (var << var)
            end
          end
          var.destroy
          unless var.empty? then;Fi[	@·iI"Z        resolve_additional_import_paths.each do |arglist|
          if var.is_a?(String) then
            (var << [var, File.join((css_path or (css_dir or ".")), File.basename(var))])
          else
            (var << var)
          end
        end
        var = { :template_location => (var) }
        var[:style] = output_style if output_style;Fi[	@ÁiSI"Õ                    (var << var)
                    var = true
                  end
                else
                  (var << var)
                end
              end
            end
          end;Fi[@µc@∂cI"#;F@è`i	[	[	@2iI")      class Delete
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@;iI"*      class Destroy
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@DiI"*      class Nullify
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[	@IiI"+      class Restrict
        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #;Fi[@'@~^I"	true;FI"end;Fi	[	[	@ói.I"Ó        end
        def function(arglist)
          defined? I18n ? (super) : (var ? (var.to_s.humanize.downcase) : ("nil"))
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true;Fi[	@ói1I"™        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          true;Fi[	@ói4I"≥        end
        def function(arglist)
          true
        end
        def function(arglist)
          true
        end
        def function(arglist)
          :activerecord;Fi[	@µi6I"≥        end
        def function(arglist)
          false
        end
        def function(arglist)
          true
        end
        def function(arglist)
          # do nothing;Fi[@‹.I"var[var] = var;FI"end;FI"end;Fi	[	[	@¯iMI"§                var[var] = var.send(var)
              end
            end
          else
            var[var] = var
          end
        end
        var
      end;Fi[	@øi©I"“        var.each do |arglist|
          if var[var].is_a?(Hash) then
            merge_joins(var[var], var) unless var.empty?
          else
            var[var] = var
          end
        end
      end
      ;Fi[	@-iuI"Ò      def function(arglist)
        if var.has_key?(var) then
          var.each { |arglist| var[var].push(var) }
        else
          var[var] = var
        end
      end
      
      # Get the $addToSet operations or intialize a new one.;Fi[	@Â	i2I"          if var =~ /\A([^\(]+)\((\d+)([if])\)$/ then
            var, var = $1, $2.to_i
            var[var] ||= {}[var] = var.empty? ? (nil) : (var.send("to_#{$3}"))
          else
            var[var] = var
          end
        end
        var.each_pair do |arglist|
          begin;Fi[@'I"raise(var);FI"end;FI"end;Fi	[	[	@˝iﬁI"g        end
        if Bundler.definition.no_sources? then
          Bundler.ui.warn("Your Gemfile has no remote sources. If you need gems that are not already on\nyour machine, add a line like this to your Gemfile:\n    source 'https://rubygems.org'")
        end
        raise(var)
      end
    end
    
    desc("update", "update the current environment");Fi[	@3iØI"–              var.requirement = var.requirement
            else
              var.version_requirement = var.requirement
            end
            raise(var)
          end
        end
        true
      end;Fi[	@≤iII"          if (@var == "features") then
            STDERR.puts("You don't have a 'features' directory.  Please create one to get started.", "See http://cukes.info/ for more information.")
            exit(1)
          end
          raise(var)
        end
      end
    end
    ;Fi[	@IiI"˝            var.backtrace.first.gsub!(/^\(haml\):(\d+)/) do |arglist|
              "(haml):#{($1.to_i - 1)}"
            end
          end
          raise(var)
        end
      end
      
      # @return [String] A human-readable string representation;Fi[@‹.I"return var;FI"end;FI"end;Fi	[	[	@
i‘I"Í          if var then
            var = ((var + " ") + var)
            run(var, var, &var)
          else
            return var
          end
        end
        
        # Returns a Proc object that defines the behavior of the sudo;Fi[	@eiLI"˜          when :head then
            var = yield(scm(:changes, "--last 1", "--xml-output", "--repo=#{repository}"))
            return var[/hash='(.*?)'/, 1]
          else
            return var
          end
        end
        
        private;Fi[	@UioI"]        if var.valid_encoding? then
          if var.encoding.name =~ /^UTF-(8|16|32)(BE|LE)?$/ then
            return var.gsub(Regexp.new("\\AuFEFF".encode(var.encoding.name)), "")
          else
            return var
          end
        end
        var = var.encoding
        var = Regexp.new("\r\n|\r|\n".encode(var).force_encoding("binary"));Fi[	@nei"I"∫          var = var.from_record
          if (var.expires_in == 0) then
            var.destroy
          else
            return var
          end
        end
      end
      return nil;Fi[@∂cI"#;F@è`@ê`i	[	[	@2iI"[        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@;iI"[        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@DiI"[        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[	@IiI"[        attr_accessor(:document, :relation, :metadata)
        
        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.;Fi[@'I"var = var;FI"end;FI"end;Fi	[	[	@i/I"Œ            var.each do |arglist|
              @var["#{dependency.name}_#{c_dependency.name}"] = _make_label(var, :edge)
            end
          end
          var = var
        end
      end
    end
    ;Fi[	@ÄiI"ë            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@ÄiFI"ë            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end;Fi[	@ÄiÑI"ç            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end
  end;Fi[@è`@ê`I"#;F@ú`i	[	[	@2iI"e        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@;iI"e        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@DiI"e        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[	@IiI"e        # Initialize the new cascade strategy, which will set up the relation
        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #;Fi[@ê`I"#;F@ú`@ù`i	[	[	@2iI"H        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@;iI"H        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@DiI"H        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[	@IiI"H        # and the metadata.
        #
        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.;Fi[@ú`@ù`I"#;F@©`i	[	[	@2iI"`        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@;iI"`        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@DiI"`        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[	@IiI"`        # @example Instantiate the strategy
        #   Strategy.new(document, metadata)
        #
        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var;Fi[@©`@™`@´`@-di	[	[	@2iI"6        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@;iI"6        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@DiI"6        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[	@IiI"6        # @param [ Document ] document The document to cascade from.
        # @param [ Metadata ] metadata The relation's metadata.
        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        ;Fi[I"validates_relation(var);FI"var;FI"end;FI" ;Fi	[	[	@oiWI"9          self.cyclic = true if var[:cyclic]
          relate(var, var)
          embed(var, var)
          validates_relation(var)
          var
        end
        
        # Adds the relation from a parent document to its child. The name
        # of the relation needs to be a singular form of the child class;Fi[	@oitI""          relate(var, var)
          embed(var, var)
          builder(var, var).creator(var, var)
          validates_relation(var)
          var
        end
        
        # Adds a relational association from the child Document to a Document in
        # another database or collection.;Fi[	@oi§I"$          ids_getter(var, var).ids_setter(var, var)
          reference(var)
          autosave(var)
          validates_relation(var)
          var
        end
        
        # Adds a relational many-to-many association between many of this
        # Document and many of another Document.;Fi[	@oi>I"O          relate(var, var)
          reference(var)
          builder(var, var).creator(var, var).autosave(var)
          validates_relation(var)
          var
        end
        
        # Creates a relation for the given name, metadata and relation. It adds
        # the metadata to the relations hash and has the accessors set up.;Fi[@=@Õg@Ú]@Û]i	[	[	@îiEI"      #
      #   person.pets.size # => 3
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@îi`I"      #   end
      #
      #   person.pets
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@îigI""      #   #    ]
      #
      #   other_pets = person.pets.to_ary
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      #;Ti[	@îitI"=      #
      #   person.pets
      #   # This is not affected by replace
      #   # => [
      #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
      #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
      #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
      #   #    ]
      def function(arglist);Ti[I"#     relation.push(doc);FI"#   end;FI"#;F@ÿZi	[	[	@≈i1I"“      #
      # @example Execute in binding mode.
      #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0;Fi[	@≈iPI"’      #
      # @example Execute in building mode.
      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0;Fi[	@≈i{I"”      #
      # @example Execute in loading mode.
      #   _loading do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.3.2;Fi[	@≈i©I"Ê        #
        # @example Execute in creating mode.
        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0;Fi[@'@ﬂJ@´ZI"end;Fi	[	[	@ iI"„        var.mobile do |arglist|
          render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  ;Fi[	@ÌiI"À        var.json do |arglist|
          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  ;Fi[	@ÚiEI"û          var.js do |arglist|
            render(:json => ({ :photo_id => (@var.id), :image_url => (@var.url(:thumb_large)), :image_url_medium => (@var.url(:thumb_medium)), :image_url_small => (@var.url(:thumb_small)), :author_id => (var) }), :status => 201)
          end
        end
      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422);Fi[	@ÚiHI"û        end
      else
        render(:nothing => (true), :status => 422)
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end
  ;Fi[@˚`I"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@ aiI"Ò    # @example Get the global database override.
    #   Threaded.database_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:db-override"]
    end;Fi[	@ ai+I"„    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:db-override"] = var
    end;Fi[	@ ai;I"Ù    # @example Get the global session override.
    #   Threaded.session_override
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:session-override"]
    end;Fi[	@ aiII"Ë    #
    # @param [ String, Symbol ] The global override name.
    #
    # @return [ String, Symbol ] The override.
    #
    # @since 3.0.0
    def function(arglist)
      Thread.current["[mongoid]:session-override"] = var
    end;Fi[@≤Y@≥Y@¥YI"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;Fi	[	[	@ï7i*I"       # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@ï7idI"       # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@*i*I"Ø      #   validation contexts by default (+nil+), other options are <tt>:create</tt>
      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[	@2iÖI"Ω      # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
      #   attribute is blank (default is +false+).
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should ot occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[@‹.I"$var = (var + (var ? (1) : (2)));FI"end;FI"end;Fi	[	[	@LiíI"        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@Li‰I"	          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var);Fi[	@RiÅI"        var = 0
        var = (var + 1)
        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var);Fi[	@Ri”I"	          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var);Fi[@'@¸@ÿ/I"end;Fi	[	[	@`(iI"Ä    
    def function(arglist)
      @var = true
    end
    
    attr_reader :function
  end
  
  class Pending < StandardError;Fi[	@‰i∑I"ª    # which doesn't interact well with filter lines
    def function(arglist)
      @var.full.=~((@var ? (/^#{(@var * @var)}/) : (/^\s/)))
    end
    
    attr_reader :function
  end
end;Fi[	@|i.I"|      
      def function(arglist)
        (@var == var)
      end
      
      attr_reader :function
    end
  end
end;Fi[	@€i≤I"±      def function(arglist)
        @var = var.clone
        @var = true
      end
      
      attr_reader :function
    end
    
    class MessageExpectation < BaseExpectation;Fi[@‹.I"@var = var if (var == 2);FI"end;FI"end;Fi	[	[	@LiûI"ç      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@OiôI"ç      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@RiçI"ç      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[	@ciÇI"á        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  ;Fi[I"#   value.;FI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi	[	[	@li&I"*        # @param [ Symbol ] field The field to max.
        #
        # @return [ Float, Document ] The max value or document with the max
        #   value.
        #
        # @since 3.0.0
        def function(arglist)
          block_given? ? (super()) : (aggregate_by(var, :max_by))
        end;Fi[	@li<I"*        # @param [ Symbol ] field The field to min.
        #
        # @return [ Float, Document ] The min value or document with the min
        #   value.
        #
        # @since 3.0.0
        def function(arglist)
          block_given? ? (super()) : (aggregate_by(var, :min_by))
        end;Fi[	@qi?I"&        # @param [ Symbol ] field The field to max.
        #
        # @return [ Float, Document ] The max value or document with the max
        #   value.
        #
        # @since 3.0.0
        def function(arglist)
          block_given? ? (super()) : (aggregates(var)["max"])
        end;Fi[	@qiUI"&        # @param [ Symbol ] field The field to min.
        #
        # @return [ Float, Document ] The min value or document with the min
        #   value.
        #
        # @since 3.0.0
        def function(arglist)
          block_given? ? (super()) : (aggregates(var)["min"])
        end;Fi[@ÍcI"var;FI"end;FI" ;Fi	[	[	@
i≈I"Ô      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@
i I"Ô      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@
iœI"Ô      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten);Fi[	@
i‘I"Œ      end
      
      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[@˝gI"var;FI"end;FI" ;Fi	[	[	@
i)I"⁄      # reduce 49 omitted
      # reduce 50 omitted
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@
i.I"∑      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@
i3I"∑      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var);Fi[	@
i8I"¶      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      # reduce 55 omitted
      # reduce 56 omitted;Fi[I"undef_method(:namespace);FI" ;F@ScI" ;Fi	[	[	@@iI"Ω      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[	@QiI"Ω      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[	@WiI"€module Nokogiri
  module XML
    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[	@ZiI"¿      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      ;Fi[@‹.I"&out("/Encoding /WinAnsiEncoding");FI"end;FI"end;Fi	[	[	@LiI"          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[	@Oi(I"          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[	@RiI"          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>");Fi[	@ci_I"(            if var["enc"] then
              if var["diff"].nil?.! then
                out((("/Encoding " + (var + var["diff"]).to_s) + " 0 R"))
              else
                out("/Encoding /WinAnsiEncoding")
              end
            end
            out(">>")
            out("endobj");Fi[@‹.@≥eI"end;FI"@var = @var.!=(@var);Fi	[	[	@UiI"2  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
  end;Fi[	@Ui%I"  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
  end
  ;Fi[	@ciÕI"N  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    out(@var) if (@var > 0)
    @var = [var, var, var] if var;Fi[	@ciÌI"5  def function(arglist)
    if (((var == 0) and ((:g == 0) and (:b == 0))) or (:g == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var)
    @var = [var, var, var] if var
  end;Fi[@'@¸@ˇ,I"var = var.first;Fi	[	[	@iZI"Â      
      def function(arglist)
        charset(ActiveRecord::Base.configurations[var])
      end
      
      def function(arglist)
        var = var.first
        class_for_adapter(var["adapter"]).new(*var).charset
      end;Fi[	@icI"È      
      def function(arglist)
        collation(ActiveRecord::Base.configurations[var])
      end
      
      def function(arglist)
        var = var.first
        class_for_adapter(var["adapter"]).new(*var).collation
      end;Fi[	@ilI"      
      def function(arglist)
        class_for_adapter(var["adapter"]).new(var).purge
      end
      
      def function(arglist)
        var = var.first
        var = var.delete_at(1)
        class_for_adapter(var["adapter"]).new(*var).structure_dump(var);Fi[	@irI"*        var = var.first
        var = var.delete_at(1)
        class_for_adapter(var["adapter"]).new(*var).structure_dump(var)
      end
      
      def function(arglist)
        var = var.first
        var = var.delete_at(1)
        class_for_adapter(var["adapter"]).new(*var).structure_load(var);Fi[@ScI" ;F@UcI" ;Fi	[	[	@@iI"      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";Fi[	@QiI"Õ      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys;Fi[	@Wi
I"(    class ElementDecl < Nokogiri::XML::Node
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";Fi[	@ZiI"⁄      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def self.new(arglist)
        var.create_entity(var, *var);Fi[@'@(I"@var = true;FI"end;Fi	[	[	@®i\I"˚              var = Formula.factory(var.path)
              install_dependency(var) unless var.installed?
            end
          end
        end
        @var = true
      end
    end
    oh1("Installing #{Tty.green}#{f}#{Tty.reset}") if show_header;Fi[	@i;I"¿                (var << "") if var.empty?
              end
              var.value = var
            end
          end
          @var = true
        end
        
        def function(arglist);Fi[	@„iwI"˚            end
          else
            var.call(object, context, self)
          end
        end
        @var = true
      end
      var = { :success => (true) }.merge((block_given? ? (yield) : ({})))
      @var, @var = var[:result], var[:success];Fi[	@„iíI"Ì          catch(:halt) do |arglist|
            var = @var ? (:after) : (:failure)
            machine.callbacks[var].each { |arglist| var.call(object, context, self) }
          end
        end
        @var = true
      end
    end
    ;Fi[@'@(I"class Formula;FI"def function(arglist);Fi	[	[	@di#I"¥  def function(arglist)
    __send__(:remove_const, var) if const_defined?(var)
    const_set(var, var)
  end
end
class Formula
  def function(arglist)
    @var and @var.nil?
  end;Fi[	@giTI"º  
  def function(arglist)
    system("find #{HOMEBREW_PREFIX} -name .DS_Store -delete")
  end
end
class Formula
  def function(arglist)
    if (keg_only?.! or ARGV.force?) then
      true;Fi[	@àiI"~        end
      end
    end
  end
end
class Formula
  def function(arglist)
    var = []
    rev_list.each do |arglist|;Fi[	@®igI"  def function(arglist)
    check_jars
    check_non_libraries
  end
end
class Formula
  def function(arglist)
    var = "This formula is keg-only: so it was not symlinked into #{HOMEBREW_PREFIX}."
    (var << "\n\n#{keg_only_reason.to_s}");Fi[@OK@PK@∏ I"case var;Fi	[	[	@˜iEI"–        associations.each { |arglist| preload(var) } unless records.empty?
      end
      
      private
      
      def function(arglist)
        case var
        when Hash then
          preload_hash(var);Fi[	@9i*I"ø        [:name, :limit, :precision, :scale, :default, :null]
      end
      
      private
      
      def function(arglist)
        case var
        when BigDecimal then
          var.to_s;Fi[	@Îi¸I"Æ        end
      end
      
      private
      
      def function(arglist)
        case var
        when File then
          YAML.load(ERB.new(File.read(var.path)).result);Fi[	@iiI"ù        @var.call(var)
      end
      
      private
      
      def function(arglist)
        case var
        when /\.jpe?g/i then
          "image/jpeg";Fi[I"u# +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;FI"#;FI"Ü# Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).;FI"#;Fi	[	[	@ciI"ö      
      ###
      # Add +node_or_tags+ as a child of this Node.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +<<+.
      def function(arglist);Fi[	@ciI"©      
      ###
      # Insert +node_or_tags+ before this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +before+.
      def function(arglist);Fi[	@ciI"ß      
      ###
      # Insert +node_or_tags+ after this Node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +after+.
      def function(arglist);Fi[	@ci_I"ò      
      ####
      # Replace this Node with +node_or_tags+.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.
      #
      # Returns the reparented node (if +node_or_tags+ is a Node), or NodeSet (if +node_or_tags+ is a DocumentFragment, NodeSet, or string).
      #
      # Also see related method +swap+.
      def function(arglist);Fi[@OK@PK@∏ I"var = @var;Fi	[	[	@LiÌI"q    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@OiˆI"q    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@Ri‹I"q    end
  end
  
  private
  
  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj;Fi[	@Ui	I"∞    end
  end
  
  private
  
  def function(arglist)
    var = @var
    unless (@var.nil? or (@var == "")) then
      1.upto(var) { |arglist| @var[var].gsub!(@var, var.to_s) };Fi[I"while (var < var) do;FI"?var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);FI"var = (var < 128);FI"if (var.chr == "\n") then;Fi	[	[	@LisI"    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@Li∑I"    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[	@RibI"    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1);Fi[	@Ri¶I"    var = 0
    var = 0
    var = 1
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1);Fi[I">Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);FI"var = (var + 1);FI"var = -1;FI"var = var;Fi	[	[	@LiªI"       var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@Oi∂I"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@Ri™I"       var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[	@ciÆI"Ù    while (var < var) do
      var = var[var]
      if (var == "\n"[0]) then
        Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        if (var == 1) then;Fi[@'@(I"	@var;FI"end;Fi	[	[	@∏i5I"            @var = []
            ([primary_key] + (column_names - [primary_key])).compact.each_with_index do |arglist|
              (@var << [var, "#{aliased_prefix}_r#{i}"])
            end
          end
          @var
        end
        
        def function(arglist);Fi[	@Ëi~I"ê            @var = 80
          else
            @var = self.class.ui.output_cols
          end
        end
        @var
      end
    end
  end;Fi[	@(ièI"Œ        @var = var.dup
        var.each_pair do |arglist|
          @var[var.to_sym] = Paperclip::Style.new(var.to_sym, var.dup, self)
        end
      end
      @var
    end
    
    def function(arglist);Fi[	@}i I"Â            @var.self_and_descendants.detect do |arglist|
              @var.allowed_to?("view_#{o}".to_sym, var)
            end
          end
        end
        @var
      end
      
      # Yields to filter the activity scope;Fi[@OK@PK@ﬂb@‡bi	[	[	@!iˇI"        list_from_response_with_users(:post, "/1.1/lists/members/destroy_all.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[	@$irI"Ó        object_from_response(Twitter::Place, :post, "/1.1/geo/place.json", var)
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param params [Hash]
      # @return [Array];Fi[	@;i˝I"π        end
      end
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::Tweet>];Fi[	@DiI"Õ    module Utils
      DEFAULT_CURSOR = -1
      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>];Fi[@0L@-dI"end;FI" ;Fi	[	[	@2iI"N        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@;iI"N        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[	@DiI",        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # This cascade does not delete the referenced relations, but instead
        # sets the foreign key values to nil.;Fi[	@IiI"N        #
        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all;Fi[I"var.move_to_child_of(var);FI"var.move_to_child_of(var);FI"&var = Category.roots.last.to_text;FI"2Category.update_all("lft = null, rgt = null");Fi	[	[	I"Rdata//redmine_proj/plugins/awesome_nested_set/spec/awesome_nested_set_spec.rb;TiNI"]    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    (Category.roots.last.to_text.should == var);Fi[	@ŒkiYI"`    var = Category.create(:name => "Node-1")
    var = Category.create(:name => "Node-2")
    var = Category.create(:name => "Node-3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    (Category.roots.last.to_text.should == var);Fi[	@öiéI"`    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var);Fi[	@öiõI"c    var = Category.create(:name => "Node-1")
    var = Category.create(:name => "Node-2")
    var = Category.create(:name => "Node-3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var);Fi[@»k@ k@ÀkI"Category.rebuild!;Fi	[	[	@ŒkiOI"7    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end;Fi[	@ŒkiZI"9    var = Category.create(:name => "Node-2")
    var = Category.create(:name => "Node-3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    (Category.roots.last.to_text.should == var)
  end;Fi[	@öièI":    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var)
  end;Fi[	@öiúI"<    var = Category.create(:name => "Node-2")
    var = Category.create(:name => "Node-3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null")
    Category.rebuild!
    assert_equal(Category.roots.last.to_text, var)
  end;Fi[@'@¸@ˇ,I"var.flatten!;Fi	[	[	@ÛiâI"(    #   # => Query now knows the string references posts, so adds a JOIN
    def function(arglist)
      var.blank? ? (self) : (spawn.references!(*var))
    end
    
    def function(arglist)
      var.flatten!
      self.references_values = (references_values + var.map!(&:to_s)).uniq
      self;Fi[	@Ûi I"˛    #   => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>]
    def function(arglist)
      var.blank? ? (self) : (spawn.group!(*var))
    end
    
    def function(arglist)
      var.flatten!
      self.group_values += var
      self;Fi[	@ÛiÁI"7    #   => SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC
    def function(arglist)
      var.blank? ? (self) : (spawn.order!(*var))
    end
    
    def function(arglist)
      var.flatten!
      validate_order_args(var)
      var = var.reject { |arglist| Arel::Node.===(var) };Fi[	@Ûi˛I"    # generates a query with 'ORDER BY name ASC, id ASC'.
    def function(arglist)
      var.blank? ? (self) : (spawn.reorder!(*var))
    end
    
    def function(arglist)
      var.flatten!
      validate_order_args(var)
      self.reordering_value = true;Fi[I" var.left.should_not(be_nil);FI"!var.right.should_not(be_nil);FI"$Category.valid?.should(be_true);FI"end;Fi	[	[	@ŒkiI"¶    var = Category.create!(:name => "Child", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)));Fi[	@ŒkiI"ü    var = Category.create!(:name => "Child", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_id_to_nil_on_create") do |arglist|
    var = Category.create!(:name => "New Root", :parent_id => (nil));Fi[	@ŒkiI"B    var = Category.create!(:name => "New Root", :parent_id => (nil))
    var.parent.should(be_nil)
    var.parent_id.should(be_nil)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_id_on_update") do |arglist|
    var = categories(:child_2_1);Fi[	@Œki7I"∞    var = categories(:child_2).children.create!(:name => "Child")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  # create a new top-level node and move single-node top-level tree inside it.
  # create a new top-level node and move an entire top-level tree inside it.;Fi[@XM@YMI"var = var.gsub("\r", "");FI"var = var.length;Fi	[	[	@LiÆI"   
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@Oi©I"   
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@RiùI"   
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[	@UiÜI"   
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0;Fi[@'@¸I"A# QUOTING ==================================================;FI"def function(arglist);Fi	[	[	@Ii∫I"|      # error number.
      def function(arglist)
        raise(NotImplementedError)
      end
      
      # QUOTING ==================================================
      def function(arglist)
        if var.kind_of?(String) and (var and ((var.type == :binary) and var.class.respond_to?(:string_to_binary))) then
          var = var.class.string_to_binary(var).unpack("H*")[0];Fi[	@Qi9I"      
      def function(arglist)
        var.error_number if var.respond_to?(:error_number)
      end
      
      # QUOTING ==================================================
      def function(arglist)
        @var.escape(var)
      end;Fi[	@ViïI"      
      def function(arglist)
        var.errno if var.respond_to?(:errno)
      end
      
      # QUOTING ==================================================
      def function(arglist)
        return super unless ((var == true) or (var == false))
        var ? (1) : (0);Fi[	@çiøI"f      # Returns true.
      def function(arglist)
        true
      end
      
      # QUOTING ==================================================
      def function(arglist)
        if var.kind_of?(String) and (var and ((var.type == :binary) and var.class.respond_to?(:string_to_binary))) then
          var = var.class.string_to_binary(var).unpack("H*")[0];Fi[@‡"@·"@‚"I"##;Fi	[	[	@•iLI"N            Logger.warn(Errors::Storage::Dropbox::CacheError.wrap(var, "              Could not read session data from cache.\n              Cache data might be corrupt.\n"))
          end
        end
        var
      end
      
      ##
      # Transfers the archived file to the specified Dropbox folder
      def function(arglist);Fi[	@“i¨I"g              Logger.warn(("  [skipping] #{local_file.path}\n" + "  Path Contains Invalid UTF-8 byte sequences"))
              return nil
            end
            var
          end
          
          ##
          # Creates a new LocalFile object using the given directory and line
          # from the md5 hash checkup. This object figures out the path,;Fi[	@oi0I"
      var.user = escape((ENV["http_proxy_user"] or ENV["HTTP_PROXY_USER"]))
      var.password = escape((ENV["http_proxy_pass"] or ENV["HTTP_PROXY_PASS"]))
    end
    var
  end
  
  ##
  # Returns true when proxy should by bypassed for host.
  def function(arglist);Fi[	@oièI"≤      Thread.current[@var][var] = Time.now
    end
    @var["#{uri.host}:#{uri.port}"] ||= var.http_version
    var
  end
  
  ##
  # Shuts down all connections for +thread+.
  #;Fi[@‹jI"end;FI"end;FI"end;Fi	[	[	@LiüI"å        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@OiöI"å        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@RiéI"å        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  def function(arglist);Fi[	@ciÉI"ú        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end
  
  alias_method(:multi_cell, :MultiCell);Fi[I"%categories(:child_2).save(false);F@˜YI"end;FI" ;Fi	[	[	@öiﬁI"  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?);Fi[	@öiÂI"  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = nil
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?);Fi[	@öiÛI"!  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:lft] = categories(:top_level)[:lft]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    assert(Category.left_and_rights_valid?);Fi[	@öi˙I"  def function(arglist)
    assert(Category.left_and_rights_valid?)
    categories(:child_2)[:rgt] = categories(:top_level)[:rgt]
    categories(:child_2).save(false)
    assert(Category.left_and_rights_valid?.!)
  end
  
  def function(arglist)
    var = Category.create;Fi[I"E# * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.;FI"#;FI"# Example:;FI"#;Fi	[	[	I"7data//redmine_proj/plugins/rfpdf/lib/core/rfpdf.rb;Ti>I"`  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text(x, y, header_left, :font_size => 10)
  	#;Fi[	@>liVI"≠  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text_block(left_margin, 85, "question", left_margin, 280,
  #       :font_color => ReportHelper::COLOR_PALETTE[:dark_blue],;Fi[	@>liïI"ä  # * <tt>:padding</tt> - Default value is nothing or <tt>2</tt>.
  # * <tt>:x_padding</tt> - Default value is nothing.
  # * <tt>:valign</tt> - 'M' = middle, 'T' = top, 'B' = bottom. Default value is nothing or <tt>'M'</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text_box(x, y - 1, 38, 22, 
  #                 "your_score_title", ;Fi[	@>li·I"_  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>18</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_title(left_margin, 60, 
  	#       "title:", ;Fi[@‡"I"	else;FI"var;FI"end;Fi	[	[	@ãiWI"Ï            (var.attribute_names.&(var.attribute_names) - var.changes.keys).each do |arglist|
              var[var] = var[var]
            end
            var
          else
            var
          end
        end
        (var + var);Fi[	@>i;I"á              (var << "(#{limit})")
            end
          end
          var
        else
          var
        end
      end
      ;Fi[	@¬iÆI"ß          var = var.pos
          var = StringIO.new(var.read)
          var.pos = var.pos = var
          var
        else
          var
        end
      end
    end;Fi[	@xitI"ñ      when :markdown then
        var
      when :textile then
        var
      else
        var
      end
    end.flatten
    incoming_entities(var);Fi[I"@var = (var + var);FI"	else;F@‹jI"end;Fi	[	[	@LiùI"ì    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@OiòI"ì    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@RiåI"ì    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[	@ciÅI"ù      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end
  end;Fi[I"newobj;F@
fI"out("endobj");FI"end;Fi	[	[	@LiÚI"ˆ  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@Oi˚I"ˆ  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@Ri·I"ˆ  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@ci'I"Ò  def function(arglist)
    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each do |arglist|
      newobj;Fi[@al@˜[I""out("/Subtype /CIDFontType0");FI"'out(("/BaseFont /" + var["name"]));Fi	[	[	@LiDI"∆    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((((("/CIDSystemInfo <</Registry " + textstring("Adobe")) + " /Ordering ") + textstring(var["registry"]["ordering"])) + " /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@OiMI"§    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@Ri3I"§    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[	@ciäI"§    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[@xQ@yQ@5]I"S# @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.;Fi	[	[	@5iII"'      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik;Fi[	@5i`I"ˇ      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user;Fi[	@5iuI"       # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :include_rts Specifies that the timeline should include native retweets in addition to regular tweets. Note: If you're using the trim_user parameter in conjunction with include_rts, the retweets will no longer contain a full user object.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[	@5iáI"-      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.;Fi[@al@^\@_\I"out("/Flags 6");Fi	[	[	@LiYI"Â    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[	@OiZI"    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[	@RiDI"Â    end
    out((("/W [" + var) + "]>>"))
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[	@cióI"    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6")
    out("/FontBBox [0 -200 1000 900]")
    out("/ItalicAngle 0");Fi[@'@(@éI"#if (RUBY_VERSION < "1.9") then;Fi	[	[	@?iôI":    def function(arglist)
      specs_by_name(var.name).select do |arglist|
        same_version?(var.version, var.version) and (Gem::Platform.new(var.platform) == Gem::Platform.new(var.platform))
      end
    end
    
    if (RUBY_VERSION < "1.9") then
      def function(arglist)
        var = /^(.*?)(?:\.0)*$/;Fi[	@ïdiJI"ò        end
      end
      on_connect
    end
  end
  
  if (RUBY_VERSION < "1.9") then
    ##
    # From ruby_1_8_7 branch r29865 including a modified;Fi[	@<i I"ã        end)
      ensure
        @var = var
      end
    end
    
    if (RUBY_VERSION < "1.9") then
      attr_reader :function
    else;Fi[	@Ui}I"          end
        end
        return var
      end
    end
    
    if (RUBY_VERSION < "1.9") then
      # Like {\#check\_encoding}, but also checks for a Ruby-style `-# coding:` comment
      # at the beginning of the template and uses that encoding if it exists.;Fi[@'@(@éI"module ConnectionAdapters;Fi	[	[	@QiI"i      var = Mysql2::Client.new(var.symbolize_keys)
      var = [var[:host], var[:username], var[:password], var[:database], var[:port], var[:socket], 0]
      ConnectionAdapters::Mysql2Adapter.new(var, logger, var, var)
    end
  end
  
  module ConnectionAdapters
    class Mysql2Adapter < AbstractMysqlAdapter
      class Column < AbstractMysqlAdapter::Column;Fi[	@Vi2I"      end
      var = [var, var, var, var, var, var, var]
      ConnectionAdapters::MysqlAdapter.new(var, logger, var, var)
    end
  end
  
  module ConnectionAdapters
    class MysqlAdapter < AbstractMysqlAdapter
      class Column < AbstractMysqlAdapter::Column;Fi[	@çiI"%      var = SQLite3::Database.new(var[:database], :results_as_hash => (true))
      var.busy_timeout(var[:timeout]) if var[:timeout]
      ConnectionAdapters::SQLite3Adapter.new(var, logger, var)
    end
  end
  
  module ConnectionAdapters
    class SQLite3Column < Column
      class << self;Fi[	I"-data//activerecord_proj/active_record.rb;TixI"Æ    eager_autoload do |arglist|
      autoload(:Optimistic)
      autoload(:Pessimistic)
    end
  end
  
  module ConnectionAdapters
    extend(ActiveSupport::Autoload)
    ;Fi[@è7I"@var = nil;FI"end;FI" ;Fi	[	[	@ïdiI"v  @var = nil
  
  def function(arglist)
    super
    @var = nil
  end
  
  if (RUBY_VERSION > "1.9") then
    ##;Fi[	@';iI"í    Test::Unit::TestCase
  end
    def function(arglist)
      super
      @var = nil
    end
    
    def function(arglist)
      var = open(var);Fi[	@ÉiOI"Ù        
        # https://rspec.lighthouseapp.com/projects/16211/tickets/342
        def function(arglist)
          super
          @var = nil
        end
        
        def function(arglist)
          source_tags.map { |arglist| var.name };Fi[	@Õi I"ï    end
    
    def function(arglist)
      super
      @var = nil
    end
    
    # The initial state name for this path
    def function(arglist);Fi[@˜U@¯UI" ;FI"def function(arglist);Fi	[	[	@£3i9I"—    @var = @var
    out((("<</Type /Outlines /First " + var.to_s) + " 0 R"))
    out((("/Last " + (var + var[0]).to_s) + " 0 R>>"))
    out("endobj")
  end
  
  def function(arglist)
    super
    putbookmarks;Fi[	@Ui>I"¬    out(("/Count " + var.to_s))
    out(sprintf("/MediaBox [0 0 %.2f %.2f]", var, var))
    out(">>")
    out("endobj")
  end
  
  def function(arglist)
    var = @var
    @var.each do |arglist|;Fi[	@Ui÷I"ﬂ    out("<<")
    putresourcedict
    out(">>")
    out("endobj")
  end
  
  def function(arglist)
    out(("/Producer " + textstring(("Ruby FPDF " + FPDF_VERSION))))
    out(("/Title " + textstring(@var))) unless @var.nil?;Fi[	@ôiªI"È          @var = self.n
          out("<</Type /Outlines /First #{n} 0 R")
          out("/Last #{(n + lru[0])} 0 R>>")
          out("endobj")
        end
        
        def function(arglist)
          super
          putbookmarks;Fi[I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;FI"@var = @var;FI"	else;Fi	[	[	@LióI"Á      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@OiíI"Á      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@RiÜI"Á      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[	@cizI"Ô      out("0 Tw")
    end
    (var << "B") if var.is_a?(String) and var.include?("B")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var;Fi[@'@¸I"# Returns true;F@‰ai	[	[	@çisI"î      #:nodoc:
      def function(arglist)
        "SQLite"
      end
      
      # Returns true
      def function(arglist)
        true
      end;Fi[	@çiåI"à      
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end;Fi[	@çi¢I"µ      # Clears the prepared statements cache.
      def function(arglist)
        @var.clear
      end
      
      # Returns true
      def function(arglist)
        true
      end;Fi[	@çißI"ñ      # Returns true
      def function(arglist)
        true
      end
      
      # Returns true
      def function(arglist)
        true
      end;Fi[@'@¸@∞NI";# Logs a message to the console and log file to inform;Fi	[	[	@FiI"3      # Return the compressor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is using the compressor
      def function(arglist);Fi[	@`i)I"1      # Return the database name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is dumping the database
      def function(arglist);Fi[	@uiI"4      # Return the encryptor name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is encrypting the archive
      def function(arglist);Fi[	@ÅiHI"8      # Return the notifier name, with Backup namespace removed
      def function(arglist)
        self.class.to_s.sub("Backup::", "")
      end
      
      ##
      # Logs a message to the console and log file to inform
      # the client that Backup is notifying about the process
      def function(arglist);Fi[@'@¸@∞N@õei	[	[	@™i6I"Í          var.passive = true if passive_mode
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@ªi6I"        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        begin;Fi[	@√i*I"        Net::SSH.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[	@»i(I"        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|
          yield(var)
        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var);Fi[@{G@¢H@£HI"var = 0;Fi	[	[	@UiSI"        var = (var == 0) ? (0) : ((var - 1))
        self.Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@UipI"˚            self.Cell(var, var, var[(var..var)], var, 2, var, var)
            var = (var + 1)
          end
          var = -1
          var = var
          var = 0
          var = 0
          var = (var + 1)
          var = var if var and (var == 2);Fi[	@ciMI"˚        var = (var == 0) ? (1) : (var)
        Cell(var, var, var[(var..var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[	@cikI"‰          Cell(var, var, var[(var..var)], var, 2, var, var)
          var = (var + 1)
        end
        var = -1
        var = var
        var = 0
        var = 0
        var = (var + 1)
        var = var if var and (var == 2);Fi[@{K@L`I"##;F@N`i	[	[	@ciI"◊      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # IPv6 support (disabled by default);Fi[	@fiI"      ##
      # Name of the database that needs to get dumped
      # To dump all databases, set this to `:all` or leave blank.
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database;Fi[	@iiI"ﬁ      
      ##
      # Name of the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Tables to skip while dumping the database;Fi[	@liI"      
      ##
      # Name of and path to the database that needs to get dumped
      ##
      # Credentials for the specified database
      ##
      # Connectivity options
      ##
      # Determines whether Backup should invoke the SAVE command through;Fi[@'@¸I"alias :== :eql?;FI" ;Fi	[	[	@Ji3I"D      
      def function(arglist)
        Git.===(var) and ((uri == var.uri) and ((ref == var.ref) and ((branch == var.branch) and ((name == var.name) and ((version == var.version) and (submodules == var.submodules))))))
      end
      
      alias :== :eql?
      
      def function(arglist)
        var = if local? then;Fi[	@Xi=I"0      
      def function(arglist)
        var.instance_of?(Path) and ((path.expand_path(Bundler.root) == var.path.expand_path(Bundler.root)) and (version == var.version))
      end
      
      alias :== :eql?
      
      def function(arglist)
        File.basename(path.expand_path(Bundler.root).to_s);Fi[	@_i)I"¡      
      def function(arglist)
        Rubygems.===(var)
      end
      
      alias :== :eql?
      
      def function(arglist)
        { "remotes" => (@var.map { |arglist| var.to_s }) };Fi[	I":data//capistrano_proj/capistrano/server_definition.rb;Ti&I"@    # definitions, based solely on their host names.
    def function(arglist)
      (host == var.host) and ((user == var.user) and (port == var.port))
    end
    
    alias :== :eql?
    
    # Redefined, so that Array#uniq will work to remove duplicate server
    # definitions, based on their connection information.;Fi[@V@VI"∂#   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.;FI"def function(arglist);Fi	[	[	@;iQI"C      #   @example Return the Tweet with the ID 25938088801
      #     Twitter.statuses(25938088801)
      # @overload statuses(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(arglist)
        threaded_tweets_from_response(:get, "/1.1/statuses/show", var)
      end;Fi[	@;ieI"T      #   @example Destroy the Tweet with the ID 25938088801
      #     Twitter.status_destroy(25938088801)
      # @overload status_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(arglist)
        threaded_tweets_from_response(:post, "/1.1/statuses/destroy", var)
      end;Fi[	@;iãI"N      #   @example Retweet the Tweet with the ID 28561922516
      #     Twitter.retweet(28561922516)
      # @overload retweet(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|;Fi[	@;i¶I"P      #   @example Retweet the Tweet with the ID 28561922516
      #     Twitter.retweet!(28561922516)
      # @overload retweet!(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|;Fi[@º[@Ω[@æ[I"(# @return [Twitter::List] The list.;Fi	[	[	@!iTI"      # Removes the specified member from the list
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/destroy
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_remove_member(list, user_to_remove, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;Fi[	@!iÒI"U      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/create_all
      # @note Lists are limited to having 500 members, and you are limited to adding up to 100 members to a list at a time with this method.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_add_members(list, users, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;Fi[	@!iII"       #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/create
      # @note Lists are limited to having 500 members.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_add_member(list, user_to_add, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;Fi[	@!i‚I"¸      # Removes specified members from the list
      #
      # @see https://dev.twitter.com/docs/api/1.1/post/lists/members/destroy_all
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::List] The list.
      # @overload list_remove_members(list, users, options={})
      #   @param list [Integer, String, Twitter::List] A Twitter list ID, slug, or object.;Fi[@'@¸@“b@”bi	[	[	@Di$I"          merge_user!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::User, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@Di/I""        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        objects_from_response(var, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash];Fi[	@Di@I"ı      # @return [Array]
      def function(arglist)
        var.map { |arglist| var.fetch_or_new(var) }
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array];Fi[	@DiLI"        var.flatten.threaded_map do |arglist|
          object_from_response(var, var, var, var.options.merge(:id => (var)))
        end
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash];Fi[@˜U@¯U@¥lI"#;Fi	[	[	@ciI"¢    out(("/Count " + var.to_s))
    out(sprintf("/MediaBox [0 0 %.2f %.2f]", var, var))
    out(">>")
    out("endobj")
  end
  
  #
  	# Adds fonts
  	# putfonts;Fi[	@ci¢I"Å    out("/CapHeight 800")
    out("/StemV 60")
    out(">>")
    out("endobj")
  end
  
  #
  	# putimages
  	# @access protected;Fi[	@ciÙI"w    out("<<")
    putresourcedict
    out(">>")
    out("endobj")
  end
  
  #
  	# putinfo
  	# @access protected;Fi[	@ciñ
I"$    out("/Filter /FlateDecode") if (var[-2, 2] == ".z")
    out(">>")
    open(var, "rb") { |arglist| putstream(var.read) }
    out("endobj")
  end
  
  #
  	# Converts UTF-8 strings to codepoints array.<br>
  	# Invalid byte sequences will be replaced with 0xFFFD (replacement character)<br>;Fi[@˜U@]\@˜[@nli	[	[	@LiCI"≤    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((((("/CIDSystemInfo <</Registry " + textstring("Adobe")) + " /Ordering ") + textstring(var["registry"]["ordering"])) + " /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@OiLI"ê    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@Ri2I"ê    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[	@ciâI"ê    out(("/Encoding /" + var["cMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[I"var = @var["cw"];FI"/var = ((@var - @var) - @var) if (var == 0);FI"/var = (((var - (2 * @var)) * 1000) / @var);FI"var = var.gsub("\r", "");Fi	[	[	@Li[I"  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[	@OiPI"  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[	@RiJI"  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");Fi[	@Ui0I"  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "\n");Fi[@Gm@XM@YM@˚ki	[	[	@Li≠I"ƒ  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@Oi®I"ƒ  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@RiúI"ƒ  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[	@UiÖI"ƒ  end
  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1;Fi[@Hm@Im@JmI"var = var.length;Fi	[	[	@Li\I"    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@OiQI"    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@RiKI"    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0;Fi[	@Ui1I"  
  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)].chr == "\n")
    var = 0;Fi[@'@¸@›c@ﬁci	[	[	@¢
i$I"$                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[	@¥
iI"1            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[	@Ω
i%I"Ì                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[	@ﬁ
iI";          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| bind_from_relational_parent(target) }
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #
          # @example Unbind the document.;Fi[@'@¸I"alias :size :length;FI" ;Fi	[	[	@ãiÆI"Ω      # @since 3.0.0
      def function(arglist)
        documents.length
      end
      
      alias :size :length
      
      # Limits the number of documents that are returned.
      #;Fi[	@éiÍI"“      # @since 3.0.0
      def function(arglist)
        @var ||= self.count
      end
      
      alias :size :length
      
      # Limits the number of documents that are returned from the database.
      #;Fi[	@#:i	I"¬      # Convert this NodeSet to XML
      def function(arglist)
        map { |arglist| var.to_xml(*var) }.join
      end
      
      alias :size :length
      
      alias :to_ary :to_a
      ;Fi[	@7iWI"Ø    # Get the length of the queue
    def function(arglist)
      @var.llen(@var)
    end
    
    alias :size :length
    
    # Is the queue empty?
    def function(arglist);Fi[I"require("twitter/tweet");FI"require("twitter/user");FI"module Twitter;FI"module API;Fi	[	[	@Íi	I"Ôrequire("twitter/api/utils")
require("twitter/error/already_favorited")
require("twitter/error/forbidden")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Favorites
      include(Twitter::API::Utils);Fi[	@!iI"ﬁrequire("twitter/error/forbidden")
require("twitter/error/not_found")
require("twitter/list")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Lists
      include(Twitter::API::Utils);Fi[	@5iI"°require("twitter/api/utils")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Timelines
      include(Twitter::API::Utils);Fi[	@>i	I"ﬂrequire("twitter/api/arguments")
require("twitter/api/utils")
require("twitter/cursor")
require("twitter/tweet")
require("twitter/user")
module Twitter
  module API
    module Undocumented
      include(Twitter::API::Utils);Fi[@Im@JmI"var = var.length;FI"var = -1;Fi	[	[	@LiØI"”  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@Oi™I"”  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@RiûI"”  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[	@UiáI"”  def function(arglist)
    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0;Fi[@ImI"end;FI"var = (var + 1);FI"	next;Fi	[	[	@Li√I"ˆ        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "));Fi[	@OiæI"·        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var < 128) then;Fi[	@Ri≤I"ˆ        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      var = var if (var.! or (var.chr == " "));Fi[	@UiöI"Â        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
        next
      end
      if (var == " "[0]) then;Fi[I"@var ||= {};FI"end;FI" ;FI"def function(arglist);Fi	[	[	@XiI"!        end
        
        def function(arglist)
          @var ||= {}
        end
        
        def function(arglist)
          var = ("#{self}##{name} has been deprecated as of " + "backup v.#{deprecation[:version]}")
          (var << "\n#{deprecation[:message]}") if var[:message];Fi[	@
iLI"è      private
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= {}
      end;Fi[	@
iPI"≠      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        @var ||= Hash.new { |arglist| var[var] = [] }
      end;Fi[	@”iI"Ã      end
      
      def function(arglist)
        @var ||= {}
      end
      
      def function(arglist)
        __raise("#{intro} received unexpected message :#{sym}#{arg_message(*args)}")
      end;Fi[@(@TlI"	else;F@‹ji	[	[	@LiúI"ü      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@OióI"ü      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@RiãI"ü      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[	@ciÄI"†    else
      if (var == 0) then
        @var = var
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end
    end;Fi[@'@¸@ˇ,I"var.each do |arglist|;Fi	[	[	@ùiëI"[        var = construct_join_attributes(var)
        var = Array.wrap(through_association.target)
        var.find_all { |arglist| (var.attributes.slice(*var.keys) == var) }
      end
      
      def function(arglist)
        var.each do |arglist|
          var = through_records_for(var)
          if (through_reflection.macro == :has_many) then;Fi[	@ΩiI"b        @var = AliasTracker.new(var.connection, var)
        @var.aliased_name_for(var.table_name)
        build(var)
      end
      
      def function(arglist)
        var.each do |arglist|
          (join_associations.detect { |arglist| (var == var) } or build(var.reflection.name, (var.find_parent_in(self) or join_base), var.join_type))
        end;Fi[	@˜iRI"F        else
          raise(ArgumentError, "#{association.inspect} was not recognised for preload")
        end
      end
      
      def function(arglist)
        var.each do |arglist|
          Preloader.new(records, var, preload_scope).run
          Preloader.new(records.map { |arglist| var.send(var) }.flatten, var).run;Fi[	@ficI"          var[var] = instance_variable_get(var)
          var
        end
      end
      
      def function(arglist)
        var.each do |arglist|
          unless ["@_proxy", "@_implementation", "@method_name"].include?(var.to_s) then
            instance_variable_set(var, var);Fi[@'@¸@ˇ,I"ensure_not_nested;Fi	[	[	@ùi$I"¨          end
        end
        super
      end
      
      def function(arglist)
        ensure_not_nested
        var = super
        if owner.new_record? and var then;Fi[	@ùi-I"◊          var.flatten.each { |arglist| build_through_record(var) }
        end
        var
      end
      
      def function(arglist)
        ensure_not_nested
        if var.new_record? then
          if var then;Fi[	@ùiYI"         ensure
          @var.delete(var.object_id)
        end
      end
      
      def function(arglist)
        ensure_not_nested
        var = super(var)
        var = source_reflection.inverse_of;Fi[	@ùixI"¡        else
          true
        end
      end
      
      def function(arglist)
        ensure_not_nested
        var = load_target if (var == :all)
        var = through_association.scope;Fi[@'@¸@ˇ,I"var = var.flatten;Fi	[	[	@ãivI"	      
      def function(arglist)
        scope.scope_for_create.stringify_keys
      end
      
      def function(arglist)
        var = var.flatten
        var.each { |arglist| raise_on_type_mismatch(var) }
        var = var.reject { |arglist| var.new_record? };Fi[	@iI"Y      def function(arglist)
        serialize(var, IndifferentCoder.new(var[:coder]))
        store_accessor(var, var[:accessors]) if var.has_key?(:accessors)
      end
      
      def function(arglist)
        var = var.flatten
        var.each do |arglist|
          define_method("#{key}=") { |arglist| write_store_attribute(var, var, var) };Fi[	@
i2I"∞      def function(arglist)
        var = [var.first, var.last].flatten
        var
      end
      
      def function(arglist)
        var = var.flatten
        var
      end;Fi[	@
i7I"û      def function(arglist)
        var = var.flatten
        var
      end
      
      def function(arglist)
        var = var.flatten
        var
      end;Fi[@Im@öm@õmI"	else;Fi	[	[	@Li·I"Ì        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@OiÈI"˜        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + var)
        var = var if (var >= 128);Fi[	@Ri–I"Ì        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end;Fi[	@UiªI"›        if (var == 1) then
          @var = @var
          var = ((@var - @var) - @var)
          var = (((var - (2 * @var)) * 1000) / @var)
        end
        var = (var + 1)
      else
        var = (var + 1)
      end;Fi[@JmI"var = var.length;FI"var = -1;FI"var = 0;Fi	[	[	@Li∞I"«    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@Oi´I"«    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@RiüI"«    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[	@UiàI"«    var = @var["cw"]
    var = ((@var - @var) - @var)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = -1
    var = 0
    var = 0
    var = 0;Fi[@€L@‹LI"	else;F@≈`i	[	[	@LiòI"¯    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@OiìI"¯    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@RiáI"¯    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var);Fi[	@ci{I"    end
    (var << "B") if var.is_a?(String) and var.include?("B")
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = var;Fi[@'@¸@ˇ,I"var = column_for(var, var);Fi	[	[	@Çi&I"        var = alias_tracker.connection.substitute_at(var, var.bind_values.length)
        var.bind_values += [[var, var]]
        var
      end
      
      def function(arglist)
        var = column_for(var, var)
        bind_value(var, var, var)
      end;Fi[	@Ii≈I"6      
      def function(arglist)
        execute("ALTER TABLE #{quote_table_name(table_name)} #{add_column_sql(table_name, column_name, type, options)}")
      end
      
      def function(arglist)
        var = column_for(var, var)
        change_column(var, var, var.sql_type, :default => (var))
      end;Fi[	@Ii I"ô      def function(arglist)
        var = column_for(var, var)
        change_column(var, var, var.sql_type, :default => (var))
      end
      
      def function(arglist)
        var = column_for(var, var)
        unless (var or var.nil?) then
          execute("UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL");Fi[	@IioI"*        add_column_options!(var, var)
        add_column_position!(var, var)
        var
      end
      
      def function(arglist)
        var = column_for(var, var)
        var[:default] = var.default unless options_include_default?(var)
        var[:null] = var.null unless var.has_key?(:null);Fi[@(@ó4@ò4I"end;Fi	[	[	@¢6iAI"’    
    def function(arglist)
      super("Attempted to #{attempted_action} a stale object: #{record.class.name}")
      @var = var
      @var = var
    end
  end
  
  class ConfigurationError < ActiveRecordError;Fi[	@¢6iZI"ù    
    def function(arglist)
      super(var)
      @var = var
      @var = var
    end
  end
  
  class MultiparameterAssignmentErrors < ActiveRecordError;Fi[	@Â	iI"Õ        
        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
      end
      
      class MultiparameterAssignmentErrors < Mongoid::Errors::MongoidError;Fi[	@ci4I"Ü        @var = var
      else
        if (var == 2) then
          @var = var
          @var = var
        end
      end
    end
  end;Fi[@'@¸@†>I"end;Fi	[	[	@iZI"æ        
        def function(arglist)
          saved_attachments.each { |arglist| (self.attachments << var) }
        end
        
        module ClassMethods
        end
      end
    end;Fi[	@iÇI"ó        def function(arglist)
          @var = nil
          @var = true
        end
        
        module ClassMethods
        end
      end
    end;Fi[	@i=I"«          var = project.notified_users
          var.reject! { |arglist| visible?(var).! }
          var.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end;Fi[	@2iQI"–        # Returns an array of watchers' email addresses
        def function(arglist)
          notified_watchers.collect(&:mail)
        end
        
        module ClassMethods
        end
      end
    end;Fi[@'@¸@^dI"#:nodoc:;Fi	[	[	@oi)I"∏      
      def function(arglist)
        index(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:doc_string, to_step_definition_arg];Fi[	@ñiÆI"Ó      def function(arglist)
        var = "table:#{headers.join(",")}"
        var.match(var)
      end
      
      # For testing only
      #:nodoc:
      def function(arglist)
        [:table, *cells_rows.map { |arglist| var.to_sexp }];Fi[	@ñi1I"
          return if Cucumber.wants_to_quit
          each { |arglist| var.visit_table_cell(var) }
          nil
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:row, line, *@var.map { |arglist| var.to_sexp }];Fi[	@ñisI"÷        
        def function(arglist)
          (SurplusCell.===(var) or (value == var.value))
        end
        
        # For testing only
        #:nodoc:
        def function(arglist)
          [:cell, @var];Fi[@'@¸@c@ci	[	[	@`iGI"H            var[/^date: (.*?);/, 1]
          end.sort.last + " UTC")
          return var
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist);Fi[	@li{I"8        
        def function(arglist)
          (variable(:git) or super)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist);Fi[	@{i<I"c        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist);Fi[	@ÇiCI"c        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist);Fi[@(@(@(I"##;Fi	[	[	@√i9I"     # Adds the given String of +options+ to the `tar` command.
    # e.g. '-h --xattrs'
    def function(arglist)
      @var = var
    end
    
    ##
    # Archives all the provided paths in to a single .tar file
    # and places that .tar file in the folder which later will be packaged;Fi[	@ÑidI"⁄        def function(arglist)
          @var = var
          @var = var
          @var = var
        end
        
        ##
        # Wrapper method for the #send_message (private) method
        def function(arglist);Fi[	@˝iI"„    
    def function(arglist)
      @var = var
      @var = var
    end
    
    ##
    # This is called as part of the procedure used to build the final
    # backup package file(s). It yields it's portion of the command line;Fi[	@ùiI"≥      def function(arglist)
        load_defaults!
        @var = var
        @var = var
      end
      
      ##
      # Performs the backup transfer
      def function(arglist);Fi[@(@(@(I"attr_reader :function;Fi	[	[	@6iI"≥      @var = var
      @var = var
      @var = var
      @var = var
    end
    
    attr_reader :function
    
    # needed for standalone, load required_paths from local gemspec;Fi[	@iWI"ì    
    class JsArg
      def function(arglist)
        @var = var
      end
      
      attr_reader :function
      
      def function(arglist);Fi[	@ˆi2I"~  
  def function(arglist)
    @var = var.to_s
    @var = var
  end
  
  attr_reader :function
  
  def function(arglist);Fi[	@1 i4I"ç    end
    
    def function(arglist)
      @var = var
    end
    
    attr_reader :function
    
    ERROR_MESSAGES.keys.each do |arglist|;Fi[@(@(@(I"private;Fi	[	[	@6iCI"t    end
    
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist);Fi[	@"i(I"¿    # once the remote gem is downloaded, the backend specification will
    # be swapped out.
    def function(arglist)
      @var = var
    end
    
    private
    
    def function(arglist);Fi[	@∆i"I"ë    #
    # @since 3.0.0
    def function(arglist)
      @var = var
    end
    
    private
    
    # Gets the default Mongoid logger - stdout.;Fi[	@i6I"               @var = var
            end
            @var = var
            @var = var
          end
          
          private
          
          # Can the existing relation potentially be deleted?;Fi[@b@b@bI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi	[	[	@>iI"e      
      # Returns activity about me
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array] An array of actions
      # @param options [Hash] A customizable set of options.;Fi[	@>i0I"y        objects_from_response(Twitter::ActionFactory, :get, "/i/activity/by_friends.json", var)
      end
      
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      #
      # @overload following_followers_of(options={});Fi[	@>iNI"e      
      # Returns activity summary for a Tweet
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Tweet] The requested Tweet.
      # @param id [Integer] A Tweet ID.;Fi[	@>iaI"n      
      # Returns activity summary for Tweets
      #
      # @note Undocumented
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>] The requested Tweets.
      # @overload statuses_activity(*ids);Fi[I"var = "LRT";FI"var = "LR";FI"	else;FI"var = "";Fi	[	[	@LieI"Ï    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@OiZI"Ï    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@RiTI"Ï    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?;Fi[	@Ui:I"Ë    if var.!=(0) then
      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.index("L").nil?
        var = (var + "R") unless var.index("R").nil?;Fi[@(I"@var = false;FI"end;FI" ;Fi	[	[	@µiI"       
      def function(arglist)
        @var = []
        @var = var
        @var = false
      end
      
      # While executing the given block, the recorded will be in reverting mode.
      # All commands recorded will end up being recorded reverted;Fi[	@˜iI"
        def function(arglist)
          @var = var.strip.gsub(/\r?\n/, "\\\n")
          @var = (var or Capistrano::Configuration.default_io_proc)
          @var = var
          @var = false
        end
        
        def function(arglist)
          options[:last];Fi[	@Çi0I"Á        def function(arglist)
          check_encoding(var)
          @var = var
          @var = var
          @var = false
        end
        
        ###
        # Parse given +thing+ which may be a string containing xml, or an;Fi[	@,iI"ƒ    # This job's associated payload object.
    def function(arglist)
      @var = var
      @var = var
      @var = false
    end
    
    def self.create(arglist)
      Resque.validate(var, var);Fi[I"var = "LR";FI"	else;FI"var = "";FI".var = "L" unless var.to_s.index("L").nil?;Fi[[	@LifI"      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[	@Oi[I"      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[	@RiUI"      if (var == 1) then
        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[@V.@W.I"var;FI"end;Fi[[	@Œi0I"≥            var = $stderr
            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        
        def self.wrap(arglist);Fi[	@!iKI"Ÿ          var[:list_id] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      
      # Take an owner and merge it into the hash with the correct key;Fi[	@DiíI"ˇ        when Twitter::User then
          var[[var, "user_id"].compact.join("_").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      
      # Take a multiple users and merge them into the hash with the correct keys;Fi[@V.@W.I"	else;FI""";Fi[[	@™iI"“          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end;Fi[	@™i4I"“          when :pdf then
            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end;Fi[	@™iqI"Æ          when :pdf then
            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end;Fi[I"
begin;FI"!var = (var + var.iconv(var));FI""rescue Iconv::IllegalSequence;FI"var = (var + $!.success);Fi[[	@ÄiI"        else
          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry;Fi[	@Äi>I"        else
          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry;Fi[	@Äi|I"        else
          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry;Fi[@–0@—0@“0I"	####;Fi[[	@ci0I"S      # Also see related method +add_previous_sibling+.
      def function(arglist)
        add_previous_sibling(var)
        self
      end
      
      ####
      # Insert +node_or_tags+ after this node (as a sibling).
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.;Fi[	@ci<I"H      # Also see related method +add_next_sibling+.
      def function(arglist)
        add_next_sibling(var)
        self
      end
      
      ####
      # Set the inner html for this Node to +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.;Fi[	@ciHI";      # Also see related method +children=+
      def function(arglist)
        self.children = var
        self
      end
      
      ####
      # Set the inner html for this Node +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a string containing markup.;Fi[@PII"@var = {};FI"@var = {};FI"@var = {};Fi[[	@àiI"§      
      def function(arglist)
        @var = var
        @var = {}
        @var = {}
        @var = {}
        @var = {}
        prepare_default_proc
      end;Fi[	@ïiI"À    def function(arglist)
      var = self.class.primary_key
      @var[var] = nil unless @var.key?(var)
      @var = {}
      @var = {}
      @var = {}
      @var = {}
      @var = {}
      @var = false;Fi[	@ïiI"ƒ      var = self.class.primary_key
      @var[var] = nil unless @var.key?(var)
      @var = {}
      @var = {}
      @var = {}
      @var = {}
      @var = {}
      @var = false
      @var = false;Fi[@–0@—0@“0I"private;Fi[[	@§i‡I"û    
    def function(arglist)
      var.send(:rules).each { |arglist| (rules << var.dup) }
      self
    end
    
    private
    
    def function(arglist);Fi[	@-iUI"¯    if var.auto_follow_back and var.receiving.! then
      var.share_with(var, var.auto_follow_back_aspect)
    end
    self
  end
  
  private
  
  # Checks if a [Contact] does not already exist between the requesting [User] and receiving [Person];Fi[	@™iI"
      IdentityMap.set(self)
      run_callbacks(:find) unless _find_callbacks.empty?
      run_callbacks(:initialize) unless _initialize_callbacks.empty?
      self
    end
    
    private
    
    # Reload the document, determining if it's embedded or not and what;Fi[@-\I"svar = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));FI"end;FI"out((var + ">>"));Fi[[	@Li3I"?            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[	@Oi<I"?            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[	@Ri"I"?            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end;Fi[I"var = [];FI"5var = ((var % var) == 0) ? (var) : ((var + var));F@õZI"return var;Fi[[	@˘i!I"3        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@iI"3        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[	@	iYI"3        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      ;Fi[I"when Proc then;FI"var.call;FI"	else;FI"var;Fi[[	@ijI"∑      case var
      when Symbol then
        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end;Fi[	@¬i´I"Ω        var = case var
        when Symbol then
          send(var)
        when Proc then
          var.call
        else
          var
        end
        if var and (var.size > var) then;Fi[	@˜iîI"é      
      def function(arglist)
        case var
        when Proc then
          var.call
        else
          var
        end
      end;Fi[I"var.call;FI"	else;FI"var;FI"end;Fi[[	@ikI"Æ      when Symbol then
        generate_message(var, var, var.except(*CALLBACKS_OPTIONS))
      when Proc then
        var.call
      else
        var
      end
    end
  end;Fi[	@¬i¨I""        when Symbol then
          send(var)
        when Proc then
          var.call
        else
          var
        end
        if var and (var.size > var) then
          raise(TooManyRecords, "Maximum #{limit} records are allowed. Got #{attributes_collection.size} records instead.");Fi[	@˜iïI"é      def function(arglist)
        case var
        when Proc then
          var.call
        else
          var
        end
      end
      ;Fi[@–0@—0@“0I"##;Fi[[	@ïiáI"ı      @var = false
      run_callbacks(:find)
      run_callbacks(:initialize)
      self
    end
    
    ##
    # :method: clone
    # Identical to Ruby's clone method.  This is a "shallow" copy.  Be warned that your attributes are not copied.;Fi[	@KiXI"–      
      # A reference to +self+
      def function(arglist)
        self
      end
      
      ##
      # Recursively get all namespaces from this node and its subtree and
      # return them as a hash.;Fi[	@Ki†I"…          (decorators(XML::Node) << Nokogiri::Decorators::Slop)
          decorate!
        end
        self
      end
      
      ##
      # Apply any decorators to +node+
      def function(arglist);Fi[@‘7I"	else;FI"	true;FI"end;Fi[[	@ùitI"Ω        when :destroy then
          inverse_updates_counter_cache?(through_reflection).!
        when :nullify then
          false
        else
          true
        end
      end
      ;Fi[	@üiπI"∫        else
          if ["false", "FALSE", "f", "F", false].include?(peek) then
            shift
            false
          else
            true
          end
        end
      else;Fi[	@ÉifI"–  def function(arglist)
    if user and user.blocks.where(:person_id => (person_id)).exists? then
      (errors[:base] << "Cannot connect to an ignored user")
      false
    else
      true
    end
  end
end;Fi[@è7I" @var = file_name.underscore;FI" @var = plugin_name.titleize;FI"$@var = "plugins/#{plugin_name}";Fi[[	I"Mdata//redmine_proj/generators/redmine_plugin/redmine_plugin_generator.rb;TiI"–  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
  end
  ;Fi[	I"cdata//redmine_proj/generators/redmine_plugin_controller/redmine_plugin_controller_generator.rb;TiI"Ï  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = controller.camelize
  end;Fi[	@ÄiI"˙  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = model.camelize
    @var = @var.tableize;Fi[@è7I"@var = [];FI"end;FI" ;Fi[[	@ãi%I"ñ      end
      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist)
        if block_given? then;Fi[	@>iI"£        INDENT = "  "
        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          super;Fi[	@HiI"Á    module Formatter
      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist)
          @var.puts("Profiling enabled.");Fi[@è7I"@var = false;FI"end;FI" ;Fi[[	@ÖiI"É      end
      
      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function
      ;Fi[	@ñiI"~    end
    
    def function(arglist)
      super
      @var = false
    end
    
    def function(arglist)
      if var then;Fi[	@ÿiÿI"—    
    # Resets callback tracking
    def function(arglist)
      super
      @var = false
    end
    
    # Resets the event attribute so it can be re-evaluated if attempted again
    def function(arglist);Fi[@{K@õe@úeI" var = remote_path_for(@var);Fi[[	@™i8I"Ô        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[	@√i,I"˘        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("mkdir -p '#{remote_path}'");Fi[	@»i*I"Ô        end
      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var);Fi[@‡"@·"@‚"I"	####;Fi[[	@ciZI"        else
          add_child_node(var)
        end
        var
      end
      
      ####
      # Replace this Node with +node_or_tags+.
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@cirI"˝        else
          replace_node(var)
        end
        var
      end
      
      ####
      # Swap this Node for +node_or_tags+
      # +node_or_tags+ can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a string containing markup.;Fi[	@ciËI"#          var = Nokogiri::HTML::DocumentFragment.parse(var)
          var = var.children
        end
        var
      end
      
      ####
      # Set the Node's content to a Text node containing +string+. The string gets XML escaped, not interpreted as markup.
      def function(arglist);Fi[I"+#     include ActiveModel::Validations;FI"#;F@ËUI"&#     validates_presence_of :name;Fi[[	@ï7iªI"∑    # error messages.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@ï7iÃI"¿    # added otherwise +false+.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[	@ï7iÛI"¡    # added, +false+ otherwise.
    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #;Fi[@‡"@·"@‚"I"J# Turn the object from the ruby type we deal with to a Mongo friendly;Fi[[	@L	ikI"           var = (var[var] or var[var.to_i])
          var = var
        end
        var
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #;Fi[	@Z	i¯I"…        #
        # @since 3.0.0
        def function(arglist)
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #;Fi[	@}	i3I"          if Mongoid::Config.use_activesupport_time_zone? then
            var = var.in_time_zone(Mongoid.time_zone)
          end
          var
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #;Fi[@<I"#;FI"#       event :park do;FI",#         transition :idling => :parked;Fi[[	@&iDI"˘    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@&ivI"˘    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[	@=<i°I"    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end;Fi[I"var = nil;FI"end;FI"end;FI"'var = nil if var and var.to_bool.!;Fi[[	@$i˝I"·      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var);Fi[	@$iI"	      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then
        var = var.first.value;Fi[	@$iI".      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first)
      LinearGradient.new(var, send(:color_stops, *var));Fi[@`oI"	else;FI"&if list_of_color_stops?(var) then;FI"var = (var.value + var);Fi[[	@$i˘I"⁄    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@$iI"È      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[	@$iI"⁄    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end;Fi[@OK@PK@íWI"4# Establishes a connection to the remote server;Fi[[	@™i$I"ü        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      #
      # Note:;Fi[	@√i I"Û        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      # and yields the Net::SSH connection.
      # Net::SCP will use this connection to transfer backups;Fi[	@»i I"        @var = path.sub(/^\~\//, "")
      end
      
      private
      
      ##
      # Establishes a connection to the remote server
      def function(arglist)
        Net::SFTP.start(ip, username, :password => (password), :port => (port)) do |arglist|;Fi[I"&#     validates_presence_of :name;FI"#   end;FI"#;FI"#   person = Person.new;Fi[[	@ï7iæI"*    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false
    #   person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:["can't be blank"]}>;Fi[	@ï7iœI"‹    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.valid? # => false;Fi[	@ï7iˆI"›    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = ''
    #   person.invalid? # => true;Fi[@OK@PK@∏ I"# do nothing;Fi[[	@KicI"Ö          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
        ;Fi[	@LiEI"õ      @var ||= [name, version, source, platform, dependencies].hash
    end
    
    private
    
    def function(arglist)
      # do nothing
    end
    ;Fi[	@CiI"Ü          end
        end
        
        private
        
        def function(arglist)
          # do nothing
        end
      end;Fi[@\X@]XI"B# Only runs validations on the action if using <tt>:save</tt>;FI"def function(arglist);Fi[[	@ûiI"π        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@∫iI"Õ        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[	@¬iI"π        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end;Fi[I"#:nodoc:;FI"def function(arglist);F@ΩXI"
begin;Fi[[	@Âi#I"‘        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}")
            FileUtils.rm(var) if File.exist?(var));Fi[	@Îi∆I"ı        s3_interface.buckets.create(bucket_name)
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("saving #{path(style)}")
            var = (@var[var] or @var[:default]);Fi[	@Îi‚I"€        @var = {}
      end
      
      #:nodoc:
      def function(arglist)
        @var.each do |arglist|
          begin
            (log("deleting #{path}")
            s3_bucket.objects[var.sub(/^\//, "")].delete);Fi[@‹.I"&out(("/Subtype /" + var["type"]));FI"out("/FirstChar 32");FI"out("/LastChar 255");Fi[[	@LiI"`          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[	@OiI"`          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[	@RiI"`          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[@‹.I"var = var["name"];FI"out(("/BaseFont /" + var));FI"$if (var["type"] == "core") then;Fi[[	@LiI"&      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[	@OiI"&      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[	@Ri˝I"&      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then;Fi[@‹.I">Cell(var, var, var[var, (var - var)], 0, 2, "", var, var);FI"6var = (var[var].chr == " ") ? ((var + 1)) : (var);FI"end;Fi[[	@Li◊I"G          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@OiﬂI"9          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@Ri∆I"G          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[@‹.I"super(var, var, var, var);FI"end;FI"end;Fi[[	@LißI"±  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist);Fi[	@Oi¢I"≥  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist);Fi[	@RiñI"±  def function(arglist)
    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist);Fi[@‹.@≈`I"@var = var;F@Tli[[	@LiöI"‡    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@OiïI"‡    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[	@RiâI"‡    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2);Fi[@‹.I"<Cell(var, var, var[var, (var - var)], var, 2, var, var);F@{VI"end;Fi[[	@LiâI"c        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@OiÉI"U        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[	@Ri}I"c        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var;Fi[@≥Y@¥Y@πjI"^#   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,;Fi[[	@ï7i+I"’      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@ï7ieI"’      # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[	@*i+I"¨      #   and <tt>:update</tt>.
      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+;Fi[@¥Y@πj@ÈoI"L#   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;Fi[[	@ï7i,I"ù      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@ï7ifI"ù      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[	@*i,I"ù      # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.;Fi[I"L#   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The;FI"P#   method, proc or string should return or evaluate to a +true+ or +false+;FI"#   value.;FI"def function(arglist);Fi[[	@ï7i/I"      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var)
      end;Fi[	@ï7iiI"	      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!
        if var.key?(:on) then;Fi[	@*i/I"      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var))
      end;Fi[I"I# * <tt>:unless</tt> - Specifies a method, proc or string to call to;F@Èo@Úo@¸oi[[	@ï7i-I"h      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@ï7igI"h      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[	@*i-I"h      #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist);Fi[@Èo@Úo@¸oI"#   value.;Fi[[	@ï7i.I"^      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(BlockValidator, _merge_attributes(var), &var);Fi[	@ï7ihI"<      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        var = var.extract_options!;Fi[	@*i.I"]      #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
      #   proc or string should return or evaluate to a +true+ or +false+ value.
      # * <tt>:unless</tt> - Specifies a method, proc or string to call to
      #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
      #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
      #   method, proc or string should return or evaluate to a +true+ or +false+
      #   value.
      def function(arglist)
        validates_with(AssociatedValidator, _merge_attributes(var));Fi[I"k#       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee);FI"#     end;FI"#   end;FI"#;Fi[[	@ï7iBI"6      #     validate :must_be_friends
      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #
      # With a block which is passed with the current record to be validated:
      #;Fi[	@ï7iPI"#      #     end
      #
      #     def must_be_friends
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #
      # Or with a block where self points to the current record to be validated:
      #;Fi[	@ï7iZI"?      #     include ActiveModel::Validations
      #
      #     validate do
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
      #     end
      #   end
      #
      # Options:
      # * <tt>:on</tt> - Specifies the context where this validation is active;Fi[@‹.I"-super(var, var, var, var, var, var, var);FI"end;FI"end;Fi[[	@LiSI"”  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist);Fi[	@OiHI"’  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist);Fi[	@RiBI"”  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist);Fi[@RZI"(var << var);FI"end;FI"end;Fi[[	@√iKI"T      (var << ("#{utility(:tar)} #{tar_args} -cPf - " + "#{paths_to_exclude} #{paths_to_package}"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end
      (var << "cat > '#{File.join(archive_path, "#{name}.#{archive_ext}")}'")
      var.run;Fi[	@fi=I"        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, dump_filename)}.#{dump_ext}'")
        var.run;Fi[	@ii=I"        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end
        (var << "cat > '#{File.join(@dump_path, name)}.#{dump_ext}'")
        var.run;Fi[@‹.I"var = (var + 1000);FI"var = (var + 2);FI"end;Fi[[	@LiHI"’      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000);Fi[	@Oi<I"≈        if (var >= 161) and (var <= 223) then
          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end
    end;Fi[	@Ri7I"’      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000);Fi[@=I":#   #      #<Pet id: 2, name: "Spook", person_id: 1>,;TI"=#   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>;TI"#   #    ];Ti[[	@îiLI"9      # Array#select.
      #
      #   person.pets.select { |pet| pet.name =~ /oo/ }
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name) { |pet| pet.name =~ /oo/ };Ti[	@îi£I"N      #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #
      #   person.pets.last(2)
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   another_person_without.pets         # => [];Ti[	@îi◊I"S      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
      #
      #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 3;Ti[@‹.I"return super(var);FI"end;FI"end;Fi[[	@Li9I"™  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist);Fi[	@Oi)I"¨  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist);Fi[	@Ri(I"™  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist);Fi[@‹.I"%super(absolutify_local_url(var));FI"end;FI"end;Fi[[	@£ipI"¡    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@£iyI"¡    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[	@£i}I"¡    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist);Fi[I"#   #    ];FI"#;TI"#   person.pets.delete_all;TI"#   # => [;Ti[[	@îiBI"ä      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îicI"ä      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îi|I"ä      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@;I"
super;FI"end;FI" ;Fi[[	@ï7i≥I"·    
    # Clean the +Errors+ object if instance is duped.
    def function(arglist)
      @var = nil
      super
    end
    
    # Returns the +Errors+ object that holds all information about attribute
    # error messages.;Fi[	@ùi‡I"      @var = var.inclusions.dup
      @var = var.scoping_options
      @var = var.documents.dup
      @var = nil
      super
    end
    
    # Used for chaining +Criteria+ scopes together in the for of class methods
    # on the +Document+ the criteria is for.;Fi[	@ iáI"ß        # Clean up translations
        def function(arglist)
          @var = nil
          @var = nil
          super
        end
        
        protected
        ;Fi[@‹.I"/render(:nothing => (true), :status => 404);FI"end;FI"end;Fi[[	@i4I"Ï    if var.present? then
      var = OEmbedPresenter.new(var, params.slice(:format, :maxheight, :minheight))
      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist);Fi[	@i#I"Ú    @var = Person.find_by_guid_and_closed_account(params[:guid], false)
    if @var.present? and @var.local? then
      render("publics/hcard")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist);Fi[	@ıiïI"¡    var = User.find_by_username(var)
    if var.present? then
      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist);Fi[@‹.I"clean_url(var);FI"end;FI"end;Fi[[	@Øi(I"Ω      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@ØiAI"±      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[	@ØitI"’      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  ;Fi[@‹.@mo@noI"var = nil;Fi[[	@$i˙I"       if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@$iI"       if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[	@$iI"       if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end;Fi[@;@;@;I"private;Fi[[	@≠i2I"ë    def function(arglist)
      @var = columns.dup
      @var = rows.dup
      @var = nil
    end
    
    private
    
    def function(arglist);Fi[	@äimI"ë      def function(arglist)
        @var = var
        yield
        @var = nil
      end
      
      private
      
      def function(arglist);Fi[	@iÉI"Å      end
      
      def function(arglist)
        @var = nil
      end
      
      private
      
      def function(arglist);Fi[@‹.I"	@var;FI"end;FI"end;Fi[[	@iTI"í        if var then
          @var = var
          @var = var
        else
          @var
        end
      end
      
      def function(arglist);Fi[	@i=I"›        def function(arglist)
          if @var.nil? then
            File.exist?("./Gemfile") and gem_available?("bundler")
          else
            @var
          end
        end
        
        def function(arglist);Fi[	@’iëI"™        else
          @var.call
        end
      else
        @var
      end
    end
    
    # Determines whether this state matches the given value.  If no matcher is;Fi[@‹.I"var = "";F@ÑnI"6var = (var + "R") unless var.to_s.index("R").nil?;Fi[[	@LigI"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[	@Oi\I"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[	@RiVI"        var = "LTRB"
        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end;Fi[@;I" ;FI"@var = nil;FI" ;Fi[[	@ïdiI"xclass Net::HTTP::Persistent::SSLReuse < Net::HTTP
  @var = false
  
  @var = nil
  
  @var = nil
  
  @var = nil
  ;Fi[	@ïdi
I"G  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  @var = nil
  ;Fi[	@ïdiI"Y  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  def function(arglist)
    super;Fi[I"ensure;FI"@var = nil;FI"end;FI"end;Fi[[	@
iwI"”          var[:prepend] ? (@var = [@var].|(@var)) : (@var = @var.|([@var]))
          yield if block_given?
          return @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist);Fi[	@{i7I"Ä        (@var = nil
        yield
        @var)
      ensure
        @var = nil
      end
    end
    
    def function(arglist);Fi[	@ixI"´        begin
          (@var = var
          yield)
        ensure
          @var = nil
        end
      end
      
      # parses a manifest file which is a ruby script;Fi[@∆pI"@var = var;FI"end;FI"end;Fi[[	@
i†I"ä      begin
        (@var, var = var, @var
        yield)
      ensure
        @var = var
      end
    end
    
    def function(arglist);Fi[	@<iI"≠            var.children.each { |arglist| compile(var) }
          end
        end)
      ensure
        @var = var
      end
    end
    
    if (RUBY_VERSION < "1.9") then;Fi[	@=i4I"É          (@var = true
          var = @var
          yield)
        ensure
          @var = var
        end
      end
    end
    ;Fi[@‹.I"
yield;FI"end;FI"end;Fi[[	@õi%I"À        ensure
          var[:available_queries_for_explain] = nil
        end
      else
        yield
      end
    end
    
    # Relation#explain needs to be able to collect the queries regardless of;Fi[	@ii9I"÷        init
        if self.!=(var) and var.respond_to?(:with_visitor) then
          var.with_visitor(var) { |arglist| yield }
        else
          yield
        end
      end
      
      def function(arglist);Fi[	@ÿi≠I"g          yield
          success?
        end
      else
        yield
      end
    end
  end
  ;Fi[@‹SI"var;FI"end;FI" ;Fi[[	@6iI"˙      def function(arglist)
        var = ColumnDefinition.new(var, var, var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        var = columns.detect { |arglist| (var.type == :primary_key) };Fi[	@îi%I"≥              @var = var
            end
          end
          @var[var] = var
          var
        end
        
        def function(arglist)
          if var = @var[var] then;Fi[	@=iNI"˙        var = constantize("Cucumber::#{ext.capitalize}Support::#{ext.capitalize}Language")
        var = var.new(@var)
        (@var << var)
        @var[var] = var
        var
      end
      
      def function(arglist)
        log.debug("Code:\n");Fi[@∫E@ªEI"end;FI" ;Fi[[	@xiSI"µ            end
            @var[var] = var
          end
          @var[var]
        end
      end
      
      def function(arglist)
        define_method("#{name}=") do |arglist|;Fi[	@ài I"ª        if table_exists?(var) then
          @var[var]
          @var[var]
          @var[var]
        end
      end
      
      # Get the columns for a table
      def function(arglist);Fi[	@üi†I"¬      if var = no_or_skip?(var) then
        (@var[var] or @var["--#{match}"])
      else
        @var[var]
      end
    end
    
    # Check if the given argument is actually a shortcut.
    #;Fi[@‹.@›.@ﬁ.I"var;Fi[[	@Œi/I"∞          when :stderr then
            var = $stderr
            $stderr = var.unwrap!
          else
            # do nothing
          end
          var
        end
        ;Fi[	@!iJI"≥        when Twitter::List then
          var[:list_id] = var.id
          merge_owner!(var, var.user)
        else
          # do nothing
        end
        var
      end
      ;Fi[	@DiëI"Ò          var[[var, "screen_name"].compact.join("_").to_sym] = var
        when Twitter::User then
          var[[var, "user_id"].compact.join("_").to_sym] = var.id
        else
          # do nothing
        end
        var
      end
      ;Fi[@‹.@›.@ﬁ.I"Evar = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var);Fi[[	@Ñi7I"ﬂ          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var)
        send_message(var)
      end;Fi[	@âiOI"          ["Warning", warning_color]
        when :failure then
          ["Failure", failure_color]
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var)
        send_message(var, var)
      end;Fi[	@îi?I"ﬂ          "Failure"
        when :warning then
          "Warning"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var)
        send_message(var)
      end;Fi[@˛?I"	true;FI"end;FI" ;Fi[[	@ÀiZI"9    def function(arglist)
      paranoid_collection.find(atomic_selector).update("$unset" => ({ paranoid_field => (true) }))
      attributes.delete("deleted_at")
      @var = false
      true
    end
    
    # Returns a string representing the documents's key suitable for use in URLs.
    def function(arglist);Fi[	@(i®I"     def function(arglist)
      flush_deletes unless @var[:keep_old_files]
      flush_writes
      @var = false
      true
    end
    
    # Clears out the attachment. Has the same effect as previously assigning
    # nil to the attachment. Does NOT save. If you wish to clear AND save,;Fi[	@i{I"√          end
          self.custom_values = var
          custom_values.each(&:save)
          @var = false
          true
        end
        
        def function(arglist)
          @var = nil;Fi[@¶R@ßRI"#;FI"*#     def initialize(attributes = {});Fi[[	@=<i˘I"     # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...
    #       super();Fi[	@=<iI"‹    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...
    #       initialize_state_machines;Fi[	@=<i#I"    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       state nil, :idling
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       @state = 'idling'
    #       initialize_state_machines(:static => :force) do;Fi[@	)@VI"Eunless (var.options[:user_id] or var.options[:screen_name]) then;FI"7merge_user!(var.options, (var.pop or screen_name));Fi[[	@Ai∞I"Ó      #   @example Return the specified user's profile banner
      #     Twitter.profile_banner('sferik')
      #     Twitter.profile_banner(7505382)  # Same as above
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::ProfileBanner, :get, "/1.1/users/profile_banner.json", var.options);Fi[	@DiI"Ä      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::User, var, var, var.options);Fi[	@Di_I"Å      # @param args [Array]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(var, var, var, var, var.options, var);Fi[@	)@V@ÇT@ÉTi[[	@!iHI"∞      #     Twitter.list_timeline('sferik', 8863586)
      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end;Fi[	@!iI"n      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end;Fi[	@!iI"b        object_from_response(Twitter::List, var, var, var.options)
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end;Fi[@	)I"9@var = Array(@var[:target_objects]).map do |arglist|;FI"%Twitter::Tweet.fetch_or_new(var);FI"end;Fi[[	@iI"      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@iI"      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[	@iI"Ò      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      ;Fi[I"var[var];FI"end;FI" ;FI"def function(arglist);Fi[[	@ÇiI"       
      def function(arglist)
        var = alias_tracker.connection.schema_cache.columns_hash[var]
        var[var]
      end
      
      def function(arglist)
        var = alias_tracker.connection.substitute_at(var, var.bind_values.length)
        var.bind_values += [[var, var]];Fi[	@i$I"À    
    def function(arglist)
      var = initialize_store_attribute(var)
      var[var]
    end
    
    def function(arglist)
      var = initialize_store_attribute(var)
      if var.!=(var[var]) then;Fi[	@€i¨I"›      def function(arglist)
        var = invoke_return_block(*var, &var)
        var = [@var, (var.size - 1)].min
        var[var]
      end
      
      def function(arglist)
        @var = var.clone
        @var = true;Fi[@îR@ïRI"var = @var["cw"];F@Hmi[[	@LiYI"Œ  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@OiNI"Œ  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[	@RiHI"Œ  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "");Fi[@	)@hI"end;FI" ;Fi[[	@iI"      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection containing the followed user
      #;Fi[	@iI"$      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # A collection of lists that were added to
      #;Fi[	@iI"      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      
      # The user who mentioned a user
      #;Fi[@îR@ïRI"if (var > 0) then;FI"@var = 0;Fi[[	@UiÓI"ß  
  def function(arglist)
    if self.BreakThePage?(var) then
      var = @var
      var = @var
      if (var > 0) then
        @var = 0
        out("0 Tw")
      end;Fi[	@ciÃI"Í    var = @var
    if ((@var + var) > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end;Fi[	@ciKI"‚    var = @var
    if (@var > @var) and (@var.! and AcceptPageBreak) then
      if @var[(@var + 1)].nil? then
        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end;Fi[@îRI"var = @var["cw"];F@Hm@Imi[[	@LiZI"›  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@OiOI"›  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[	@RiII"›  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length;Fi[@	)I" @var.human_name(@var.class);FI"end;FI" ;Fi[[	@„itI"Â    end
    
    # The human-readable name of the event that triggered the transition
    def function(arglist)
      @var.human_name(@var.class)
    end
    
    # The state name *before* the transition
    def function(arglist);Fi[	@„i~I"€    end
    
    # The human-readable state name *before* the transition
    def function(arglist)
      @var.human_name(@var.class)
    end
    
    # The new state name *after* the transition
    def function(arglist);Fi[	@„içI"Ù    end
    
    # The new human-readable state name *after* the transition
    def function(arglist)
      @var.human_name(@var.class)
    end
    
    # Does this transition represent a loopback (i.e. the from and to state
    # are the same);Fi[@	)I"Rvar.class.state_machines.transitions(var, action).perform { |arglist| yield };FI"end;FI" ;Fi[[	@ûiDI"9      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@∫i=I"9      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[	@¬iAI"9      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute;Fi[@	)I"(action == :save);FI"end;FI" ;Fi[[	@ûiI"ı      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@∫iI"ı      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[	@¬iI"ı      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist);Fi[@	)I"#if (action_hook == :save) then;FI"Gowner_class.set_callback(:save, :around, self, :prepend => (true));FI"	else;Fi[[	@ûi;I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@∫i4I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[	@¬i8I"      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end;Fi[@	)@îqI"Iowner_class.set_callback(:save, :after, "value", :prepend => (true));FI"end;Fi[[	@óigI"I        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end;Fi[	@µiOI"A        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end;Fi[	@ΩiI"f        def function(arglist)
          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end;Fi[@	)I"if var.errors.empty? then;FI""Transition halted";FI"	else;Fi[[	@îi'I"=      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end;Fi[	@≤i I"D      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          var = []
          var.errors.each_pair do |arglist|;Fi[	@ i$I"=      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end;Fi[@	)I"var = max_value;FI"var = min_value;FI"var = (var - var);Fi[[	@˘iI"ﬂ        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[	@iI"÷      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[	@	iQI"Ï        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var);Fi[@Ä;I"@var = [];FI"end;FI" ;Fi[[	@ØioI"{  
  def function(arglist)
    @var = var
    @var = []
    @var = []
  end
  
  def function(arglist)
    var = which(var);Fi[	@ÃiI"€      class ValidateAttachmentContentTypeMatcher
        def function(arglist)
          @var = var
          @var = []
          @var = []
        end
        
        def function(arglist)
          @var = var.flatten;Fi[	@Çi∞I"L    # where you either are re-using an existing state machine implementation
    # or are subclassing machines.
    def function(arglist)
      @var = []
      @var = []
    end
    
    # Draws a representation of this event on the given graph.  This will
    # create 1 or more edges on the graph for each branch (i.e. transition);Fi[@	)I"@var[:fields];FI"end;FI" ;Fi[[	@˘iI"î      
      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value;Fi[	@i$I"ó        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        (var / -2.0);Fi[	@	iGI"ê        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super;Fi[@	)I"Jif (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then;F@±eI"	else;Fi[[	@UiI"    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end;Fi[	@Ui"I"    out(@var) if (@var > 0)
  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end;Fi[	@ci I"R  	# @since 1.3
  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end;Fi[@	)I"out("/Subtype /Type0");FI"?out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]));FI"'out(("/Encoding /" + var["CMap"]));Fi[[	@Li=I"ı    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[	@OiFI"ı    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[	@Ri,I"ı    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>");Fi[I"var[var] = var[var];FI"var[var] = 1;FI"var = 0;FI"	else;Fi[[	@ôi
I"ˇ        var = []
        var.each_with_index do |arglist|
          if (var > var[var]) then
            var[var] = var[var]
            var[var] = 1
            var = 0
          else
            if (var < var[var]) then
              var[var] = var[var];Fi[	@ôiI"÷            var = 0
          else
            if (var < var[var]) then
              var[var] = var[var]
              var[var] = 1
              var = 0
            else
              var[var] = 0
            end;Fi[	@ôi'I"4            if (var[var] == 0) then
              var[var] = (var * var)
              if (var[var] < var[var]) then
                var[var] = var[var]
                var[var] = 1
                var = 0
              else
                if (var[var] > var[var]) then
                  var[var] = var[var];Fi[@	)I",AddCIDFont(var, "", var, var, var, var);FI"9AddCIDFont(var, "B", (var + ",Bold"), var, var, var);FI";AddCIDFont(var, "I", (var + ",Italic"), var, var, var);Fi[[	@LiI"ö    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[	@OiI"ö    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[	@RiI"ö    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end;Fi[@$@@%@I";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;TI">#   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[[	@îiøI"'      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi˜I"'      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[	@îi/I"'      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #;Ti[@	)I"$if @var.respond_to?(:call) then;FI"#@var.call(attachment.instance);FI"	else;Fi[[	@Úi(I"b    # There is an important change of interface here: a style rule can set its own processors
    # by default we behave as before, though.
    # if a proc has been supplied, we call it here
    def function(arglist)
      if @var.respond_to?(:call) then
        @var.call(attachment.instance)
      else
        (@var or attachment.processors)
      end;Fi[	@Úi:I"‘      whiny.!.!
    end
    
    def function(arglist)
      if @var.respond_to?(:call) then
        @var.call(attachment.instance)
      else
        (@var or attachment.send(:extra_options_for, name))
      end;Fi[	@ÚiBI"⁄      end
    end
    
    def function(arglist)
      if @var.respond_to?(:call) then
        @var.call(attachment.instance)
      else
        (@var or attachment.send(:extra_source_file_options_for, name))
      end;Fi[@	)I"Pvar = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil);FI"3var = var.last.is_a?(Hash) ? (var.pop) : (nil);FI" var = NodeSet.new(document);Fi[[	@#:iFI"Ω      #
      # For more information see Nokogiri::XML::Node#css and
      # Nokogiri::XML::Node#xpath
      def function(arglist)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document)
        var.each do |arglist|
          var = (var + send((var =~ /^(\.\/|\/|\.\.|\.$)/ ? (:xpath) : (:css)), *(var + [var, var]).compact));Fi[	@#:iWI"n      # Search this NodeSet for css +paths+
      #
      # For more information see Nokogiri::XML::Node#css
      def function(arglist)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document)
        each do |arglist|
          var = var.document;Fi[	@#:ikI"™      # Search this NodeSet for XPath +paths+
      #
      # For more information see Nokogiri::XML::Node#xpath
      def function(arglist)
        var = [Hash, String, Symbol].include?(var.last.class).! ? (var.pop) : (nil)
        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document)
        each { |arglist| var = (var + var.xpath(*(var + [var, var].compact))) }
        document.decorate(var);Fi[@	)I"if Nokogiri.jruby? then;FI"5var = var.first.is_a?(Hash) ? (var.shift) : ({});FI"if var[:save_with].! then;Fi[[	@Ni+I"ç      ###
      # Convert this DocumentFragment to html
      # See Nokogiri::XML::NodeSet#to_html
      def function(arglist)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var[:save_with].! then
            var[:save_with] = Node::SaveOptions::NO_DECLARATION.|(Node::SaveOptions::NO_EMPTY_TAGS).|(Node::SaveOptions::AS_HTML)
          end;Fi[	@Ni9I"ê      ###
      # Convert this DocumentFragment to xhtml
      # See Nokogiri::XML::NodeSet#to_xhtml
      def function(arglist)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var[:save_with].! then
            var[:save_with] = Node::SaveOptions::NO_DECLARATION.|(Node::SaveOptions::NO_EMPTY_TAGS).|(Node::SaveOptions::AS_XHTML)
          end;Fi[	@#:iÙI"`      
      ###
      # Convert this NodeSet to HTML
      def function(arglist)
        if Nokogiri.jruby? then
          var = var.first.is_a?(Hash) ? (var.shift) : ({})
          if var[:save_with].! then
            var[:save_with] = Node::SaveOptions::NO_DECLARATION.|(Node::SaveOptions::NO_EMPTY_TAGS).|(Node::SaveOptions::AS_HTML)
          end;Fi[@	)I"J"#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>";FI"end;FI"end;Fi[[	@@iI"«      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@WiI"«      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ZiI"ª        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[@	)I" var = [var.first, var.last];FI"var;FI"end;Fi[[	@
iÿI"ï        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@
i›I"ï        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist);Fi[	@
i‚I"ì        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted;Fi[@∏<I"#   #    ];TI"#;T@ipi[[	@îiAI"^      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îibI"^      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[	@îi{I"^      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;Ti[@Fp@GpI"#   #    ];TI"#;Ti[[	@îiMI"4      #
      #   person.pets.select { |pet| pet.name =~ /oo/ }
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.select(:name) { |pet| pet.name =~ /oo/ }
      #   # => [;Ti[	@îi§I"7      #
      #   person.pets.last(2)
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   another_person_without.pets         # => []
      #   another_person_without.pets.last    # => nil;Ti[	@îiÿI"7      #
      #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
      #   # => [
      #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.size  # => 3
      #   person.pets.count # => 3;Ti[@	)I"/var = Node.new(:CONDITIONAL_SELECTOR, var);FI"var;FI"end;Fi[[	@
ijI"¢        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      # reduce 13 omitted;Fi[	@
ipI"≤      end
      
      # reduce 13 omitted
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist);Fi[	@
iuI"§        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist);Fi[@ipI"#   # => [;TI"A#   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,;TI";#   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[[	@îiDI"[      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îieI"[      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi~I"[      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[I"?#   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>];TI"#;T@0aI"#   person.pets;Ti[[	@îiºI"      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îiÙI"      #   #    ]
      #
      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[	@îi,I"      #   #    ]
      #
      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,;Ti[@0aI"#   person.pets;TI"#   # => [;T@ri[[	@îiæI"I      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îiˆI"I      #   person.pets.delete(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[	@îi.I"J      #   person.pets.destroy(Pet.find(1))
      #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
      #
      #   person.pets.size # => 2
      #   person.pets
      #   # => [
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ];Ti[@	)I"prepare do |arglist|;FI"if document[field] then;FI"var = document.send(field);Fi[[	@
iI".        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then
              var = document.send(field)
              (value > 0) ? (var.pop) : (var.shift)
              execute("$pop");Fi[	@
iI"        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then
              var = document.send(field)
              var.delete(value)
              execute("$pull");Fi[	@
iI"<        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then
              var = document.send(field)
              var.delete_if { |arglist| value.include?(var) }
              execute("$pullAll");Fi[@	)I"$return image_url if (var == "");FI"4if (var.nil? or var.match(/^https?:\/\//)) then;FI"super(var);Fi[[	@£ilI"    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@£iuI"¡    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[	@£i~I"¡    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var));Fi[@	)I"+self.author = Webfinger.new(var).fetch;FI"end;FI" ;Fi[[	@Äi;I"π    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then;Fi[	@ài.I"ñ    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false;Fi[	@çi3I"ß    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid;Fi[@ôg@ögI"end;FI"end;Fi[[	@´inI"≠          if var.key?(locking_column) and lock_optimistically then
            var[locking_column] ||= 0
          end
          var)
        end
      end
    end
  end
end;Fi[	@mi4I"ç      @var ||= (var = host
      var = "#{user}@#{s}" if user
      var = "#{s}:#{port}" if port and port.!=(22)
      var)
    end
  end
end;Fi[	@≈iI"≥      def function(arglist)
        @var ||= (var = Devise.mappings[scope]
        raise("Could not find mapping for #{scope}") unless var
        var)
      end
    end
  end
end;Fi[@ôg@ög@õgI"##;Fi[[	@xi4I"        if var.keys.count.!=(var.keys.count) then
          Logger.warn("Duplicate public key identifiers were detected in #keys.")
        end
        var)
      end
      
      ##
      # Cleans a public key identifier.
      # Strip out all spaces, upcase non-email identifiers,;Fi[	@“iiI"@            local_hashes.lines.map { |arglist| LocalFile.new(@var, var) }.compact.each do |arglist|
              var.merge!(var.relative_path => (var))
            end
            var)
          end
          
          ##
          # Returns a String of file paths and their md5 hashes.
          def function(arglist);Fi[	@“i|I"h            @var.files.all(:prefix => (@var)).each do |arglist|
              var.merge!(var.key.sub("#{@remote_base}/", "") => (var))
            end
            var)
          end
          
          ##
          # Performs a sync operation on a file. When mirroring is enabled
          # and a local file has been removed since the last sync, it will also;Fi[@	)I" self.author.diaspora_handle;FI"end;FI" ;Fi[[	@Äi7I"˛  after_destroy { |arglist| self.parent.update_comments_counter }
  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch;Fi[	@ài*I"¥    (self.participants - [self.author])
  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch;Fi[	@çi/I"¡  
  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch;Fi[I"[var, var];FI"end;FI"end;FI" ;Fi[[	@ViqI"Ω          else
            var = ActiveRecord::Result.new([], [])
          end
          [var, var]
        end
      end
      
      def function(arglist)
        var = execute(var, var);Fi[	@ViØI"—          var.result_metadata.free if var
          var.free_result
          var.close if var.empty?
          [var, var]
        end
      end
      
      def function(arglist)
        var = @var[:encoding];Fi[	@ÒiŸI"¡        if var and var.stores_foreign_key? then
          [var.foreign_key, var.id]
        else
          [var, var]
        end
      end
      
      # Validate an embedded document.
      #;Fi[I"	end];FI"end;FI" ;FI"def function(arglist);Fi[[	@Úi$I"ˇ              var.association(through_reflection.name).reset
            end
            [var, var]
          end]
        end
        
        def function(arglist)
          var = through_reflection.klass.unscoped
          if options[:source_type] then;Fi[	@˜imI"'      def function(arglist)
        Hash[records_by_reflection(var).map do |arglist|
          [var, var.group_by { |arglist| association_klass(var, var) }]
        end]
      end
      
      def function(arglist)
        records.group_by do |arglist|
          var = var.class.reflections[var];Fi[	@ŸiƒI"Í      Hash[var.map do |arglist|
        var = var.left.name
        [var, var.fetch(var.to_s) { |arglist| var.right }]
      end]
    end
    
    def function(arglist)
      @var ||= where_values_hash.merge(create_with_value)
    end;Ti[@	)I"broadcast(var);FI"end;FI" ;Fi[[	@ûiI"‹        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[	@ûi&I"¬        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var);Fi[	@ûikI"¬        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) };Fi[@	)I"@var.language;FI"end;FI" ;Fi[[	@Éi@I"‘        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      
      class ExampleRow < Cells
        class InvalidForHeaderRowError < NoMethodError;Fi[	@Éi®I"∂          "| #{@cells.collect { |c| c.value }.join(" | ")} |"
        end
        
        def function(arglist)
          @var.language
        end
        
        private
        ;Fi[	@êiXI"¸        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      
      def function(arglist)
        @var ||= file_colon_line.gsub(/\//, "_").gsub(/\./, "_").gsub(/:/, "_");Fi[@Kg@LgI"end;FI" ;Fi[[	@i,I"„      def function(arglist)
        super.tap do |arglist|
          @var = changes
          @var.clear
        end
      end
      
      # <tt>reload</tt> the record and clears changed attributes.
      def function(arglist);Fi[	@i4I"ñ      def function(arglist)
        super.tap do |arglist|
          @var.clear
          @var.clear
        end
      end
      
      private
      ;Fi[	@(i‚I"∏            var.disconnect!
          end
          @var = []
          @var.clear
        end
      end
      
      # Clears the cache which maps classes.
      def function(arglist);Fi[@	)I"@var.accept_hook?(var);FI"end;FI" ;Fi[[	@uiCI"¥        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init;Fi[	@Éi!I"ù        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags;Fi[	@ÉiÉI"≠          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var);Fi[@	)I"$p4_sync(var, var, p4sync_flags);FI"end;FI" ;Fi[[	@{iI"Â        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@{iI"Â        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so;Fi[	@{i%I"∂        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.
        def function(arglist);Fi[@	)I"var = var[:channel][:host];FI"2logger.info("[#{host} :: #{stream}] #{text}");FI"case var;Fi[[	@li{I"£        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}")
          case var
          when /\bpassword.*:/i then
            unless var = variable(:scm_password) then;Fi[	@qi8I"•        # Determine response for SCM prompts
        # user/pass can come from ssh and http distribution methods
        # yes/no is for when ssh asks you about fingerprints
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}")
          case var
          when /^user:/mi then
            if var = (variable(:scm_username) or variable(:scm_user)) then;Fi[	@ÇiHI"î        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,
        # etc. are handled here.
        def function(arglist)
          var = var[:channel][:host]
          logger.info("[#{host} :: #{stream}] #{text}")
          case var
          when /\bpassword.*:/i then
            "#{scm_password_prompt}\n";Fi[@a@a@a@˛ai[[	@xi'I"9    # expand %something%, this `something` should be a public method in the class calling
    # #directory. If a method is private, Thor stack raises PrivateMethodEncodedError.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #                If :recursive => false, does not look for paths recursively.
    #                If :mode => :preserve, preserve the file mode from the source.;Fi[	@Çi*I"ï    # Links the file from the relative source to the relative destination. If
    # the destination is not given it's assumed to be equal to the source.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples;Fi[	@Çi`I"å    # at the relative destination. If the destination is not given it's assumed
    # to be equal to the source removing .tt from the filename.
    #
    # ==== Parameters
    # source<String>:: the relative path to the source root.
    # destination<String>:: the relative path to the destination root.
    # config<Hash>:: give :verbose => false to not log the status.
    #
    # ==== Examples;Fi[@	)I"(var.to_i + 1);FI"end;FI" ;Fi[[	@[iCI"∏        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private
        ;Fi[	@{i:I"9        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[	@ÇiAI"9        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text
        # from the SCM. Password prompts, connection requests, passphrases,;Fi[I"@var = 0;FI"end;FI" ;FI"def function(arglist);Fi[[	@ªiI"ì    class Debug
      def function(arglist)
        @var = var
        @var = 0
      end
      
      def function(arglist)
        true
      end;Fi[	@«iI"≥        @var = 0
        @var = nil
        @var = []
        @var = 0
      end
      
      def function(arglist)
        case var
        when /^image\/(png|gif|jpg|jpeg)/ then;Fi[	@‰iYI"õ      @var = 0
      @var = []
      @var = 0
      @var = 0
    end
    
    def function(arglist)
      begin
        (@var = @var = ParseNode.new(:root);Fi[@,sI"out("0 Tw");FI"end;FI"AddPage(@var);Fi[[	@ciœI"∑        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[	@ciI"‹        if @var[(@var + 1)].nil? then
          var = @var
          if (var > 0) then
            @var = 0
            out("0 Tw")
          end
          AddPage(@var)
          if (var > 0) then
            @var = var;Fi[	@ciNI"∑        var = @var
        var = @var
        if (var > 0) then
          @var = 0
          out("0 Tw")
        end
        AddPage(@var)
        @var = var
        if (var > 0) then;Fi[@	)I"@var = (@var + 1);FI"end;FI" ;Fi[[	@oiBI"ú  
  ##
  # Forces reconnection of HTTP connections.
  def function(arglist)
    @var = (@var + 1)
  end
  
  ##
  # Forces reconnection of SSL connections.;Fi[	@oiHI"•  
  ##
  # Forces reconnection of SSL connections.
  def function(arglist)
    @var = (@var + 1)
  end
  
  ##
  # Finishes then restarts the Net::HTTP +connection+;Fi[	@9i7I"Æ          @var.flush
        end
        
        def function(arglist)
          @var = (@var + 1)
        end
        
        def function(arglist)
          move_progress;Fi[@YH@I@II"var = 0;Fi[[	@UiDI"x      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@ci=I"x      end
    end
    var = -1
    var = 0
    var = 0
    var = 0
    var = 0
    var = 1
    while (var < var) do;Fi[	@ßiI"—      
      def function(arglist)
        var = self.words.collect { |arglist| h(var) }
        var = 0
        var = 0
        var = 0
        var = 0
        diff.diffs.each do |arglist|
          var = nil;Fi[@	)I"(@var or @var);FI"end;FI" ;Fi[[	@Ji«I"∞        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        options["revision"];Fi[	@ÉiáI"¥          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var;Fi[	@iI"b    class GherkinBuilder
      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("\n")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, []);Fi[@	)@±?@≤?I"end;Fi[[	@%iI"require("set")
module Gem
  class Specification
    def function(arglist)
      @var ||= []
    end
  end
  
  class Dependency;Fi[	@%iI"m  end
  
  class Dependency
    def function(arglist)
      @var ||= []
    end
  end
end
module Bundler;Fi[	@ÙiI"l      
      private
      
      def function(arglist)
        @var ||= []
      end
    end
  end
end;Fi[@YHI"while (var < var) do;F@ãkI"if (var < 128) then;Fi[[	@LiBI"     var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@Oi2I"     var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[	@Ri1I"     var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1);Fi[@YHI"var = @var["cw"];FI"var = var.length;FI"var = 0;Fi[[	@Li?I"º  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@Oi/I"º  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[	@Ri.I"º  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var]);Fi[@	)@0MI"var = [];FI",transferred_files_for(var) do |arglist|;Fi[[	@•i_I"≠      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from Dropbox."))
        end;Fi[	@±i(I"ô      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << "#{storage_name} started removing '#{local_file}'.")
        end;Fi[	@√i=I"≠      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from '#{ip}'."))
        end;Fi[@	)I"binding;FI"end;FI"end;Fi[[	@Ú`iI"ù    
    ##
    # Returns the binding (needs a wrapper method because #binding is a private method)
    def function(arglist)
      binding
    end
  end
end;Fi[	@iÑI"i        end
      end
      
      def function(arglist)
        binding
      end
    end
  end
end;Fi[	@ci	I"Ümodule Compass
  module Sprites
    class Binding < OpenStruct
      def function(arglist)
        binding
      end
    end
  end
end;Fi[@	)I"[self];FI"end;FI" ;Fi[[	@ﬂiÓI"Á      
      # A chain of reflections from this one back to the owner. For more see the explanation in
      # ThroughReflection.
      def function(arglist)
        [self]
      end
      
      def function(arglist)
        false;Fi[	@©i∫I"4    # @return [ Array<Document> ] An array with the document as its only item.
    #
    # @since 1.0.0
    def function(arglist)
      [self]
    end
    
    # Return a hash of the entire document hierarchy from this document and
    # below. Used when the attributes are needed for everything and not just;Fi[	@s	imI"¿      # @return [ Array ] An array with only the string in it.
      #
      # @since 1.0.0
      def function(arglist)
        [self]
      end
      
      # Is this string a writer?
      #;Fi[@	)I"var = 0;FI"var = @var["cw"];FI"var = var.length;Fi[[	@Li>I"É    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@Oi.I"É    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[	@Ri-I"É    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do;Fi[@	)I"?execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");FI"end;FI" ;Fi[[	@Ii&I"        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[	@kiπI"$          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[	@çi8I"        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}");Fi[@	)I"3execute("SAVEPOINT #{current_savepoint_name}");FI"end;FI" ;Fi[[	@Ii"I"ﬂ        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[	@kiµI"          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[	@çi4I"ı        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}");Fi[I"super();FI"end;FI" ;FI"def function(arglist);Fi[[	@gieI"È    class RGProxy < ::Gem::SilentUI
      def function(arglist)
        @var = var
        super()
      end
      
      def function(arglist)
        if var =~ /native extensions/ then
          @var.info("with native extensions ");Fi[	@izI"‘          
          def function(arglist)
            @var = nil
            super()
          end
          
          def function(arglist)
            return unless (var == "meta")
            var = Hash[var];Fi[	@iÉI"Â        class JumpSAXHandler < SAXHandler
          def function(arglist)
            @var = var
            super()
          end
          
          def function(arglist)
            super
            throw(@var, @var) if @var;Fi[@	)I"super(var, var);FI"@var ||= 22;FI"@var ||= "backups";Fi[[	@ªiI"      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        @var ||= false
        instance_eval(&var) if block_given?;Fi[	@√iI"      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "");Fi[	@»iI"      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?
        @var = path.sub(/^\~\//, "");Fi[I"C# +binds+ as the bind substitutes. +name+ is logged along with;FI"$# the executed +sql+ statement.;FI"def function(arglist);F@éei[[	@0iII"      end
      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      ;Fi[	@0iPI"      end
      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      ;Fi[	@0iWI"      end
      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      ;Fi[@Ÿs@⁄s@éeI"end;Fi[[	@0iJI"`      
      # Executes insert +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes delete +sql+ statement in the context of this connection using;Fi[	@0iQI"`      
      # Executes delete +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Executes update +sql+ statement in the context of this connection using;Fi[	@0iXI"T      
      # Executes update +sql+ statement in the context of this connection using
      # +binds+ as the bind substitutes. +name+ is logged along with
      # the executed +sql+ statement.
      def function(arglist)
        exec_query(var, var, var)
      end
      
      # Returns the last auto-generated ID from the affected table.;Fi[@IY@JYI" ;FI"def function(arglist);Fi[[	@3iZI"å    end
    
    def function(arglist)
      yield
    end
    
    def function(arglist)
      Gem::DefaultUserInteraction.ui = var
    end;Fi[	@iI"ê      end
      
      def function(arglist)
        yield
      end
      
      def function(arglist)
        scan_setup(var)
        do_parse;Fi[	@ài$I"¥    def function(arglist)
      @var = var
      @var = var
      yield
    end
    
    def function(arglist)
      class_eval do |arglist|
        define_method(var) do |arglist|;Fi[@	)I"
yield;FI"end;FI" ;Fi[[	@FiØI"p      
      # REFERENTIAL INTEGRITY ====================================
      # Override to turn off referential integrity while executing <tt>&block</tt>.
      def function(arglist)
        yield
      end
      
      # CONNECTION MANAGEMENT ====================================
      # Checks whether the connection to the database is still active. This includes;Fi[	@3iYI"ñ      Gem.refresh
    end
    
    def function(arglist)
      yield
    end
    
    def function(arglist)
      Gem::DefaultUserInteraction.ui = var;Fi[	@iI"í        @var = nil
      end
      
      def function(arglist)
        yield
      end
      
      def function(arglist)
        scan_setup(var);Fi[@	)@YYI"@var ||= Array.new;FI"@var ||= Array.new;Fi[[	@ci0I"      # 'lock' dump meaning wrapping mongodump with fsync & lock
      ##
      # Creates a new instance of the MongoDB database object
      def function(arglist)
        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= false
        @var ||= false;Fi[	@fi)I"      # Path to mysqldump utility (optional)
      ##
      # Creates a new instance of the MySQL adapter object
      def function(arglist)
        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?;Fi[	@ii*I"a      # Creates a new instance of the PostgreSQL adapter object
      # Sets the PGPASSWORD environment variable to the password
      # so it doesn't prompt and hang in the process
      def function(arglist)
        super(var)
        @var ||= Array.new
        @var ||= Array.new
        @var ||= Array.new
        instance_eval(&var) if block_given?;Fi[I"yield);FI"ensure;FI"@var = var;FI"end;Fi[[	@
iüI"ä    def function(arglist)
      begin
        (@var, var = var, @var
        yield)
      ensure
        @var = var
      end
    end
    ;Fi[	@Vi4I"◊          if block_given? then
            begin
              (var, @var = @var, true
              yield)
            ensure
              @var = var
            end
          else
            LocalProxy.new(self);Fi[	@=i3I"å        begin
          (@var = true
          var = @var
          yield)
        ensure
          @var = var
        end
      end
    end;Fi[@	)@YYI"@var = var;FI"end;Fi[[	@¢6i-I"™  class WrappedDatabaseException < StatementInvalid
    attr_reader(:original_exception)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
  ;Fi[	@>iI"ª    # @return [Fixnum]
    # @param message [String] The error message
    # @param line [Fixnum] See \{#line}
    def function(arglist)
      super(var)
      @var = var
    end
  end
  ;Fi[	@Ui6I"é  class InstallationError < RuntimeError
    attr(:formula)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
end;Fi[@	)I"{};FI"end;FI" ;Fi[[	@>iI"_      # Returns a Hash of mappings from the abstract data types to the native
      # database types. See TableDefinition#column for details on the recognized
      # abstract data types.
      def function(arglist)
        {}
      end
      
      # Truncates a table alias according to the limits of the current adapter.
      def function(arglist);Fi[	@B)i/I"u      @var ||= ""
    end
    
    def function(arglist)
      {}
    end
    
    def function(arglist)
      0;Fi[	@≥i∑I"é      var.finish
    end
    
    def function(arglist)
      {}
    end
    
    def function(arglist)
      self.env["omniauth.error"] = var;Fi[@	)I"64;FI"end;FI" ;Fi[[	@-iI"Õ      end
      
      # Returns the maximum length of a column name.
      def function(arglist)
        64
      end
      
      # Returns the maximum length of a table name.
      def function(arglist);Fi[	@-iI"Õ      end
      
      # Returns the maximum length of a table name.
      def function(arglist)
        64
      end
      
      # Returns the maximum length of an index name.
      def function(arglist);Fi[	@-iI"“      end
      
      # Returns the maximum length of an index name.
      def function(arglist)
        64
      end
      
      # Returns the maximum number of columns per table.
      def function(arglist);Fi[@	)I"@var.shift;FI"end;FI" ;Fi[[	@(i\I")        end
        
        # Removes and returns the head of the queue if possible, or nil.
        def function(arglist)
          @var.shift
        end
        
        # Remove and return the head the queue if the number of
        # available elements is strictly greater than the number of;Fi[	@úiAI"∑      @var.first
    end
    
    def function(arglist)
      @var.shift
    end
    
    def function(arglist)
      var.kind_of?(Array) ? (@var = (var + @var)) : (@var.unshift(var));Fi[	@ÊiI"∏        return (@var.first == var)
      end
      
      def function(arglist)
        @var.shift
      end
      
      def function(arglist)
        return unless @var.include?(var);Fi[@ˆGI"end;FI"end;FI"var;Fi[[	@
iÚI"Æ            var = ["2", "n", "+", "1"]
            var = Node.new(:AN_PLUS_B, var)
          else
            var = var
          end
        end
        var
      end
      ;Fi[	@ÄiI"Ñ          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    ;Fi[	@ÄiGI"Ñ          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var
    end
    ;Fi[@	)I"@var.keys;FI"end;FI" ;Fi[[	@iØI"&    #   person = Person.new
    #   person.attribute_names
    #   # => ["id", "created_at", "updated_at", "name", "age"]
    def function(arglist)
      @var.keys
    end
    
    # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
    #;Fi[	@]iI"‘      ##
      # Returns an Array of all attribute method names
      # that default values were set for.
      def function(arglist)
        @var.keys
      end
      
      ##
      # Used only within the specs;Fi[	@ﬁi.I"§      var and (@var.has_key?(var.to_sym) or abbreviation?(var))
    end
    
    def function(arglist)
      @var.keys
    end
    
    alias_method(:[], :get)
    ;Fi[@	)@YI"var = @var;FI"var = @var["cw"];Fi[[	@LiXI"π    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@OiMI"π    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[	@RiGI"π    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var);Fi[@	)I"replace(var);FI"end;FI" ;Fi[[	@ãiI"      end
      
      # Implements the writer method, e.g. foo.items= for Foo.has_many :items
      def function(arglist)
        replace(var)
      end
      
      # Implements the ids reader method, e.g. foo.item_ids for Foo.has_many :items
      def function(arglist);Fi[	@¸iI"€      end
      
      # Implements the writer method, e.g. foo.bar= for Foo.belongs_to :bar
      def function(arglist)
        replace(var)
      end
      
      def function(arglist)
        create_record(var, &var);Fi[	@¸i4I"Á        raise(NotImplementedError, "Subclasses must implement a replace(record) method")
      end
      
      def function(arglist)
        replace(var)
      end
      
      def function(arglist)
        var = build_record(var);Fi[@	)@“Q@o@oi[[	@oi
I"–  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
  end;Fi[	@oiI"È  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = controller.camelize;Fi[	@ÄiI"‰  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}"
    @var = model.camelize;Fi[@	)@“QI"@var = [];FI"end;Fi[[	@ãi$I"»        replace(klass.find(var).index_by { |arglist| var.id }.values_at(*var))
      end
      
      def function(arglist)
        super
        @var = []
      end
      
      def function(arglist);Fi[	@>iI"«      class NestedTextFormatter < BaseTextFormatter
        INDENT = "  "
        
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist);Fi[	@Hi
I"Õ  module Runner
    module Formatter
      class ProfileFormatter < ProgressBarFormatter
        def function(arglist)
          super
          @var = []
        end
        
        def function(arglist);Fi[@ÚVI"@var = var;FI"end;FI"end;Fi[[	@¢6i.I"©    attr_reader(:original_exception)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class RecordNotUnique < WrappedDatabaseException;Fi[	@>iI"¿    # @param message [String] The error message
    # @param line [Fixnum] See \{#line}
    def function(arglist)
      super(var)
      @var = var
    end
  end
  
  class SyntaxError < Error;Fi[	@Ui7I"î    attr(:formula)
    
    def function(arglist)
      super(var)
      @var = var
    end
  end
end
class CannotInstallFormulaError < RuntimeError;Fi[@ÚVI"	else;F@\pI"end;Fi[[	@£ioI"¡  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@£ixI"¡  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[	@£i|I"¡  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  ;Fi[@	)@“QI"@var = false;FI"end;Fi[[	@ÖiI"ñ        self.target = var
      end
      
      def function(arglist)
        super
        @var = false
      end
      
      attr_reader :function;Fi[	@ñiI"{      var
    end
    
    def function(arglist)
      super
      @var = false
    end
    
    def function(arglist);Fi[	@ÿi◊I"ø    end
    
    # Resets callback tracking
    def function(arglist)
      super
      @var = false
    end
    
    # Resets the event attribute so it can be re-evaluated if attempted again;Fi[@	)@Ú)I"super(var);FI"end;Fi[[	@oiI"ù      
      attr_reader(:content_type)
      
      def function(arglist)
        @var = var
        super(var)
      end
      
      def function(arglist);Fi[	@]Wi
I"à    attr_reader(:object)
    
    # The object that failed
    def function(arglist)
      @var = var
      super(var)
    end
  end
end;Fi[	@uiI"ó        raise(var.from_response(var)) if var
      end
      
      def function(arglist)
        @var = var
        super(var)
      end
    end
  end;Fi[@	)@Ú)@Ç9I"@var = false;Fi[[	@®iI"ª  
  attr(:show_header, true)
  
  def function(arglist)
    @var = var
    @var = var
    @var = false
    @var = (ARGV.ignore_deps? or ARGV.interactive?)
    @var = install_bottle?(var);Fi[	@,iI"›    # The name of the queue from which this job was pulled (or is to be
    # placed)
    # This job's associated payload object.
    def function(arglist)
      @var = var
      @var = var
      @var = false
    end
    ;Fi[	@|i
I"Á    class ArgumentExpectation
      attr_reader(:args)
      
      def function(arglist)
        @var = var
        @var = var
        @var = false
        @var = nil
        if ArgumentMatchers::AnyArgsMatcher.===(var.first) then;Fi[@	)@Ú)@Ç9I"@var = nil;Fi[[	@≠iI"ü    
    attr_reader(:columns, :rows, :column_types)
    
    def function(arglist)
      @var = var
      @var = var
      @var = nil
      @var = var
    end;Fi[	@™iAI"ß  
  # Used by formula to unpack after downloading
  # Used by audit
  def function(arglist)
    @var = var
    @var = var
    @var = nil
    @var = nil
    @var = nil;Fi[	@«iI"∞      
      attr_reader(:expected, :actual)
      
      def function(arglist)
        @var = var
        @var = var
        @var = nil
        @var = false
        @var = nil;Fi[@»J@…JI"A# @param [ Array ] args The names of the fields to validate.;FI"#;Fi[[	@ÙiéI"Û      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist);Fi[	@ÙiüI"Á      #     field :title
      #
      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist);Fi[	@Ùi∞I"€      #     field :title
      #
      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist);Fi[@»J@…JI",# @return [ Object ] The yielded value.;FI"#;Fi[[	@éi)I"‡      # @example Execute with selection.
      #   context.selecting do
      #     collection.find
      #   end
      #
      # @return [ Object ] The yielded value.
      #
      # @since 2.4.4
      def function(arglist);Fi[	@
iMI"È        # @example Prepare the operation.
        #   prepare do
        #     collection.update
        #   end
        #
        # @return [ Object ] The yielded value.
        #
        # @since 2.1.0
        def function(arglist);Fi[	@≈iI"˚      # @example Execute the assignment.
      #   _assigning do
      #     person.attributes = { :addresses => [ address ] }
      #   end
      #
      # @return [ Object ] The yielded value.
      #
      # @since 2.2.0
      def function(arglist);Fi[I"super(var, var, var, var);FI"end;FI"end;FI" ;Fi[[	@Li®I"Æ    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"];Fi[	@Oi£I"∞    if (@var["type"] == "Type0") then
      SJISWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"];Fi[	@RióI"Æ    if (@var["type"] == "Type0") then
      MBWrite(var, var, var, var)
    else
      super(var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var["cw"];Fi[@»J@…JI"-# @return [ Enumerator ] The enumerator.;FI"#;Fi[[	@Üi"I"›      # @example Iterate over the results.
      #   map_reduce.each do |doc|
      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@ãiaI"‚      # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@éiqI"‚      # @example Iterate over the context.
      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist);Fi[@[I"var = (var + $!.success);FI"end;FI"var = var;Fi[[	@ÄiI"›            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@ÄiDI"›            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[	@ÄiÇI"›            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end;Fi[@∂sI"end;FI" ;FI"def function(arglist);Fi[[	@Ii#I"›      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@ki∂I"Ô        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end;Fi[	@çi5I"›      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end;Fi[@´sI"end;FI" ;FI"def function(arglist);Fi[[	@Ii'I"Â      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end;Fi[	@ki∫I"˜        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end;Fi[	@çi9I"Â      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end;Fi[@»J@…JI"2# @return [ Object ] The result of the yield.;FI"#;Fi[[	@áibI"Á    # @example Execute the block.
    #   document.with_positional_operator do
    #     document.atomic_updates
    #   end
    #
    # @return [ Object ] The result of the yield.
    #
    # @since 3.1.0
    def function(arglist);Fi[	@ë
iâI"      # @example Execute without autobuild.
      #   document.without_autobuild do
      #     document.name
      #   end
      #
      # @return [ Object ] The result of the yield.
      #
      # @since 3.0.0
      def function(arglist);Fi[	@ù
iI"Ï      # @example Execute the binding block.
      #   binding.binding do
      #     base.foreign_key = 1
      #   end
      #
      # @return [ Object ] The result of the yield.
      #
      # @since 3.0.0
      def function(arglist);Fi[@»J@…JI"W# You can also pass the resource name as the first argument to skip that resource.;FI"def function(arglist);Fi[[	@´i¥I"O      #
      #   class ProjectsController < SomeOtherController
      #     skip_load_and_authorize_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(arglist)
        skip_load_resource(*var)
        skip_authorize_resource(*var);Fi[	@´i√I"W      #   class ProjectsController < ApplicationController
      #     load_and_authorize_resource
      #     skip_load_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(arglist)
        var = var.extract_options!
        var = var.first;Fi[	@´i”I"\      #   class ProjectsController < ApplicationController
      #     load_and_authorize_resource
      #     skip_authorize_resource :only => :index
      #   end
      #
      # You can also pass the resource name as the first argument to skip that resource.
      def function(arglist)
        var = var.extract_options!
        var = var.first;Fi[@@J@AJ@BJI".#   states = Vehicle.state_machine.states;Fi[[	@î iI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">
    #   ;Fi[	@î i,I"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@î iGI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   
    #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[I"5ConnectionAdapters::Column.value_to_decimal(var);FI"end;FI"end;FI" ;Fi[[	@Vi-I"¯        class Decimal < Type
          def function(arglist)
            return if var.nil?
            ConnectionAdapters::Column.value_to_decimal(var)
          end
        end
        
        class Boolean < Type
          def function(arglist);Fi[	@ri+I"ﬂ            else
              # do nothing
            end
            ConnectionAdapters::Column.value_to_decimal(var)
          end
        end
        
        class Vector < Type
          attr_reader(:delim, :subtype);Fi[	@riÇI"˜        class Decimal < Type
          def function(arglist)
            return if var.nil?
            ConnectionAdapters::Column.value_to_decimal(var)
          end
        end
        
        class Hstore < Type
          def function(arglist);Fi[I"rescue LoadError;FI"
false;FI"end;FI"end;Fi[[	@ßiãI"ê        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end;Fi[	@¨i~I"ê        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end
  end;Fi[	@èiVI"}      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end
end;Fi[@@J@AJ@BJI"#   vehicle = Vehicle.new;Fi[[	@=<i¶I"    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   vehicle.state                             # => "parked"
    #   vehicle.state_name                        # => :parked;Fi[	@„i¥I"[    #   class Vehicle
    #     state_machine :action => :save do
    #       ...
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, machine, :ignite, :parked, :idling)
    #   transition.perform                  # => Runs the +save+ action after setting the state attribute;Fi[	@„iËI"!    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end
    #   end
    #   
    #   vehicle = Vehicle.new
    #   transition = StateMachine::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling)
    #   transition.persist;Fi[@ÉI@°[@¢[I" ;Fi[[	@ªiíI"Á    var = 0
    var.each do |arglist|
      self.aspects.find(var).update_attributes(:order_id => (var))
      var = (var + 1)
    end
  end
  
  # Generate public/private keys for User and associated Person
  def function(arglist);Fi[	@iÄI"l          var = ((var - var) * var)
          var = ((var * var) - (var * var))
          @var.add_element("rect", "x" => (var.to_s), "y" => (var.to_s), "width" => (var.to_s), "height" => (var.to_s), "class" => ("fill#{(field_count + 1)}"))
          var = (var + 1)
        end
      end
      
      def function(arglist)
        return "/* default fill styles for multiple datasets (probably only use a single dataset on this graph though) */\n.key1,.fill1{\n\tfill: #ff0000;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 0.5px;\t\n}\n.key2,.fill2{\n\tfill: #0000ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key3,.fill3{\n\tfill: #00ff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key4,.fill4{\n\tfill: #ffcc00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key5,.fill5{\n\tfill: #00ccff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key6,.fill6{\n\tfill: #ff00ff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key7,.fill7{\n\tfill: #00ffff;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key8,.fill8{\n\tfill: #ffff00;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key9,.fill9{\n\tfill: #cc6666;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key10,.fill10{\n\tfill: #663399;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key11,.fill11{\n\tfill: #339900;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n.key12,.fill12{\n\tfill: #9966FF;\n\tfill-opacity: 0.5;\n\tstroke: none;\n\tstroke-width: 1px;\t\n}\n";Fi[	@$i:I"Ÿ      var = 0
      while var = Resque::Failure.all(var) do
        Resque::Failure.requeue(var) if (var["queue"] == var)
        var = (var + 1)
      end
    end
    
    def self.remove_queue(arglist)
      var = 0;Fi[@@J@AJ@BJI"#   class VehicleObserver;Fi[[	@§iI"Ô        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@§i\I"Ô        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     include DataMapper::Observer
        #     ;Fi[	@§i{I"
        #       event :ignite do
        #         transition :parked => :idling
        #       end
        #     end
        #   end
        #   
        #   class VehicleObserver
        #     after_transition_failure do |transition|
        #       # log failure;Fi[@ÉII"	else;F@;pI"var = (var + 2);Fi[[	@LiGI"ı      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end;Fi[	@Oi;I"»      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end;Fi[	@Ri6I"ı      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end;Fi[I")#     define_attribute_methods :name;FI"#;FI"#     private;FI"#;Fi[[	@˝i)I"Ì      #
      #     attr_accessor :name
      #     attribute_method_prefix 'clear_'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def clear_attribute(attr)
      #       send("#{attr}=", nil);Fi[	@˝iMI"Ô      #
      #     attr_accessor :name
      #     attribute_method_suffix '_short?'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def attribute_short?(attr)
      #       send(attr).length < 5;Fi[	@˝iqI"      #
      #     attr_accessor :name
      #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
      #     define_attribute_methods :name
      #
      #     private
      #
      #     def reset_attribute_to_default!(attr)
      #       ...;Fi[@«U@CoI"#   end;FI"#;Fi[[	@ï7iΩI"ÿ    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.valid? # => false;Fi[	@ï7iŒI"–    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[	@ï7iıI"–    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new
    #   person.name = '';Fi[@≈UI"#     has_many :pets;TI"#   end;TI"#;Ti[[	@îi¥I"      # You can pass an array of attributes hashes, this will return an array
      # with the new objects.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.build
      #   # => #<Pet id: nil, name: nil, person_id: 1>;Ti[	@îiœI"2      # attributes, linked to this object and that has already been saved (if it
      # passes the validations).
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.create(name: 'Fancy-Fancy')
      #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>;Ti[	@îiÎI"Ë      
      # Like +create+, except that if the record is invalid, raises an exception.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   class Pet
      #     validates :name, presence: true;Ti[I"var = "";F@Ñn@≤pI"6var = var.to_s.index("T") ? ((var + "T")) : (var);Fi[[	@LihI"˙        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[	@Oi]I"˙        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[	@RiWI"˙        var = "LRT"
        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end;Fi[@ÄuI"
begin;F@¢n@£ni[[	@ÄiI"[          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length]);Fi[	@Äi=I"W          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length]);Fi[	@Äi{I"W          var = var.iconv(var)) rescue var = var.gsub(/[^\r\n\t\x20-\x7e]/, "?")
        else
          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length]);Fi[@ÄuI"&(var << "top:#{params[:top]}px;");FI"-(var << "left:#{coords[:bar_start]}px;");FI"!(var << "width:#{width}px;");Fi[[	@™i´I"ß        var = ""
        if var[:bar_start] and var[:bar_end] then
          var = ((var[:bar_end] - var[:bar_start]) - 2)
          var = ""
          (var << "top:#{params[:top]}px;")
          (var << "left:#{coords[:bar_start]}px;")
          (var << "width:#{width}px;")
          var = "task-todo-issue-#{options[:issue].id}" if var[:issue]
          var = "task-todo-version-#{options[:version].id}" if var[:version];Fi[	@™iπI"–          (var << view.content_tag(:div, "&nbsp;".html_safe, var))
          if var[:bar_late_end] then
            var = ((var[:bar_late_end] - var[:bar_start]) - 2)
            var = ""
            (var << "top:#{params[:top]}px;")
            (var << "left:#{coords[:bar_start]}px;")
            (var << "width:#{width}px;")
            (var << view.content_tag(:div, "&nbsp;".html_safe, :style => (var), :class => ("#{options[:css]} task_late")))
          end;Fi[	@™i¡I"≤          end
          if var[:bar_progress_end] then
            var = ((var[:bar_progress_end] - var[:bar_start]) - 2)
            var = ""
            (var << "top:#{params[:top]}px;")
            (var << "left:#{coords[:bar_start]}px;")
            (var << "width:#{width}px;")
            var = "task-done-issue-#{options[:issue].id}" if var[:issue]
            var = "task-done-version-#{options[:version].id}" if var[:version];Fi[@û=I"K# @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline;FI"<# @note This method can only return up to 3,200 Tweets.;FI"# @rate_limited Yes;Fi[[	@5i'I"º      (alias :mentions :mentions_timeline)
      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@5i?I"ù      end
      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[	@5iWI"«      (alias :retweeted_by :retweeted_by_user)
      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[@û=I"E# @see https://dev.twitter.com/docs/api/1.1/get/friendships/show;FI"# @rate_limited Yes;FI",# @authentication Requires user context;Fi[[	@DiŒI"Ü      end
      
      # Returns detailed information about the relationship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship];Fi[	@DiÏI"∑      (alias :relationship :friendship)
      
      # Test for the existence of friendship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if user_a follows user_b, otherwise false.;Fi[	@DiI"Ω      end
      
      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor];Fi[@MN@NN@ONI"end;Fi[[	@‰i,I"∏        if (top_level.preferred_syntax == :scss) and top_level.sass_dir then
          "\n# If you prefer the indented syntax, you might want to regenerate this\n# project again passing --syntax sass, or you can uncomment this:\n# preferred_syntax = :sass\n# and then run:\n# sass-convert -R --from scss --to sass #{top_level.sass_dir} scss && rm -rf sass && mv scss sass\n"
        else
          ""
        end
      end
    end
  end
end;Fi[	@i©I"»      
      # Emits an HTML fragment that can be used to link to the compiled css files
      def function(arglist)
        ""
      end
    end
  end
end
require("compass/installers/bare_installer");Fi[	@Ji5I"{    if File.exist?("spec/spec.opts") then
      "-O #{File.join("spec", "spec.opts")} "
    else
      ""
    end
  end
end;Fi[@MN@NNI" ;FI"def function(arglist);Fi[[	@ÿ#i?I"Z  end
  
  def function(arglist)
    ""
  end
  
  def function(arglist)
    []
  end;Fi[	@π)iI"l    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      ""
    end;Fi[	@π)iI"k    end
    
    def function(arglist)
      ""
    end
    
    def function(arglist)
      0
    end;Fi[I"end.compact;FI"end;FI" ;FI"def function(arglist);Fi[[	@iÑI"Æ          else
            nil
          end
        end.compact
      end
      
      def function(arglist)
        (@var << JsStepDefinition.new(self, var, var))
      end;Fi[	@aiI"{      else
        # do nothing
      end
    end.compact
  end
  
  def function(arglist)
    tapped_formula_for(:A)
  end;Fi[	@`i7I"≤          else
            nested_description_from(var)
          end
        end.compact
      end
      
      def function(arglist)
        var.description_args.join
      end;Fi[@û=I"`#   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;FI"=#   @param options [Hash] A customizable set of options.;FI"Õ#   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@DiI"}      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs
      #     Twitter.friend_ids('sferik');Fi[	@DiI"/      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@Di.I"/      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[I" yield(self) if block_given?;FI"end;FI" ;FI"def function(arglist);Fi[[	@˜iiI"Ë      def function(arglist)
        @var = var
        @var = []
        yield(self) if block_given?
      end
      
      def function(arglist)
        (branches << ConditionBranch.new(configuration, var, var, var, var))
      end;Fi[	@DiI"≤      def function(arglist)
        @var = var
        @var = []
        yield(self) if block_given?
      end
      
      def function(arglist)
        yield(self)
        self;Fi[	@;iI"∑module Paperclip
  module Helpers
    def function(arglist)
      yield(self) if block_given?
    end
    
    def function(arglist)
      Paperclip::Interpolations[var] = var
    end;Fi[I"return true;FI"end;FI"end;FI"end;Fi[[	@‡iI"™        if var and except.any? then
          return except.include?(var.fully_qualified_name).!
        else
          return true
        end
      end
    end
  end
  ;Fi[	I"/data//mongoid_proj/lib/mongoid/matchers.rb;TiI"à          return false unless Strategies.matcher(self, var, var).matches?(var)
        end
      end
      return true
    end
  end
end;Fi[	@nei4I"¬      end
      return false if ((var - Time.now.to_i).abs > OpenID::Nonce.skew)
      Nonce.create(:server_url => (var), :timestamp => (var), :salt => (var))
      return true
    end
  end
end;Fi[I"var = case var;F@ÚaI""Success";FI"when :warning then;Fi[[	@Ñi0I"       # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[	@ëi.I"       # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[	@ói,I"       # : backup log and other information if `on_failure` was set to `true`
      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then;Fi[@û=@÷a@◊a@hi[[	@iI",      attr_reader(:max_position, :min_position, :target_objects)
      
      # A collection of users who followed a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      ;Fi[	@iI""      attr_reader(:max_position, :min_position)
      
      # A collection of users who added a user to a list
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      ;Fi[	@iI"      attr_reader(:max_position, :min_position)
      
      # A collection of users who mentioned a user
      #
      # @return [Array<Twitter::User>]
      def function(arglist)
        @var = Array(@var[:sources]).map { |arglist| Twitter::User.fetch_or_new(var) }
      end
      ;Fi[@û=@ºfI"def function(arglist);FI"9@var = Array(@var[:target_objects]).map do |arglist|;Fi[[	@iI"      end
      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end;Fi[	@i
I",  module Action
    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end;Fi[	@i
I"  module Action
    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end;Fi[I"var.save;FI"end;FI"end;FI" ;Fi[[	@çiPI""  def function(arglist)
    if var = ConversationVisibility.where(:conversation_id => (self.conversation_id), :person_id => (var.person.id)).first then
      var.unread += 1
      var.save
    end
  end
  
  def function(arglist)
    Notifications::PrivateMessage unless (var.person == var);Fi[	@úi}I"÷    var = Profile.where(:image_url => (url(:thumb_large)))
    var.each do |arglist|
      var.image_url = nil
      var.save
    end
  end
  
  def function(arglist)
    Resque.enqueue(Jobs::ProcessPhoto, self.id);Fi[	@èizI"Á    assert_equal(2, var.versions.size)
    assert_raises(ActiveRecord::StaleObjectError) do |arglist|
      var.title = "stale title"
      var.save
    end
  end
  
  def function(arglist)
    var = Page.create!(:title => "title");Fi[I"K# its non-bang version in that it passes through the attribute setter.;FI"J# Saving is not subjected to validation checks. Returns +true+ if the;FI"# record could be saved.;FI"def function(arglist);Fi[[	@ÀiI"l    end
    
    # Wrapper around +increment+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(arglist)
      increment(var, var).update_attribute(var, self[var])
    end;Fi[	@Ài I"l    end
    
    # Wrapper around +decrement+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(arglist)
      decrement(var, var).update_attribute(var, self[var])
    end;Fi[	@Ài1I"a    end
    
    # Wrapper around +toggle+ that saves the record. This method differs from
    # its non-bang version in that it passes through the attribute setter.
    # Saving is not subjected to validation checks. Returns +true+ if the
    # record could be saved.
    def function(arglist)
      toggle(var).update_attribute(var, self[var])
    end;Fi[I"end.new;FI"assert(var.satisfied?);FI"end;FI" ;Fi[[	I"1data//homebrew_proj/test/test_requirement.rb;Ti(I"Û  def function(arglist)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (false)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) do |arglist|;Fi[	@2vi9I"     var = Class.new(Requirement) do |arglist|
      env(:userpaths)
      satisfy(:build_env => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    ENV.expects(:with_build_environment).yields.returns(true);Fi[	@2viBI"     ENV.expects(:userpaths!)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (true), :userpaths => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) { |arglist| satisfy(true) }.new;Fi[@û=I"#     property :id, Serial;FI"##     property :state, :String;FI"#;Fi[[	@§iI"        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@§iTI"        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[	@§ixI"        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do;Fi[@û=@Vo@WoI"#       end;Fi[[	@&iEI"’    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@&iwI"’    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     ;Fi[	@=<i¢I"÷    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end;Fi[@û=@SaI"'#     include DataMapper::Resource;FI"#;Fi[[	@§iI"        # information about the various configuration options available.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String;Fi[	@§iQI"        # as the given requirements match the transition.
        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String;Fi[	@§iuI"        # be performed so long as the given requirements match the transition.
        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String;Fi[I"1class_option(:timestamps, :type => :boolean);FI" ;FI"aclass_option(:parent, :type => :string, :desc => "The parent class for the generated model");FI" ;Fi[[	@:iI"l      
      class_option(:migration, :type => :boolean)
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
      
      class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
      ;Fi[	I"Mdata//mongoid_proj/lib/rails/generators/mongoid/model/model_generator.rb;TiI"B      
      check_class_collision
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
      
      class_option(:versioning, :type => :boolean, :default => (false), :desc => "Enable mongoid versioning")
      ;Fi[	@ÄiI"H  
  class_option(:migration, :type => :boolean)
  
  class_option(:timestamps, :type => :boolean)
  
  class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  ;Fi[@û=@Sa@tLI"!#       other_states :idling;Fi[[	@î iI"µ    # will be raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@î i(I"œ    # the value of the attribute on the object.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[	@î iCI"≠    # raised.
    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end;Fi[I"attr_accessor(:name);FI" ;F@t`I" ;Fi[[	@ciI"¥module Backup
  module Database
    class MongoDB < Base
      attr_accessor(:name)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:host, :port)
      ;Fi[	@fiI"ªmodule Backup
  module Database
    class MySQL < Base
      attr_accessor(:name)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:host, :port, :socket)
      ;Fi[	@iiI"¿module Backup
  module Database
    class PostgreSQL < Base
      attr_accessor(:name)
      
      attr_accessor(:username, :password)
      
      attr_accessor(:host, :port, :socket)
      ;Fi[@û=I"!# Valid requirement options:;FI"N# * <tt>:from</tt> - One or more states being transitioned from.  If none;FI"E#   are specified, then this will be the object's current state.;Fi[[	@Çi|I"⁄    
    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.;Fi[	@â iI"ê    end
    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.;Fi[	@â i1I"ì    end
    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.;Fi[@û=@€\@‹\I",#   machine = StateMachine.new(Vehicle);Fi[[	@„iìI"Ñ    
    # Does this transition represent a loopback (i.e. the from and to state
    # are the same)
    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   StateMachine::Transition.new(Vehicle.new, machine, :park, :parked, :parked).loopback?   # => true
    #   StateMachine::Transition.new(Vehicle.new, machine, :park, :idling, :parked).loopback?   # => false;Fi[	@„i°I"“    
    # A hash of all the core attributes defined for this transition with their
    # names as keys and values of the attributes as values.
    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   transition = StateMachine::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling)
    #   transition.attributes   # => {:object => #<Vehicle:0xb7d60ea4>, :attribute => :state, :event => :ignite, :from => 'parked', :to => 'idling'};Fi[	@„iöI"|    
    # Gets a hash of the context defining this unique transition (including
    # event, from state, and to state).
    # 
    # == Example
    # 
    #   machine = StateMachine.new(Vehicle)
    #   transition = StateMachine::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling)
    #   transition.context    # => {:on => :ignite, :from => :parked, :to => :idling};Fi[@û=I"/#    it "should do small edition stuff" do;FI"#      ...;FI"#    end;Fi[[	@Pi1I"€      #
      #  describe SmallEdition do
      #    it_should_behave_like "All Editions"
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist);Fi[	@PiFI"ƒ      #
      #  describe SmallEdition do
      #    it_should_behave_like AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      #;Fi[	@PiQI"       #
      #  describe SmallEdition do
      #    include AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist);Fi[I"if @var.compressor then;F@	aI"(var << var);FI"(var << var);Fi[[	@√iII"#      var = "tar"
      var = Pipeline.new
      (var << ("#{utility(:tar)} #{tar_args} -cPf - " + "#{paths_to_exclude} #{paths_to_package}"))
      if @var.compressor then
        @var.compressor.compress_with do |arglist|
          (var << var)
          (var << var)
        end
      end;Fi[	@fi;I"Í        var = Pipeline.new
        var = "sql"
        (var << mysqldump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end;Fi[	@ii;I"Á        var = Pipeline.new
        var = "sql"
        (var << pgdump)
        if @var.compressor then
          @var.compressor.compress_with do |arglist|
            (var << var)
            (var << var)
          end
        end;Fi[@û=@∫tI"#;FI"# @since 2.4.0;Fi[[	@ÙièI"0      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::FormatValidator, _merge_attributes(var));Fi[	@Ùi†I"$      #
      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::LengthValidator, _merge_attributes(var));Fi[	@Ùi±I"      #
      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var));Fi[@û=@ÿZI"#;FI"# @since 2.1.0;Fi[[	@≈i3I"       #   binding do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@≈iRI"Ã      #   _building do
      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin;Fi[	@≈i´I"›        #   creating do
        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin;Fi[I"var.perform!;FI"end;FI"end;FI"end;Fi[[	I"6data//diaspora_proj/models/jobs/delete_account.rb;TiI"r    
    def self.perform(arglist)
      var = AccountDeletion.find(var)
      var.perform!
    end
  end
end;Fi[	@3iI"¬      suppress_annoying_errors do |arglist|
        var = User.find(var)
        var = Postzord::Receiver::Private.new(var, :salmon_xml => (var))
        var.perform!
      end
    end
  end
end;Fi[	I";data//diaspora_proj/models/jobs/receive_local_batch.rb;TiI"°    def self.perform(arglist)
      var = var.constantize.find(var)
      var = Postzord::Receiver::LocalBatch.new(var, var)
      var.perform!
    end
  end
end;Fi[@û=I"0# @return [ Hash ] The reloaded attributes.;FI"#;FI"# @since 2.3.2;Fi[[	@™i)I"Ò    #
    # @example Reload the document.
    #   document._reload
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      embedded? ? (reload_embedded_document) : (reload_root_document);Fi[	@™i5I"    #
    # @example Reload the document.
    #   document.reload_root_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      {}.merge((with(:consistency => :strong).collection.find(:_id => (id)).one or {}));Fi[	@™iAI"5    #
    # @example Reload the document.
    #   document.reload_embedded_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      extract_embedded_attributes({}.merge(_root.with(:consistency => :strong).collection.find(:_id => (_root.id)).one));Fi[@û=I"#   class Game;FI"$#     include Mongoid::Document;FI"#     belongs_to :person;Fi[[	@oi|I"ﬂ        # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #;Fi[	@oiïI"Ÿ        #     include Mongoid::Document
        #     has_many :posts
        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #;Fi[	@oi I"ﬂ        # another database or collection.
        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #;Fi[@û=I"+# @return [ Array<Hash> ] The inserts.;FI"#;FI"# @since 3.0.0;Fi[[	@hiI"%        #   batchable.batch_insert([ doc_one, doc_two ])
        #
        # @param [ Array<Document> ] docs The docs to add.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          execute_batch_insert(var, "$pushAll");Fi[	@hiEI"        #   batchable.batch_replace([ doc_one, doc_two ])
        #
        # @param [ Array<Document> ] docs The docs to replace with.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          if var.blank? then;Fi[	@hitI"         #
        # @param [ Array<Document> ] docs The docs to persist.
        # @param [ String ] operation The atomic operation.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          self.inserts_valid = true;Fi[@û=I"$# @example Build the documents.;FI"'#   Builder.new(meta, attrs).build;FI"#;Fi[[	@Ò
iI"Å          # metadata on the relation. Instantiates through the factory in order
          # to make sure subclasses and allocation are used if fitting. This
          # case will return many documents.
          #
          # @example Build the documents.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type Not used in this context.
          #;Fi[	@iI"j        class Many < Builder
          # This builder either takes a hash and queries for the
          # object or an array of documents, where it will just return tem.
          #
          # @example Build the documents.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #;Fi[	@iI"q        class ManyToMany < Builder
          # This builder either takes a hash and queries for the
          # object or an array of documents, where it will just return them.
          #
          # @example Build the documents.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type The type of document to query for.
          #;Fi[@û=I"N# @option options [ true, false ] :continue Continue binding the inverse.;F@9_I"#;Fi[[	@¢
iI"`          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[	@≠
iI"z          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[	@≠
i&I"m          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist);Fi[@û=I"&# @return [ Proxy ] The relation.;FI"#;FI"# @since 2.0.0.rc.1;Fi[[	@ë
iI"n      # @param [ Hash, Moped::BSON::ObjectId ] object The id or attributes to use.
      # @param [ Metadata ] metadata The relation's metadata.
      # @param [ true, false ] building If we are in a build operation.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = create_relation(var, var);Fi[	@ë
i$I"      #
      # @param [ Document, Array<Document ] object The relation target.
      # @param [ Metadata ] metadata The relation metadata.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = @var[var.inverse_type];Fi[	@ë
iQI"      #
      # @param [ String, Symbol ] name The name of the relation.
      # @param [ Proxy ] relation The relation to set.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        instance_variable_set("@#{name}", var);Fi[I""next if send(var).to_s.empty?;FI"$"--#{option}='#{send(option)}'";F@UI"end;Fi[[	@ciâI"      # to perform the database dumping process
      def function(arglist)
        ["username", "password"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##;Fi[	@ciìI"ˇ      # to perform the database dumping process
      def function(arglist)
        ["host", "port"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##;Fi[	@figI"	      # to perform the database dumping process
      def function(arglist)
        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##;Fi[@w@UI"end;FI" ;Fi[[	@ciäI""      def function(arglist)
        ["username", "password"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds the MongoDB connectivity options syntax to connect the user;Fi[	@ciîI"      def function(arglist)
        ["host", "port"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Returns the mongodump syntax for enabling ipv6;Fi[	@fihI"      def function(arglist)
        ["host", "port", "socket"].map do |arglist|
          next if send(var).to_s.empty?
          "--#{option}='#{send(option)}'"
        end.compact.join(" ")
      end
      
      ##
      # Builds a MySQL compatible string for the additional options;Fi[@û=I".# @return [ Object ] The new array value.;FI"#;FI"# @since 2.1.0;Fi[[	@
iI"Ê        #
        # @example Persist the new values.
        #   pop.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|;Fi[	@
iI"Á        #
        # @example Persist the new values.
        #   pull.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|;Fi[	@,
iI"Ì        #
        # @example Persist the new values.
        #   pushAll.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          append_with("$pushAll");Fi[I"
end));FI"end;FI"end;FI"end;Fi[[	@ÂijI"      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  # hovercards fetch some the persons public profile data via json and display;Fi[	@"iBI"Á      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  def function(arglist);Fi[	@(i*I"Ÿ      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  
  private;Fi[@û=@w@wI"# @since 2.0.0;Fi[[	@Ù	iI"Î        #
        # @example Persist the new values.
        #   addToSet.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|;Fi[	@
iI"Î        #
        # @example Persist the new values.
        #   pull_all.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|;Fi[	@'
iI"Á        #
        # @example Persist the new values.
        #   push.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          append_with("$push");Fi[@û=I"<# @raise [ Errors::InvalidIndex ] If validation failed.;FI"#;FI"# @since 3.0.0;Fi[[	@®	iI"N        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var);Fi[	@®	i,I"L        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|;Fi[	@®	iBI"w        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!;Fi[@û=I"(# @example Is the object a number?.;FI"#   object.numeric?;FI"#;Fi[[	@G	iI"±      end
      
      # Is the float a number?
      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #;Fi[	@Q	iI"≥      end
      
      # Is the integer a number?
      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ true ] Always true.
      #;Fi[	@Z	iïI"¥      end
      
      # Is the object a number?
      #
      # @example Is the object a number?.
      #   object.numeric?
      #
      # @return [ false ] Always false.
      #;Fi[@û=I"0# @example Get the object as sort criteria.;FI"#   object.__sortable__;FI"#;Fi[[	@D	i	I"Û  module Extensions
    module FalseClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 0.
      #;Fi[	@Z	i;I"‹      end
      
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.
      #;Fi[	@â	i	I"Ú  module Extensions
    module TrueClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 1.
      #;Fi[@û=I"3# @param [ String, Symbol ] key The error key.;FI"@# @param [ Hash ] attributes The attributes to interpolate.;FI"#;Fi[[	@i-I"      #
      # @example Create the problem.
      #   error.problem("error", {})
      #
      # @param [ String, Symbol ] key The error key.
      # @param [ Hash ] attributes The attributes to interpolate.
      #
      # @return [ String ] The problem.
      #;Fi[	@i<I"      #
      # @example Create the summary.
      #   error.summary("error", {})
      #
      # @param [ String, Symbol ] key The error key.
      # @param [ Hash ] attributes The attributes to interpolate.
      #
      # @return [ String ] The summary.
      #;Fi[	@iKI"      #
      # @example Create the resolution.
      #   error.resolution("error", {})
      #
      # @param [ String, Symbol ] key The error key.
      # @param [ Hash ] attributes The attributes to interpolate.
      #
      # @return [ String ] The resolution.
      #;Fi[@û=I":# @return [ Array<Document> ] The matching documents.;FI"#;FI"# @since 3.0.0;Fi[[	@ëizI">      #   criteria.from_database(ids)
      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        ((var.size > 1) ? (any_in(:id => (var))) : (where(:id => (var.first)))).entries;Fi[	@ëiÖI"˚      #   criteria.from_identity_map(ids)
      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        var = [];Fi[	@¬i3I"/    #
    # @param [ Class ] klass The class of the document.
    # @param [ Hash ] idenfier The selector.
    #
    # @return [ Array<Document> ] The matching documents.
    #
    # @since 3.0.0
    def function(arglist)
      documents_for(var)[var].try(:values) if Mongoid.using_identity_map? and var;Fi[@û=I".# @param [ Class ] klass The model class.;FI"4# @param [ Hash ] spec The index specification.;FI"1# @param [ Hash ] options The index options.;Fi[[	@®	iI"T        #
        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.;Fi[	@®	i(I"Y        #
        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.;Fi[	@®	i>I"S        #
        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.;Fi[@û=I"# @since 2.0.0;FI"def function(arglist);F@Åri[[	@Ù	iI"        #   addToSet.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            document[field] = [] unless document[field]
            var = document.send(field);Fi[	@ 
iI"        #   inc.persist
        #
        # @return [ Object ] The new numeric value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            var = (document[field] or 0)
            document[field] = (var + value);Fi[	@
iI"        #   pull_all.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then
              var = document.send(field);Fi[@û=I"1# @return [ Array<Document> ] The documents.;FI"#;FI"# @since 3.0.0;Fi[[	@éi˝I"÷      #
      # @example Get the cached documents.
      #   context.documents
      #
      # @return [ Array<Document> ] The documents.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= [];Fi[	@ùiVI"æ    #
    # @example Get the documents.
    #   criteria.documents
    #
    # @return [ Array<Document> ] The documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= [];Fi[	@hi8I"        #
        # @param [ Array<Document> ] docs The documents.
        # @param [ Symbol ] method Delete or destroy.
        #
        # @return [ Array<Document> ] The documents.
        #
        # @since 3.0.0
        def function(arglist)
          var.each do |arglist|;Fi[@û=@⁄tI"#;FI"# @since 3.0.0;Fi[[	@Üi#I"ˇ      #   map_reduce.each do |doc|
      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        block_given? ? (documents.each { |arglist| yield(var) }) : (to_enum);Fi[	@ãibI"‘      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then;Fi[	@éirI"‘      #   context.each do |doc|
      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then;Fi[@û=I"5# @param [ String, Symbol ] name The config key.;FI"0# @param [ Hash ] config The configuration.;FI"#;Fi[[	@gi&I"3        #
        # @example Validate the session has database.
        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@gi5I"-        #
        # @example Validate the session has hosts.
        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@giEI")        #
        # @example Validate the uri and options.
        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist);Fi[@û=I"# @since 2.3.0;FI"def function(arglist);FI"@var ||= {};Fi[[	@ái
I"§    #   person.delayed_atomic_sets
    #
    # @return [ Hash ] The delayed $sets.
    #
    # @since 2.3.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[	@]iI"Æ      #   options.defaults
      #
      # @return [ Hash ] The default options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
      ;Fi[	@]i6I"Ø      #   options.settings
      #
      # @return [ Hash ] The setting options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
    end;Fi[@û=I"K# @param [ Document ] document The document to generate the paths for.;FI"#;FI"# @since 2.1.0;Fi[[	@0iI"#          #
          # @example Create the path util.
          #   Many.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent;Fi[	@7iI""          #
          # @example Create the path util.
          #   One.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent;Fi[	@CiI"!        #
        # @example Create the root path util.
        #   Root.new(document)
        #
        # @param [ Document ] document The document to generate the paths for.
        #
        # @since 2.1.0
        def function(arglist)
          @var, @var, @var, @var = var, "", "", "";Fi[@û=I"# @since 2.2.0;FI"def function(arglist);FI"@var ||= {};Fi[[	@-i’I"∏      #   modifiers.pull_fields
      #
      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      ;Fi[	@-i·I"∏      #   modifiers.push_fields
      #
      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      ;Fi[	@-iÌI"∂      #   modifiers.set_fields
      #
      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      ;Fi[@ÚaI""Success";F@˘uI""Warning";Fi[[	@Ñi1I"«      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[	@ëi/I"«      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[	@ói-I"«      #
      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure";Fi[I""Success";F@˘uI""Warning";FI"when :failure then;Fi[[	@Ñi2I"Ã      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[	@ëi0I"Ã      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[	@ói.I"Ã      def function(arglist)
        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else;Fi[@˘uI""Warning";F@”wI""Failure";Fi[[	@Ñi3I"«        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[	@ëi1I"«        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[	@ói/I"«        var = case var
        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing;Fi[I""Warning";F@”wI""Failure";FI"	else;Fi[[	@Ñi4I"º        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[	@ëi2I"º        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[	@ói0I"º        when :success then
          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end;Fi[@”wI""Failure";FI"	else;FI"# do nothing;Fi[[	@Ñi5I"Í          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var);Fi[	@ëi3I"∆          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s]" % var);Fi[	@ói1I"˝          "Success"
        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger}) (@ #{@model.time})" % var);Fi[I""Failure";FI"	else;FI"# do nothing;FI"end;Fi[[	@Ñi6I"        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger})" % var)
        send_message(var);Fi[	@ëi4I"Ã        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s]" % var)
        send_message(var);Fi[	@ói2I"        when :warning then
          "Warning"
        when :failure then
          "Failure"
        else
          # do nothing
        end
        var = ("[Backup::%s] #{@model.label} (#{@model.trigger}) (@ #{@model.time})" % var)
        send_message(var);Fi[@û=@d_@e_I"
begin;Fi[[	@≈i5I"”      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("bind")
          yield);Fi[	@≈iTI"‘      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("build")
          yield);Fi[	@≈i≠I"Á        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("create")
            yield);Fi[@û=@˝M@˛MI"return nil if var.blank?;Fi[[	@}	i+I"N        # @param [ Time ] object The time from Mongo.
        #
        # @return [ Time ] The object as a date.
        #
        # @since 3.0.0
        def function(arglist)
          return nil if var.blank?
          var = var.getlocal unless Mongoid::Config.use_utc?
          if Mongoid::Config.use_activesupport_time_zone? then;Fi[	@}	i?I"        # @param [ Object ] object The object to mongoize.
        #
        # @return [ Time ] The object mongoized.
        #
        # @since 3.0.0
        def function(arglist)
          return nil if var.blank?
          begin
            (var = var.__mongoize_time__;Fi[	@Ñ	iI"        # @param [ Time ] object The time from Mongo.
        #
        # @return [ TimeWithZone ] The object as a date.
        #
        # @since 3.0.0
        def function(arglist)
          return nil if var.blank?
          ::Time.demongoize(var).in_time_zone
        end;Fi[@|K@}KI"super(var, var);FI"@var ||= "backups";Fi[[	@•iI"      ##
      # Path to where the backups will be stored
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        @var ||= :app_folder
        instance_eval(&var) if block_given?;Fi[	@∂iI"Î      ##
      # Ninefold directory path
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end;Fi[	@æiI"ı      ##
      # Region of the specified S3 bucket
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end;Fi[@|K@}K@xI"@var ||= 22;Fi[[	@ªiI"‚      ##
      # Flag to use local backups
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        @var ||= false;Fi[	@√iI"ˆ      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?;Fi[	@»iI"ˆ      ##
      # Path to store backups to
      ##
      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= 22
        @var ||= "backups"
        instance_eval(&var) if block_given?;Fi[I"@var ||= "backups";FI"(instance_eval(&var) if block_given?;FI"end;FI" ;Fi[[	@†iI"∑      def function(arglist)
        super(var, var)
        @var ||= false
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@∂iI"’      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[	@æiI"’      # Creates a new instance of the storage object
      def function(arglist)
        super(var, var)
        @var ||= "backups"
        instance_eval(&var) if block_given?
      end
      
      private
      ;Fi[@û=@˝M@˛MI"
false;Fi[[	@Z	iéI"û      #   object.multi_arged?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      ;Fi[	@Z	iöI"°      #   object.numeric?
      #
      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      ;Fi[	@Z	iπI"ú      #   object.resizable?
      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      ;Fi[@û=@˝M@˛MI"var = clone;Fi[[	@ùi0I"1      # @param [ Hash ] options Additional query options.
      #
      # @return [ Criteria ] The scoped criteria.
      #
      # @since 3.0.0
      def function(arglist)
        var = clone
        var.options.merge!((var or {}))
        var.apply_default_scope if klass.default_scopable? and scoped?.!;Fi[	@ùiKI"Ó      #   criteria.unscoped
      #
      # @return [ Criteria ] The unscoped criteria.
      #
      # @since 3.0.0
      def function(arglist)
        var = clone
        unless unscoped? then
          var.scoping_options = false, true;Fi[	@ùiÅI"      #   criteria.with_default_scope
      #
      # @return [ Criteria ] The criteria.
      #
      # @since 3.0.0
      def function(arglist)
        var = clone
        if klass.default_scopable? and (unscoped?.! and scoped?.!) then
          var.apply_default_scope;Fi[@M@M@0MI"var = [];Fi[[	@•i^I"™      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from Dropbox."));Fi[	@±i'I"ñ      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << "#{storage_name} started removing '#{local_file}'.");Fi[	@√i<I"™      ##
      # Removes the transferred archive file(s) from the storage location.
      # Any error raised will be rescued during Cycling
      # and a warning will be logged, containing the error message.
      def function(arglist)
        var = remote_path_for(var)
        var = []
        transferred_files_for(var) do |arglist|
          (var << ("#{storage_name} started removing " + "'#{local_file}' from '#{ip}'."));Fi[@û=@˝M@˛MI"@var.!.!;Fi[[	@éi!I"∂      #   context.cached?
      #
      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      ;Fi[	@éiÒI"∫      #   context.cache_loaded?
      #
      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      ;Fi[	@ùiqI"™    #   criteria.embedded?
    #
    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    ;Fi[@û=@˝M@˛MI"@var ||= {};Fi[[	@ái"I"ß    #   document.delayed_atomic_unsets
    #
    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[	@≥i’I"¢    #   config.sessions
    #
    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    ;Fi[	@yiI"®      #   command.command
      #
      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      ;Fi[@õe@úe@/oI"connection do |arglist|;Fi[[	@™i9I"      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[	@√i-I"       end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          var.exec!("mkdir -p '#{remote_path}'")
          files_to_transfer_for(@var) do |arglist|;Fi[	@»i+I"      end
      
      ##
      # Transfers the archived file to the specified remote server
      def function(arglist)
        var = remote_path_for(@var)
        connection do |arglist|
          create_remote_path(var, var)
          files_to_transfer_for(@var) do |arglist|;Fi[@û=@˝M@˛MI"var.each_pair do |arglist|;Fi[[	@-i I"G      #   modifiers.pull_all({ "addresses" => { "street" => "Bond" }})
      #
      # @param [ Hash ] modifications The pull all modifiers.
      #
      # @since 3.0.0
      def function(arglist)
        var.each_pair do |arglist|
          add_operation(pull_alls, var, var)
          pull_fields[var.split(".", 2)[0]] = var;Fi[	@-i/I">      #   modifiers.pull({ "addresses" => { "_id" => { "$in" => [ 1, 2, 3 ]}}})
      #
      # @param [ Hash ] modifications The pull all modifiers.
      #
      # @since 3.0.0
      def function(arglist)
        var.each_pair do |arglist|
          pulls[var] = var
          pull_fields[var.split(".", 2)[0]] = var;Fi[	@®	i.I"S        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|
            unless VALID_OPTIONS.include?(var) then
              raise(Errors::InvalidIndex.new(var, var, var));Fi[I"A# the block from the user's configuration file is evaluated.;FI"def function(arglist);FI"
super;FI"(instance_eval(&var) if block_given?;Fi[[	@ﬂi'I"Y        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(arglist)
          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end;Fi[	@‰iI"Y        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and Cloud specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(arglist)
          super
          instance_eval(&var) if block_given?
          @var = path.sub(/^\//, "")
        end;Fi[	@ÓiI"=        # which in turn will invoke Syncer::Base.
        #
        # Once pre-configured defaults and RSync specific defaults are set,
        # the block from the user's configuration file is evaluated.
        def function(arglist)
          super
          instance_eval(&var) if block_given?
        end
        ;Fi[@û=I"# Returns nothing.;FI"def function(arglist);FI"
begin;Fi[[	@ÂiI"-    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin
        (self.content = File.read(File.join(var, var))
        if self.content =~ /\A(---\s*\n.*?\n?)^(---\s*$\n?)/m then;Fi[	@¸iYI"    # Extract information from the post filename.
    #
    # name - The String filename of the post file.
    #
    # Returns nothing.
    def function(arglist)
      begin
        (var, var, var, var, var = *var.match(MATCHER)
        self.date = Time.parse(var);Fi[	@!i•I"Ÿ    end
    
    # Render the site to the destination.
    #
    # Returns nothing.
    def function(arglist)
      begin
        (var = site_payload
        self.posts.each { |arglist| var.render(self.layouts, var) };Fi[I"if (var == 0) then;FI"@var = var;F@TlI"	else;Fi[[	@LiõI"Æ    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@OiñI"Æ    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[	@RiäI"Æ    if (var == 1) then
      @var = @var
    else
      if (var == 0) then
        @var = var
        @var = (var + var)
      else
        @var = var if (var == 2)
      end;Fi[I"attr_accessor(:source);FI" ;FI"def function(arglist);FI"@var = var;Fi[[	@6iI"±    
    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var;Fi[	@LiI"∞    
    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = [];Fi[	@"iI"¢    
    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var
      @var = var;Fi[@û=I"=# base - The String path to the dir containing the file.;FI".# name - The String filename of the file.;FI"#;Fi[[	@ÂiI"’    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@≠9i!I"’    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[	@¸i?I"’    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist);Fi[I"0@var = Hash.new { |arglist| var[var] = [] };FI"end;FI" ;FI"def function(arglist);Fi[[	@?iI"¥    def function(arglist)
      @var = []
      @var = {}
      @var = Hash.new { |arglist| var[var] = [] }
    end
    
    def function(arglist)
      super
      @var = @var.dup;Fi[	@ÏiI"÷        @var = ensure_io(var, "rerun")
        @var = var
        @var = []
        @var = Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var = []
        @var = var.file;Fi[	@˝iI"ÿ        @var = var
        @var = ensure_io(var, "usage")
        @var = var
        @var = Hash.new { |arglist| var[var] = [] }
      end
      
      def function(arglist)
        @var = var
        @var = Time.now;Fi[I"var = (var - var);FI"var = (var - var);FI"var = (var - var);FI"var = (var - var);Fi[[	@8i|I"º      end
      var.uniq!
      var.flatten!
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var);Fi[	@8i}I"ÿ      var.uniq!
      var.flatten!
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var.collect do |arglist|;Fi[	@8i~I"ˆ      var.flatten!
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var - var)
      var = (var.collect do |arglist|
        var = Pathname.new(var).basename.to_s;Fi[@ΩxI"-var = (var == 0) ? (10) : ((var / 20.0));FI"var = ((var + var) - var);FI",var = (scale_divisions or (var / 10.0));Fi[[	@˘iI"7      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@iI"7      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[	@	iTI"7      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = [];Fi[I"
true);FI"rescue LoadError;FI"
false;FI"end;Fi[[	@ßiäI"Ø        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end;Fi[	@¨i}I"Ø        return @var unless @var.nil?
        @var = begin
          (require("diff/lcs")
          true)
        rescue LoadError
          false
        end
      end
    end;Fi[	@èiUI"É    begin
      (require("rubygems")
      require("ruby-debug")
      true)
    rescue LoadError
      false
    end
    end
  end;Fi[I"(var << "  specs:\n");FI"end;FI" ;FI"def function(arglist);Fi[[	@Ji.I"†          (var << "  #{opt}: #{options[opt]}\n") if options[var]
        end
        (var << "  glob: #{@glob}\n") unless (@var == DEFAULT_GLOB)
        (var << "  specs:\n")
      end
      
      def function(arglist)
        Git.===(var) and ((uri == var.uri) and ((ref == var.ref) and ((branch == var.branch) and ((name == var.name) and ((version == var.version) and (submodules == var.submodules))))))
      end;Fi[	@Xi0I"¸        var = "PATH\n"
        (var << "  remote: #{relative_path}\n")
        (var << "  glob: #{@glob}\n") unless (@var == DEFAULT_GLOB)
        (var << "  specs:\n")
      end
      
      def function(arglist)
        "source at #{@path}"
      end;Fi[	@_i:I".      def function(arglist)
        var = "GEM\n"
        (var << remotes.map { |arglist| "  remote: #{r}\n" }.join)
        (var << "  specs:\n")
      end
      
      def function(arglist)
        var = self.remotes.map { |arglist| var.to_s }.join(", ")
        "rubygems repository #{remote_names}";Fi[I"(@var or @var);FI"end;FI" ;FI"def function(arglist);Fi[[	@Ji»I"ñ      end
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        options["revision"]
      end;Fi[	@ÉiàI"ü        end
        
        def function(arglist)
          (@var or @var)
        end
        
        def function(arglist)
          @var = var
        end;Fi[	@iI"m      include(Gherkin::Rubify)
      
      def function(arglist)
        (@var or @var)
      end
      
      def function(arglist)
        @var = Ast::Feature.new(nil, Ast::Comment.new(var.comments.map { |arglist| var.value }.join("\n")), Ast::Tags.new(nil, var.tags), var.keyword, var.name.lstrip, var.description.rstrip, [])
        @var.gherkin_statement(var);Fi[@û=I"# @example;FI"#   class Person;FI"$#     include Mongoid::Document;Fi[[	@ÙiáI"∞      end
      
      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #;Fi[	@ÙiòI"∞      end
      
      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #;Fi[	@Ùi©I"”      end
      
      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #;Fi[@û=@ﬂ`@‡`I"*# @example Eager load the inclusions.;Fi[[	@|iI"      
      # @attribute [rw] eager_loaded Has the context been eager loaded?
      # Eager load the inclusions for the provided documents.
      #
      # @api private
      #
      # @example Eager load the inclusions.
      #   context.eager_load(docs)
      #;Fi[	@|iI"»      end
      
      # Eager load the inclusions for the provided document.
      #
      # @api private
      #
      # @example Eager load the inclusions.
      #   context.eager_load(doc)
      #;Fi[	@|ixI"œ      end
      
      # Eager load the inclusions for the provided documents.
      #
      # @api private
      #
      # @example Eager load the inclusions.
      #   context.load_inclusions(docs)
      #;Fi[@û=@ipI"#   # => [;T@bri[[	@îiCI"á      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îidI"á      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[	@îi}I"á      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
      #   #    ]
      #
      #   person.pets.delete_all
      #   # => [
      #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
      #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
      #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>;Ti[@û=@◊@@ÿ@I"@var = var;Fi[[	@ñi’I"Û      #   table.map_headers!('Address' => 'ADDRESS') { |header| header.downcase }
      #   table.hashes.keys
      #   # => ['phone number', 'ADDRESS']
      #
      def function(arglist)
        @var = var
        @var = var
      end
      ;Fi[	@ciﬁI"  	# @param float :right Right margin. Default value is the left one.
  	# @since 1.0
  	# @see SetLeftMargin(), SetTopMargin(), SetRightMargin(), SetAutoPageBreak()
  	#
  def function(arglist)
    @var = var
    @var = var
    var = var if (var == -1)
    @var = var;Fi[	@ciI"Ÿ  	# @param float :margin Distance from the bottom of the page.
  	# @since 1.0
  	# @see Cell(), MultiCell(), AcceptPageBreak()
  	#
  def function(arglist)
    @var = var
    @var = var
    @var = (@var - var)
  end;Fi[I"	name;FI"end;FI" ;FI"def function(arglist);Fi[[	@ﬂ;iI"í  before_validation { |arglist| name.strip! }
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    case var
    when Post then;Fi[	@E\i&I"¨  end
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[	@H\i	I"ª  acts_as_nested_set
  
  def function(arglist)
    name
  end
  
  def function(arglist)
    var.call(self, lambda { |arglist| self.children.each { |arglist| var.recurse(&var) } })
  end;Fi[@û=@◊@I"2var = var.last.is_a?(Hash) ? (var.pop) : ({});FI"var = (var.first or var);Fi[[	@xi2I"    #
    #   directory "doc"
    #   directory "doc", "docs", :recursive => false
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var = (var.first or var)
      action(Directory.new(self, var, (var or var), var, &var))
    end;Fi[	@ÇiI"+    #   copy_file "README", "doc/README"
    #
    #   copy_file "doc/README"
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var = (var.first or var)
      var = File.expand_path(find_in_source_paths(var.to_s))
      create_file(var, nil, var) do |arglist|;Fi[	@Çi4I"    #   link_file "README", "doc/README"
    #
    #   link_file "doc/README"
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var = (var.first or var)
      var = File.expand_path(find_in_source_paths(var.to_s))
      create_link(var, var, var);Fi[@û=@◊@@*yI"var = var.first;Fi[[	@riI"    #   end
    #
    #   create_file "config/apache.conf", "your apache config"
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var = var.first
      action(CreateFile.new(self, var, (var or var.to_s), var))
    end;Fi[	@uiI"˙    # ==== Examples
    #
    #   create_link "config/apache.conf", "/etc/apache.conf"
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var = var.first
      action(CreateLink.new(self, var, var, var))
    end;Fi[	@ÇiLI":    #   get "http://gist.github.com/103208" do |content|
    #     content.split("\n").first
    #   end
    #
    def function(arglist)
      var = var.last.is_a?(Hash) ? (var.pop) : ({})
      var = var.first
      unless var =~ /^https?\:\/\// then
        var = File.expand_path(find_in_source_paths(var.to_s));Fi[I"
retry;FI"rescue;F@‰tI"end;Fi[[	@ÄiI"˚          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@ÄiCI"˚          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[	@ÄiÅI"˚          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end;Fi[@û=I"#   class Comment;FI"+#     include ActiveModel::Validations;FI"#;Fi[[	@ï7i;I"      # you're looking for more descriptive declaration of your validations.
      #
      # This can be done with a symbol pointing to a method:
      #
      #   class Comment
      #     include ActiveModel::Validations
      #
      #     validate :must_be_friends
      #;Fi[	@ï7iGI"       #   end
      #
      # With a block which is passed with the current record to be validated:
      #
      #   class Comment
      #     include ActiveModel::Validations
      #
      #     validate do |comment|
      #       comment.must_be_friends;Fi[	@ï7iUI"@      #   end
      #
      # Or with a block where self points to the current record to be validated:
      #
      #   class Comment
      #     include ActiveModel::Validations
      #
      #     validate do
      #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee);Fi[@û=I"# Example:;FI",#   rename_table('octopuses', 'octopi');FI"def function(arglist);Fi[[	@IiºI"˜      end
      
      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(arglist)
        execute("RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}")
      end;Fi[	@ÉiﬁI"w        # Renames a table.
        # Also renames a table's primary key sequence if the sequence name matches the
        # Active Record default.
        #
        # Example:
        #   rename_table('octopuses', 'octopi')
        def function(arglist)
          clear_cache!
          execute("ALTER TABLE #{quote_table_name(name)} RENAME TO #{quote_table_name(new_name)}");Fi[	@çi~I"˙      end
      
      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi')
      def function(arglist)
        exec_query("ALTER TABLE #{quote_table_name(name)} RENAME TO #{quote_table_name(new_name)}")
      end;Fi[@û=@«U@CoI"#   end;Fi[[	@ï7iºI"Ω    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@ï7iÕI"Ω    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[	@ï7iÙI"Ω    #
    #   class Person
    #     include ActiveModel::Validations
    #
    #     attr_accessor :name
    #     validates_presence_of :name
    #   end
    #
    #   person = Person.new;Fi[@û=@ıF@uuI"#   end;Ti[[	@îi≥I")      # with +attributes+ and linked to this object, but have not yet been saved.
      # You can pass an array of attributes hashes, this will return an array
      # with the new objects.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.build;Ti[	@îiŒI"G      # Returns a new object of the collection type that has been instantiated with
      # attributes, linked to this object and that has already been saved (if it
      # passes the validations).
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   person.pets.create(name: 'Fancy-Fancy');Ti[	@îiÍI"∆      end
      
      # Like +create+, except that if the record is invalid, raises an exception.
      #
      #   class Person
      #     has_many :pets
      #   end
      #
      #   class Pet;Ti[I"@var = var if var;FI"	@var;FI"end;FI" ;Fi[[	@åi!I"‘      
      # Stores and return the source root for this class
      def function(arglist)
        @var = var if var
        @var
      end
      
      # Returns the source paths in the following order:
      #;Fi[	@A*iI"ºmodule Jekyll
  class Converter < Plugin
    def self.pygments_prefix(arglist)
      @var = var if var
      @var
    end
    
    def self.pygments_suffix(arglist)
      @var = var if var;Fi[	@A*iI"à    end
    
    def self.pygments_suffix(arglist)
      @var = var if var
      @var
    end
    
    # Initialize the converter.
    #;Fi[I"var.unshift(var);FI"var = nil;FI"	else;F@moi[[	@$i¯I"”    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@$iI"Á      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[	@$iI"”    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil;Fi[I"rescue NotImplementedError;FI"# do nothing;FI"end;FI"	else;Fi[[	@ôi*I"˛          if var.symlink? then
            begin
              File.lchown(var.uid, var.gid, var)
            rescue NotImplementedError
              # do nothing
            end
          else
            File.chown(var.uid, var.gid, var)
          end;Fi[	@ôi4I"˛          if var.symlink? then
            begin
              File.lchmod(var.mode.&(1023), var)
            rescue NotImplementedError
              # do nothing
            end
          else
            File.chmod(var.mode.&(1023), var)
          end;Fi[	@ôi>I"Ó          if var.symlink? then
            begin
              File.lchmod(var.mode, var)
            rescue NotImplementedError
              # do nothing
            end
          else
            File.chmod(var.mode, var)
          end;Fi[@´bI"var = 0;FI"while (var < var) do;F@ãki[[	@LiAI"   def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@Oi1I"   def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[	@Ri0I"   def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr];Fi[@´bI">var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n");FI"var = 0;FI"if var then;Fi[[	@Li_I"    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[	@OiTI"    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[	@RiNI"    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB";Fi[@πb@∫bI"&def self.required_fields(arglist);FI"[];Fi[[	@ïi	I"•module Devise
  module Models
    module Omniauthable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      ;Fi[	@õiI"•module Devise
  module Models
    module Registerable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      ;Fi[	@£i	I"§module Devise
  module Models
    module Timeoutable
      extend(ActiveSupport::Concern)
      
      def self.required_fields(arglist)
        []
      end
      ;Fi[I"def self.process(arglist);FI"evar = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8");FI" FileUtils.mkdir_p("_posts");FI"!var[QUERY].each do |arglist|;Fi[[	@ iI"N    
    QUERY = "SELECT id,                     permalink,                     body,                     published_at,                     title              FROM contents              WHERE user_id = 1 AND                    type = 'Article' AND                    published_at IS NOT NULL              ORDER BY published_at"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:title]
        var = var[:permalink];Fi[	@iI"@  module MT
    QUERY = "SELECT entry_id,                     entry_basename,                     entry_text,                     entry_text_more,                     entry_authored_on,                     entry_title,                     entry_convert_breaks              FROM mt_entry"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:entry_title]
        var = var[:entry_basename].gsub(/_/, "-");Fi[	@iI"
  module TextPattern
    QUERY = "SELECT Title,                     url_title,                     Posted,                     Body,                     Keywords              FROM textpattern              WHERE Status = '4' OR                    Status = '5'"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:Title]
        var = var[:url_title];Fi[@µ I":# Runs state events around the machine's :save action;FI"def function(arglist);F@~qi[[	@ûiBI"Î          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@∫i;I"Î          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[	@¬i?I"Î          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      ;Fi[I";# Increments the given revision number and returns it.;FI"def function(arglist);F@!sI"end;Fi[[	@[iBI"           var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        private;Fi[	@{i9I"          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[	@Çi@I">          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        
        # Determines what the response should be for a particular bit of text;Fi[@µ I"H# Uses around callbacks to run state events if using the :save hook;FI"def function(arglist);FI"#if (action_hook == :save) then;Fi[[	@ûi9I"5      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[	@∫i2I"E        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[	@¬i6I"T        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else;Fi[I"I# Returns the command that will sync the given revision to the given;FI"L# destination directory. The perforce client has a fixed destination so;FI"K# the files must be copied from there to their intended resting place.;FI"def function(arglist);Fi[[	@{iI"e          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@{iI"~          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[	@{i"I"~          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end;Fi[@ﬂy@‡y@·y@si[[	@{iI"]        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@{iI"]        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[	@{i#I"]        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        ;Fi[@‡y@·y@sI"end;Fi[[	@{iI"û        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@{iI"û        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given;Fi[	@{i$I"°        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will do an "p4 diff2" for the two revisions.;Fi[I"9require("capistrano/recipes/deploy/strategy/remote");FI"module Capistrano;FI"module Deploy;FI"module Strategy;Fi[[	@ëi I"örequire("capistrano/recipes/deploy/strategy/remote")
module Capistrano
  module Deploy
    module Strategy
      class Checkout < Remote
        protected;Fi [	@õi I"òrequire("capistrano/recipes/deploy/strategy/remote")
module Capistrano
  module Deploy
    module Strategy
      class Export < Remote
        protected;Fi [	@•i I"ÿrequire("capistrano/recipes/deploy/strategy/remote")
module Capistrano
  module Deploy
    module Strategy
      class RemoteCache < Remote
        # Executes the SCM command for this strategy and writes the REVISION;Fi [@µ @ïo@ño@âqi[[	@ûiI"≤      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@∫iI"≤      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[	@¬iI"≤      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      ;Fi[I"@var = (@var + var);F@
Z@=aI"var = (var + 1);Fi[[	@LiŒI".        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@RiΩI".        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[	@Ui®I"        if (var == -1) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next;Fi[@µ I"L# Describes the current validation errors on the given object.  If none;FI"F# are specific, then the default error is interpeted as a "halt".;FI"def function(arglist);Fi[[	@îi$I"A          var.errors.add(var, var, var.merge(var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted";Fi[	@≤iI"X          var.errors.add(self.attribute(var), generate_message(var, var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted";Fi[	@ i!I"f      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted";Fi[@µ I"Aattr_reader(:plugin_path, :plugin_name, :plugin_pretty_name);FI" ;FI"def function(arglist);Fi[[	@oiI"˛class RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore;Fi[	@oiI"  argument(:controller, :type => :string)
  
  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore;Fi[	@ÄiI"f  class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore;Fi[@µ @UcI" ;FI"def function(arglist);Fi[[	@@iI"      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end;Fi[	@QiI"–      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        attributes.keys
      end;Fi[	@WiI"      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end;Fi[I"if var.delete(:erb) then;FI"?var = TemplateContext.ctx(:to => (var), :options => (var));FI" var = process_erb(var, var);FI"end;Fi[[	@iTI"/            copy(var, var, nil, var)
          else
            var = File.new(var).read
            if var.delete(:erb) then
              var = TemplateContext.ctx(:to => (var), :options => (var))
              var = process_erb(var, var)
            end
            write_file(var, var)
          end;Fi[	@ieI"≈        var = templatize(var)
        var = targetize(install_location_for_stylesheet(var, var))
        var = File.new(var).read
        if var.delete(:erb) then
          var = TemplateContext.ctx(:to => (var), :options => (var))
          var = process_erb(var, var)
        end
        if preferred_syntax.to_s.!=(var[(-4..-1)]) then
          var = Sass::Engine.new(var, Compass.sass_engine_options.merge(:syntax => (var[(-4..-1)].intern))).to_tree;Fi[	@ièI"Ñ            var = install_location_for_html(var, var)
          end
          var = File.read(templatize(var))
          if var.delete(:erb) then
            var = TemplateContext.ctx(:to => (var), :options => (var))
            var = process_erb(var, var)
          end
          Compass.configure_sass_plugin!
          var = Haml::Engine.new(var, :filename => (templatize(var))).render;Fi[I"9Sass::Script::List.new(var.value.dup, var.separator);FI"	else;FI"*Sass::Script::List.new([var], :space);FI"end;Fi[[	@+iI"V    # returns the opposite position of a side or corner.
    def function(arglist)
      var = if var.is_a?(Sass::Script::List) then
        Sass::Script::List.new(var.value.dup, var.separator)
      else
        Sass::Script::List.new([var], :space)
      end
      var.value.map! do |arglist|
        if var.is_a?(Sass::Script::String) then;Fi[	@$i¿I"á    def function(arglist)
      var = var
      var = if var.is_a?(Sass::Script::List) then
        Sass::Script::List.new(var.value.dup, var.separator)
      else
        Sass::Script::List.new([var], :space)
      end
      return var unless var.value.all? { |arglist| is_position(var).to_bool }
      if (var.value.first.value =~ /top|bottom/ or var.value.last.value =~ /left|right/) then;Fi[	@çi.I"˝  # into a string by sass before it was passed to a mixin.
  def function(arglist)
    if var.is_a?(Sass::Script::List) then
      Sass::Script::List.new(var.value.dup, var.separator)
    else
      Sass::Script::List.new([var], :space)
    end
  end
  ;Fi[@µ @kI" ;F@Sci[[	@@iI"÷      undef_method(:attributes)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line);Fi[	@QiI"“      undef_method(:values)
      
      undef_method(:content)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line);Fi[	@ZiI"ﬁ      undef_method(:attribute_nodes)
      
      undef_method(:attributes)
      
      undef_method(:namespace)
      
      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line);Fi[I"if color_stop?(var) then;FI"var.unshift(var);FI"var = nil;FI"	else;Fi[[	@$i˜I"«    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var);Fi[	@$iI"ﬂ        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var);Fi[	@$iI"«    end
    
    def function(arglist)
      if color_stop?(var) then
        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var);Fi[@mo@noI"var = nil;FI"end;Fi[[	@$i˚I"‘        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@$iI"‘        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[	@$iI"‘        var.unshift(var)
        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!;Fi[@noI"var = nil;FI"end;FI"end;Fi[[	@$i¸I"⁄        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if color_stop?(var) then;Fi[	@$iI"˝        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      if (var.size == 1) and list_of_color_stops?(var.first) then;Fi[	@$iI"        var = nil
      else
        if list_of_color_stops?(var) then
          var = (var.value + var)
          var = nil
        end
      end
      var = nil if var and var.to_bool.!
      var = var if (var.size == 1) and var = list_of_color_stops?(var.first);Fi[I"if var.to_bool then;FI".Sass::Script::String.new(clean_path(var));FI"	else;FI"clean_url(var);Fi[[	@Øi&I"         end
      end
      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end;Fi[	@Øi?I"‡        Compass.configuration.http_fonts_path
      end
      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end;Fi[	@ØirI"‚        end
      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end;Fi[@|zI"	else;FI"clean_url(var);FI"end;Fi[[	@Øi'I"ƒ      end
      var = "#{http_stylesheets_path}/#{path.value}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[	@Øi@I"∏      end
      var = "#{http_fonts_path}/#{path}"
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[	@ØisI"‹      end
      var = "#{asset_host}#{"/" unless (path[(0..0)] == "/")}#{path}" if var
      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end;Fi[I"clean_url(var);FI"end;FI"end;FI"end;Fi[[	@Øi)I"ô      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module FontUrl;Fi[	@ØiBI"ö      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module ImageUrl;Fi[	@ØiuI"£      if var.to_bool then
        Sass::Script::String.new(clean_path(var))
      else
        clean_url(var)
      end
    end
  end
  
  module GeneratedImageUrl;Fi[I",require("cucumber/ast/feature_element");FI""require("cucumber/ast/names");FI"module Cucumber;FI"module Ast;Fi[[	@ii I"ïrequire("cucumber/ast/feature_element")
require("cucumber/ast/names")
module Cucumber
  module Ast
    class Background
      include(FeatureElement);Fi [	@äi I"ìrequire("cucumber/ast/feature_element")
require("cucumber/ast/names")
module Cucumber
  module Ast
    class Scenario
      include(FeatureElement);Fi [	@çi I"örequire("cucumber/ast/feature_element")
require("cucumber/ast/names")
module Cucumber
  module Ast
    class ScenarioOutline
      include(FeatureElement);Fi [I"include(FeatureElement);FI" ;FI"include(Names);FI" ;Fi[[	@ii
I"ûmodule Cucumber
  module Ast
    class Background
      include(FeatureElement)
      
      include(Names)
      
      attr_reader(:feature_elements)
      ;Fi[	@äi
I"êmodule Cucumber
  module Ast
    class Scenario
      include(FeatureElement)
      
      include(Names)
      
      attr_reader(:line)
      ;Fi[	@çi
I"∞module Cucumber
  module Ast
    class ScenarioOutline
      include(FeatureElement)
      
      include(Names)
      
      module ExamplesArray
        def function(arglist);Fi[I"@var.accept_hook?(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@uiDI"£      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        init
        var = @var.index(var);Fi[	@Éi"I"õ      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist)
        @var.source_tags
      end;Fi[	@ÉiÑI"´        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end;Fi[@µ I"L# Execute the cascading deletion for the relation if it already exists.;FI"I# This should be optimized in the future potentially not to load all;FI"# objects from the db.;Fi[[	@2iI"O          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[	@;iI"P          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.;Fi[	@IiI"O          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.;Fi[@µ I" # Unbind a single document.;FI"#;FI"$# @example Unbind the document.;Fi[[	@≠
iI"÷              end
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.addresses.unbind_one(document)
          #;Fi[	@Œ
iI"          def function(arglist)
            binding { |arglist| bind_from_relational_parent(var) }
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.posts.unbind_one(document)
          #;Fi[	@’
iI"              var.synced[metadata.inverse_foreign_key] = true
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.preferences.unbind_one(document)
          #;Fi[I"$attr_reader(:gherkin_statement);FI" ;FI"def function(arglist);FI"@var ||= var;Fi[[	@riI"æ        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@uiI"‘        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[	@êiI"≥        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end
      ;Fi[@µ I"# Obtain destination path.;FI"#;FI"5# dest - The String path to the destination dir.;Fi[[	@≠9itI"    def function(arglist)
      self.data.deep_merge("url" => (File.join(@var, self.url)), "content" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.;Fi[	@¸i¿I"7      var = { "site" => ({ "related_posts" => (related_posts(var["site"]["posts"])) }), "page" => (self.to_liquid) }.deep_merge(var)
      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.;Fi[	@÷4iI"Õ    def function(arglist)
      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.;Fi[@{SI"newobj;F@}SI"<var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH");Fi[[	@LiˆI"G      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[	@OiˇI"G      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[	@RiÂI"G      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!;Fi[@{S@Ôz@}SI"out("<</Type /Font");Fi[[	@LiI"Œ      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[	@OiI"Œ      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[	@Ri˜I"Œ      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var);Fi[@µ I"!# Read the YAML frontmatter.;FI"#;F@¶xi[[	@ÂiI"Ÿ    def function(arglist)
      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@≠9iI"Î      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[	@¸i=I"˝        self.categories = self.data.pluralized_array("category", "categories")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #;Fi[I"broadcast(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@ûiI"∞      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[	@ûi'I"ñ      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var, var)
      end;Fi[	@ûilI"∞      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end;Fi[@Pd@Qd@RdI"end;Fi[[	@∏i6I"º          else
            @var.puts(format_string(var.backtrace_line, var))
          end
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist);Fi[	@Êi6I"†      
      def function(arglist)
        if (@var == 1) then
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist);Fi[	@MiI"        end
        
        def function(arglist)
          @var.puts
          @var.flush
        end
      end
    end
  end;Fi[@µ @ÿzI" ;F@⁄zi[[	@riI"”      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[	@uiI"È      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[	@êiI"»      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var
      end;Fi[@◊:@ÿ:I"end;FI" ;Fi[[	@∏i7I"Ô            @var.puts(format_string(var.backtrace_line, var))
          end
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        @var = step_mother.scenarios(:failed).select do |arglist|;Fi[	@Êi7I"Õ      def function(arglist)
        if (@var == 1) then
          @var.puts
          @var.flush
        end
      end
      
      def function(arglist)
        var = format_string(var, :tag).indent(@var);Fi[	@ÏiI"Ó        unless @var.empty? then
          after_first_time { |arglist| @var.print(" ") }
          @var.print("#{@file}:#{@lines.join(":")}")
          @var.flush
        end
      end
      
      def function(arglist)
        @var.close;Fi[@◊:@ÿ:@*{I"end;Fi[[	@∏iïI"—          if @var then
            @var.puts
            var.each { |arglist| @var.puts(format_string(var, :tag)) }
            @var.flush
          end
        end
      end
      
      def function(arglist);Fi[	@Hi$I"∞            @var.print(red(sprintf("%.7f", var)))
            @var.puts(" #{description} #{example}")
          end
          @var.flush
        end
      end
    end
  end
end;Fi[	@MiI"|        
        def function(arglist)
          @var.puts
          @var.flush
        end
      end
    end
  end
end;Fi[@µ I"attr_accessor(:options);FI" ;FI"def function(arglist);Fi[[	@iI"Ã      include(Actions)
      
      attr_accessor(:template_path, :target_path, :working_path)
      
      attr_accessor(:options)
      
      def function(arglist)
        @var = var
        @var = var;Fi[	@<i	I"îmodule Haml
  class Compiler
    include(Haml::Util)
    
    attr_accessor(:options)
    
    def function(arglist)
      @var = var
      @var = 0;Fi[	@h$i	I"imodule OmniAuth
  class Form
    DEFAULT_CSS = "    body {\n      background: #ccc;\n      font-family: \"Lucida Grande\", \"Lucida Sans\", Helvetica, Arial, sans-serif;\n    }\n\n    h1 {\n      text-align: center;\n      margin: 30px auto 0px;\n      font-size: 18px;\n      padding: 10px 10px 15px;\n      background: #555;\n      color: white;\n      width: 320px;\n      border: 10px solid #444;\n      border-bottom: 0;\n      -moz-border-radius-topleft: 10px;\n      -moz-border-radius-topright: 10px;\n      -webkit-border-top-left-radius: 10px;\n      -webkit-border-top-right-radius: 10px;\n      border-top-left-radius: 10px;\n      border-top-right-radius: 10px;\n    }\n\n    h1, form {\n      -moz-box-shadow: 2px 2px 7px rgba(0,0,0,0.3);\n      -webkit-box-shadow: 2px 2px 7px rgba(0,0,0,0.3);\n    }\n\n    form {\n      background: white;\n      border: 10px solid #eee;\n      border-top: 0;\n      padding: 20px;\n      margin: 0px auto 40px;\n      width: 300px;\n      -moz-border-radius-bottomleft: 10px;\n      -moz-border-radius-bottomright: 10px;\n      -webkit-border-bottom-left-radius: 10px;\n      -webkit-border-bottom-right-radius: 10px;\n      border-bottom-left-radius: 10px;\n      border-bottom-right-radius: 10px;\n    }\n\n    label {\n      display: block;\n      font-weight: bold;\n      margin-bottom: 5px;\n    }\n\n    input {\n      font-size: 18px;\n      padding: 4px 8px;\n      display: block;\n      margin-bottom: 10px;\n      width: 280px;\n    }\n\n    input#identifier, input#openid_url {\n      background: url(http://openid.net/login-bg.gif) no-repeat;\n      background-position: 0 50%;\n      padding-left: 18px;\n    }\n\n    button {\n      font-size: 22px;\n      padding: 4px 8px;\n      display: block;\n      margin: 20px auto 0;\n    }\n\n    fieldset {\n      border: 1px solid #ccc;\n      border-left: 0;\n      border-right: 0;\n      padding: 10px 0;\n    }\n\n    fieldset input {\n      width: 260px;\n      font-size: 16px;\n    }\n"
    
    attr_accessor(:options)
    
    def function(arglist)
      var[:title] ||= "Authentication Info Required"
      var[:header_info] ||= "";Fi[@µ @ﬁy@ﬂy@‡yi[[	@{iI"w        def function(arglist)
          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[	@{iI"ê        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[	@{i!I"ê        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags);Fi[I"(@var << "</div>");FI"end;FI" ;FI"def function(arglist);Fi[[	@«iYI"™      end
      
      def function(arglist)
        (@var << "</div>")
      end
      
      def function(arglist)
        (@var << "<pre class=\"comment\">")
      end;Fi[	@«iÅI"Ÿ      
      def function(arglist)
        @var = nil
        (@var << "</div>")
      end
      
      def function(arglist)
        @var = true
        @var.h3(:id => ("background_#{@scenario_number}")) do |arglist|;Fi[	@«i≤I"ø      end
      
      def function(arglist)
        (@var << "</div>")
      end
      
      def function(arglist)
        @var.h4 do |arglist|
          @var.span(var, :class => "keyword");Fi[I"@var.text!(" ");FI"$@var.span(var, :class => "val");FI"end;FI"end;Fi[[	@«iàI"        @var = true
        @var.h3(:id => ("background_#{@scenario_number}")) do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist);Fi[	@«iûI"        @var = false
        @var.h3(:id => ("scenario_#{@scenario_number}")) do |arglist|
          @var.span((var + ":"), :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist);Fi[	@«i∏I"„      def function(arglist)
        @var.h4 do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist);Fi[@]{I"end;FI"end;FI" ;Fi[[	@«iâI"        @var.h3(:id => ("background_#{@scenario_number}")) do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = (@var + 1);Fi[	@«iüI"	        @var.h3(:id => ("scenario_#{@scenario_number}")) do |arglist|
          @var.span((var + ":"), :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = 0;Fi[	@«iπI"‡        @var.h4 do |arglist|
          @var.span(var, :class => "keyword")
          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        (@var << "<ol>");Fi[I"@var = 1;FI"end;FI" ;FI"def function(arglist);Fi[[	@Êi?I"◊        var = format_string(var, :tag).indent(@var)
        @var.print(var)
        @var.flush
        @var = 1
      end
      
      def function(arglist)
        @var.puts("#{keyword}: #{name}")
        @var.puts;Fi[	@Ui…I"à  end
  
  def function(arglist)
    @var = 1
  end
  
  def function(arglist)
    return if (@var == 3)
    self.AddPage if (@var == 0);Fi[	@UiGI"Å  end
  
  def function(arglist)
    @var = 1
  end
  
  def function(arglist)
    @var = (@var + 1)
    @var[@var] = @var.length;Fi[I"end.call;FI"end;FI" ;FI"def function(arglist);Fi[[	@
i`I"          proc do |arglist|
            invoke(var, "Around", var, true) { |arglist| var.call(var) }
          end
        end.call
      end
      
      def function(arglist)
        hooks_for(:before, var).each { |arglist| invoke(var, "Before", var, true) }
      end;Fi[	@=iqI"      def function(arglist)
        @var.reverse.inject(var) do |arglist|
          proc { |arglist| var.around(var) { |arglist| var.call(var) } }
        end.call
      end
      
      def function(arglist)
        @var.map { |arglist| var.step_definitions }.flatten
      end;Fi[	@óiùI"d    @var ||= Proc.new do |arglist|
      var = postgres? ? ("ASC") : ("DESC")
      ["contacts.user_id #{order}", "profiles.last_name ASC", "profiles.first_name ASC"]
    end.call
  end
  
  def function(arglist)
    fix_profile if self.profile.nil?
    @var ||= Person.name_from_attrs(self.profile.first_name, self.profile.last_name, self.diaspora_handle);Fi[I"if (var > var) then;FI"*if ((var == -1) or (var == var)) then;FI"if (@var > @var) then;FI"@var = @var;Fi[[	@Li I":      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var);Fi[	@Oi“I"Ú          var = var
        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var);Fi[	@RiπI":      end
      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var);Fi[@µ @»y@…y@!si[[	@[iAI"„          var = scm("revno", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[	@{i8I"8          var = scm(authentication, :changes, "-s submitted", "-m 1", "//#{p4client}/...#{rev_no(revision)}")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[	@Çi?I"˛          end
          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end
        ;Fi[I"include(ViewPathTemplates);FI" ;FI"Nsource_root(File.expand_path("../../../../app/views/devise", "(string)"));FI" ;Fi[[	@§i+I"	    end
    
    class SharedViewsGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("../../../../app/views/devise", "(string)"))
      
      desc("Copies shared Devise views to your application.")
      ;Fi[	@§i:I"    end
    
    class FormForGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("../../../../app/views/devise", "(string)"))
      
      desc("Copies default Devise views to your application.")
      ;Fi[	@§iNI"    end
    
    class ErbGenerator < Rails::Generators::Base
      include(ViewPathTemplates)
      
      source_root(File.expand_path("../../../../app/views/devise", "(string)"))
      
      desc("Copies Devise mail erb views to your application.")
      ;Fi[@´dI"module Atomic;FI"module Paths;FI"module Embedded;Fi[[	@0i I"ymodule Mongoid
  module Atomic
    module Paths
      module Embedded
        class Many
          include(Embedded);Fi [	@7i I"xmodule Mongoid
  module Atomic
    module Paths
      module Embedded
        class One
          include(Embedded);Fi [	@>iI"ırequire("mongoid/atomic/paths/embedded/one")
require("mongoid/atomic/paths/embedded/many")
module Mongoid
  module Atomic
    module Paths
      module Embedded
        attr_reader(:delete_modifier, :document, :insert_modifier, :parent)
        ;Fi[@´d@¨d@≠dI"module Embedded;Fi[[	@¢
i I"∂module Mongoid
  module Relations
    module Bindings
      module Embedded
        class In < Binding
          # Binds the base object to the inverse of the relation. This is so we;Fi [	@≠
i I"¨module Mongoid
  module Relations
    module Bindings
      module Embedded
        class Many < Binding
          # Binds a single document with the inverse relation. Used;Fi [	@¥
i I"∑module Mongoid
  module Relations
    module Bindings
      module Embedded
        class One < Binding
          # Binds the base object to the inverse of the relation. This is so we;Fi [@µ I"H# Returns the command that will check out the given revision to the;FI"# given destination.;FI"def function(arglist);Fi[[	@[iI"         def function(arglist)
          :head
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, "--lightweight", revswitch(var), repository, var)
        end;Fi[	@`iI"h        def function(arglist)
          "HEAD"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          [prep_destination(var), scm(verbose, cvs_root, :checkout, cvs_revision(var), cvs_destination(var), variable(:scm_module))].join(" && ")
        end;Fi[	@ÇiI"K        def function(arglist)
          "HEAD"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, arguments, arguments(:checkout), verbose, authentication, "-r#{revision}", repository, var)
        end;Fi[@´d@¨d@‹dI"module Embedded;Fi[[	@Ë
i I"±module Mongoid
  module Relations
    module Builders
      module Embedded
        class In < Builder
          # This builder doesn't actually build anything, just returns the;Fi [	@Ò
i I"±module Mongoid
  module Relations
    module Builders
      module Embedded
        class Many < Builder
          # Builds the document out of the attributes using the provided;Fi [	@¯
i I"∞module Mongoid
  module Relations
    module Builders
      module Embedded
        class One < Builder
          # Builds the document out of the attributes using the provided;Fi [@µ @≤y@≥yI" FileUtils.mkdir_p("_posts");Fi[[	@ iI"8    end
    
    QUERY = "SELECT id,                     permalink,                     body,                     published_at,                     title              FROM contents              WHERE user_id = 1 AND                    type = 'Article' AND                    published_at IS NOT NULL              ORDER BY published_at"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:title];Fi[	@iI"module Jekyll
  module MT
    QUERY = "SELECT entry_id,                     entry_basename,                     entry_text,                     entry_text_more,                     entry_authored_on,                     entry_title,                     entry_convert_breaks              FROM mt_entry"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:entry_title];Fi[	@iI"˙module Jekyll
  module TextPattern
    QUERY = "SELECT Title,                     url_title,                     Posted,                     Body,                     Keywords              FROM textpattern              WHERE Status = '4' OR                    Status = '5'"
    
    def self.process(arglist)
      var = Sequel.mysql(var, :user => (var), :password => (var), :host => (var), :encoding => "utf8")
      FileUtils.mkdir_p("_posts")
      var[QUERY].each do |arglist|
        var = var[:Title];Fi[I"var.json do |arglist|;FI"8render(:json => (@var.stream_posts.map do |arglist|;FI"ILastThreeCommentsDecorator.new(PostPresenter.new(var, current_user));FI"
end));Fi[[	@ÂigI">    end
    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end;Fi[	@"i?I"\    respond_with do |arglist|
      var.html { |arglist| render("layouts/main_stream") }
      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end;Fi[	@(i'I"    gon.tagFollowings = tags if user_signed_in?
    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end;Fi[I"redirect_to(:back);FI"end;FI"end;FI" ;Fi[[	@€iGI"æ  def function(arglist)
    unless AppConfig.settings.invitations.open? then
      flash[:error] = I18n.t("invitations.create.no_more")
      redirect_to(:back)
    end
  end
  
  private
  ;Fi[	@iI"      @var.errors.delete(:person)
      flash[:error] = @var.errors.full_messages.join(" - ")
      Rails.logger.info("event=registration status=failure errors='#{@user.errors.full_messages.join(", ")}'")
      redirect_to(:back)
    end
  end
  
  def function(arglist)
    super;Fi[	@ıilI"…      else
        flash[:error] = t("users.destroy.no_password")
      end
      redirect_to(:back)
    end
  end
  
  def function(arglist)
    if @var = User.find_by_username(params[:username]) then;Fi[I"Fvar.json { |arglist| render(:nothing => (true), :status => 204) };FI"end;FI"end;FI" ;Fi[[	@«iI"    end
    respond_with do |arglist|
      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  def function(arglist)
    if current_user.blocks.find(params[:id]).delete then;Fi[	@«i I"¿    end
    respond_with do |arglist|
      var.html { |arglist| redirect_to(:back, var) }
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  private
  ;Fi[	@Ìi I"     @var = Like.find_by_id_and_author_id!(params[:id], current_user.person.id)
    current_user.retract(@var)
    respond_to do |arglist|
      var.json { |arglist| render(:nothing => (true), :status => 204) }
    end
  end
  
  #I can go when the old stream goes.
  def function(arglist);Fi[I"/render(:nothing => (true), :status => 404);FI"end;FI"end;FI" ;Fi[[	@i5I"      var = OEmbedPresenter.new(var, params.slice(:format, :maxheight, :minheight))
      render(:json => (var))
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    var = Post.visible_from_author(@var.author, current_user).newer(@var);Fi[	@i$I"Í    if @var.present? and @var.local? then
      render("publics/hcard")
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    render("host_meta", :content_type => "application/xrd+xml");Fi[	@ıiñI"”    if var.present? then
      redirect_to(var.image_url)
    else
      render(:nothing => (true), :status => 404)
    end
  end
  
  def function(arglist)
    if current_user.confirm_email(params[:token]) then;Fi[@µ I"def self.included(arglist);FI"var.extend(ClassMethods);FI"end;Fi[[	@åiI"†class Thor
  module Actions
    attr_accessor(:behavior)
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods;Fi[	I"0data//cancan_proj/cancan/model_additions.rb;TiI"ú        var.model_adapter(self, var).database_records
      end
    end
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
  end
end;Fi[	@”iI"¿module RFPDF
  module ActionController
    DEFAULT_RFPDF_OPTIONS = { :inline => (true) }
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
    
    module ClassMethods;Fi[@›{@ﬁ{I"
end));FI"end;Fi[[	@ÂihI"<    respond_to do |arglist|
      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[	@"i@I"D      var.html { |arglist| render("layouts/main_stream") }
      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[	@(i(I"U    @var = Stream::Tag.new(current_user, params[:name], :max_time => (max_time), :page => (params[:page]))
    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end;Fi[@ﬁ{I"
end));FI"end;FI"end;Fi[[	@ÂiiI"#      var.all { |arglist| respond_with(@var, :locals => ({ :post_type => :all })) }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	@"iAI"      var.mobile { |arglist| render("layouts/main_stream") }
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[	@(i)I"Ì    respond_with do |arglist|
      var.json do |arglist|
        render(:json => (@var.stream_posts.map do |arglist|
          LastThreeCommentsDecorator.new(PostPresenter.new(var, current_user))
        end))
      end
    end
  end
  ;Fi[I"'include(Diaspora::Federated::Base);FI" ;FI"include(Diaspora::Guid);FI" ;Fi[[	@ÄiI"âclass Comment < ActiveRecord::Base
  include(Diaspora::Federated::Base)
  
  include(Diaspora::Guid)
  
  include(Diaspora::Relayable)
  ;Fi[	@àiI"Ñclass Conversation < ActiveRecord::Base
  include(Diaspora::Federated::Base)
  
  include(Diaspora::Guid)
  
  xml_attr(:subject)
  ;Fi[	@çiI"≤class NotVisibleError < RuntimeError
end
class Message < ActiveRecord::Base
  include(Diaspora::Federated::Base)
  
  include(Diaspora::Guid)
  
  include(Diaspora::Relayable)
  ;Fi[@µrI"end;FI" ;FI"def function(arglist);Fi[[	@Äi8I"¬  
  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[	@ài+I"í  end
  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[	@çi0I"ƒ  #sign comment as commenter
  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end;Fi[@órI"end;FI" ;FI"def function(arglist);Fi[[	@Äi<I"√  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    if (self.post.author == var.person) then
      return Notifications::CommentOnPost;Fi[	@ài/I"|  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    false
  end;Fi[	@çi4I"ç  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist)
    self.conversation.guid
  end;Fi[@µ I"@var = nil;FI" ;FI"@var = nil;Fi[[	@ïdiI"uclass Net::HTTP::Persistent::SSLReuse < Net::HTTP
  @var = false
  
  @var = nil
  
  @var = nil
  
  @var = nil;Fi[	@ïdi	I"S  @var = false
  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  @var = nil;Fi[	@ïdiI"\  @var = nil
  
  @var = nil
  
  @var = nil
  
  @var = nil
  
  def function(arglist);Fi[@år@çrI"super(var);FI"	else;Fi[[	@£imI"¡  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@£ivI"¡  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[	@£iI"¡  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end;Fi[@çrI"super(var);FI"	else;F@\pi[[	@£inI"¡  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@£iwI"¡  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[	@£i{I"¡  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end;Fi[@\pI"end;FI"end;FI" ;Fi[[	@£iqI"¡    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "");Fi[	@£izI"¡    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "");Fi[	@£i~I"ﬂ    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    if ["month", "day"].all? { |arglist| var[var].present? } then;Fi[I"!ugly_select_clause(var, var);FI"end;FI" ;FI"def function(arglist);Fi[[	@Â#i:I"{    if var[:by_members_of] then
      var = var.joins(:contacts => :aspect_memberships).where(:aspect_memberships => ({ :aspect_id => (var[:by_members_of]) }))
    end
    ugly_select_clause(var, var)
  end
  
  def function(arglist)
    var = Aspect.where(:id => (var[:by_members_of]))
    var = Person.connection.select_values(people_in_aspects(var).select("people.id").to_sql);Fi[	@Â#iBI"ï    var = Person.connection.select_values(people_in_aspects(var).select("people.id").to_sql)
    var = var[:klass].where(:author_id => (var), :public => (true), :pending => (false))
    var = var.where(:type => (var[:type])) unless (var[:klass] == Photo)
    ugly_select_clause(var, var)
  end
  
  def function(arglist)
    var = { :pending => (false) }
    var[:type] = var[:type] if var.has_key?(:type);Fi[	@Â#iLI"    if var[:by_members_of] then
      var = var.joins(:aspect_visibilities).where(:aspect_visibilities => ({ :aspect_id => (var[:by_members_of]) }))
    end
    ugly_select_clause(var, var)
  end
  
  def function(arglist)
    return nil unless var
    contact_for_person_id(var.id);Fi[@µ I"alias :== :eql?;FI" ;FI"def function(arglist);Fi[[	@Ji4I"L      def function(arglist)
        Git.===(var) and ((uri == var.uri) and ((ref == var.ref) and ((branch == var.branch) and ((name == var.name) and ((version == var.version) and (submodules == var.submodules))))))
      end
      
      alias :== :eql?
      
      def function(arglist)
        var = if local? then
          path;Fi[	@Xi>I"3      def function(arglist)
        var.instance_of?(Path) and ((path.expand_path(Bundler.root) == var.path.expand_path(Bundler.root)) and (version == var.version))
      end
      
      alias :== :eql?
      
      def function(arglist)
        File.basename(path.expand_path(Bundler.root).to_s)
      end;Fi[	@_i*I"ƒ      def function(arglist)
        Rubygems.===(var)
      end
      
      alias :== :eql?
      
      def function(arglist)
        { "remotes" => (@var.map { |arglist| var.to_s }) }
      end;Fi[@µ @öxI" ;F@úxi[[	@6iI"ª    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform, :dependencies)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var;Fi[	@LiI"ª    include(MatchPlatform)
    
    attr_reader(:name, :version, :dependencies, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var;Fi[	@"iI"¨    include(MatchPlatform)
    
    attr_reader(:name, :version, :platform)
    
    attr_accessor(:source)
    
    def function(arglist)
      @var = var
      @var = var;Fi[@e@eI"include(ActiveModel);FI" ;Fi[[	@ûi	I"»module StateMachine
  module Integrations
    module ActiveRecord
      include(Base)
      
      include(ActiveModel)
      
      require("state_machine/integrations/active_record/versions")
      ;Fi[	@∫i	I"∆module StateMachine
  module Integrations
    module MongoMapper
      include(Base)
      
      include(ActiveModel)
      
      require("state_machine/integrations/mongo_mapper/versions")
      ;Fi[	@¬iI"Ωmodule StateMachine
  module Integrations
    module Mongoid
      include(Base)
      
      include(ActiveModel)
      
      require("state_machine/integrations/mongoid/versions")
      ;Fi[I"# For example,;FI"#;FI"#   class Vehicle;F@yai[[	@=<ijI"1    #   the given event.  This may be generated by internationalization
    #   libraries if supported by the integration.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@=<iõI"=    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@=<i÷I"˛    # behavior will *not* work if the class defines an +initialize+ method
    # without properly calling +super+.
    # 
    # For example,
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end;Fi[I"# @example;FI"#   class Person;F@˙xI"#     field :title;Fi[[	@ÙiàI"Á      
      # Validates the format of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i;Fi[	@ÙiôI"€      
      # Validates the length of a field.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_length_of :title, minimum: 100;Fi[	@Ùi™I"Ú      
      # Validates whether or not a field is present - meaning nil or empty.
      #
      # @example
      #   class Person
      #     include Mongoid::Document
      #     field :title
      #
      #     validates_presence_of :title;Fi[I"require("keg");FI"module Homebrew;FI"extend(self);FI" ;Fi[[	@)iI"{require("formula")
require("keg")
module Homebrew
  extend(self)
  
  def function(arglist)
    outdated_brews do |arglist|;Fi[	I"%data//homebrew_proj/cmd/prune.rb;Ti I"ôrequire("keg")
module Homebrew
  extend(self)
  
  # $n and $d are used by the ObserverPathnameExtension to keep track of
  # certain filesystem actions.;Fi [	@}7iI"™require("extend/ENV")
require("hardware")
require("keg")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi[@µ I"attr_accessor(:path);FI" ;FI"##;Fi[[	@∂i
I"∑  module Storage
    class Ninefold < Base
      attr_accessor(:storage_token, :storage_secret)
      
      attr_accessor(:path)
      
      ##
      # Ninefold Credentials
      ##;Fi[	@√iI"¶      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials
      ##;Fi[	@»iI"¶      attr_accessor(:username, :password)
      
      attr_accessor(:ip, :port)
      
      attr_accessor(:path)
      
      ##
      # Server credentials
      ##;Fi[@µ @WvI" ;F@Yvi[[	@:iI"Å      check_class_collision
      
      class_option(:migration, :type => :boolean)
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
      
      class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns");Fi[	@_viI"û      argument(:attributes, :type => :array, :default => ([]), :banner => "field:type field:type")
      
      check_class_collision
      
      class_option(:timestamps, :type => :boolean)
      
      class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
      
      class_option(:versioning, :type => :boolean, :default => (false), :desc => "Enable mongoid versioning");Fi[	@ÄiI"∏  argument(:attributes, :type => :array, :default => ([]), :banner => "field[:type][:index] field[:type][:index]")
  
  class_option(:migration, :type => :boolean)
  
  class_option(:timestamps, :type => :boolean)
  
  class_option(:parent, :type => :string, :desc => "The parent class for the generated model")
  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns");Fi[I"require("blacklist");FI"module Homebrew;FI"extend(self);FI" ;Fi[[	I"&data//homebrew_proj/cmd/create.rb;TiI"ârequire("formula")
require("blacklist")
module Homebrew
  extend(self)
  
  # Create a formula from a tarball URL
  def function(arglist);Fi[	@iI"∑require("formula_installer")
require("hardware")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    raise(FormulaUnspecifiedError) if ARGV.named.empty?;Fi[	@iI"ârequire("formula")
require("blacklist")
module Homebrew
  extend(self)
  
  def function(arglist)
    if ARGV.include?("--macports") then;Fi[I"var.pull!;FI"var = Report.new;FI"var.merge!(var.report);FI""assert(var.expectations_met?);Fi[[	@‚i9I"v      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef")
      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?)
      assert(var.empty?)
    end;Fi[	@‚iKI"≤      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?)
      assert(var.select_formula(:M).empty?)
      assert(var.select_formula(:A).empty?);Fi[	@‚i_I"˝      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!
      var = Report.new
      var.merge!(var.report)
      assert(var.expectations_met?)
      assert_equal(["xar", "yajl"], var.select_formula(:M))
      assert_equal(["antiword", "bash-completion", "ddrescue", "dict", "lua"], var.select_formula(:A));Fi[I"(HOMEBREW_REPOSITORY.cd do |arglist|;FI"var = UpdaterMock.new;FI"1var.in_repo_expect("git checkout -q master");FI"Evar.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd");Fi[[	@‚i1I"u  end
  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master");Fi[	@‚iCI"¥  
  def function(arglist)
    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master");Fi[	@‚iWI"±  
  def function(arglist)
    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master");Fi[@µ I"alias :create :insert_sql;FI" ;FI"def function(arglist);Fi[[	@Qi¬I"∞        super
        (var or @var.last_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        execute(to_sql(var, var), var)
      end;Fi[	@ViÄI"’        super(var, var)
        (var or @var.insert_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        var = 0
        exec_query(var, var, var) { |arglist| var = var };Fi[	@çi-I"∂        super
        (var or @var.last_insert_row_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        exec_query(var, var).rows
      end;Fi[I"File.executable?(var);FI"end;FI"end;FI" ;Fi[[	@îiñI"  
  def function(arglist)
    @var ||= ["#{which("hg")}", "#{HOMEBREW_PREFIX}/bin/hg", "#{HOMEBREW_PREFIX}/share/python/hg"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install mercurial") unless hgpath;Fi[	@îi¿I"Í  
  def function(arglist)
    @var ||= ["#{which("bzr")}", "#{HOMEBREW_PREFIX}/bin/bzr"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install bazaar") unless bzrpath;Fi[	@îi‡I"Û  
  def function(arglist)
    @var ||= ["#{which("fossil")}", "#{HOMEBREW_PREFIX}/bin/fossil"].find do |arglist|
      File.executable?(var)
    end
  end
  
  def function(arglist)
    raise("You must: brew install fossil") unless fossilpath;Fi[@µ I"J# Disconnects from the database if already connected. Otherwise, this;FI"# method does nothing.;FI"def function(arglist);Fi[[	@Fi¬I"Û        clear_cache!
        reset_transaction
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        clear_cache!
        reset_transaction;Fi[	@Vi∞I"Â        disconnect!
        connect
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super
        @var.close rescue nil;Fi[	@çiñI"Î      def function(arglist)
        @var.!=(false)
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super
        @var = false;Fi[@µ I"J# Returns an array of record hashes with the column names as keys and;FI"# column values as values.;FI"def function(arglist);Fi[[	@0iI"Ë          var
        end
      end
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(arglist)
        select(to_sql(var, var), var, var)
      end;Fi[	@0ihI"‰        var.projections = [var]
        var
      end
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(arglist)
        # do nothing
      end;Fi[	@Qi∑I"Ú      end
      
      alias :exec_without_stmt :exec_query
      
      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def function(arglist)
        exec_query(var, var)
      end;Fi[@µ @£YI" ;FI"def function(arglist);Fi[[	@Ki5I"…        
        class MethodAttribute < Attribute
        end
        
        attr_reader(:options)
        
        def function(arglist)
          @var = var
          @var = var ? (var.dup) : ({});Fi[	@˜iI"      
      class Branch
        attr_accessor(:command, :callback)
        
        attr_reader(:options)
        
        def function(arglist)
          @var = var.strip.gsub(/\r?\n/, "\\\n")
          @var = (var or Capistrano::Configuration.default_io_proc);Fi[	@iI"°          (options[:to] or from)
        end
      end
      
      attr_reader(:options)
      
      def function(arglist)
        @var = []
        @var = var;Fi[I"good_checksum(var);FI"end;FI" ;FI"def function(arglist);Fi[[	@∑iI"ÿ    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|;Fi[	@∑i)I"·    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|;Fi[	@∑i9I"˚    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new
    var.stable.instance_eval do |arglist|;Fi[I"3assert_instance_of(HeadSoftwareSpec, var.head);FI"end;FI" ;FI"def function(arglist);Fi[[	@øiΩI"V    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@øiÃI"V    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head);Fi[	@øi€I"X    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new
    assert_not_nil(var.stable);Fi[I""assert_nil(var.head.checksum);FI"Bassert_equal("https://github.com/mxcl/homebrew.git", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);Fi[[	@øiπI"â    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@øi»I"â    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[	@øi◊I"â    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end;Fi[I",assert_equal(var.head, var.active_spec);FI".assert_version_equal("HEAD", var.version);FI""assert_nil(var.head.checksum);F@O}i[[	@øi∑I"Ü    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@øi∆I"Ü    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[	@øi’I"Ü    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader);Fi[@[}@\}@O}@P}i[[	@øi∏I"û    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@øi«I"û    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[	@øi÷I"û    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head);Fi[I"Bassert_equal("https://github.com/mxcl/homebrew.git", var.url);FI"=assert_equal(GitDownloadStrategy, var.download_strategy);FI"<assert_instance_of(GitDownloadStrategy, var.downloader);FI"3assert_instance_of(HeadSoftwareSpec, var.head);Fi[[	@øi∫I"r    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@øi…I"r    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[	@øiÿI"r    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  ;Fi[@n}@o}@p}I"end;Fi[[	@øiªI"^    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@øi I"^    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[	@øiŸI"^    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist);Fi[@o}@p}I"end;FI" ;Fi[[	@øiºI"[    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@øiÀI"[    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new;Fi[	@øi⁄I"[    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy)
    assert_instance_of(GitDownloadStrategy, var.downloader)
    assert_instance_of(HeadSoftwareSpec, var.head)
  end
  
  def function(arglist)
    var = ExplicitStrategySpecTestBall.new;Fi[I"assert_nil(var.bottle);FI"assert_nil(var.devel);FI",assert_equal(var.head, var.active_spec);FI".assert_version_equal("HEAD", var.version);Fi[[	@øiµI"M    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[	@øiƒI"U    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[	@øi”I"U    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url);Fi[I"assert_not_nil(var.head);FI"assert_nil(var.stable);FI"assert_nil(var.bottle);F@ç}i[[	@øi≥I"  
  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version);Fi[	@øi¬I"  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version);Fi[	@øi—I"  
  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version);Fi[@ô}@ö}@ç}@é}i[[	@øi¥I"#  def function(arglist)
    var = HeadOnlySpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum);Fi[	@øi√I"+  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum);Fi[	@øi“I"+  def function(arglist)
    var = IncompleteStableSpecTestBall.new
    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum);Fi[@ç}@é}@è}@\}i[[	@øi∂I"g    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@øi≈I"g    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[	@øi‘I"g    assert_not_nil(var.head)
    assert_nil(var.stable)
    assert_nil(var.bottle)
    assert_nil(var.devel)
    assert_equal(var.head, var.active_spec)
    assert_version_equal("HEAD", var.version)
    assert_nil(var.head.checksum)
    assert_equal("https://github.com/mxcl/homebrew.git", var.url)
    assert_equal(GitDownloadStrategy, var.download_strategy);Fi[I")var.extend(StringInreplaceExtension);FI"(var.change_make_var!("FLAG", "def");FI"8assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var);FI"end;Fi[[	I"/data//homebrew_proj/test/test_inreplace.rb;Ti
I"class InreplaceTest < Test::Unit::TestCase
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist);Fi[	@π}iI"Ó  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist);Fi[	@π}i&I"Ô  
  def function(arglist)
    var = "OTHER=def\nFLAG=abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist);Fi[@¥}@µ}I"end;FI" ;Fi[[	@π}iI"  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc";Fi[	@π}iI"  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "FLAG = \nmv file_a file_b";Fi[	@π}i'I"  def function(arglist)
    var = "OTHER=def\nFLAG=abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2 = def";Fi[@µ}I"end;FI" ;FI"def function(arglist);Fi[[	@π}iI")    var = "OTHER=def\nFLAG = abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension);Fi[	@π}iI""    var = "OTHER=def\nFLAG = \nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "FLAG = \nmv file_a file_b"
    var.extend(StringInreplaceExtension);Fi[	@π}i(I",    var = "OTHER=def\nFLAG=abc\nFLAG2=abc"
    var.extend(StringInreplaceExtension)
    var.change_make_var!("FLAG", "def")
    assert_equal("OTHER=def\nFLAG=def\nFLAG2=abc", var)
  end
  
  def function(arglist)
    var = "OTHER=def\nFLAG = abc\nFLAG2 = def"
    var.extend(StringInreplaceExtension);Fi[I"assert(var.universal?);FI"assert(var.i386?.!);F@.P@—Oi[[	@◊OiI"class MachOPathnameTests < Test::Unit::TestCase
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.dylib")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?);Fi[	@◊Oi6I"Ë  
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/a.out")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[	@◊OiDI"Ì  
  def function(arglist)
    var = Pathname.new("#{TEST_FOLDER}/mach/fat.bundle")
    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!);Fi[@µ @:NI"I# Yields to the block the compressor command and filename extension.;FI"def function(arglist);Fi[[	@FiI"ˆ      include(Backup::CLI::Helpers)
      
      include(Backup::Configuration::Helpers)
      
      ##
      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        log!
        yield(@var, @var);Fi[	@RiI"Ÿ        @var = "#{utility(:lzma)}#{options}"
        @var = ".lzma"
      end
      
      ##
      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Lzma is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super;Fi[	@Ui"I"‹        @var = "#{utility(:pbzip2)}#{options}"
        @var = ".bz2"
      end
      
      ##
      # Yields to the block the compressor command and filename extension.
      def function(arglist)
        Backup::Logger.warn(((("[DEPRECATION WARNING]\n" + "  Compressor::Pbzip2 is being deprecated as of backup v.3.0.24\n") + "  and will soon be removed. Please see the Compressors wiki page at\n") + "  https://github.com/meskyanichi/backup/wiki/Compressors"))
        super;Fi[@µ @ÿ/I"end;FI" ;Fi[[	@`(iI"Å    def function(arglist)
      @var = true
    end
    
    attr_reader :function
  end
  
  class Pending < StandardError
  end;Fi[	@Si
I"÷    class WireException < StandardError
      module CanSetName
        attr_writer(:exception_name)
        
        attr_reader :function
      end
      
      def function(arglist)
        super(var["message"]);Fi[	@€i≥I"±        @var = var.clone
        @var = true
      end
      
      attr_reader :function
    end
    
    class MessageExpectation < BaseExpectation
      def function(arglist);Fi[@—O@“OI"assert(var.dylib?);FI"%assert(var.mach_o_executable?.!);Fi[[	@◊OiI"    assert(var.universal?)
    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert((var.arch == :universal));Fi[	@◊OiI"     assert(var.universal?.!)
    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[	@◊Oi+I"     assert(var.universal?.!)
    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!);Fi[@µ @ÿ/@È}I"end;Fi[[	@∫i.I"j      private
      
      attr_reader :function
      
      attr_reader :function
    end
  end
end;Fi[	@‰i∏I"á    def function(arglist)
      @var.full.=~((@var ? (/^#{(@var * @var)}/) : (/^\s/)))
    end
    
    attr_reader :function
  end
end;Fi[	@|i/I"u      def function(arglist)
        (@var == var)
      end
      
      attr_reader :function
    end
  end
end;Fi[@“OI"assert(var.dylib?);F@Ù}I"#assert(var.text_executable?.!);Fi[[	@◊OiI";    assert(var.i386?.!)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert((var.arch == :universal))
    assert_match(/Mach-O (64-bit )?dynamically linked shared library/, file(var));Fi[	@◊OiI"+    assert(var.i386?)
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O dynamically linked shared library/, file(var));Fi[	@◊Oi,I"2    assert(var.i386?.!)
    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?.!)
    assert_match(/Mach-O 64-bit dynamically linked shared library/, file(var));Fi[@µ @°+I"split_words(@var);FI"end;Fi[[	@Yi:I"æ      def function(arglist)
        @var.collect { |arglist| var.inspect }
      end
      
      def function(arglist)
        split_words(@var)
      end
      
      def function(arglist);Fi[	@YiêI"ù        var.to_s =~ /^(be_(an?_)?)(.*)/
        return [$1, $3]
      end
      
      def function(arglist)
        split_words(@var)
      end
    end
    ;Fi[	@«i}I"⁄      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end
      
      def function(arglist)
        split_words(@var)
      end
      
      def function(arglist);Fi[@µ @°+I"var = max_value;FI"var = min_value;Fi[[	@˘iI"Ÿ      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0));Fi[	@iI"æ      end
      
      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0));Fi[	@	iPI"        var = (((@var[:fields][0].length / 2) * font_size) * 0.6)
        @var = var if (var > @var)
      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0));Fi[@”O@‘O@ıXI"assert(var.mach_o_bundle?);Fi[[	@◊OiII"
    assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O (64-bit )?bundle/, file(var))
  end;Fi[	@◊OiWI"     assert(var.x86_64?.!)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O bundle/, file(var))
  end;Fi[	@◊OieI"    assert(var.x86_64?)
    assert(var.ppc7400?.!)
    assert(var.ppc64?.!)
    assert(var.dylib?.!)
    assert(var.mach_o_executable?.!)
    assert(var.text_executable?.!)
    assert(var.mach_o_bundle?)
    assert_match(/Mach-O 64-bit bundle/, file(var))
  end;Fi[I"var = var.patches[0];FI"#assert_equal(:p1, var.patch_p);FI"end;FI" ;Fi[[	I"-data//homebrew_proj/test/test_patches.rb;TiI"/  def function(arglist)
    var = Patches.new("http://example.com/patch.diff")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(["http://example.com/patch1.diff", "http://example.com/patch2.diff"]);Fi[	@3~iI"˛    assert_equal(2, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(:p0 => "http://example.com/patch.diff");Fi[	@3~i+I"9  def function(arglist)
    var = Patches.new(:p1 => "http://example.com/patch.diff")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = { :p1 => "http://example.com/patch1.diff", :p0 => "http://example.com/patch0.diff" };Fi[@.~I"end;FI" ;FI"def function(arglist);Fi[[	@3~iI"?    var = Patches.new("http://example.com/patch.diff")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(["http://example.com/patch1.diff", "http://example.com/patch2.diff"])
    assert_equal(2, var.patches.length);Fi[	@3~iI"˛    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = Patches.new(:p0 => "http://example.com/patch.diff")
    assert_equal(1, var.patches.length);Fi[	@3~i,I"<    var = Patches.new(:p1 => "http://example.com/patch.diff")
    assert_equal(1, var.patches.length)
    var = var.patches[0]
    assert_equal(:p1, var.patch_p)
  end
  
  def function(arglist)
    var = { :p1 => "http://example.com/patch1.diff", :p0 => "http://example.com/patch0.diff" }
    var = Patches.new(var);Fi[@µ @°+I"@var[:fields];FI"end;Fi[[	@˘iI"Ü      end
      
      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist);Fi[	@i#I"∏        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist);Fi[	@	iFI"é        end
        return var
      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist);Fi[@µ @°+@ﬂq@‡qi[[	@Li<I"Ò      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[	@OiEI"Ò      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[	@Ri+I"Ò      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"));Fi[@µ @°+@ˆq@˜qi[[	@LiI"∞    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[	@OiI"∞    var = (@var.length + 1)
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[	@RiI"∞    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[@-vI"end;FI" ;FI"def function(arglist);Fi[[	@2vi)I"    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (false)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (false)) { |arglist| false };Fi[	@2vi:I"Ô      env(:userpaths)
      satisfy(:build_env => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    ENV.expects(:with_build_environment).yields.returns(true)
    ENV.expects(:userpaths!);Fi[	@2viCI"    var = Class.new(Requirement) do |arglist|
      satisfy(:build_env => (true), :userpaths => (true)) { |arglist| true }
    end.new
    assert(var.satisfied?)
  end
  
  def function(arglist)
    var = Class.new(Requirement) { |arglist| satisfy(true) }.new
    assert(var.satisfied?);Fi[@Ù|@ı|@ˆ|I"9var.in_repo_expect("git config core.autocrlf false");Fi[[	@‚i2I"∂  
  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[	@‚iDI"¯  def function(arglist)
    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[	@‚iXI"ı  def function(arglist)
    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[@ı|@ˆ|@j~I"Zvar.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master");Fi[[	@‚i3I"˛  def function(arglist)
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef");Fi[	@‚iEI"0    var = fixture("update_git_diff_output_without_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var);Fi[	@‚iYI"-    var = fixture("update_git_diff_output_with_formulae_changes")
    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var);Fi[@ˆ|@j~@s~I"Evar.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef");Fi[[	@‚i4I"ˆ    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef")
      var.pull!;Fi[	@‚iFI"˚    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!;Fi[	@‚iZI"˚    HOMEBREW_REPOSITORY.cd do |arglist|
      var = UpdaterMock.new
      var.in_repo_expect("git checkout -q master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "1234abcd")
      var.in_repo_expect("git config core.autocrlf false")
      var.in_repo_expect("git pull -q origin refs/heads/master:refs/remotes/origin/master")
      var.in_repo_expect("git rev-parse -q --verify HEAD", "3456cdef")
      var.in_repo_expect("git diff-tree -r --raw -M85% 1234abcd 3456cdef", var)
      var.pull!;Fi[@µ @°+I"var = Scoped.root;FI"var = var.children.first;Fi[[	@öi‹I"H    assert(categories(:child_1).is_ancestor_of?(categories(:child_2)).!)
    assert(categories(:child_1).is_ancestor_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_ancestor_of?(var))
    var.update_attribute(:organization_id, "different");Fi[	@öiˆI"N    assert(categories(:child_2).is_descendant_of?(categories(:child_1)).!)
    assert(categories(:child_1).is_descendant_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_descendant_of?(var))
    var.update_attribute(:organization_id, "different");Fi[	@öi˛I"    var.update_attribute(:organization_id, "different")
    assert(var.is_or_is_descendant_of?(var).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.same_scope?(var))
    var.update_attribute(:organization_id, "different");Fi[@ÎN@ÏNI"1head("https://github.com/mxcl/homebrew.git");FI" ;Fi[[	@ÒNi±I"ø  end
end
class HeadOnlySpecTestBall < Formula
  homepage("http://example.com")
  
  head("https://github.com/mxcl/homebrew.git")
  
  def function(arglist)
    super("headyonlyspectestball");Fi[	@ÒNi∫I"¬  end
end
class IncompleteStableSpecTestBall < Formula
  homepage("http://example.com")
  
  head("https://github.com/mxcl/homebrew.git")
  
  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  ;Fi[	@ÒNi≈I"£  end
end
class HeadOnlyWithVersionSpecTestBall < Formula
  homepage("http://example.com")
  
  head("https://github.com/mxcl/homebrew.git")
  
  version("0.3")
  ;Fi[@µ @°+@,rI"end;Fi[[	@@iI"Ó      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end;Fi[	@WiI"Ó      undef_method(:namespace_definitions)
      
      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end;Fi[	@ZiI"”      def self.new(arglist)
        var.create_entity(var, *var)
      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end;Fi[I"Esha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard);FI">sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion);FI"Fsha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion);FI"end;Fi[[	@ÒNitI"  end
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist);Fi[	@ÒNiI"5  sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist);Fi[	@ÒNiI"  
  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist);Fi[@£~@§~I"end;FI" ;Fi[[	@ÒNiuI"  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("spectestball");Fi[	@ÒNiI")  
  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("allcatsbottlespectestball");Fi[	@ÒNiI"5  bottle do |arglist|
    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("revisedbottlespectestball");Fi[@§~I"end;FI" ;FI"def function(arglist);Fi[[	@ÒNivI"  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("spectestball")
  end;Fi[	@ÒNiI",  bottle do |arglist|
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("allcatsbottlespectestball")
  end;Fi[	@ÒNiI"%    version(1)
    sha1("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" => :snowleopard)
    sha1("baadf00dbaadf00dbaadf00dbaadf00dbaadf00d" => :lion)
    sha1("8badf00d8badf00d8badf00d8badf00d8badf00d" => :mountainlion)
  end
  
  def function(arglist)
    super("revisedbottlespectestball")
  end;Fi[@{I"#;F@¶x@ßxi[[	@ÂiI"÷      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@≠9i I"Í      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[	@¸i>I"≈      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.;Fi[@¶x@ßxI"#;FI"# Returns nothing.;Fi[[	@ÂiI"Ÿ    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin;Fi[	@≠9i"I"„    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[	@¸i@I"„    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var);Fi[@ßxI"#;FI"# Returns nothing.;F@Öxi[[	@ÂiI"    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      begin
        (self.content = File.read(File.join(var, var));Fi[	@≠9i#I"%    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["layout"] = "page" unless self.data.has_key?("layout");Fi[	@¸iAI"%    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.
    #
    # Returns nothing.
    def function(arglist)
      super(var, var)
      self.data["layout"] = "post" unless self.data.has_key?("layout");Fi[@µ @°+I"%var = Node.new(:COMBINATOR, var);FI"var;Fi[[	@
i,I"ß        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@
i1I"ß        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[	@
i6I"ß        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      ;Fi[@µ @°+@7rI"var;Fi[[	@
i◊I"æ        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@
i‹I"ù        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[	@
i·I"ù        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      ;Fi[@µ @°+@år@çri[[	@£ikI"    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[	@£itI"¡      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[	@£i}I"¡      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var)
    else;Fi[@µ @°+@órI"end;Fi[[	@Äi:I"§  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@ài-I"§  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[	@çi2I"§  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  
  def function(arglist);Fi[@µ @°+I"Cucumber.logger;FI"end;Fi[[	@2i5I"ñ        end
        raise(TagExcess.new(var)) if var.any?
      end
      
      def function(arglist)
        Cucumber.logger
      end
    end
  end;Fi[	@=i¢I"≤          log.debug("  * #{file} [NOT SUPPORTED]\n")
        end
      end
      
      def function(arglist)
        Cucumber.logger
      end
      
      def function(arglist);Fi[	@Ei°I"¶      var = (@var.support_to_load + @var.step_defs_to_load)
      @var.load_files!(var)
    end
    
    def function(arglist)
      Cucumber.logger
    end
  end
end;Fi[@µ @°+I"broadcast(var);FI"end;Fi[[	@ûiI"¬      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[	@ûi%I"¬      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[	@ûijI"®      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      
      def function(arglist);Fi[@µ @°+I"@var.language;FI"end;Fi[[	@Éi?I"π      def function(arglist)
        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      
      class ExampleRow < Cells;Fi[	@ÉißI"À        def function(arglist)
          "| #{@cells.collect { |c| c.value }.join(" | ")} |"
        end
        
        def function(arglist)
          @var.language
        end
        
        private;Fi[	@êiWI"»      def function(arglist)
        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      
      def function(arglist);Fi[@µ @°+@ôfI"var = @var;Fi[[	@LiWI"π      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@OiLI"π      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[	@RiFI"π      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var
    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0);Fi[@‰zI"#;F@ÊzI"#;Fi[[	@≠9iuI"      self.data.deep_merge("url" => (File.join(@var, self.url)), "content" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns the destination file path String.
    def function(arglist);Fi[	@¸i¡I"Ã      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path String.
    def function(arglist);Fi[	@÷4iI"Õ      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #
    # Returns destination file path.
    def function(arglist);Fi[@µ @°+@¯rI"end;Fi[[	@uiBI"√      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist);Fi[	@Éi I"ê        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      
      def function(arglist);Fi[	@ÉiÇI"§            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist);Fi[@¨O@˛MI"@var ||= {};FI"end;Fi[[	@ái#I"¡    #
    # @return [ Hash ] The atomic unsets
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Flag the document as destroyed and return the atomic path.;Fi[	@≥i÷I"∑    #
    # @return [ Hash ] The sessions configuration.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= {}
    end
    
    # Set the session configuration options.;Fi[	@yiI"∞      #
      # @return [ Hash ] The db command.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the database session.;Fi[@µ @°+@¥@I"	init;Fi[[	@ii%I"           @var.dup(var)
        end
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?
        var.visit_background_name(@var, name, file_colon_line(@var), source_indent(first_line_length));Fi[	@ui'I"‰      def function(arglist)
        (@var << var)
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        var.visit_comment(@var) unless @var.empty?
        var.visit_tags(@var);Fi[	@ÉiI"        init
        super
      end
      
      def function(arglist)
        return if Cucumber.wants_to_quit
        init
        cells_rows.each_with_index do |arglist|
          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var));Fi[@¨O@˛MI"@var.!.!;FI"end;Fi[[	@éi"I"‘      #
      # @return [ true, false ] If the context is cached.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the number of documents matching the query.;Fi[	@éiÚI"»      #
      # @return [ true, false ] If the cache is loaded.
      #
      # @since 3.0.0
      def function(arglist)
        @var.!.!
      end
      
      # Get the documents for cached queries.;Fi[	@ùirI"Ÿ    #
    # @return [ true, false ] If the criteria is embedded.
    #
    # @since 3.0.0
    def function(arglist)
      @var.!.!
    end
    
    # Extract a single id from the provided criteria. Could be in an $and;Fi[@µ @°+I"	self;FI"end;Fi[[	@diCI"x      @var = nil
      var
    end
    
    def function(arglist)
      self
    end
    
    def function(arglist);Fi[	@oiI"å        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end
      
      def function(arglist);Fi[	@oi&I"ã        @var = var
        self
      end
      
      def function(arglist)
        self
      end
      
      alias :arguments :argument;Fi[@µ @°+I"
yield;FI"end;Fi[[	@3iXI"Ö    def function(arglist)
      Gem.refresh
    end
    
    def function(arglist)
      yield
    end
    
    def function(arglist);Fi[	@íiYI"v    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end
  end
end;Fi[	@iI"ã        @var = 1
        @var = nil
      end
      
      def function(arglist)
        yield
      end
      
      def function(arglist);Fi[@¨O@˛MI"
false;FI"end;Fi[[	@Z	ièI"†      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Is the object a number?;Fi[	@Z	iõI"√      #
      # @return [ false ] Always false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Remove the instance variable for the provided name.;Fi[	@Z	i∫I"¥      #
      # @return [ false ] false.
      #
      # @since 3.0.0
      def function(arglist)
        false
      end
      
      # Get the substitutable version of an object.;Fi[I"# @since 2.2.0;F@ΩwI"@var ||= {};FI"end;Fi[[	@-i÷I"‘      #
      # @return [ Array<String> ] The pull fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be pushed.;Fi[	@-i‚I"—      #
      # @return [ Array<String> ] The push fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the names of the fields that need to be set.;Fi[	@-iÓI"”      #
      # @return [ Array<String> ] The set fields.
      #
      # @since 2.2.0
      def function(arglist)
        @var ||= {}
      end
      
      # Get the $pullAll operations or intialize a new one.;Fi[@±wI"#;F@≥wI"def function(arglist);Fi[[	@0iI"A          # @example Create the path util.
          #   Many.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent
            @var, @var = "$push", "$pull";Fi[	@7iI"@          # @example Create the path util.
          #   One.new(document)
          #
          # @param [ Document ] document The document to generate the paths for.
          #
          # @since 2.1.0
          def function(arglist)
            @var, @var = var, var._parent
            @var, @var = "$set", "$unset";Fi[	@CiI"#        # @example Create the root path util.
        #   Root.new(document)
        #
        # @param [ Document ] document The document to generate the paths for.
        #
        # @since 2.1.0
        def function(arglist)
          @var, @var, @var, @var = var, "", "", ""
        end;Fi[I"# @since 2.3.0;F@ßwI"@var ||= {};FI"end;Fi[[	@áiI"¥    #
    # @return [ Hash ] The delayed $sets.
    #
    # @since 2.3.0
    def function(arglist)
      @var ||= {}
    end
    
    # Get a hash of atomic pulls that are pending.;Fi[	@]iI"…      #
      # @return [ Hash ] The default options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
      
      # Define a configuration option with a default.;Fi[	@]i7I"ö      #
      # @return [ Hash ] The setting options.
      #
      # @since 2.3.0
      def function(arglist)
        @var ||= {}
      end
    end
  end;Fi[I"$#     include Mongoid::Document;FI"#     embedded_in :person;FI"#   end;FI"#;Fi[[	@oi-I"
        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.;Fi[	@oiKI"
        #   end
        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.;Fi[	@oigI"        #   end
        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.;Fi[@ô@—vI"#   end;FI"#;Fi[[	@oi~I"Ï        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[	@oióI"        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.;Fi[	@oiÃI"Ï        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person
        #     include Mongoid::Document;Fi[@õw@úwI"#;FI"# @since 3.0.0;Fi[[	@gi'I"~        # @example Validate the session has database.
        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionDatabase.new(var, var)) if no_database_or_uri?(var);Fi[	@gi6I"r        # @example Validate the session has hosts.
        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionHosts.new(var, var)) if no_hosts_or_uri?(var);Fi[	@giFI"M        # @example Validate the uri and options.
        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          if both_uri_and_standard?(var) then;Fi[@úwI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@gi(I"T        #   validator.validate_session_database(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionDatabase.new(var, var)) if no_database_or_uri?(var)
        end;Fi[	@gi7I"K        #   validator.validate_session_hosts(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::NoSessionHosts.new(var, var)) if no_hosts_or_uri?(var)
        end;Fi[	@giGI"_        #   validator.validate_session_uri(:default, {})
        #
        # @param [ String, Symbol ] name The config key.
        # @param [ Hash ] config The configuration.
        #
        # @since 3.0.0
        def function(arglist)
          if both_uri_and_standard?(var) then
            raise(Errors::MixedSessionConfiguration.new(var, var));Fi[I"# defined.;FI"#;FI"# @api private;FI"#;Fi[[	@giQI"ˆ        end
        
        # Return true if the configuration has no database or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config);Fi[	@gibI"        end
        
        # Return true if the configuration has no hosts or uri option
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_hosts_or_uri?(config);Fi[	@gisI"¸        end
        
        # Return true if the configuration has both standard options and a uri
        # defined.
        #
        # @api private
        #
        # @example Validate the options.
        #   validator.no_database_or_uri?(config);Fi[@µ @°+@&NI"@var = [];Fi[[	@öi
I"ü    include(Backup::CLI::Helpers)
    
    attr_reader(:stderr, :errors)
    
    def function(arglist)
      @var = []
      @var = []
      @var = ""
    end;Fi[	@OiI"£    SPECS = "  specs:"
    
    OPTIONS = /^  ([a-z]+): (.*)$/i
    
    def function(arglist)
      @var = []
      @var = []
      @var = []
      @var = :source;Fi[	@_iI"émodule Capistrano
  class Role
    include(Enumerable)
    
    def function(arglist)
      @var = []
      @var = []
      push(*var)
    end;Fi[@µ @°+@&NI"@var = var;Fi[[	@µiI"º      include(JoinTable)
      
      attr_accessor(:commands, :delegate, :reverting)
      
      def function(arglist)
        @var = []
        @var = var
        @var = false
      end;Fi[	@iI"ú      end
      
      attr_reader(:options)
      
      def function(arglist)
        @var = []
        @var = var
        @var = true
        @var = true;Fi[	@BiI"Ÿ        attr_reader(:images, :max_width)
        
        def_delegators(:@images, :last, :delete, :empty?, :length)
        
        def function(arglist)
          @var = []
          @var = var
        end
        ;Fi[@µ @°+I"var = 0;FI"var = @var["cw"];Fi[[	@Li=I"Ç      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[	@Oi-I"Ç      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[	@Ri,I"Ç      return super(var)
    end
  end
  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0;Fi[@⁄tI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@Üi$I"Ê      #     p doc
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        block_given? ? (documents.each { |arglist| yield(var) }) : (to_enum)
      end;Fi[	@ãicI"      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          (documents[(skipping or 0), (limiting or documents.length)] or []).each do |arglist|;Fi[	@éisI"’      #     puts doc.name
      #   end
      #
      # @return [ Enumerator ] The enumerator.
      #
      # @since 3.0.0
      def function(arglist)
        if block_given? then
          selecting do |arglist|;Fi[@µ @°+I";execute("RELEASE SAVEPOINT #{current_savepoint_name}");FI"end;Fi[[	@Ii)I"/      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      
      # In the simple case, MySQL allows us to place JOINs directly into the UPDATE;Fi[	@kiºI"Ù        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end
    end;Fi[	@çi;I"Í      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      
      #:nodoc:;Fi[@µ @°+@´sI"end;Fi[[	@Ii%I"Ô      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[	@ki∏I"        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist);Fi[	@çi7I"Ô      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[@ÜwI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@éi˛I"ÿ      # @example Get the cached documents.
      #   context.documents
      #
      # @return [ Array<Document> ] The documents.
      #
      # @since 3.0.0
      def function(arglist)
        @var ||= []
      end;Fi[	@ùiWI"¿    # @example Get the documents.
    #   criteria.documents
    #
    # @return [ Array<Document> ] The documents.
    #
    # @since 3.0.0
    def function(arglist)
      @var ||= []
    end;Fi[	@hi9I"O        # @param [ Array<Document> ] docs The documents.
        # @param [ Symbol ] method Delete or destroy.
        #
        # @return [ Array<Document> ] The documents.
        #
        # @since 3.0.0
        def function(arglist)
          var.each do |arglist|
            var.run_after_callbacks(:destroy) if (var == :destroy);Fi[@qw@rw@swI"#;Fi[[	@®	iI"T        # @example Validate the index spec.
        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[	@®	i)I"Y        # @example Validate the options.
        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[	@®	i?I"S        # @example Validate the spec.
        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #;Fi[@µ @°+@∂sI"end;Fi[[	@Ii!I"≥          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[	@ki¥I"	          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist);Fi[	@çi3I"Œ      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist);Fi[@fwI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@ëi{I""      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        ((var.size > 1) ? (any_in(:id => (var))) : (where(:id => (var.first)))).entries
      end;Fi[	@ëiÜI"¸      #
      # @param [ Array<Object> ] ids The ids to fetch with.
      #
      # @return [ Array<Document> ] The matching documents.
      #
      # @since 3.0.0
      def function(arglist)
        var = []
        var = selector_with_type_selection;Fi[	@¬i4I"1    # @param [ Class ] klass The class of the document.
    # @param [ Hash ] idenfier The selector.
    #
    # @return [ Array<Document> ] The matching documents.
    #
    # @since 3.0.0
    def function(arglist)
      documents_for(var)[var].try(:values) if Mongoid.using_identity_map? and var
    end;Fi[@µ @°+I"@var[Process.pid];FI"end;Fi[[	@(iƒI"à      end
      
      private
      
      def function(arglist)
        @var[Process.pid]
      end
      
      def function(arglist);Fi[	@(i»I"©      def function(arglist)
        @var[Process.pid]
      end
      
      def function(arglist)
        @var[Process.pid]
      end
      
      def function(arglist);Fi[	@ViuI"Ñ        end
        
        private
        
        def function(arglist)
          @var[Process.pid]
        end
      end
      ;Fi[@µ @°+I"@var.clear;FI"end;Fi[[	@Èi√I"´      def function(arglist)
        "proxied_by_rspec__#{sym}"
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[	@Èi«I"õ      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[	@ÈiÀI"õ      def function(arglist)
        @var.clear
      end
      
      def function(arglist)
        @var.clear
      end
      
      def function(arglist);Fi[@µ @°+I"@var.type;FI"end;Fi[[	@i;I"¢        def function(arglist)
          var.unserialized_value
        end
        
        def function(arglist)
          @var.type
        end
      end
      ;Fi[	@"iI"ƒ          var = @var.type_cast(var)
          var.acts_like?(:time) ? (var.in_time_zone) : (var)
        end
        
        def function(arglist)
          @var.type
        end
      end
      ;Fi[	@,iI"{    end
    
    alias :eql? :==
    
    def function(arglist)
      @var.type
    end
    
    def function(arglist);Fi[@µ @°+I")reflection.active_record_primary_key;FI"end;Fi[[	@‘iI"Ú          var = super
          klass.connection.select_all(var.arel, "SQL", var.bind_values)
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        def function(arglist);Fi[	@ŸiI"æ        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
      end
    end;Fi[	@„iI"≈        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        
        private;Fi[@µ @°+I"var = [];FI"var.each do |arglist|;Fi[[	@iBI"8    def function(arglist)
      execute_callstack_for_multiparameter_attributes(extract_callstack_for_multiparameter_attributes(var))
    end
    
    def function(arglist)
      var = []
      var.each do |arglist|
        begin
          send("#{name}=", MultiparameterAttribute.new(self, var, var).read_value);Fi[	@ i£I"    def function(arglist)
      @var ||= expand_dependencies(dependencies, @var)
    end
    
    def function(arglist)
      var = []
      var.each do |arglist|
        var = Dependency.new(var, ">= 0") unless var.respond_to?(:name)
        var.gem_platforms(@var).each do |arglist|;Fi[	@£iI"Â  BOTTLE_EXTNAME_RX = /(\.[a-z]+\.bottle\.(\d+\.)?tar\.gz)$/
  
  OLD_BOTTLE_EXTNAME_RX = /((\.[a-z]+)?[\.-]bottle\.tar\.gz)$/
  
  def function(arglist)
    var = []
    var.each do |arglist|
      case var
      when Array then;Fi[@µ @°+I"
super;F@oi[[	@oi	I"  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[	@oiI""  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[	@ÄiI"H  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize
    @var = "plugins/#{plugin_name}";Fi[@µ @°+@dÄI"@var = nil;Fi[[	@¬HiI"≤module ArJdbcMySQL
  class Error < StandardError
    attr_accessor(:error_number, :sql_state)
    
    def function(arglist)
      super
      @var = nil
      @var = nil
    end;Fi[	@ïdiI"^  @var = nil
  
  @var = nil
  
  def function(arglist)
    super
    @var = nil
  end
  ;Fi[	@ÕiI"É      @var = var[:target]
      @var = var[:guard]
    end
    
    def function(arglist)
      super
      @var = nil
    end
    ;Fi[@µ @°+@dÄI"@var = [];Fi[[	@ãi#I"ﬁ        var.map! { |arglist| var.type_cast(var) }
        replace(klass.find(var).index_by { |arglist| var.id }.values_at(*var))
      end
      
      def function(arglist)
        super
        @var = []
      end
      ;Fi[	@%iI"¥      include(GemHelpers)
      
      attr_reader(:activated, :required_by)
      
      def function(arglist)
        super
        @var = []
        @var = []
        @var = nil;Fi[	@>iI"æ    module Formatter
      class NestedTextFormatter < BaseTextFormatter
        INDENT = "  "
        
        def function(arglist)
          super
          @var = []
        end
        ;Fi[@µ @°+@dÄI"@var = false;Fi[[	@ÖiI"ï        @var = true if var
        self.target = var
      end
      
      def function(arglist)
        super
        @var = false
      end
      ;Fi[	@ñiI"Å      var, self.runtime = runtime, 0
      var
    end
    
    def function(arglist)
      super
      @var = false
    end
    ;Fi[	@9i"I"ﬂ          @var.puts(report_header)
          @var.flush
        end
        
        def function(arglist)
          super
          @var = false
          @var = (@var + 1)
          unless (example_group_number == 1) then;Fi[I"A# Get the value of the object as a mongo friendy sort value.;FI"#;F@Pw@Qwi[[	@D	iI"˙module Mongoid
  module Extensions
    module FalseClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 0.;Fi[	@Z	i:I"Á        "#{self}="
      end
      
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Object ] self.;Fi[	@â	iI"˘module Mongoid
  module Extensions
    module TrueClass
      # Get the value of the object as a mongo friendy sort value.
      #
      # @example Get the object as sort criteria.
      #   object.__sortable__
      #
      # @return [ Integer ] 1.;Fi[@µ @°+@K1I"@var = true;Fi[[	@GiI"ü      attr_reader(:configuration)
      
      attr_reader(:message)
      
      def function(arglist)
        @var = var
        @var = true
      end
      ;Fi[	@JiI"©      attr_reader(:configuration)
      
      attr_reader(:hosts)
      
      def function(arglist)
        @var = var
        @var = true
        @var = nil
      end;Fi[	@óiI"Ÿ      module Console
        class TestRunner
          alias_method(:started_without_rspec, :started)
          
          def function(arglist)
            @var = var
            @var = true
          end
          ;Fi[@µ @ü+@†+@ïoi[[	@ûiI"ÿ        require("active_record/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[	@∫iI"Ó      def self.matching_ancestors(arglist)
        ["MongoMapper::Document"]
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[	@¬iI"“        require("mongoid/version")
        super
      end
      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save);Fi[@rw@swI"#;F@:wi[[	@®	iI"?        #   Options.validate(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@®	i*I"G        #   Options.validate_options(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[	@®	i@I"D        #   Options.validate_spec(Band, name: 1)
        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0;Fi[@swI"#;F@:wI"#;Fi[[	@®	iI"1        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@®	i+I"1        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[	@®	iAI"1        #
        # @param [ Class ] klass The model class.
        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist);Fi[@:wI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@®	iI"F        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          validate_spec(var, var, var)
          validate_options(var, var, var);Fi[	@®	i-I"N        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          var.each_pair do |arglist|
            unless VALID_OPTIONS.include?(var) then;Fi[	@®	iCI"j        # @param [ Hash ] spec The index specification.
        # @param [ Hash ] options The index options.
        #
        # @raise [ Errors::InvalidIndex ] If validation failed.
        #
        # @since 3.0.0
        def function(arglist)
          raise(Errors::InvalidIndex.new(var, var, var)) if var.is_a?(::Hash).!
          var.each_pair do |arglist|;Fi[@µ @MI"J# Turn the object from the ruby type we deal with to a Mongo friendly;FI"# type.;Fi[[	@G	iI"„      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@L	i¶I"        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[	@Q	i+I"„      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #
        # @example Mongoize the object.;Fi[@'I"'return if (var[:data].length == 0);FI"var = [];FI"var = [];Fi[[	@i@I"}        end
        unless ((var[:data].length % 2) == 0) then
          raise((("Data supplied must be x,y pairs!  " + "The data provided contained an odd set of ") + "data points"))
        end
        return if (var[:data].length == 0)
        var = []
        var = []
        var[:data].each_index do |arglist|
          ((((var % 2) == 0) ? (var) : (var)) << var[:data][var]);Fi[	@iKI"Y        end
        unless ((var[:data].length % 3) == 0) then
          raise((("Data supplied must be title,from,to tripples!  " + "The data provided contained an odd set of ") + "data points"))
        end
        return if (var[:data].length == 0)
        var = []
        var = []
        var = []
        var[:data].each_index do |arglist|;Fi[	@i<I"^        end
        unless ((var[:data].length % 2) == 0) then
          raise((("Data supplied must be x,y pairs!  " + "The data provided contained an odd set of ") + "data points"))
        end
        return if (var[:data].length == 0)
        var = []
        var = []
        var[:data].each_index do |arglist|
          if ((var % 2) == 0) then;Fi[@'@ÃnI"out("endobj");FI"end;Fi[[	@Li5I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[	@Oi>I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[	@Ri$I"          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end;Fi[@wI"#;FI"# @since 2.0.0;FI"def function(arglist);Fi[[	@Ù	iI"        # @example Persist the new values.
        #   addToSet.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            document[field] = [] unless document[field];Fi[	@
iI"        # @example Persist the new values.
        #   pull_all.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@'
iI"È        # @example Persist the new values.
        #   push.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.0.0
        def function(arglist)
          append_with("$push")
        end;Fi[@w@‡ÄI"# @since 2.1.0;FI"def function(arglist);Fi[[	@
iI"         # @example Persist the new values.
        #   pop.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@
iI"        # @example Persist the new values.
        #   pull.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          prepare do |arglist|
            if document[field] then;Fi[	@,
iI"Ô        # @example Persist the new values.
        #   pushAll.persist
        #
        # @return [ Object ] The new array value.
        #
        # @since 2.1.0
        def function(arglist)
          append_with("$pushAll")
        end;Fi[@'I"var = var["file"];FI"if var then;F@ ni[[	@Li1I"Ü          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[	@Oi:I"Ü          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[	@Ri I"Ü          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"));Fi[@'I"out(">>");FI"out("endobj");FI"newobj;Fi[[	@UizI"·            else
              out((("/Encoding " + (var + var["diff"]).to_s) + " 0 R"))
            end
          end
          out(">>")
          out("endobj")
          newobj
          var = var["cw"]
          var = "[";Fi[	@cibI"€              else
                out("/Encoding /WinAnsiEncoding")
              end
            end
            out(">>")
            out("endobj")
            newobj
            var = var["cw"]
            var = "[";Fi[	@ciã
I"2    var["desc"].each { |arglist| out(((("/" + var.to_s) + " ") + var.to_s)) }
    if var["file"] then
      out((("/FontFile2 " + @var[var["file"]]["n"].to_s) + " 0 R"))
    end
    out(">>")
    out("endobj")
    newobj
    var = getfontpath(var["ctg"])
    Error(("Font file not found: " + var)) if var.!;Fi[@'@ˇÄ@ ÅI"#if var["type"].!=("core") then;Fi[[	@Li#I"”              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[	@Oi,I"”              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[	@RiI"”              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"];Fi[@'@ˇÄI"var = fopen(var, "rb");FI"putstream(fread(var, var));Fi[[	@LiI"      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj");Fi[	@Oi
I"      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj");Fi[	@RiI"	      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj");Fi[@˙vI"#;F@¸vI"def function(arglist);Fi[[	@ë
iI":      # @param [ Metadata ] metadata The relation's metadata.
      # @param [ true, false ] building If we are in a build operation.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = create_relation(var, var)
        set_relation(var, var);Fi[	@ë
i%I"F      # @param [ Document, Array<Document ] object The relation target.
      # @param [ Metadata ] metadata The relation metadata.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        var = @var[var.inverse_type]
        var = var.builder(self, var).build(var);Fi[	@ë
iRI"      # @param [ String, Symbol ] name The name of the relation.
      # @param [ Proxy ] relation The relation to set.
      #
      # @return [ Proxy ] The relation.
      #
      # @since 2.0.0.rc.1
      def function(arglist)
        instance_variable_set("@#{name}", var)
      end;Fi[@'I"if var.!=(var) then;FI"RCell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var);FI"end;Fi[[	@LiÁI"¡      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  ;Fi[	@OiI"         var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  ;Fi[	@Ri÷I"¡      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  ;Fi[@'I"<var = (var + "B") if var and var.to_s.index("B").nil?.!;FI"<Cell(var, var, var[var, (var - var)], var, 2, var, var);FI"if (var == 1) then;Fi[[	@LiïI"Ó      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[	@OiêI"˜        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[	@RiÑI"Ó      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else;Fi[@'I"!return ((var * @var) / 1000);FI"end;FI" ;Fi[[	@LiLI"¨        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@OiAI"ü          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[	@Ri;I"¨        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then;Fi[I"3# @param [ Hash ] options The binding options.;FI"#;F@v@9_i[[	@¢
iI"r          #   name.person.bind(:continue => true)
          #   name.person = Person.new
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1;Fi[	@≠
iI"ã          #   person.addresses.bind_one(address)
          #
          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1;Fi[	@≠
i%I"w          # @example Unbind the document.
          #   person.addresses.unbind_one(document)
          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1;Fi[@v@9_I"#;F@;_i[[	@¢
iI"å          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            base.metadata = metadata.inverse_metadata(target) unless base.metadata;Fi[	@≠
iI"é          # @param [ Document ] doc The single document to bind.
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            var.parentize(base);Fi[	@≠
i'I"í          #
          # @param [ Hash ] options The binding options.
          #
          # @option options [ true, false ] :continue Continue binding the inverse.
          # @option options [ true, false ] :binding Are we in build mode?
          #
          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| var.do_or_do_not(metadata.inverse_setter(target), nil) };Fi[@'I"after_flush_writes;FI"@var = {};FI"end;Fi[[	@ÂiI"ß            FileUtils.chmod(var, path(var))
          end
          var.rewind
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:;Fi[	@ËiGI"ú          ensure
            var.rewind
          end)
        end
        after_flush_writes
        @var = {}
      end
      
      def function(arglist);Fi[	@Îi›I"é          ensure
            var.rewind
          end
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:;Fi[@'I"good_checksum(var);FI"end;FI" ;Fi[[	@∑iI"≈    var = TestBall.new
    var.stable.instance_eval do |arglist|
      md5("060844753f2a3b36ecfc3192d307dab2")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new;Fi[	@∑i(I"Œ    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha1("482e737739d946b7c8cbaf127d9ee9c148b999f5")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new;Fi[	@∑i8I"Ë    var = TestBall.new
    var.stable.instance_eval do |arglist|
      sha256("1dfb13ce0f6143fe675b525fc9e168adb2215c5d5965c9f57306bb993170914f")
    end
    good_checksum(var)
  end
  
  def function(arglist)
    var = TestBall.new;Fi[I"># Binds a single document with the inverse relation. Used;FI"0# specifically when appending to the proxy.;FI"#;FI""# @example Bind one document.;Fi[[	@≠
i
I"1    module Bindings
      module Embedded
        class Many < Binding
          # Binds a single document with the inverse relation. Used
          # specifically when appending to the proxy.
          #
          # @example Bind one document.
          #   person.addresses.bind_one(address)
          #;Fi[	@Œ
i
I",    module Bindings
      module Referenced
        class Many < Binding
          # Binds a single document with the inverse relation. Used
          # specifically when appending to the proxy.
          #
          # @example Bind one document.
          #   person.posts.bind_one(post)
          #;Fi[	@’
i
I">    module Bindings
      module Referenced
        class ManyToMany < Binding
          # Binds a single document with the inverse relation. Used
          # specifically when appending to the proxy.
          #
          # @example Bind one document.
          #   person.preferences.bind_one(preference)
          #;Fi[@Ë_@∞iI"7# @param [ String ] type Not used in this context.;FI"#;Fi[[	@Ë
iI"F          # parent since it should already be instantiated.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type Not used in this context.
          #
          # @return [ Document ] A single document.
          def function(arglist);Fi[	@Ò
iI":          # case will return many documents.
          #
          # @example Build the documents.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type Not used in this context.
          #
          # @return [ Array<Document ] The documents.
          def function(arglist);Fi[	@¯
iI"R          # to make sure subclasses and allocation are used if fitting.
          #
          # @example Build the document.
          #   Builder.new(meta, attrs).build
          #
          # @param [ String ] type Not used in this context.
          #
          # @return [ Document ] A single document.
          def function(arglist);Fi[@'I")constraints(var) { |arglist| yield };FI"end;FI" ;Fi[[	@∑iÓI"|    def function(arglist)
      var = lambda do |arglist|
        var.env["warden"].authenticate!(:scope => (var)) and (var.nil? or var.call(var.env["warden"].user(var)))
      end
      constraints(var) { |arglist| yield }
    end
    
    # Allow you to route based on whether a scope is authenticated. You
    # can optionally specify which scope and a block. The block accepts;Fi[	@∑iI"d    def function(arglist)
      var = lambda do |arglist|
        var.env["warden"].authenticate?(:scope => (var)) and (var.nil? or var.call(var.env["warden"].user(var)))
      end
      constraints(var) { |arglist| yield }
    end
    
    # Allow you to route based on whether a scope is *not* authenticated.
    # You can optionally specify which scope.;Fi[	@∑i5I"»      var = lambda do |arglist|
        var.env["devise.mapping"] = Devise.mappings[var]
        true
      end
      constraints(var) { |arglist| yield }
    end
    
    alias :as :devise_scope
    ;Fi[@'I"var.join("\n");FI"end;FI"end;Fi[[	@«i5I"
            var = "<span class=\"linenum\">#{((offending_line + i) - 2)}</span>#{line}"
            var = "<span class=\"offending\">#{new_line}</span>" if (var == 2)
            (var << var)
          end
          var.join("\n")
        end
      end
    end
  end;Fi[	@xibI"°            (var[var] << "</li>\n	</#{lT(v)}l>")
          end
        end
      end
      var.join("\n")
    end
  end
  
  QUOTES_RE = /(^>+([^\n]*?)(\n|$))+/m;Fi[	@Ui=I"
            var = "<span class=\"linenum\">#{((offending_line + i) - 2)}</span>#{line}"
            var = "<span class=\"offending\">#{new_line}</span>" if (var == 2)
            (var << var)
          end
          var.join("\n")
        end
      end
    end
  end;Fi[@'@~^@îq@üqi[[	@óifI"a      version("3.0.x") do |arglist|
        def self.active?(arglist)
          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super;Fi[	@µiNI"Y      version("0.9.x") do |arglist|
        def self.active?(arglist)
          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super;Fi[	@ΩiI"f        end
        def function(arglist)
          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super;Fi[@'I"return true;FI"end;FI" ;Fi[[	@òi'I"î          var = var.counter_cache_column
          var = unscoped.where(arel_table[primary_key].eq(var.id)).arel.compile_update(arel_table[var] => (var.send(var).count))
          connection.update(var)
        end
        return true
      end
      
      # A generic "counter updater" implementation, intended primarily to be
      # used by increment_counter and decrement_counter, but which may also;Fi[	@bi7I"}        process_command($1, $2, $3)
      else
        raise("eh?")
      end
      return true
    end
    
    private
    ;Fi[	@â
iWI"F      unless save(var) then
        self.class.fail_validate!(self) unless errors.empty?
        self.class.fail_callback!(self, :save!)
      end
      return true
    end
    
    # Touch the document, in effect updating its updated_at timestamp and
    # optionally the provided field to the current time. If any belongs_to;Fi[@'@	9@
9I"end;Fi[[	@Ui{I"          rescue Encoding::UndefinedConversionError => var
            yield("Invalid #{encoding.name} character #{e.error_char.dump}\n".rstrip, (var + 1))
          end
        end
        return var
      end
    end
    
    if (RUBY_VERSION < "1.9") then;Fi[	@îi˘I"N      puts("Subversion 1.4.x will not export externals correctly for this formula.")
      puts("You must either `brew install subversion` or set HOMEBREW_SVN to the path")
      puts("of a newer svn binary.")
    end
    return var
  end
end
class UnsafeSubversionDownloadStrategy < SubversionDownloadStrategy
  def function(arglist);Fi[	@}iœI"Ö      (var << self[var])
      var = (var + 1)
      var = (var + 1)
    end
    return var
  end
end
class Array
  include(Diffable);Fi[@'I"if var then;FI"var = var;FI"var = var;Fi[[	@™iöI"            var.text((var.round + 8), 14, "#{month_f.year}-#{month_f.month}")
            var = (var + var)
            var = (var >> 1)
          end
          if var then
            var = var
            var = var
            if (@var.cwday == 1) then
              var = date_from;Fi[	@™iI"           var.RDMCell(var, var, "#{month_f.year}-#{month_f.month}", "LTR", 0, "C")
          var = (var + var)
          var = (var >> 1)
        end
        if var then
          var = var
          var = var
          if (self.date_from.cwday == 1) then
            var = self.date_from;Fi[	@™iI"◊            var = (var + var)
            var = (var + 7)
          end
        end
        if var then
          var = var
          var = var
          var = self.date_from.cwday
          var.SetFontStyle("B", 7);Fi[@'@QB@RBI"end;Fi[[	@óijI"Ÿ        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@µiRI"Ÿ        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end
  end;Fi[	@ΩiI"ˆ        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
      
      version("2.0.x") do |arglist|;Fi[@'@Z[I"@var = var;FI"end;Fi[[	@i4I"Ù              @var = var.with_indifferent_access.sort { |arglist| (var[0].to_i <=> var[0].to_i) }
            else
              @var = var
            end
            @var = var
            @var = var
          end
          
          private;Fi[	@Ui˛I"ã    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage);Fi[	@ciÎI"ã    if @var.!=(var) then
      @var = var
      out(var)
    end
    @var = var
    @var = var
  end
  
  alias_method(:add_page, :AddPage);Fi[@-dI"end;FI" ;F@¬zi[[	@2iI"c        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@;iI"c        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[	@IiI"c        # @return [ Strategy ] The new strategy.
        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.;Fi[@¬z@√z@ƒzI"#;Fi[[	@2iI"L          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[	@;iI"M          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading destroy.
        #   strategy.cascade;Fi[	@IiI"L          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade;Fi[@⁄vI"#;FI"# @since 3.0.0;FI"def function(arglist);Fi[[	@hiI"¯        #
        # @param [ Array<Document> ] docs The docs to add.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          execute_batch_insert(var, "$pushAll")
        end;Fi[	@hiFI"'        #
        # @param [ Array<Document> ] docs The docs to replace with.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          if var.blank? then
            base.add_atomic_unset(first) if _assigning? and empty?.!;Fi[	@hiuI"D        # @param [ Array<Document> ] docs The docs to persist.
        # @param [ String ] operation The atomic operation.
        #
        # @return [ Array<Hash> ] The inserts.
        #
        # @since 3.0.0
        def function(arglist)
          self.inserts_valid = true
          var = pre_process_batch_insert(var);Fi[@'@Z[@ÕÅI"@var = var;Fi[[	@˜iïI"Ó        var = Tree.new(nil) { |arglist| var.else(var, &var) }
      else
        raise(ArgumentError, "block given with tree argument") if var
      end
      @var = var
      @var = var
      @var = var
      @var = open_channels
    end;Fi[	@UiªI"ò      else
        raise("Font unavailable")
      end
    end
    @var = var
    @var = var
    @var = var
    @var = (var / @var)
    @var = @var[var];Fi[	@ci%I"∞      else
        Error(((("Undefined font: " + var) + " ") + var))
      end
    end
    @var = var
    @var = var
    @var = var
    @var = (var / @var)
    @var = @var[var];Fi[@öI"#   end;FI"#;F@õPi[[	@oi.I"B        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[	@oiLI"B        #
        #   class Address
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[	@oihI"?        #
        #   class Name
        #     include Mongoid::Document
        #     embedded_in :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.
        # @param [ Hash ] options The relation options.
        # @param [ Proc ] block Optional block for defining extensions.;Fi[@'@ﬂJI""";FI"end;Fi[[	@™iI"¿            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[	@™i5I"¿            pdf_task(var, var, :label => (var), :markers => (true), :height => 0.8)
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[	@™irI"ú            pdf_task(var, var, :label => (var))
          else
            # do nothing
          end
        else
          ""
        end
      end
      ;Fi[I"#   class Game;F@–v@—vI"#   end;Fi[[	@oi}I"Œ        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person;Fi[	@oiñI"Ï        #     has_many :posts
        #   end
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        # @param [ Symbol ] name The name of the relation.;Fi[	@oiÀI"Œ        #
        # @example Define the relation.
        #
        #   class Game
        #     include Mongoid::Document
        #     belongs_to :person
        #   end
        #
        #   class Person;Fi[@ƒvI"#;FI"# @since 2.3.2;FI"def function(arglist);Fi[[	@™i*I"Û    # @example Reload the document.
    #   document._reload
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      embedded? ? (reload_embedded_document) : (reload_root_document)
    end;Fi[	@™i6I"    # @example Reload the document.
    #   document.reload_root_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      {}.merge((with(:consistency => :strong).collection.find(:_id => (id)).one or {}))
    end;Fi[	@™iBI"7    # @example Reload the document.
    #   document.reload_embedded_document
    #
    # @return [ Hash ] The reloaded attributes.
    #
    # @since 2.3.2
    def function(arglist)
      extract_embedded_attributes({}.merge(_root.with(:consistency => :strong).collection.find(:_id => (_root.id)).one))
    end;Fi[@'@ﬂJ@™o@´oi[[	@LiI"E          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[	@OiI"E          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[	@RiI"E          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"));Fi[@ÿZI"#;FI"# @since 2.1.0;FI"def function(arglist);Fi[[	@≈i4I"·      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("bind");Fi[	@≈iSI"‚      #     relation.push(doc)
      #   end
      #
      # @return [ Object ] The return value of the block.
      #
      # @since 2.1.0
      def function(arglist)
        begin
          (Threaded.begin_execution("build");Fi[	@≈i¨I"ı        #     relation.push(doc)
        #   end
        #
        # @return [ Object ] The return value of the block.
        #
        # @since 2.1.0
        def function(arglist)
          begin
            (Threaded.begin_execution("create");Fi[@'@ﬂJI"nil;FI"end;Fi[[	@(iI"æ            var = (var + 1)
            var = var.offset(var)[0]
            Gherkin::Formatter::Argument.new(var, var)
          end
        else
          nil
        end
      end
    end;Fi[	@=i∞I"‡            log.debug("Failed to load '#{ext}' programming language for file #{step_def_file}: #{e.message}\n")
            (@var << var)
            nil
          end
        else
          nil
        end
      end
    end;Fi[	@niI"„            "#{best_match[:example_group].description} #{best_match[:example].description}"
          else
            best_match[:example_group].description
          end
        else
          nil
        end
      end
      ;Fi[I"=# @param [ Document ] document The document to validate.;FI"=# @param [ Symbol ] attribute The name of the attribute.;FI"7# @param [ Object ] value The value of the object.;FI"#;Fi[[	@Òi9I"J      # @example Add the error.
      #   validator.add_error(doc, :name, "test")
      #
      # @param [ Document ] document The document to validate.
      # @param [ Symbol ] attribute The name of the attribute.
      # @param [ Object ] value The value of the object.
      #
      # @since 2.4.10
      def function(arglist);Fi[	@ÒiXI"É      #   validator.create_criteria(User, user, :name, "syd")
      #
      # @param [ Class, Proxy ] base The base to execute the criteria from.
      # @param [ Document ] document The document to validate.
      # @param [ Symbol ] attribute The name of the attribute.
      # @param [ Object ] value The value of the object.
      #
      # @return [ Criteria ] The criteria.
      #;Fi[	@ÒiqI"\      # @example Get the criteria.
      #   validator.criterion(person, :title, "Sir")
      #
      # @param [ Document ] document The document to validate.
      # @param [ Symbol ] attribute The name of the attribute.
      # @param [ Object ] value The value of the object.
      #
      # @return [ Criteria ] The uniqueness criteria.
      #;Fi[@∫tI"#;FI"# @since 2.4.0;FI"def function(arglist);Fi[[	@ÙiêI"2      #     validates_format_of :title, with: /^[a-z0-9 \-_]*$/i
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::FormatValidator, _merge_attributes(var))
      end;Fi[	@Ùi°I"&      #     validates_length_of :title, minimum: 100
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(Mongoid::Validations::LengthValidator, _merge_attributes(var))
      end;Fi[	@Ùi≤I"      #     validates_presence_of :title
      #   end
      #
      # @param [ Array ] args The names of the fields to validate.
      #
      # @since 2.4.0
      def function(arglist)
        validates_with(PresenceValidator, _merge_attributes(var))
      end;Fi[@VrI"var;FI"end;FI" ;Fi[[	@
ikI"≤      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      # reduce 13 omitted
      def function(arglist);Fi[	@
iqI"€      
      # reduce 13 omitted
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var);Fi[	@
ivI"      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:CONDITIONAL_SELECTOR, [Node.new(:ELEMENT_NAME, ["*"]), Node.new(:COMBINATOR, var)]);Fi[@'@(I"if var[:markers] then;FI"if var[:start] then;Fi[[	@™i»I"π            var = "task-done-issue-#{options[:issue].id}" if var[:issue]
            var = "task-done-version-#{options[:version].id}" if var[:version]
            (var << view.content_tag(:div, "&nbsp;".html_safe, :style => (var), :class => ("#{options[:css]} task_done"), :id => (var)))
          end
        end
        if var[:markers] then
          if var[:start] then
            var = ""
            (var << "top:#{params[:top]}px;");Fi[	@™iI"õ            var[:pdf].SetX((var[:subject_width] + var[:bar_start]))
            var[:pdf].SetFillColor(90, 200, 90)
            var[:pdf].RDMCell((var[:bar_progress_end] - var[:bar_start]), var, "", 0, 0, "", 1)
          end
        end
        if var[:markers] then
          if var[:start] then
            var[:pdf].SetY((var[:top] + 1))
            var[:pdf].SetX(((var[:subject_width] + var[:start]) - 1));Fi[	@™i#I"ü          if var[:bar_progress_end] then
            var[:image].fill("#00c600")
            var[:image].rectangle((var[:subject_width] + var[:bar_start]), var[:top], (var[:subject_width] + var[:bar_progress_end]), (var[:top] - var))
          end
        end
        if var[:markers] then
          if var[:start] then
            var = (var[:subject_width] + var[:start])
            var = (var[:top] - (var / 2));Fi[@7rI"var;FI"end;FI" ;Fi[[	@
iŸI"≠      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@
iﬁI"≠      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last];Fi[	@
i„I"°      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      # reduce 41 omitted
      # reduce 42 omitted;Fi[I"$var = Node.new(:AN_PLUS_B, var);FI"	else;FI"@raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'");FI"end;Fi[[	@
i˙I"·      
      def function(arglist)
        if (var[1] == "n") then
          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end;Fi[	@
i	I"          if (var[0] == "-n") then
            var[0] = "n"
            var.unshift("-1")
            var = Node.new(:AN_PLUS_B, var)
          else
            raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
          end
        end
        var;Fi[	@
iI"Ï        if (var[1] == "n") then
          (var << "+")
          (var << "0")
          var = Node.new(:AN_PLUS_B, var)
        else
          raise(Racc::ParseError, "parse error on IDENT '#{val[1]}'")
        end
        var
      end;Fi[@'@(I"if var.!=(var) then;F@(Åi[[	@LiÊI"÷        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end;Fi[	@OiÔI"“      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end;Fi[	@Ri’I"÷        var = (var + 1)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end;Fi[@'@(@2Å@3Åi[[	@LiîI"        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var;Fi[	@OièI"˘      else
        var = (var + var)
        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var;Fi[	@RiÉI"        var = var if var and (var == 2)
      else
        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var;Fi[@'@(@=ÅI"end;Fi[[	@LiKI"ë      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist);Fi[	@Oi@I"ñ          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist);Fi[	@Ri:I"ë      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist);Fi[@,rI"end;FI"end;FI"end;Fi[[	@@iI"¿      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@WiI"¿      undef_method(:line) if method_defined?(:line)
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[	@ZiI"ñ      end
      
      def function(arglist)
        "#<#{self.class.name}:#{sprintf("0x%x", object_id)} #{to_s.inspect}>"
      end
    end
  end
end;Fi[@'@(I"@var = [];FI"end;Fi[[	@LiI"«              (var.width <=> var.width)
            else
              (var.height <=> var.height)
            end
          end
          @var = []
        end
        
        def function(arglist);Fi[	@Âi6I"Ò            # do nothing
          rescue SystemCallError => var
            log("There was an unexpected error while deleting directories: #{e.class}")
          end
        end
        @var = []
      end
      
      def function(arglist);Fi[	@ÎiÍI"’            s3_bucket.objects[var.sub(/^\//, "")].delete)
          rescue AWS::Errors::Base => var
            # do nothing
          end
        end
        @var = []
      end
      
      def function(arglist);Fi[I"document.decorate(var);FI"var;FI"end;FI" ;Fi[[	@#:iMI"Ò        var.each do |arglist|
          var = (var + send((var =~ /^(\.\/|\/|\.\.|\.$)/ ? (:xpath) : (:css)), *(var + [var, var]).compact))
        end
        document.decorate(var)
        var
      end
      
      alias :/ :search
      ;Fi[	@#:icI"Ã          end
          var = (var + var.xpath(*(var + [var, var].compact)))
        end
        document.decorate(var)
        var
      end
      
      ###
      # Search this NodeSet for XPath +paths+;Fi[	@#:ipI"F        var = var.last.is_a?(Hash) ? (var.pop) : (nil)
        var = NodeSet.new(document)
        each { |arglist| var = (var + var.xpath(*(var + [var, var].compact))) }
        document.decorate(var)
        var
      end
      
      ###
      # Search this NodeSet's nodes' immediate children using CSS selector +selector+;Fi[@[ÅI"@var = {};FI"end;FI" ;Fi[[	@ÂiI"ó          end
          var.rewind
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist);Fi[	@ËiHI"¶            var.rewind
          end)
        end
        after_flush_writes
        @var = {}
      end
      
      def function(arglist)
        for var in @var do;Fi[	@ÎiﬁI"ô            var.rewind
          end
        end
        after_flush_writes
        @var = {}
      end
      
      #:nodoc:
      def function(arglist);Fi[@äk@ãk@lsI"/var = (var + var[var.chr]) if var[var.chr];Fi[[	@LiCI"ˇ    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@Oi3I"ˇ    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[	@Ri2I"ˇ    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else;Fi[@'@(I"(@var << var);FI"end;Fi[[	@
idI"a              raise(GemfileError, "You cannot specify the same gem twice coming from different sources.\nYou specified that #{dep.name} (#{dep.requirement}) should come from #{(current.source or "an unspecified source")} and #{dep.source}\n")
            end
          end
        end
      end
      (@var << var)
    end
    
    def function(arglist);Fi[	@OiZI"          if var and ((var.size == 1) and (var.first =~ /^\s*= (.+)\s*$/ and var.source.is_a?(Bundler::Source::Path))) then
            var.source.name = var
            var.source.version = $1
          end
        end
        (@var << var)
      end
    end
    ;Fi[	@Li:I"»            if var.add(var).! then
              (@var << var)
              var = new_row(var)
            end
          end
          (@var << var)
        end
        
        def function(arglist);Fi[I"(var << self[var]);FI"var = (var + 1);FI"var = (var + 1);FI"end;Fi[[	@}iπI"‡        case var[0]
        when "-" then
          while (var < var[1]) do
            (var << self[var])
            var = (var + 1)
            var = (var + 1)
          end
          var = (var + 1)
        when "+" then;Fi[	@}i¿I"Í          var = (var + 1)
        when "+" then
          while (var < var[1]) do
            (var << self[var])
            var = (var + 1)
            var = (var + 1)
          end
          (var << var[2])
          var = (var + 1);Fi[	@}iÃI"î      end
    end
    while (var < self.length) do
      (var << self[var])
      var = (var + 1)
      var = (var + 1)
    end
    return var
  end;Fi[@$zI" ;FI"def function(arglist);FI"
super;Fi[[	@oiI"class RedminePluginGenerator < Rails::Generators::NamedBase
  source_root(File.expand_path("../templates", "(string)"))
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[	@oiI"  
  argument(:actions, :type => :array, :default => ([]), :banner => "ACTION ACTION ...")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[	@ÄiI"'  
  class_option(:indexes, :type => :boolean, :default => (true), :desc => "Add indexes for references and belongs_to columns")
  
  attr_reader(:plugin_path, :plugin_name, :plugin_pretty_name)
  
  def function(arglist)
    super
    @var = file_name.underscore
    @var = plugin_name.titleize;Fi[@'@(I"	else;F@´Zi[[	@ iI"*        var.html { |arglist| render(:nothing => (true), :status => 201) }
        var.mobile do |arglist|
          render(:partial => "comment", :locals => ({ :post => (@var.post), :comment => (@var) }))
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end;Fi[	@ÌiI"        var.mobile { |arglist| redirect_to(post_path(@var.post_id)) }
        var.json do |arglist|
          render(:json => (@var.as_api_response(:backbone)), :status => 201)
        end
      end
    else
      render(:nothing => (true), :status => 422)
    end
  end;Fi[	@ÚiDI"ç        respond_to do |arglist|
          var.js do |arglist|
            render(:json => ({ :photo_id => (@var.id), :image_url => (@var.url(:thumb_large)), :image_url_medium => (@var.url(:thumb_medium)), :image_url_small => (@var.url(:thumb_small)), :author_id => (var) }), :status => 201)
          end
        end
      else
        render(:nothing => (true), :status => 422)
      end
    else;Fi[I""assert_equal(@var, @var.root);FI""assert_equal(@var, @var.root);FI""assert_equal(@var, @var.root);FI""assert_equal(@var, @var.root);Fi[[	@äipI"  
  def function(arglist)
    assert_equal(@var, TreeMixin.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root);Fi[	@äiqI"  def function(arglist)
    assert_equal(@var, TreeMixin.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
  end;Fi[	@äirI"˚    assert_equal(@var, TreeMixin.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
    assert_equal(@var, @var.root)
  end
  ;Fi[I"var.column(:body, :text);FI"%var.column(:parent_id, :integer);FI"var.column(:lft, :integer);FI"var.column(:rgt, :integer);Fi[[	I"Ddata//redmine_proj/plugins/awesome_nested_set/spec/db/schema.rb;TiI"'    var.column(:name, :string)
  end
  create_table(:notes, :force => (true)) do |arglist|
    var.column(:body, :text)
    var.column(:parent_id, :integer)
    var.column(:lft, :integer)
    var.column(:rgt, :integer)
    var.column(:notable_id, :integer)
    var.column(:notable_type, :string);Fi[	@ÉiI"    var.column(:black, :integer)
  end
  create_table(:things, :force => (true)) do |arglist|
    var.column(:body, :text)
    var.column(:parent_id, :integer)
    var.column(:lft, :integer)
    var.column(:rgt, :integer)
    var.column(:children_count, :integer)
  end;Fi[	I"Ddata//redmine_proj/plugins/awesome_nested_set/test/db/schema.rb;TiI"'    var.column(:name, :string)
  end
  create_table(:notes, :force => (true)) do |arglist|
    var.column(:body, :text)
    var.column(:parent_id, :integer)
    var.column(:lft, :integer)
    var.column(:rgt, :integer)
    var.column(:notable_id, :integer)
    var.column(:notable_type, :string);Fi[I"var.column(:name, :string);FI"%var.column(:parent_id, :integer);FI"var.column(:lft, :integer);FI"var.column(:rgt, :integer);Fi[[	@ÉiI"%ActiveRecord::Schema.define(:version => 0) do |arglist|
  create_table(:categories, :force => (true)) do |arglist|
    var.column(:name, :string)
    var.column(:parent_id, :integer)
    var.column(:lft, :integer)
    var.column(:rgt, :integer)
    var.column(:organization_id, :integer)
  end;Fi[	@Éi&I"Û    var.column(:children_count, :integer)
  end
  create_table(:brokens, :force => (true)) do |arglist|
    var.column(:name, :string)
    var.column(:parent_id, :integer)
    var.column(:lft, :integer)
    var.column(:rgt, :integer)
  end
end;Fi[	@ÉiI"%ActiveRecord::Schema.define(:version => 0) do |arglist|
  create_table(:categories, :force => (true)) do |arglist|
    var.column(:name, :string)
    var.column(:parent_id, :integer)
    var.column(:lft, :integer)
    var.column(:rgt, :integer)
    var.column(:organization_id, :integer)
  end;Fi[@'@(@)I"out(">>");Fi[[	@Li!I"¸              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[	@Oi*I"¸              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[	@RiI"¸              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then;Fi[@'@(@)I"	self;Fi[[	@Æi<I"6        else
          Rails.logger.info("event=receive status=abort reason='object signature not valid' recipient=#{recipient.diaspora_handle} sender=#{self.parent.author.diaspora_handle} payload_type=#{self.class} parent_id=#{self.parent.id}")
          return
        end
      end
    end
    self
  end
  ;Fi[	@ë
i‰I"ı                set_relation(var, get_relation(var, var).substitute(var.substitutable))
              else
                __build__(var, var.substitutable, var)
              end
            end
          end
          self
        end
        ;Fi[	@i9I"0              var = var.value[0].value.first
              var.value[0].value = ["*"]
              var.value[1] = Node.new(:COMBINATOR, [Node.new(:FUNCTION, ["#{match.value[1].value.first}("]), Node.new(:FUNCTION, ["self(", var])])
            end
          end
        end
        self
      end
      ;Fi[I",var = Category.create(:name => "Root1");FI",var = Category.create(:name => "Root2");FI",var = Category.create(:name => "Root3");FI"var.move_to_child_of(var);Fi[[	@ŒkiKI"_    (categories(:child_2_1).right.should == 9)
  end
  it("move_to_child_more_than_once_per_parent_rebuild") do |arglist|
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text;Fi[	@ŒkiaI"V    (Category.roots.last.to_text.should == var)
  end
  it("should be able to rebuild without validating each record") do |arglist|
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var.name = nil;Fi[	@öiãI"f  
  #rebuild swaps the position of the 2 children when added using move_to_child twice onto same parent
  def function(arglist)
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text;Fi[@9É@:É@;É@…ki[[	@ŒkiLI"b  end
  it("move_to_child_more_than_once_per_parent_rebuild") do |arglist|
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null");Fi[	@ŒkibI"J  end
  it("should be able to rebuild without validating each record") do |arglist|
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var.name = nil
    var.save!(:validate => (false));Fi[	@öiåI"ï  #rebuild swaps the position of the 2 children when added using move_to_child twice onto same parent
  def function(arglist)
    var = Category.create(:name => "Root1")
    var = Category.create(:name => "Root2")
    var = Category.create(:name => "Root3")
    var.move_to_child_of(var)
    var.move_to_child_of(var)
    var = Category.roots.last.to_text
    Category.update_all("lft = null, rgt = null");Fi[I"0(categories(:child_2).should == var.parent);FI"6(categories(:child_2).id.should == var.parent_id);F@Ìk@Óki[[	@ŒkiI"_  end
  it("assigning_parent_id_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end;Fi[	@Œki	I"V  end
  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end;Fi[	@Œki5I"H  end
  it("creating_child_from_parent") do |arglist|
    var = categories(:child_2).children.create!(:name => "Child")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end;Fi[@MÉ@Ìk@Ók@Ôki[[	@ŒkiI"â  it("assigning_parent_id_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent_id => (categories(:child_2).id))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_on_create") do |arglist|;Fi[	@Œki
I"ä  it("assigning_parent_on_create") do |arglist|
    var = Category.create!(:name => "Child", :parent => (categories(:child_2)))
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  it("assigning_parent_id_to_nil_on_create") do |arglist|;Fi[	@Œki6I"í  it("creating_child_from_parent") do |arglist|
    var = categories(:child_2).children.create!(:name => "Child")
    (categories(:child_2).should == var.parent)
    (categories(:child_2).id.should == var.parent_id)
    var.left.should_not(be_nil)
    var.right.should_not(be_nil)
    Category.valid?.should(be_true)
  end
  # create a new top-level node and move single-node top-level tree inside it.;Fi[@'@(@)I"return var;Fi[[	@«iîI"ﬂ              next if var.nil?
              var = var.instance_variable_get("@cell_matrix")
              var = (var + var.size) unless var.nil?
            end
          end
        end
        return var
      end
      ;Fi[	@ciÓ
I"x          (var << 65533)
          var = []
          var = 1
        end
      end
    end
    return var
  end
  ;Fi[	@ci/I"õ          (var << var.&(255).chr)
          (var << (var >> 8).chr)
          (var << var.&(255).chr)
        end
      end
    end
    return var
  end
  ;Fi[@'@(@)I"end while var;Fi[[	@LiSI"´                      end
                    end
                  end
                end
              end
            end
          end while var
        end
      end;Fi[	@Ui†I"˘            var.read(4)
          else
            (var == "IEND") ? (break) : (var.read((var + 4)))
          end
        end
      end
    end while var
    if (var == "Indexed") and (var == "") then
      self.Error(("Missing palette in " + var));Fi[	@ci 
I"û              var.read(4)
            else
              (var == "IEND") ? (break) : (var.read((var + 4)))
            end
          end
        end
      end while var
      Error(("Missing palette in " + var)) if (var == "Indexed") and var.empty?
      return { "w" => (var), "h" => (var), "cs" => (var), "bpc" => (var), "f" => "FlateDecode", "parms" => (var), "pal" => (var), "trns" => (var), "data" => (var) });Fi[I"assert(Category.valid?.!);FI"end;FI" ;FI"def function(arglist);Fi[[	@öi¶I"⁄  def function(arglist)
    assert(Category.valid?)
    Category.update_all("lft = null")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.update_all("rgt = null");Fi[	@öi¨I"·  def function(arglist)
    assert(Category.valid?)
    Category.update_all("rgt = null")
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    Category.delete(categories(:child_2).id);Fi[	@öiπI"‡    assert(Category.valid?)
    categories(:top_level_2)["lft"] = 0
    categories(:top_level_2).save
    assert(Category.valid?.!)
  end
  
  def function(arglist)
    assert(Category.valid?)
    var = Category.root.to_text;Fi[@'@(@é@æyi[[	@ûi@I"4          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@∫i9I"4          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[	@¬i=I"4          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield };Fi[@'@(@éI"L# Resets any errors previously added when invalidating the given object;Fi[[	@îi,I"          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?;Fi[	@≤i)I""            var.each { |arglist| (var << "#{field_name} #{error}") }
          end
          (var * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?;Fi[	@ i)I"ˆ          "Transition halted"
        else
          (var.errors.full_messages * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear;Fi[I"R# * <tt>:border_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.;FI"@# * <tt>:border_width</tt> - Default value is <tt>0.5</tt>.;FI"U# * <tt>:fill</tt> - Fill the box, 0 = no, 1 = yes? Default value is <tt>1</tt>.;FI"[# * <tt>:fill_color</tt> - Default value is nothing or <tt>COLOR_PALETTE[:white]</tt>.;Fi[[	@>liI"Ò  # 
  # Options are:
  # * <tt>:border</tt> - Draw a border, 0 = no, 1 = yes? Default value is <tt>1</tt>.
  # * <tt>:border_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:border_width</tt> - Default value is <tt>0.5</tt>.
  # * <tt>:fill</tt> - Fill the box, 0 = no, 1 = yes? Default value is <tt>1</tt>.
  # * <tt>:fill_color</tt> - Default value is nothing or <tt>COLOR_PALETTE[:white]</tt>.
  # * <tt>:fill_colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #;Fi[	@>liqI"Ò  # 
  # Options are:
  # * <tt>:border</tt> - Draw a border, 0 = no, 1 = yes? Default value is <tt>1</tt>.
  # * <tt>:border_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:border_width</tt> - Default value is <tt>0.5</tt>.
  # * <tt>:fill</tt> - Fill the box, 0 = no, 1 = yes? Default value is <tt>1</tt>.
  # * <tt>:fill_color</tt> - Default value is nothing or <tt>COLOR_PALETTE[:white]</tt>.
  # * <tt>:fill_colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #;Fi[	@>liãI"£  # Options are:
  # * <tt>:align</tt> - Vertical alignment 'C' = center, 'L' = left, 'R' = right. Default value is <tt>'C'</tt>.
  # * <tt>:border</tt> - Draw a border, 0 = no, 1 = yes? Default value is <tt>0</tt>.
  # * <tt>:border_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:border_width</tt> - Default value is <tt>0.5</tt>.
  # * <tt>:fill</tt> - Fill the box, 0 = no, 1 = yes? Default value is <tt>1</tt>.
  # * <tt>:fill_color</tt> - Default value is nothing or <tt>COLOR_PALETTE[:white]</tt>.
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is nothing or <tt>8</tt>.;Fi[I">var[:border_color] ||= Core::RFPDF::COLOR_PALETTE[:black];FI"var[:border_width] ||= 0.5;FI"var[:fill] ||= 1;FI"<var[:fill_color] ||= Core::RFPDF::COLOR_PALETTE[:white];Fi[[	@>liI")  	#
  def function(arglist)
    var[:border] ||= 1
    var[:border_color] ||= Core::RFPDF::COLOR_PALETTE[:black]
    var[:border_width] ||= 0.5
    var[:fill] ||= 1
    var[:fill_color] ||= Core::RFPDF::COLOR_PALETTE[:white]
    var[:fill_colorspace] ||= :rgb
    SetLineWidth(var[:border_width]);Fi[	@>li}I")  	#
  def function(arglist)
    var[:border] ||= 1
    var[:border_color] ||= Core::RFPDF::COLOR_PALETTE[:black]
    var[:border_width] ||= 0.5
    var[:fill] ||= 1
    var[:fill_color] ||= Core::RFPDF::COLOR_PALETTE[:white]
    var[:fill_colorspace] ||= :rgb
    SetLineWidth(var[:border_width]);Fi[	@>li§I"P  def function(arglist)
    var[:align] ||= "C"
    var[:border] ||= 0
    var[:border_color] ||= Core::RFPDF::COLOR_PALETTE[:black]
    var[:border_width] ||= 0.5
    var[:fill] ||= 1
    var[:fill_color] ||= Core::RFPDF::COLOR_PALETTE[:white]
    var[:font] ||= default_font
    var[:font_color] ||= Core::RFPDF::COLOR_PALETTE[:black];Fi[I"H# * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.;F@8lI"#;FI"# Example:;Fi[[	@>li=I"l  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text(x, y, header_left, :font_size => 10);Fi[	@>liUI"|  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>10</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_text_block(left_margin, 85, "question", left_margin, 280,;Fi[	@>li‡I"Z  # Options are:
  # * <tt>:font_color</tt> - Default value is <tt>COLOR_PALETTE[:black]</tt>.
  # * <tt>:font_size</tt> - Default value is <tt>18</tt>.
  # * <tt>:font_style</tt> - Default value is nothing or <tt>''</tt>.
  # * <tt>:colorspace</tt> - Default value is :rgb or <tt>''</tt>.
  #
  # Example:
  #
  	#   draw_title(left_margin, 60, ;Fi[@'@(@éI"extend(ClassMethods);Fi[[	@]iRI"Ö              self[nil]
            end
          end
        end
      end
      
      extend(ClassMethods)
      
      self.reset;Fi[	@{i/I"±        
        def function(arglist)
          File.expand_path(var.location)
        end
      end
      
      extend(ClassMethods)
      
      include(ExampleGroupMethods);Fi[	@°iYI"”        # active
        def function(arglist)
          versions.each { |arglist| var.extend(var) if var.active? }
        end
      end
      
      extend(ClassMethods)
      
      def self.included(arglist);Fi[I"var[:font_style] ||= "";FI"9set_text_color_a(var[:font_color], var[:colorspace]);FI";SetFont(var[:font], var[:font_style], var[:font_size]);FI"SetXY(var, var);Fi[[	@>liHI"F    var[:font_color] ||= Core::RFPDF::COLOR_PALETTE[:black]
    var[:font] ||= default_font
    var[:font_size] ||= 10
    var[:font_style] ||= ""
    set_text_color_a(var[:font_color], var[:colorspace])
    SetFont(var[:font], var[:font_style], var[:font_size])
    SetXY(var, var)
    Write((var[:font_size] + 4), var)
  end;Fi[	@>licI"I    var[:font] ||= default_font
    var[:font_color] ||= Core::RFPDF::COLOR_PALETTE[:black]
    var[:font_size] ||= 10
    var[:font_style] ||= ""
    set_text_color_a(var[:font_color], var[:colorspace])
    SetFont(var[:font], var[:font_style], var[:font_size])
    SetXY(var, var)
    SetLeftMargin(var)
    SetRightMargin(var);Fi[	@>liÌI"F    var[:font_color] ||= Core::RFPDF::COLOR_PALETTE[:black]
    var[:font] ||= default_font
    var[:font_size] ||= 18
    var[:font_style] ||= ""
    set_text_color_a(var[:font_color], var[:colorspace])
    SetFont(var[:font], var[:font_style], var[:font_size])
    SetXY(var, var)
    Write((var[:font_size] + 2), var)
  end;Fi[@'@(@éI"###;Fi[[	@ciîI"        return var.first if (var.length == 1)
        NodeSet.new(document) do |arglist|
          var.each { |arglist| var.each { |arglist| (var << var) } }
        end
      end
      
      ###
      # call-seq: css *rules, [namespace-bindings, custom-pseudo-class]
      #;Fi[	@Çi<I"∫            parse_io(var, &var)
          else
            parse_memory(var, &var)
          end
        end
        
        ###
        # Parse given +io+
        def function(arglist);Fi[	@ïi%I"           else
            raise(ArgumentError, "Must provide Nokogiri::Xml::Document or the name of an existing file")
          end
        end
      end
      
      ###
      # Returns true if +thing+ is a valid Nokogiri::XML::Document or
      # file.;Fi[@al@}S@zI"var = filesize(var);Fi[[	@Li˜I"      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[	@Oi I"      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[	@RiÊI"      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var));Fi[@al@}S@˘zI"%if (var["type"] == "Type0") then;Fi[[	@Li	I"«      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[	@OiI"«      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[	@Ri¯I"«      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else;Fi[@alI"var = var["cw"];FI"var = "[";FI"B32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[[	@Li'I"        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[	@Oi0I"        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[	@RiI"        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj");Fi[@al@_I"'var["desc"].each_pair do |arglist|;FI"/var = (var + (((" /" + var) + " ") + var));Fi[[	@Li-I"W          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[	@Oi6I"W          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[	@RiI"W          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"];Fi[@'@(@é@›ci[[	@¢
i#I"              else
                target.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #;Fi[	@¥
iI"*            target.parentize(base)
            binding do |arglist|
              target.do_or_do_not(metadata.inverse_setter(target), base)
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #;Fi[	@Ω
i$I"Ÿ                  end
                end
              end
            end
          end
          
          # Unbinds the base object and the inverse, caused by setting the
          # reference to nil.
          #;Fi[@'@(@éI"J# Turn the object from the ruby type we deal with to a Mongo friendly;Fi[[	@)	iâI"            var.blank? ? (var) : (var.convert(var))
          else
            var.blank? ? ([]) : (var.convert(Array(var)))
          end
        end
        
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #;Fi[	@?	iI"·        else
          var = to_time
          var.respond_to?(:getlocal) ? (var.getlocal) : (var)
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #;Fi[	@Z	i}I"Œ          return instance_variable_get("@#{name}")
        else
          false
        end
      end
      
      # Turn the object from the ruby type we deal with to a Mongo friendly
      # type.
      #;Fi[@'@(@éI"A# DATABASE STATEMENTS ======================================;Fi[[	@IiﬁI"          yield)
        ensure
          update("SET FOREIGN_KEY_CHECKS = #{old}")
        end
      end
      
      # DATABASE STATEMENTS ======================================
      # Executes the SQL statement in the context of this connection.
      def function(arglist);Fi[	@QiUI"ˆ        unless @var.nil? then
          @var.close
          @var = nil
        end
      end
      
      # DATABASE STATEMENTS ======================================
      def function(arglist)
        var = "EXPLAIN #{to_sql(arel, binds.dup)}";Fi[	@ViºI"=        if @var.respond_to?(:change_user) then
          @var.change_user(@var[:username], @var[:password], @var[:database])
          configure_connection
        end
      end
      
      # DATABASE STATEMENTS ======================================
      def function(arglist)
        @var.query_with_result = true;Fi[@'@¸@æy@øyi[[	@ûiAI"Ò        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@∫i:I"Ò        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[	@¬i>I"Ò        else
          super
        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end;Fi[@'@¸@”y@‘yi[[	@ûi8I"K      # Initializes dynamic states
      def function(arglist)
        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true));Fi[	@∫i1I"T      def function(arglist)
        owner_class.key(attribute, String) unless attribute_key
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true));Fi[	@¬i5I"c      def function(arglist)
        owner_class.field(attribute, :type => (String)) unless attribute_field
        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true));Fi[@'@¸I"A# Adds hooks into validation for automatically firing events;FI"def function(arglist);Fi[[	@îiïI"$            var.invalidate(var, :state, :invalid) unless var.states.match(var)
          end
        end
      end
      
      # Adds hooks into validation for automatically firing events
      def function(arglist)
        super
        define_validation_hook if runs_validations_on_action?;Fi[	@≤ieI"+            var.states.match(self) ? (true) : ([false, var.generate_message(:invalid)])
          end
        end
      end
      
      # Adds hooks into validation for automatically firing events
      def function(arglist)
        super
        if (action == :save) and supports_validations? then;Fi[	@ i^I"Ø      def function(arglist)
        super
        define_validation_hook if (action == :save)
      end
      
      # Adds hooks into validation for automatically firing events
      def function(arglist)
        define_helper(:instance, "            def around_validation(*)\n              self.class.state_machines.transitions(self, :save, :after => false).perform { super }\n            end\n", "(string)", (369 + 1))
      end;Fi[@˜U@
ÅI"newobj;F@‡Éi[[	@Li%I"Ô          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[	@Oi.I"Ô          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[	@RiI"Ô          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) };Fi[@˜U@]\@_@ÎÉi[[	@Li,I"O          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[	@Oi5I"O          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[	@RiI"O          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end;Fi[@'@¸@ÑÉI"def function(arglist);Fi[[	@îi-I"˚        else
          (var.errors.full_messages * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?
      end;Fi[	@≤i*I"Á          end
          (var * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear if supports_validations?
      end;Fi[	@ i*I"‚        else
          (var.errors.full_messages * ", ")
        end
      end
      
      # Resets any errors previously added when invalidating the given object
      def function(arglist)
        var.errors.clear
      end;Fi[@'@¸@z@zi[[	@îi#I"`          var = default_error_message_options(var, var, var)
          var.errors.add(var, var, var.merge(var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then;Fi[	@≤iI"`        if supports_validations? then
          var.errors.add(self.attribute(var), generate_message(var, var))
        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then;Fi[	@ i I"|      # Adds a validation error to the given object
      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then;Fi[@ˆq@˜q@¯qI"@AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var);Fi[[	@LiI"	  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[	@OiI"	  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[	@RiI"	  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  ;Fi[@˜q@¯q@KÑI"end;Fi[[	@LiI"  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[	@OiI"  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[	@RiI"  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist);Fi[@¯q@KÑI"end;FI" ;Fi[[	@LiI".  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths;Fi[	@OiI";  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = "KozMinPro-Regular-Acro";Fi[	@RiI"-  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths;Fi[@KÑI"end;FI" ;FI"def function(arglist);Fi[[	@LiI".    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = Big5_widths
    var = "ETenms-B5-H";Fi[	@OiI"9    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = "KozMinPro-Regular-Acro"
    var = SJIS_widths;Fi[	@RiI"-    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var)
    AddCIDFont(var, "BI", (var + ",BoldItalic"), var, var, var)
  end
  
  def function(arglist)
    var = UHC_widths
    var = "KSCms-UHC-H";Fi[@'@¸I"2# Adds a validation error to the given object;FI"def function(arglist);Fi[[	@îiI"+      
      def self.matching_ancestors(arglist)
        ["ActiveModel", "ActiveModel::Observing", "ActiveModel::Validations"]
      end
      
      # Adds a validation error to the given object 
      def function(arglist)
        if supports_validations? then
          var = self.attribute(var);Fi[	@≤iI"P      def self.extended(arglist)
        require("dm-core/version") unless ::DataMapper.const_defined?("VERSION")
        super
      end
      
      # Adds a validation error to the given object
      def function(arglist)
        if supports_validations? then
          var.errors.add(self.attribute(var), generate_message(var, var));Fi[	@ iI"Ò          (var.changed_columns << var)
        end
        var
      end
      
      # Adds a validation error to the given object
      def function(arglist)
        var.errors.add(self.attribute(var), generate_message(var, var))
      end;Fi[I"(AddCIDFonts(var, var, cw, var, var);FI"end;FI" ;FI"def function(arglist);Fi[[	@Li3I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "GBK-EUC-H"
    var = { "ordering" => "GB1", "supplement" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var);Fi[	@Oi#I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "90ms-RKSJ-H"
    var = { "ordering" => "Japan1", "supplement" => 2 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var);Fi[	@Ri"I"    32.upto(126) { |arglist| cw[var.chr] = 500 }
    var = "KSCms-UHC-HW-H"
    var = { "ordering" => "Korea1", "supplement" => 1 }
    AddCIDFonts(var, var, cw, var, var)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var);Fi[I"return super(var);FI"end;FI"end;FI" ;Fi[[	@Li:I"û    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[	@Oi*I"†    if (@var["type"] == "Type0") then
      return GetSJISStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[	@Ri)I"û    if (@var["type"] == "Type0") then
      return GetMBStringWidth(var)
    else
      return super(var)
    end
  end
  
  def function(arglist)
    var = 0;Fi[@GmI"var = var.length;FI"var = 0;F@îyi[[	@Li@I"–  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@Oi0I"–  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[	@Ri/I"–  
  def function(arglist)
    var = 0
    var = @var["cw"]
    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then;Fi[@'@¸@∞ÉI" ;Fi[[	@]iSI"z            end
          end
        end
      end
      
      extend(ClassMethods)
      
      self.reset
    end;Fi[	@{i0I"Ø        def function(arglist)
          File.expand_path(var.location)
        end
      end
      
      extend(ClassMethods)
      
      include(ExampleGroupMethods)
      ;Fi[	@°iZI"¸        def function(arglist)
          versions.each { |arglist| var.extend(var) if var.active? }
        end
      end
      
      extend(ClassMethods)
      
      def self.included(arglist)
        var.class_eval { |arglist| extend(ClassMethods) };Fi[@'@¸@¬z@√zi[[	@2iI"<        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@;iI"<        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[	@IiI"<        def function(arglist)
          @var, @var = var, var
          @var = var.send(var.name)
        end
        
        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #;Fi[@ãk@ls@ÕÇI"var = (var + 1);Fi[[	@LiDI"    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[	@Oi4I"    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then;Fi[	@Ri3I"    var = var.length
    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000);Fi[@ls@ÕÇI"var = (var + 1);FI"	else;Fi[[	@LiEI"    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[	@Oi5I"    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        if (var >= 161) and (var <= 223) then
          var = (var + 500);Fi[	@Ri4I"    var = 0
    while (var < var) do
      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      if (var < 128) then
        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2);Fi[@;pI"var = (var + 2);FI"end;FI"end;Fi[[	@LiII"¡        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[	@Oi=I"∏          var = (var + 500)
          var = (var + 1)
        else
          var = (var + 1000)
          var = (var + 2)
        end
      end
    end
    return ((var * @var) / 1000);Fi[	@Ri8I"¡        var = (var + var[var.chr]) if var[var.chr]
        var = (var + 1)
      else
        var = (var + 1000)
        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end;Fi[@=ÅI"end;FI" ;FI"def function(arglist);Fi[[	@LiMI"∆        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[	@OiBI"º        end
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var);Fi[	@Ri<I"∆        var = (var + 2)
      end
    end
    return ((var * @var) / 1000)
  end
  
  def function(arglist)
    if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var);Fi[@%pI"end;FI"end;FI" ;Fi[[	@LiTI"     if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[	@OiII"Ã    if (@var["type"] == "Type0") then
      SJISMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[	@RiCI"     if (@var["type"] == "Type0") then
      MBMultiCell(var, var, var, var, var, var, var)
    else
      super(var, var, var, var, var, var, var)
    end
  end
  
  def function(arglist)
    var = @var;Fi[@'@¸@ÕzI"#;Fi[[	@≠
iI"                var.do_or_do_not(metadata.inverse_setter(target), base)
              end
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.addresses.unbind_one(document);Fi[	@Œ
iI"%          # @since 2.0.0.rc.1
          def function(arglist)
            binding { |arglist| bind_from_relational_parent(var) }
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.posts.unbind_one(document);Fi[	@’
iI"/              base.synced[metadata.foreign_key] = true
              var.synced[metadata.inverse_foreign_key] = true
            end
          end
          
          # Unbind a single document.
          #
          # @example Unbind the document.
          #   person.preferences.unbind_one(document);Fi[@Im@Jm@ém@ùyi[[	@Li]I"    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[	@OiRI"    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[	@RiLI"    var = @var
    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then;Fi[@'@¸@‰zI"#;Fi[[	@≠9isI"    # Returns the Hash representation of this Page.
    def function(arglist)
      self.data.deep_merge("url" => (File.join(@var, self.url)), "content" => (self.content))
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #;Fi[	@¸iøI"%    def function(arglist)
      var = { "site" => ({ "related_posts" => (related_posts(var["site"]["posts"])) }), "page" => (self.to_liquid) }.deep_merge(var)
      do_layout(var, var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #;Fi[	@÷4iI"»    # Returns source file path.
    def function(arglist)
      File.join(@var, @var, @var)
    end
    
    # Obtain destination path.
    #
    # dest - The String path to the destination dir.
    #;Fi[@'@¸@{I"#;Fi[[	@ÂiI"˚    # Returns the contents as a String.
    def function(arglist)
      (self.content or "")
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.;Fi[	@≠9iI"ˆ      @var = var
      self.process(var)
      self.read_yaml(File.join(var, var), var)
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.;Fi[	@¸i<I"      if self.categories.empty? then
        self.categories = self.data.pluralized_array("category", "categories")
      end
    end
    
    # Read the YAML frontmatter.
    #
    # base - The String path to the dir containing the file.
    # name - The String filename of the file.;Fi[@'@¸I"3# Input is escaped, output is always HTML safe;FI"def function(arglist);Fi[[	@Fi$I"a      # Output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(list_of_without_haml_xss(*var, &var))
      end
      
      # Input is escaped, output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(surround_without_haml_xss(haml_xss_html_escape(var), haml_xss_html_escape(var), &var))
      end;Fi[	@Fi)I"à      # Input is escaped, output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(surround_without_haml_xss(haml_xss_html_escape(var), haml_xss_html_escape(var), &var))
      end
      
      # Input is escaped, output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(precede_without_haml_xss(haml_xss_html_escape(var), &var))
      end;Fi[	@Fi.I"l      # Input is escaped, output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(precede_without_haml_xss(haml_xss_html_escape(var), &var))
      end
      
      # Input is escaped, output is always HTML safe
      def function(arglist)
        Haml::Util.html_safe(succeed_without_haml_xss(haml_xss_html_escape(var), &var))
      end;Fi[@Im@zI"var = (var + 1);FI"	next;Fi[[	@Li–I"(            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@RiøI"(            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + (var ? (1) : (2))) if (var == var);Fi[	@Ui™I"            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end
          var = (var + 1) if (var == var);Fi[@Jm@Ïm@ùyI"var = 0;Fi[[	@Li^I"    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[	@OiSI"    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[	@RiMI"    var = @var["cw"]
    var = ((@var - @var) - @var) if (var == 0)
    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then;Fi[@'@¸I"module FormHelper;FI"def function(arglist);Fi[[	I"5data//haml_proj/haml/helpers/action_view_mods.rb;Ti{I"      alias_method(:form_tag_without_haml, :form_tag)
      
      alias_method(:form_tag, :form_tag_with_haml)
    end
    
    module FormHelper
      def function(arglist)
        var = (block_given? and (is_haml? and block_is_haml?(var)))
        if var then;Fi[	I";data//haml_proj/haml/helpers/rails_323_textarea_fix.rb;TiI"–      end
      
      alias_method_chain(:text_area_tag, :haml)
    end
    
    module FormHelper
      def function(arglist)
        text_area_without_haml(*var).sub(">&#x000A;", ">\n").html_safe
      end;Fi[	@FiÅI"(      alias_method(:form_tag_without_haml_xss, :form_tag)
      
      alias_method(:form_tag, :form_tag_with_haml_xss)
    end
    
    module FormHelper
      def function(arglist)
        var = form_for_without_haml_xss(*var, &var)
        return Haml::Util.html_safe(var) if var.is_a?(String);Fi[@ùyI"var = 0;FI"if var then;F@€Li[[	@Li`I"¸    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[	@OiUI"¸    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[	@RiOI"¸    var = (((var - (2 * @var)) * 1000) / @var)
    var = var.gsub("\r", "")
    var = var.length
    var = (var - 1) if (var > 0) and (var[(var - 1)] == "\n")
    var = 0
    if var then
      if (var == 1) then
        var = "LTRB"
        var = "LRT";Fi[@'@¸I"# @note Validation;FI"def function(arglist);Fi[[	@isI"Î  # @note before_save
  def function(arglist)
    self.service ||= "email"
  end
  
  # @note Validation
  def function(arglist)
    if (self.identifier == self.sender.email) then
      (errors[:base] << "You can not invite yourself.");Fi[	@izI"    if (self.identifier == self.sender.email) then
      (errors[:base] << "You can not invite yourself.")
    end
  end
  
  # @note Validation
  def function(arglist)
    if self.sender_id.!=(self.aspect.user_id) then
      (errors[:base] << "You do not own that aspect.");Fi[	@iÉI"J    if self.recipient.username? then
      (errors[:recipient] << "The user '#{self.identifier}' (#{self.recipient.diaspora_handle}) is already on this pod, so we sent them a share request")
    end
  end
  
  # @note Validation
  def function(arglist)
    return false unless self.identifier
    if (self.service == "email") then;Fi[@'@¸I"O# Generate a token checking if one does not already exist in the database.;FI"def function(arglist);Fi[[	@äi“I"A          var = find_or_initialize_with_error_by(:confirmation_token, var)
          var.confirm! if var.persisted?
          var
        end
        
        # Generate a token checking if one does not already exist in the database.
        def function(arglist)
          generate_token(:confirmation_token)
        end;Fi[	@òi^I"e          var = find_or_initialize_with_errors(reset_password_keys, var, :not_found)
          var.send_reset_password_instructions if var.persisted?
          var
        end
        
        # Generate a token checking if one does not already exist in the database.
        def function(arglist)
          generate_token(:reset_password_token)
        end;Fi[	@¶i0I"U      module ClassMethods
        def function(arglist)
          find_for_authentication(:authentication_token => (var[token_authentication_key]))
        end
        
        # Generate a token checking if one does not already exist in the database.
        def function(arglist)
          generate_token(:authentication_token)
        end;Fi[@'@¸@ÿzI" ;Fi[[	@riI"–      
      def function(arglist)
        @var, @var, @var, @var, @var = var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var;Fi[	@uiI"Ê      
      def function(arglist)
        @var, @var, @var, @var, @var, @var, @var = var, var, var, var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var;Fi[	@êiI"≈      
      def function(arglist)
        @var, @var, @var, @var = var, var, var, var
      end
      
      attr_reader(:gherkin_statement)
      
      def function(arglist)
        @var ||= var;Fi[@'@¸@ﬁy@ﬂyi[[	@{iI"^        # depot.
        def function(arglist)
          "head"
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist);Fi[	@{iI"µ        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist);Fi[	@{i I"µ        # the files must be copied from there to their intended resting place.
        def function(arglist)
          p4_sync(var, var, p4sync_flags)
        end
        
        # Returns the command that will sync the given revision to the given
        # destination directory. The perforce client has a fixed destination so
        # the files must be copied from there to their intended resting place.
        def function(arglist);Fi[@'@¸@»y@…yi[[	@[i@I"          return var unless (:head == var)
          var = scm("revno", repository)
          var = yield(var)
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end;Fi[	@{i7I"[          return var if var.to_s =~ /^\d+$/
          var = scm(authentication, :changes, "-s submitted", "-m 1", "//#{p4client}/...#{rev_no(revision)}")
          yield(var)[/Change (\d+) on/, 1]
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end;Fi[	@Çi>I"P            raise("tried to run `#{command}' and got unexpected result #{result.inspect}")
          end
          [(var["Last Changed Rev"] or 0).to_i, (var["Revision"] or 0).to_i].max
        end
        
        # Increments the given revision number and returns it.
        def function(arglist)
          (var.to_i + 1)
        end;Fi[@(I"@var = nil;FI"end;FI" ;Fi[[	@LiI"Ω      @var = var
      @var = []
      @var = var
      @var = var
      @var = nil
    end
    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then;Fi[	@ßiI"¢      def function(arglist)
        @var = var
        @var = var
        @var = var
        @var = nil
      end
      
      def function(arglist)
        begin;Fi[	@€i$I"†        @var = []
        @var = nil
        @var = false
        @var = var
        @var = nil
      end
      
      def function(arglist)
        var = clone;Fi[@Ñn@≤p@ÅuI"end;Fi[[	@LiiI"Û        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[	@Oi^I"Û        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[	@RiXI"Û        var = "LR"
      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1;Fi[@≤p@ÅuI"end;FI"end;Fi[[	@LijI"Ï      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@Oi_I"Ï      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[	@RiYI"Ï      else
        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0;Fi[@ÅuI"end;FI"end;FI"var = -1;Fi[[	@LikI"Ì        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@Oi`I"Ì        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[	@RiZI"Ì        var = ""
        var = "L" unless var.to_s.index("L").nil?
        var = (var + "R") unless var.to_s.index("R").nil?
        var = var.to_s.index("T") ? ((var + "T")) : (var)
      end
    end
    var = -1
    var = 0
    var = 0;Fi[@'@¸@ø{@¿{i[[	@[iI"2        # committed revision.
        def function(arglist)
          :head
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, "--lightweight", revswitch(var), repository, var);Fi[	@`iI"r        # repository.
        def function(arglist)
          "HEAD"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          [prep_destination(var), scm(verbose, cvs_root, :checkout, cvs_revision(var), cvs_destination(var), variable(:scm_module))].join(" && ");Fi[	@ÇiI"U        # repository.
        def function(arglist)
          "HEAD"
        end
        
        # Returns the command that will check out the given revision to the
        # given destination.
        def function(arglist)
          scm(:checkout, arguments, arguments(:checkout), verbose, authentication, "-r#{revision}", repository, var);Fi[@'@¸I"def self.included(arglist);FI"var.extend(ClassMethods);Fi[[	@´iI"Í      def function(arglist)
        @var ||= { :authorize => ({}), :load => ({}) }
      end
    end
    
    def self.included(arglist)
      var.extend(ClassMethods)
      var.helper_method(:can?, :cannot?, :current_ability)
    end;Fi[	@|iI"¥      def function(arglist)
        var.model_adapter(self, var).database_records
      end
    end
    
    def self.included(arglist)
      var.extend(ClassMethods)
    end
  end;Fi[	@¨iI"’      
      def self.required_fields(arglist)
        []
      end
      
      def self.included(arglist)
        var.extend(ClassMethods)
        assert_validations_api!(var)
        var.class_eval do |arglist|;Fi[@'@¸I"#if (RUBY_VERSION > "1.9") then;FI"##;Fi[[	@ïdiI"ø  def function(arglist)
    super
    @var = nil
  end
  
  if (RUBY_VERSION > "1.9") then
    ##
    # From ruby trunk r33086 including http://redmine.ruby-lang.org/issues/5341
    # :nodoc:;Fi[	@oi™I"  # Is the request idempotent or is retry_change_requests allowed
  def function(arglist)
    (retry_change_requests or idempotent?(var))
  end
  
  if (RUBY_VERSION > "1.9") then
    ##
    # Workaround for missing Net::HTTPHeader#connection_close? on Ruby 1.8
    def function(arglist);Fi[	@oi’I"¥  # +generation+.
  def function(arglist)
    cleanup(var, Thread.current, @var)
  end
  
  if (RUBY_VERSION > "1.9") then
    ##
    # SSL version to use
    def function(arglist);Fi[@'@¸@∞NI"J# Creates (if they don't exist yet) all the directories on the remote;Fi[[	@™iRI")          end
          var.rmdir(var)
        end
      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::FTP does not support
      # paths to directories that don't yet exist when creating new;Fi[	@ªiQI"      # Note: Storage::RSync doesn't cycle
      def function(arglist)
        # do nothing
      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file.
      def function(arglist);Fi[	@»iDI"+          end
          var.rmdir!(var)
        end
      end
      
      ##
      # Creates (if they don't exist yet) all the directories on the remote
      # server in order to upload the backup file. Net::SFTP does not support
      # paths to directories that don't yet exist when creating new;Fi[@¿lI"var = (var + 1);FI"var = -1;FI"var = var;Fi[[	@LiwI"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@OilI"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = var
      if (var == 10) then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[	@RifI"      var = var[var].is_a?(String) ? (var[var].ord) : (var[var])
      var = (var < 128)
      if (var.chr == "\n") then
        Cell(var, var, var[var, (var - var)], var, 2, var, var)
        var = (var + 1)
        var = -1
        var = var
        var = 0
        var = (var + 1);Fi[@¿lI"	else;F@ﬂo@{Vi[[	@LiàI"k      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1;Fi[	@OiÇI"]      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1;Fi[	@Ri|I"k      if (var > var) then
        if ((var == -1) or (var == var)) then
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1;Fi[@¿l@{VI"end;FI"var = -1;Fi[[	@LiäI"E          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@OiÑI"7          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@Ri~I"E          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
        else
          Cell(var, var, var[var, (var - var)], var, 2, var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[@'@¸I"$alias :exec_update :exec_delete;FI" ;Fi[[	@QiÃI"Ã      def function(arglist)
        execute(to_sql(var, var), var)
        @var.affected_rows
      end
      
      alias :exec_update :exec_delete
      
      def function(arglist)
        @var.last_id;Fi[	@ViáI"æ        var = 0
        exec_query(var, var, var) { |arglist| var = var }
        var
      end
      
      alias :exec_update :exec_delete
      
      #:nodoc:
      def function(arglist);Fi[	@çiI"Ã      def function(arglist)
        exec_query(var, var, var)
        @var.changes
      end
      
      alias :exec_update :exec_delete
      
      def function(arglist)
        @var.last_insert_row_id;Fi[@å{@ç{I"@var = @var;F@	Zi[[	@LiÀI"g      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Oi”I"        end
      end
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[	@Ri∫I"g      var = var if (var.! or (var.chr == " "))
      var = (var + (var ? (var[var.chr]) : (1000) or 0))
      if (var > var) then
        if ((var == -1) or (var == var)) then
          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var);Fi[@'@¸@ˇ|I" ;Fi[[	@Qi¡I"¬      def function(arglist)
        super
        (var or @var.last_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        execute(to_sql(var, var), var);Fi[	@ViI"∑      def function(arglist)
        super(var, var)
        (var or @var.insert_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        var = 0;Fi[	@çi,I"»      def function(arglist)
        super
        (var or @var.last_insert_row_id)
      end
      
      alias :create :insert_sql
      
      def function(arglist)
        exec_query(var, var).rows;Fi[@2Å@3ÅI"if (var == 1) then;FI"@var = @var;Fi[[	@LiñI"¸        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@OiëI"ˆ        var = var if (var >= 128)
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[	@RiÖI"¸        var = (var + (var ? (1) : (2)))
      end
    end
    var = (var + "B") if var and var.to_s.index("B").nil?.!
    Cell(var, var, var[var, (var - var)], var, 2, var, var)
    if (var == 1) then
      @var = @var
    else
      if (var == 0) then;Fi[@'@¸@ÑI"def function(arglist);Fi[[	@QiVI"Ô          @var.close
          @var = nil
        end
      end
      
      # DATABASE STATEMENTS ======================================
      def function(arglist)
        var = "EXPLAIN #{to_sql(arel, binds.dup)}"
        var = Time.now;Fi[	@ViΩI"6          @var.change_user(@var[:username], @var[:password], @var[:database])
          configure_connection
        end
      end
      
      # DATABASE STATEMENTS ======================================
      def function(arglist)
        @var.query_with_result = true
        var = exec_query(var, var).rows;Fi[	@çiÈI"2          var = var.encode(Encoding::UTF_8)
        end
        var
      end
      
      # DATABASE STATEMENTS ======================================
      def function(arglist)
        var = "EXPLAIN QUERY PLAN #{to_sql(arel, binds)}"
        ExplainPrettyPrinter.new.pp(exec_query(var, "EXPLAIN", var));Fi[@'@¸@}@}i[[	@Fi¡I"ı      def function(arglist)
        clear_cache!
        reset_transaction
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        clear_cache!;Fi[	@ViØI"’        super
        disconnect!
        connect
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super;Fi[	@çiïI"›      
      def function(arglist)
        @var.!=(false)
      end
      
      # Disconnects from the database if already connected. Otherwise, this
      # method does nothing.
      def function(arglist)
        super;Fi[@'@¸I"# Renames a table.;FI"#;Fi[[	@>iI"π        else
          yield(Table.new(var, self))
        end
      end
      
      # Renames a table.
      #
      #  rename_table('octopuses', 'octopi')
      def function(arglist);Fi[	@IiπI"‰          end
        end.flatten.join(", ")
        execute("ALTER TABLE #{quote_table_name(table_name)} #{sqls}")
      end
      
      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi');Fi[	@çi{I"’      
      def function(arglist)
        exec_query("DROP INDEX #{quote_column_name(index_name)}")
      end
      
      # Renames a table.
      #
      # Example:
      #   rename_table('octopuses', 'octopi');Fi[@'@¸I"7# Returns an array of indexes for the given table.;FI"def function(arglist);Fi[[	@IiåI"À          var = nil
        end
        tables(nil, var, var).any?
      end
      
      # Returns an array of indexes for the given table.
      def function(arglist)
        var = []
        var = nil;Fi[	@ÉiNI"°        # Returns true if schema exists.
        def function(arglist)
          (exec_query("            SELECT COUNT(*)\n            FROM pg_namespace\n            WHERE nspname = '#{name}'\n", "SCHEMA").rows.first[0].to_i > 0)
        end
        
        # Returns an array of indexes for the given table.
        def function(arglist)
          var = query("             SELECT distinct i.relname, d.indisunique, d.indkey, pg_get_indexdef(d.indexrelid), t.oid\n             FROM pg_class t\n             INNER JOIN pg_index d ON t.oid = d.indrelid\n             INNER JOIN pg_class i ON d.indexrelid = i.oid\n             WHERE i.relkind = 'i'\n               AND d.indisprimary = 'f'\n               AND t.relname = '#{table_name}'\n               AND i.relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname = ANY (current_schemas(false)) )\n            ORDER BY i.relname\n", "SCHEMA")
          var.map do |arglist|;Fi[	@çiiI"⁄          end
          SQLite3Column.new(var["name"], var["dflt_value"], var["type"], (var["notnull"].to_i == 0))
        end
      end
      
      # Returns an array of indexes for the given table.
      def function(arglist)
        exec_query("PRAGMA index_list(#{quote_table_name(table_name)})", "SCHEMA").map do |arglist|
          IndexDefinition.new(var, var["name"], var["unique"].!=(0), exec_query("PRAGMA index_info('#{row["name"]}')", "SCHEMA").map do |arglist|;Fi[@XM@YM@z@Öi[[	@LiœI"          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@RiæI"          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[	@Ui©I"          if (@var > @var) then
            @var = @var
            @var = (@var + var)
            var = ((@var - @var) - @var)
            var = (((var - (2 * @var)) * 1000) / @var)
            var = (var + 1)
            var = (var + 1)
            next
          end;Fi[@'@¸I",# Adds a new column to the named table.;FI"I# See TableDefinition#column for details of the options you can use.;Fi[[	@6iI"˚      def function(arglist)
        @var = var
        @var = var
      end
      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      #
      # ====== Creating a simple column;Fi[	@>i/I"˘      # In that case, +options+ and the block will be used by create_table.
      def function(arglist)
        execute("DROP TABLE #{quote_table_name(table_name)}")
      end
      
      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      def function(arglist)
        var = "ALTER TABLE #{quote_table_name(table_name)} ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}";Fi[	@ÉiÈI"a            var = "#{new_name}_#{pk}_seq"
            execute("ALTER TABLE #{quote_table_name(seq)} RENAME TO #{quote_table_name(new_seq)}")
          end
        end
        
        # Adds a new column to the named table.
        # See TableDefinition#column for details of the options you can use.
        def function(arglist)
          clear_cache!;Fi[@òkI"	else;F@¿o@¡oi[[	@Li÷I"F            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1;Fi[	@OiﬁI"8            next
          end
          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1;Fi[	@Ri≈I"F            next
          end
          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1;Fi[@òk@¡oI"end;FI"var = -1;Fi[[	@LiÿI"I          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@Oi‡I";          var = (var + var) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[	@Ri«I"I          var = (var + (var ? (1) : (2))) if (var == var)
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
        else
          Cell(var, var, var[var, (var - var)], 0, 2, "", var, var)
          var = (var[var].chr == " ") ? ((var + 1)) : (var)
        end
        var = -1
        var = var
        var = 0;Fi[I"if var.!=(var) then;F@(ÅI"end;FI"end;Fi[[	@LiËI"¿        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[	@OiÒI"∫        var = var if (var >= 128)
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[	@Ri◊I"¿        var = (var + (var ? (1) : (2)))
      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private;Fi[@(ÅI"end;FI"end;FI" ;Fi[[	@LiÈI"õ      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[	@OiÚI"õ      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[	@RiÿI"õ      end
    end
    if var.!=(var) then
      Cell(((var * @var) / 1000.0), var, var[var, (var - var)], 0, 0, "", var, var)
    end
  end
  
  private
  ;Fi[@
fI"out("endobj");FI"end;F@˘Ui[[	@LiÛI"˙    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@Oi¸I"˙    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@Ri‚I"˙    var = @var
    @var.each do |arglist|
      newobj
      out((("<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [" + var) + "]>>"))
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[@}S@z@ŒÉI"*Error("Font file not found") if var.!;Fi[[	@Li¯I"+    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[	@OiI"+    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[	@RiÁI"+    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[@}S@˘z@◊ÉI"putType0(var);Fi[[	@Li
I"Õ    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[	@OiI"Õ    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[	@Ri˘I"Õ    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"];Fi[@z@ŒÉ@bÜI"out(("<</Length " + var));Fi[[	@Li˘I"M    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[	@OiI"M    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[	@RiËI"M    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]));Fi[@ŒÉ@bÜ@tÜI"5out("/Filter /FlateDecode") if (var[-2] == ".z");Fi[[	@Li˙I"S      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then;Fi[	@OiI"S      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then;Fi[	@RiÈI"Q      newobj
      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then;Fi[@bÜ@tÜ@}ÜI"(out(("/Length1 " + var["length1"]));Fi[[	@Li˚I"Ñ      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[	@OiI"Ñ      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[	@RiÍI"Ç      @var[var]["n"] = @var
      var = (FPDF_FONTPATH + var) if defined("FPDF_FONTPATH")
      var = filesize(var)
      Error("Font file not found") if var.!
      out(("<</Length " + var))
      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"));Fi[I":out((("/Length2 " + var["length2"]) + " /Length3 0"));FI"end;FI"out(">>");F@Åi[[	@Li I".      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var);Fi[	@Oi	I".      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var);Fi[	@RiÔI",      out("/Filter /FlateDecode") if (var[-2] == ".z")
      out(("/Length1 " + var["length1"]))
      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var);Fi[@Ù[@Å@ÅI"fclose(var);Fi[[	@LiI"È      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[	@OiI"È      unless var["length2"].nil? then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[	@RiÒI"Á      if var["length2"].nil?.! then
        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end;Fi[@Ù[@ı[@
ÅI"newobj;Fi[[	@Li$I"∑            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[	@Oi-I"∑            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[	@RiI"∑            end
          end
        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "[";Fi[@'@¸@ˇ,I"+var = Twitter::API::Arguments.new(var);Fi[[	@!iI"b          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options)
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then;Fi[	@!i$I"        rescue Twitter::Error::NotFound, Twitter::Error::Forbidden
          false
        end
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_user!(var.options, var.pop)
        merge_list!(var.options, var.pop);Fi[	@!i.I"(          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options)
      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var = var.pop
        merge_list!(var.options, var.pop);Fi[@Ù[@ı[@ˆ[I"#out("<</Type /FontDescriptor");Fi[[	@OiXI"¯      var = (var + (var["cw"][var].to_s + " "))
    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6");Fi[	@ciïI"¯      var = (var + (var["cw"][var].to_s + " "))
    end
    out((var + "] 231 325 500 631 [500] 326 389 500]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    out("/Flags 6");Fi[	@ciÉ
I"    out("<</Registry (Adobe)")
    out("/Ordering (UCS)")
    out("/Supplement 0")
    out(">>")
    out("endobj")
    newobj
    out("<</Type /FontDescriptor")
    out(("/FontName /" + var["name"]))
    var["desc"].each { |arglist| out(((("/" + var.to_s) + " ") + var.to_s)) };Fi[@Ù[@ı[@l\I"end;Fi[[	@LicI"v    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>")
    out("endobj")
  end
end;Fi[	@OidI"v    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 60")
    out(">>")
    out("endobj")
  end
end;Fi[	@RiNI"v    out("/Descent -200")
    out("/CapHeight 800")
    out("/StemV 50")
    out(">>")
    out("endobj")
  end
end;Fi[@'@¸@ˇ,I"__add(var);Fi[[	@Èi%I"Í      def function(arglist)
        @var[:null_object] = true
        @var
      end
      
      def function(arglist)
        __add(var)
        warn_if_nil_class(var)
        if var = @var.detect { |arglist| (var.sym == var) } then;Fi[	@Èi1I"˘        end
        (@var << var)
        @var.last
      end
      
      def function(arglist)
        __add(var)
        warn_if_nil_class(var)
        (@var << NegativeMessageExpectation.new(@var, @var, var, var, (block_given? ? (var) : (nil))));Fi[	@Èi8I"C        warn_if_nil_class(var)
        (@var << NegativeMessageExpectation.new(@var, @var, var, var, (block_given? ? (var) : (nil))))
        @var.last
      end
      
      def function(arglist)
        __add(var)
        @var.unshift(MessageExpectation.new(@var, @var, var, var, nil, :any, var, &var))
        @var.first;Fi[@Å@ÅI"fclose(var);FI"out("endobj");Fi[[	@LiI"„        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@OiI"„        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[	@RiÚI"„        out((("/Length2 " + var["length2"]) + " /Length3 0"))
      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|;Fi[@ÅI"fclose(var);FI"out("endobj");FI"end;Fi[[	@LiI"≤      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@OiI"≤      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[	@RiÛI"≤      end
      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj;Fi[I"fclose(var);FI"out("endobj");FI"end;FI" @var.each_pair do |arglist|;Fi[[	@LiI"ƒ      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@OiI"ƒ      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[	@RiÙI"ƒ      out(">>")
      var = fopen(var, "rb")
      putstream(fread(var, var))
      fclose(var)
      out("endobj")
    end
    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var;Fi[@˘z@◊ÉI"putType0(var);FI"	else;Fi[[	@LiI"Ë    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[	@OiI"Ë    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[	@Ri˙I"Ë    @var.each_pair do |arglist|
      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var));Fi[@˘z@nl@olI"öout((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"));Fi[[	@OiNI"z    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 [";Fi[	@Ri4I"î    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    if (var["CMap"] == "KSCms-UHC-HW-H") then;Fi[	@ciãI"z    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 [";Fi[@◊ÉI"putType0(var);FI"	else;F@µoi[[	@LiI"      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[	@OiI"      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[	@Ri˚I"      newobj
      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then;Fi[I"putType0(var);FI"	else;F@µo@∂oi[[	@LiI"      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[	@OiI"      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[	@Ri¸I"      @var[var]["n"] = @var
      out("<</Type /Font")
      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1");Fi[@µo@∂o@∑o@“]i[[	@LiI"9      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[	@OiI"9      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[	@Ri˛I"9      if (var["type"] == "Type0") then
        putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding");Fi[@∂o@∑o@“]@”]i[[	@LiI"         putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[	@OiI"         putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[	@RiˇI"         putType0(var)
      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end;Fi[@∑o@“]@”]@‘]i[[	@LiI"      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[	@OiI"      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[	@Ri I"      else
        var = var["name"]
        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else;Fi[@'@¸@ˇ,@~i[[	@Yi9I"©      
      def function(arglist)
        @var.collect { |arglist| var.inspect }
      end
      
      def function(arglist)
        split_words(@var)
      end
      ;Fi[	@YièI"¥      def function(arglist)
        var.to_s =~ /^(be_(an?_)?)(.*)/
        return [$1, $3]
      end
      
      def function(arglist)
        split_words(@var)
      end
    end;Fi[	@«i|I"≈      
      def function(arglist)
        (@var[var].arity == 1) ? (@var[var].call(@var)) : (@var[var].call)
      end
      
      def function(arglist)
        split_words(@var)
      end
      ;Fi[@”]@‘]I"end;FI"	else;Fi[[	@LiI"=        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[	@OiI"=        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[	@RiI"=        out(("/BaseFont /" + var))
        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32");Fi[@‘]I"end;FI"	else;F@™oi[[	@LiI"9        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[	@OiI"9        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[	@RiI"9        if (var["type"] == "core") then
          out("/Subtype /Type1")
          if var.!=("Symbol") and var.!=("ZapfDingbats") then
            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255");Fi[@‘]@BáI"end;FI"end;Fi[[	@Li I"¸            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[	@Oi)I"¸            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[	@RiI"¸            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end
        out(">>")
        out("endobj");Fi[@™o@´o@¨oI".out((("/Widths " + (@var + 1)) + " 0 R"));Fi[[	@LiI"?            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[	@Oi I"?            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[	@RiI"?            out("/Encoding /WinAnsiEncoding")
          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then;Fi[@´o@¨o@VáI"6out((("/FontDescriptor " + (@var + 2)) + " 0 R"));Fi[[	@LiI"8          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[	@Oi!I"8          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[	@RiI"8          end
        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then;Fi[@¨o@Vá@_áI"if var["enc"] then;Fi[[	@LiI"m        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[	@Oi"I"m        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[	@RiI"m        else
          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[@Vá@_á@háI"if var["diff"].nil?.! then;Fi[[	@LiI"q          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[	@Oi#I"q          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[	@Ri	I"q          out(("/Subtype /" + var["type"]))
          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else;Fi[@_á@há@qáI"9out((("/Encoding " + (var + var["diff"])) + " 0 R"));Fi[[	@LiI"u          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[	@Oi$I"u          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[	@Ri
I"u          out("/FirstChar 32")
          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding");Fi[@há@qá@záI"	else;Fi[[	@LiI"f          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[	@Oi%I"f          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[	@RiI"f          out("/LastChar 255")
          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end;Fi[@qá@záI"	else;F@ki[[	@LiI"U          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[	@Oi&I"U          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[	@RiI"U          out((("/Widths " + (@var + 1)) + " 0 R"))
          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end;Fi[@záI"	else;F@kI"end;Fi[[	@LiI"-          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[	@Oi'I"-          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[	@RiI"-          out((("/FontDescriptor " + (@var + 2)) + " 0 R"))
          if var["enc"] then
            if var["diff"].nil?.! then
              out((("/Encoding " + (var + var["diff"])) + " 0 R"))
            else
              out("/Encoding /WinAnsiEncoding")
            end
          end
        end;Fi[@
ÅI"newobj;F@‡ÉI"var = "[";Fi[[	@Li&I"¸        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[	@Oi/I"¸        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[	@RiI"¸        end
        out(">>")
        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"));Fi[@‡ÉI"var = "[";F@‚É@_i[[	@Li(I"        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[	@Oi1I"        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[	@RiI"        out("endobj")
        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj;Fi[I"var = "[";F@‚É@_I"out("endobj");Fi[[	@Li)I"/        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[	@Oi2I"/        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[	@RiI"/        if var["type"].!=("core") then
          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var);Fi[@‚É@_I"out("endobj");FI"newobj;Fi[[	@Li*I"5          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[	@Oi3I"5          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[	@RiI"5          newobj
          var = var["cw"]
          var = "["
          32.upto(255) { |arglist| var = (var + (var[var.chr] + " ")) }
          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|;Fi[@'@¸@ˇ,I"var = min_value;Fi[[	@˘i)I"¯      
      def function(arglist)
        (var / 2.0)
      end
      
      def function(arglist)
        var = min_value
        var = field_width
        var = ((@var.to_f - ((font_size * 2) * top_font)) / (get_y_labels.max - get_y_labels.min));Fi[	@i*I"¸      
      def function(arglist)
        (var / -2.0)
      end
      
      def function(arglist)
        var = min_value
        var = field_height
        var = ((@var.to_f - ((font_size * 2) * right_font)) / (get_x_labels.max - get_x_labels.min));Fi[	@	idI"        var[:x] = (var * var)
        var[:y] = (@var - (var * var))
        return var
      end
      
      def function(arglist)
        var = min_value
        var = ((@var.to_f - ((font_size * 2) * top_font)) / (get_y_labels.max - get_y_labels.min))
        var = field_width;Fi[@_@ÎÉ@ÏÉI"end;Fi[[	@Li.I"%          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[	@Oi7I"%          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[	@RiI"%          out((var + "]"))
          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then;Fi[@ÎÉ@ÏÉI"end;F@ıÄi[[	@Li/I"Ö          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[	@Oi8I"Ö          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[	@RiI"Ö          out("endobj")
          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"));Fi[@ÏÉI"end;F@ıÄI"if var then;Fi[[	@Li0I"{          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[	@Oi9I"{          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[	@RiI"{          newobj
          var = ("<</Type /FontDescriptor /FontName /" + var)
          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end;Fi[@ıÄI"if var then;F@ nI"end;Fi[[	@Li2I"`          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[	@Oi;I"`          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[	@Ri!I"`          var["desc"].each_pair do |arglist|
            var = (var + (((" /" + var) + " ") + var))
          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj");Fi[@ nI"end;F@ÃnI"out("endobj");Fi[[	@Li4I"          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[	@Oi=I"          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[	@Ri#I"          end
          var = var["file"]
          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end;Fi[@ÃnI"out("endobj");FI"end;FI"end;Fi[[	@Li6I"ˆ          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[	@Oi?I"ˆ          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[	@Ri%I"ˆ          if var then
            var = (var + ((((" /FontFile" + ((var["type"] == "Type1") ? ("") : ("2"))) + " ") + @var[var]["n"]) + " 0 R"))
          end
          out((var + ">>"))
          out("endobj")
        end
      end
    end
  end;Fi[@ﬂq@‡q@·q@¶hi[[	@Li>I"ˇ  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[	@OiGI"ˇ  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[	@Ri-I"ˇ  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj");Fi[@‡q@·q@¶hI"out(">>");Fi[[	@Li?I"  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[	@OiHI"  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[	@Ri.I"  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj;Fi[@·q@¶hI"out(">>");FI"out("endobj");Fi[[	@Li@I"  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[	@OiII"  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[	@Ri/I"  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]))
    out((("/DescendantFonts [" + (@var + 1).to_s) + " 0 R]"))
    out(">>")
    out("endobj")
    newobj
    out("<</Type /Font");Fi[@'@¸@ˇ,I"case var[:format];Fi[[	@™i÷I"           render_issues(var, var)
          var[:indent] -= var[:indent_increment]
        end
      end
      
      def function(arglist)
        case var[:format]
        when :pdf then
          var[:pdf].Line(15, var[:top], PDF::TotalWidth, var[:top]);Fi[	@™iﬂI"°        else
          # do nothing
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then
          var = "";Fi[	@™iI"ó        else
          ""
        end
      end
      
      def function(arglist)
        case var[:format]
        when :html then
          var = "";Fi[@nl@ol@˚ÜI";out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"));Fi[[	@OiOI"ñ    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 ["
    var["cw"].keys.sort.each do |arglist|;Fi[	@Ri5I"¢    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    if (var["CMap"] == "KSCms-UHC-HW-H") then
      var = "8094 8190 500";Fi[	@ciåI"ñ    out("endobj")
    newobj
    out("<</Type /Font")
    out("/Subtype /CIDFontType0")
    out(("/BaseFont /" + var["name"]))
    out((((("/CIDSystemInfo <</Registry (Adobe) /Ordering (" + var["registry"]["ordering"]) + ") /Supplement ") + var["registry"]["supplement"].to_s) + ">>"))
    out((("/FontDescriptor " + (@var + 1).to_s) + " 0 R"))
    var = "/W [1 ["
    var["cw"].keys.sort.each do |arglist|;Fi[@'@¸@ˇ,@ﬂqi[[	@Li;I"ø        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[	@OiDI"ø        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[	@Ri*I"ø        end
      end
    end
  end
  
  def function(arglist)
    out("/Subtype /Type0")
    out(((("/BaseFont /" + var["name"]) + "-") + var["CMap"]))
    out(("/Encoding /" + var["CMap"]));Fi[@'@¸@ˇ,@ˆqi[[	@LiI"å    var = (@var.length + 1)
    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var);Fi[	@OiI"∏    Error("CID font already added: family style") unless @var[var].nil?
    var = (@var.length + 1)
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -120, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var);Fi[	@RiI"å    var = (@var.length + 1)
    var = var.gsub(" ", "")
    @var[var] = { "i" => (var), "type" => "Type0", "name" => (var), "up" => -130, "ut" => 40, "cw" => (var), "CMap" => (var), "registry" => (var) }
  end
  
  def function(arglist)
    AddCIDFont(var, "", var, var, var, var)
    AddCIDFont(var, "B", (var + ",Bold"), var, var, var)
    AddCIDFont(var, "I", (var + ",Italic"), var, var, var);Fi[@'@¸@ˇ,I"var = Scoped.root;Fi[[	@öi€I"[    assert(categories(:child_2_1).is_ancestor_of?(categories(:child_2)).!)
    assert(categories(:child_1).is_ancestor_of?(categories(:child_2)).!)
    assert(categories(:child_1).is_ancestor_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_ancestor_of?(var));Fi[	@öiıI"c    assert(categories(:child_2).is_descendant_of?(categories(:child_2_1)).!)
    assert(categories(:child_2).is_descendant_of?(categories(:child_1)).!)
    assert(categories(:child_1).is_descendant_of?(categories(:child_1)).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.is_or_is_descendant_of?(var));Fi[	@öi˝I"    assert(var.is_or_is_descendant_of?(var))
    var.update_attribute(:organization_id, "different")
    assert(var.is_or_is_descendant_of?(var).!)
  end
  
  def function(arglist)
    var = Scoped.root
    var = var.children.first
    assert(var.same_scope?(var));Fi[@'@¸@ˇ,I"!var = categories(:top_level);Fi[[	@öi´I"v    assert(categories(:child_2_1).children.empty?)
    assert(categories(:child_2).children.empty?.!)
    assert(categories(:top_level).children.empty?.!)
  end
  
  def function(arglist)
    var = categories(:top_level)
    var = [var, categories(:child_1), categories(:child_2), categories(:child_2_1), categories(:child_3)]
    assert_equal(var, var.self_and_descendants);Fi[	@öiæI"E    assert_equal(1, var.children.size)
    assert_equal(1, var.children.size)
    assert_equal(2, var.descendants.size)
  end
  
  def function(arglist)
    var = categories(:top_level)
    var = [categories(:child_1), categories(:child_2), categories(:child_2_1), categories(:child_3)]
    assert_equal(var, var.descendants);Fi[	@öiƒI"<    var = categories(:top_level)
    var = [categories(:child_1), categories(:child_2), categories(:child_2_1), categories(:child_3)]
    assert_equal(var, var.descendants)
  end
  
  def function(arglist)
    var = categories(:top_level)
    var.children.each { |arglist| assert_equal(var.id, var.parent_id) }
  end;Fi[@'@¸@ˇ,I"@assert_raises(ActiveRecord::ActiveRecordError) do |arglist|;Fi[[	@öi?I"-    var = Default.connection.quote_column_name("rgt")
    assert_equal(var, Default.quoted_right_column_name)
    assert_equal(var, Default.new.quoted_right_column_name)
  end
  
  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.lft = 1
    end;Fi[	@öiEI"Ê    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.lft = 1
    end
  end
  
  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.rgt = 1
    end;Fi[	@öiKI"Ï    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.rgt = 1
    end
  end
  
  def function(arglist)
    assert_raises(ActiveRecord::ActiveRecordError) do |arglist|
      Category.new.parent_id = 1
    end;Fi[@'@¸@ˇ,I"!var = locked_pages(:welcome);Fi[[	@èiBI"    assert(var.revert_to!(var.versions.first), "Couldn't revert to 23")
    assert_equal(23, var.version)
    assert_equal("Welcome to the weblg", var.title)
  end
  
  def function(arglist)
    var = locked_pages(:welcome)
    assert(var.revert_to!(locked_pages(:thinking)).!)
  end;Fi[	@èiNI"B    assert(var.new_record?.!)
    assert_equal(1, var.versions.size)
    assert_instance_of(LockedPage.versioned_class, var.versions.first)
  end
  
  def function(arglist)
    var = locked_pages(:welcome)
    assert_equal("Welcome to the weblog", var.title)
    assert_equal("LockedPage", var.versions.first.version_type);Fi[	@èiWI"z    assert(var.revert_to!(var.versions.first.version), "Couldn't revert to 23")
    assert_equal("Welcome to the weblg", var.title)
    assert_equal("LockedPage", var.versions.first.version_type)
  end
  
  def function(arglist)
    var = locked_pages(:welcome)
    assert_equal("Welcome to the weblog", var.title)
    assert_equal("LockedPage", var.versions.first.version_type);Fi[@’q@±eI"	else;F@≥ei[[	@UiI"  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[	@Ui#I"  end
  
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[	@ciÀI"[  	# @see SetDrawColor(), SetTextColor(), Rect(), Cell(), MultiCell()
  	#
  def function(arglist)
    if (((var == 0) and ((var == 0) and (var == 0))) or (var == -1)) then
      @var = sprintf("%.3f g", (var / 255.0))
    else
      @var = sprintf("%.3f %.3f %.3f rg", (var / 255.0), (var / 255.0), (var / 255.0))
    end
    @var = @var.!=(@var);Fi[@'@¸@ˇ,I"sassert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id));Fi[[	@ái¿I"R  
  def function(arglist)
    teardown_db
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
    ListMixin.find(2).move_lower
    assert_equal([1, 3, 2, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id));Fi[	@ái–I"3    assert_equal([1, 3, 4, 2], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
    ListMixin.find(4).move_to_top
    assert_equal([4, 1, 3, 2], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
    ListMixin.find(3).move_to_bottom
    assert_equal([1, 2, 4, 3], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id));Fi[	@ái¸I"j    assert_equal(1, var.pos)
    var.reload
    assert_equal(5, var.pos)
  end
  
  def function(arglist)
    assert_equal([1, 2, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id))
    ListMixin.find(2).destroy
    assert_equal([1, 3, 4], ListMixin.find(:all, :conditions => "parent_id = 5000", :order => "pos").map(&:id));Fi[@'@¸@ˇ,@‡~i[[	@
i+I"º      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@
i0I"º      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[	@
i5I"º      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end
      
      def function(arglist)
        var = Node.new(:COMBINATOR, var)
        var
      end;Fi[@'@¸@ˇ,@7ri[[	@
i÷I"”      def function(arglist)
        var = Node.new(:FUNCTION, [var.first.strip, var[1]].flatten)
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[	@
i€I"≤      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[	@
i‡I"≤      def function(arglist)
        var = [var.first, var.last]
        var
      end
      
      def function(arglist)
        var = [var.first, var.last]
        var
      end;Fi[I"return var[0];FI"end;FI" ;FI"def function(arglist);Fi[[	@Ui≠I"£  
  def function(arglist)
    var = var.read(4).unpack("N")
    return var[0]
  end
  
  def function(arglist)
    var = var.read(2).unpack("n")
    return var[0];Fi[	@Ui≤I"£  
  def function(arglist)
    var = var.read(2).unpack("n")
    return var[0]
  end
  
  def function(arglist)
    var = var.read(1).unpack("C")
    return var[0];Fi[	@Ui∑I"ï  
  def function(arglist)
    var = var.read(1).unpack("C")
    return var[0]
  end
  
  def function(arglist)
    (("(" + escape(var)) + ")")
  end;Fi[@'@¸@ˇ,I"+var = (HOMEBREW_PREFIX / "foo_script");Fi[[	@◊OiàI"¯class TextExecutableTests < Test::Unit::TestCase
  def function(arglist)
    (HOMEBREW_PREFIX / "foo_script").unlink
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#!/bin/sh")
    assert(var.universal?.!);Fi[	@◊OiòI"˝    assert_equal([], var.archs)
    assert((var.arch == :dunno))
    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write("#! /usr/bin/perl -w")
    assert(var.universal?.!);Fi[	@◊Oi®I"Ì    assert_equal([], var.archs)
    assert((var.arch == :dunno))
    assert_match(/text executable/, file(var))
  end
  
  def function(arglist)
    var = (HOMEBREW_PREFIX / "foo_script")
    var.write(" #!")
    assert(var.universal?.!);Fi[@'@¸@ˇ,I":FileUtils.touch((HOMEBREW_PREFIX / "bin/helloworld"));Fi[[	I")data//homebrew_proj/test/test_keg.rb;Ti+I"  def function(arglist)
    @var.link
    assert_raise(RuntimeError, "Cannot link testball") { |arglist| @var.link }
  end
  
  def function(arglist)
    FileUtils.touch((HOMEBREW_PREFIX / "bin/helloworld"))
    assert_raise(RuntimeError) { |arglist| @var.link }
  end;Fi[	@•ài0I"  def function(arglist)
    FileUtils.touch((HOMEBREW_PREFIX / "bin/helloworld"))
    assert_raise(RuntimeError) { |arglist| @var.link }
  end
  
  def function(arglist)
    FileUtils.touch((HOMEBREW_PREFIX / "bin/helloworld"))
    var = OpenStruct.new
    var.overwrite = true;Fi[	@•ài7I"‚    var = OpenStruct.new
    var.overwrite = true
    assert_equal(3, @var.link(var))
  end
  
  def function(arglist)
    FileUtils.touch((HOMEBREW_PREFIX / "bin/helloworld"))
    var = OpenStruct.new
    var.overwrite = true;Fi[I"# @since 1.1;FI"#;FI"def function(arglist);FI"@var = var;Fi[[	@ci9I"}  	#
   	# Set header font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  ;Fi[	@ciDI"|  #
   	# Set footer font.
  	# @param array :font font
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  ;Fi[	@ciOI"~  #
   	# Set language array.
  	# @param array :language
  	# @since 1.1
  	#
  def function(arglist)
    @var = var
  end
  ;Fi[@'@¸@ˇ,I" (@var << X11Dependency.new);Fi[[	I"3data//homebrew_proj/test/test_comparableset.rb;TiI"Âclass ComparableSetTests < Test::Unit::TestCase
  def function(arglist)
    @var = ComparableSet.new
  end
  
  def function(arglist)
    (@var << X11Dependency.new)
    (@var << X11Dependency.new)
    assert_equal(@var.count, 1);Fi[	@ªàiI"Â    assert_equal(@var.count, 1)
    (@var << Requirement.new)
    assert_equal(@var.count, 2)
  end
  
  def function(arglist)
    (@var << X11Dependency.new)
    (@var << X11Dependency.new("2.6"))
    assert_equal(@var.count, 1);Fi[	@ªài!I"    (@var << X11Dependency.new)
    assert_equal(@var.count, 1)
    assert_equal(@var.to_a, [X11Dependency.new("2.6")])
  end
  
  def function(arglist)
    (@var << X11Dependency.new)
    (@var << Requirement.new)
    var = Set.new([X11Dependency.new("2.6"), Requirement.new]);Fi[I"if (@var == true) then;FI"Ln;FI"@var = false;FI"end;Fi[[	@ciAI"◊        Ln if (@var == @var)
        @var = @var
      end
      if (@var == true) then
        Ln
        @var = false
      end
      (var == "ul") ? (@var[@var] = false) : (@var[@var] = true)
      @var[@var] = 0;Fi[	@ci$I"≤      Ln if (@var == 0)
    when "ul", "ol" then
      @var = (@var - 1)
      if (@var == true) then
        Ln
        @var = false
      end
    when "li" then
      @var = "";Fi[	@ci*I"º      end
    when "li" then
      @var = ""
      if (@var == true) then
        Ln
        @var = false
      end
    when "h1", "h2", "h3", "h4", "h5", "h6" then
      SetFontSize(@var);Fi[@¢n@£n@§nI"1var = ("?" + $!.failed[1, $!.failed.length]);Fi[[	@ÄiI"           var = Iconv.new("UTF-8", "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@Äi?I"          var = Iconv.new("UTF-8", var)
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[	@Äi}I"          var = Iconv.new(var, "UTF-8")
          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue;Fi[@£n@§n@ŒàI"
retry;Fi[[	@ÄiI"          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@Äi@I"          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[	@Äi~I"          var = ""
          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success);Fi[@§n@ŒàI"
retry;FI"rescue;Fi[[	@ÄiI"          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@ÄiAI"          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[	@ÄiI"          begin
            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end;Fi[@§nI"end;FI"var = var;FI"end;Fi[[	@ÄiI"¬            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@ÄiEI"¬            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
      var;Fi[	@ÄiÉI"¿            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var
        end
      end
    end;Fi[@ŒàI"
retry;FI"rescue;F@‰ti[[	@ÄiI"            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@ÄiBI"            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[	@ÄiÄI"            var = (var + var.iconv(var))
          rescue Iconv::IllegalSequence
            var = (var + $!.success)
            var = ("?" + $!.failed[1, $!.failed.length])
            retry
          rescue
            var = (var + $!.success)
          end
          var = var;Fi[I"var.alias_nb_pages;FI".var.footer_date = format_date(Date.today);FI"var.AddPage;FI"var.SetFontStyle("B", 11);Fi[[	@ôi∞I"y      def function(arglist)
        var = ITCPDF.new(current_language)
        var.SetTitle("#{issue.project} - #{issue.tracker} ##{issue.id}")
        var.alias_nb_pages
        var.footer_date = format_date(Date.today)
        var.AddPage
        var.SetFontStyle("B", 11)
        var = "#{issue.project} - #{issue.tracker} ##{issue.id}"
        var.RDMMultiCell(190, 5, var);Fi[	@ôidI""      def function(arglist)
        var = ITCPDF.new(current_language)
        var.SetTitle(var.name)
        var.alias_nb_pages
        var.footer_date = format_date(Date.today)
        var.AddPage
        var.SetFontStyle("B", 11)
        var.RDMMultiCell(190, 5, var.name)
        var.Ln;Fi[	@ôitI"f      def function(arglist)
        var = ITCPDF.new(current_language)
        var.SetTitle("#{project} - #{page.title}")
        var.alias_nb_pages
        var.footer_date = format_date(Date.today)
        var.AddPage
        var.SetFontStyle("B", 11)
        var.RDMMultiCell(190, 5, "#{project} - #{page.title} - # #{page.content.version}")
        var.Ln;Fi[I"@var[:fields];FI"end;FI" ;FI"def function(arglist);Fi[[	@˘iI"•      protected
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        var = max_value
        var = min_value;Fi[	@i%I"é      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        (var / -2.0)
      end;Fi[	@	iHI"ø      end
      
      def function(arglist)
        @var[:fields]
      end
      
      def function(arglist)
        super
        var = (((@var[:fields][0].length / 2) * font_size) * 0.6);Fi[I"var = max_value;FI"var = min_value;F@∂q@…xi[[	@˘iI"˘      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@iI"ˇ      protected
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[	@	iRI"˘      end
      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0));Fi[I"var = min_value;F@∂q@…x@ xi[[	@˘iI"-      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	@iI"-      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[	@	iSI"-      
      def function(arglist)
        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[@…x@ x@ÀxI":var = (var < 1) ? (1) : (var.round) if scale_integers;Fi[[	@˘iI"T        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@iI"T        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[	@	iUI"T        var = max_value
        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var));Fi[@ x@Àx@*âI"var = [];Fi[[	@˘iI"r        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@iI"r        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[	@	iVI"r        var = min_value
        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) };Fi[@Àx@*âI"var = [];F@÷ni[[	@˘iI"m        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@iI"m        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[	@	iWI"m        var = (var - var)
        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var;Fi[@*âI"var = [];F@÷n@õZi[[	@˘i I"]        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@iI"]        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[	@	iXI"]        var = (var == 0) ? (10) : ((var / 20.0))
        var = ((var + var) - var)
        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end;Fi[@÷n@õZI"return var;FI"end;Fi[[	@˘i"I"-        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@iI"-        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[	@	iZI"-        var = (scale_divisions or (var / 10.0))
        var = (var < 1) ? (1) : (var.round) if scale_integers
        var = []
        var = ((var % var) == 0) ? (var) : ((var + var))
        var.step(var, var) { |arglist| (var << var) }
        return var
      end
      
      def function(arglist);Fi[@'@¸@ˇ,I"return nil unless var;Fi[[	@Â#iMI"       var = var.joins(:aspect_visibilities).where(:aspect_visibilities => ({ :aspect_id => (var[:by_members_of]) }))
    end
    ugly_select_clause(var, var)
  end
  
  def function(arglist)
    return nil unless var
    contact_for_person_id(var.id)
  end;Fi[	@ i*I"3    
    def function(arglist)
      ::I18n.t(var.to_s, :value => (var), :locale => (var.to_s.gsub(/(.+)\-(.+)$/) { |arglist| "#{$1}-#{$2.upcase}" }))
    end
    
    def function(arglist)
      return nil unless var
      var = {}
      var[:format] = Setting.date_format unless Setting.date_format.blank?;Fi[	@ i2I"^      var[:format] = Setting.date_format unless Setting.date_format.blank?
      var[:locale] = User.current.language unless User.current.language.blank?
      ::I18n.l(var.to_date, var)
    end
    
    def function(arglist)
      return nil unless var
      var = {}
      var[:format] = Setting.time_format.blank? ? (:time) : (Setting.time_format);Fi[I"decode(var);FI"end;FI"end;FI"end;Fi[[	I"&data//rescue_proj/resque/coder.rb;TiI"^    
    # alias for decode
    def function(arglist)
      decode(var)
    end
  end
end;Fi[	@7i8I"¿      else
        synchronize do |arglist|
          Array(@var.lrange(@var, var, ((var + var) - 1))).map do |arglist|
            decode(var)
          end
        end
      end
    end
    ;Fi[	@ûiI"‡      decode(redis.lindex(var, var))
    else
      Array(redis.lrange(var, var, ((var + var) - 1))).map do |arglist|
        decode(var)
      end
    end
  end
  
  # Returns an array of all known Resque queues as strings.;Fi[@åvI"#      ...;FI"#    end;FI"#  end;Fi[[	@Pi2I"Ï      #  describe SmallEdition do
      #    it_should_behave_like "All Editions"
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist)
        add_options(var);Fi[	@PiGI"
      #  describe SmallEdition do
      #    it_should_behave_like AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      #
      # And, for those of you who prefer to use something more like Ruby, you;Fi[	@PiRI"¸      #  describe SmallEdition do
      #    include AllEditions
      #
      #    it "should do small edition stuff" do
      #      ...
      #    end
      #  end
      def function(arglist)
        Spec.deprecate("share_as", "shared_examples_for");Fi[I"# == Example;FI"#;FI"#   class Vehicle;FI"/#     state_machine :initial => :parked do;Fi[[	@&i>I"0    # *after* callback with only affect that event's transition.  Other
    # transitions will continue to run their own callbacks.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@&ipI"˝    # 
    # See StateMachine::InstanceMethods#fire_events for more information.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[	@„i˙I"1    # Rolls back changes made to the object's state via this transition.  This
    # will revert the state back to the +from+ value.
    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling;Fi[@'@¸@ˇ,@åri[[	@£ijI"v    var = { "description" => "bio", "image" => "image_url", "name" => "first_name", "location" => "location" }
    var = Hash[var.map { |arglist| [var[var], var] }]
    self.attributes.merge(var) { |arglist| var.blank? ? (var) : (var) }
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var);Fi[	@£isI"¡    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var);Fi[	@£i|I"¡    else
      super(absolutify_local_url(var))
    end
  end
  
  def function(arglist)
    return image_url if (var == "")
    if (var.nil? or var.match(/^https?:\/\//)) then
      super(var);Fi[@'@¸@ˇ,@óri[[	@Äi9I"¬  #should be in relayable (pending on fixing Message)
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	@ài,I"è  
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[	@çi1I"™  #sign comment as post owner
  def function(arglist)
    self.author.diaspora_handle
  end
  
  def function(arglist)
    self.author = Webfinger.new(var).fetch
  end
  ;Fi[I"flush_output_buffer;FI"end;FI" ;FI"def function(arglist);Fi[[	@ÿi2I"◊      self.processed_headers = true
    end
    (self.output_buffer << (var + "\r\n"))
    flush_output_buffer
  end
  
  def function(arglist)
    (self.input_buffer << var)
    if (self.consumed_ace == false) then;Fi[	@ÿi=I"¡      self.consumed_ace = true
    end
    process_compressed_data
    flush_output_buffer
  end
  
  def function(arglist)
    return if output_buffer.empty?
    if other_connection.ssled then;Fi[	@ÿiúI"    (self.zip_stream << self.unzipped_output)
    self.unzipped_output = ""
    (self.output_buffer << zip_stream.flush)
    flush_output_buffer
  end
  
  def function(arglist)
    if (var["refId"] == self.last_ref_id) and @var then
      if ($LOG_LEVEL > 1) then;Fi[I"N# * <tt>:from</tt> - One or more states being transitioned from.  If none;F@zvI"N# * <tt>:to</tt> - One or more states being transitioned to.  If none are;FI"6#   specified, then this will match any to state.;Fi[[	@Çi~I"    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
    #   conditionals defined for each one.  Default is true.;Fi[	@â iI"    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[	@â i3I"
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none
    #   are specified, then this will match any event.;Fi[I"attr_reader(:object);FI" ;FI"attr_reader(:machine);FI" ;Fi[[	@Õi	I"–  class Path < Array
    include(Assertions)
    
    attr_reader(:object)
    
    attr_reader(:machine)
    
    # The object whose state machine is being walked
    # The state machine this path is walking;Fi[	@“i
I"ô  class PathCollection < Array
    include(Assertions)
    
    attr_reader(:object)
    
    attr_reader(:machine)
    
    attr_reader(:from_name)
    ;Fi[	@„i:I"y  end
  
  class Transition
    attr_reader(:object)
    
    attr_reader(:machine)
    
    attr_reader(:from)
    ;Fi[@xv@yv@zv@¢âi[[	@Çi}I"    # Finds and builds the next transition that can be performed on the given
    # object.  If no transitions can be made, then this will return nil.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:guard</tt> - Whether to guard transitions with the if/unless;Fi[	@â iI"’    
    # Gets the list of events that can be fired on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[	@â i2I"ÿ    
    # Gets the list of transitions that can be run on the given object.
    # 
    # Valid requirement options:
    # * <tt>:from</tt> - One or more states being transitioned from.  If none
    #   are specified, then this will be the object's current state.
    # * <tt>:to</tt> - One or more states being transitioned to.  If none are
    #   specified, then this will match any to state.
    # * <tt>:on</tt> - One or more events that fire the transition.  If none;Fi[@d@tL@TaI",#         transition :parked => :idling;Fi[[	@&i@I"…    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@&irI"…    # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       ;Fi[	@„i¸I"     # 
    # == Example
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #     end;Fi[@d@tL@dvI"#     end;Fi[[	@î iI"®    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@î i)I"®    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[	@î iDI"®    # 
    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   ;Fi[@d@MvI"#;F@9vi[[	@§iI"ÿ        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@§iRI"ÿ        # 
        # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[	@§ivI"◊        # 
        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     ;Fi[@'@¸@ˇ,I"Cucumber.logger;Fi[[	@2i4I"û          end
        end
        raise(TagExcess.new(var)) if var.any?
      end
      
      def function(arglist)
        Cucumber.logger
      end
    end;Fi[	@=i°I"£        else
          log.debug("  * #{file} [NOT SUPPORTED]\n")
        end
      end
      
      def function(arglist)
        Cucumber.logger
      end
      ;Fi[	@Ei†I"º    def function(arglist)
      var = (@var.support_to_load + @var.step_defs_to_load)
      @var.load_files!(var)
    end
    
    def function(arglist)
      Cucumber.logger
    end
  end;Fi[@'@¸@ˇ,I"if @var.nil? then;Fi[[	@i8I"‰        
        def function(arglist)
          [("\"%s\"" % var)]
        end
        
        def function(arglist)
          if @var.nil? then
            File.exist?("./Gemfile") and gem_available?("bundler")
          else;Fi[	@biTI"’        else
          "#{@expected_exception} with #{@expected_message.inspect}"
        end
      end
      
      def function(arglist)
        if @var.nil? then
          " but nothing was raised"
        else;Fi[	@oi1I"¬      
      def function(arglist)
        @var.nil? ? (true) : ((@var == var.method(var).arity))
      end
      
      def function(arglist)
        if @var.nil? then
          ""
        else;Fi[@tL@dvI"#     end;FI"#   end;Fi[[	@î iI"œ    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@î i*I"œ    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[	@î iEI"œ    # == Examples
    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states;Fi[I"#       event :park do;FI",#         transition :idling => :parked;FI"#       end;FI"#     end;Fi[[	@&iFI"    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do;Fi[	@&ixI"    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #     
    #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do;Fi[	@=<i£I"¬    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end
    #     end
    #   end
    #   ;Fi[@'@¸@ˇ,I"return if (@var.! or @var);Fi[[	@Êi≠I"√      
      def function(arglist)
        @var = nil
      end
      
      def function(arglist)
        return if (@var.! or @var)
        @var = 0
        @var.print("  |".indent((@var - 2)));Fi[	@Êi≥I"„        return if (@var.! or @var)
        @var = 0
        @var.print("  |".indent((@var - 2)))
      end
      
      def function(arglist)
        return if (@var.! or @var)
        print_table_row_messages
        @var.puts;Fi[	@Êi¡I"Â      def function(arglist)
        return unless @var
        @var = (@var + 1)
      end
      
      def function(arglist)
        return if (@var.! or @var)
        var ||= (@var or :passed)
        var = @var.col_width(@var);Fi[@'@¸@ˇ,I"if File.file?(var) then;Fi[[	@«i I"          else
            ["# Couldn't get snippet for #{error_line}", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("\n")
            var = [0, (var - 3)].max;Fi[	@Ui(I"          else
            ["# Couldn't get snippet for #{error_line}", 1]
          end
        end
        
        def function(arglist)
          if File.file?(var) then
            var = File.open(var).read.split("\n")
            var = [0, (var - 3)].max;Fi[	@qi£I"˝          (@var = :custom
          self.differ_class = load_class(var, "differ", "--diff"))
        end
      end
      
      def function(arglist)
        if File.file?(var) then
          @var = [File.open(var).read.split("\n")].flatten
        else;Fi[@'@¸@ˇ,I"return if (@var or @var);Fi[[	@«i˛I",      def function(arglist)
        @var ||= SnippetExtractor.new
        "<pre class=\"ruby\"><code>#{@snippet_extractor.snippet(file_colon_line)}</code></pre>"
      end
      
      def function(arglist)
        return if (@var or @var)
        (@var << "<table>") if Ast::Table.===(var)
      end;Fi[	@«iI"˚      def function(arglist)
        return if (@var or @var)
        (@var << "<table>") if Ast::Table.===(var)
      end
      
      def function(arglist)
        return if (@var or @var)
        (@var << "</table>") if Ast::Table.===(var)
      end;Fi[	@ﬁiII"¡      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return if (@var or @var)
        var = (Time.now - @var)
        if var.failed? then;Fi[@¡K@OI"#;F@Voi[[	@&iCI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@&iuI"    #   class Vehicle
    #     state_machine :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[	@=<i†I"	    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       event :ignite do
    #         transition :parked => :idling
    #       end
    #       
    #       event :park do
    #         transition :idling => :parked
    #       end;Fi[I"#       event :disable do;F@>eI"#       end;FI"#     end;Fi[[	@&iPI"∫    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   ;Fi[	@&i}I"∫    #         transition all => :active
    #       end
    #       
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   ;Fi[	@=<iîI"À    #     end
    #     
    #     state_machine :alarm_state, :initial => :active do
    #       event :disable do
    #         transition all => :off
    #       end
    #     end
    #   end
    #   ;Fi[@'@¸@ˇ,I"@var = 0;Fi[[	@«i°I"≥          @var.text!(" ")
          @var.span(var, :class => "val")
        end
      end
      
      def function(arglist)
        @var = 0
        (@var << "<table>")
      end;Fi[	@€iI"è        @var = var if var
        @var = :any
        self
      end
      
      def function(arglist)
        @var = 0
        self
      end;Fi[	@€i8I"        else
          # do nothing
        end
      end
      
      def function(arglist)
        @var = 0
      end
    end;Fi[@z@z@z@©qi[[	@îi%I"        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[	@≤iI"        end
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[	@ i"I"W        var.errors.add(self.attribute(var), generate_message(var, var))
      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else;Fi[@z@z@©q@™qi[[	@îi&I";      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ");Fi[	@≤iI""      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          var = [];Fi[	@ i#I";      end
      
      # Describes the current validation errors on the given object.  If none
      # are specific, then the default error is interpeted as a "halt".
      def function(arglist)
        if var.errors.empty? then
          "Transition halted"
        else
          (var.errors.full_messages * ", ");Fi[@îq@üqI"end;FI"
super;Fi[[	@óihI"1          (::ActiveRecord::VERSION::MAJOR == 3) and (::ActiveRecord::VERSION::MINOR == 0)
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[	@µiPI")          defined? ::MongoMapper::Version and ::MongoMapper::Version =~ /^0\.9\./
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[	@ΩiI"R          define_helper(:instance, "            # Initializes dynamic states\n            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n            \n            # Initializes static states\n            def apply_default_attributes(*)\n              result = super\n              self.class.state_machines.initialize_states(self, :static => :force, :dynamic => false, :to => result) if new_record?\n              result\n            end\n", "(string)", (26 + 1))
        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end;Fi[@îq@ïqI"	else;FI"
super;Fi[[	@ûi<I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@∫i5I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[	@¬i9I"      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end;Fi[@üqI"end;FI"
super;FI"end;Fi[[	@óiiI"ﬂ        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@µiQI"ﬂ        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
    end;Fi[	@ΩiI"ﬁ        end
        def function(arglist)
          if (action_hook == :save) then
            owner_class.set_callback(:save, :after, "value", :prepend => (true))
          end
          super
        end
      end
      ;Fi[@ïo@ño@âqI"end;Fi[[	@ûiI"‡      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@∫iI"‡      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[	@¬iI"‡      
      protected
      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute;Fi[@âqI"end;FI" ;F@Ê[i[[	@ûiI"_      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        if owner_class.connected? and (owner_class.table_exists? and var = owner_class.columns_hash[attribute.to_s]) then;Fi[	@∫iI"      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_key and attribute_key.default_value;Fi[	@¬iI"      
      # Only runs validations on the action if using <tt>:save</tt>
      def function(arglist)
        (action == :save)
      end
      
      # Gets the db default for the machine's attribute
      def function(arglist)
        attribute_field and attribute_field.default;Fi[@'@¸@ˇ,I"(@var << "</div>");Fi[[	@«iVI"≤      def function(arglist)
        @var = []
        (@var << "<div class=\"feature\">")
      end
      
      def function(arglist)
        (@var << "</div>")
      end
      ;Fi[	@«iíI"        @var = false
        var = { Ast::Scenario => "scenario", Ast::ScenarioOutline => "scenario outline" }[var.class]
        (@var << "<div class='#{css_class}'>")
      end
      
      def function(arglist)
        (@var << "</div>")
        @var = true
      end;Fi[	@«iØI"®      
      def function(arglist)
        (@var << "<div class=\"examples\">")
      end
      
      def function(arglist)
        (@var << "</div>")
      end
      ;Fi[@”y@‘y@’y@ïqi[[	@ûi:I")        define_helper(:instance, "            def initialize(*)\n              super do |*args|\n                self.class.state_machines.initialize_states(self, :static => false)\n                yield(*args) if block_given?\n              end\n            end\n", "(string)", (468 + 1))
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@∫i3I"        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[	@¬i7I"        super
      end
      
      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super;Fi[@ïqI"	else;FI"
super;FI"end;Fi[[	@ûi=I"      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@∫i6I"      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[	@¬i:I"      # Uses around callbacks to run state events if using the :save hook
      def function(arglist)
        if (action_hook == :save) then
          owner_class.set_callback(:save, :around, self, :prepend => (true))
        else
          super
        end
      end
      ;Fi[@æy@øy@~qI"end;Fi[[	@ûiCI"$        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@∫i<I"$        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[	@¬i@I"$        end
      end
      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or;Fi[@~qI"end;FI" ;F@.[i[[	@ûiEI"K      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@∫i>I"K      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[	@¬iBI"K      
      # Runs state events around the machine's :save action
      def function(arglist)
        var.class.state_machines.transitions(var, action).perform { |arglist| yield }
      end
      
      # Creates a scope for finding records *with* a particular state or
      # states for the attribute
      def function(arglist);Fi[@MvI"#;F@9v@:vi[[	@§iI"         # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@§iSI"         # == Examples
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[	@§iwI"ˇ        # == Example
        # 
        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do;Fi[@9v@:vI"#;F@†ai[[	@§iI"0        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@§iUI"0        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[	@§iyI"0        #   class Vehicle
        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling;Fi[@:vI"#;F@†a@°ai[[	@§iI"*        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@§iVI"*        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[	@§izI"*        #     include DataMapper::Resource
        #     
        #     property :id, Serial
        #     property :state, :String
        #     
        #     state_machine :initial => :parked do
        #       event :ignite do
        #         transition :parked => :idling
        #       end;Fi[@yaI"#       ...;FI"#     end;FI"#;Fi[[	@=<iÁI"Ï    # In the following example, a custom +initialize+ method is defined:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize
    #     end;Fi[	@=<i¯I"≈    # like so:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[	@=<iI"Ë    # to initialize the state machine attributes:
    # 
    #   class Vehicle
    #     state_machine :state, :initial => :parked do
    #       ...
    #     end
    #     
    #     def initialize(attributes = {})
    #       ...;Fi[@dvI"#     end;FI"#   end;FI"#;Fi[[	@î iI"    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">;Fi[	@î i+I"∆    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[	@î iFI"∆    # 
    #   class Vehicle
    #     state_machine :initial => :parked do
    #       other_states :idling
    #     end
    #   end
    #   
    #   states = Vehicle.state_machine.states
    #   ;Fi[@ºf@
v@v@7qi[[	@iI"      
      # A collection of tweets that mention a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[	@iI"&    class Reply < Twitter::Action::Tweet
      # A collection of tweets that reply to a user
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[	@iI"    class Retweet < Twitter::Action::Tweet
      # A collection of retweets
      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end;Fi[@'@¸@ˇ,I"broadcast(var);Fi[[	@ûiI"≠      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      ;Fi[	@ûi$I"≠      
      def function(arglist)
        broadcast(var) { |arglist| var.accept(self) }
      end
      
      def function(arglist)
        broadcast(var)
      end
      ;Fi[	@ûiiI"ì      
      def function(arglist)
        broadcast(var, var)
      end
      
      def function(arglist)
        broadcast(var)
      end
      ;Fi[@'@¸@ˇ,I"@var.language;Fi[[	@Éi>I"°      
      def function(arglist)
        @var.visit_scenario_name(var, var)
      end
      
      def function(arglist)
        @var.language
      end
      ;Fi[	@Éi¶I"ƒ        
        def function(arglist)
          "| #{@cells.collect { |c| c.value }.join(" | ")} |"
        end
        
        def function(arglist)
          @var.language
        end
        ;Fi[	@êiVI"≥      
      def function(arglist)
        @var ||= @var.file_colon_line(@var) unless @var.nil?
      end
      
      def function(arglist)
        @var.language
      end
      ;Fi[I" include(Twitter::Creatable);FI" ;FI".attr_reader(:max_position, :min_position);FI" ;Fi[[	@i
I"Èmodule Twitter
  module Action
    class ListMemberAdded < Twitter::Base
      include(Twitter::Creatable)
      
      attr_reader(:max_position, :min_position)
      
      # A collection of users who added a user to a list
      #;Fi[	@i
I"€module Twitter
  module Action
    class Mention < Twitter::Base
      include(Twitter::Creatable)
      
      attr_reader(:max_position, :min_position)
      
      # A collection of users who mentioned a user
      #;Fi[	@ägi
I"·module Twitter
  module Action
    class Tweet < Twitter::Base
      include(Twitter::Creatable)
      
      attr_reader(:max_position, :min_position)
      
      # @return [Array<Twitter::User>]
      def function(arglist);Fi[@'@¸@ˇ,@¯ri[[	@uiAI"Æ      
      def function(arglist)
        source_tags.map { |arglist| var.name }
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      ;Fi[	@ÉiI"…          var.configuration.expand? ? (var.accept(var)) : (var.visit_table_row(var))
        end
        nil
      end
      
      def function(arglist)
        @var.accept_hook?(var)
      end
      ;Fi[	@ÉiÅI"ò              end
            end
          end
        end
        
        def function(arglist)
          @var.accept_hook?(var)
        end
        ;Fi[@'@¸@ˇ,I"var = self;Fi[[	@oiI"⁄      def function(arglist)
        return if Cucumber.wants_to_quit
        var.visit_doc_string(self)
      end
      
      def function(arglist)
        var = self
        var.each do |arglist|
          var ||= "";Fi[	@0iHI"ì  
  def function(arglist)
    root.try(:nsfw)
  end
  
  def function(arglist)
    var = self
    while var.is_a?(Reshare) do
      var = var.root;Fi[	@ci*I";        var = Nokogiri::XML::ParseOptions.new(var) if Fixnum.===(var)
        yield(var) if block_given?
        process_xincludes(var.to_i)
      end
      
      def function(arglist)
        var = self
        document.canonicalize(var, var, var) do |arglist|
          var = var.is_a?(XML::Node) ? (var) : (var);Fi[@'@¸@ˇ,I"return false;Fi[[	@fi$I"√      
      def function(arglist)
        # do nothing
      end
      
      def function(arglist)
        return false
        var = var.send(:import)
        var.!=(Compass.deprojectize(var));Fi[	@€i#I"è        @var.register(self)
        @var = true
        self
      end
      
      def function(arglist)
        return false
      end
      ;Fi[	@C9i>I"  
  def function(arglist)
    self.guzzoni_conn.inject_object_to_output_stream(generate_siri_utterance(self.guzzoni_conn.last_ref_id, var, (var[:spoken] or var), (var[:prompt_for_response] == true)))
  end
  
  def function(arglist)
    return false
  end
  ;Fi[@6q@7qI"end;FI"end;Fi[[	@i I"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user;Fi[	@iI"	      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets;Fi[	@iI"      #
      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user;Fi[@7qI"end;FI"end;FI" ;Fi[[	@i!I"      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the mentioned user
      #;Fi[	@iI"	      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection that contains the replied-to tweets
      #;Fi[	@iI"      # @return [Array<Twitter::Tweet>]
      def function(arglist)
        @var = Array(@var[:target_objects]).map do |arglist|
          Twitter::Tweet.fetch_or_new(var)
        end
      end
      
      # A collection containing the retweeted user
      #;Fi[@'@¸@ˇ,I"var = var.value;Fi[[	@Øi4I"        var.declare(:font_url, [:path])
        var.declare(:font_url, [:path, :only_path])
      end
    end
    
    def function(arglist)
      var = var.value
      return Sass::Script::String.new("url(#{path})") if absolute_path?(var)
      var = if relative? then;Fi[	@ØiNI"'        var.declare(:image_url, [:path, :only_path])
        var.declare(:image_url, [:path, :only_path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_images_path)}\/(.*)/ then
        var = $1;Fi[	@Øi{I"-        var.declare(:generated_image_url, [:path])
        var.declare(:generated_image_url, [:path, :cache_buster])
      end
    end
    
    def function(arglist)
      var = var.value
      if var =~ /^#{Regexp.escape(Compass.configuration.http_generated_images_path)}\/(.*)/ then
        var = $1;Fi[@'@¸@ˇ,I"	self;Fi[[	@diBI"o      @var = nil
      @var = nil
      var
    end
    
    def function(arglist)
      self
    end
    ;Fi[	@oiI"å      def function(arglist)
        @var = var
        super(var)
      end
      
      def function(arglist)
        self
      end
      ;Fi[	@oi%I"Ü      def function(arglist)
        @var = var
        self
      end
      
      def function(arglist)
        self
      end
      ;Fi[@'@¸@ˇ,I"(@var or @var);Fi[[	@Ji≈I"ò          var = uri
        end
        Digest::SHA1.hexdigest(var)
      end
      
      def function(arglist)
        (@var or @var)
      end
      ;Fi[	@q1iI"”      @var = var
      @var = var
      @var = I18n.t(:"unauthorized.default", :default => "You are not authorized to access this page.")
    end
    
    def function(arglist)
      (@var or @var)
    end
  end;Fi[	@ÉiÖI"®        
        def function(arglist)
          @var.accept_hook?(var)
        end
        
        def function(arglist)
          (@var or @var)
        end
        ;Fi[@'@¸@ˇ,I"
yield;Fi[[	@3iWI"u    
    def function(arglist)
      Gem.refresh
    end
    
    def function(arglist)
      yield
    end
    ;Fi[	@íiXI"w    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      yield
    end
  end;Fi[	@iI"ï        @var = StringScanner.new(var)
        @var = 1
        @var = nil
      end
      
      def function(arglist)
        yield
      end
      ;Fi[@ÿK@ŸK@⁄KI"%# @return [Array<Twitter::User>];Fi[[	@Ai?I"›      # Returns users that match the given query
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>]
      # @param query [String] The search query to run against people search.
      # @param options [Hash] A customizable set of options.;Fi[	@AiPI"ﬁ      # Returns an array of users that the specified user can contribute to
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/contributees
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>]
      # @overload contributees(options={})
      #   @param options [Hash] A customizable set of options.;Fi[	@AigI"‡      # Returns an array of users who can contribute to the specified account
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/users/contributors
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::User>]
      # @overload contributors(options={})
      #   @param options [Hash] A customizable set of options.;Fi[@ŸK@⁄K@_LI"'# @overload friend_ids(options={});Fi[[	@DiI"©      
      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@DiI"≠      #
      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[	@Di I"Ø      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #;Fi[@'@¸@ˇ,I"unless @var then;Fi[[	@LiII"ﬂ    
    def function(arglist)
      # do nothing
    end
    
    def function(arglist)
      unless @var then
        raise("LazySpecification has not been materialized yet (calling :#{method} #{args.inspect})")
      end;Fi[	@ÚiI"ì        
        def function(arglist)
          "h1. #{@page.pretty_title}"
        end
        
        def function(arglist)
          unless @var then
            content_for(:header_tags) do |arglist|
              ((javascript_include_tag("jstoolbar/jstoolbar-textile.min") + javascript_include_tag("jstoolbar/lang/jstoolbar-#{current_language.to_s.downcase}")) + stylesheet_link_tag("jstoolbar"));Fi[	@9iZI"          @var.puts("      </div>")
          @var.puts("    </dd>")
          @var.flush
        end
        
        def function(arglist)
          unless @var then
            @var.puts("    <script type=\"text/javascript\">makeYellow('rspec-header');</script>")
          end;Fi[@ŸK@⁄K@⁄RI"Í# @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.;Fi[[	@$i I"5      # @see https://dev.twitter.com/docs/api/1.1/get/geo/reverse_geocode
      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).;Fi[	@$i3I"Ì      #
      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.;Fi[	@$iMI"≈      # @see https://dev.twitter.com/docs/api/1.1/get/geo/similar_places
      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.;Fi[@ŸK@⁄KI"6# @return [Twitter::User] The authenticated user.;FI";# @param options [Hash] A customizable set of options.;Fi[[	@Ai.I"D      #
      # @see https://dev.twitter.com/docs/api/1.1/get/account/verify_credentials
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [Boolean, String, Integer] :skip_status Do not include user's Tweets when set to true, 't' or 1.
      # @example Return the requesting user if authentication was successful;Fi[	@AiOI"ß      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile
      # @note Only the options specified will be updated.
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :name Full name associated with the profile. Maximum of 20 characters.
      # @option options [String] :url URL associated with the profile. Will be prepended with "http://" if not present. Maximum of 100 characters.;Fi[	@AiqI"      #
      # @see https://dev.twitter.com/docs/api/1.1/post/account/update_profile_colors
      # @rate_limited No
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::User] The authenticated user.
      # @param options [Hash] A customizable set of options.
      # @option options [String] :profile_background_color Profile background color.
      # @option options [String] :profile_text_color Profile text color.;Fi[@⁄K@_L@_ãI"[#   Returns an array of numeric IDs for every user the authenticated user is following;Fi[[	@DiI"·      # @see https://dev.twitter.com/docs/api/1.1/get/friends/ids
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@DiI"‰      # @see https://dev.twitter.com/docs/api/1.1/get/followers/list
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[	@Di!I"Ê      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.;Fi[@'@¸@ˇ,I"Aif ((platform == Gem::Platform::RUBY) or platform.nil?) then;Fi[[	@LiI"∆      @var = var
      @var = var
      @var = nil
    end
    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "#{@name}-#{@version}"
      else;Fi[	@Li&I"    
    def function(arglist)
      (@var == var.name) and var.requirement.satisfied_by?(Gem::Version.new(@var))
    end
    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        var = "    #{name} (#{version})\n"
      else;Fi[	@"iI"    # specs don't bother to include the arch in the platform string
    def function(arglist)
      @var = _remote_specification.platform
    end
    
    def function(arglist)
      if ((platform == Gem::Platform::RUBY) or platform.nil?) then
        "#{@name}-#{@version}"
      else;Fi[@⁄K@⁄R@qãI""# @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.;Fi[[	@$i!I"¨      # @note This request is an informative call and will deliver generalized results about geography.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :accuracy ('0m') A hint on the "region" in which to search. If a number, then this is a radius in meters, but it can also take a string that is suffixed with ft to specify feet. If coming from a device, in practice, this value is whatever accuracy the device has measuring its location (whether it be coming from a GPS, WiFi triangulation, etc.).
      # @option options [String] :granularity ('neighborhood') This is the minimal granularity of place types to return and must be one of: 'poi', 'neighborhood', 'city', 'admin' or 'country'.;Fi[	@$i4I"e      # @see https://dev.twitter.com/docs/api/1.1/get/geo/search
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :query Free-form text to match against while executing a geo-based query, best suited for finding nearby locations by name.
      # @option options [String] :ip An IP address. Used when attempting to fix geolocation based off of the user's IP address.;Fi[	@$iNI"J      # @note Conceptually, you would use this method to get a list of known places to choose from first. Then, if the desired place doesn't exist, make a request to {Twitter::API::PlacesAndGeo#place} to create a new one. The token contained in the response is the token necessary to create a new place.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @param options [Hash] A customizable set of options.
      # @option options [Float] :lat The latitude to search around. This option will be ignored unless it is inside the range -90.0 to +90.0 (North is positive) inclusive. It will also be ignored if there isn't a corresponding :long option.
      # @option options [Float] :long The longitude to search around. The valid range for longitude is -180.0 to +180.0 (East is positive) inclusive. This option will be ignored if outside that range, if it is not a number, if geo_enabled is disabled, or if there not a corresponding :lat option.
      # @option options [String] :name The name a place is known as.
      # @option options [String] :contained_within This is the place_id which you would like to restrict the search results to. Setting this value means only places within the given place_id will be found.;Fi[@'@¸@ˇ,I"@var.any? do |arglist|;Fi[[	@ iII"Ú          var.class.===(var.class) and (var.uri == var.uri)
        end)
      end
    end
    
    def function(arglist)
      @var.any? do |arglist|
        next unless var.instance_of?(Source::Path)
        specs_changed?(var) do |arglist|;Fi[	@ iòI"‚    
    def function(arglist)
      var and (var.source == var.source)
    end
    
    def function(arglist)
      @var.any? do |arglist|
        var.satisfies?(var) and (var.source.! or (var.source == var.source))
      end;Fi[	@“ieI"P    
    def function(arglist)
      (@var.include?(:all) or (@var.include?(var) or matches_subject_class?(var)))
    end
    
    def function(arglist)
      @var.any? do |arglist|
        var.kind_of?(Module) and (var.kind_of?(var) or ((var.class.to_s == var.to_s) or (var.kind_of?(Module) and var.ancestors.include?(var))))
      end;Fi[@'@¸@ˇ,I"@var.each do |arglist|;Fi[[	@ iGI"      @var = converge_dependencies
      @var = converge_locals
      fixup_dependency_types!
    end
    
    def function(arglist)
      @var.each do |arglist|
        if var = @var.find { |arglist| (var.name == var.name) } then
          var.instance_variable_set(:@type, var.type);Fi[	@ixI"[          var.edge[:fontname] = var.node[:fontname] = "Arial, Helvetica, SansSerif"
          var.edge[:fontsize] = 12
        end
      end
      
      def function(arglist)
        @var.each do |arglist|
          g.add_nodes(var, { :style => "filled", :fillcolor => "#B9B9D5", :shape => "box3d", :fontsize => 16 }.merge(@var[var]))
        end;Fi[	@˝ieI"-        @var.values.to_a.flatten.map do |arglist|
          (var[:keyword].unpack("U*").length + var[:step_match].format_args.unpack("U*").length)
        end.max
      end
      
      def function(arglist)
        @var.each do |arglist|
          if var.empty? then
            var.status = :skipped;Fi[@'@¸@ˇ,I"$log(var, var, var) do |arglist|;Fi[[	@kicI""        
        def function(arglist)
          Arel::Nodes::BindParam.new("$#{(index + 1)}")
        end
        
        def function(arglist)
          log(var, var, var) do |arglist|
            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var))
            var = {};Fi[	@kiuI"
            var.clear
            return var
          end
        end
        
        def function(arglist)
          log(var, var, var) do |arglist|
            var = var.empty? ? (exec_no_cache(var, var)) : (exec_cache(var, var))
            var = var.cmd_tuples;Fi[	@çi˚I"        def function(arglist)
          (var.rows.map { |arglist| var.join("|") }.join("\n") + "\n")
        end
      end
      
      def function(arglist)
        log(var, var, var) do |arglist|
          if var.empty? then
            var = @var.prepare(var);Fi[@yQ@5]@zlI"´# @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.;Fi[[	@5iJI"ı      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by @sferik
      #   Twitter.retweeted_by_user('sferik');Fi[	@5iaI"˘      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @example Return the 20 most recent retweets posted by the authenticating user
      #   Twitter.retweeted_by_me;Fi[	@5iàI"m      # @param options [Hash] A customizable set of options.
      # @option options [Integer] :since_id Returns results with an ID greater than (that is, more recent than) the specified ID.
      # @option options [Integer] :max_id Returns results with an ID less than (that is, older than) or equal to the specified ID.
      # @option options [Integer] :count Specifies the number of records to retrieve. Must be less than or equal to 200.
      # @option options [Boolean, String, Integer] :trim_user Each tweet returned in a timeline will include a user object with only the author's numerical ID when set to true, 't' or 1.
      # @option options [Boolean, String, Integer] :exclude_replies This parameter will prevent replies from appearing in the returned timeline. Using exclude_replies with the count parameter will mean you will receive up-to count tweets - this is because the count parameter retrieves that many tweets before filtering out retweets and replies.
      # @option options [Boolean, String, Integer] :contributor_details Specifies that the contributors element should be enhanced to include the screen_name of the contributor.
      # @option options [Boolean, String, Integer] :include_entities The tweet entities node will be disincluded when set to false.
      # @example Return the 20 most recent retweets posted by users followed by the authenticating user;Fi[I"=#   @param options [Hash] A customizable set of options.;F@V@V@#ii[[	@ÍiUI"›      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)));Fi[	@ÍiwI"›      #     Twitter.favorite(25938088801)
      # @overload favorite(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          begin
            object_from_response(Twitter::Tweet, :post, "/1.1/favorites/create.json", var.options.merge(:id => (var)));Fi[	@'iZI"Í      #     Twitter.saved_search_destroy(16129012)
      # @overload saved_search_destroy(*ids, options)
      #   @param ids [Array<Integer>, Set<Integer>] An array of Tweet IDs.
      #   @param options [Hash] A customizable set of options.
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::SavedSearch, :post, "/1.1/saved_searches/destroy/#{id}.json", var.options)
        end;Fi[@'@¸@ˇ,@˜i[[	@Ii(I"‚      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[	@kiªI"ı        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("RELEASE SAVEPOINT #{current_savepoint_name}")
        end
      end;Fi[	@çi:I"‚      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("RELEASE SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[@'@¸@ˇ,@´si[[	@Ii$I"⁄      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[	@ki∑I"Ï        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        
        def function(arglist)
          execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
        end
        ;Fi[	@çi6I"⁄      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      
      def function(arglist)
        execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[@V@ÇT@ÉT@ÑTi[[	@!iII"ÿ      #     Twitter.list_timeline(7505382, 'presidents')
      #     Twitter.list_timeline(7505382, 8863586)
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::Tweet, :get, "/1.1/lists/statuses.json", var.options);Fi[	@!iI"î      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::List, var, var, var.options);Fi[	@!iI"o      end
      
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then
          merge_owner!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(:users, Twitter::User, var, var, var.options, var);Fi[@V@$q@%qI"end;Fi[[	@Ai±I"∫      #     Twitter.profile_banner('sferik')
      #     Twitter.profile_banner(7505382)  # Same as above
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        object_from_response(Twitter::ProfileBanner, :get, "/1.1/users/profile_banner.json", var.options)
      end;Fi[	@DiI"m      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        objects_from_response(Twitter::User, var, var, var.options)
      end;Fi[	@Di`I"o      # @param method_name [Symbol]
      # @return [Twitter::Cursor]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name))
        end
        cursor_from_response(var, var, var, var, var.options, var)
      end;Fi[@'@¸@ˇ,@∂si[[	@Ii I"¶        rescue
          # do nothing
        end
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[	@ki≥I"{          var = "#outside_transaction? is deprecated. This method was only really used internally, but you can use #transaction_open? instead."
          ActiveSupport::Deprecation.warn(var)
          (@var.transaction_status == PGconn::PQTRANS_IDLE)
        end
        
        def function(arglist)
          execute("SAVEPOINT #{current_savepoint_name}")
        end
        ;Fi[	@çi2I"π      
      def function(arglist)
        exec_query(var, var).rows
      end
      
      def function(arglist)
        execute("SAVEPOINT #{current_savepoint_name}")
      end
      ;Fi[@'@¸@ˇ,I"if Hash.===(var) then;Fi[[	@>iµI"F        return unless var
        remove_index(var, :name => (var))
        add_index(var, var.columns, :name => (var), :unique => (var.unique))
      end
      
      def function(arglist)
        if Hash.===(var) then
          if var[:column] then
            "index_#{table_name}_on_#{(Array(options[:column]) * "_and_")}";Fi[	@biI"Á          else
            super
          end
        end
        
        def function(arglist)
          if Hash.===(var) then
            var.map { |arglist| "#{escape_hstore(k)}=>#{escape_hstore(v)}" }.join(",")
          else;Fi[	@ﬁiI"      
      def function(arglist)
        __mock_proxy.add_negative_message_expectation(caller(1)[0], var.to_sym, &var)
      end
      
      def function(arglist)
        if Hash.===(var) then
          var.each { |arglist| stub!(var).and_return(var) }
        else;Fi[@'@¸@ˇ,@PÄi[[	@‘iI"Ú        def function(arglist)
          var = super
          klass.connection.select_all(var.arel, "SQL", var.bind_values)
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        ;Fi[	@ŸiI"‚      class HasMany < CollectionAssociation
        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
      end;Fi[	@„iI"ﬁ      class HasOne < SingularAssociation
        def function(arglist)
          reflection.foreign_key
        end
        
        def function(arglist)
          reflection.active_record_primary_key
        end
        ;Fi[@_L@_ã@ÑãI"#;Fi[[	@DiI"”      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@DiI"”      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Di"I"”      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@_ã@ÑãI"#;FI"=#   @param options [Hash] A customizable set of options.;Fi[[	@DiI"˘      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs;Fi[	@DiI";      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@Di#I";      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@ÑãI"#;F@åI"-#   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[[	@DiI"Í      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids;Fi[	@DiI"ó      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[	@Di$I"ó      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={})
      #   Returns an array of numeric IDs for every user the authenticated user is following
      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.;Fi[I">#   @example Return the authenticated user's friends' IDs;FI"#     Twitter.friend_ids;FI"-# @overload friend_ids(user, options={});FI"W#   Returns an array of numeric IDs for every user the specified user is following;Fi[[	@DiI"À      #
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@DiI"ê      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@Di*I"ê      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[@$å@%å@&åI"#;Fi[[	@DiI"      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@DiI"õ      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[	@Di+I"õ      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.
      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.;Fi[@%å@&åI"#;FI"`#   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[[	@DiI"ó      #   @option options [Integer] :cursor (-1) Breaks the results into pages. This is recommended for users who are following many users. Provide a value of -1 to begin paging. Provide values as returned in the response body's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@DiI"Ì      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[	@Di,I"Ì      #   @option options [Boolean, String, Integer] :include_user_entities The user entities node will be disincluded when set to false.
      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.;Fi[@&åI"#;F@9åI"=#   @param options [Hash] A customizable set of options.;Fi[[	@DiI"î      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @example Return @sferik's friends' IDs;Fi[	@DiI"Â      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[	@Di-I"Â      #   @example Return the authenticated user's friends' IDs
      #     Twitter.friend_ids
      # @overload friend_ids(user, options={})
      #   Returns an array of numeric IDs for every user the specified user is following
      #
      #   @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.
      #   @param options [Hash] A customizable set of options.
      #   @option options [Integer] :cursor (-1) Breaks the results into pages. Provide values as returned in the response objects's next_cursor and previous_cursor attributes to page back and forth in the list.
      #   @option options [Boolean, String, Integer] :skip_status Do not include contributee's Tweets when set to true, 't' or 1.;Fi[@©u@™u@´uI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	@DiœI"Û      
      # Returns detailed information about the relationship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Relationship]
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;Fi[	@DiÌI"      
      # Test for the existence of friendship between two users
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Boolean] true if user_a follows user_b, otherwise false.
      # @param source [Integer, String, Twitter::User] The Twitter user ID, screen name, or object of the source user.;Fi[	@DiI"‹      
      # Returns a cursored collection of user objects for every user the specified user is following (otherwise known as their "friends").
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/friendships/show
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Twitter::Cursor]
      # @overload friend_ids(options={});Fi[@'@¸@†>@¡Äi[[	@G	iI"–      # @since 3.0.0
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #;Fi[	@L	i•I"˚      def function(arglist)
        var = var.fields[var.to_s]
        var ? (var.mongoize(var)) : (var)
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #;Fi[	@Q	i*I"–      # @since 2.2.1
      def function(arglist)
        true
      end
      
      module ClassMethods
        # Turn the object from the ruby type we deal with to a Mongo friendly
        # type.
        #;Fi[@ﬂb@‡b@·bI"%# @return [Array<Twitter::User>];Fi[[	@!iI"Ì      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[	@DiI"Ì      
      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[	@DiI"Ó        end
      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var);Fi[@‡b@·b@]åI"def function(arglist);Fi[[	@!iI"      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop);Fi[	@DiI"      private
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|;Fi[	@DiI"+      end
      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then;Fi[@·b@]å@fåI"+var = Twitter::API::Arguments.new(var);Fi[[	@!iI"R      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        merge_list!(var.options, var.pop)
        unless (var.options[:owner_id] or var.options[:owner_screen_name]) then;Fi[	@DiI"\      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        var.flatten.threaded_map do |arglist|
          object_from_response(Twitter::User, var, var, merge_user(var.options, var));Fi[	@DiI"^      
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array<Twitter::User>]
      def function(arglist)
        var = Twitter::API::Arguments.new(var)
        unless (var.options[:user_id] or var.options[:screen_name]) then
          merge_user!(var.options, (var.pop or screen_name));Fi[@ûu@üu@†uI",# @authentication Requires user context;Fi[[	@5i(I"π      
      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@5i@I"ª      
      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[	@5iXI"¿      
      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>];Fi[@üu@†u@xåI"g# @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.;Fi[[	@5i)I"‰      # Returns the 20 most recent Tweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @overload user_timeline(user, options={});Fi[	@5iAI"      # Returns the 20 most recent retweets posted by the specified user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param user [Integer, String, Twitter::User] A Twitter user ID, screen name, or object.;Fi[	@5iYI"ˆ      # Returns the 20 most recent retweets posted by the authenticating user
      #
      # @see https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
      # @note This method can only return up to 3,200 Tweets.
      # @rate_limited Yes
      # @authentication Requires user context
      # @raise [Twitter::Error::Unauthorized] Error raised when supplied user credentials are not valid.
      # @return [Array<Twitter::Tweet>]
      # @param options [Hash] A customizable set of options.;Fi[@'@¸@†>I"J# Attempt to find a user by its email. If a record is found, send new;Fi[[	@äi∫I"~      
      def function(arglist)
        self.class.reconfirmable and @var
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new
        # confirmation instructions to it. If not, try searching for a user by unconfirmed_email
        # field. If no user is found, returns a new user with an email not found error.;Fi[	@íiI":          self.errors.add(:email, :not_locked)
          false
        end
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new
        # unlock instructions to it. If not user is found, returns a new user
        # with an email not found error.;Fi[	@òiSI")      
      def function(arglist)
        # do nothing
      end
      
      module ClassMethods
        # Attempt to find a user by its email. If a record is found, send new
        # password instructions to it. If user is not found, returns a new user
        # with an email not found error.;Fi[@“b@”b@‘bI"# @param args [Array];Fi[[	@Di&I"        objects_from_response(Twitter::User, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array]
      def function(arglist);Fi[	@DiBI"ı        var.map { |arglist| var.fetch_or_new(var) }
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @return [Array]
      def function(arglist);Fi[	@DiYI"˚      end
      
      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param args [Array]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor];Fi[@“b@”b@‘bI"# @param options [Hash];Fi[[	@Di1I"˝        objects_from_response(var, var, var, var.options)
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Array]
      def function(arglist);Fi[	@DiNI"–        end
      end
      
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @return [Object]
      def function(arglist);Fi[	@DihI"˝      end
      
      # @param collection_name [Symbol]
      # @param klass [Class]
      # @param request_method [Symbol]
      # @param path [String]
      # @param options [Hash]
      # @param method_name [Symbol]
      # @return [Twitter::Cursor];Fi[I"&# Returns an array of photo sizes;FI"#;FI"%# @return [Array<Twitter::Size>];FI"def function(arglist);Fi[[	@Li
I"§  class Configuration < Twitter::Base
    attr_reader(:characters_reserved_per_media, :max_media_per_upload, :non_username_paths, :photo_size_limit, :short_url_length, :short_url_length_https)
    
    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var);Fi[	@aiI"l    class Photo < Twitter::Identity
      attr_reader(:display_url, :expanded_url, :indices, :media_url, :media_url_https, :url)
      
      # Returns an array of photo sizes
      #
      # @return [Array<Twitter::Size>]
      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var);Fi[	@fiI"%require("twitter/base")
module Twitter
  class ProfileBanner < Twitter::Base
    # Returns an array of photo sizes
    #
    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var);Fi[I"/var[var] = Twitter::Size.fetch_or_new(var);FI"var;FI"end;FI"end;Fi[[	@LiI"⁄    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:photo_sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi[	@aiI"Ê      # @return [Array<Twitter::Size>]
      def function(arglist)
        @var ||= Array(@var[:sizes]).inject({}) do |arglist|
          var[var] = Twitter::Size.fetch_or_new(var)
          var
        end
      end
    end
  end;Fi[	@fiI"‘    # @return [Array<Twitter::Size>]
    def function(arglist)
      @var ||= Array(@var[:sizes]).inject({}) do |arglist|
        var[var] = Twitter::Size.fetch_or_new(var)
        var
      end
    end
  end
end;Fi
